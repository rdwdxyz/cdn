<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d666ffc80378fcf880f89f43cb231fbdffe42b6e6d167b4b77c08cb7055202bee33a3414fe7f447c83b8c59c949819f60d344ff42c6df4fde82221fcfdad11260062f30f001a2012dcd31a16053cfa5e9d5823ed67832127db11bccadb3524f447eb854e53dd02d98ae1c1d0761c32839f4e07f7f1cfa3941493a0ef3a8da5a32c0f0bf12aa96c489503c22545e14addb27dae5f5701ed01fe3adfcee31bf1f198c58c1def75fd06f145d49d10d5f1571e7bb1e9be4229d8264579f8d764cedfb06e8ff1f3b4d7412e9b2012cbecd21a978b226cf423bc8985e9753aa8ab96f91893ea1bd3286a59cc5a42954fc69cd8e211629e7c2d598941f2e622bb7a82e7c155154073bd41cc05eb6a7578bf111397ddb332e015651e50b3cccf0f72e39172241d8d14ae1dbda1c7ceb6325eb2910d6256e30bf0e7246d21e6f52b2ac707c79d9b282b09a6d0f809a0526d482e426d367fd36171fb4a97eeaa14088b6c310d8b0172317f7914e1ad32d7511d68b0a4db960044aa43ed0a6a0d0e7871b9da5c2ad835be218c32f8ced2259d8ddffbf3896e992ae3f714da67974f103f6555e12b053dfd291056e49b38c9ac186ee7d9b24f510c9cc41df3134c8951cdf26c5263ba71d95802bab9e870daf48caadf5658dd7465de37e8f3a55132d66fa6ad95b368fd065493e40f15239c7044e48dfd5e2c27f2c1bf613a73472182e95ad720d5b58bc9b573ae0c4c2795b702ae148ff7acaf1a657e85fed8384ac9ba34e5163cbecb2029e46ec911386a781be372c7e398f0a8003c8ed8f5367faa285f363144c6cef1be1299f51f37a0194aa61a89ffc574b96f7decd1f3ee900433b4b5199fde07dce7d32fc34d518d493d17fbba66c0ee2aa52f3223dabaac429abd9c34cf5d63887011398621e8808c6680e731042fe0558a8b06d140979b82b27b1f6b2281756dd7bd579eb8d42c2fb5736cf28c6d41c356e54b7534fde9bcd85b99702087b5292068de36f4dfdeadce1ba4626f67121053f8778770b8ead294c9af0794987eaf26b6474ef7348713f4d58bbf5ac38f03db235bb03ba2a3c9526c534b3191e6de7d07c7a58eb771c3f5fe05660a430c209b3279c9a257bf3efb4c329369abb55828648709151faf89d356e5fb964fee0ed136d8fe590e831554fe55aea43027c2a22b4f1ce3bcd6f7f3ddfbb437488626b649c9605cb7e0f3949ef102e6d8a218ec5f828f348933a72d4c6384126f64c21fede071e78f946c28375f67b13dccb063e7ee9a4add741efb9d4c897360c0f62474f0c1b5347811948f963de6ef9bf265d646a4907f7492a4f32be1bfdb3e4505b3fa2e48365c211725f2341c495d1f129526391fa579704220b5a16cb5fdbba61213b6df8eed862d12dd569722d662b88e4a7bd4bb1feb24bd8b0286d688fdb5c81922e18a1b0f609be3616996f9489849bea6e771a51cff6ae21293c93c6a26c1f2d93ec51d6404196729b5d4ed547a79a6a4474de7a996821c490033fc8ed2af89d126a8ac82ccd9c002a568d00899c332da59281e2765c196c8af2222df4caec5c4daeba65bd123ff4bb5204acca0ced848ddff17ac60b0b61acf133a9d38a03adde6cffd63628c54a7003efb2096e08c11c1a488f5b71e95ce7f3dca039021856494b970aa7839d34ace88f80a1d31fc49805f94d914cf9ab40f2746dc57c3bae89ddbf296e420c2f4bbf01119f2246c04492256800b0d58e29b141fd934895dc81ab0407d62acba105bc28b678eaebfe87148f31ca9e61627ffc43ab54fb3d160a48db2c05c85b8d3639d7287b9ada588a74d31753301dca38ab9aeeb5b8ec6f3ab7d1b583e3e1dcb869bf1ad33cbe08d6ad01411558927b6028c9ad53e39826450ab4af4be84b60e0a7d78426da716d803185d3dce7b59dd294131f61e782f90d3d46e63ec0c2328c459ff7762a519ddeae21e29508e8f61f389b65015446be4fc46f513b4f830c8f4e7f153f3d3bceb191c3a8895952bcb1f3f580e172bdef2ef765276dbc0e9be5eb8dcf98aca5b3570f541071911b7a97313bc4a2226e12bb7ccf35e3f24bcaf520b0033cfed4826809da6242573dccb346c19bddf5306d9591691fd5a091b5f01aafe9e7592202850536908f4e75f4ebf7204f3cbf1471c81c9754a91e138e5540474a2eb44fed2226e4494af7dfb5c2cb0c6276d4a53218f8f82c2c3f613fbd032ec7c158efba1b7647178f3bcb9e044bb4e906b4c10cc603d7351dd79417be68eded1d39ac5ef201d02fc438e58cb7e7172a3a47d6671e25f075bc5d379cbcfd699589a3de6b616ce510fab4c4d3484f6ccc30790771d0d4b409583207942a51b93f931545e5f6d462f0f9a9287795096148e9818008322799883c9030510fd0eaca0fab765773557a3c98d3bd1cb12ef28774768089ff140c1ee1b8f0d6883c365360b8ab3fc717b0de401ff628f1ecffe05a15601862c8196b176bd78b05de34787d3e43d74d0f6d57b29f242454a614ac5f879d3b70d215e672293c28dc22f88dfc1a09f3507604127965532526d14f3a0b8f234a66f5cd546406a2ec250030189e5b69c95f18192889e61ada42078e4efe1095eb46546246e26fbdb5ea543957304258194510fd7954af32edbc7791ad8dd7962c8b64d20941dd95f1208b80bc022adc9575900ae87be891da0c842f9a7e1a7ccec0271a474156b4d11ee6ec97ed0c1567bf1d37a5c8d64e8e6131bed35ddd22586e3e998e42f4796eaed9193353d43dab212e9f4bbf32cfd8830f0c9efc41ea93cbad34898d44c75cf685809b2ddccfb923c9552f5d6d7f55b567ed680205973b6cd153cdc4a497df5dd741c488542127a7ffb89253a37341480a65da58afe76edbe9304c41ff3024945ef4520da858bccd01bccc910646b59a23a23c7c028694566d5bfc94f724194e93994056a6b6272d914b8940c325f6a2838f4745bb5a9c8cb17b305b5e5875c9dc2ffae0f3978f3bb23455bd27625f8fa62dfbf99a741eb092e39da46bdd7b1e34a77bcc83f52bf298279dc8882af6a8b71b6faf6cb477ff4056eca56e2e6c33d5e09ac25f9190cd66b42768c3be6b3f388e6dc961099856b8d0e61896ebc4bc1cff02b6e7c4eab4eaa5d77f198287fa7bf0b6d0c7d1a9f3bc89704915679e67da73d2fc3042cc8f97e8e034c76b5042714c314b3b3a85638545f4ae170900de38ea3c7ed1064cd91da54652255f913aead58c1f2ff9ddde2c8a351062f790818ffe99acc67c313f97d24595517de499ed3bf9fb82f71b6849bd3f2cb420c091f0216de523a0e48ed01f2e46795477b2e8d7df3a8b525922606cb8f9b546f61bb7b20181bdd3f8a9dd97e2d44d4490efd1fb78ef7416b9b67bfcbc34b80c03b91f82a480763b8a3d0ba76ec58d24bf56c6f4757605caab5ad1291f43864dbc3666d4da340a0e13c9ca59db0945d07baaea4566e0892f356f9052e11812fe2b7813c4bfdea5a761c4882759c18d328b575e49f74c669ae0a75c37928bb98b242c229a7b6fc4b281154650cdc7054576e01adf8217834def0b4ec618ce78d55f6406127667a5111aea115b2af556251c8a2d390835068cdeee751673043d9de9609f74514df5a7902c6b140d5dfaa6dea5204260c527892a96ac95998f5aa35812ddc4db40fd8a46ac2a98da9bb815bc3b22510721949e00b9f41587b79424e6ed56f0aeaf480114740d01e2d9495ad9a2c8b1ec083d55b3fff8cde63d179f7b48c162bdd2dd4ee637606a56af5e0063f8cc3c3b227bf0dc9b7758f2d0ac5ccbb2d5be1e65c5bf1b1e6704b35a046b1915e665de96273a5dae51e218a03ac20f1cdc91c67be988e15965ba4d5c7887ec09fec72ecdf6fcf3cb2444ace688bd220dcbc876afb6322fa18d91a9caadce831589fca456ce2a811ed68513d1febb757a1ed362bfbde3f286deb2c56df15bfccb4b1ad7900b5682333ca0d1a59ed0f8fead27452169637acc76cd0ae8dc79b74921edbefa2c9335b40cb93812cdf19f6a4613f16d3484cf2ad2bb46ce40113e927494af61a275d02de37a8b7063199ba75a10fef506072f8c7a927e775f7822d22e91d4a4f5e1c5ab7c04f599995af8d38d89e8dd88a760f225bbf1925bb283ea6aacbf155903fbfe85fde9a03b73b4778306d9e83748047f801e1ba7ea1b6a56e8c76e4b77762d9c0f15e81e5aea1d2eac402a4283a81a9ff2d9598dc0e70ffe02e4af10a1929f0fda6e6448abfc833b5d8e0d4c91a30114c128e4329dd343c210a2e7346429c5306ceadafc37f94f4cc6e1ef55af28f900a492981caecf809dddb044ab1d852d5d765b6eff0acefca88ef98f0cdfd0f7c1e9f5cad98e3b717df8cfce0939eff6c1273b14016065fe7d066a6473be2e8f8f150e951683a9d4db1af70a9a4b50ea09dccd16572dd0a024f15b468b4cf0a9d26e577a70258c20526e6fd52d5503c903c0d61e11b8374a1633bbfe64eff9e57992d1a537c0e47eed80a5e5b2016f5ff0f7b80599f80794f9022619a955a9e3c627e4d83a8da3757d8fcd61ea6daafdb8df1bccb9fec2e46878061829e767e6ee4f79c62f6e323d41000842e79673f343198cd4b2bf9c9b5f56bdc1db811e8b081d8a14f6b56d77da6bd6bc7bed50f5934b24e42778ecd4472e57b2e915747a2e7c0e068a26387fa87868f1cada050cec8473e3b7a85cef8afcd5bcb66f189454defdcd2cfcb0926ebc81052067f1d96fca8918f8257176ddba1787e094372cfe9bc0a8a6e66c534a192c889d043ff4925ffd9e567df9d1e91a939896e8cabc60ae513103f007168c521f6f8adf99a8a08bcabe5c31468b4c1fadcc55751026629298b0c15c13b1270aaa5d9ebe8a5a11762067f07c32daaefc9043587e5c550d872b251046e8296c5f27b495df736f263b148c4e6f8708506209c197aeae39804e5178f2a6067a914c393c6c5ec6644f35b28a7f1e3bf38f9578dcd6bcfd5006e6e41452a4f46fdd7ad8a74759ef14f1f20ca74f1610c129b854cf72a65397925c1206f8641d10de190900fda2742e0f1d2fd0b6c1df6027dd835e8bcae08c595e876b8caaafa3bb42a0ac471ff16ad43f0cdfd9a9cd2709d8257279292c13420cdfc5e91e650f956ad21eb6144d648351cc0d68daaae0bbebd806128a1a99a88b039bba9f68a15bbe06b1529fad6e938788687b73965c9303e602475b87fa308024e0724bb8be70e1d921dbbfbf7232f0c799c4c73a7d1f9e9c6f1e93f0432c19811cf29c3d681328064726e8ebc8ed4daf1aecfc1d398f5e2ee24b7324b8d1d23e71f3fc6992a33b51c323c7b939c25051d6afd8eafaf11835d3a1ab720e711552e6b904cac49db90579f667b0eace663e9d7e7d1ea8ad327e89a6ce3697c6ca2cc605a4ce7b4c23d27946a27deaaf5685c5e2d8b97156403c3debe76579a9d2f3d9dc42f1f23d3ebf70e3584ca932c6bf2741b24e987082638e11dc29c01f05e6a19aeaeb88557426d88d2bd7bb5c1580d9cad6daa011a287d76e875eb03412b7f19859aeab8e1ccfa41b5477c199b8746eb42ca1a09141a37786eba5a972ce682203956b1ea5a210b72e857401b2146cf70601a4fa5494532a8b240e15364e4d5a5c0f91f43b8fe207e81f3901bb2aaced01bcaf3b63bbcada85ab32169cc15d071287e951a2b31cae024a601c3cd7c3d9c51c7627a9df8634f3aec853f0f6e7b750dc60a3b574db19517932ec5a3fed1dfb9887fa5af22af8d34b2eb84025c3fa893af85a80ede1715115c7fc099ac769c095e63c65dcddd7397567fb071268869e3dc6f53eb74bf51af5a11819b93c67d067e8b4a26f100e79799d11270ec0c9a5aef6a1faa235ccf28647d979301439fa3f44376c973314329c116f87d804b281aa494fcf0c68a856bbffc7dc1fedda106bbec72d1d61ed8b33bc3d69aa49b337b4376fb616542602dc2c430766bf4d56102160454852870e20c42e0873f9307527bfd6f6b6b4958f80c4202d9d0f6ea7a97163a86307f8041f62fea9750be6b9f9f4de3b46fc756c0f6d21cd3a35793ab95640c82b65d140b12dd57f0925851d0b32bccc8c2146106b19de0787c443668257ce0fa7350d0eb99efefe141111da9cb04c285eae6ddd4a8761e130cb2939e2e5632862d7d8b7e47dc1c32409fa12ee6e2c403f970e87bcd4cabea9fba6c637db8e05a49c14195e333a0247d43c724761d65e67b0da09ba4efb1adbbe87c31de6c706707e31d21e716100293e446abb5ad33c05090c8f57f0d5a1527d946c2914672ad7e2ba4c94bd78d2323f4e88b5381e14bfdf8197885f222cd32d8f18833cfc34d415ce524ae37203efa37af045472099906c95bb932ea4d746e23c39939a7fb9580f82f9c42702bff0445ef2fdf153414eb2c357e95b0d0519bb44f61be696b6c4f9dd996fd6aaab13e0dce2e249f6116a2ea0fdcafe060ae9eddc372182e940b91e72eb43ac4c6383c9752c914677e847a3d316f873bd8189dc0972201ed1d4619d372d4a83d649c79670f575630c99f49587470fd42b71d6c98029a4a867548ed80d140b9e6e77992e9575b6de8c8c76e96436ac22fd46bcc4ba5c984e5e213a15b384d909740e988ab66fa78a8b72c163e731032b27f37e8c1cbcfbf600f3bfc270f40437e5c0e8f2355675b245f62eea0aad21a0c7f92a0a4212c57efc43dba9789c7980f187912814ab4ad8b8596cf3c765999db92db7e35966c299ad817202bc82b5edaca88f8fca7e333412d2a4f69711d03c73c4fe84f4d38695e1a8e001ecfaf53a4c506804620b741b98442bdd548c817d4d88d17f077dda623505989ded3a67c99b0dfe2a22ef3c3564fb375a1ae3eb4e9b0b6df255bd5253d5c4442d8f77222913634e6c3cd5f9d37acff077edf4e5950a3dd209a15cf14ca381b2c860205f983161f4e59b43306dab837dc7d9b88564dd2b0a84ea1612963a4e3d91ce2e3f9bcea649e46599f7bf976e526c6828f78f59e24fa541f7598454c734f85ef9e927c1d4d3ffdd90cf9879c1d1d2938d21519db170eb1239c5f35ebac64fb71e4743e186e70b66ad701038ccba15002579c26dea56da28473fb8ef72a81e8cae446193a069ecc88705861a6a06e7e29376626dece0b6dc9ba1d2ef8d9630f704f2f0e2f3ec97bf8c6f1031bc1690e5fb7786a76953ffefdd91eaa89ce1f2aec1b6d4454b50ed39bd5ef3ce37c8ad9a4c2835be06c6456f1dea2cfb85fd60730b275a50071a5738dc6040ff8eb3c6f399cbbf869195832d486cf27011910e3fb5558aa72dca660e3ae70feb4be8d7daee802554905a29a0b5e5a7ff5feed1011b34521217699312fc8f9a4550d156d4081e62b512ee0db5926d9c292ec9fa98923889f7e1d87afd10a70676d1d76bdeb6aea6615c79acea342ea3dbfbc8d1e69e3aaed7a9238a37e3d7e1366d8a163f56a1b97defe2d4eb549d5fc326a2d4c631831018c999f4d4d1a78e9f05c78e7ccb651ac1821894b7ce7bba3aa0641000eb734a904b9dfc9051d6f40f7fbe40cf2c3fe6d50ee9611126309d9ab2de11465dd0c1c13a468f216d641a10e039ebc092f34cb31cd945d4ba2a4d767ed8e8744bcf07f0a421583ba17e1ab6d490ba8a84528bb8f77d95196699a6a38bd08cbae443cc2d11e1f13201221caf9a8ccb0183549aad16e1925654b7b572e2391428281eb67f4575470f32f77991d626e072d2693d057fbfbc4385f41daad6900ce0565b498ca318567f3bee3d6831be0496a5e5b453c309f9822b77457781442dc90325457711e73659f24b3d498525fc95884c507dcb64a8d0624c207a15c27ea65724c84d91832eabb5ab035928f0592bfef60b287b9057a6a3307d98ef5be0bcb57c342f6b17a3ce477b2479e2ebafaca28711ca568d6b1dd2d545c753fbfd8d1b9de07839dd8e980b23ddf0098e4d9acc60746197ff2fada99790af20d5dc9e8d7cf586dbdbc1d4f4024cfc4452c9f3f883b9a084b6b5569a898979c9bf6e10eeef11ee53e7c830b09b7b02ea29ee64a804e34586581f4f3988322433d86ecab03ca3a279bee3e0c8abe674f6e83a3f15d13424fe0c4e9a6750594daff0d70ef5f58f0ef45ba5d0dc78a20e42e2309db5c0048c36d8e8fb4a39463cdaeea06ec682fe48813d2c1b60cb9fc9c534df8cf05d5ea0bc30d67edd24b2053b6e016adbfdb8c7bb386ae3a1ea7a13fd6fb486e0c96120b0462b2987508a5b4fb986e62fe0cb92848e9bc463cbd940c5dda39119669fc6d4eba5db60c3eec0b67fb02e134db00be06af91f653aeb3456aad22f905bdeec59d0c5e56dfcd38a7f8ad765d1e5a10e0013eb03fb0245601521ab769151d6e609667647ee586801dd665d6882ef058105ad86f99582d49710709b0fc28f5c67b330367ec428779d0906a18637e95eefdc5f06189518ced870d86b46553a61a52d23e830b800298d0dcfd227fdd3de64fba1084bcba6fe4e784cb4daaf1511734bdc774563f029cb1acb96bfd135f9f733ff5a2fa8ac272a7c71da70aae847544d69951c6f3a0d74894bca82a7e84fc87a33374b3e637b53c1bfb1cbc2f66481fa3f62903ab32818a51b43626a1480033ea6177e675330dd4d31313e6c23c5079c0b04c50be7075e62b59bb2a377776eec481f9ffff3f0b46f9e6aa352138d0eb3bec1be8e5e61d5a2c04f87efb71fae7a23b0c36d31c12ff713eb9263cef4413ea6b6bb2721b051d9c487b8fcdd4a0b24b543c7d659752a7406738f3faacd31398a839e9b61de95e410817d3bb19d5379da3396ed8f1e682887546163d45ba5063f9b43dbab328b680ab62b4f92fc2899a55d8e815807a7ded5aceede1bb9fb12c9cfdd733b3e89c3a7a1fa3c75e4831dc8c827ce70eab49b6318426034b5e21b36d1efa30ef934a9449dba5af73dfb021ad2de211e3c0f9f50541498ae14bb590415c65c41559aeafd1fcfa2e790c4aef1c4e4c9eb61b9455361991c740f6709c57eed80f09bc19518fee24feb00ef1f20179e2fef5ded06d4ac880900e379eb21f81f2823fcc50c958dc88e5d92244e91c580fcb5af246cec563371f96dc2db60d1a545d4ab82b30243f7089a0fe06c2bf550b226173ae1d82bc43d3bf05eee62a0aff06187012a32904e7f59685b673c5a4275c419c13b4655889e655c00414a44e541873f1eb2b7faf2304b28a424698b9589dd3f38b07d55c0ec1911e4154d0c97493fc4d939ac5c4d2a3956fc12ec8800fbc9a19d485b0fb1d318757d9d7e67e2b1e95a5fe7470052dba8f04da0f7f5a83b32a631bb338379414d7df7582cd5fc53764a248a843a6aee0174f98788182a28c1bfb22911effca661c4d8463204061a1b9a45ff49a21b16224711883c032076a11a02ef56d13b4c53a91c88bc37f17366e7588926f9193d7d70baeca6ce0809607e42403f86e6da06468ff4eff2341289d66fac334e9ef67f78cc7a6138fdca957f283c1d929860e07e1356eb4ad09364d9285ccb992b298ce473f401318b9189f14356c57007d81daa3a33133218b5b5d7bd1135254496a60c7e044d4ada571810bb8cfedf71b38a964ca2662cc835f117217209ee302cd6967497a6f394040bc0ea8dacb752a116a733739681dfde4155cbd5437187535fe552d8194b5e1c3ba99386ff9a9c35a01945f35d002d120ee6e4beed4ea95d15d01396c0586fb62b63d86d771eb4cce2cf953b5f37a3eaff30caf7c579356dad332bca1fa6e9da1691fcb1664f86921f6681f570e6601d076a8558ab61f5e70e390e24906a196f37c9540732a07bacb1a182366f09fd7afdcfd836ff3af8783f8d1288b19c14888d436f0db89dedc731730b53341008c0a31d178e2645a31d104f836bc19937f76f3138d2e736d63232dafffd87a89dab0c2f8a78af3c9752f5167174de9efa0a2ebaaec422c0f8c3d2c3aabb97b579b4ad6a0a073f5441d6328d45a4ed874e11adcadeed1599cc6456fb7ab9056584bd4480165faa092c7797a135040fd28f776c7d84e2c26a4710098b604b304e2f396550f842b0f0eb4c85ea53762b73d04bdb1b9b4c3e447f6f74d87a61410b6902931760d1a47f5055a8c4ecf11e69469993782d4de4366c4a4ad099d91dfc9573aa31a21159a78694894b077bbd4bd3ff750c72bf38117442bdcd02e2f800ae3c96b422e7861d06027dc7ed85fffe40b3c4989dbff393f39fb833c6cdc25d50d2b062d0b459c9b13fe3beca16f29c96763d176279d6dbd7c9690f3e45fe649634ec656a16f09df4a527237da298302b770d1d883d95326539f3c628f9f87a8cd1d3c8838143e39141ec739fe9d004707eaab52c0d4f7af3afa93ec7a24f550443a1e65feba422ac59703be7cd0cb560702d2469f2541479bb275042069188a2e3cdb4faf9818c7214225340d5a4d752af50f8464dd5520e635a7ba50797188dca44fea5e8ff0d9ee7ce176166ef5809e59a9353b4289457c817b25fe3dbf2ecf9b4b49d41bd50a77c19b2b36c5fa0f39dbb4cc7becb363761d4a334118ff53f48d675db6aa803874addca32206c8cc61971e1503eed55a88ece86e4e2444871b349f85dc8c35223319ce3a89173d3c1c8864a4440918d12d5276ac467ba32bf2a86ba1bc26d92d3f97bfedb0dff73cf90484a3ec37ef0ec0758c3aa6714982855d058ca8e5a93d7baedc0d990273e1a72b2dfd4a159910c90d3c1e234a736426618d460cb07b5777d26188ea893ce8a19059b06877ed7aa89cff5f6114f46b2e35204451e0fe6056bd6f29b3878436be0b806966bb0d8d88e47f60e11dda7f843713e9e26d2026479a9f542d738c729881d217656f4034a83722fa8f095edbfdc3b678e5b81c4e3b3d6c77d2f467fe723c7ab0edfe186a709a4f579624b80402c19f547fb027d3e6eaafc2ea6de2828d38b695ebfc22fb9dd4eb83ede8cca5607923c5f87ed86d83140bcd79446c241b636f686adb5e6574b3125c88c5277962d563072e2c5b4990fa73521c390f6f478075de7a4b01579b015616e9ec369211dce6ef7106df5b9412ff166f35e70ac42a6c3ccffeacfe420d95c3b95d481cf8ef19e6d92825573edd3dc665849643769996629db5fb00b864c397708354e0964301a775e7381e959b1295ef3d06ef9e4b0049ab68117d676d5ed0d8bc2e7666037049e0d8921f23a0b402cfbf115db653ca9e63f432213efdc8621520678dd8b795def4ff22d5f57cfcfc9da6c6216b4e9fa6d2e368d26230a21d0862ec0fae6dbba8d4fb61a1b8067d60adf7790d7c679f0f80e4793414f3df5316a8c59875c2b40df3e029e601535d6a0a033d137f36bbed5a82a592f24b430dc043f7d9415b28563883ad35f778f7c8b4b4ebff2a314edced325694cc79053cbc8dff04b9f9545be852f8d7bf47bdf4b83a705616172401865fedad1c1a8a1cc8a0432c69cc448db471b3f89cd516e498d3af0f8bb95cd993a55ebf72f6ef1feb39fd55869b4ce4f8f952221e292bcf67993a1cb998c75ca22abb0c54b4354226b840fced28eebd3d45b20d41e5847fc529a40c91f59f7e4c76215216657e3b901b75bbd2ff6ddb34400d1e70cd26774a29f659243140ee78aa3261d1367826a3a3880dfc4b46a5c46889308cb9c959c9ba634c9c72a35ba16a05d2b921e913f6e735f1ea6d7e3047b73a807771d26087e1f2b913db71cc274bda90ff32f473fd8483199704ee2a1fc3a8f56ec901c72a7dcad491dc8b717005c7da9ab287f674091ef4241d479ba5bce1cace17f73313ffd131ab0d7e4634cf894b625fac88d9090898922cbc8adfa0434e69512930bf3d9c4b56b5ed2fbc3af9f1a7550ce470344facb5150efbea0bc1f89cbf29e94bc39efc4c6c727a846cb4792964627682aa935bb0d4c9815ef875afce5c5728ed4e0088b0c102d7a5de97cdb448c7d5aeb54dbdaa2da3fd710d1f7a4ee5bdd823d6ee3084b3aa42f980d05f76440ad615da54a621a7b05ffc58b06d6bca42cbda49e82abbbc2289c6dd4f48df8ebcb7e5807c94860516629120284a9425b5484e1b2c2cfb954644cfdaa73222959f8ab9adf8d03f22ae5199a56fe401f0e8c352d32e0f879c5a894565e4ed981aeed6e1732c0272dd71a8d1653615d2bfd5c91f160c95cd3874c52e2859495f2af60f09cb922734d2db623f8433331c24f875d70fbffaf939e337a1a4149c598756363bc223fc00fad0e3f532f7339e00a6be122c997c50f7999ebbe715f76e3117b8fd594cd3b3f2333c974251149820aa2593c43e8c66beb82ee8999a97eae94da9e3aeff1272070067f3f3dd25548e0afa0fb48b6def8144cf6293b0e50cacf7319651130c2f1fddbef994514214a840b32732b44355fd32c0ff478ea8a6107c0160fa5bc9e95934d99f2cc1e58066dbcc2173399ba6546d0adcd954d4aab807042205027cc4ada5d9e9fb660d508974d175b72264a92c7f4a26ccc99086f0aad232364c9689193922aba48d0308ea8b58247789752ddcf8f536defe7cafdf0c34369b92e994bbf59f392e0dd163ad00300f2f7b37196d04928560c16b47a7edecfb7962e7ba0536a942fac05f385d1032acc881ebd70b2eb60406119add35990d952183f0d50a86d6481f54457070bd67fcdb56665d4b395bb9ad98fdf8568511faadd6fc6bde94706730114f7e769c5577ff686109c9a413189d2b87a35feaef282446d3fd13195972b173bb555abdb49bc533faae3d32646806ead504313eefe0d08c74e9068e5e891f516f298ad5409a5e1a04e8203628c9ce38af2389e2b6788406858158a37970e6fa0c99399008e3fb099966d958ad0cfb8b92b9d0ba023682d404e2d106f5752f02947e8f7c71d962c5dc8bfb07bb400007ad1ad5ea6c74478dd74f5f174b0069cc4d6c6b39e2232e2038264af747877102b2913419022547d42f0568ac519f2eee05f3e63cf01f4ba0fd2d10676597e569cb4527d851aa4eb4d7e02e1ece9d9127cb9e6f6f99048c45d877cbad4855b445f1d0c4f89100aa71d34ac0aeb074615e2be321734c3d00714625cf52b132f5f3b35148ddd41e080e6d6b34086156ab1e49847ed9d0b432970ce76c6992a6a248714b9517804c608c674b33d092a2af72d08d967d7299deeaab9fdf88704768823e44532487877220dbab00569ebd4bc08f6de9fb59d0d53288b19aa2bcacfdd19ece2f0d54f040653c2bcb936925054a71cdff9b87faab16df2c55177be04ad10092f17cace9e7f9c8121935ea20acf6e1a73932c23f1e94d7d609cd2f8fa47993605454f9630ff5664ef3b692450686e543eabd0d992175dffc6ae21de5f8be411d9833b839ed8dddbb1b5714c641d93028694539e96f9524af5651f4d0696e92bab3e62bd466074014b4833efbbe1823f60d4d2fb535a5867e216cfc71c05fe3cdf4ead07759afbdce8a5ac9dd400aeba4f5b8d55740c93c87039c18e0727387e7c295bcaa9ffe975abda369eb901364b7f190c462995990b71abc977dd3d8ea5730cc47f01a55b540a31b3cd0c886db223d23f831aa82b082e977ccd41ae56266a4749ecb0f1e739e78f63c9f13f2c641ac6cf3b34fe14c4330ef50990ca6190df73737c71b4a774937c5be679089ade6ef10512a4b53ad72679081280a6e612d6cdf67da094ec87c7c047c71db788f87f0113bf5af188ab10dab604a7c71060718d94b84670e253afd3bd13db7e956b19313f1662b40dcc6d61c7bf4264f7f427f3bb0857c221cb3cbc98c7167ae599fabcd16b61f171b42c4b2cba488bf9723f131b49bbadc05a41644043eb240e60ea0bac10f380b1d954e0c5ce6bfc23804f590b32ab41fc19b3121598ee6aaad5dc0a541802e8b6fd39fcede7531bfdc0928e269166990d2d121a8ee01466f4e15c7ef3b418101f9bf2342c932fd016d27e81538ca1a8b6b755b87d05bf5ec78a5dda1ec288c7e62700440ad8c71b1086dc2fa60598507926ea37f7462b3885016a6c97a46e37b25722d0d60af0ba39b561a307dfa8f9a70db45d99ee9e6cc16eebe94fa2a247e716e4f5e306e5eb5c9a52650f1f63891869185a5237bb88d99141008775b988d304239a64c9cd130889188aee9056acb034cf3fc936780a753d04851a0ceb2397e6d5f76e4e9ffd4b39711a75731ba1f997111acefff890a2783fbf27e0b40f0905a5ef0fe80e723785ab0c05eea86dd60142ba279ccd0df00b116c5b99a87ce80cfc561521d7b44441cbe58fb2b6213e276762a245d38cde424f3b302a3f009eb9f8ec470ea98deb0056df8e26eea6866c51a526de5142645a09f22d525a33ff5997c07c362ae08c29d05086b405719122a3cb1b91c5c29cf03289d577bf3a7adbe8572e03160b7622211cdae8d536a3734874af983775301a8a8c85f7697339175d2050519c5705e0a611a49bb57d6f569a7069ee7370c7ebd8d7361d8c6b34f8c226b6fb309c6c172aaf2759dd121e8dbe42ae7fd81c864cf758d79b238c8142f0c9e26e05efb3114c44c5a5d2b71f0adfdff52ffd949bf2743c5b78638318401dddaa14c1925cd67ec46e36d4458be436af436e9ca53992fa71540c261f0cc361411bcc51cc2d0327bdf8fa34a18a1e354e02b90922d015fb7403117cd2c2cb4b3fb6843c76117f0c7670a5bb18013748dfa822d2500aecb40eba6dacb9a900708e04615241e59e0f172b0ca3a0ecb29bd9202dcec7ee4005c6642647b90cff4e5f63894c9077a196715161598383d5f1081cb062c700e071250f7ff259e95b785c2ca67e43be61825becda58391a34a298f71d5c22f285bcf85c4f33655ba886de353032fc91ef985eabc06663ad7ea2215d4c61a31d6cc9202c701875f8fd93f19a133182983bd2b74a14a26f73699b07b96e44575ff3163f2e5c1a175da505aaeaa69dbdbce2a2f4b38ff5a3128e96ad34eea7a6b3f42b44530c2f2b28d3797139ffe72caab59b44341d40e17b0cfd555b9b0a09a37b52337d825e4fa5a6a2c7b3f3492e95f37f6bfb156791b95fc0b972111f5237e07c94e8b905ee85e7462ba9658e920cf0cba67819ccdbe04d1ae8f0f7f7bbefdcabd9c67b9a4ccc15fd689ca2b0e8ba5aa3616d1cfeb14611aea2f04b124bb663780091335d7efe80b5c3a0303f38984d03e2936929620ea091ed4c6ed429691bea562fb324634b8bbeef23976dd2455ce9db0c57cc87cef9be1a1835e2c8943ffb53de1d9444456841203680cb99182cf11ab8e5130a8c4ee1234235c3275831611496ff4430a9c3c87a993585a6cbe3a401b8db2e8bb6e805fe3709c3672e043d62090f4dbb5c88066063a40a517d7711cce36e12f41243f9179dded72ae6df7414456e43bf4a9c0a0024c2d9cb22e96bcbcf65c39f5bdcbb865930db22aaf5e2843d26fab9755810f52cddcc5b99c7e67a714d37fe1f0ddb6abbcb4ad170a83df03464563c9ff42a477e8d23527728cf01f9949a92f669b5ed6dd2ed80d33b7f297260e8a034f2a64240d04aa5b1300d3a6f4303d1d3d1dda17a49b179d188e10872e4d810c87f323e6693cf0efa96fe511c5b4715eb48e3f7d54596e1c16b753d50d0ee139e1d44d6e1ba000b6798173bf06b2c6388137e1e968c3641490c923110570aee3a2d77cd8e00ef3c7ff1b70a832d4e3b5100738987faf00097c4f754c021fb979fc249db123ec603ac58b1382e36d6ba923a671cadc18bf7d6208bcda9f4b2afbaf4ef78c452e83ecf0c4c10403f2e30ac81411085face1cd928e1820586af4002738ff32743132246b37d21cb409362117fe66baf3bc917e1c5e542a68853c8f4b6e3b0d469b9da4949d62d2ad9b2ea9ab4c86b0f3c88c060c21ec549f4bfffc015b6dfc5048022d42ed8903292a710beea307c16c72e1281e8d3a36c9ea35b8f58e02c7e5bafcb3b08d51ceb309fda4c8751c6456a80dfc2160c0d767a7aeeb2a80b984b44949bf79476a3dff63a22d563c9df945bd58a08f47343533e80567393187a72089583bf382b3c1fec63d907f04ccc77826ff010506380051662719e9a968fd611574b8fcee783908e626c674ee32744acd4556c99a115f88f58b5f6f4999a07d61d269bede56c745f6722c95d2f0e979d4578d2b5e013598a344bfe22ea24252fee380de79876652ff29fa9d1b78e560704802ceb59f04e59ed4e392335985125a756006f3e641747778a89353642ff8b8b737a51966fa15f15c701d3289cfff14db9e3b02987319f60b0bd5365b8bcb5335d03a98dafcf27a5d1809060e85efe58542955776e29d9056d62a71f57a46a700ad6b1a26ad7ab60461a54dad8bb39ea6512de5fdaa4f5dd46f065fac797bfa64e496509f5d95eb97ca7461304afc288fe2a7565e30296fac63681af34c95358de11ac87e854d8716db8b1147985d171f16955c0b2d104395f0db98d3dfb4490eb76ce9ee1c5533159a9ed7eb70a2de6b6864c62c3e88374b9a56e8cbd29947564af5b8d8884d5a7ae8c9e888f516c4d1703aaf5d9920d6e3242bd3a1d931954357016cec900933098320e11e55ea0e088530a22f24603502c4b6452c3cbab0ccf63dbe6eceaa9e46cab1397785377cfdebb4eb8957d1026187fff26cd5e4be63e87a3c637fc23a4f8210038242659c3761f683f1749cf9b572220f21102726d7dacb35857e958a6ebbd4f48fb51a4faf9b05de34a6b79680661b7d55da38cebb6f879c0674ca12346d9c2fb5cc531d5c6ad45879c2e4274dc6267b4cd8bd9da8ea8862ba4f5257a977be4db3e9e08adcc8d66e69092e32b11e9f5011d37d25aaf48df2572d7b859be677b938334fab2bdf68627c2ef44dde6c6c2b844542e8382adc0c9a3cfa9230de2c98522debafd8fc05c30b917f2c940f21667384993f671903b271829df118398032a9c1f9031c7fdb61aefca3139c5b1e39564f93fe5aa80387b8c827564a2092e5a250c2bf68c9994d9003a20bcc12c651cd76a987e055f93542e10e0a975ca0c233607c64d22aa7ca6fc76af24753ed07840c73c0a26f14227e7fb4aecb5135078be61595bdda0062d6561127bd729f2f446ef66851b2bd4bde3ab38352d863d09c4fa6f22eff4d7f30019dabf83b0ce907e2df2c7dd6c4bad9ec00b5cce4ce404be971775fa9eef403bd72c6a15a8805ea3924b09ebcc53a8b6c60d14d31e12144e64fd8561f8dcd1583ed655da5928bcf90167cec2d49cc5951f5f7e78abc442a6a4bb2077fe6c049d534ac1e399ab6dba98eeba8efa6b26d3e3e8bb088f228c905606dd56b09d3a5432943289c6e04ce5df04b798e5456ea64d30c4bbb3473f45f1954723d174878a78d65d06f7b0d86af78f7c470d92eecfd6e6a3b63b1753b124e74f0c5e9c848f25f83d96105b94a4dba8601fcac108977de3fe6a4133d2359e3120f568ea6f8a7a8f423200d86ed6bfda74396593931b376942b2b37e6e99c03a47d0afe65e5ad027b50e66e34caf9304f4d36b5a6fb7bad80ec09e7ca1701741bed6d1f4ec5f04db9ee858076b63dd08a039b9e4936619c3779a37f864da8243499101425c6a15e838c9f47d610c87812ab74a032133053fee515dd08e2ee5c8cade18d47fab3297e16ee2400106b0199ebb128ef8345da9128d82899b531fd1806fadeba09c60daa4653583fced99f2ad975754fbcf3828ac77da501a32e49dee280670a6204e9e7e7d57413fde49f669e42b7a1bfd3cb4fd68e4e05040eb782f388f129b9718bcd47bcaf7cca21beac59471243e6d1fc4d44221f2c11a4cd16133b42f611638cd15260549b2129a5c04342eb1d46930adb13a9a482316be311ed5c63b3a8a4de14576e69176edf4a3937eaa8794122f71b075ff5d5574bf7e2d3d920ba311f8fbf6b97c85321c9a7bd39df57c4afbeb3c657a1043439ec84948ef5f3299623569b5251fa770ee1d5771d91516a9073848454f75ec632dc110d785a452342d11bcbbff4d8dec602e4b5b2b1f2926c6958a550a189a4284a3af022aae5ae57eee58088aeb29b69c281","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
