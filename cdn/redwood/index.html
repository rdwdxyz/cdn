<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b235963fe7b05ac6e837d3f95695a0c7e6fdb434d983744e9588fe0c58bf81cdbdecbe4ecce8c1c26f672362e6e1b63d63a855a61d9bcabeef9ef825c122e64d93edb1cc62de74dc6868265292507803e2fd6f68455ce4223205aee7d2634c9b796386a383207042fd4514d3a58703241f6ed24278abefca95f0d75cffb44de42ca26ffd25bb27e7aea1d833047eac1b4bacb4271a4871acea00375288a51a459e51143491d0272a21d61870214ab7c36e473a84f9a974dad8a43b74417b22fc30004fc394a95648c193ebab7d76fa87fea72b2948cb9278d18393a3ee6a1c67daae67d2cd41af72e3b56c6823764257c3793a1c9dc7654f2bf29c60f0bf62ac8747b2cc179b85f0a3bc9d259ca8ddb3709e941b493908441cdffb1d36787667b5efb76bd7cbb57a06397c186f6d755f5219ac12dc2d35c86803a8cbeafb8ea8b6224445eea4704e967de20cd13a02c2e405f8e149d836105966a0182c7b4405cf27232ecdd22a181d80c1ff5ae8a5b117926e95ec3211715ff8511ea5167dd42e6b56ed8d5575d80bd8a951636a7ab3cc9d50eaf21a54bc3c67e7a3e93f39606396840371cd234346f7c8dabb314799e4f8a675f79aaa7c4973b99032af1116b3956083f79806e0b1e302b681095dc4168c99696453a041a6a1350753ee41f2e3bf04d6324cfefa5d63bca539c629dc0ab9b6898e6de818fe27fe0dc900117cf20e5cd4ee5f336c689cb0b3c3305038531a9bec702ca1c11e875ade9fea1845554536558c7d96c73f6e5c1f907392c01cf1668c84d775fdff297296a20ebd74e88c3b35686e5de8009b79fcc1d6ae30c79824bfd6429a16f985e2ca1ce35136864639ec767071d35cf6bf19057afd546fac6ffc5811e27a524f5eda472dc7daf3859a59108c980b7c137ff7acf2ae12d9a038ba1081ff5718456c97e565ed954009485a1302e5812441091d861a422b3a0c3ece5d57da7d0e24cd7d4d191af5fb2591849626e6cc3a15fd590cbd303ff6ccddab5c0512cf6ba17900ccf51a6a0ae4d34ae634c4b3869caa893fbccf6e0aeab6c5eda64b9d6d9bcde9da538c877527d6b943749830606b12bd66292b4402be9d8003893ef90d136143fab248a449a184a26cbc40a5aa9691a8d95a7fe12be670ba2674091c3a84e1faa661016875564ee93481990d0a7bb6b347c34c89bbcd36432b46e2423384c1eb59cf23eba4c485e579da79f1f1ce9eb5655a672f3112153b40eb714bf6452b93ebe5609a899697ecc4fa9659b0d6098acec3a5b594665a9891e1ece0aee19a781cb438bea2bff3168c42987a0391b887dd453ea320d2b08e348499d41e058fc08e95f06367b40e847d15d779eb285dd52175d4b57b15e7660199ee7e427f9cde1ddb230c7da34e912223a9d1c6f0d0bc2dcf14d0c4f8a66ef88a0ef3ce56ac8cf30a10b678524c211de2160229a52ec13a782ea5e2b79c49c09346660567e19fe2dea77c6125bd51126e4fb68cdd5238f3ce330d59d34f8ee99fd3c2a8cc93e0df099da9b8da8e790bf7c008fbd11164f70f93129682f497e8895f9dc97dcfd3e916624bd5198e9cf154950637028babc39694667caa20b76aeaacc4c53b71ce64de0bc77da264316d0f6b9b4ab925f9958b122d554a892ac521bfca36cb0ad221e408bcdb012e4dedda2f6a95b77412a7786bd5d3dd729479d23edefa6ba34c7fbc4fb93b5ccca9094e3766e666681fb5eb57aa1da4a83a2efd932ab2878c61ca14e1fbb27bc1b958da19a0713a5dd7657330b588b8800f102bbc60aaff0173aecda219d3c942538b329afb71a99b06ae7f3b751a8d014f7c148e16757bedd2b7f853568fb7c08ab2868bef0956b4bfe3943ed8bc2d32969bac61126242a56beb6b32d7c2ab43190ad4f6d3b57dd77e2a6f3e72e3226ad3bb32d25a51ba1736990c32c13a4cebc95c6d126016cfff4bd07cf34aadbe5f7e8664f1d429cbfa59d11143403f23ec1a82686ea9904154dbc50be01981366e6e9e4fe328647b01064ed1e49ab61282577a5ca2f8f440ee06393bc81e2929073edd803bef3821e6b653eb8ac3a93c478c0fed075f1edfdb8a0aec5d4bb33bd4734b0828bf77ece8b7e57b0c51c2c9fe5317f7d57705369f3618a9a793a5ad4e139632509778baf63d0cededd28a397dc2ef6348826f91b381286b9dafcb02ef52104159ad76ff0740d6997c55826bfe5d0e346e6408f964f3d3e5e6de1b651cf0eb7dbc6537774e7b6c6a08a03aa06c7fcec44be0c90d9f3b3fefda3c790183a95aecc0913457add5677476d2febee7ed1e9acb4550e8b314b2cd559b92cd6e212eaf0d6ba91ed4f0659190bb650293dde979d3752c5d2c33d4f283aff93383c7ccc57d7a10731429c03854057a0806bc1300acead9a85262d485a6940462b82462fde8117a45cef8dff51d22758628d805d71b85c888028929a547f9d21d7ef73140e911cf2b1506f34b35a3c54bc2c4ad885d92b0888db1168ac6fae81e7868281a361b5317a801156547a73074091e35c76282a032df24252389148b64dd3f06262235801bf21fd6a0702f77cf5bf51ebe4362cb040f4fdda76d3c969b0e460ff03892ff41df4b551c204af05950989f0f7e1caae185ae7640e8c42dafa552e736b629d76c79abd578cbc8dcc1c064723da19fedf1d7862309a3ebcd17c54b5e4f9fe610c89c65ce420ea09a5071f9e913b9637998f77629ac2fd319689b03fed54e12e6bf6456de5b922fb895655ff06dbd3e9d24ed855fa7a26b4118022f3c0a8a98991a93fbcc91b03fb2549b1d55a76c93827f7a93de4440bf6d8501aaa9531352851e4d37ca3ed3ce67101fc820ff05ed0294f762ab8e7dd87ae687ff78d0fb0940ab6ffb130fff4d537c2bf1aa61fe69e56262772246fce498610540c645ab4a68213b26cd24888e4e87f9b284d76b8f3cf99c83dd0596fda4326c94f70bdfeaab2902ef04c9f7a0fac07b025c8ac8580bf1c37fa9f1e9682a1527a5c1536771cfb7bac564d99ae48be43225e3a12b34644d29f4ef4292354be28a13969e81f8396d732c8402cfba210677d4846e3f524b24fbdc875fd8b0fac3449f02b499bc30f873601bf0d235afdad0c5297e13cdf8e9624458cae6f609fdcee0ae32dc929387fbba48d7a1763192af6173292a14ac5760cc4b9d33816bc9fae3fc7a9921c7a8cd8843bb3dbb0c801ae76e757b8c0e92b392bfc45fd2942d7343d81bf225085451b67027b37b5e72946daed8c1636c8a90a8753146ce32b875f3c32064fce2062e7e78cdd7ed622cbeab0ef572d1380446cf73cb637f9b135f46cf4ecd8b66beac35d58416847960c22fe7d4dc41e881514c99ce2559e71ff01be8a75a47131860493876f6542be03ae4a0f160cad15e9572b9b28b002e8528d9473f3de3c01bc78b5b09696931c4aa276b36c2dc263d1d488cd19a043cea4e1df96c6f53eb6b2c7899484f0d21896d8c0f67a14cc7870cccedfe058df1627dd256628407b44d0286ffbc98d8d8abe3794fd67772983a21aa2add3bb897c4dc00f7a0603108b43725b7a4ffaeca48c156668412768bf4d0e3f71deb575cbab18d235483c1dd9d1e81b3d111dfe59d005143244cf9bfd5bf6ee85a1344befee150ef02fb9148affac3a4e97f8e2cac814a68cb0c07fbad2855382c6293dfefd01972b5bbceed21eb13e56f254b9f1189d89867b91dbcf662e37684b4b420ecfe30c07eddaaf42d6390a9aef89fc84466d3e5df5772d188ec777a60b006236ed6366db3185f955944594a2e00f7ab92d9433c08cad517a464de80de564bb3352b1f42957196a3e7a39b806119f1a64887f17ed7b26b1dc3de4276ec28435b36c57069a676b77b8360c45808767418af3a5fdf4bc661bde8d7dfba31d2d91b58a68c52f7561e82fc2e690ec285a566607186a393fe7dc6bc695b66eef162bf89e2fac478a535950c32113004226cba936e03546d7386da54727027c7f058b9991f93e9d08aec47949d38d5f2d5ca4b8355bbe8e0552a8228ab0a939affc32862499f3680cb1a243d442f65de4ef184da80239f9932335f2a49e8b22cd88b64cff80d197c6cbb676a966e03bb4434bc09b936e047ccc8748126c7c8f28b5edb69772c4d52c10974bffe6d79b96a77bd6fc0b92e6a6c93fcc797c62493131414d8e069e3506cdba697f7d76e256ae1c238479228d1c4adc66eb7888b51c7c621f2e9c29de0cdaa0cf5b1ff7c68ed0c7579f05a8ca1691df132e3646a9e1f80ca09efb32ef3f267439e361c70daeaf520b31aaac5c1bab84f4aa2b82815c468c206eea6739847014151a7e680c332c0f9b2339f65fc9a6ea244cc1f884059d2d41cb0aeeb0fa4f2d228e994e383928730a78785838abc233780b238ee2b41d1ac7edab1eb561c20cc316499ee59544d20d990bc901c247919fe2c53c3b1bb8afa2fcfcdfe85f76612af5ec53c399a605245b3f59cf51de24574aa895a4d4f8321281b52015d66e38a124975de3c72d9b3fc9f5f467e6fe87769b97fa6d884184c5cd70dd514eb98468b24e40dafec6e2e93d058e8fa2ebde5a923fce24d54f3acd036d93123affe4d930947f84a6e3006470f73cfbdbbba08905e29c7fe4e2d8cb5d6d71d5db882ee930865f25b6fd50f3f9ce0be56b3a7477105f0cba97a4996b4617ec171d6a7a88a2b932d4e08c317a3399012008209606921cc1dc7008ae268439bbb9df3d6ebb7d9dd07ddaf3326ba1dd843904c3d8becd1f40d7129c5c397f8c465db4895d76e21c03e2e38d4b9aee9cf42f50a755ce9ed94e111115d20a161acfb4651adb41b00bb81ee2092e123187f82833dcdca7ed92e27a5410bd5cfcd309bf4947221361e1ede7fad799616bd5022f37b3799034ff150f4d7108a8f7c09e302ae02ce963cfeb2f508b3f132197854537c2792cbcbffd31601a572b809ab77c835722bc91cfb8aa428bef442a1211d710947c7ad8c0f80e8b638e87a8663254f01dd842069932d87b5bd3880268a8033d36f7f1024407e1c9eb1bad31d6c1ee1930011d92a71ef97818acf93035f93ccf1ffd3a4651d32f51dd361e89dfe787b7f47d93f4b4bf16f4fae5944ce8d13fdaac45e95ca7c8aaaea54a50cc8540ebf432e7a4cf2ddaccf71f0cc628db1c998ee82784b7cacbf00d36798c304d45db7669131f4e21bf85bfbf003d7581b4b890ec370be7bb057f4defcaa643a5befc709e84af43e2b342e2faed725cdff97bd3e0c34e9ed56c92c0ee52681eec62c169dd36bc4cd68b18c43aa9f2c1136debbf9ed4a7d3595a1fb9893345a52a1119c073eb971fa7bf82c77966cccfc707fb24f8a0d27109fc2988b99dbb490b3b17a2a6968be202b9451e6a6b06bde870d522bd588bd3855949d8303c95d1b664e2cdf1cbaf216bb0e74866ecf555f57c1fa9aa3e6a3ed082d6d7159dec1c701eb3228f9c625d70f6f9f2c6f07b4f1fcb665d734c814a112d9c5b4cb006c0658fd25c8352fa9d203a86c2e756ec743b8119248c5a0096caef3769d83eb62770c1d5ae1203fea390d2424f43078233fdcdefdd9452036cf66cedb3821240e425b444b09715c6c6ae99089fa9bf4c2c2b5fa322cb9c759a91e1a53d02846f478f31dc5043ff503a6c7ffb1b784d586a031638be2757221d646c5fb671f20f08128c8ebd9b77f545996acead8350b722a243c41a6c6f47598dcd02b4a66448d42888d8decce049ee109716ffe716dc456a1e3c3215f6586e68c9c004fec36a193930c6ff4565c40ed7925a1655d2efd7e4c7e40b5489cf4480ea9208ead584f28ae636051a97b2652aef02bfd62a79b25ff50d2c5533169ac2ec04f42c7291cc43fa00430a0e97578cf69aba176c931e295426242e655498283583c34ff619cc6b291130738aba8faad70c6810807a4b08fb996fb22e0d254108b5c16d8027d260121c411191aa363c450f0a7398d83fdb67fdb619ba17a1f2696a3dfce3d23f3b4d3c081fefa5e85b8e11033dbbc76e16bae8cce6b39a864ca1a36dd8b9cc1bfeb8027f3d315d66290780cdc9292ae8709dfc544e97b1014fbce8fa5dbe7869bcac7c1768d3d2532fcc7b4209c4c6a06afacfcf267b8c7268f7dd4b49f00b14b0ff113487885cef6024e8c17ada3f4cf7eeddd80f5be4a979bde3a0e67f42790cb846be99561ff43e3795d920adeaf0af7c0259030781fd8a80343e85d15efb164ab8ecce27362b8fa61fca8ec85cc4e1a826f55ddb51d96b4cabff9d83e3e402cdb8b33e0a32daa16c3654b23aaabd3c42c91a527fd4573c527ab9017606e22395139b6992e7cff46b9fc297b54124b286f631989e2aab9e5e0a188e801c156a912ac2a1d665cdad77e46ed74373ae6839f3a5a51a822a612bf11cf52388dd111bfa53a0099ed785d3346f8b0d78c3b785db2f69bb58c48b1e3fcf1e83bc1349e9eddada9f4243cc01aeb17a0495b8aa300c0b148acebeba00e1758a14ccd776c4943d423ab1c151ac76bb4eedd17a4980ffaed4d1494a36b85d91f26729374de194cbbe00d02897914d16b143e762271d3e0810387334ea68485affb8a6839ef1ae2e233654667398775cdaaa303fa79dc91d13af482afd6721587587db4cc575f7fd5840b28f3df158411e997cde01fd6548b76a668a83cd1e04bf8582540e721f5f9d8d62a2515491b13901d226004fc7cabda6635e75b11230c133b2c58234e6cfd4d3a5afc0c6d00efb08fa2d4c7f0c82a1e99fb6541f49cf73d83fd92a264ff90bfb4094b2989acca2f2644fdbee58efa3f6e78dd7aad21359c8e40912dab8913c60025cd63ff22411df0dc8a14d2a051bac1494a79f1f7b1c0160afc489a9c741af140b55fb60cc67a7563eb8e809402c60cac216cf78cabe2ad76c4fe026b6a9256a75d8fc5e6d4d4a2ce07b85ab13fad8947da515448dc8997320286c32601963fbdbe4723af8269754b2020c04271e2dea732cf6aedcd2eaebec1bfb36f7f4c2f16a00aac387bb7f95e52f0d43bbbabcffef16b609743e9f96362a8d0e67d025d9ca2b8c93e5942e5f6a8a3ddbda8b6a662b83eb0370516f8746aa60c1768b388db1efb149af0a5026cffb1caf5290b1745d8b9563f89a64b16a6cb55992dd46bfdf64b9d89e5f291ef8524aba21714ae9f5d7ec5a0de0056d6839cdac6df8d4332984b8debde9e2b7ded5126c0b3811dab7498ede9769070bae4e4efadd0f8e8055d5cf98eb53e0e699fe03d0b6105e272589410fdd1bc6ef1f4dba0d56c5d43660d48065f05998b193ff328be8cf71b76b31049053f2a24b8d22b8b8458c0373b68a4470699f53e2f8b1e8ee549742f2c0300d75a838641c188818aa3f01cbcfd5ec1dbcae847f49fc3b56efd2599f343e10cc7a51343b9d5d23f0c16d84f65930745a2caed9d99cef3cb51d5aad4bf86fc4b628881c166a7e8e2a2db35c0c17ee0a2759c1f8dfdf3b22b20f7fd92609c3bc73a88793df0b3ddb9b8178df19fab8859494c336aef78955b661dda4fac9c57a252b32fe179764066105a16f87d138b062c02d48e37e64dc54cb776809d011ebf49553253136c172de4428c9c2400e8039fc837155ef447f3167c3d8d9c928394378dba52d28d024f41ebaf8eb8a2c9fd93447869774ff0d7970445815be6091f7f47ac90fe1bb3c193228d4da296c65d01f6a36c994ab095ce99591424c37f3160398d45d60db44307d8158fdbe576a9f554f9531c6a6bafc0eea68305ecc8ba44c393fdac01a72e2e9b0989886b0ad038e203d5f4c3870499d90ef15465a05fb662d1f9ca6299efa9a25527dd3e60ebfc2df1ab47351cec4569622a231800a606a019bb907ed69596bd55ce42a8fcb3c0a9b6f2b01f04e94d64232cb8d2ce0c4a1d40f9b7a33c063d01630f7a8f5d88271e865cf770304c8744c42bf984194a3f86945a68843fed264d53bc8bbe5cae7ba08d3eef25528890a5dc82b9e66abdfb8b0efb2e4af75f80f38945afaac4d33a271a36f407de9b9693e170cecb6ada21af0d00ceeba81777d0e3dfe17f8512ceed26e9529c2c0efd136dfb3acf15d01cdaf58ed1b08f09a9e2a3cd1e4306a1ec6786a0732c383850f8d130a9bd61b184bcd046e17122f117920e13f9e4bbc58037e4744a736e19f3620e008c1dfc4467935a89665062d8982b73f1f75284a21ca75c4ccc4b2f677e55d4e0bcb8438e0a5b9890ad4f0256241e18f2c7d612134435e57ffc6b2a4d3ee98eeba8a2faa5890ddaac9fe544db0a09ccbae1c525daf5aebc984340501b99a80a28fc33cee97a84aa29f8ec9b783a21cb99d3006acbc8c63d8c72c62a7b8f2cfc9e30dc4a99424b9029aa1cce1ff909c8be1d7ecfdeb2d7c8062594743f910d1c4873c2d6f8cd7b5328133da3a92df7d5bb5908d33e6765bd66c3cd01af54fa35dcf698fbca9f449c73b1d74c0317b450bd61ef386517d316bfdf5058a369e05ea87da5548f4bb5e5ddaa39bbb2f732e31ad023437a19b3ac1768097afa14dbd5764cd01536a26f3aa6abb4b631ffb9fba10bb233d2a84a1d9d0da1a2dd29c97e2371e348f771d253051af8a0fa7ae67a31861769120837d35d33f0bdb20c317f7ae53f875c723442b6cf8cd9b266ed2ed8afccbe07842ea39d67f3e5ac89def0e7b8032c44b46f31a13cad71475c9cca29836ee111da69924916327dd194f3962285158ce8f913356531afa2892f09d956d9245e866e4159b1407863ad0f8365e8078e314c2caca27f78f784eeb94960d4ea74eca815c311163a101a8aa4aa43c215a7637975fe42a6adc9a6b6177f7eb7f885d306d6e0fad81ebdc714cff1b0e32b1aa46127d6b03ae8e25a52a72d7f7b70820bcf297f3ba23accef696c4f1be61bcc3a339b6dfbfd42a7c490afd91875e97569601df7067fc4c009067db64810ea801ed81e14e829e3cedfa8dc62dcf53b9cebbf60d710e5c108990be41070ce61bf7b33edfc4e74aa4f5057b35703cf876a3501c48aa8207726b970dcf3a5641e1e3a9155768aaafef18619a601fadafe585b9b16c4fff6c0767cbf27c13412aee3311143e1188aa7700b84e4e817f2a9a5fbbef4933adabe3019444f5beca60064b2dfb5f5064cf4344499133d0b49875f340b01f76d3130ebdfd93d1a231d26f2efc5efbb0ef97f8035bb39fb38a4fb4e280c371db74142517a641fb367f507195da0b48e1b35ccc5a8fb0eb2030b1d34690c7eeaaaef88bf4d7c16c60f83a116d5df71f46f177c1ae213fae56f9b9a52e0d190a3ca501b2ee8de594ee267a604fccbb4548c71a7d51c2ee0055fc50d3bddf23cfda995f326529b629fd651333c5f4bc5cf113f5345ce9ca454b55409621d8de7d10bc3431c6af259eaa933be094662151154abceb2b20831af7c622bf16c11b318bbd5e2c6540a17c93781be878686a71e329c97b9a2dcae850c98dff70c47a2914c8a4d46a46be50dceb048bfd537cc1f4a91d1c7ec637ebd689b8ea5497b60fd17cc1a71bf9493e818e86e6c7a0d5a4ca0c0f8780e3bcb36b7f271c8f55dfa7b434cfb105c7c75426e55f39f4f1d8005e193b0b423b4dddf40b8a87a89ac0ea44e0052d7c6db7e7e3795a26af17eb369fa691934d82b19470a241d9157bd86e8325f556ae391da49ab7ae7636f859d2815a5abfc1b284d915f5844c2bc7f98f4a6d935ac486070db2d61b71fb3ef54ff2bad13fdbfd475c65859bfe5eab4de9be8f6f4c3004dd772229625be70f721e15851c475c2c5ce24dae54710213f4945b18e47acd798465c7c5f50fd98f8a407c74d67ab38f9c251cff3028ade7491c7e44ff4d4620cf6e2d5fcc7753e24a814e8f8d6ed4a30525070b1c33592413fd758699fbfdd06d7dc0517c87e4d9d44a44247df88012b6232670e947fd34d43e3dd67b96e7e53232f94c72f5a154d2f562ab9070df4cd9fd61993a985a3c0930bd8652be24471047857942be27a7e3738e165a179b08e187aa334aa80006b915284588cf08b51a27129022762c02daac4428036518d1d494082dae47813323b03f9aed3f00a008e81c87901553c41e1678b42ac061246757e9ad82e408f997f16a4405cb65037de38dff090b602c1be25da5f2a386daba3d5c4cb391694c11f8e8649f49572c8ff4beac09ebda16d8a0e4bdb047eefe3cd6f2cbfaa7350161d07467f03cb5d61671b54a1937b5fc9ffa2f0e8f1c9f1dbbb402a639bb4af0cc605a5dd3d86cc6f85ff94450aa15c25f5806373158914f3c4b91aca3ffb5bbfe8111c7b39e4b557c35663293a0c0264066497f83bd480399642608a148fc3b0f9ee3bd065af228a3ce468d4eda18def9875a94599e5017506f15eda70810a1f352da7eec923f67ce54152851d582daa0ffd1f264f809861ff38ce3c65ba4f1aed595a4658406112a4c072dfad809acb7770a5adcfcdb192c9db026f6bfbe456a951d9067c3862522512e093b5622489d9a5b23a848783540c23cae7fc28dac642abc625c7fd131279d1a3feeefa26fbd9e33c848165234ef92497b490c3ca6458f340c271147336d672c8d1000fbaccaf3dee7c9eb757f73126512bb00b0ad31a517b9b6a77060a07e7082950c630d10fbce282f2c421dbb78f790d4ce230e1552d5f20cabc55a191422ba2b53e8e10f9c8b4301e9b8b5c4745d7546fd6ca602f3e58315aa74ac743229d84b05585bacbd720c95e19f5afd2ea64d0dbc08ca75f2fa72cf0ac66cd1b603e78ec335832ae71dab333fcb4611f4356faf38437ca6eeb72e8fac686a8de15dfa38541e308b899c4c020d8c9507a3e6befab31ba4671fff497f494f0c2c1a712a8d3dddff4180112ca05e299bdb6bba29b13db76e2088bfae69d2554822774c004bb7fb760b7321bb631ec588f61778646a09fe31c558c95e505323cda663d38d2924278d333d9c9067823ce7c413c605c16adad7dce0d0d54bc1563ddc5c9371bbe0c7fe6488df2ee8ed89d758635d4dd9785e0773830f056c4294fae55f2dc158d6589a0a29f05f74a42f82daefef986872d360a11caed9beeed2e031435bffe4da28360cddc8dfd857fc9bf5b14717fd9f0fd6f9064226e25c249c2595df611ea2c5dc015c76c8983c1bd33f0ba0976469da4278c5226649404593c3daaacf584b16fffaaf20125a5324fd5cf1c4b4a129c0bf26c77afd6e09d0f226a27db1cf2a489766851d0d95470e279b3bf38b9fed6deda6a6ed0a374d5861bf36848173cc4d60172ecb7b39f69594b83303e66506b07f3b55dc7e1160468107a345d5071cc128f6e60e0d475bf3ab2871570d9903f94491135f2a33efc06334fff32e9d43802222882ca2db9d8a5858759c516c68b79b16a9e5755c6999faa77cc2f7464477a96e5ea8b0e7d503c2fde27a9337eff7008035a641cc6b83ce762f66bf44fa5549d887073ab8a01ff57e457428a61347910d34b82e1a255b85107c17348b5a39ed639f48cb74844bc5a8cadfdae891d6e1cf54b1fdab278ed9b2faff3dacd978740c848a451f2e1eb93effd28d3bd1566975c7549926986e508705eaa7f34dc49d48d6427dfe6bee31a1917c6ca776faaf46807ee228e42968bdd899a87eff8c6e15b1bdfe5dd01fdef59ea0f18fa27fd7eb5da35963440844d42c8002657055bab6c0475252c45e22069ef9d813020b16d8618d449c05b3290dfd7e6b382042f230debd3b619f55356353bde40157084ab99ffd85f7f2416b5b6155cc9516346b83f618a4f2bd4b5b68e1f1e88ce0a9129a7a1eac7bf84227d1853c239b69bd0bf7cfe668998381fdd75a7c62ab6f6945ec4fbd7f7b6da500eb9d5ce22468ee113240143897f05640068aa0599090348b062776f076d86a5653689e3221341986878849c8995d29d5a95f169f79a07a4371366ae83264b34c7b8afcf1472396091d5c11ebb72be390209f99798e8bcdfd7530a73e2f37e38ee38ced5a9a1fbb2271e46efd3fdafd6e90f7187afb533e2a95ecebfa29c6ac959bf75a435edc7939b0f86552bff61513b2d26b54ea3924f0a1b126c74b43053094a5cab709b6f77bad346c6936f3b3377438ca33458162b907bb032a3336f18250f79d85fefc2f40671c492df69bbda261f9ac44f9eedba409dea2cd2cfd3abc47010eb62550112328ee5a6483e3a6719d4367e08e3b11cc55baa4ee3fecd8af2ca35fc21ca9243af216ac4af323bd3e2bd26f9dfbd0a096729bcb096d982db8cf74cc0b592f774542652968eb60017e49a21431714d35e9dfe3f6397b45c7dc7a6c8ecc6a0e065e03d171c58b65e4dd299568ee7fc7dbdb2bc36b758f4609aebc553b066b099e200d8380a0b0fe30a52aa6fb0c517ef1545196de78f3a7816d4fe3acd573383e3788ba147c91d004af943bc636f7ac8327351df7c8b69d0849cad85825fc31089ae8f48757eb777af5f788a8178929f2fb9c5d64ae3ae2824a6c98e4fddcbb56079fa8c80c3a7abeb0c32feff759a477101b5edb26043603c7213e6ead56bcfc741cff35e3dcf1fbd5d2e1a4124fbb33acd5ef5e70003222a2a08467425a6c1cd54c6720645bb00ec0bf1c876e31d5fb3beba36013adb4d7ebaffdbd4f6329a82b7ad0443e5207dda00046c285b42bf4974b97e047331ce6c5b4c798efe8f6fb57775c31152bd0b9ed22eece134e44aeff40da0f28fc5f2f974f98dbb3f5b632ca43a1789dab7a19d095d36da5dcf9b84ae72915a9c4b28926efba1f8d0f0310d5799d0c1c0a6a01ef525893e7ead96ceabe22dfaf709efa9f81c104472563117a655ffd7d4dd705c540a87f16d2ffccf4258a9faf5bd88876f9cbb013e4f496147d83b6c07295d5e34a1efe4fba791a878f92d98141a2d8fe74df9b2c9a8a85b48ad049d2c3c0c82c84115ca52ef95049d405d0edcc63fb9307377e99e9f7760ed2299042ae34d0609ac6e2c42189e8ca76c5a14c9463d5c92e2274f7baa2f55c50c095e1499ebe95388462c653a933e62bb8c27caa0040e97d32562d245cc48c1c4d8b49283b6c80cf11446de2c280f7194b069deeb2845f9b04b7df68a19680533323e9259cd5ea113824a106a332624e4801719f3783477e3072ece73df42189e0a0130e2f16ed5ec51d57b3d93909feee2087ac18a2516de8798375c016b4efafad3b68a13c7d92f68c408e135c341e8f5a5e73427a9c4855dba5e0d0a03eca4d5f0e1bb42c151eda8583464d133aa45fc3793519fde3dd46eda64287a97775503af1b1f9249744de2afd8ff6e58edcc4335813e852facfd3df68d56e6e4fef6eab3c60255cc6f7170b300b1f2ae4bdb9342fae99710e5fd437d91d9049b509d86dca9c29897d982075ca5f2f6a153ab81a1c071f883eb20be86cf57ea351e0570bea4efe6cd83a9bf6837ff6c68ddee36b3f1836627a2dad0da62b25c2f04dcb00f06cbb8cf530b6ec0e4994605b826175084be234f60b170b4e641aadbb5eeeceb926a7f57446af08e8d963ca4d0d4eec15d59724da3f6961af0cd3159b6e236da80e1f52ffeaa250447a7b6667dd30631be5dbfbd3a187258c3eea0279e29fe84d95b9bce943bf8b3586264b1a95b0590fe954ab11f8e52750a73c4d71029a9a1114ee22260156be44653cf475325bc24f65b121a7b631274d3bc941a7b266eabf248707d8b01a1f1b2e4cd044766fff35e7fe9d8c12837879a745d3ab56d3e9191cb0fd15a1df9c21423c74b86519cf6bf5be9a6ac63246188935aec1d650911f62beabdbb7b4d1662d4b83bc915a2d27f4e72464e590f720fd0ddbfb19e3012b21fd8026fa968e5226e982b878c8dce8ab409a9f49f20fa322a7f9e109b42157da74589b682ccc29d3ecb80276a1262bcfccc31a4befd2f333fc41429afbfab233b885072be1c0378ebba82e4c5048db0601e1f046cf32d32c4f714343a7952649d0d770c32ac68a1ccbc1b25c2fb8ea63eed6fe65bce8a8dba267a0a1c4c4ef4286d54a790bfd3c05fddcb7fdb4805e15e5be80e80acd55a62c092d88f214d218e7cd531d4773af1bbe17c56f694bb439a5605e8343c16c83d67852aa729ae03a242e0e37f94b16b2a264cb5b1d9ead2069f87d02a04d3d54468137d7896b827d177711cc232365192d38a627cd59ce272c105da672597cdc82821413e236707d2131cce73b400b246a36fdbdd64bd417e28777148c65e2c76e9e1b866357020ccc640979983faec27afb461cae505a1c81804c6c937db045bd43f0b1661d4f513735d8e03315d572799aacfe13f5eece1c3bd7607127ca3d942a146809241530f6ef4ef7b4dce1fd5bc5a92bc1698b6bbf89774c9c573dbdb289a3a80d7c073a434255850a671232262b46d7ebe76a4c90d28d2da90e8b49ca58f318cb9827e263ca297b4cac44d2beacff8fea4a06ebae1dce05a1bf5ae8d7ad05e411d372e79b578da2a8176962995e20e0bdca7d9d6dd6be082556fae86bc68417fde248f1fba73c410a333f3c72988954ae78529874ec126ccb546d4238eaac41071ab839ef954b85bc72715384712f429ad45c063e3b29e40e0d0fdc93f82db793656257c6e6e80207a12e1f1dbe447b12e0bcb6eb9db11190a8e58b62599fd005f30425cafd395b13c49b7e4c22b73b622ee0298887976efd3cc985e7eb3f6b92f08ae95bd01a28b248caad6f433981c4d837d9b5965f7b457d3e26136a39dde26ecf39784e5765328f3de3af04668d88d21392a55644263dffa39779487dbb37d5cbe5418f349410c9e5200147038d8de1cdda8ac6ef3fff06b452481c0925531312ecd54ac333a00bf71d48a229518b5932c6eff30b489631a532f43c0c3c2f24554b24a21a1ff74a8d85eca848447b2eedccf0bc4f6ba101f5eccea13e8fbccfc1a9016c8175069ea26014b192345727a17ea9a5ff4c3565d602b35228c80ef8365caa6edf8d92f5e46c386677749ea8ae6ba040df959dc9332441e4ef9ae8a9d31cbd13164b38a9e3c32206ac3d9b23d638606e289c24a6ade842476000332d321397e4cf282b1b2085c4c75f777f804999ecfe09917c4f3870eb40612b43fbcd137872191b9e4a05a0deb4645b9bd6ca0a9b8505c29a91386dfa6c5655704d7ba54b968a69f6fdbb0d5802125c6f4ebe6acb564b4f1532428052b1428a846ea9e3609ccc2119f58f788877f2699e81c01a56f0974666bad1fb96c1adb992705bc033015d61406606c4a157ff34737058d3b595a5b312f2c3f7679ae7538fe1e850f073734d3ad9a1658eb65639af6c5141b2dcc7a1b2be2c95c79b02ed2754840733a6de864ce56aa4e287a0fdee3d4209deb00c28da8398ef5b995807be029833f3d6fdc2270280db86dbc315a3fa7c0a4423341baf15e80ae9453f134a0a975e8e6c9546c6884d8b1eea91f373a1a88392745a027ceb1820ef51a46fe3220079070bb2bf817dfa6a55e87750eaa031faa53296110867a6371e73152668ffb3784c881e7edd956b2f60c95dc5457887b37ba8c266a0b86c85f6e5a73dc96c2c80253098adb507e81793e630ef3c9e6f9ff0072d5e2733056e2211250b2ea670fb7f805106d13406bb8d8b54934f181486d634ea7e7251b8b1ffd6674a63d2da63bb6593b398ac62b71dc4f969c943ec7e884d64a4b31bf8d28ffdf85da4da2a8837cf8688555af6bf49d60f32c6df84d59a5f042cb077160149590d7abfbb224b18e7072ae0397fedaac4d979116ceb4a8fb64fc3ba5d6e1d68d0f7696b01ead02993623750483faf98dd32a4b84cd04329a6cc761fb19d5ceccee63792ed6d1965c4430fc7080ff65fb16c29ddaee6ef3517c1f6eb8294adbf5f989f7c6198ffa6d3e6c4d5c7ae817c54023b945e509d0ede4274af14f8ac0e8faf10a408c37e82a40dc590fe41742735a6b66328e85d4d4a4709692053e5aeaec450208131855cf4210531f455a31620a8c4f26347b7e72538f2026b5b124288fc0091f6ebea071333467d19042899d0964e27731347264062b10e48a6b6a1c793abde57e12dc5d5499744c52a78ec8cd7fa48607f31cd9caa321fd45c2987a6a104ddf4a8cb4d5f3393b356cb18a94e4025154a25535330ca819b3698f6f355817228cf333064efc0924d5e16577720a90a01d21f0886a4fc4740b5cb42a9986ba8222e178fb8ac32e3902fa912c175f017be2aafe4d52f86afb4f6d3f3f84296d89256cb2c3ca99a961c8fc21fe644f92b9704e0ac6c307fee1ef5249eb866f31207535e7b54abf4172b6035c50590f002fb4c864064c6835926b4b586d9c664919021638f5fa8f352898240481f01b066aa566faf16af023bba28dfea8b28249048a43df3ac03b9d6b1d3a5a82f7d230450c7678f906ee53e7d7758c73d87472d81f1814372d778b4d6976300cca2ce373fecd2bdc21171963d09945def632629eb0fe2742e238621b2757486e08513b1be8f32f64a8b0cc40809150977b8f576c60dd30c46b2964cac8b80acefd76196bafa512fcac8d858a79430bec10a465f9320bea04a8443f753cde63ee118b9e2d841edef3b6bf2831fc33e8132dc789c37b1b6120c8c30b02e98c97a432d2ba41c0263a50a938b613389c871ae9ec3de696c7a715557638018686eb49211a6bfc1addf20882fd714a4808851e47bd45df906c5380a840ff019b6629e503d229a5eee3e658c20df7fcc3510e49aa48bc6613ad22bb12a1eade55e2a84de5a5fde553ec886c03a8bf5f612e9e44b42eec3773d2f217e3ac405cd3eb172787c612b6b1173e7ae126e6390d32d505bc9b2f5ca6519270138284c37bf4d8f6786bbbf50a8ee142bac345cea6ef6dddb05fe6ffafc3005dee695828365ab759b511a2bc30012088727e6986d94b15429aa6fea6445355c2fd2a9e3c39678f31d27e2f5276064899f545f3d4afe1cddf37a83aa694eeab5ffa39be73a870d39513289af8c895bbe595d58aa4e659504957ed9c27543acac7bc60f46ff95abd8f488839160f167d1a852f434a642ebc359f0c3091c80fe5f2cfd426b42cdd9c73f68b03af194f3f1ebd307e0621d52821048cd2d2113d830ad4b52908cbe8fe3968cac4713150c98cdb65f8cf4b17e15c0c64d04d7e4eb0d7d04a39bf03819b59172f19251a89cf9189c08baa590631c6e88bd51586d4fecbdbc70bc6253764f0bbbadcd3e063230daa265eb8a44665e8ce6f8aec620f45a52f0a8326701a043718e1b1dd3bb250decf0793d8657c5bd6a58b842db4322f7ec7f9371e570ddcf0386e0f5c73562cd694f12ae381c7f6f93ad1bfb061ac5ec5df7ad5e1de18698b18e62b76007a7c58fad9b597ddb8ccfaa6ddba538b051a65934dc5d6dbbf34eb49e26db0a8880b250bec57272f52743cd1142f9d79725f2c0b24a2e0e9fb6cb2031c3eb55e32d55310d4addf9a3929b7ffbac02d92a2fc253683d98965586b0d61401881fda39709415ad5bb344adfe079966097c94439a465b875b5b8cdc0023c54b0c44a3a497e7ebd3eab5b0a9d87c8de0544c2f0abffa3d3b3729d3c5e96f7b3ef0b4f2af5a78a0150e5e4bfa4db5eb008ca9734d65ca5765551da34156ff267cfbe4641834a5473815c0c2d1f49b153e112a5ddf587eca6e8c0778019310b9393664a95ac1db3105ac3e09c0079be755212a57933ccc7ce367ae373bc9a9d90b8ff5c3bddf63730bcd759cb3f98da51ff8f3126b665306dd884c61be0d8c0f0816eb1782638e972f5594b4ad8a3ac0eedf53ce50a72f2293b61c94faf8ac34a0b75bd6401a8f0bef44d04629356344d00bfcdcb521de19a13371d1c2c77205a2148ecd03e60aafcb5f86956a326286e2bb3e7eefe2be946deef30ec4d0b2a8aea8d8864a1add4453d54a191428b146682a6ad23879884d54775ee004418c8629f7b5741e6fab7b5d1bea074a592f44090485d69a519e28c47aa95feba1dcd70fac1c43de0015fb1eca39da993e87bf15f7cbacd3e614f74fe0a71d4573f8a6f0bd614ddfb13603c349f39b137fb165d5b5f1044646e91c64779d817c9de988353f1bd3eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
