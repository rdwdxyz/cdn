<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"918407e21c728c53472e11914d80f62259391f5ddbe52f8c6c5c8875b092852497458540a55dbb861f081210ad59b42075df8770f0e2a34a0e2928d02b002455e4fbbd6d2f90688f007e31528b1cc8b561e1fecefe92e565c8c7c4ec1f9d235a0795ab5a8494ca5647fab389a8deff4f84bc69542ccb8cc1480c1c08f8c39eeb75c1d7c256f3b8c848e65c0309596cc0a4db4d390b662aaf84904a14149df652c60c7efd97688f0cb36f1586494fb5d68a14082ba6cf2ff0aa42a1ca1320116cb00e185080533244bee23b420b60dc36fa2b5b861d0b92718fa68a10224f64f5911c5eaf4885901c4e5f7af31cc7c4c9f738e24dd821a10c85ead27377fd7a59301508c593c7670227c45d10efba23c6463cb96ebaa71e7d89a96ba249b788f9c06a94ed446e5d08e553e626ce6a866e562a359343e0457408c1fa0d7514742f1fe02e50a4dec1d35b0790148f591c708d4cc6ed99079241b0163afe44e871d83e03ca53af03e3f56a271b1a98da48008f62d969274d7b55c4fcc010278ff026fa46f77515655e20f36218bdbad995355133ad31b734acbbe3e3f32dda2a361b42e3af822c2e22e1ebb57f3f7a4c7ff04e183389c88f17be3acc8a0f39b795395f38b47f384e802f9c62202a721aae4f78097272082a55690b4f9837b66486bb0b362245585b3440359439aedac36517736cca3137e3bc57982f7fe1d1a20a500cef437519d03f139a5fcab4acf05779b075e78983762888d0e0062bd2a5d5f4da9f09cf7f75356acf16b4ef517a4fb834a5df93b7a247e985e5be40b03e4535f7f79bbd74a7a0aa2d29137c0d5954440b313ac96cf12a514d28dc4ddb6e2a5b186a3910c7bff82392fae6b386a12f0b47df90b7460d9fdfcf9efa6b176799b4724a9a45a03a6a278a3b91441b7ec71ac1c4db60bdb842dd6ed832659f517deee5190b669ea8bdd3883cc4dce1bf38f8560cd872dd36090b4013f998188980f638fdccea922374889039ce36d285f57909564260514bc4877d045662634c3d74f0b6bd21917df3298684b2f3202b2577e2969abc66d3c3a330b10b89802497b676f4cfdbd68be2a04baafff2b0d93a662a17301e6898055aafb9327abca91c7017acb4a17a9410cc850480014a805f39519413d7643e5a9773c297e04792983e09ea64642f8f418a80e70142302efcb92833aa7ea898c5148e20ede4579c47753dda49b1faf811ff9ea3bdd11fdf74b1816a3cadda3495afcc49081b5dc614e531fe0ae3992980d9ce1fb14c9c81584db3441583c8ef116ab9820795a74f8900a34008bdd5ce7760d8585b89615a0815a2b4320814cf3777da20d5961878deb98933d60bc7aa0bec66eff79fd627ad0b3d5eeb669236e821c1e1efd34af0742b059b73bab78a2f469c389b389c894cdc187b61078f3decef913290ab2f450db0f0a7b45bb536a81865a361a362b8da986cad184ebc86884a1d146ad88a204acb0fed31da75126763e1d3ddd61204ed916646a14b7a17ede57e3289d403a203978f97b71519a6d2b8a8cc8577847addb9bebf5d3712598a02773f938ff5d31ee68b1a777dd309f7a72d84c2f9cfec2fe11771b9a1e63e985b26c29ea9a8c2a615bc734169d327333f2177a2d050189faa662c872054393ef588e910220155c3066e2ae7d44d9e03c3179c7b8dee0d90ee2a13b861a9dd12f0b57935677aa3be98cafbd195a5b637e53b22d9f823d18a4d3ae6d91775ff91693ccf1ed904a9e22b7c186ce8670bb5f4988194fa9bf9aa1c97dd5c79615b0f3333f2984b4dcf572f6f699df142ce7f512c0190813c06f2e4abb9c5c311594112f5df6f011a38ba65f7c283f5145e0f332fea94d75e0cf2f070d12f0f73139697f9b343c363d93f298648aec380a01c5f136b7f45772e394e67d5b003841cc54f29e23202487a7873512fee9bba455d84ce303109dee3794ffb7381d108f2eeead1885f41e273e0d6763be59c642ea858727e1945590197cd69e4dea9a920189cbd8052c92ef0c61e8646d284ae250e39c23031ff0ed95a59a5278a987f026bdc80c65892e6580397008ac155212d1b2f09ad31822df2ae928a3427dd7e16f20ec0b6d69b2a03b776067600057e127b12b20ef1e37206fba064473a508c407733dc9dcead108d36102575a7e0df3a9e1d8b7236e97eb99b2248b0a6c302daf00a15ce510d1fca70286fecd959b396dd6f582a28c077ec986c4740d2029271e887da0c7a3e2c6da060c8d597e94d2d1e6b6c3d5fcab08d1998ad41bf67bf6201bc5a315dcd5f2a0d3e4f9f0a13934411cbda84a30c0312c6ca8e2dfde01ca4298d2983839f1dc18988c2d92b1b249c2c0ad8c5200201f00394ea78b344d785217d09239d7892dc93cb462a0df2eed5a07df5ae5e2359edc7e8561874f8259983d626498232d7de4cb11250cb4a500e17a0bd6db481c1428bb0464d1a93c0b64344f7990197661b9f930ee17c83d7c70a20e6e76ac77a651a6c5b319abc5ffaf4ce93394e1576d4b3f0898d824d4b0b621c73f7f6d1b1ce40c122133d577fa36e1564661992f1f8d3ab94719ab6d5fbd9d67033c152bb05f2fb1e38077e76f09edbf837a05592003b49f6414358957d0e2111c602bdc46a491ad80e7b2dad84c486db200a421bf0886a5b64ff1c345b0a0488d1eee8e0e71a420822df02c058e6834c28a6f5ba93f77e1081182b620dc6098acc03818963e448b7b22ef2262c7e8041ebc9841021665fcfc77518578301bf3604359a4746282807600bb36500db3d28ff0880797530aab0d3add9fd9991ea816f6fbab34c81d4598a32edd044bdb096362f2548a817805222beba514cd81ebe86e01d1e7431ae8a1f083900b0058957772330dfbb03a1bf473b73ca2c4b7d07882ca3a6ccfa32717ba3aa4ccdd9171a6cb27aa918a3904a38203aa94e35980b4a4601f92285e75c8326fe179cfde136f23e64bedbb93a56f75daf303d74bf097097b1df3f20f13773716c20857b146dfd8024d3fa66e58f4275844a095576fa5936f6944914ddecadb49bc9659c943dee0c6844148505f38df0842ac599eb141df9379b611c0fa1591f214a7bf80c18dbef71c3acdf872b96a7482d9b8006bc85040dd2073b613d1651aec91aa475233b61fdaccec8631121fbcae87765da425108f40fc7d935034a3ced6c2010e443046ce86648cc59561192767b69cdc38683d06bec7fbf75a72b9d63409b3ca08991d6da8da5270254bcce95d3bb75b1492ea1a85e2e2ae4c09d5e693746a8a239408b06ba28053715a454cd193ebe0a6e0ef8bd099159193cca2bcdc78688d00a077e3f91304776ef70530c685b2da994e5cf46b8d66012b295dc46fe16bb0e743520c6871e511829176e39d0b6f3f733cbf85a9425c009033af154db7850d8c0bc0334dee865c9baf46329993ca5391a041a47752c7e44b3b46802d6d322de6b953d01686def980ddac437f3210913b8b88eded45227051cf4c844d5107c82f1f9a801b83cccf00bc4497d4f824c151e99e1d74d2270c9e1271351b4220338849c587f074e67f4c82b348ec200b656a29f986ae9fcd2fbda38f2131caf44877a1e37515ed91715a4c3895cfb8dd26c0f227853fd6bdbb1b5b8a84d3f8d09cedbf53e49828ecfba1faf50f0c5fdf7ae94cb755c88d4c7782db158f86c955d96507273a28490a00b0fb2f503cb29f628ecd0cc83d4a8f5d6400ec6382138c1a535d676736ee10f5a9dbe0ed4e3a23e53203a828b006ed4176d4718fddae82cc2a31736960aaff5ee1a057d9cc710c0091e862b73a34caaaa11ff73bfa1edbc4104f9db891aac984644f2b47656c8c6b0a783976232623d1d119f0bbaea76b9d85cfa386e2e826dbf9f56fbf9220dab3d2a7b6421351324ea12dcffd82ae1818d21f599d6fb18eca4c286910c1dd539093d4b949abf81533ad4bd91dee3ad72e964e4bb13dd76c475070b33eaca5c5c9f478929c4de7ba8786bc98abff245c1fb5289eb471dc2f13ff5cd60d5e686ef52226f94455703fbd51943dd7906d79b48e2ba2e61bd2247bc87a428ade13f1d44746110361bce15914107a7f1cbb7a997112fc8b24a884a5da7c76c1905af6b1945fbf1d1b79d3946be8e8432544b8c3549f69b3245b0b513cb0a5dc77a84aa4a37078ef3854289d1fe906bdb7d9a2f50681499c63af3deccfaf7dbd75e0429b1229a6fc7f1dd971637dd602ec56fdb6b78e93493d7b215c2bdc446e26949e5336911698edd170f24a9f5990086df10a3344923e080db645239aa86e3d8ae32121ac061c2c9a6b2e6b802706de7f0698cb6c3bd8255f20e2bed6ca18d8d809fb834907947895648584d3886c09eec4347ef7dea08a96a4422641355814cf619cfd2c344c422620298581cc58c262678e0d0698fd83a3c32301093d866dd10eaac23d56d0499f7894b1c9649e0a90f696ba9b377c7080c324d0e09e91d1c78db0c8cb4fb74984988c02ea4e3120f9e345cd50ecfada00147ed58c135dcd9c6812b84f56222d31f5280930ee83bae42c329acae1da72ae5ef80b105727e13f01a78eccc053d5bf462e3a7ad62679e4a643b5cddaa568b18a7feefbc9c108f52711d7e41b480acdbcab26e38f2793ffef4979596423d5021ff18f8d1c29e794a3299be13f72ebaed67b75018f3b9334db983cf841203b135183836555f0bef30eddecf72af337147e61350998cbdab7a5fadc0eaddb5c6ed0f19e37b968204d9a1797ef3a4340e31e79eb5e983f5f70fa909a7205361884697ab9def3ca6488b8d494a57d27143d282a6d5138e0fddf6155f43da53dd33177e7e483b29d6f5da7b8ecdd2d4b711b736be5c706b2a14a5f39fb8bd9bc7513a65c200faf5744de5d2b70915a080eebf95ff188baa92c491c1a66394ff03bb41e457e3d20690f910b23b0fe12624a6e26bba298ef6bf5927e6fcca7c88b5db05502a6b5e0ce95737f9358d9e6ef1145e43a5348d3c3b36fb7cf1abe49d223bfbe9b970a496dbaa4d30fcb8a5b6607d68f0afa781721ee201c516674647ecec7b82dfb090e00d6bacb495c53f75fce9f2cd5cf6ac16da97156ac48e6b436f34a427cca7984e3cbf105bf06c5a3549e7d5fd15b0f9eb9b3ea332aa634b3d4baa8fbf7080d6c74eedf27269edffa9d58157da97957f50bd3c3615defc4ce131e342e3e16e812ebcd7950ea77cef6f2d1919bb31bc27872f84c4300fed0a7d0f9be30748283fea62f68d29e7b8232bfa19bf0e673861fa88aced47c8b31f85dc7bb92e0a66bcd528cb8fa167755324b8f74aa59771a2c0719ea1c525e145bace4836061a0c64428e85030f6a6747108dc251e0556d1b25c89be8d400f03d5e772c347f6fa4ec22136937b5fd054df5d35b435b2009786d96e301dacce265563c0df2ead5f497e16578b694631395e7b212bc18279406ecf9428e8f5155c563fa741a36f0284b773268cc4a2d9d7d27d26f157998eecc5e153500239d0232c5ae86182321c72e30364b417dc4b9d0a556e0979a2d271530a24c8fc9bd6d04b4c3c89fa32e4c16b8ee191af6aecaa56294c30b52c801d7a1734ab1a33dbc3d2bd3ca56643f78ed42698c9ed1a539eb046102f034dc220caf6978d3edbb88df66d49398508b24c761bfeabec945849329bca979014f199cfaaf0283f44b930f7f0f26fdb6c73bb801e9ebcb77f04ad12527e1d20c673caf08bdb560e155275335f1014b70a7a4c056b10f31ec12058971cae17f5d8481cfa2fe611baacc700d18a35b702307c551ba11fed77e7e91b20d228319aef2216b51d900c62c9928099e835e4d32b7f135a6c3d052e48e28c1d984705d85d39c184e1ad4ef3c61e980989f52e47d5cb204729ce23e5f8e9411161af777de6ce9a1f848b0cd08c81e0ad61435212ed22881fe0aac70e5b985ea6f40c39a12bdd1e1adc33729b53e9f639265d0ee15866d511c2a38d2c363964a0eb5b1f01e54c06b429fb3edae431ca68b940f661489b5f8d4df9f9dc8616eef1d23bfef18bef81a4f51924b63b0047c4d0ea15f52333f5f93401be5a53d42f8a6884b070a309605b7088b3f7bf61de5a93c9006aa0d8b3d5024b7d7deab3cd038d81e6f2ecaad22ea59370090e31dfd66dfa97c1d6a3ac321a7b57c850fd516a1c47bda2cd1505ddd39e0fe88f0bcf18e0c2b4d010364e4e3f10f79a0289a9fb76f52849575fb1a6165760ce3d5e9cefce872d8e2a0b869df35b5ee04b47134268f13190ad7dcc031b64d5a7e6f85f84a88291d6676605ab88da5c4d962bd61d55e2244c890d6ea1ac26f00d65b6f2e95e73fb1f5476f63905f4a03124b787caac0bba0c08e37e4cde7291b3ed3133068a21c2f5343e91f5e2a8283003127619054374797b909a196297a2d4f290c8eadff105d4b0b8fea35937edc9c0fc77d0fda370b4b494b8b8a1b00add567f6f1728e3b9e23bafe4eaa615b8b9f6bea84c7e7e2a8d6fa7129ac414a568d9bd3ce3c26dd7f2ef76919d36201d7cd6675fb71bab168e677b71ece7741be310f994ad4f2fec49a5abe7b49e0fc019825ba02352483e762cc9cb17cd46f660c8c1e637742559d9c75f1e3b037f7cde2baaf885ba47461123c1a3a8051b82ced60b933f7b378ef9c78270e16b4d9dc4ec2442c1004d4d89f0e65ccb9fea26f9ae9a39b802feca0cdb5675d7e12b58c8298156738f4657522b3e2290d355d11b51854ed2deb1a75d954ea3e1908364d93d10193d3b1484158bec35bd3d54f77e2c19da0d75701c5d9b4abef6bc59ffa7bfc883738d8e009734b8f84316c71f41cbfa5548cfde4fb946b40c6c75404839c63941e63dca7d37fff8e6336cdcec17b19fbf3065599bd705560b670ca89c458888b84e19193eab3499ff8fb61a8311e3ff9595afbf27879a0722ff9aab5bc2b4a5540fb9db1b58928b895e13158b16d477657270a6f50fcd42544fe5806e692f6c2c4869a0ef8c73e2b3d90a0621bbe1d963cdb4af3269f6bd8ef13ba0fb219035dc0c3e274475f99a477ebbabf57857caecc807d3553e078c7ffb9c091526f6cc2e6a19b0f70513ed1f97beee0bb964bcdfdb6cb6128adaba557a6cee4210055b409dd152188b8234f90c074a2966b8edfe9544e193b66d21a02f23993eb0eb1292e2066bea4b0adde185ead552a00e8d92f455697f3698fec93020de42beaa66d244baf0c3ba2b62ae4f38c9d47066cd8a98a3a75f8c14cc625670f267245646a2988736fc65fdc29e14166e9d90ec09cb522c7bc2c15ec73fa526d89bea98c62036a3eb148521e895cff43da3e53a38968e1f4b4afff4dadc4a7208b938679be33c629ed945c99de2a592aa13056b23980cb0b669b47e221cd3fdbaf1ec59882b07bcb64af70911c69e473c1f658881f9bfb043f3bccb4d68361eb3dcc1c3502a7a310566e22a8fcc03ad04e7304f8503c51d7f6f0bba4dc7d929920a09927ca841ff811faa1f91302bbd1bcf36f4fe56cf4bbae571bfd027fe11c527c52adfcb0fa2e201f5edab1a741659687e611bdc43e11ddfb913dc149a407bf0517f75c75e53207be6099ea4ee7d42b80acbab07f7deec457a6e5cb9abcf9fac4406463dd17e1b48224e04539e829f100f0879d47ca514771c2fbd30b8020dabe71abe8e5e75da04e7950a627bc5c37d20bfc07e0ada62c17a96dd75851b32058f9812e849659e7243a155645c7df538aac212d00b54ab5b8d5838573a89af76687be2790a8ef63f69963767aff2d75c69805b2eea3e54ad9558722ea183163c4a212abe2070cf0da0b03d7b4d5233ea3309133166ae01f5f06a1570c7772b14b8a139f402517f98637b0a805967a2760ede29ba49fe9eb198e1c2a86f1a9ad80bcdf09a792f77608b79398fef2fe04ef22d0210c12d162e40d7b4907ddb979b6306a5beb3334756c3613132dfdf59e0319ba48533a616d49230d04f9d3c0ce911d4e810d3949e39aec9467bc38f07fffa2f61708bdec35fb56c83d2635e44ade9b9609f78e9466481880ba8ada6eaae9408c8d7cce3f221445c49f770edffd7ecddaa38030bd8ae907135d7f8b85835c3939d15f7555d5b539f22f95c1539067a632750933e3a48b4069e3433e1635241648d201ee804f71b0e78cd560b7e76eb393addfb9ace2d3030c5ff07efd2f9575a7e621dc68e7f1a72df7c6d5a6147725282ce1b8f23898a70877d171800d6f5bf982384bec35e14c868083d0fa3bc8fe9996b9616a607e504d0daa16f645833c4ae0d243adb7565514357e1f4a0e9fec28db43c3bf3345d2ecfe4538d3692e01e2ff3439c1c23c5cd18c9d4e52e9889cb639a70defa07aa5353a3e68ce2b1d07347c9ad281860999d7ae4440064ab608a90df758bc4bb8fbf5a6167a0b91a02db029a7dcd169b0d27254895be793af9c03608a6366d7012b73757ef3f692ff3bfbd88d0f1b75936a8f303b3d297681ecb8c8249bb05a7c7cd8e5a01256612356696fe8ad8e8df8cdf649679d3993b7711a02c9046cb4de6542488181dd2149e935120b21cbf5efda67312ffb85db84497c55d418c35a68322d8adf11e8e3a93f8aa401b57cc17deb3cc93de5632b7a182477fa6808f9ce52cdf2ed93a059518a0232267d3b7ecae683cf753f885684f0f95cd1d7c4e83e03e31c4576dfb8337cb30e9d58d50b31b6623ffc546e41a4a6cdcf7fea02fa2a424a52122815b3e85ed48d2a76dcbd24a27bc5551d5301bfda94f2465851ac560f85a4346cee5cb749ed970f36ceff89efc27f8dd415f7811e80bea20690d236e37922fdf641ddb7dec594bc66f10fbe5c853e9f513b4013b7f040ae52558cd48e7be809066ba6d40549d4de0e23d4c9280d95f68f0551fcc913aed32847a55dbab01fe984488ef29b71ec129ebb433bd07de785690e2ebc23adb5b8775de27fb7004363f5a62f7dec5fe030ecac763d871adca53dace982e0285bb376c7107698b337dd5d913fc6d27a78f5e97868749b080e3fdffe644b7cb7fcb145e7118ef475185069aa98c38aec7dc2880a31e2e3955b6f04d23e0cccbbfb2818a6fe53e6fdd0e0d9be6cfa9af2a595f476657692156ac35a433a00d92055b62ce0a3c72fb65032406691bb71069c1b465f3e9442261f109337530879bd4e30e889e2ca6cf2292bf150eb7fffb5718b90eb0fc3aac084f9156216fdfadb3acc9d19dfb3e8baa751418ad07316c049240adea5f94ccc9696d48f9772f76d9a3897621e490d17e68e9355ed2a14d97d88f0c132d4d97eb0e9f5933e2aa14dc8a5097dca7a21edd3cfad11e15f40b84fe8730338ab6352f7cf33f411f14c1059022ce8004db30abe8f937ee781267ad3c5ff93edd10430c6084d8298eef81b4cf7338cbae4845d7b3013f9a18f799a415ba0a8c53a72a7a6e228cadb35d65bb7e32180588b992b66695e88cc1cadfada0ee88cacd3c7a8046d61f5de88d3653a1fb0b8de99458e4734d291c66b8114fdab105275df4b82cb991b227602bdff6bfd7514e70b683cdf659f103b833822cea11805a7421ede73ea0105563122c2c1111dd1987bb90792cf6131cdd37fc4b6091a477f99175f436fdb2717dee0a6ad2bd51c4e372549d79ae7259019499a6afb6959dc0e4bac1f80dde94943c36f3bc3437fc0e50f2ed6d47aa0047c4e0b84fca28285a19b38c7c6fe321781ddc9ff2d088cdf694900012cfa07e8d102b11038ccaa5c445b738afbe37ec421562e60f3b3cb03e17f59db2616da5db93d884805dbbb51eb038e8cb7cccd74ad7c66d09b13ad08d48abdf4ab4a5d8e8d75c506304aaa25d8235e5b23168509b276d4d6d93736dbde21f30624244249e0d3c375602549b083d7a19f4067f67eb43af515917b55f8e1b453ca98b436e0db17b8c26aad8f552591c5c9cb18006b82398d338416c4c17240bf4a93229dafcfc7313c6fea7920a5317f0339d42b717c0c06285aa70a297c80fdce81a8e827116a418bc9bea19b92060ca15000cc74ffb9ed5145d4427bda5ae259681328d3e466555684ecccfc5ae19096cf41d10e81b2f60c59727b45287b02d0f5016a86cc847f51a08f6480c73e10595602c04bcb2058f181709829916de17ce57f19199e81cda1e82ef2f48e41b15f5fbb030c0b21d335287ca5b52f73b048f2621df85edeb4b857f98b6c1f76a04c898cbd8867062e071be7eb6e6ac4a2880e74d558463f019eb7b27ef12c653c1f1c8b1ed147ea59d313ed2a10b759682373a0632bf0badf88ebf30e5f9b0dc79076ec5eb90eb3c86ba93a68240568d0fb86dc6df7b6eb401a65c65d4f9b905682172fb8b8e1e799742f5464fa3ebcbf98e052aec10ba9089edc8bf66c11cf8843817ca747e244a330ce8bc3b8a0faf7f64fe291f044c025eb608f1d189672df474e168ce455f59a90094ec1cd4213caa98c2f3835f142f0d2259665a733fc33029a3c08ad9c3d76c549888b86227eeb6916923e994867d5b80eba8398a9e39b1e83e3b63a99100d93741777b8b08ce47237a585bd51dd10e56d9680b2b26a7e1ad4b028f9cb3d304d520e0e7cf7de758973c50ff6c6435504a8008f0c915f9293fcec4b6597ee616f2522f0c3f5d626daf9c311679356e3524eb2255b704ff06d3d71bfb6778db22f38e4a3f11d5e6a9a358f4735301ee47cdd57880f49edb36ed26823a91e1601b95212131ac144ff478f85d1403b3c885d0ec59b018bf832390c79d58c011f30ec79df926140e0407ad41561a25e4b5b479a6a0be1d5a05d0a740c50c8069b65cb30be0ee960139d65fb45ad8ad0abc70bb9d97e7c50b27fa52114d1d3fb34d99c1dd6b080331a3de7513485358bc6be6ebb74307bad34232fc3a0e06b964657f62ca3f334417a5392bd1bcd78637373a03f142fad65a447ca69bcf04252391f567915212f9817d581d5b8d58be5d9d8bdd26988d018b37858cf8339851bdc0878e5012946db15bacee40e53394772ce5b075fbd043f862c765644ddd22431a5b9108fa775f99add1663e30731fbe3da06d26439788ddc356c244b7f4afb95757ece50f2b0670727e98ee54b0800e6f45c1a0ebb298f64da3d6b63847ce29bfcf09c1877e20ba4eb91f462ada6aa0e1ae456aee01a8765ac2af5880c86c5797d24889601d30bd1207a981b5366915b8a5cc57c5f5b0a5a12ba6447e8080bac178213991e8e6810f098a3efe63a2482cb8b006570827ed451548bb967f7db5fdeb80f87d0a57a196bd5dbc2baa4da8909c76635c8fca4205bbca73047522239d7b678cf69b23be045d50d43d0c6949d696bb22bdb2b95b7d3d7343fb1d578ffef9f8fa446d7b6acf89e5a1526675d9c9d66be5e177e850acdc4942d773ca5584cbc08d74e34b516ca1827d3ea7306ecc2b444b90f36b2befd2bf12e72dede6c700e14f2316b29a399e30ca3eb5a1c50b9018021662bf597bea9cfdbc74923ed4c0ab071fe97d81beff3b724eefdb2f0bd84e2d72de3e5d3fec0650e628ca224dd64433769366148c685dd6237abb193adfc2a2679a59372b79c937873caace7bb79af601f9a5c266d0184d1cc7de7cc023feac6e96f9d59fb4621f1cf9511fca5bbc0f0297f9e2057121743fe2c7a19e60e352ca319d8622802e584ec83b3b0803f7b54a996bff1cfb887c03b0f45a68875094860a2fea98421ca0801bb952c054fb41ec891f3b5db6e73b0dbd62bc327db881d693cff1b4d4a556b72ded235b608b73a8c0077b202532000b5f2c3de168bfae33557014205ac9b81f661f191f2f88a94ecfa0979aff8363a92994706bb3762bfce03e331df438a815a8fd7dd4bb0c66e0df8a93e7c31a51089b7fe7e7a70f755797d7e92f15b9159f16d3c4f821b7b03476289e472aa9dfa2650d508c2151e15907a640a67a2331d7e16223d86fd1a2cfaa5984804ee2fe3600115a0d2d2bb84d271bc28a47871cdfca92192753dedcfe1ed3d8f101088f94be6e4e4bdec5e6ed2e141def18bc79ef2026e3ee19acd773803e52337e06f1a62eaeda55728e6f5534cb9ba5bed1960f9071034bf0da930ca0b48325604ebf50bba04d7009781c158014d22031aee0fc41d1a5ac857c3fdea419950940a596669ff65eb77b215625d5980a53e08960f0c93bc01229cf65107178b68a159ead6525ccabad5704a6efc48fd85a8c6c323c37d96a67a35e39ac27cbdce3a6da08e39dd99ef9df6784a6abdc599b06504086869ac41c91a30de38e983ea354e1e3d234bd12a629c3ac594ed55106d4715a2043cd7d324090dc10f686a35b34df8e08381fc83388abb06bda71d678001e6dff4a46ac6188d654fba2e6d8242af8a7f1ca0698c8235e62d4d1110ab6eef8eee79a5b700074b7c79a011f660eef2fb1ab53a6d031f0d84a6c2128840b714129dde20af85257f2ffe82226dad60c1c62bc00a05bad8a0d7c663ee9e3572a841f0cab1c2657b9cb7d638f1938f86ca89514de5dc1a20db953b1014066905e1c8416469348094cc4efe70aca6d25835a56fc4d9c0c807027f1fd72ffb67a6f50296f222e38ac9db2d3253c9c164a93731eca9d1208681e94eb98cd904bfb4513f9b45cb015c5c1d2a0649709eb141f8999a583a4668f14ba4c957f19cbb8a2ad8bed43cdc87647957a107415a9e894d9e13de9af3b36d80aecdf33eca210c87211e665274f883d41b155ac0e5d939e4730fecb306e301c6fabdc20362f7551c86fcc8c612f3bc75d3eb308373d228a1138c5d87661e4bfb223db3ba757c01f3ad627d21da5cc90b26ff7f298efa987d8f12e5a4b5f5803619687c0bf2c9db7dd91e8f19469d7af4869b68ce47efb217affd36b3c89fa3a609073acc138785e40eca50d3e93726a745e403059ba52d1909f93beee8e26eb0a45db293aa160d6e8902f975f6bb390552cad69dbd81f50af87f00ca2b15fec02607162d286f1906514046195f1960a31915fd347fdfa609e69959d1ae483fa20edb00c74f5726362a80fe07489b182c19a2f9fda6b496a6246d65096f4924b342e540df49d8838f3893af7ee1c73ec2ed5e385c110778045a0da8a352adf66741e568238750d5f1a88206cbea8e42aff169bf696a83f72f06867acf379bb525555d4cf9933532e77e0ac9327966922e9c3a523e0fa151fa254cc5a1fa9062903a7361ee2615d1ec42ee4fa68dd7274641176613ca7f7aa9430b7d6aeb24976126cacd28ce7017c0a5e2ac30975fd9ba7cebc3b6efcb2091e01b1a7cb655b1d3584d218b61aaa4004de64ca0ed9aab915bf58c21353d1303fd8a46db53a9c9ac033aa04dc5fe9ad626c38e1e286599c17974452a3a0ae4723d7650235fc8c40b478bad433e11ad8fd825be2e02803982456fbbbc0e671ec7a6bdf679fb81083bd553b9c557283c333146a8b8efd340d590192befc94bed34e9203f37e8ca39e9ae3188311c7e391154d7c2da158ef09109f03f50a69131feb666fc7ef2772d3687ae25efc6903f173bfbb4264d6410b4f8fef54f18bd90c01442eb025ba5557d20e78de1dfd44bce4fe0e0d66abafedc778a62a20fd3c5c77558e58addc242a8c2899352398ff269c7e8a3dfe0f577b50faaab08f1b389fec2d27c601eb90bbffe977ef50725fbad4adc5f0747cde550c4f50bad692e26f18fd5ecddd7a811d265fd5a19aabc1a26e755e0d82c3b4c10c5de0cb0d0fae76ed34a98c5922152194759ed8adc53296e4c007129b16a2d63c74458bdb05641e1bd11814c90faa01d61dc13cbc20631b8869d860e5d86fc5a9a6699cbccad242c279d612228cf0e1f441d1a6f88d2ebc166c01035cd21eb308b1a25bcc6087786816ccc4460578c5b3925d4866c2cd54cd48ba98f0d2b158e7828dd52bf655c18bd156e0bda6881e9937338b1f69da1b867281fce3eb827162635fea43828d853a8c5393e574861b71831cd144c792dbacc38bfbc3a8dc31f02b4c58a3b2dfaccced6514082e844cadfe411a3288c24349ef52972ec953abd867b3b0c04cd34fe3f1ad67d60fc6ff80a530f02811260b15959398ac7eb77759b14af61b1fb52669764a77b4b3731caa904c8817ad5681bc02b9cb799595b331466e6ba5c081f9c7b796503c0deb86aab7acc866c2efabb4f241e2701bb24657c9e4dad9e77bddb17b01c5f83cd555e2f723604eee9e444390a2b81bf57410a5922e6da7ec91f47dad19c14dade8eec7bd59325500b580b38f2f3480054483024925bab31ff6f0868fa3c547986a694a7bd161d5476127a26eb364f98276f2fe0519f370e0424ceccbcc27d30ea5302803a282fb88b848c294a9efd709dc4954eff30c8a65863f2c00d56e7c0de40bde9883c42d48dfbd7c4ef9aebabe8941dae7496bc65f163d7e2ef5fa26501f042c188af7f3cc41b1472fe88db4410208dffcad71b30c25329d67b017cf80ab36c861408b3c632d6d84201c0a6c41849488007bec572d86e708edb1dacd5bf575d6eae056c3ae4ebe5236420b429ee119609e9577706cae9367bcbb95ab77070d7e2e511de81a880feecd1e9367ebf8130c9dc4676095a1bd58e274fc9b67c71fb707935e16faa8472280b697088e21da8f54259f21c5722b150b2184d67c656ddee0e311356f44f87bc82299a6366e4815544c3b5c4f0b0d10d8147f0516f3cade6bb597b2472cd9ef7b80f41deb10af3fe277cb41e7d3d095fe40e4019fbff6013cfa85e1ffe9ea9e1bccf20944033d98af4b55d4d6e12649b811ab0cdcc04431873899f81ba4de93ace228ebcfe309bcd96408520991224c637784ec6cc00864563680088a1e824210a092dcf823693f16a151ee08f01363465c765a40f0ea64b592fbc565965a587e81b7b7e03de99f473cb2d29c20bb2de4ddd6d6bb90c41ccfacfc12196ff5e8ab1dcb83d3112b535f066d1d3018adee813f297dc1e1ba9a950aea61c3c33c07b929d85e19257596408fd28bcd832a664a18a051c107077627567ddde7fd1428f001d1e4153362ea7da7b9bc12779556b43da04f6e76017a17fd266359749d0dd9ce7f15d8710daab8f35aeb9596540b076a9fe3c02663479fda2039b46d20a0e113f2c3939b66b02c2af514a9db61b8ccf0334159f7281364a146b1d3d7a943255eea35278913519e919f2165578bb41b4f2c1e9653b2671171d083c028a9588a1c02904b346b6bd20945ae20d2cc1ae6d9799933a750a875f5bde301f6dbb031346f9439883b822d77346116f3a5ce392396a24ed018e39feff6c36d2972fb3ab79c27efed422774ac856ccf3139ea7456758cc6106544067af5a7de123c647d1da8eee178111747d9c73e6ef956f8ce8b57d514d45d343a720d097bd538dc36fa34b91033d8375f9f5a4f4e12af1c8fe12f4093d4201ecff2d85cadc8f6cdf24605d62b339dda54c450a94b221b0ae3981c54a4668c7c8dee7c62fe4988205df4e4714f65b0a2750dad20481f082c6812b39d76b5473c71c74e8d20fd175029c860a4c8955dfbf3702d5255f268322aafc7ec0064e72d1bdad35c05d430b3f51a58f6d51a19d7dc2ee74bcb3c0a9abe20597e6d36e12f58d709bf03de643dae9a54feed363cdcda78f361a40a6823620356eab3b6a0fb4bc9dea7401048b71ec46c316c9c99fa22949349c6a4e640f2f7e99ef22e9bbfd518b35e67720748eb9fa0f53031e1bd01c944b4abf424c5424e9d43b6cc71fa63ee70ca05f5c7e7e47fdbe64bca08c6f7158a090c134182a72e794e6a6dc26d62997753befe025a0ecd03d20fb0995593cae0ec6344fb4b265b8598f9b61c92e4e3efb80aaf6871a49b001e0daa13a61ca553a7e3c4ac31599c5dbfd1b08847e1cb943e5765745b771641f16219c9916eefcbbda9de2f84ee1216b7c41b9bb486683d08566601c94702a9963a30826a8335ec75ab579f3d3cf3592725ba121f78a3d1a489da03fe7a0ff5cc6690a0d17a84844604f6b7497814c0a64d9b9b0dbe9e66ed7073362f557105c12402214d1ad2a2af9fe63f7650bd72354d8a006d670438bd1bf79c20217acab085c67cfdac117539bcdfb4a6418c690e698e3c7602af181109e37ee2f883d5f201dc5cad0c778af9fe2d5d6ac0da1446f96f824f266145423bb3f319910481e2529c69537b536142137217a7a5c6f76b748f55972b8010a05a54cff8c4fa94802c8fcf07f0429062531da260fd0e0f490682c7205e8b7570e15fe030831c5a61ace2792df17eef781561c704948ebc645cc6c4b08fef6baa40e51e7ccdc9fa3ac0400e5201d3f4de4037208f9e65f01df4cbbbded4ac9b4dbd21036c2c91298892414f88a6618193f35bd054ddbda729a02cac136a8ac0f5308494a18e67df263abfc21daddf30f5dd230bb6a6c66a33882224033c777f7aa9a2ebc04977d1ee58c2a0590899cb81f6a964272adb8df0186746261b3befc561150f1d91a47a1678a5df2c8ac0617bc5fa8d2fccde40d4060aa16ec718820a2504dce6fb91c248ac8ff92e419a5c027ca5f34c6b7dbde08ed23d5aee0b16cb6223ea4366b53f07208c2e76a2efdc7cef7658416b3ab2c9ece5fbcb1622fad44003232e608add053ff202cd67eeee3e0e110e8985619dba8c4e650877a629af8d69e92b91eee250830046c985711cc952a1e769d344279c69177e27f1dbe63cf50ad5834d4c35fb8e227c92bda70626a167594320c701ac1f10782af86286284aa7d4f1944c994c130bfeaf0208eb9d62634061a7cc2dfc223a958a6b2623b41de205d525bb1d84eb7f4caadc69d9c7dc3756228a1b06f4e8da3f40b15b80a0d7334e6852a24192d1d7a59e80c942feb03bd90fbf45cb80e0c5b18bdfb765c2f46a979f9943c49a0094ed5c14fe9f4e476dde30dac80a77acbea34c1121ad9914f11b6356fb3ad1a992c9fe877a754b81bf6c5cb7ad204e4ad7c40dc074e9a22f85a2be1a2e4748cc1f0c6d625ec0c45039ce970593eab90a597783075eecc518b8c6379f9336aa3a0a6068f4879f19c4c1d144a793444608b0959123c48a6881576c859814954bd9d8f938e2f6241caeddc5b70118e1e02bb20e316e0bdee3cb38825041a3b547d7169f22680e53ecb53cd0f860b07971e20bb1d9e5fd798ebfbf1dd5a1559a25c4b23a271b997e4253b006db123d64e42de52912f033bdbf4fcc364182655714dd208fe5c56aeccb7a6e808987d8dba8ecb068ed5b5887b849cdf9df6855cce8c55a38b5a8dfedb0839730ac418118b40bb89937b675103f72001471cff3805ac81ba326062d1d282ed924428e7839cc3f562f9b1250ef218001e4620312a40ca2d43f7e9b2659fab49d9fbc07813361bbc98eaf9666c1f67b2e519335f397029ebfbeac43d9847773e69a4dbb0ae5c931acd6d73fc2b11bdf22b0519784a3cfa32c748c97cfec2e352893a13460a61fefc39ea0f7f0bb434e936b7b7d5a56560c8ca3c0cc57e8b19c9d210198c28e8bd4df01ba7fca7500ca879bd166c2f67f2e2ca662f1ed60792b8dc075518b4d1b896895d63ea1b44375ccba4e02f0ec5e4cf0c8c779a4e13dd5ef0cd0cb79c1b1650cd953a75c9d4a1bb98d8bffb963d4f1500a558de4656f36347cfdbd02e1e85befb88b9fcfc4a369ca5656a9954ec0f31060b6db3e6613db73530b69867e5b11d6ad3aa843b484ba6139138df531a0a7cff12f8e49c5d03ec89630dc21dbf7f48c27ffdc394a46b33115998f74e0f3250242f7e155d8013d1e8c8f86191145117ef81569aab248ac7bc14f29330ac1513139836f0df490a22d5331136eeb80ad07b58f82a5c03f3d242a841772903dab69d9a60497ea9033ffaa03c6078cded174ebd1d0b09b9600f3dddab21707dc896c0117476bf7652d8ab2bdfc13499beb3c483fa99c313f021965fc19da0603c1f82f14376a143fc0060a19b73ee9b0b957e5b97efe80b67b76afab86837a293a6d1e5bf26e8786707ca7f533aedb35c8bec6980dc8c8a735b0d1f9816b10d17c0b2e460e661f7a30950306fbc7afe5c17aedd8f8d67d7c1b226","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
