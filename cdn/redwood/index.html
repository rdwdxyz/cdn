<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12228adc99f99630213e235e2e2a7734c70ceda7210e4399da18eae60139e5bc3d2f7bb7172614bc8154932bf73f0639f1450558d434e6b635c9b20aa85e57cfdcac8d70c0a6f22e4d28159cba0ffdf1bc19fd91744a4c65f62ca4c78e30acfe64c461aba3834cb5e969cc7234be30e0a44e08fa2d57d539eafa7fc9363aa05e2ad90fec356cc4dc7b7e29a2cb82c38b45267e0ce66d959b2ea5e85cc564d911957459fd1efb496bdb15ad2e0ca5e44cb4a61bc2815ba210f70ee45e79f3909e0c5baa9dba9afce2f9b564130dfd7da72e6fe37ffe756a789a6c1ed7a25148eb6a0670fb096d070c500b124959213ecace1f950d9ac9c1b06318770d36def754a3dd302ed3b913bd4c4fdc9cd6cb306577cb26bd9177a62da6e7235ce4fa38e7b4b0a3127ed3581073de28956ec28abfdbe570bd76b97349df96096088579fda0e4f8fcbd5d9784bc6fef8b936798e99db8d580902e9cd62ebf95d602fec056ad451783157a7557b656ad0290034d4ecc396a865a4c2841f9004e8f5625dd55907a119b3147d1190dddc98715210c20e43e5255982b458d0f5b5c93857f24ec837e7e9d4406e875315270b09da6d202cc5daadeba09f4caf680880514b7adfd3e96aeff942aed8d866ccb89aaa1625eafec50164342cb382b2b67e42a9df4e7d71bb21020e3fcff7d498928fe7ab508416e70d073cb0734f14c342724267e6c87323749b921c4c3e8ce26be7709b2eb67d3b3a4ff59580c6c3e6b21e8dedabc84b7258c9aa5d972bb227751f33c3ec36420e1290a6639f5c0f07ff525bc5bd537574779b123fb98c78f96cfbb0d7ac0153f852e2fa83980fd1d96fe54a3924f29fa983323f6a276ab261b4eb4961f0d554548bf7676d3459da7517faeb451a9f59998ac613c632b89a977f7006b9d6c788ada66037369fbca3dc7ecae30bd82b3e41305979491a9b7156c185d78ce97c6909ed7675bcbbb6269e89cc86cebab4fdd8c20ef592de76d2794a23d9fc8210f52855cfb5437118b310decae296232c87e35eccbc64c2925d880573460f05ad1a7870ccaf4fb64788354410f0fa1a20570e9dd3d7b823dda8528e56a895baac4dc7c93dd45de8422a2ce929707ba282fb10a0f90b75940d6bdfde4171a8c9d25c843ecfedb7efb11da0670620326edbcfc9319ce42fa617e034aae17e19da772db43000be85ed972a94618ec510298d64b99a8d88b9a71656b418b20cb1485880172377de47463071f8b3fbfb7dac7a21258388b9d60c8527b410854cfcd6f06cd4d3b98d21207d9b5791227aea49ee940395d7b63930c203aafc00adb606d3a78d2ceb164ef23c80e4450f7e75b278446ca4e06e92e21fb2fc05a22dff58b8d396dca0976ff5dbbd790801b0fcc8a7ce00d3400a4b7de5806f59734e67c068e57eb9b84cae7669ba2097cc75d54c5c63b25591c62dfcf2c4d09b565ea8de035cc3f0fce8c79840d5717070ce3ecefd8ca0dd1ec33df223648dea79b18e7b3072a7f1b7ce9b0a58ced928a7f64c19b5d725c5aaa51f981232af1ce161535c158a93f2744c293789699cacaa3ee4149c6ffe3537aeb35e549361f7e09608455842b7b1e0cb3e8f27081246e01044f6bfe42c3ade996b93265c20c17f85b69fae7c998147cc3da82ce3fb23c73ef03c6e166d3ac954bc58a22346b0a4eb9e40142aa1e076f1a5afe86f8566dad54568543285cd4b9c018b4da0bd6f96ffa4b7433045cd28f857348fb33c68f63481bb6a5c2e8ecef4889e75b2d03da0550d1fabd674732d24e766f9a24ff41571c28889e4b8be29e3b1c61f1d80b7e9db3e46248716f7681b2b8ae73c97d0835729d6e4acb5639f7ec437624f3d73c9c49b24bb25984dacfd85ff055b54888af92b829f18ae2200d29ff8324b9932cfe954032497286db82667feb7e4a40b945130ad28d6b2597f611cd084e1e266a66e626e5678d02e47767b92f18a144d802effa658f958887dc810d268fae90df8d7f83235f4bd4dcaf72a1aeb45343d78975f10f259f83966d6318caeb87dde0eaef6e087772a5cf8de67b06be7f281bc227bd201e69858a91b7851a6c627e56f0ea1ae1d98305d9001ac2e5813bd655ecfcdcde77cfd0aea8a2449e2bffb89f19fec15ef3640f40f92a28351c2a915a5918a4c6489659e4e77fbb21aa8246a5342a3f4279fdab39dba201f75111fff86b91f5502ca5d1b51bd6b7912f017fdc267ca2a26409df2a75d098cfc4953cda3fff6296d521392c30f8930e1de5eace330f7bf006114744f02091d8f0c7acd377f2ca12538ebd22b13348d05696ed56c87408a87261aa1c1c4f4c7d2b450d2cd758e747b23e9d483d3f41d853b923c0db052ccafb4b943bbbea2574edb617a3b20d4db8de35f0c01372cb382c70af737e8af6cbd1e971e22edbf689e8bee610c152c898ee97e03b6462b73265a4ff0b29448837b4310139d37a2eaa238a5e7e9d9736cc37ac7e222c51e19fb765e88ab22fbcf2aa4879ce264a42cf5b95e4731eb1d37ac649c3bfedf97d7738066f1a9731e2edf8c136a4799ce2b6b9cc111cb72be48c7cc11602802804f2218392ffd3de42efba9135fd8b9ed6a207874b7803ebc3d0536d0ef645c29537d2777ccc42015e93ddcdbd3b8355ccdd1762d70e4c47ab01a48e82bb7d408790995f99fbe5ec270bf7ceb63c024bdb3c1308f7be27f9fba7aed119e29cfbda12152e1af8fce316332a058a9fc9569cd8f9c23fa6fbb339a3d4e321dcc7fd060d76e4696ece91fcfe8f9351f3888558b2560c5e6bae086a3af538c2dc884bc1ed9b1dab3ba018d740d36b2afdf42ea8aadb1b9ba57342b2e98e7b1a2934f068880ef8d9a233dc402b072b3ee20d2cb0339c661bc9b8424dd94f044c65abdb8fd0f1460451286fdabbc7b54637e0ad1d268ba503857f912a74069ca4e4635b978cacff7f33493056b99cc2a1f23a34aae90c7da7cc0846b0ea3f5e5cf8beaeab46cf9bd634730004a59fb338e84202025a8768609663248e8aed5fe60615b03cf9e47d7290b011ae0b63d5077de96745e1dae4b261fa1b5765baf2a6c02c318729c718d2c8407f10b78cc707c6711f26522c8a339d9914378d8078733c62fbf6fc1accd0f4541638496ae788f3a309287255bfea73f95bb7b8e667bc2aace2106616668e218d77077dc6ebe4d90fd337cff265fc21e036b439d92e3a0a4370fee402f625f5a262c1094b2931424f81d2ae0e5637565866fc64b7bce288871f52c76a6c7e24912a01bc1f1a3e5e3a6f41f2a191ae38b2350da31af2523123bb93fb4ff01bdd4c4939ae20c16ca075bc19bcdf244c530a8376e914e0737f671fb3fab50ba717887ee59f95e3d106af53c09699379ed8e1826f47ba566f40e5b04fa1953e445b9feee9fd3fdd9f07158611f0a39d79755a01ac665d88dcae49bb12a62e08d352509320c62f9776f833f299dc672cecccdd50b5bddab762e8a23785aaa69c9e28cd586f387804341c405452447e7aeaf5e7a618cf6940e46fc71f18cfb787194e2a22114b9b75cf6e1e803c23a9c74afe1a0f5d55cac7f153ea8af35b2819732fb69fea3924a72d657ce3f825cea09cbb59d6c921ed181c27228ac178f1381acf6402f850bd21cf8e02281a56278e26e115eb8f2b9b16eb45728d548c0769f38cc56df8b9d04827395abc897407266de107fb6784e97ffd9951c709c9424f732cd4f7a070c22516bc2aae73e87ec71bcae08aee2a059bcfdf38c962bec113bba7cc1a36353e77bf0d9c47ca3975c81c5145133ad4221b7da95db23156d4f834cdef4396de1071523b6a4738e2d5751dcb6ca302abc82221683c46d22c82944dc77bb349cd65fe905b95e9298536a1d2830e7038b73147c6834b7e265b488aed711112ac6fcd5978e5b01ea8c7fda74780be2e6bd805b05ca08919abd86b6f7e33d381b0b1209193ebe29074655b6216a73d202913e49aa686c69f327013852975736ccef9dcee33bde862270a95bf8af065489057c8c3fa71b51dd3e2182960e0ab1fac1d24608da82ec3e2be4e7e4a5807ddc783733aa70c413374bffc29a1e26eead690670eb4388b64a154e9f77237c4cc5950e340c5752f0f787e79ba419bf072fad2f9f6d21c15569a6fd4f96ea0d2d4577b893e6461cc877de7ea85dc115020f7d4fc48489b0d7a4ecd328e9c4914926d2277f1480a90ea6b09a477dd623e94bbc759ca95d162edcf244960bca0cc674753231ebdae48b06d2ed77b8f42bea8c71a9798de059ea15330ebe8715c58cad2eccd03ed8e90c9199e8a97232ba77f2a6c0aa8882a8642e6ccd09224ddd8dab32495ae180b7ea8f8c710725806589c62652f8894e20790ff5564c0c4c8d78a1252a128da779c2bd82dc397e761ab60bd564984a4c6230cb5bcdef4af3bff6f0de80d3213eb08ff69044c8fa5e8fc4eccba0806297d7a60616237ac97ec75e5cac22865d9e5a0f8cfb1a2ff44aa4148c862d26f2e34f9dd47da8b594f987bd12d3b7afb8bf7f15379a9e9e325203d869fc25823418f347b663989fd719d77359f04fc07548343dcb7cf9a80a3d4588b9e846484de2480d314a59e23b12ae030c9dcff5508b879932a1ca3c3a94bd8046bce97253305fedd1ca281469d23c5484085cf8a1255a95fd5b369b83d32edc7551a025056c301ddcdac172da7a4e1726eb641568f7c02e12f62aa0aa036873613387551f90e1ec079b6235483ee2f261f4bd3e954ea1106ec5b3e2f734c230e605267cad720aa7388af946ef169513617b02dcaf45bdfa75d122717a4698482f5263e051efcbc3952d73fbd7728f1a5abed3f9dc203ab5cfb89ebe3edadfbbf3f817a44d44d0aa28a199c49c745f9e3ab8a4009fbc9b3689a7a7a3f5774e0b4cf6f430a04a0b543deaf02663ff3b1c74117cb2ed8afab17ace0151026dce0fece3cf131cf445133199a573ac8420c4a1d9f0eaf3d3d2b04b64f41a11ef7117005d7d534f6a4423ae07ab5ec698f7b998c3b624d5fa38984cf5a0dfe640c88bf411ebbb05c35452d3160b194acba121f1b93b7351a2994f4b7240869f3928461e303a1a713ad0fcf51b2c7dc289b22e0c59b4b01a85a0ca7b4cbaa965fba857a6f46835c3e2f47f2b8f53969b5694b720d27243a31066294c3d989c4d619dfb69fe68bfc6e2ceff84ebb1c94dfdcbcecaa2bf06e5b15719c4dc7d68b9a8a26c3a64f793e2c6f1972000965b340384ec1deb72131346e9d9545c23afb9790257acb23f8125294fd75bb49a11a2156ae79bfcb9f1d580a2ebf3945fea1f8f4b20eda9367a09b29c735417d2f67e4360743acf0c5c1255305d9310fcc9d789be94494515144895173a3d794c73bfe356e7dcbb33449ccfdfdd45a21b05247dbdc64f0184f341b1b20e34d532112b151b6b0b24a86e7d77d9c81e7c6acd38ec15d689886fe5e0486b4476e9e9114eae47f847ee921622fe0829594fd3a5664e7e7cede7640b886592f966f4bdd62085a84859727195b04e5e136e2a50147c0bf42e1680d796c54f89cec0c09c494e2a782ed35e1d94bd58220d01cb3054069bf2b5220e682769de7f984b99b2a43fb47653443793f575606476c520b97c9b0f5200b333c8cdadda4404e06626e88e6ec96922806043a17c4de9c1326f6c5d2535950aba37f99f1730d303eea206246ce5f64aba98cd0e040e76dd60c4b10c79ae919fd960211769f36ab7c425454e5d7766aeb96b71f9c3449cb66e50c08c5c592b27ab816cb5efbecbe105458b4f7aec7ea7c48fd4753a14e4cde6fc303f22d802fdfc6fa7b901cebb5f869fd3dfd6255a1b67b25fc10acdaee872f9a0b64b8b4a4fb75a530344160d27f5561fe814bc53bca3ba0503935928dd38ca6efa3201e1d790f90bbcc7511e1fe83ee24139b1cc712abdbf94864691bc7c82f1f99acb1c9e6bbc2102a474779e17178186277e85ac079fd8ce6603a90c1c8782a2c6608bec5a51155a0f616a4c3ee9c5af06185abbf514852d758cd19a326057d54ff8aaf93ec559a23864b898b7b79929cdb9cd7f59fbb109ef8e2c3aea5b5ba21d17d4c3aa381800c2917ac06e27924522107863a035902a63c76d664e5488186b81c8a5cd9354ae22b5a76b48a55193c98a9e05dbe8fdb9aefb44bff7364aa8d6448fcbf39ffde995bef6f04535bc0498355036f2f9357eb4ef618b9cc685089091f245b13633b4fe9ee95f5f69ddb9e02f556510aa133b30321c422446545fcaa4e7d58c6d62b82bfca923678bbc104df51160b44e86e07c6820dbd19cda42d744a4efed90463abd398266ad3549cacf441ce92b23df54956f186cc3dc0f18181479efd4ac2d9a3b2603653eeeef3da849abe6562c346f79f268ec2c4e38218835bf069b683b563a253839cd0f73ed08257285e707d37d3530aa79f59983909d6f6f9ce5f7998a57858379571724b569b174a78b14a63f66d4b4385ae79310e111d5c3388e44590c8a2cc057bb581bfd4aaa564bbd81263b2755dc66935626d1e52dbfe5dc3d1dd333c261fec1ad9fe8fa6fc1d7bf44108b93c0dde455211ffd3b32098e9dafc9e5df81b9e6944b866b84a82367f656e6aedf734a8d57fc2adb8e6eca218b53f0d436b5c0b269c9a869e5bbbbd94922d3021a2f089fb543f4b8296e1eb87c86c6f0a82c566950fcc7088d0df5a234f78fe4085c76545cda812eaa1ddd192a2018c241d6499d719316b00ccfa3382842eab66fc5cdc1a2a238615f6d21d5f75d3f4eec3f1c5079db7ec25df29478df5ac22fb3f32975dd9d1723541f9072b817330f210066fec79f0b11823061e5353dcfede28f485a0baf29b779f3f68cfb118ba620c98ab1f71095b3377371c45f68fa5a2af34cec5769bb7b95620f6c643cd1c36b0871f37de7804fddef5bd69afaabad094b57220c45d0cd5d6505b2429ace39797e24c476ff845d6c8885a716ff24bfdb85ef3f9196319674fde68274538dba122a579ed64fc6280377de2bdfa56ce3553e107ddc0fda05bdecfb8bd8a87eb3a385d16c656b40154c7f30bd516667876e405998d20da62999234fa682edb86ffc1594846c1aada81dcac970a84cc42a99e2e1e52c9ac9b9721c66eebee724e47f73c92c5beccef252bb1746f88cc211287c4ce1a001f8492ae06cf31837812648b599027e9d1a1ff51182feb2a4835ff44a606e9524303efa7ae16df41f67f16a31dd312b3f0b3cdab7a1d100683b3e86086426773b85f958a12ea0f49e9ab89d8260e702c569925971ddd6df6777cacc740fe3c87a4cd09d41c4d080789de253dad04752c0e6c2c3126345540e6b70c8c39371e2bd190a14668e0502e011d58029ceb371338762cc4bdf3a7c5d65624e07b60b1b39d7d41f7f7cc54d5cd4ea6933a5cec3a4fa4b6762251e8bf569435873c8ea5e750e97e6de6b5565c1959ddcce9903f99e760dbc2d3daf6720bdc46f081d42ce6d7bd19df11790ea62006f3c31e1bbb968c71b7b692db8758b8f01ece8ea97afd01bc52c4384f378779c1356c631813984630e3400b941ff64e9cfa73f1547b3ede3cbe8182ed6cec3d967ac26f030a91a840ca3f433f9db8bacd962567847cbe729b4494aad82794c796b77120eed8d2e3d564d251c5e927ab73e6610619fcf81f448c16b22a7f3ba74351cfe4147065ad9e9293ed7505a7583029cfec5374b98841fc67f835be376d8c8d4519ba32fcacc3a1358e90b9b0e0b1d4e45f6360a29cfc5edc78148a1410ab04e7207b89df87f0056f4f241424a3e31c4419e03c613136fa32b22136588aee5a83d79b42119e1c993b6afe70f1c6f9601c22a7c5f32b6f9cfeb55479939b6a8d8c440c0f3c69b1f4fc55f21a6921d61bb2be840f0e5186f17eca5a6c0bdc1a02fde49302c4c0bef6fee4a752a2d477d8d684f472b84d08316a6c888fb5e28aa5e340677ccccf2dbc72d73e1bc434972241a025824efa2323a9e336a04d3110a3cb09295d3037fbc9defd28ffe47528385d68fc5cad0fab5e534439e5218b5d83a9b435c34383111a6bdb981626a2851bdcc6469b4d630a8050c9f479ff12ea5d3c284df3571f55c92b15857874c3f0df92d952d3dd75b81919e3fc8ac18e186d64d833e0b7151c70b09e5473ef114b39679cc8878cbd185f7283571c5f4d5cfd84025bf1d0281e01ac633814bc19e9b5e4dffc2e61f490d57a80cfc16c8d0a2713acf40a51f1d161d99bb2a02e75ac47ff09e7f68ea1cdb531488b8a1ac7828e1dcfd46a40accc2e60f992323ba8ff815c1c76d24620761eeddc2e506c28f630eea40c203b79a46215985c5438e81dbf7a67412eb0ecf1528ee1cbd9af80415f4b1d4be426b99f84693c94603e184218bf16ed1639b2ba39fce09ce8fbead11100081b85c5446c50cd019c4d5977aaebb2745118980b05896f38ad15df06c0da9f6916c0be0adcc2c7e114e065e1577dfbee9f3dcee706fb324509701478bd22398f134af73e5ac3d87bb1ae9e11c8d4240932d17feaecda6534e4f86b94b48e63d2fe16ef02a415621d8b05e7a4800cca4459537907ababa2538a3a7c14ba3d3ec8020507fbe7e1db918d59a874bae35b88fef2e8b592031534fd943f9a0aad995f7ad0ec1b06a93751238f16cbf28ffbceb02aa09a8283752fad2d2cc488487a5f5f8b1ebf071796fc3fddf90a5f834ef7722dba2a25f7f69aa10fd4e816a4738c22f17040ebcbf3f4847dc288d3826174d6764e16a17140544a60e0479231cac9a7cb46828fda25055b5666874ce9509efabc965200060a72118bde406893373a3b248fbda83d8334dfdf83b404418d5ada9fff224a1eef5c2d5fd022a748ee9bd2eebf278576f4151e1a2d7dcc088efb1a472bdd576cfacaa006994ead852a98ec6a6b3350c87c6769fd0a5df609bdcf61761f6afdac7b3e677ab160b01822440869285e5cc3849e68d3e83d536553623d4f43f74c2cdad819b696caf3756df3a7060a8235bf7fc8d63569409ce6d0d682499e131273ec3dfe4378e754b05eb73c8bdf747b5d69ccf35261d81c5d66db632cd1c70406917f5b7729931e38eb7f1625961b78f72fae8b1b824cbf5ca252eb087a40103af4d54816c4bf074777b8a4b663f0b6d038c16efa082b9664c57b1fe0a44b59194359790378a8966764112d6dba1eb025f1066d870c4ab9f160d9d2a6923195af648f0429cced951fe9a42fae1552ad38fd950747c7c9baab5c59fd767ea5c124d3956d4511247bcac93b4f429bd65e00fc95528019a26c4f06f79c650430227be48c54a690c14deb1dccfda51ef038c0f1822d862a9e076318d4e6487345c2634b5eb5b2f2fe68fdf2021dce506ed040310baa9865a94e6c882fbd1c0577c49aa1f514d8de7a32ec8238fa986aebb8c9994cc08b644832fa1f738c50b3b9ffef2d3fbfdf1f46c6f43dd044a52568506991cee53424f0606081c4335713544560c43b150ce2b07ea4a15893b55102b2fc4a09d6f998e1f89e6ba1eb1bd648385237134c4b02606f6ca99a7d980626fbc679cb084b86505c2abc62fc6598135d89bb9517f93084f0da95b0313378463dc0467ef9feb37611e359e71d48659dbf0b9a8c1d112a34f773a654cff7dfb19685536c8f4d9eaec1d4bc5ec679d73c5d0a8b7cd3babe48d91f6162712d1470de1f55c4a007c3ea955f13a66e94eb54fa813ae07a9782129b19f3659d6eb14bbd351f1b1a015f2f7cd99ffed6107b859bbaf74806be94f962764ff1099230f392f0146a8b891fe5e5ebdd28903af38effc7eba123a22ec54df8aae7c6549fab64eb7a9c4e6f7d1ec2007886b4231b64113a8b40a43f1560d9e730f5c090e738e29f1f67a18991348254f4e789ffd2e39516e824ede098c8b817a934acc21b1c7e6ca32dcc13669b573ca0fe5dbb2b053923391679c0ba8795cd2bd18b4222ed8b1a23e8e6682ef235d6b8f038eb67618102db75163782f7fefc7479d8d1e234f0a3d83550307e4ff32232858aad6edbc9ba8d07c223415e71ccc3010b18c550749e1a26ded5500270455cf54045285d847cc036e6a9db03ac2a387b9d302007f35100a919d755e6a1f7940abbaf5e75d32cf93e2a88989dd4387978705830eed834dcf1e8503f89ed3d3f8eb7207e655e83ca1e47f8cc574d9e86cfc46c8d583bea2dbe2dc75847ec3a183033ee000c243ded014b59ab24a83bf723de5d31b7021a10911531343f4fbafac2d28de6aefd9e23cc1ded5eb8001678d0e31af0d60d12058097b00895ce696e30b356a0e77fda2864ed2d86df97e9ab0bbc3ae45a5a858c3e762884345b10d689c9533a14f2e5caa64c0f7e73c3df88ccc963f5fb750d15c69c2edea9fa01d105ba720d297dd7c0dd27ef6d6d8ec7369c26e1a7f99640bd826fb2bc80b9469aeae2bf28b1ac417502f147bb6560f7eb382ff339bb47a21163f1d6f18ede5e0fc17debe6d6ddc2626fcdf66d6d8f8e426c93550493ab78fd1828736899089a32b5629411bceadc7f2e76e03c6514fe17a713bf2c6946058f9ddc1005405b6818082149ca18beb591d74d1fc4ee8c5718017cd145703b281dc3a8323dd8e066e9f38b37e89831825b81b95c0403b0e481066e895ebc489ae299672d9531c6d4e26f7294a68e3708e25f8a051ec2b41ea959a945d1e85bcf617f4cd23fb15b75efdb7aa1daef0de784615d43fe80bb3b2ee423c14331163d65554ed5f65cfad9746afeb226021443f804b0f31805788448f9e882c47fdcd279bde4992698d25447eb10c30e372e91a072ececffc3452db5c206a030346e6b6d04ed41317752499e22ce79389226cb3bee95ea4a38160d2ba4ff16dd931a9ff7b969268c11572d84ed817b0b40f970b235cb711905cee9ea7dcb4528e84de3f49891ec14a642ed6341ed811b6b9cd790f04af8307110d796c1b321e3251471a0c0c9d2754e7e414dfee38a62527f6c1ea472cf3a22b65607e600a6a8c103e51c7d3f718107d7f98dd838a79e5d806d0dcb707753a8a0787456c049ad84f0843aedfbdb54a57be1b1d3be21d02d79b452105f4bf39622e171616f6843bf76e7d603a72b912d2f1826c1cea98c6dede388c1a112241293e05684718be569a6ed5b2dba60767e19660d7b01ec724bb3a48393ca50ac6ef3a68c8cf241b46a644a462e965093e79906b916969ebb5bc02378549add2b75c5d5a3d08405b45064b75ef85776a05c8cb8266a056f104ce17876c519057efdf560a17b26cfb681c533be3e5db4d43687250586808179497a7a9ab47c301251c62a1cc5e9aed57724fa5cde893f320593a1e75f9fae7d7b450078c0333404d41f4340f576316a5e6452dc0b11c548ecbd1e45afc3dd1f6e117cd3aa04571fc913b35dfd0f3ec7d3ef667f52f1ca381a158430470d7b96e59c6fbd58273f03a08691ab17b81df1d1ad1d9bb8dbde0140bb945174154e9896ba5c8b320fac99f07c1d9d17665906928894ad9ccf410158e7128ab24ceb15155ea97cac20f1c6405797e86ccd38bfec4df50178bee24c830b71456c83b140b0850e48790032dd1aa4b6794d90b3ec33775ad90cc46658dbb3f2cdf478b6012d264cbbff752e6b919bc3083416eb37df5d8b420dab919507021eccead1a02b14a1cb8383934eb05cc3b6fafccfe28ab86cec4c4e9395fe555d03015a7b69063817fdf995bb8b111e093db80dbeaadd083b13826bdae846e0ebc0ce39ca42ca1a48aaf4753ffbc8eb0dc1d454c9ce5b12608347fda19a798b304645b3aae5862c813677dc467a75f59124c2ee2f1264b1fbd16f592fe2d9c1b9704041093395fa34fe9fac7458613156a1a9d5a5215e1640b1a5ba4fff7200ab8ae2e1822930eaee0bf06069d7448779dc652c9febaacafc530e8ea664605c9e9d67ca9790d055b37759e0e6aa79422dcfd73f8c4415bf787b5dbac950e61b377b8e11225e3e2606510f9d1a29f0a0dd62cd4ac24e51d142f1f61b701302f301c5a1847fdb79d040a0d0e473f8a6685fea44567ec08f3623422ae5e62384bb71088513bf99d90ed42c5ec5ebef079bbf5de983f48f1355c0652546539fef3e0aa3a5cceb84eda32555a837b2deee4e5fa3b46619a1a8e2b84a3cf4008362cf20ecf031081b04740c9624edcc0bfca5024692aa1ce4d7fb5efeb7fa8f954a7b4b9cd2e9fb0768d60abce28d7f3d15abfb097f96bfb820ff6491859365ebd6115b1c56f16042410e124469b5b28f9c2367d386c561a782091c071c226d1a8d1079b3d0a12eb53ad0230126824327e7fe16db91a60492195351eefcee64e186e3ee163eadb90a94238ee5bf3cdc13c6bfb4405d3d3d2b4118f60d6173454c7be547b05ebfabe9fb2f5c8d29a0b96b897242d3f452ea99b5309647e4a76b3527c972e9317923c435ed1b876945bfa081df88fd02eeec8c583a7493dd44f21e33dcc8a91c7880252fbde189348861e0f278c286632176a8e2147bed725af7c5035451345aad1a707f2a171b996fcd6c1b999ac9eb100c2bc838f65d302c83fd9a0539b55e10fc68a2c70c0734b1bfeca5716bee9c57287e91c49a9d3c0daa78d71f507253009095dbedc8f3edd03230b898eac26e61326c9db3cd0423786c731b5bfea9ef3e3db6e8f5ac50100982da06564143edf01355ac7559f6d2e7f04a3ff2e3438833dbf71ea09bf87891593e6d12f4b2a8cdeecc6abc7b4feb4a89be4c84e3f2c14e3c22fc36501f58436977d63267bea738ca16dd3925d339f321bdfee98158c0ce0a1012df5ec47af088b4dde9f437fd3481ce0f128ab24f09f0ebe6e7f4742991e65c5ed4bea84751dadd6b65d3dd74dec28d92735fca4ab15515ce2b843c65004e724e8966818f052ba1f223383c38f603870596e1525fad15bb1bb3652a820c87092bd5d4803d7e0c03d53b39544274968ae0c9f6a94c7b6465de457e138fee72a3352a39154d0bac3dda1418d7dd6e64ff50c9b088667333641bf5a09ab43febfd3088ac041c2cfb45e8db933a2977a512c53a2a87ef11d8c03ebb3d31ca87e2230a8a0dc5feaeb7a1fb968e2e8fdb74c8b672f61699c7e141fa2643f2a4a0dfd2c9048e1113dee285c31bb9ce635391a53e1c82b4490dca529a30edfa05ce04880e66987fe9e5cf5c297bdb311845ea832c5f5fa6b6e96b1d4a3def7c8457bac20e5b602ab998ab1eab2ecb69c0df7e32727a453ce1f75b97d220d6da4cd6fa6ef6d151429fbb8296210757a0a73ff6985a70957288b3027b95c7d1b4378624da32997fc9793f66f18e68acc10925cf1cced00395a4df1a745b4cdcf48e509e8a20d911028bb2b35d7fe1e63b8be12f98303d8470585a820017137ad10a5766c8aa64c2b8cc4fe7ca1bd80b965e6ffb6fc09c3b99d02d94133f41941c50ecae9b11a72a3dbf1adfd9fcb328e90da54cb6fa0e2fa240d6f49dc674804ab811a527932d8472e8a1683028bafe5f379677703182ec9cfb1d80e8b7a14ae80dbe2c48035701cf8ed62f0995c9cf7b318646c961a7fc171daca8cd7d55c5014680019890fcc6aece520cf0482ca9ae1247c7c05a8420f6f4ccbcc479a4581710f1347b4bffb5f26568446c874ce592efa3b9c3bd2c1a1b26fd9674d90e5de8a7d1ca4cfd23359aa8bc70b49e32ba0d68c21a0b4f19560734961e366ca57f1a8da301b4827d91ca1a7ed4ea4186294b60b95f6379e7588bf9f130abc8bebbce56c84198ce9d31d1d6f858f917040510323b508b4088f5c5a0c283a96f28e79ae8eba33d84e03d8e4320fb95711125c6ad23808a742035b420aad1a4d76108460eced2298a103fa7b2bc5e44b08a494113a425f28a29691f4375a9d7678f9649ab46d3399c20e4ebca49992be8b305d072edd053718c43dc08f0941ccaaf3eabea9a17431f14660720d7c96ad345c6f2cede15c1f20a3754dc792022d20801d8b6a2e039f4e350464969190f667ed01c5e727720b26759afd506c029f96827f81e5e3bc9f6ec614223ebcd8e1a5697be7dc3e3334057b849846a6eb412140569e6cc70b0c4b3e97af48df1162299fa2210e1d002ab9574baac10d64a74dbbe97f45cabdfdf3a0f588d1da24c220c4c5b4d48799e6de6f0db5c2a3a07a9ca469c896a2c22931ececf75f65fc21cb96b4b284090b72a2af81c9d9c4b6a33a9fedd60cd275242154ba93d230991e26c5857964968e70dc361d56f444f6dd00277c9dde5e2ff53e75df4677123b69a87db46b596593685a8d54936d19609193d0dab61404449a070d00aa0853e346e1344c6f47f0f9b1066da60a2b53c773f146b2b79932f251d358d846a2ae0133bb62860d4d36408e4c8886cbc702a7240c4cea8cc5ad8a2ea80bb6cf1360a73dd8dc6da52c617605b5817267a8ae0d3785fb9a2f056dca1389ae529a168d23b674d7ee8dc574233948f5e977631c223682b6578e6c56624ada3cd654435985be0f042ab42b079bd1ee6daf324f86d0997c409e18addb5654d652a0756f75c5a6530c5c2bf5ab62f752e66998dc5be40b433762eff8db67b9abeee7cf12b8a50650f001a42eba8f8efe4c0b72a25d0bdb6e57307a6715eaff5e009438729627bc58f662b63728604fac6c2e8b08dc244876d8185cae206105a42b7877e9aa865cc23a9e99c632fdac35492a3a2e49608cae9eb76930e5ea43d5d94c26671cebc17ce66c0c908095f28f3e6c5f1424bb413e383de489ca1b399c36692e5cd434235dbd6d4e9ab9b3b77da1e90f78fbbe470d042ee463151e228ecca4e2e834a21d9cae434cd848e18f1fdf2d38195ca52f28706040eaf2d6daa12a6cc1caedf2c07b11b8b36df3f60ed74d7ee9d7fe599af36c11144e0c9f0b6eecf18e8a2da24df7de01b2543869614a530d19160931c48c0902085a204c959a274f1f47496d1c5a49369ec4b2f292a43d6479d983e165fac8a9d249c285242e41c34dde06cac87ecf480f5e0adf09b7ba86d432f12b65125bdcbb9b25fde30edbc800e7c9b3cedf492a89cdaf6ca1071c324265bc28572cf8274f9297ac45b61bb81777c6af7834ef97e7a84d3669ebd3df7fa1f8033a61ecb8fd4b333197530cc2c7f409979d2e19ebfcf10a6bbfe819e7f0c8fa06a92fd7d5f1aaf308a3a98d3fc967f5d1e4772e9a4fb92c7064aeae759c646ac3c756726a949787c98dd42f4257baee49f8258486e573e768b00b5a596da425a084cde57f64d62bfa15d1007cddf8e9730dcc63bf6defbbd982e43aa083ce4f99d435d7aa8aa0dd8451f223da24193df15d187cfbb0d52f00d5b4a82fa183fd92fa7923be693bc4d7ae988a56809867948355ca8fae5e74896e3dbe5bf298a40296c46ab8e5b8544e560e8c3decb0ba4322ab3463fcd19cd02ec5a2f6395e3675b7162ff5f3d33bf93de70e79c31d56921693f17b0fa9b3c5a3a14ad62806499884290325730cab1e12b2f4f93009c0b98dee0e0e37453eb52b2906d4f16d3fd5c7f0528f37acb667370d56d174f56e0db9b548a96914c6b5d0efbadc363a4a5541c463b6d66dab1167cbfb069120fd84607db572ec07b96011daebe2a4f92b03fe01052b80adcbf2d53b726b6eec1b202c0094513467e59a070e20ff534eacbe6e2e40b0e40d0543e7d48a6b02f41cfc8d9cb863842d2c712bfd3a8e5ba360ba7bfa5986281c6d99b5d85bfbda9a6e367d965501d3c3033def2d973a88f8776bec6913bc273bbde4df4426196b877f1c9eb62b9528371ce54c3f154aa8be305d8d09b36e856af5a7cdd9def93834fea9487297b019d5f0be1f631b259c25f88eea6e70f3cdebf1d5ad46ecda2eff1cb6db23c84fa5ee7de015c4121d0e47f3fe44bba606d88d446333938c9ad95846c45412caa30cf8c7bfa6445e15042fb6f1860447d5a82f466b773bb523e874d3e530354fe1fe9cc798cda4ac9c40fcab3b31ad832eeef38c79a8fedd0a7b396ba2b3e53d9527f65a227586888312d8d958c5d1edff5fb6aca46690d1cf0669e2733f6edf8c9f0429e757584c8e83b0e48c3e0b3b1d923372c2dd068b8d95031409ca915d3ecfcb13a4977a9d55df45969337f8f5258105be7f80a84e42b322bc6287efaeed666fc9825be222aa9105371c83af96ac17e875fe5ddff34ac93939c8f2edfec3b37fe9cb01b120c777eebfd8265ad60c845f89c25a26ef4a71efd9c6a8521eeb64b5c736e502409bd547a1b73d4ac38064aa1088ace7f1d3364cb27cd1a624fd7cd2c580de1898f979462e19bceff9d4ca58b264b36760219032087c82fbaddd361212a8f592a92fce354105c066b9f6b90587c1de24ace0b869eafce0ce154d115780ec9a5038aad5a3964ded330283738c16a3bb93ccbd25532d27a67953325689521ffb974cae4b7048bc161fb8e8d7bb5bbb27e5fecb1ae7714c8d2562ed57d27ab96736a7695a37c27d6a0e6ca1e97d951211ff5f6276a3e8f18fd751d76dd70cf61c8463de768bce8601a235eb196abff2043d563a174cb295af2b596029990373bde4f7435a2b24e3ddec4eaf2c84ff220165c84fcfc4efc0283d061c88383d4f2f7fe5fbed7972c81fae260f276cb97eee69d1b5937b4b77dd84000cf86746e594bb64d1d88f68cbeb22cd3c5b901c848453a1109f9c376ba3e861b28852055e1716a648f682dea2412ae295a56a42ff203006f810e5fdf788aa36f1876dd758d3430110a39fe6e0e5fc79f43784803d9732849dbd7b852a83c22b2289edb5662fdaf42e3548dea56d4631b69d8ebddfacc0e28885601e8f2ba18d03c78a2306504cd7f744c39c8e871c882f1ec58e81950649b1e70b6968c72376424ac846a2293f9871d7bd09fa7be15ae515a17dea0aed29f7579ef0b9d3c6d94b724b92d09f72a596770d52716a60548e9c3bf13d1a0c167dda40b2a376670d1ffb29a44b9938b16bc29b780736fe25cff1d2077cebd0a869b8701e5e5a5ff93434b4716b0db1438544df59219299e55211b3633f706051920411ed6df7441c3e7c275cfdf597358dcd1fba62f4854fc1b8973f0d7ab430e4080abd0b45fd7514106534e53da9081c7119fce813089efb2a38c0133b1fd357359db73738062eab32c38d01a5ec14c803d8082eb68308583edd122a2b960859624d8e61f2d101d002bb7d6b3291ad5e30ae01e3c055048e2d92a4b306faf5a682afbad4e5d16e0eb1baf7c23185f080b9d64a3ac1ca98756ef9d16d084fd97b5c1d2d25e8603838088db5c8523101c18bdfc19e302ab2a651fa59cbde63821d82fb9861ddfe9c0818901d148e7509ef7b13637199256616cd4dd5fb86df8e8755be79f1abb3389359545a16f3c09ab81c5cb87a53a34805bf3293d8f3f9ec7d6772064db6ed729f4825563f87f5a492737b65994782407c6820a79b39f31633791112e9741ffc8c6015a49155fa59603dfeb69a851fbe3ad455837d24c44e774bd2083519d9bd3859b53255c0aea41c2b302cd0d03475bc19936132076ec7a72d238eeb76dd318bd35a4dafd179a8a2389204aab01c149cd2fb1824e4a0e72ca862b033df6c4d5a2e044d18a022c6402684e2f94b84fe1ce65c1f8124face8a664c1d02298f57c1b11a723f2e583566065075c81684b6515ad800e0737968e59ea746a8426d049d6244d7e8ed228ad011d26b5ab9edb291a021965d24c77e004995ec10f197416851b7c49c1d4b585fd43c8a4e2bfe6bae9c683fdd75b35bb7e5b8e7cd0131821070de4d8905b9fb3224665060d038b5a81be20ecb8b8bb9dfe3665b69d724e10ae9e87de943f544dfa785b7d04a60000f24b922a98d6d8414afb4449bd93c93bd351320ab05f16c54f8f6a7d59f24be0b85b1c27d5f79e33bb12c46df3c73185c683d4f1fc5fa79e938f4f84c991c6ccbc8f8c619a8ea19e38875dc7a16b47a7e1ab6c8244a2d9d7269f96821727b4ddfbc9a761dd888fab4e910a5ddad0fdf6bf9a0fcfecff671acee453328d93c1eb341fdfaa79f1ec59f209aaf1ebdf1799a31c85487fefb4e01e33c0d3385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
