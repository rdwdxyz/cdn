<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"576785ec7cb46a237425c307d957470d731ee4c506fa1d0a633226d8e34eb96c1b2e1432eee5a1b38d2965873701db12b3313c3218c9cf992abf4d52cf001e0020eee344e2c86413463f610be00898ef4050f1ebe285fb943efb3d4831ce13e089d5f6283881f8f776f5f1672f9faee7518d853d3a36ca64e1c838a079fc80f2084f67e7eaedc866ed2ce470ccde0ecf2a4d7813fedfffbb63c17edf3021e670bd3c9c7591b01b5a147870670034eaf5418aa083d34ee3b75bf9be9909ba558e2977a8c6bfb81935632ac5bbae958f8cbe3e52756b26445486e1a0453c9c0fccbbd9fce109244ffd90151932164e19fcf017b99a2bafdcd2eec4af9d78519129063e7327c533d2786e9fde88796add99b77ea025d8e7fe98109408206387205fc85fcbf4fe1c2a936d93bac6aaa6645b6e09b86172052f42bd2c723c2f6c306269fe644d8f21d925b13e61ab08e50fb8c2630285ae74a6e48823e53b86dce8abb3e6f6460d9165b6740bc2f81fb4bf23aa02c1f2871b438d288e4b550e41569a0707f9e6ad904941a0c68d1c1c0d32adf7ef9674e0f5032e164458b3da257a19b448551da13ae09ec6dcb4e61c858371a14d4845d999fd847c28c5d4a3d27cac68cbcb8b52dbb59dda3333a833eb62a33ef92605e4a85730c49b119f0f4a8b5e369063d62f0954ba0f7e0ff5371d4e97af08378cba31ff3e81892dde5e254f917e317f8475559142393c4f0682618780f4ebffd97ddc98046b8c71680270463b856292aea99549a62356d1290cc2091926d558a4460592d4dc0d16779da58a6ea95b30d7a81363ddec3cd92ca4f017a340f59313e62ddbdefa5d2a0be09a952eeab1042737deac753703836a114e96775d33236aa14a98f5d8c4bcbb408a376d31325e366b17bb648d87e03e7f8bafb2e3a84b44a93623819dbe58f6494aae7991f5a6984622f26a600701f82e0a0db1cea1c400a86e72c19f77815ab3b4b99804ddf668e7cb8866dcf3e664a25d8f0ec27f783ad390ff81341a42428b1ea2c6bea8945c02940cc019fdfed36cb8642be88b4cf751b43eb100705cf59d64f1619afb9044396092bd3ea9b676e049b03600b6298eb67f15ebb418c306a009eda9df4d0c9d49a59dd7cf48df0bd2460a69ff4273f5c353af60da628b44202350688e1117dea3961cd5740a6aa892ba072307e10716db1b8b8bec81c00c7a40f94080ac0c2a3a5b3f57244ed969d3f2d9961c27cca4b11155afe22e3023942c5c75888b3868d5b55243bd98f1e6732f4150a11d309f85a61c0ee49b5e69f742c02778bd6abe77e7c9f0fa8ad2ec35523bdeb9edfa17d6cb4c62547d94304343659de13d0c38d9425f8929d3536176c9013902e0a4ae530e7f7afe9a345468376928a7bd357a060a3915841ce125efc0a2949198bb9ac21c721e9e22211da8c8af57ab43e681a14f8485e6c9533745b24cce5bd3a7965a4d26fbbd44382b5e99f90e6996b503b67ac00b003015bbdc52c394359930048493fef8af4729ffce273ec03fa98ca747ca31c0321a1e0faee6b88f74dabb31f23ac2ba1a7dbce5ece1afce08251b1adcaf80d7cb45747aafd8d0708a5422ea59e1ee86bde2cc21a8ef6a9f176553b2e47d61ee510b7ccb0e76b03e807bf904b7b00078f2e559fb90557ac0487c8422d6c476ab63ad8af45e6375376d0f0b3e4b3c5de6f1412107872ca4f6e93685e5410e17d781e767aaec9dbd8858cc748a39f4625dea5922227a390e07344acb720cdb1b25de07c139993f1f4e1af56bbec2acfda9a777fcbc78180b76dff4cfe8c9a1790b3f53ae1fb1b256aab0895d5f6f4496b2ca285cd06192303ea2926c7986d6dc41adfb57c8df475a1db51b3b4023466b3dd237a2345bf4c89bcea7bd8ea0e2a9969e86e91507a0b11857068ae83ff3e9177427a31a1bc01709e2f4cac74bfe66c81b48ed1805a1860a8b3767bb40111f7fa87d192e1b6d932f2670ac005c2b0c92a9307a3a3603b01e5932781c535d891f1dfdc2abf4a82134efe2d6ebf07fd8877783580f5f76aaf806d5a15551bf75d58867fac0f496fd3415b09691ae4d638b8c68f6d5abea3cbef741ff9498f3e6aff7e07c23ad1f48763b439ffd51cc2170cd4561e6a29a99d7f99b6f5d8a4de9d1994f3f7cfb8ea9d48f1526c2e7622f75f69b046ecfe1c63441831238a757e17db4744e7ef6655b009f5c5a28ecc8853cfeaa1b50ee3a953295796d21a1a777101ac5c42b99c8a5b286f3d1166e61a66dfd288d46283fba45b25283bd633061de92770ea39f2cfc8fe136cd71083648bc24a3fbac1d151b59adfbcc98ab18345ceba6a7a19bfcb394df1560a98b046613fa244766d9c7e799471ba8828be0b359b84d1099ce3697e5bd8f212d549b2221dd8ed5479658d0a836398f017f4c9d1b03e173f366f00c48fc8172d6225d2195559daa2344436c0e67d8d884f8b5b732d07a1113fc5b50d1cc6e991e66ddfb319cd9e4ecf0da98aeb70823504ec7419a7f56954bac8904754d03cedbe363b7761ab8448f6457722e197eb292c6cdc695a1501c07f8bd72eb5cc4d54e32288da9be319025b23b6be35c433475bcb337d3da8f0abb1cce3089d03bed96a8c78dffb542f2c96d45bd8a7ec6f960c1e296b28e4ea4d90e41dd49aa940d43562685b7f056efc29b58e26cf2302d56b5fae1bc0355cd647634accd060aa582f0c7bb948d60abe7d8daf6b5ad14bb4a4c889fa9d8137bc735c666d80003783c2ce18d2ec728ecbe2112f5156534d1bb29b9acbbd4da33f0fac1df975f329ed3c52b422fbcb0acdcbc9ea4f046b1a65a11ce35bef94d7d1e1f51eae2f178b774d1e2c4c87702394ea81b8b0060c364a9e286eaec348fe8de1bc3258f152a2eb62b32a6a48ccb0e6afa38cec9651641411afc0698a7d441db8a84074fc4cabcbb55c319904c79fbd038cd59fe5492a01d7fe2233d4408713384ae51ab4d7ec436311785501739383dd63f2257b00e35d56de88411e989c7fa09f7cfb95dfc51fb08c11faaff71652627ab5484ada588e960c4f9870dec8219ee82cde4c810c148d190678337651e8ffe679ad61f6554c785c44cbb0d9bc3b5e6effdf2383212d344eb405271d0110286205661fd5930ff9911a0efddc7f8cf66fd3d53cc10a8898808e8ef1e19274bc01804e0f6635bbca516c836f2da5c1082fbc3560b8fe888ed18324f22b85e2ac06cd6aaa38bab21ee4b80fe2687895c15ace22e0581cb6b3d5e0cffa718b74f3686c6c133e20bebd1d9a2c3fa4d43b8f75d2cb76aff165f7283daa9920c5436a92b32255f5263e51726d16c7f115ce2960844b379bc39a28e326a3ce3656ad26c903be75454ff3f326a415ea189bfb850dd42ea64018035a9b874e8ac3a375ada35a154828ae2e039d541dc8816a1b3f35e6968ea43c086117bfff414fbae7b8ad14eee5bf99a59db4dc3040d9d73207f7e8e7a918f1e246632314bbe5e5307a0e1a322964e3d9cd051886e8c4235ad40c222d9fb7d61ffb74716e466b58d2820d07562cb99a31afb679b9c4f7b0ab60f54557c241bbb6da9717854cd1ecae7a2872aa09c9d5d627c6b55ffaebfe63e6a3612100a8d41f331fc957a427d6cab3733623e48949f776255ee884d59b21372baf921a859a519718b840f1f332139479a9d2c1e8443b45f5dd1c642ae5ca854c1c2fbee440a0f734a0e9777bc0daaa860ae2cdcaa53db0ac68ed8de3b31dc703de6cb675d234626b5edb6936db2be27a141e8fddb7688b3ac6184b8a4207990dd4a6ceb06825dd47603e4b6ca3c7016a0d9bcc8f879a1bc4a24c426a391342c6110b5f300f1b73a040b17703a6efee08b78c37dd3ed0adb17bb8a33ccebd627a5dfca868784e21297de505b1d4f8c5f5ca01283d41e61604f9c67a494de80c52403264c8ff8a534a3fe39b5145fa20b9c5e75e5349943636cbbd1e6f1daaa29a9fe8e63c9fefd3a4656fdfb06076a3c28bb8c896b944cac42160df3105266f7a1c054e7d2afb6a812b466545f8a7162932b9112699a8d949a012cc45bd9e65c0057b4fbbea157fb1f0c0be555d7daa792d7d25617ff41b15202859d651056736c599b1a8b5de12464e91948132e8cc093e99d9cf0fc4b0771302fdc49c64e689bfd2eac9c5da2fdb1f7450274a2ba696c628a09be1ce5dd3e05f0f98ac34450825f0f76134c93ec93a0e19714f9b8a6c1bda9e3f8bb4f36a7341ac8921270e598bbf455dab9a19b22637c55fbe84814fae9e978c3fe21415d0741debdd086fbc51fc22cf94b422b13f19ba56f623e61f78d29a17092c528adc5e281a71f405040f30db7743d27b2b848b9de852921f579616b9ba22874f981893938ae1c31f8979659c5845ae70078463bac92cc20e707da7c93637b2ef6e2a323cabc7efe9c4a3f7dc16964b8cf576bb00959355340732f7ac3e18d2fbf9874d9f83b09f787af401a460a02c546e9bb4769b8612e237d933b1f0fd29fb891745966ab918e761635fd5b49383ba15593ace1af75dffe383b6a5ba6cf72295b626f9e0a9549b7e19f5febf60a153ffc86a50fd4a6d442d9add8e0241388f873bee30949942bfb24dc1bf7ca9bcbf4350b753017aedf63b29d2c748982394c1fb05ef1c004bd01b129144b1a1f23193543b3ac2cda59a758b0e9c198fac64ea0d3aa8002508ef07d8a1972576d8d5aa82bc91c58d9a8e33822b26780c74a313e5c562f40ac1895c8492320ad803611010194b51f460b3c6a3f9b4c03533bb851528f70c1e323f1036a7f44377038d2a5819b4ee97f3897afebd9e98b1fccc702b8e6ec5a74bab3a6f92d17c36258b6831508506822c9b259094e4e7cb472a8ec173570dcbc74e2546ee3925ffd449ec5e5d8cc7aae156232d5de61b715f70585554a025fb0d798c7a59e8d12f5527e8aa1f2251731081cdecd279c3c60d0d2dca05fee4dd61ca39b5dae982fb5f40d3825ad69ba6e8f84941b3bf815324f26fbbe93d5499d944708715f143f16bffd0862ab52b15bdef9ee209d014db7c333fce13e293da2ffc8da8301d1330f0a329ce298420beb6047bc4f2d995676992bc9d6172f29b4102f9f6691d12efd5ad3fd16598a1d0e3f2808bb49ea4f6ec63cf00066d81909f73b6a646aa3284a01c63ce54f95a0b50a8564abecc2ee18c40eea870979487271f918b19273ea7ec7db334d6c90ad4972462b0696fbe6fd6cb7452a1482234f95d63d1fbf20dd901a6f1d1018e1946451b5de2e2825b3aeb44060b7fa56dcf41e04cbcf1bde9e6cef02324c54865cb2a0f5062cda6e44bcb0addfd5e4305d981cf7b92e1b28b52b56004c03005076d8223eb5c146704e0221a0355a40e4b456260c18044af50962aad64a77336d6e1cd6d4a3a77f649db4f2c4b9955b25bb3f0c1b46dcf87c22daad536ec61dd8367526e204631f9403b62aa43e9eef4ab1e1db42db5eaab84cf68c8e9b9a7fc8c7b1906fe34fcd8eadd64fa1971952eea45954eb26eefc2a92c8bc375377ed4c6f75ad6456b74001d3e8adc36ff313a75d276d032367c5ea0016d40d56310cff3d435f7dbd70607ca7601d213369a6ed3312ad02ad33aa76fa8a1c9def334f61e3aab32b3e2b9df21e61c1ad4a4b18ace5d8729fdc979e2038053c4afa031e4a2038cf0795ad99fa7dfe9c6ae8f63e9eb99b8e87f4a2196d1f7395fceefeed80a12dc66e3a69dbdfae629e41ea9d074032a8189a80907da093aa02368e4b494d26ce3f951821b4805c743cc19ff2a100c53c7dc9d2e235ee677a17d19cef50bbb8cb64aa72badb7c472f6a3206402d1fb8e0a14283b918b3a9421bbe7569323d71a58540355b7bf957ef47647b3545252e1a69ad8141802002424545b26d88e9cf8cf927789c1c16c7a0313a33c28851975aa6a8dcbb7e243783d649a1eaf286bb6276432ef6a45f9efc8eed667067969df66177152a0050f5dcf9979a73444eb32cbeb65df030a2e1b5189f6ddc4384c0645f43bb21f77df14db1f853f9c8d3d736ac6b9977249a2b139629973b3f8dbdd65fb59d98ceb82c0b8d3c5eca1b2ca146ed9a8bd41b61a3fd5f11e9d42b7d8f1dd399f0d807921bcf722ec4cff2e7751c34ba0ac13681dc9ab53f5aea9445293b1da12010f421d1db95b02affba62eac3eaa1014cc5202398cae569510adb4675ca8f9552ccbb78307805ab40770e7dd9220d7802bf2c0a8f0508b5cbe8c3b554d9e69a4e309df0088797cff33c76665d4d5629d5c070fa8aca74c0519b0486fd86b06512e63b541feac83edee52b1dac8df55d82ab95a1d2dd1a1a3f2b1ff6e531eb15c369de174ffe9181cb47da7fd5fe1c199ca4e0940e40a5f5f392a976d187c721e895fd2997fad9d3f164b6e26a15c86a3480cfe79bc1b09c4541581d4b2bf23475f368d182b57b2af61909cc689948f719869e70715007e7105b0fa76c6101ea64e70f25c4913cfd389d90b5b565a160e441324cc7fea2e1fcf0d73545a4f045fc86f72e88bc561bc7417c9aa9bf17599ffcf4a5a5d38bb34dfca17bc2aee645a81c0aada08a7879d439a907af8b19f6b6515ffb00d035b0353b28b2fb46087b0896f551b258628109e4e3d9b6a9641125cccda72e84ba4b7b12736534f1e7f8ae39d359fb6fe998665c167a02467172ae86545add9baa5f5ebeaee78451ec2900535a6792dcc8a9877b618a7fc03413625c031baba87ae2f44db99e7c0a1416012ba3f1a8111bc705aeaab5e2f55f55991dfa1fdaaa266ddb6eb83ff7b0b3848151ba660ff59bfa0fa2725f0a3c49b9f0af94fd7bb2d0f0368f4619ca519bf7f95ec60f9fb4517b33560cf3358d5450d5ab7a0598c7a9c4827e82c6b6d08a35a7aac00374b534bc859324f72efa20538549e80bc166c2b99d83df4b0bfc41b0dbf114ad19ede1825da8867f54ec98676484ffe467789e13bb21a083741034fb753360547b8d006f442bee4402ecd41ab4b73d34b5e6d57569ef3af07a4dd4b0de5831059b25e6a7b9327fd170d505a6c623a3e9db780e1b77e8acb9a7519eb5e899cbf4795876dede5909806d77b4c3d4f76cd39230cacddcd03dcf7236614824d22f18c621c1b20e1ad84fb1baecd98ce758c8df065bcdbcd8eab35d80d8cbebd44194fa37792d88e217c3b8fe40bbc66c120602a5c88490ee9506c3515b9225e9f2ebb7600b1e672016449ea2f9017e824e17c92b1622fa00d025283f6eaf96fec2921d649c7c7db0f18b14514a73ce1b79dcd5f7c1af289dd94e50929dfa2fc835f00a3b8b15ba37593656c6ed86b094824b0dc319320124e037fffd53ad60de0560620cbb92d5319a35fd644e3a6b5cca622536c0bf0a9067c8356722c520b6e85ddeb769ae34eb428bbf4e2fa7a03ca01a619632b1193b9030b84bdbcfdb3d187b976ebc18ba4eda0bf18c04cc5ac928d15c40437d739a9bb4db6f9c62fedfd9845fd348676068e197cd331853b98f23954c80e0b79b43a63d9fc5991408e3e298adc96ac5bd1a1a38923bff1e1184f5ae8ca27c523880c894e66e3326fc857b4f6aedf6d644ac0edaed17a502964ab51b4707b6058e413cc5c26f93884ae6f729f774809d0324bf56ceafe22abcd51c404d628d44789ca5a2a16c27db893d5d63afd3ac1b3c5729ba6b7851da3de84346ccbde618232804fb5105b9278d6b4ed784fb645438c40b9a3190067c0611c2bacbe23cc18aefc8653c020ce3ede0eac4ef7ade9f8e414225c2e185d103aa9ce39047b963eac03918d9288535c90566109e83cc236e6c3033603d44ddf7bdd8e072807287eaa1f4e5fe5bdb027e84eba1945dc7b60743d1532d13bb584e1ddae927af7405716de5035e7c8c90f694a5108465a6e93d85303e39e7dbf83b66b4b43a1744a4cf7dea1f7089a261beb188f223dd387187f91429035ccd39bffe3d15cccc5b6b553d935536d3edae6d498c33486686e8d340123d6104c48c303af492eeb72351c0da305a272956beda706478d9adfed61bb2503f4c3155e5d367f9b8eba2b69896fb51361f3887141aa5ff2dd91e47482e0a161ed95f32f49b6a46199f00633b2b83597d3de19213d83b3c5bd8b90c9897289d6a9c0dbac893e28731cde450e5acfc72ff08a6fdf66f80315d1ea7c94daaa85b2d52e72b860a444388e075bc77eeed8b4cb5c33d7b0ac6f19499f522cc528665ed87bdfe78cd8f2c153ff92a6b198a343f22e569d27fa38b4acb108432a1ab77bca1cc15a169214cab0d0d719b3696150996c14e3d3655c0094fc7315f7359346783240e7ea86818bea098663d25fc5f1cb8474e6c2a8eb4da6ed970663141937af45f591bd93ff99dcc3807804a7d7b20775204cf11a4160d442c311b79d3a70beaa44516828127e38bc07ff05c926451cdf55a4757f675addd799ba7a2397c6d43f479038a03a7b60378ef5ade30e80d13b12db0887db84a1a64bf354b60256c0d88f5bcc3a5344894fe7da622417d304a1ea82e9e9ecd2a5ddce7dd3cc2c7d0cf4fb95d8a5f1ea9db7d2a701e9551d1a1041da761e24eeec3b2e3ce5bd24bba455506c2b9e9a279f5a0c7c3ca0fb225f946b85dd134a7d0c04c390ea209b8e45755a9033e9eaa8a995ea3b62b027e2c107615ab393c92f0a46dc799d5d4c2f54b3f4270eb4af36292f97a4f3b9619c5a6337e01e5909dce54d5136bcaa0de31e350e07e8a97f66ff665d34e5eba6c5cfc5568f17b187d2164c6d9ab0bbf6ebf84cdf05c709fe43504787df4df6f250ae8baa6948a5cabb4ead51f274d6f2959029f398d40f9bb975661f4c7dc00fd14de765eb6ae0f62136926c356541a7d1e22da373325b1e07cacf21ca891d097efc4ec473cee50273947ac233e3426ce749cc4800fe7e4529ac80df5bce1d7c673d32ed303aef4cb84b364ec953d02dcb3c7a5c04fa5c2ba18ae93f129f9013086a3bb87aa052e3909554682d8023474915ff7dca464d0787eb4949111b5a144ef0f4d9332192183a98af598994749fffbda7d76fa160b1fef29747f7a49b4110847d8d5a801c6baead7023b366c8adbb44c052df3e1f795ee10deca243af01c69849ee8cfa0f27d3d795b0199f9a25aa4e80f6094b3efdac7ac3bd340e7e3adca77fe5450acdcf27f5c254fd3acffdb4a7cff2d2261aaa7a08b145435f6cd631762745b150d0af8f53e4330aada38ca5a20d66e7fdcd4083decb64d84cbcdd300f3d7a839e0f8b64e0c3a5c18978766735baabf10830604ea8fa05b9612d2ba213f1282ecd61e5f604db40fd227a4426d91109e3a449c10cf138b7a7a642638721751363d9166956f391f46fcf77281ecf4fa2c078b4658c9eeeba7b33798d613104e5c5795f5c60d62d838d894fe5676e5ff832dbb8d31f7db7520c30ba66ba9144a3c82df42b1bac4f606fed59ed275149f7e9f2a2e37195e7361ef391d1f5ee8943934136e05faca6add35a979c9eed33fd183b47849d571d524a0f926f878eb5ade370c1ffcbe0f04c363b4e9c124db86e4b1a92017296e81e9b151630b0a507e7d6dbe39e6da87638b73c0bf0db63628d956da98603a789a46b1e40ca1b7ed2245c8bf4da7eef7e5de0d456ddb8aca988dd0d7240db3c235526ca8c651063d394556347b2e2b6ba0a2b0704bb877090c27133007b0e4a02d41aba0ee14591ad8d8d2fe69b4074772e530e7ddcca34fd7bbd399bfa6289ec935afaddf0b78e3b8bfad61b92a19739904fb72bb6e3b7363a4e2874de1cd6e935c9d106ea712cc1900fd733bf3ca8dd2962ee775d1ac0125ffa0e1132df912ea3a6ace30c6334ffa119b62b3497442d2700504054b585ad9ad2166681250a8d389b7000196a4ff10ca37caa20a5c3ae3b88a178a9d2e3de756e05d67783dd2687aa7602a6dc5b57274d05aeebcd9ee18b98f9326c4e7ed24d64231efeb24dd513f38517e01d99fd02d4d1d14e62d5a5cfbd44102a3c3a3a26469bb34a3936b2f33c15361e95dca96fff706662b3d6b540b6e9ff10448a0ff04c5c8e3955423bae7e045d33fbaf59b868254b39321e7853d17987ea83ccf0f42dd07047e114068ff3ec54cab9fa9c4b86158d0984fcb26c6b8b593253ac647c6f64ea9c8b1dc08b291b81767840d62c43245145a3417b45b6ed7ca39b7c11ceba963ffc6a8b0c1f7c09c798fffade869681be01acce1ee82807cc09801a7f64522889962bbb0df59219043c473c2c6926e93bcc186017dfc5b26014c91ed730d809acf37b7f52549b7255f67db91e8fb8bfd29d3e3e4a0ac8b1f1b648ff535519d182fc762346356c8e7ddc502c1a20409ae0716f45b86ca68b0597a43e61acaf899481b96bc45871f2d4880b7e9b3f1da12325b39a03e510308d8a8550ed325b86e1781c165f406fc3969fe368305d01f3da03efb683557a3a38e95b161d727a02f3d0c87a2c5ed03118d577f16a38da238c20ad8bbf2d0700d501d41a1e8547a005eb9c45dc030f17802e3594f8481fea37b46a9ff4937d0e6094a56de131ee87091c8e920621c9928752cc9c1436055a5f4f4048681df8c6360ca479a16dfa84640326e0efc3f158912a973b7fad007cb2d33863d3c3237228f1041c452ff964cc483f490ea7f76bac54b3565416511e6cd9da8b8d8d6d6ea62b827875a5e5409fb3782485675772bc75d4c620e09ad5f8f70ec7aac8adf553607f78ce686ec4f1eb18f3a5b133b86251ff2625e4c591bbbf83029b65f109a4239489a411c976918b01867aeef35454a73ef1a0638a72d3c7fd914763b1449f2ae007c9df03455bc197ebc560b9f77de3abec937541d622d1898fa33d040b793f99ce5f47e29eceeb533e162ffadfc45c3fc02794f307974620ba21e38e2d11bf8f2a0f65fcda06e2a30a72d103ec1782685b3074b9e01061d0e7bee6192bfc902bb8d2147dc0d975da6ca5e7c1607ba2acecc96eaa62ffd1b857e7c7d580b103af17e3bf9cadd9ea01f0c01bf832f52a1f7a7feba40ddfca816551ddf88449145f6682bf4d2d6a12240211806c6ff3a3a21fafddd987a5b8a42684ae6219373166d9c88b382a7d3bcd14fce1d635a67dca27e3558aebf9d1e75729338e9729c6f8a74dd60a2b8c9fd29b8fdbb03873ef42843a9f8c4beab4e75c0f9c09497694203c6ab01c19021c90254a9be260b83c717e8910ec708316656bb73d79a50fe259a6f342dea7ab51d7823ee78e2d78a45847883f46dec6d71226f0fc8ffbb1028b368e34cce6f4cb52db62180a5d6e61eb588fc4883d450b7dbf9204b9ffe160f46cde4f5d7e37524a01c28d7ab8aa9c6fd795616d27c34fe044dca0af38eb50ba2233d65cd945a8d9161da96f10e8b32b94cc072e715c224480f83b0afb17a5710aaabb5651fca38d5c71128801212d182fc390ebccfc3b301df9266a43fd51ef82959968ea96e808dc11bb74f716b3235cf26ef5d9b3c85c44fb2fce7a2ef63cff7e5476cdcc826eede0528b31b6ba55d235f72c10a079b46ca26d5f35bc9a6202b0728e61bb3ba3df4539af2f43e29deccf13d3b41460a8ebb4e9fe5f967c3a330c84fdb12e0735985f5bbf4c400800d5ccd58a440557903c900056a9c85ca7f9f5029214465944084d1b9cf7c90395b0f0c0b7694db4a626fd34ece21bf5981dbb20cd74e7b0076baa29e58f0e199c70b8b1c5c25f91a5ef347cfd11c0fe19a2c7f85fb96f9be80238822eefd1704bdeb490203c69257a0025b97d7a9ff267731f50e0d0802b5248ef97ad1ff449ac7a7a25477d7c019442220c7843b7c429ebc6e3f0cc52e809f2d83812c094f991ba3f994345333c21f1487e654381aa09c7a7d62cf2a8e6a72edd24c817596a3f1121ba0b5b4c6cf25cf514a2237f9e58fe997178edf72249a677186f044a987b9732dfc125df84b1834712cede0412e95133daee07ea68c95e1bce29132b8d3da0ba713e7c230fb81454613bf6232053d369c72c3ca8bcd02500c6433a1ec3a9ebc90b5b1198e4ad6db300783e162cf1ab763770c095e9d29f700cdad4d524cd6363a77e6a346fc0f01ca19bbfdf7b119d90fb33e7807c6853aa535375caa3d15d12cdbcd2cfd80b524bf636f8db530537a90c148f44887fbde7656ac979f37de97eae14961d25e70faad28eef5ef5c6bc66c0cf7329d91a90892de10ac86cc7080094d8203fe377518ae7061de74262c2c906be46b177dad95dad1097017ff47192650653a3b0b57b1c97b09cca91520b80860c94915b61bcaa98ff5bd4d3b503f0de19d32ff3b0b8c4bc29f9ff60cd6d3fe47632fd5f2adb26471663cda9202507c74b5a54a915d0b734456dc6ca8873496352901b851776d8609bd07983e32230a66d27f6df6e4e8403852b2f09193fb9d86beb2fc592a078caad535af66100f2e73ebdcc95fec6ed4e3de6258110c6409bbec3f054b397548acd9a5bf8b2b761bc7d94ed2a4bbdcc038bc006d1e99b0cd9293d88d48015877a37e111ca68291ddbb345f47d6b696e7e1dc51eaea89236ec6c266a76cea23cbf4a828abbf3edf7d08180a6125abc741b7b5d6eae17ab74d202f9a5eaa30419d1b40563da7d357fcab82d2a22fd99175551a713e2bd82c6277950ad5d1110a6797eb10b5597680152694091941b08599c979367487c687d05d0b8b44ce59c7bf32f97a050fd59918822b17bc3347cf094e414986a13dba3e776321337912bd4e92a953edb4831ba077a41b004103a15b586bca96bba5de791d763fef1a54abe402514463e57faa4efea5c9dd38b1c6c3dc2aceacfcaa2d8aba563c7931ad32494da4b512c486b9ab94eb1febe2bd543374e16fc308bbceb8fdb4d69e77fdd6fb32794487ba5fe428f9594af1f700d4b68b96073686675cb66fd2473a1314284af13439bffd6d403d2daf832fcafc7376e80081effd231980b9566841c4a084830ff413e089aac22900a4d9e222e9c7919f58db84cdddb8f9edd400dd7fc65135b472ef25eb0bfb3f34f920727ed1ab01f1c90dbca4cb774947d1c1acdb7704e08c0cc78ae54c162606ec76bc1d3460f0fa0f779e57bf9ebba3668eaaa7dbd5b96a95f45670daff1ba892ad6afdc7d609a5e5f98f5d3c95b40ba553c6e6b2644e50776da9ea8de2ec281562ae2a553b4ed877782e99315d3d7c3abe25b013768330fc2be8740a8a06d4b5f131993369c96735b77b868458f8b5c48e2d08cd1e6cb21ea46538bb470301b7599b6f1266ff244e533543550e0474150f1dfad9b4aab3809c6689dad6254b72fbd8883b95970b0bc517a0ce455d3d6755a7a135713767aacc2c1a26ad80193f1cc156f30d333769a0ff356eac547f55eaf74aa2dc90b762bd616f599fb8c23f4801a8c072d06cf4f55911030a6f5bf4ea7e3334aba51f74a9b2a40707a0f295814fb42ea76b63b6d920b959c6d27a035482db8f11c00ffef81ed3add1ebff6aa451c1dfab7783f0e776fda1a0136d5ca1728a8193d61f09338b871d8d22b3d64275160eddb234fb93785cb75fa7bc4f7e6576bda5db552547040be1b61880e167e7a741070159efbde488572b6fcf0fa2ff0938d5d043e3579f4da46c06e8b4a1e18d187c9ec32bb7da2838ec30be3f4d52801770a1d7fa83f803805f6307eac4fbc5a28cdd0a472f287452f58a7f347c8c7889ee8a770a3434293d835863aa89cf3cdda235e4169d88e78c361f7f27ec47da2da2f3c2b5619a073aad76ffb28e1e1a8be74be9291df27a7f5b79a839afbc8845e911bc370d97b283d24a078cd76fd172174b98d793f1400661b6506dcea3f01d6ca285bb320aa172b2849dfe9b7151a502c964e4a4a0d9a32f22a140a6a6f505df96957a2ed7904a167193f540b67a595b0a735f560fd9bc89f9b360d983fec916d2912e8dbd0ec2e7fe36b962a582459e451491e9023800dc0e570acd7898352c11b4b7ada9f8e693520df70c751d1c13fa0a3e3831fe86691274a98cdc04885bd2045107a0c38d14f04141657062c0f98fc63874277012f692f7c6020fb94a0985d44862dcf2d6f51ab251854ee83c0bcc313409eac9ef3f2bade17cb56ad0fc944ef2205a1de28d1c9bf059d2e49c25010b12bf1d8e8ea13c0782dedb7216fd558bc12407c53bf7e89154cd9b8492e8af9f50d032c7fa1d2fa94b8fc3acf6e719baaaad831f9998aad7151783e17c23b6c93dabb24d4f5bdd8a39b9d1689b16b473afea4d6be648dab9c6d87d5505bc6560f8a353e7956fa2c81c89d2d76b9c0d6ccb60c7db6abe4a40eff322e04649de650f1ea5fc2a3fb81f7fe6beabeb2b9fc3d5166d31e66ef3d4ae7f58b7f48d85a3d715aa69d32d63f330637aa439ce0480cf64be51bb6947bc5d914d49efd1b16fbff77b7a762762d865bcff7803afbf7f4d27e4c2cf1189c4fe18a986a4198f379302ac91c4b8681eeca95e626dda996305a8d056d81bbc800cfda4a46f6241202b2c6198eb0a1e6117fea80cf2bdf6b09bfd955016976e647bf5b24af7a6c5ce898e4135673d9b43a5febb27377c2c664fd1c2b92d9fe1abfae32e64ddb915ac19e3c2fff5881ea89fdd9fc77a104d57d28df252e48699156590990f7419f0400ffe5ce2f11e4b26d4d08ca89ba6f8f604018cf5ed6a8143825062b669d0de570757f2b243aff4633bf4ebe311c72fe290628bddce709afb1a11b17d3e2c267a67a5b3bbfd37cbbd99128634d84d916c6260d1d0af7fe3c178dc07243d1a5d172a27ce8d28d5932f692f10f4b938a2a009a3a55310b9efce67317ea434a20da6ed319c65944ba13c6e0fb0496e04e26cebc4a7dacfb4f1c80a883804d3bfed93ef8a792d957a906c313f71366dd82a2ed92699689c5b196cd1c27d4aa61b830654738147aa81d23c764f9e9d0de7d637aee199a0d93660aae1d7986d5bee1a2b75c8dc3136be46de8250325c780318a7972df20ab495cae6ff7fb465f11b0796f1befa9f25ca133831f30a151af2c1d5b69188772abcabafd10b33cb99a67cc5c8404f2857474788d0b40c9f425ca288fedf99c24069d825997596b9f362a27a5ac3ca29f488c56fe89f404584d407242c49f5fdb468e61d0dacbbcbfebfd0b2b3d6cce5e096897e68bb29","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
