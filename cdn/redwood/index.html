<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"304af2425a22568278e13c5962cd253f20ff0e2a44650f45937b15a837667068a387c152f125bdd82fb76faf6af0a28d34e689f8af0628ae073c81881512555caf5fee073f91b10b719360517e0144ac82ff7ee36588c496399812bf6ca6ff26e8ad5512262fdf995f15f0c8f57f39962332d0da07aad3df0f016f7b3c4979310549e4c19cbe965b6e12deb3cfb9b7992043b3d9f55fa18310513698cc5a3fb080a214190ef2f3996749666f3f073413cfbeef552c61260393343846bf5bd5fdf2952a0d06bd4d0bd312a286343c929f958b170918e8f5c16af192e816a9d33d13ee4dbdf8360d96be16d90ce8ffa3e8740a6008d2ceaf3c99b2fb6d3c72db7e0f0bc19e142c6a128af8e14ad301933b7019a6c4f07f4c193e189dc2610f98f1c092c26958953539474b6680b69ce37317bd7d2368f591315c26d8f370db7f7106d7d26b897a56e54c4a29a1cb0eda0289d4bd8ac7b4201346ed0af843489e2cc33ed7946f19e540da3f3e0983556db0da4d6bb952b203d9b8a0c313ddfc49019f9b0a1f25d99e084702be460d9396cdde7688e0a2962df80639b28179a90958ba4750ae092ff0cf6453c96637ae9e9dacc895cb0bc1ecc0af4ab8c9204024326825bf387516c2a00f2b44350563939074b044ef23780e88cc6026f627bf93cf51a8b3f466722886289372660526c00fb5aeba6acc4696f1da4dbb0c6dfd3bf56b595bf34dbd15c227aad54a2c13f4e8dab8816391c810e2d933f30e0fd6fcedc7ca3bd26182fd3223c7d56deedc861af62d849f81c8f7c2c3f21c10333b8150c3389a535aaca902facdc1ddf32b318c7f087b3bc62c2b4d83e7c653a23c40a7efe8648d3c3e803944a13d590aae6c3da37463bcc3b40bed03319a147365f81904f277430a036de9bacda4c4e9fc8f7402c6428e50f647a85e5e64482a68b89ecfa871a6383a7b0ccdcaf6ec4b01c8f4ab7e35fb4d879fed667d3d3ef4562c5a509e41801ee3e3be6ddc5fa0fd961b2ecb0cb1de4ad513213c875ef24afd0b0dd9ff0d952ada227344c0fb47ded8c83e5b3c77c1304dff4b4ce99ebed8840d7f8b540cb1b43f47a3b758715e3f0d70a117776c1fdaa1887dad848e71d17f22928b2a3161be234f5cd308ee194b4062d1c18eb97851634d56db5e18b5b1901c88380e8199004823666ec80b3495bd65f9bec920c2b2f2c4e3d173ddcea249bb58da792c7d16197a651a6c2514d4428c1b2dfb598e998e337c9cf21e1f08632272b8291ccb71c0a8813f8bb72e2792f5a7952bb5208574491db6c23ed3bdeb0bb7e736b3b306f355979094925a013f36e6e5bf8c390f87fb5edb83d6496856f851f20f73de7e1a9a645d8fc1cd9516f55331a5c62aad4825248b9bbb149466ca5bb1a26da44891e9f299a1c966e4c6df8cd68544a7d300b03f0fea4b51bd2285ca4ead8f4d8f74139f6faca848671f1eb00b7a0eeacf75e6781e23ccfa17bb0489149d1795606b238ae095bc5e5087d00fdae1124bbdfbb5163794849e3f6b8bc5ede712efbff4ef6df020a79d16dde8707e66c7e05d7f951d1533ad28a0f819229413724438fff3f16a1279c1da548c1632ba34b64e1cc713c9a3b92fb08e0a432b0558f4c4af88a86b8fe7a54e8f7c0fbabc4995334722ff3ab19850d0462adc88ca9682f801873f683030ddd7a6e6d0d69f73e0d0bbbe9c687b247a9d043d77306b3d053776252e461570eaa401cb24421b052dbec2f96052ed7bd68a88ed1a54e02717ac99f03f4b4484e7df5bac0230b994b5d18a171c651fc6c41ac962b6792a29f4bcf356e2c84d6212d05380b17bc919025672f498dd95518cb2ddd8f281fc733ae74b207f2cd5c346d4f11c74fc801e9e031064baedff1ecd302c2c971c98244fff16652a40fc477fa2e099bcfb323131b202a35af23d97259cba4c625d831dcb19e84e21c9d2318b23c60f671ec87a23cc946462e89df7b5e027b2734f3b459c71b37d44e8908348502975e0e601830436fbe016c68cfa216eb4bd5d4b75b4e710fa4dbbd579dbc840eaa3a8e942fe8df1d088275f82416e833cfa263174e106093e50cc2cf0f5bba856aeb4cd334a9e09346d73160b6d3b3dd3bdebc4b4eb2762d5f8bec68db79c87e857ccae6a1acf259277af320498e4f2653de53c05cf96462a010ed10719351057e353ea2a78314e568a5bdcc3466374ec3b86d37464db4cda70ab3438f526278d13d8281385a0bb81711ae962f5a1a42ea701be7dc1f248cfb3ba8270dae67e9dee37fade7a765fe8ebbaada5852d0722172500102ea9e87dcb4474806c1679fd9ac24b4357dbec71439691f82d0bb7254e7c59badf87891b8a4960a6860d46d8591db6b90fe3cdcf1904c20b9767a8f9ad6e5c2aa6b52e7d17c6c282f2a30e68f26d165b25ef8cb54ce20fb0a95b325cef9019bc0979e338b7296e4e1c309401e057ad69876d0b3c606fc4287e49d027c81edfd0aa353674d143140267e4c8ed15a807cf5b1971dbcc6c46d9393f151eb718629ca535d6a2845eb3ea6af698ea715c5b9b8440c98943760c0a33f883c3d5df87869b13d63642c238535a020235548a5c4eeed46279c4647f138c27437e3229a45dba30b5f661e63f1afb663518840b7adad564e47184d6974828e95224b1134ff053ee608dd39c0a85df1b10b65ca574b41ddf59f7e650750691251fcddf6100078986daa1b5c2d4d201404e66d6c1f3067f499c90248237b3d10bafb6edbec0a21e6bc768314601a4b4a08a7af3618466dbcbb3205b4dd07a756e1ec78c6c2ddadaa45b993ed81fcb4d99db3f9f5c5ec25711a1b24b806dfea1404a2fe904c9aacc30b225823a0bf6949db17c5f1d8bcf6ab1c97f0a23385091b20c0e2f891cdf1e99d51c8361644c519ef075a009eab98ab9b25c6019bb7206d5bee5ef4f4ded4b93fbbb0e8f0f8bbc1095508892cdcce1c9c7d319a551abf877cf6511aa8de12b6f765f3bb39e13eea326df6a214c3df79e3fc99e01a8466300ba4776d878d8b16d010790d14e64283aa25ffb5c76eb2715a75fb00cfd62ddcb3fbfe9bbcc8a908755e387bf47ec4aa2df397a5ce483cd15a06036610b9140ecea4f6cf96975506a5132670a98aa0348969d08698d2f46a6fb16ef625e3bf202676268e9e18865c6407f6b7e33c1d7ad619714cc3a5382544ffad48578fac30ae0639f7a10b6352cc6ca7da8b72563c828de79ccdac6c92c21813713a4d88789b721521bb78baf68a465768ee126f08c8922ae356452d932bbf7f2265b813f6d1716243a49a65be18f4e606f617eba25f6d6f6f46562d28cbcb30e9072928471f6fdb59345ee3e44d3c5af69fdf6265b6f5d078a5e63a41a2852548efd9c874d7930ec6d6074af5bb033ec939d4adc8162408065b9b8e05c2f8d831d93f5bbbae58fc65f8dd0e2e8b23ba9917d91fdc037dd7c6964637919888c9b421f7605c5b3b780ae8430e48a34a269313870e9aec435ea671604e88dd0e3ac7c898e3299001db48f8ff6be5bd6ddc2478b0131ca5f91d7ba92e9e6e4c0c96b0b5b64a906884ded2c80553593d14b4e403d52ea11746b25f1ef2dc88e665220ce7055bb0666e1a38ddfa6b448d8a833df08afe1efe67f42af6e206bcffb1354cfdf24328e3806d704713bc002849873616cf81111575c7abc4b883613788f8cc67507a759e4d2bc4f2d95ca69c24311c3b1b9cccf5557f99cfa2f145e10af216e0719d477d77790a9944b6d3d3d298f226dd180dd5ca9b07c1b5275e715f1dd0daf836c0ff80c5be149037b1b8294ddc71a496ae2cba200902d5e24c13dd0d6ceca8961a7bda1170f711a86964436b7cf4f9c918550e688491de9fd6596553b8543245684c25c70b0735447bb34b7245bda9c23cbe8ff139a2d17384b48711b1aab54ff5e3c9ea401344c4bb3b825c12884618d663bbe971cebf67fa0133cdae4a1a5e77db5212b0ea075325baedc4b7a12ecfd725b221a42af3620c47b538a6cd9830ffdd5e8b6041ae56c3d4e8f667c0f29833db0207246912b6edbeb3a0ec1ed6fcc97a7c845f43fa17f3ea53a8e4f33409b1fdb6856b5107bf05068cef04ef5c12bcfc53ada9bce355e8522261598ddb8af352e2d2b48f2d762e365cad377ad5fa0af96364f3b01b22053d80810cd829f8371d166faccb27fd09eb59d2dbec666f5f4069cb19a3645a5af3e36dd0765d0d8d7de9c5fc0bba780e6b0752fe7889c11b1f573f54d8dbdab03de8b2b7f3210c269fc0579a6119c48b4a150b704ad8bb90cd8faf131a77c415257ec2c8dcefb7005325612d3c995440d6222e7913d43c218bb88cd8eb1b12609dcba2b3fb8b538ab8a1841dc24fcb1214f5e5e34480a8f1b4644500862c437e421860897bfdc6b96fde8bbeef864c1d447c53a01f5795b4d6d52df0db6cdbce4b4af641b2d5e3bd3ee8f4b740d4565584b7e026a3aa268749c3329a0f6957b5555d8ecca03c35599a88583e675f8ccfcd6b40a239e3bc94e13ee7fea5507840339214894025b14161f1ca7b80c0b5342b57b5b7274121019d282b17c634eece85265dcc30c895169c74ba6960ba30fe7e1f33df895489d41e29834cd629ec3cddd1eb16ded28b51bb845b91ea72c3e1680b7585fa2d1282ced8a687aed90fff6128e092c42c5d177be116178a0eb67807a4f709aea7a76b7c05d117f24ca94bdce558a75000f67476e4c89a30733abe0e186b16e22fcda0af0648845e0da8233d9e3b819009ff7956615e4bd7871d8f9df71ea5b995e8a5cb2eb0d4ea955820a9a257492c71e734feebaeb57ef7ec4d460a2c653e07740c9ea6c6bd4fded1a4714a6e931a4c3890574207033f3c25514ff3876c70bde48327ea6f7fbe04e34971a869afdc8f8c8a93af46681aff4ef2aef4fa542cfe0d02a566bdc155bef9209c1e4bf3ec3e720d766cee85b42fb87d9fe82ac4f1b8355338e4ce693b2402b7afc6988520903546021a4600b46e577f5baaea1a708f69196cbff3419eb7fa306e83cd77360e9121818025cb1450a2fd5d99c897de71f29329daf49ebb246737542157bd5b31332cd90e1eb0ff6a1013e4086d91185c2e0a045670b94e2fb19e5dc1bda7478aa73427971a6fcaa36cfa318679494dc305c9914bbdb6426a1979594c8b9779938b65a6831c006a7020068df3cb05003d0777a2f33f0e0574284b628aa1d0408160c321887069af195173c2a76467f86b55d2b683128e6d6f0b556663483df2642ce1d685f92b2255b3e5cc7e1bd1edb2b6c6121418978ba74e53a0102adbcfb651dedbfa6a22c3f4d67a1c72c70a9771e751da3eb63baa4cce17fe5865806436fd5d5d5c562fbf90a79a56f12f3e46eaa24a441deca19a4137907d3182c1f9bb10a5b17fa48f2926ffe98e4d48a67a45955e1482c1d9abf702cc4fe8dd0d3d928b6746de8549199442b29e61e4753888120b30e1eb4f65784ca28cbc748e28c322dfe50d87873395420b28dafdded5e6e02ffa0e5155e6dd07781094139a7046510f175f2786c31ba5ea221cf67905c3ed560affec2449758c94f3d1ca0243ae1dbcecbcfc91e80fca33b747af969ab143da98dcf2041904235245c6050178f15dcfcb1ba9dc634f580b7a81c16c2895c74ec2fbe883f520f08edb44821f4b092cc43d3f8472f70e5ff60978054ab826410c8290ba1f4429820f7afe6c7a530b9986f875fa5f69cd3dfac1ad0bd8a1fcfc27026ba01504ee54cf6502d1b2f2309bc25f12570ad385da8ada47e2dc3d15ea9e53f0490bc445d63f98f902f934a0fec5c422d6d074854fc3f77a1f1d5c99bc224bdce58248389f9973086ad09a34450da2306815fe336c94b20998e623118712dbe327d5e8b5e8e06d392f927e5457054b4fbc6f75d5fe49f90bb8f30f4c0c2e5677407f3f25a44250b5c2f12b628297750a764646e49b31bf7165c2a3067b59ee5a4f64f6762e4d5cc9a5bdf0f86a467307170860d0b015267336fabf3ec007e8ed572b09378b7318dc863b1d905d27ff37d4326fd015ffe3efaa62a488431971c3529fbd3d389742334f9bddd2b6a4f601c5722e69b594bf369958c938322c98d7b5a6c19c6077c632696bfd45a565c2238bc54198d9343f95c0a5c61f572163478923ded234dc370b11614749cfd9ed6e4e4ecd1ec34c113149115c1b7b7e7a0b9a0000d6f6446d798a35e8aee2758ad9e04d7abf2bbb1e8d500b607c10a2c63374bfb730574675ff951d42616d5bf2b0ca9bbe58bc0b185b475adf4d5595a416bfb64c6a176007b78118e1f4469a4762de5b86b637fe0af01ffc22b32f7f6e4ae944e85939308c2c7f368103df4a2882db300a30f3acce0301ea25ed4788121d0b80bbd6f3a36de93672444ce9405a4d9c3cfe01fcc8d5aadec91df87dcfb81d17bfdf0f4aa01bd9d0837614d6f6151ed72b739583322c02ba4ca9e77aabc510b72d65c37634ff8ce3d54231de60ca359bb2eb565fdfb92916b4dbcf92a3cd23c0ac3f9f19a9a5fb562259712e68d8a1e833ee87c83cc4b8245c1de26d5545cd77824ebf50d262d80220a04394f9a9904a5c14f8bb497e96479c90eaf08c6db53664fbc3bd3780dc80ebec4abd8dcb2b2aed27a88b883d157846c5f6983ded1000ccce7ac36b0b6735ea7a568ad9d1e6d4b2f231913065b9f42174e6f4e6368ddf14a8ac32d41cbd4119791c1009ee5733de9f21ba95b95ad300590fbecb74f9b5978f9b24acb8183119c165a6bf75f5405999fe1d3a1b8b834612f46e08f81035876f3d3c896196e45c1fd0f477866a27ccc6bb855463ce199843944e07e8c62e1c9ecbb1d9f9224844af0ada46b9df8f38a1fb0f5cd4f03c01f23ef6bb5a55c77035c2d6fd4da64fbb00693933900114d7228c6c20cc94f75cf27387229aa4568f9b62efc24d985dc5733211709d8c60a90ca46de4f75251660b78a7eb948c2091d5752a863e2065d99a27a0882af9add172b1d6aa03cbaa8d6652f6d5c6b979fb53ccf0bfabc72be3252b70466cdcb4bcc23254ad315e0e544f9d1b4faa0f2aa5f48001afa77d430796a75b63af3fb2f1a70b0304f938b929e4517f835663ce05beb8289ebd19834eb471555c37cd15d43ab53ec31f113f8f82d86ea541c971d7d2f8bc1307bdc2a5c2a21add196239b5ea0c098174af07ee060af6c4bbc383b104c05a216fc205572114f7c5f47a162dc0a5c901f21e1ef669a5c232eb1237142bf828485101e51d81481c047bf04bd19eda3365d06cafe6a1b2fee2e9f606ffc0fff31a2320ccf95b3f2fe974aa05bd76272be577b18d16161b06c4c9db78aff4430f83dddbd999bf77cd6bc19acbad56299e3ce9cae2de491b1913b4eda009647ca43c3a6794b362246532af8a8564aa0bbfcb2f530846b9f03d4ba4f560469367fa06bd8e133f9c5ab6131fe1e1873903352a512484d05649f1c34f695210c784ae5b28182efcb59538d90c7a5b330c296dc39432ff966eaca88878586f7c95d04ff914701bcbf64230bf6c59bfe193115d15f27520885ff55774cacd35f64c06a015302286ce4cb8517ca0709341de081c3f22d8a6117c2e87805f5c2f2ff194b404c0ccc6b716b6d87f9330a3593e956147340677c8391544282ce633988d735e9670cdd2d1d6aa3913ede82193f7074516f547440e936ad8ca1ab07a56199cfec4440ca501fbaef5c94e8207fe6fd041379b9b84ef03d4c9c2f9bd9104710f303be268dcdf3d3fa121fde10adc0efdcd69e41075c74287cd85ff2e95b0570b9beb031cdb99044b196142c199f706cbd8161517a37ded1f06990cf06ddd2faeea82237beebe55043db8f3d71dbc3625eeb49228b280ff6a5281a4b946bc33630a65b5baf03166503a453897c073acd95695258590b2c29ef1a6b60ec3f09ddce1293ce02c33a991b793a6f43c809d3715a0e79e809a6eddd67988d7cd9a9b7aff927681f18eeb32ca988a51c5e63efc3f1b3e8cd913fbacdfd81a16e2b43f03a4f3b90e11a53e71f614a78cad281f6f2449fa80e784d005c1e0d875f8cd289bdaf46659f68c87749728a37482ef45f023b446d88e7a1d43b1f400b741d0c81dd249f6341176d331c9a180360f0be32c1b66b36f2e0e9111203d356cf6ccc3f5fa65e5317a479883031328e54868328d63b00ffe6c87bfebd95ab9ce94e2b6ff3d7e60627ed5a2be874ffe7a03e337f294acba92dc759d717dc7fd2ec040c7f9db54f7f05d82ba618c39db38dfd09fdd38f2bd6aeee6480caea17b5bd8e1ad6342edb7235ee1071b38f515261330d38b31dd24aabc1292950e1400d8cecfdb95dc0979c26a958219e628f46055fce3c5191826468c50c0346821bfc37fd16a1f602c8b636b1351586d3e1266a279db2ea1759a455713dfe6bd3bd02a5c3a581612bd02644e019406211f414645684ef87280d839172eaa159f97e6b78d3112778367b71c8a05d2ee7adcf20ffa395bfdd74e6b5e7bb985c8b903f19956f9b5f15476f879e9d5d164e11132c3e2bc3b3b8fe48683de791b4de69cd74d406d1ffa6edf54969362b81faca0cdd653b771678b47148ab8e1feaccf0c6a17b64dd0686348ac689767d6f9217665ff0f3289e09b891219b2a80b4d30a2aa9e89d206f1f44a1dfe2e699354ca58f118d02f495708a0c2a324ab6754f8811992a1d2de9df4e5d03315e6ade2965e745132dd51804643d0f121e65b89ab48d008c45e74ff3ec8620d48ca69c0a2350905d2651a4d3ecbdd952bfec7985bfb58fd41bfe49b2e03f2b17dea258e351bcdf39a88f5b7d8a22cac74501b40da2c46b8e334d85673c421ab16438d40fadd142d8bf9f9bc99a3b50323591ae85447e46ffac38f558c05ccf28cb188a9b241e249308978408b013fdb34cf5403a995c227e906e3900f7111c4febe81943fd259ac85390cfbe1df583864c383f48ce9767b9157e04fa324951c83bf5211e3e3b1bade575622adcdb9e784f80aae7815350b8f8bfa03d3cc260535cc7532c6154fa7df689b81c54823de96d542451a192f2c6377381671ca63da1b766deb3bf62d415c0ceb905a5a7cd20244a7f3838ad193ab162a77b328e3dfe88709ce396152f0be2b77b4c20726a6e7e2588e96cc6d32d235a824c26e162826269476661bd90a13465c323e152bd5a54888b2667c24bf8ca51887746fdfb18ffce2891cfba89e9c2c03314b3b41a23fade6e34e8bbaf6b1dd5b2656b78f04223005584e24b101b7f467cb4584655b2c9c6364eda17e3925050537066500eb4754bc98162babf4fa797f0506830e790b37e199a25aa2f2053fad5468562ecff9bd157a9160e1c4f844d9dc4aa9e4cd341266b2c1ffddbf4f5c26825d5df719285247f103259b6c40b312c05c20e1fd94c3726b20005bee53026283e9118adfb9bb4fbe2b13b252bdcc22eb18c762fd9bc4b5a4675cf394613a6300046ca34b9bf1c4866c491c03ccb49721e4104e8855017036112979c8e2d88427eef231cb89e6db42fb1309f6a378309a9c5419d6af7ca7a2cfe698ed96590069226b20c785c330c452c907cb6c869ccc6dfb9ee33aa2819d7d84b0a3bea7c3e26b3993cd4aa58c86f98266bf18052bed0c512bce61e1576e52d0f32717028dd5f201ae30eaafa3119e6ea97ecc41eade91a17fea0b39a9429c55421d2a3ecafe57cc874d76d7775fd060c7fc2e6caa110818f766edf38a2e395892647ccabbf71ef751dbb1f2a9b172da4c7f056a03ee0d5712dc07154dcf70ea901597f0bacb38f52314a8d7bc6ccca10ab08d040effe093b54db44bcbc6d314d3c83b6f23138734e7997630647b732fa1787d8ae734ee861e885107eb90488e6bfc6e16672ca3b7b96ec5507eaccfd8718275d17648d823bd2ecf69f45efb620fdb9cde919433f3f99ba9725c62cafa179b41a6f09bf21358ab935982c84eb61aa8483fd8d4c1636547983e3524e10bd4cdb1060a6fbdb1ba4e6155e9e3f4cc9a4d8139e0de05640e08c74af0e1356a9305219f50640211fd43a2eb1ff266081b0eada4af65803f3bd78de4d2cf94b0d2c8fe2a7168a18dabc7175e6af6a00c6a72ed87d3d2b78cd678011247dbdcc31bc0685a27cfc8a48fa0dbdf887784d7a950ec95cb17486e3d5542759b1257c4cf0f9fa68a2f65fb5e06e8a1546f06f6343945e3a214c6b9281b048596623e0665113008775e825bd2b2ecc0544b4b57d427c129c45fd3b561d59bf354e4ab96a4fecf4038198bd450ac85de22c0c04ecad591c2a071853b07da8e19dfa25a0a05e0467213b7390bc475721185e04bbb848bff03eae485871410b0f12e9ce555c7d6f5ce8b5837dc1a92c7c2710a6fc8ff8d85ba58dfeebd097cde5976932f972c85e691e2bb36e6622e2cd889371446174e54dbb1579cffdc79178ff42c527442f85bff0dd9c82718628f34542b000fccb3fae045f4571e9d238fd348bf034aeb14ec77dd1d9d5472943c626001f5c49a59becc9d68db34fb412fe859c90c6ede9779574e5fae4f5fd12055d5f1fd34a77165cf7a6f5aa37c0fb9fa89ab75c33ad99d8bcd212ea4ebe04d74afdf3d5fe194fecc3bb54542d837b59dc038516109692dfb9e86ecea48bdb7648ca26f92b364f62ffbf484b76ad21abbce862b9ebaebb67721d2c6e08f92d4c0a09f0bd21c674e95e89947651b95651fb19b22e9826fcef3648d775b145cfab011112f984666c288a2958a67a9b30daf3b123ef21a611661274b56f91b72cb94558ddeede59bba472e4214f906f4bfdbb030b912e2a0c3569087409f0fb6b63c63bce00644bce3d874ec7a00902206a103a25f41cce8b350d7d64580e70e721fcd4911b27893f7f7f4a7eac65d297195a278965f0270db6d5dc96f970d8d9a63209fbeae066d0a7463a833600bbefaba7e43a025d6d3be55d6fe838b49ae94c5372eabb9dc2b3ac9997cdbfbb42e5a575f87c5e6cc688d5c9f3f85969f72f637fc325928f73524af2367731515a000a470d987c630490eccc2d2c97ae7a1a43f099c4ba29f21ffa7757b9509234dbd1facc92ac79e8f9ffa9c1f27b646a44307ade58e15e707fcdb943f05af951209aa8440b7eda07810757c967a068b834dc8d1a4d604370beb58b0a244726e9ff3eb3c589b724b87303d60d7e5de21a2aa19298b22df438d4988739de3727ad02a03a201c74edfbce2d601a106ae381c84171648db8993e0dedf45707e660f954364545447e538604fe25704d730ac1b9746b9e36e976d504b0314d23704effb7d29a7b1137382af37bce8d6c52b43999c5ade189b9b7dd51a473e0b8327d40f54a0350460b6b1c82e7b7dd13ee1d2d9b40915c204f4b529310264d42ba7619eb000942316b958a526fd0c3079ae500ff19078eeb572b8c4f4a2c5d1ad2f61636ddaf4cc87d7dee2a65f90dde8d45d5cdf61371413a23fe6c9750c7160ff41ff3a411be009ff664b2890e7b1e36c9c9026baca0dcf4342c041d5eb55a511eb96c2f45ffbf7bbeb209d881a4ca3c290fcdafd6a983eb3a519e45ca37d3a6a6a3732f86d4559c95830884f2f9ec779384d22f0665c94aa90ed8c05a2306a6b7e230a8130e6bf2aacd46ff61078443d2d43dd192bd1d4eeaeea614d12641b1aac5923b5ebcb1485f89d8f5bfc022b50b734ca794985962e4b8fcc510c3b238cd3fe0b7c4415de10b17bd85ce1cf4da2fc273aed0196f637379a6131b49af98f644a4b1c2b0fa6929261bea607bfe312d4b34c1bb955133699c5cb746f79db4202084f3fdfdb2adea0f242bdc9256b1bc23d4081532c461054817f5950f0d79be52cf13df8bf8568f51f93de762663aca01ee94ca565e037f9ed3833c3d5a28c2ec86dd929fae15428563b533ee2f37f781b9c178d741925d50dc50e8cb6e13484cf81a58f911f0bc716e3bdb2756059d4c4f28a67cd5282c2edb3a3c12b92835e9b5f9bc9149684e12cbd56715d2b74c5686dd20305471b4df6cc481c97dc46401085beb15dd505d13c88533ed802a6df10985a05a1ed4545276a6fc86526453515aa183f2d828877d5ad1eef730cf580b5e306cb60ffd5b45aa79bcd4fd65469ed214ad3ac941c3bf4d9606a69f642a93c746cab95c04c61839fbd34f91a305b0dcbfe8feb463e1b866a4b8b283dcc737f3e72bef0a3686b668603f259483410922c6d5efcc4d5fcb6d6c89e330fc0e64958f6c81035ce66ec49808e8b06175ad5cc96ffab5239d230ddbb8445651d326ee1fea8b167ec6f118dfa16706767095c866b178aa387f7566a01675c9775959a1ba72229d4270506c5818ee7550009f97d21fe11d0e7c3655aa26ca7a241f6a9b097436eb85658716d07c70a32aa62e706c3664421091aa80d5620ed0ea0700c24fdf2baa8c733456f82f0ba1ed2d2c28f563da678826d1f36257e7844d71c19cc3cb716a6ae206c9a197c329b7ea2fd6de937037ab0eb10c439010039af1e86ce8e8afc2432a726f2af27af89b507baecf7037ecd28e0acb58ad45374e6e108514fdfb77ebc152d1d11d99713e9876dd500af3d0206017bc0de1d51167e7dd62562a812f783e6a3f2a79b7ece90686fbf14392dc62df76f7be74eb7634fbaec121a7315ccfa0b0a7470e672f0b29d220518aafafeca6c5be6ed3f43c64e317012aea487502775edcab00972a8759511117aef189b5315011557dfe07ff0ddbae47c550ebfc7c0b759557703640c0595327c24ea036ecbe4e18150c1b0f0dcf082dde4b9aaa58161d9a8f0dc2117e29b3e8068620c96ea768e643231b24c2a8c4bbe4a5b92836fe5feaac6459aa80ba52a9196d96c1ac218109e37ebbcbb8812636ac2a1fec71285c829cc2ed482d29c85b20d976af11c9cdbd95a0e1c9ffe11467e2da5a24287438d65f78ba7264f9838354a6ab6ed5fea71b7097a8b46f6e5cf81f110d6bc2ae3255c0f773fc1a15805d8c4ab6bb77e5dbc57d44f4a9d43651d813b038cbf750ab84e64ced44ea75dd52c00452144b3e9bc42c3d9329b276469ad1c8ac1dd00d31d8e1d5ae0a27fd2cf57c81ec02dbb4352fc1f9a3384bde05297322f795b55504582472ed3fb00835b537c565078f2d6c1309a2dbf2da5b63fa026b69167055f17383d88126c2d742dd3a0d3df3b3ae1849d60e002a942fdf6eae39fbe34724b2b758b700e50888e58883770b826190c5fa356ba6d2998258c68428af2731197f6ea4dbb9b152474f9fb968d517e6db1d314a1672a05edcb983b33be9f4b3ec2946c55313191d43cf72c4ba63fe2b67ca27b60f896450ded6fa6b49275fcc04c43162fa5e6aed253ebc462ccbfc26d752a37f47f756d7ebcf0569106ecd035c13fde283c30a9e4d55d3e6643e5340ce064d5fb245fbc4f97acfb18865d402a1ca4a07da853c7cb5ec57c2077abaf8429f33769f3b1f6cb80e1e567b4cf23070dd555f2944d08521b1fed866a574d993d9a0575d4b1cff8a21bc4a4407290aad6ecc16b0bef2ace2e3780a94b007179e3a6c15f2f6f5cb6f9237ed9a5e778b8111c03ada8c42663101c33663bd630bc420922e0e199bf68b2c47df82af4e4734dbfe68c791777c93961fd5da66fdcf76b886bb5a97397fd7dc49b37bd5dc0f26925e3f89215e5b62a8e0de8a52414c78d7ca4c70b052f85f6b9b1759c5360ec05a1f06de7960a00a12d6fcc0ed0b7732b9fe574c04dfaffd1ee71ddd9b83b5ff76e4142228352d35232ef2dbe28e972ab729c3807ad6220756a354d9e705199e8f571dec4d1298871a3b42fc437bfa1b7298905427f8e4f2e16cea3be639c3d44d91fc2bc75b48e6d41f71201291bed01f22b1db5838bf703393008ad54915c2b2c020c021718b32f8ca30e88579d6544a27594edd8deaf1ceec7697d80c7db96305df10be232e3684145c542714a0da0c362226f9d122752430e1ddd5fdf3ca637a5cefa97fae2d2bb3130889a3acd2eaf41a5459e5c5d45aca588bdb5e01f380f71ccb11c66491965c5c45f205fc48cf68834edf11bbc3971a632cac13067742e6909a6210ad239e3a6667270f7468c0b51279f92070e7b43f235f15385dbbc747cdf12cfac7598680598642795426bb245ef1e509861321e99ab27e1df1d3be2b2c131fe2cb9489c88f90326629f2197388066c3fd4e4526134ebb0593e29309b5930d0e1ee5c1ea0ab58593492f254e2df588464aa0087c66c6ed46746dd1482db8b115e3159abf7c094e00e0473a599deb252042a31ae16fc16a1cba1202cec4a1956eb82498243b8cf8dbd89c7bf12284460b713d8952b31cbc9de7d294e40c4105d6f905f2ccb398cf9be847960bb12f029f35a0b1bceed7edcc4dea792ba643391eee101b41db4c00298b66fb98eede7576fe70952001a1c199b10051518562a65baefff3ebde7466035765b119df6d55e526db9601670428994e0fb55b67debd45fe155a1987a264d0e4c3977521ac392f158d552b19b7a6a0381bc7b28c617e81aeea490eb5ab8eb91db037a4f93d87e05e1d47f2e4639242ede939eca8759d22672d730298da05e913dfbf9baf04b6090c9f1b19b0674bd2bdfa23fd423ee41796151e065822ebe7709c7052a4a5a776de9cfffdeb330a2d944d163108159de139e530a4eb95327f51c74cd0b667029f5e60c61d4cf2d41f367e4ce28fa212f1129d754502a5a76629b6a2b1f2e6a330618bcd78c3a087090bbd8e0c222e5e18248cd3d290b25c108ab209f632c20446f8f5aed02368acace1ede8f1594bd7d2e21e1ab0fba30b710d64b6b3de4497c6e51f4eaf4d5e1c6f474bf43de4ade1c923d7e8b96a306fe000756a1b68212f87d5bb85abf67e9537b39a03e6c1f5bf16551e83d21ddd7caa376ac99f66064c4fd5bd24c72e72335fa3b502a5f866b1563ecaa7eed4b863df8597b24d96393234cf151659d3391a87fd3a2e82713522e6eef78cbbf762a8abaf203a5efa5ebf677f7f7b52ede2fad13278b4d4fdebdbc5cb52577950ed9690488b7031b3a53ad69ee28dc3d3b2d6d46189f095c642d590a981d2024d3ea38349d47356f144d679d1c396edc2c0b38fa0f913a740f7d49ea1457a8a07438c93c76249f7d590eb4ec7353c7621c500204d74222b9a8998d384c40b7e2448e8bf2bd4c0320af7a7f1e7e87066102acb42b3b256d0c38b4a6980667a45b0e08b5073cabc11ad40e6094f391c714ca9ec814e0e555a96897848317ed6cb11f7ee2cc8b01d057f5d6656f7df0736287886172816010a2a48ae9b0ca38355ac092c758a17cb3e7a4f96ddb4309a9ddfc2031df3cd22701acdd30da59e3c44d8f3b59aac62e92653e37f71ef0ced68e880e91f833b9de82798231e5080d1164549778d8c9a1206073aedc633ca4bff9a7c7204a94cd706fd938dacf0d82dbcae2299c61e35504e2eafd77918e5a6d97870b5863668aa89a00c4ba2658b702038e8d2fac0f0461b40ac2a51c2bcdd46fcb71a54677ace2a40ac6d274efda4fa0c5942a52d423a4d663afec52e9ac8aef64344728d1426d79ba39bb3716c0493c072070599b9b5f66026cc73f577cb53b73478bdfde858bec7dffb3b09bf4c0460a0defff785ee98d2de56ee156bc56a974ba64999a6ec6b0ff2cb564c714374272530f46226e053ce4fd9434450c194321b4724f79706bdacffe511b18a91fcf0a2d2e1611c3c0b0ca586f3e80c714ad2cb3de05c3ab106168d9dea471d5dc54daf3f194b0f4c8dff838720dd05baf5b052b55bca5b4ac0c3ebb35050c51ea38a05dbd31ee666c6ca9ab5360cd99ec85a5249f4317f741679db333c6f9cfacb1f26f48b90cc324101ac7baeb867c1416f183971f3e86e0b7e3f37134e4c36dbac6019d574f48aee1016127068cf5f1d936c0a8f63fcfe522367ba086d7f7ecfa988e408c1eb52dda1442e6a7189abe571da4d6e88583934329ca6478dc16be2796630c292f01ef95da19f95bbb15bafb0e2cee29872c0617a657f19bb7aadf61710e57c04130c83800e5747f0147b25d59781af65cf5ebc7b543e22b36d3d896d5dea2ebd04a4927e1d135b4a395e4e83bcabae11deedbb48e2d4f42a2f29d84d120c54ca801eb2cbcbb1eedd2bd14edb873511bac3451b402e2a4f613145833c30ac573317106d29964ea28b5d4914af8f887e8affb8e7b3b914b1f825ec5889e50ec90b34938dac0937fde41a48d09f602693a07d0ea8f0157a36a4b714004857c62637578605e97317e904668640f52053db5c454624e7bca8673123657370dbe6a1009145cbddcdf17005da25fbba5bb99f70803d9c919de6907e409c94b223b9f787b731ba62d8b4e3325ef987259998abeac49e852ccc4b08317486621acff2254d7eb61b1efe02519737cc3041bb0e522bb3d3eb8d7d8a7afde9a741be737878230674e11986862b6677e696eea63c6c20fbb079a31d1566969897ae520e5241360534348ed82bc3be31e398b455c470a9fd2192eddf56b2e49f17f1bd7cba9c094095d6f54b266235ba32c5fda510d113287aeb633d4bb77afc0b06ae35fd6549f6a4032a92d6d0305b8e72e3a4ff3bd5a4aadd2352440260bee1681c0fd0f34794e5520940519a025bdd14628f839bf2e562451df86de4c7cad165f23c7d73cac9114ac9b23be167afff8294667c0dc172de60cce48dd8ab2a0e449bf2fcba3f305cd00cafac44b638d656b028baa551ef622c33b227e516ee4238df6fe16b7219032d0ac39c1c60962529cae7629552658991fb1e0901b7cd0f31638af739fddba135fab15cba7f1f1c6254c847cfac44f92ae0c5d2eb2d73825ec1f27a93b53bd3879c4665a8bf4a54447c65648629ffba56a75ff725d0dcb1af8d33113692c09cbf79b0b24d9e11df54307c13c9641dc1a85f40d5d13f92cb1ced8804f5e192b3aba01424aad94197a7992f09d0cabde9845c5367cf349282e746984f66efa7238af2c75f933614b315ad97acf886d421375f1622996336862cb6641d56739f313bc129b42d35871d915a70f3d1c9711aeeec44d07a74286f7f43a006a8af5cd601264468bc4861701435e98aad4e02e1fb61a84c7a1fb464ab025624c0252ae80edaa8105c2fb49e1d77057b55a2d0d6cdd3cea0034d55c23f4081d4456edeb0aaeaf8ee39481a821b754fdec336205767e2c109c22aa17d41200ba4bd36e343a29ea6b55db07b2796bb9fc358e2ca2c2fd28ce716caf816ac9a1ecc8a280e4cf93c4d2d8af02683c10b5c38dae8f551fda2636e584eebaff74d67cc9e83fe2690932107480232be73f54aa97d85197172c7e2342edaad2b48e8c5994632f4251c286b655911b5a01e5dcae98e5341203a9ebd8ad87cfe7d4142589f76fdc61d1d02abc7a4c5e4ff878980f41b9eae5761c58c31e819540a839aadc61fc38a4407ff4e88e66bc0dfb8bb6715d89a1ac4d786df871cc1d122a0a1f20324ecd615cafe8c2a663b729eb04c8373f8e41e1f857442ddbad11da05ff39c8d0b281651aa6a42841ff1ce879a070ab260ff2bd0b913a9ba78bc45f7b2a1d5497bc3a0bf98722152bb66aa82ce6b7e5f274606e7505d5924779c23348fb3d1814d564c4e6cc4f0e5a7912cf13f5689188a0c8e82a6e24c612247edb96cea9a2770664b3f098a7c7a656db6632d1c454eb8fde6f3993606a25fdb72026a46fc472ecd68f617b3f6b04a014bfbae25269a9bf3edbd2bc7d8ef4d1d3d9b836513c66be1be63ad3ca16baf7cf9023a09bf08ff6444572bb965bbe92043ffbc0216e45be5fc18086711fa248320f8bdbbbabe6f631093e95bda0efbd73c18264289bad35069e7b36062a9ab6dcbc761065285887784b4158e0cb684a607a60c7968cdc0e9598252474e774a4e027e57d05fff7e1d2d98ae1e997c1a15ac32442dd65d1e76418bf8a8436a5fd3f53203dd36740749ca6a9bb4816bec2d445c0d5fdab070b0bfdf7073c3de683a665ee9587fa4347cb23cff33a8224eb82094911406cda2feaebef6b7fe5d172075993c88709c11702703a3630","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
