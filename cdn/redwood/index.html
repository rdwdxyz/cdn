<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5adcbd4a7949bbf995b628d9084cd5f90f90a0d78f78a9189e8f36384cd26c4129d95c4862a769822c95af8bb8c8071cf0381109529479f0dd22024a371f190826196be04df0ff789f50f620abcc3f026bcf617f90f0620304c51d08cf3559182f773417046538865187a17f4847a14e5a62b33f343a52fbc2579907ed0132c68d9f364c01cd66e497236f8315328ba7299f89aacde62cd3d7791e31235c89a53802891ac4793c0ccc7524f0e66df468943ecc53c6aaf582df6ec5a426cf21be02ce8f9042e75decdf27304f2c74a1e3b55e991ce48a8ef68238e1d82a0d64ee1088f5d9c362fcc25ced2e2ccfe8337b1648e3a06aa00bb8076665391fba94721a8d4f6cfbb2df3b17b6ce8febeb3a7908eb72602bcd1c0b3994c745ea9b781933e6e5e8c5e70293d90cb1517cd6f277368f3b6f853b464d0010d356e537cd9016fc7c21fe6a51fcdf518d7fcabb25bd54749f4dba67103484c5d4b4aaa6ec3d38c514469a7487e1558d4365b1512b282a016debe89342c9869a8de48117e4cdaf2486d52d6fe797a92475b196eca28c9a21835ca319906463914ffeab936992cb946500c77469d34822878a62e863ff1f1b35083f849f5cca830eb7d758698c64fd73ac4f7a73ca2d74a4d058e317ce916be9a5ede354cfc94ab2126bd558e3c27f9a8e911cbd8c82334e5cc853e64dfb615459e92eedeb2e602bf4e96ee9d7d0db22b5f28679821c1a51c322d562057f177e7e0ce9c530838eaa294241960367475f3c51973cd2b56c425f3ffd23a769e81eeb7cd1e00e81fd6955572350beea274b68e2e1c2befbbd6ac729e3b6f2c5b9187d058f7ffa2be5a4a66982ae18e78edc528877c914dee02081a83b3976e9bd96cbac417b932df3791a79ae123796e45158d5591c91d7653aa6469de96f14272e1bf2dd6566e5a88e7ae77d64e19d17952bea8ed55ef83431ef318efcbf9b33bd6f5c01e74d7070281b52f90012114f2c3088f8b41287caa6617f150b2101871f5755052789c978eb7f6628bca246a3793881d97141212acf7a51a70b108b115665abc3209d697d6c4478177007ed4952357268dbcde2afb8abffcaf36f2800fa7340ae2e06a00ea34d2bfc25ba2ee61d4d79742d852f8fe60fb731f4c8fc9d410ef802fcaa9d65622e0767d32d3a311dab3cd97e1610ec99c8624592a0aaf312f06e2f4e503cab0770cee1602ea69902aa91d26a0e919c2ccbdd386995eacf26679b891bf230a4dcf53bf6cb7b70b8125659d29e098c113a049a2f2ca80e77bfff0404671b1a2acf3bcb222c9bc86e7274bb14686dca5c5f7c746bb2d6e53692d41d4117215706cb6c6efa84682d41421885913165124ff5abdb56a192d3836c9919007c89958a3851ea448c8d3bd29d5e2ec86e49241a1b3dc4f30d7c8d5c3d7d364c645ccb6940a1dc6c37813080f1fc265c6075347822c442483bc26641b572cc8ac06ed1a79adbbae187118be11ca074a4135a156a4fb3f884f403dc3dba5cf82ca9c91a49cfbf7002962ac53726d3ef51007aa3f5e0e95eb6c4985f70236198e1893d5ff359f139842cb9cd9c7fc9b7acd360cfdc2571cd7afbc8155f30ecd8c8cdb391bc7bd3b71c548cd2d109f36a498d0fd8a1c7daeb8b1fdbfc3dcb9c1f82101d04742398c0e9c81b9127311673dd59fdf7b90ab59959a6466733e8d244e5411746ecdb889f143bdd7c6f39e03ea017a6730050045a5d3b54f70cb3cb19df1505e9f72ec43867f63666fb686f407b2cbb74d0005f5e127952ed1fa9419b50f76eb7a2d3e0964725cc5732a0775f465fcba9638a9ab5a535a22144e15f0ce61626e62dfdf69498a26bb1a0fa85001e0be421be2eb99bf373587bafee1c32fbbf40d9df17be3e3d9d5d35b6fca0017a2ca04fa3bb785c123d8063f7c945ec194e17ea008365708db13aaa7f646d8ce9ebc73ff6b502a29c5ae560d388c326d710ebe7c5821beaf9eaeee3f5563187275fff517d38084f8137d665397d046c8bc0645f128070f9b75c575b4f594f4c6d22682481ccbd3be83044f033f54cf9a78ca0cc3bb91790a91111ed506c8e76ec95d639d4c42de4fbc1525ff3c4e3c05f5a65862c385b8f915efcb8dfa97eaa20c9aa6049625235e929be91e8f701b9e41a54a47793ed163e1777ad91f3ffdbcc942a9c7c0226442d44cf0c4ade008a7d6c10848d714397c3fa96edbd80578174bf97cfbc381a3d98559373b19d250a8ae15c296699c469bf111ff53468552122deeda0699c8b752de61cbfc46807419c1274902ce06bd0ce3257429c882eaf46466e0a99e405b1b2f96f5fb9388ac641f0b2e3268bf1d6ca57c85c4e8ac374d0fec3f05680dc5fd92026fda91cd07ba255a0f8b76b9e6fa76fa6a37a8324d1e760501f690ce9c9bfd9f01365149f20c9c914427344a565fb9ad0f106abe4ff5b50cc7e8ce0a7e6f7f02e5144ed0d8d6fc756ff715945330c00a20e60e081de46ca999bded291e8e42fe9ce693d12a8c54f1bfba7eb21b7c65bc3c00fe36d7a1daba13c3efce62541ae0dcff8e62e7610c9343459df984ebbc72eb4e74d1b760db754199ff0ad7f1470b8f69f7e665cc73435466da33375a8c3854dee2d80eeba6bf76b7f63ee24e4fecdae03c5b56566dc040c2d4e7abe2398bfee5f696c399ee7de8e27ec9a46818e8a4efb4e5907f56ff65d6ace4ffec45213a0c9e6773767778aaedea3527c7ef56403c0776f2fc7aa78e163904a9c12144947921e7048ad65deff855f87079e15c2fbd7b19fa5e9717db7c1300ecd30cfa2bbd5d48c7fd45a6924c75b77170f3edcc6c2c1274a18a4cb578ff68ad5be28ca977e33ee915ad76326838301846041967c0496e609fc2294fc8fe1d5991568be13620e1b41a327f1343b48ca1924573d6ebbc5a51f40f4699a08e5c21987d780a38705d0883e547a85c53b343673e098be94c69acfdbe5ff57f512afc911a77298af25200fad8296995dbfc56cd7336a33a65379a8237445c65cea67603b1fdfb9b23ff25218a3ae871783c7d46f6c430240a3590e040cc29354f606617c0eed6df842d2cb20ed2129b9f934bac28c054b7b6f04576578adc7a40ea1690718b92aa7dfdd65c0d25b017e320743b08ca731401224d8952f2cedfd81283f7a0011bb8933668a1818855b9d582411f4c39e025fbd2061a2181979fccb33c0dd84b5db5a3cb1ee95a12429cba70b709bf724883f5ffe0f7dac4c796ae91734fa416eedbbb883d483ea4cae07992232d359e4800f14bbb0cf2fcad4158122011bdd5d19848925a44ff807e5145f45079fafd354d223ee2984b68d451289aa6ce558dd87387e2f5b66b6aa0bd2371b95ce0969d7c63322f63f7c630e23ae27b998a770b1db7558bb9bf46c720c03e6accb5783666064839c882dbb090297f1217e7455719f3476538a055b853fa98b48c08f7d4f0bdcc35ab6fcb6d3f756bf9fcd476cc2d18b69ac2cda8995bfeeca2e4a8bc9363982592f75549d1af89ae70276e1941e3b3f968d447b33762181df5e49d0764b82dca6f2cd1a3767ad551b68ed8838f03ab001bb501a068173ef3cfbab1f06745f364ab31fa4f211e4ccbb2e779871d56363133ca2195d7515220eb723c8697d2fc60e1b2f0b7cc8d7f6fdb7c248caf27599cda72a131906fc6c6f2501d25a1dc39c2b2104e738e8f226e73d52f28ea55b3383740d0c59c0b0952cb6a4806106f37428ed2e1a486c44c69dc12352db6baf5f62765b5817f15ce7805c98e8125334f56fdd7b732c56c6fb27524aef20032fd6651c9f7e92a1f17fce3266b868fd0ed6a32d1514b1155156426b0f84cc5b3732f4a1fe82fbf7931fdf635c5508c1b1d4995ccf8f6415b926a87525cc81660f0c84e878176b5ee86a9de99536fa9b19506cfeaabc73c1636558f57ccd427cc2a4e7c1b8cd4343fca92c22c7d488abecb2b98b03ac76d354a943bed7635945f8e369bbbd7e2e9f3c0c2c92f7e4b48ad054db1e54ecbe892ad30974d206684158496b03c47583052ec6eb735b188eac153162baca1ab2758910a46785617f0913cc603f519cf453e1b26d449c386524dbb87ee880a4d60479f81a3a9fc2d0e5973cbd1c20bd28c3d9d7dc1d291048fdf1a7f4455946c1d0b48d3f6e62d1ed8af7ef818d46f605a14d56dcef6056be494745f054fd4d6d0fe3c3533bfd5cc1f095d2483f096eea6de523ec1299782ec0e9aace59356679946a86f0e0b75be9a53c27215fc0176a5227c84603f4a250e67e122bcb897ece609356a6aa2207602adf2d62b11b4595779c8656b762b26e1b8602eaa61955b4fcf60d93f64ac0599da7fd8b41dbc705af5e5d455a625fba9dd781444fc49fb6682835f75bcf180319b5886f498e5772681ddfd544f8a2bf5731c3662fd9487824a1ab884e5383968eb8dbc05c4850b34587ecfb33619f738dc2a647e9b08f142e6ee9b3eb67da1742be371c4b5ea3adba947ff5975fc83a5d1be9dee03bebead8480682191fac918b0a745c68186e951f464a52d8e67705615ab872bf38c8ddf93b59e296f522e9453635893dafa50c2fc7c6fd589149afe93f5989399b7434ea45e35a5f9f123e3c2875d0d1a90fa902df9e0e94836dcf69b76216b9656e2feedf9739066fba3c0dd3c0206c9ebda39e1737819016697b5685814bbab151603e397b2a86d46138d00e9c6ada304a68dcc66f92f852079f1d2bdf3781ba5c258edad7a281f5eff7b3c8ef56b790595d8dec0f1829b8197db0618174fec5914f5aadd73c12b538c3273df6bf4f6949bf400ce3121fe58d869aa313c476218e0ce8a02fbc1a64468f424c7d57b1cb6020e7743b8c79bdf8a747c78a7c01ee13acc78734ce674cc0411a09683dbf2df2a01ec3b3390a2f86c1edb2fb08e640bb73d57d662429b5f96cf37548fad6c915c01ee491fdea46875f9335303ae269a640e9f15547cf7dbb1085e75ad1a582699aca608ad307babc7b1df7afb93375cb468076b5dd0a12430aa7a4dbfb9d73b5eefef2abbdeedd73837997b0e20a253533552ccd0141cd4af93b13977aa713c2cb42b6d143cacf509f5106ce1f920bde3fa50441864d382f7237d3a26bfbf280b7ddca134f852acce16d5d7f57e733435f7814e468b4792b8e4196456e8776adb430b3e83aec1265e825ae633d962a1860dee41d8bd36f211a07e59088c3bf44ac594be0ce5004dacfde5fb26e0e5178a2092ca90185e31d4bc3b1d3bf6958784fdbf68f07622d29826f0fd27de672ad0d235029d012e49444c53168583f2807310c55de3d750580efe53dfb767fdd49f8f72e607f787e99433da8ee9a8de1f8e23ea467a3201fbc5bbf462c98a2e741726c6bef449c061fc7268bb89e230f54cd9a722b742f103ca119a9ae9ad39e15f5cef633c7816101928b9fb3d803ad09563a77a6ee179bf5b8e57eb99e8fa369d30b26a75549725435044c68a7a214c92d514595bf61d2233354844b0abd964f8eaa87f545d82ad5c68348773554163534a67456ffbbcad6d8b0d5bf1d9f4a686ed967ac34be7c6143237533319eb883e9ccaf603b7f6ee95484a8afe21c0a59d4d373415881f6b368d61b27fa4c0436525968effab3772b791030655ee79388de1440bd8a590fc1d30040a77178d4adcb343da7581dc80eb09f3b09eeb4781899721cc56f663bcc639b9535da3a8c795b4484789ce8dbf36637ae5c58b919a705d51a68334b6ad32ee99ccd1e009d17582cf4ba2e7b29da0d55f936fa1b1d77510494359cc588849246f8c540f1d9e480bb54f5289bc96043b462bec01157a8e4094d8ccd9ac159f2f1dfc15c634452fac8923d8f95df3e023221d26e9c7ce870dc7132fb4663a8605290afb0a9b5ad83138f692da4d79938d83e33db9622bc9eedfe06909dd7111c6773de8607c56a6a9e8000be2c0eea6791182eceeae59360d4a28af3be7d4e43d57cb46d256320f5fd62d477bddd77e0814acac87354098ee023f739909dc9cc8e3332ca064f7881d5d90e84d482e52b2862cc469d85c177485a6c68cca5dc9a6bd7b096afa3f7b9aa3d074fd40d7bc876ea5df257f53a3685ed4975f0af0f19220b65ef12b77ac21f3a764fdae00515034d7689dff770511af72534b9eecc43481394f52c68be6d6a239620e140e75e185834a74b19acfff5fbfeabc1a3f7fc399877a6ca49d65cbd29be4646e56ede94efcb68d3b0353fd158242b0750b31a9df185756c86d673804b6eb24d0c8d7c16d62141e73c20fa5923836aae7b1fd0bae4002ebc25fd6651694b774901d3c647b5b7903db2d4af28506a4d19d4c108c69f9292b3da2961b0a8928656960be45f08334d349b3bffb12ad80c51471106f331690300053461308e79122ea52014f46627eca4011493c3d831cadcef7af766b64e16f8076cbfec8080f7d9d3f9ae2c3ccb4cfbc5d19af318584ec9438b1aa12ec63040634ac40b25c79b4232837847141e9f089dcb14d7fa282bec1c9e7006dc63249e31c4a1945387824414886bc5ccff0d1a8d188652cc3fd6d0339f5a0006bda82db7b8d2168e6ff04821ae6cdd517e79b142ef5fe06c370022221d8b1307c763f00619424efd317dc9b0c6c395012006fd3ad2052f1afaf8b83d08386d61921c11bc78a54d6f65908c5afb69bce672dfbeb22ad03779ac987766986bb906a448e5d6e4ec770de1676660d1a2df55ccc920561b9bafc5772abdb832826f5bb967a51118e6ccf71e1481b378fabdce94601d0d0bb90686803a33f1b706b7c9abe1a8ec850c0afe89679a2717b1424d121f8ccd86bcef61db459487199679014822b41564ac6b524b1d5ea46e023d02887e139cda7c7314fbfd03c3afe42f6b4caa8f1fd866cf002d6830af51eec37fd484a94a89f3f9587020800555cff8613e57f957bee7263f243e755cdf73dfc0f32c8d7ada25220e41a1cb8b55794ab115c9fa63bb3ec970b2c688a56c9ee900147780e92060c9507dc3579838582b576811310ac200b7f1dd6373e97df2d90851072cee1f211987adbad1fdf3005ffe3aa431be0eb718bedb315067425ae353a5598a003db2264c7e13a19235430adba315a1f6a58f4e66c884a1735c108ed292dbe49904c5c9194d266e4e5bd29ef85fe375bc57399c491385f2b4d8120b746e689feb893ad39a40a073777c95026bd1c1700c6d1de5b3e7b60bf618a51d558eb09c7fffd75bc7802a8eacb6c41d5036fa7464aed3886ba5da5b8190570d4f724787077f7bb4608ae86a0a8817ee0c07bed2c3a80058f73026831ff55f6ddfddebc351c6eac73b8dc92f941082765ad32305f75728eef412efedecbbe2ab584540c63586b2abe59df8f6c890dd6f0650fe4ac5c23268a40d9b9cd073916baf26d6413728fac5c0d15a69c3dfbbb49f6b8a1f1881c1ac28a10e5909dff7c21e0471f2bd389984ce8652ba95220b9575c4212e0938ec02e9131d7313fd4a563b7ab36ed79563e89882f55baf56f8417916095a3ac8a2dd290d70c34674c394734f2efb312150a66c9796796158877f39e800827768749df73d6695d9c58093f3b45e942bcc9d568fef5956b8fcbc44bb31ef44ccab7c26a2571cc325391fba8076a35398ef958320ad5eb7fa6b0b7d5d78d8f7fb6515991fd92d1384a424f38109c035393137f1b10679313671b794df1350b54842c3cfa72a96b07e5eef74ec46d034702935e68dc22e74a863fbc0d77f3b87a50ff1f2176acf4181403a5a82ce28fc69bec3b6bff32204cff07b518315ffd603b3c3391bd79e5f0d153ff6e6e3c1aab70d0377182498c321fe7dd8679a917cf0fb0cfeb00970e935d92c9d15603fcb8cd29179805de29c558a99a96396157a231fed565e4efa9e50661b8dea74258625f2f6f843d11e6fd6af48f1d09db0156ffa3f27227b6f43f40e48852b35a7a08eeeec42ab540078ec16b447a70d64034c0a1ac72c80d1a171e5c95ada85bc9edc3206e6e657421dd4d6839cc58a9609c5cab1c360a4bd4683cb4ec01f3b10738d75464b8cc7b6cc85868fb858d6ca3acadd9319e6a3835b4e3acaf105c1d32a93896ded959415aa7589fa4ce6635fab9320a279f9f43ea63385643003465040289ad5f51b0b4bda9fc9f31010ee4394e9d4ea7d0ed8717fee62bae4350a5fdb39e6ce35bc89a0159f3458a222fbfeec9f9dbf923697517499b7c37a3e40855559e07a50b1badc7a5dcbaf9777111b6c1ce5694686442929359a272314c6e02f29cfe787745d7a65df181b7adedf70a2b08454b4271a663458a2b8b09cede15f910b55f5613fbd93709553d38069b4cc71fb8c0a3ea281c28241fa59b88b3b272588399c9571033ad35708161465ab9d6181bf1d2a2c3a44cf2d2e45332729c19ab5abac81070b368409882b5215b7aaa5d7a8edd5d5dfecb15ec3158565005e97d77c76bf8a4560c4f6e039f824a5b339f129b0599eb431cb2583c1e9a62f521bcf39f398d5e500cdfef3d9fb857e2a97d5a9c098cb4c3c7bbafe3b3f955a7699bb409b23827afe625917d15b194a915f762c5af08131a1a6f88db2ea7005ebd0a4b633d601b1b51859accd711dab2077f79e1e981ad219fd6dc32e46afec601cb4068247e4c745f22d5f305044ccd0ee0b68d2fdbd8b5448311506e59335c166635a6159d40132ef4bd78b2ee5043392eadbfa529d2d28966a61746239ab41831aeb2366f2e292e3759621f1c5a9981dc2d3436a0c33cfde4a384ace0d941ace63b2b3651966df7beba8161906608ba4aaea9ab2d9c761c215448bd8944b1f6fd761c3d98daada11800c2c8b150f4c6cf73f0b0b3a38097c2caf7d681acc86febf774eb6e0fd84fe281c8105c0ad20bb44c7a71875786425b2e777569db062666e813a1e6c049b396fd6440bb27e988cae7756ea479317fc8493bfe94a0fcdabb928f9ffd237b3266bf959bdb829f769eb95da32cd2cd7b623fc744d73d65c1498e802ba71632ce4aee054b6ef356b56a79140bffed7ad4dc56d3424d8f80cb71628bcf9a9e9b20676e7a1ff602df1194f01bf34183e04ee4834f088c521eff366427cd0a4ee0cd9bdcf8e00831f475f6f22f669f90cd2cb93e14c760bde399ffb3806df58bf48d2390da6000fa3d5b2d9bfa24fe262f8237e88a5f46250ae61499dc4cf645ad98708be9d43b72cd302b8ab5739c1d56e570aed631000d7fd171cc3efb1fc74e2a4beb3254184d8328f95b3051bd0dec227fe46af90dfd9ec31fb640659e28568b66f949a8a441cc69b51e7516d10503c92657b3e655a56bb398db313a2642ef95126115e06b304727d4a1678fbfbbd8e922bc3a9deec72a24acb4a4a8dfd133c6ef3ae093633369f114c875b54d9a34c4b24f69588a2368d2e022fc61a74f77d74c2e459b705db6e01c5e357a142fb5f1730dbfa73b282add52084a3440337556cf7edbec70859f1fd9a3b9da75ff989d893bb28529e28a46707316f0a59329cc0fc9d7bffe3f26610281c0b27648127c5c51f1438a9ce597b5b003e158befacb85b359a7a26035ed2703b18ca298111fd6cf4eb968ff4d0beb878220827702c49c83c9414afcf18302dfa1e64ae17329c85b74c419ea1f30bbd3756f370798b84f2caeb15cb024272ee09ca6012c9bf7e59617bac4711bea8c04d026bb7f5d3d199e30faf7eeb7a07ec2e999ccc759a686526539729b9167d5256acb64e30b140a8a14c742609432d97504bb730c52fe3e0e62f74ff498f276eb46a7be0d9fb182e5825ed1c73d78ba147ee575fe5bf859e86533332d8a3b4c38f6564a84c0f8db8f81d3ecee69749e8349777e49fa0226e272595f62d76e1f073258788c9995828892f4ad4e01fe7f473cabedadb1e65cc26993afbe28efe7897b1203da9ca9760946eaf7f4a5a120990a812590bdb213680bb2fa90e08acfb145d594b62322eabbf101971e5332b5dbb11dcdcb51824f693f08c025d23174f30ffee6927d00bcaf81bf928f9e9ff8e06aa0fb5664a05c4fdbc333b81c81d0c73307a3563fb8db823a0626154a4c484cf7ddc49afd20fae2b9099803d1f71caa1c76be4ccf3cd55bf1226c7ea6c680c5e50d8b4bb2c5486512a4616c8682891262f8faf266958a65716caf8f560472248a54b3206821b03f08ab5b39b4183d133136c76e03292d6754456bb8aac84b8b47883c5c7ceee2d83b5613d7633d2089348ed729ef99ea2082a14281deaf4d204e7daac1262d0023536680a4a096555f0ae0a71a1572abc76081417a51574bec8213bf4033e84260ed825af53c59043c2ae2006defcc3ec017fb2afd425a9517b799ba8bbba74745db79016a22e37e9fcb244e1847d57a890adbb658d7e9f9c30e0a76fc16dbe51813cfae50369523ab45e1aa6f408856e0d4e0c708de1cbf1ebca88fdcd7072882467dbf9604a0e935dc0286487bea1cac747963a26cbf77a80cb66bfc1a07c7ac5dccf5d6a9c0ca4dda8551c5ba71288fab8ab24364726d592f156922b765b9e7d9f8e2cce5c2261342f1d0b73d2190c35e135dca4cbca184f6ca26c051a3ef065e6b073e10dd533145bf39c188b27f3cd70ed488d74a28739085607e6b41e07223cd6fdda8e918470f983710d7a08d7f65cdec35c5969de050de9d9f1226d54501fdbaad33d8092bbf8c6c145c8636846c0710ea09fc03709f931ec3e699922aa11757ed7cdec66185ad8f709281c6d16456b28e621efbcf9e077343c88e5c5362517e91cf0dbc651700b7e50f4b7f4f541b3ec5131ac973e5297457d5f671dce8c89bf3bc908d44428d6b9d2d6d0f710d40ba2a64b9887d3538b83d5d9a5250a6cd1a0691cc35455e0ba23150c39ae71373d10459fc597f333c5abb0c94f0a6c37e80042c10eb9b5ffdc207a3b07f5b1168bfb269f7ec624054d0ed0a7ec4f78b79753262c189869afcffd55c6a66667f1415aae20c69fcc0d08bb747ce3730e2aacc7037514f1b0bc9c780bede24405d343c822d20b15ddbe94211c083de4db9aa20eae8b07ff63e3a5fcf1193a7988879eeed8cfa8fab17e7dda699bb7d80da1252ac68547dd37539584bcbc215c785bc9a5c7c56fa66caae0828fb4731f1c3e95fe2a64950f9e1398291bb94a3761e5369c2719434affdc452008dd81f446970ea74420d6c21fdd870977f827011d32f459704f22f1b95181e623170a014a41986ebb26e4476510e67d13bd2b1a89410e48c8ce735335111b931a079b85473ca32f8b85f2599c4b429ebf4954c5514233070aac9d990a59daf8857c1f73d35b04dc65d3183be60768d9219ec22190027e657481c9368937c4c0c31a8aacd5c3c90f105322cb19f931529731d78655bc196955291117956d329fd655da0b7c22a980da49de6ba3216d533824b1c8891fccf4a1f74e9802aa61127827f4a3ec14e2007793e0b2eaef81c514a68c7fe5d96c0d8e258938aec42d72697dd2718f7dcf93993d2536e355c8037590be5df879b029f797752538e75861f7cca379b19bf664b58dc346e3eb261bc88bb94fb35786c8d5758abd71f573d974d7ffddd7c4ea64193ee5ab5da958e9e32edc22e6b91028be3a88ffbf8ea58dfa15b229dc31e9ccd76956d6b24ef1ddaa19677965a18565f04dd9938a9c6fb0e2d47fb83faf63d80a9b724bca984adbfd6b783feaf63a8acf8825df0e529c8dae7f2c2d5fc03177d8690387666d538202e66951295025796e53f703106a7053db0272b01eabf5003ac55d22939743edb84c5ab6df19a0333fc9b5341651e74f7b7fac40b6022fd00e5d718036677f44247e900150c0f2d2a8ee1363ec2606943859695ee619d87a89eea786c3863cc4dd1eac3ca96f5d994584bc8a80bde312d4c95d8bb6d6198af63dfc8f0d51b0b321d9d857351e503671bba5e84b16fa8b9cc70f6441cb5fabc55e82e46d3f62c17f616ab46877af9a2424c3056b6c95d8d715611f7fa5d9e21b0476e630161e3c23638e870c59bb4a9a72e17587ff2911826efa319294894e6e91576fc7c92a9c90a2469171ec46ce153bcf667525c7f99d151826d7dadcf78dd71019e22a17e6d8448f673b29fddda574def2d8b2b581ab285b356998191f3c450e6f38675c738a422f7474f0b09677d5a4fde40b1ee04837d27c21c92331ce26beed78881fc79c4fad6b2a89994e47425c6520fc7f07045000b2d19d7dee22e7ecfa609b5808854898e08cb45c00e59d0ad8bbc434b4969ffdcd6c81dad625c22ceb7bd469abfa700c6072b8984ed7973c4ed68a96c89dd2ba582154b8e98b9e6e9b7e13aad256b25e84a402818bdebabd9553751b4b17ecca22d1eb2ef0fbecbfd1ecd57f4c4829a6c2a8d885b9c647eb68d9e26f443374b17f1c6e459e791794aa52a67b6f90817aba558fbbe46524c566502b56315ea97218b8dc239c39d7b5dda2fe2658465bd1b5f2dee36ac2435581bba5d0d77300549cad5c453ea59b29026b0260e732749f3de0f2e4dcf9bc013ab456083f0aa6c7478c6493212f5a13720f0e8dd86113317fec43a5da6b6e7ed7a6b3de4548ed1de0e740f08a0ccc58cc887b2308d9966a7a2e25d3a37e38d3babbae441ffa841fe50bdc6618eb0d2bd579a68e951ee809e0b7af382d169916f1826b968fb2867b2d99d6a294b550516db6c80ea92ede30cd051bf54b11b2d1ac5f4ede57add66159b0de62e5c3b6645c4058de226ecae92c1e0d503b32d061d7b33c49d2331bcc878cdd55549f7b7bf62dc7a758ed25757e8e349d3fc60d277f30df1b2b68a344783b00bb0f0b7d44edf4e8550b39081f5569662f848bd708c73f8662618724d673ef43c40a4901b422627989cda5fded60dcfd3b98c9047730dae601872b77c3002a0a1aadb4728866c15ac1d8669365ebf41e92f9e398fcb4df3869a5dc753230372730471d3ea7189417703551d75c078150658aeb4707cb760cd126256fb84b82905eb202e3d4202e1667102315e49c1f23088a680bf77aa165f78040d42c7e30ff63321f4aef2e1f925e784953207f10aa0ab0323f7272f16a1271e57bed9a1588bb0dc89fbbbd792786c18939f7120ccfbc709808ffbfe9c4a35140c49f73d5e53ef45fc7f9ecdf234de67fe082fa55384074a9cdc3eed0e3b3e27f9e415608cb5b92260ddb4300f883e9df058732b8be8420768f3f289edff72066e3196dcc695de9d67c9c1a1dbff45896b77891bf7d092c31e512ab0d3cae4f97dce73b19630ce38c1841ce0ccaa052d9cc48c7cd7eefb230753d3f6090acd2578f38c2953a2800e55bd0f85f65812d1868006e49a646554a179a377f6bf20f534540cc1283694c1fb77db997c5f7f7556d143a1ea89ec4a5f852daa553d8f8a8e1662ae6f6e42d9c778bb96adba90e57add59c3038499c61596fed989c755e8f3efe405d4f9a56ee78ddba8366354e1bb36644786539a3838f213c87fad321bab07bd8fdbff26b2a6a34f2f0d6aa58887090712f63c150df89de3adbed8ce15fd0fcfa2919f368c8a4b421144c6715f9e81625a30f695bf095c5c7fd7832eb01845a79534179fe4af600cfa15aadaf905a2532e87bf05e31d17410a11675ada5f1db072d81dafc012b491589ca631d5d0e478b0c9e047f3c251d516650f2b7d9a32f4bb3ab57d6b298524a2d016bdb783be83ad993869e6cd2bfc5e19c8f8ef30537270e81aade1a2e4d1c832a47f58f0e72da9fe14991d1113a132786f9baf1906889399bb04667a15f8cb60a04ca2a39da644569437e85006a0a89c41addad270d7322ae66ef04d28a4a4d9eff3dd1afe25eedb500f72ba1d762e9e0c3f82e3fad195fda4f2371a485cb7ad64cffa7944a8d89c00827268060ccaa26e1c58218bcef57c293b438466e4e78aa0d00d03d8bec9567597546e3f8f79ea9aad0da95156fd9001b8722efe8dbacb7410639df6c5d13431c3446398df6b434ebeb147ab85a0875766a54a4ad667e90bdb213f06d50a4956a5c9e7550f5dd14d4299c73f2bd1520731034f1cfe12cbbe319f3006925dcf72379a337d645d0efb29eeeb9d23357ddde75b875e355963bcb6634225e99e3281d371aaf7b14a8c8437ae2373703296613e85d389452a749c4afd9e504b97a9a270dca2259e17407b2ce4106a702997dd5ca245e31f69c91b897e5e17505c84f92d40a073e15d16f25c84906b24a4af3a9521c131707922bef8b0de22bc8b4142161088b388e5e22726bd265a4e3976b033ac2266ba968bee29e29f095208a3a2665cedee0152afd6332ba3a2dc009d25a2901c2b6868f85658d196db2d4957155918f170c2e40aabe9fa333f1caaa32a1cfe3a43fa479570d5dab1aaab66ebee202e99f68e33a3cdb88626cc5118e9360e59ce155c2f05ff82f6efafbd66840353e9b636e119335882fb6a264804e790134ab3ffe36e98992a6ad7eff0488a1d8bbf6f1edc2118192ea5e62541ef948ec264b751e5697783bffbe8014ff52c2da19b71b6ff263842394ee083a7ea2116dac2bd194059543e34f13676ff7544caa2b398c50c70bf87dc6d103d7f09eb6685235265e2e21183c4c91cb7ba9e2b970a19d9ddd5669aeb2ee7e82ee8e74c5644ec97a8f67517ef252f8acf037caad085f6611a4c14a7ca442b81d2a3997db3979b320087e2239037c45cb039663f392408c18f1da0c7588f7bcfaba6fc1229d78c580f3e78c25094b25131b0262a02d18437f436933d57214e4599f48c47ef6f69530ab72160ea512ed3668d74327046bd2b2df34ab05eea04799e3e2dc695cbf6d05b94261cde7ceb17c5ac436d7fdde17343cf38bbf78ec03bb5c9f45de5436127b39aa621ef0addd4fedd41e5b7c088804628da2d68b010ee41b32b21a0905eb136620f1e6b8ca54992d22ee586968dcc5bb72d8b1761bc6d350bfb26b89c497febddc18ee2602ae07f6c91cb35a71bb9bf827d2356976e18df8270c81102da17aeee3ebd292e3478eb3f21bd0d4cdf3e2c8aad42b8709ecd9510186ad062d3b179227a118410322e2373b2de93d0afdd1f7c6965456a28f3a97403e6e6bb1b6e53c6539506bc18044699df298f501c8b0cdec1d627d37148efde0ed7d4b238f69a50752bf872b663d0f52420a898df65a0b78f390f22cf385a24b23989cada1208ac9374e940a61d2d33b163b0a90220fe9f8f0f52d3b7a01021102281161f20214d72e483f066fd64bf74832823699b68832fce5c18965eb3e1ac221a609377b1000e2ad5f1a9acc9c83a544a2643d267613baa590c420de2a3ebbe82760823747a436413aab8a64bdb394684148698fd7f131f0b22c31573c0aa98b5646c95f1ab712dd2121adb136ef60aca72705f998815c42119d8a98ee7c0b46c1a66816c83c257e9a42f59c1c76333f9888eace4b604f17a4cd029da4ec4c58795cb292414b83ccb95df3ee67214d452f4480bb8504ce6d936f800645b749bf2994ded60a09f82c30b6a830cd2d05491a3abb8bb6e267ee5dc15064c5c086b6f64c48b3a6ed5513a520c4d158d048a827b48206608b35a73223d2d21124bfd2b7735d16c43d6949def7bcd81c7737a55aba93f845ed4a36a62ffbd4f9736d6626a00e6ba11a72257443cd7f1220c5b211fbf2143ea3eb1f2d559e443b83beeb98105109732a2995b1b8acb9f0f2e9fe0a10a9b2e9ae43385950d8379538fe104c92203e8349f787db3f452639a90bf722d195a4ef4c60d0b048953211821baf31c18085f39b10054336d8bb2a85789557b8cf4043da33a53fdc888df3ae2c68edae399dfd2e344648864c3a910cce4bd15e75e9819e579f19cc8f9996891592547d6137a7796965dbeed3bcda4e91006600ba849e65f7a33a7d58276fcd1b10b6d51848d8fdcedf4ba4555a3f7d1203289919294c8000800bb92a67dee90a782b2949883d57c7ffa03f4ee29f3a2c610ffa3bcd27a9da55f8531fecb10333ded08e16329a2b3a90ed165246f0286c6b390e7a022a5e0a23304320f903b5133cfa0f9a958c8320e2d7b2f63794bc7f8c7b9276808ab33e3963a443c8afd867d7896f6baf03355248797b5e7b745f6eb7fe860cf3112350ed87aa247a975dae54e90dea35c3ab36bf380879e05b29bdd5e4db558bb63d9eab2cd7a149fb79e1ddb8ef2d835caf996e57c3090dbaa60a5f47bfbbf879101e92a323c329094c36b14218981441a6780319be852df1838e6e090bbf3e7a622397b76f4fddfbc95f228fe59952372e552861328406fca967cf83495fffcfac53d587ea14df2d9e82851de3bbe005f1873bf382ee1e099ffedef3195bf09724a65c1b63a96c9b13b045620ac835e9923a23b5b7974dce76504384f40811ae95b07250824898148976c0cb807a5eb268e989f9691773c217add4f120c892195621d9895519bbbf5fd94d8bc710933edccd148ccf34e0496009fe1c841dd4a93e93932d2242de7e084ecfcb3ebd5c1bc906f5dc014cafe6f2800d4d18f06cce279fa96ab997c120d16e3840e3d158475e021ed18faa71497dd4d38448f7968a7cc206e3804c1a6cab74ef052e6049b5bfb16e65cad9838bb5c8fd7dd392680f1b81dc9c0383909d5387acdd29ace30bc96ed40466b489b88cb6bea864ea854c75eba8885a5f1dee3c0c499f55659a423e516e3f1e22fa58837eaac5f7a1c4a29e263dae092d9bcbd17f0341a95fb307405ae3f2312dd3a46b9b75d0c7773f3cc7d7911fd03160a3a6055fb07dad5b39cff34b903dd3394bfc5440aa12da4ee7d9c2b224f4f69b7f136f09562ac41a9da49c0cd8aa77a35afa765b3119a1970345fc16fd46f4c1cf55319870b78223088925190ee8918c3bc8737859c27388d5b0f1a352798cc5eb00cc080d46a4ec92cdf2d80e54b0745b3516a101585dcc87125ee7f6d377df2b7c1ec19b4a62400d67ecf1eed11631300365cbd7e7d5959a74ea953eb925376117ff4890dd78f93dff9f0ddf7805558c7b2058a8ef0e4d126be70bdbe44d5b30c22d64ebb6e8d1fcace743397601405a3ebaf2fce4af0486c210e49b4d9a154a385a021533977806263a4a85e588537f95011deb375c2c2e265683e61254eebf5d73e568182a774eb734a35405f8d30252ec7cc4b6f67d87d6f51c20cc9708af987f3c406bb34f37c9f77145d76ad0746dc353c584b50af31c590b0ce19bac320357f20761b09064c8477d883597011d0d32246aeac64ba41823c78937ffe91138b2a5a20121ec77cd57067c4f758efdf3c3d8a17af24ef5ff0b948d3e229269a62d9e5d136ee39cc65805d145a3dda2e0b17bacdab965b3b8ac7f73811bc8101fb3a3dac539045dbc47d592b7449e6bcf621daa4c9f680834aebf71bb2968e39242d34c55c302b0d53ceaa8d77c3fb1ef4787293a3adcefe3adbc8a1c559e3290ef0ca36e8440249400ebf720b2824dff56b46624e09d641e9645e99fbddfdaf85e2e615ab216c398aa31144e146a2357e6dbfefff56a79ff1f186e58c10b518805e44d3ca0089a04689e8d845994a7553a682420b0a9b713f8301088fc56dacf2777e6db19889ae5d9ae2892c69a194c24d13700eecd7c4646467f650abcc875153ae0c7ca898880b9015db67e9ba1acd1663ea9aa2eaf1e6e02f87c257b9c10a0bd79028876f2981ca6b1a2bf9aa8d81a66945f140f4145997fd1dad89096ed373da8d52479180e2e5a12ff1566744741ba2a71d317b2cc12a90753f423aabc5ca207e4d536d15877a8403b90e7aa1af4340d26ba135a19bb433e2eeae3422eaeaaf62f78dafc04e48cff98e61fd1dc3573ec91e86c199891b6319a35f143cc422ce634be854889dfdecf920be8a76e2b9cb1c1c6538be40c00c528b1d02a0a14750473a1de63f8fdf40ba73f4d854c5ef9204428316d0b9916ea34b82707bcde166b520874cf5d05af4e574fc907abdbf4e26a8987a08e6197f94834237bc1ca65111b266f883519c90718fd54f825d9f0ccf3674a73120558642e4f1760734f2cd241a0d90eebed7e49e2b71e06af44","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
