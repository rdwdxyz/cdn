<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96078a072fdddd2ae5b963187156fae4dfc9981afe3adf04c1d6a91fcb9bfe53b24e962050d2ed32772dcf148dd8da422d8aad6f37cb7a47bd618c212b185c1de615e8e9b4733303d4fd7641551f7a3a989c6b62bc270f0abb5753a8ff8c4b82654972a0a5860ded4db464880e1aba1268282547238f74cb444d94c6c4b231ff3ae42a683487dd46b6c9ef1ec9698efb3ad4bb20de34626e7d64b1cabf05e0b3880f8df9d54310b7faeaf2a456c8b162d5d127a953d677fbce41548e2099dccde8a75fa740d5c3f2da001303471328e7a07acef59629bb87e98f937ccfc5d5897343d3fb99ff75e3c43641fb0e2ec8e54123330e390c2614281ed38dca880731d407bb26b454b6523c830d67e6049fb74b4fea1879449cb3ec5c8fe6acf6e0d96d9aad2c27bc5f0675eb89fcb181a5632cd010da6ae352fc6ac1724f40ff293d0e154e28b3e0402bb7f1d8032bd30e6157c2c7991c070e1befecc7b21579b581eb572320260c71597fdfb0e1de218e6b72ce2b47738bd7940f4ce80b544e9e6d95319ee7207562aa4f990ebb2b3390a1670b3ed90d652059105c67543c526808ea90d8a87eafa7033ebf181e23ce5bb8aff316e8aa3ee8eff14e653082ce2caab820317911f97b90c16eba8a25784bd1881e0d89e27480a5cdd580e3205eb2ee606ef28e6e32db7a67ba90508e78f5c41db2f6e03d40ea76f19e36cf131883a72c7bee9d514cac36d23b7540336d8c7777975604bd86fed78f21d2c3c7dbbde4afc0de0110843dc3391c7c8c097d8291d14360b677f1da39371fb09c1260acb8d8f4a345da71233be25b4e1a3b92cb84799b07b9de07b3e6d4a55f81b2bd36462781fe0d675b82bd1a77cdfbeb62e935bcf137d310115fd6bba15b1ab59780564c588d9defaa973ce7064e4e6d156986ab4d4e08b16f2aff740e86f85153a449c131ee6cb8a3a8d2327075496c4203d4263288d8ec2e7ac091aa79cb0ebffdfecfac539b6cc353b80aeb81e32f2d96241582f94f3c276a065e1878beededbfbf72ffb1d54eef21cc5996f81ffb42c9f5a163897854e8568a6120aed0f8bf7a24890b640c588eeaa5dd4980528e64d4451547da7b85271f9b7bff8a87ea7430904c79a5359455ba9c564db653f23a129c57c87a4e25c190aa9b6b4b22c57ab6827530588da9e204d40f4595d0017798e98a2f38d44cbb3c27259ba4a34cbc327850480464d3b54aa8dfd86c24b8b052df390907200fc4ab595d567291cff770302d065ad54f434b6b9edfc99b05c533f4387c4b9c12e2c04af25731ecbbdb0e7d7885d493fbcd26e6e7bc003f96f2a0a8b13f636e2f329b631b7afbf83911c947d59a4ef85823448d6f9cc98b7fbaf7aa66052c56886a04d4aab2fb5daa07cd2191511104f0c11a7379445aca29f3d64f810c075d4c6dace10a01de40dbda612a0b0d3fe1807fbebfcaf6047463e8393ee664a26aa19986ddcde39d91056a6b6e2b1c249abcb82f6310ef9d06da3c8fb66b99e7748829efc5c3730079bd28a89d635ec04d02924e7d254280dce2d962094842d08379c561b249df5b52aeb9296ff68f86d22cb903eb171fdb708a4673cfd08940954847289fad47f06afa7f21e5eb513bf78014aab78d23bbd80b25c67a13bfe8515d4898fef6eb9d678dbdb391a6e61d2589ceb6672b2560f8b1404df9bacfc6486e0c4a93ed0d45174100b6a82b319802585517e556dc6b85c2e0f5f7947466a9c312e761782377310aaa8872445bbde2d292ad2f717d5634189a281a90db8a794d2731f05521f3a3b5a18d46b3115ab0a2510d02e8fc3fcaba20f7ec03c630892d325b48c247d5aa2e4b00c62aa32fd2223ab987a585b5f4de3045b351740dba9d9c24a8bf9d8da1652ee91d7a5bacbc0417c8f6e44ab4b39370c0779d07c642cd604e69a90a47d87d3ac4450a5992e4b3d83dbb28bebeb3294503b1c7b5fb730d449d29ede0640543dde513be26d6f9f05cb90b77d17318c6cd6e05f588f2eac0b53634a29f9686963367d0a50fba70795354640548f9aab575320159676398030d56423ae5b267ddb2bac50650921fb9304933b0917b7320d6df8954968cdfc32f45d242482b5810484b623128c52be1435d34b322707d31dd93b20d0b435fd3119da1140607cb812117b82456f7e80701d64360509bea6593756f545deddf37d943ddb977f12118fbaf9e2dcdbaf5b8b47b7e5c60df25299004f63dfb420fee0e6e39d40fb71df6df458198dfc9230dd43305194cce5d94f57b3eb2d86ad5e6ca481cad2702623981303b9c25ed17b0592547012e958757f21876d38b4ca28ef5d3e919724f2efbbe52a568835f2f2bac8fe0d114e735804959f8b7a4a49d1046d0019bda235b5b64b4c7d60d5e11d436da2d8bb7ffaad38cfe1db38c2be0e5bd2a76e9ccde40160d471ed93ac652e702ffc30656135ef7c6227814ce33d05b10a5c1739eca727e7eab0866e6461c1bff589b417910c69520a836b6985c1c20364726ee479c9e426a7531b28d5ac355ed159f1eadf91024fb90a2748e3adbc92fcf4d3d73ea8792b0fa0d675ef3d32c89825a8d1c4780f36faabaada07431773308be3b6d3dbd7a925a35b67ba4451757048ac85f8b34ad35b1c794f4e77714c288e0f9a785260b279b4e7ba7fec784f0ef3d48da35eb19d3c170af83d32ba3bacc204384eecc54d649c6eb253ccae9699896e9134818343e349545b81cfb9f893134eb10217e105dc299a79a3ed66dcde38e919f4a436362f0897bfc522214b306269a3162cc4198afeba0a6626e330bd8e5b55c12baede6b87abc23d78e4147a20f5f110a5d460217e89899d3c586719483fc2da8ab9f193da5c250475749662830f6b8dd437767e53c6d3855f500329305505dac18218be4e40d2a0866d8eb104ddbaf414ab00ec1689f72e8a7e71d4444dc1dc5b4f449918ee8a9fe040634debb89bc3a7cd4de8bcb4496e6eb6ff11a18b68b8d2eaddf1965fcb7fd89a9214be5faaf09b2ff01d7df1c9c9a45c40ee8028bd7c59f17dad6f5303889397262a0bc3625a074f1e4fab67777e1806376752489be0051fbcac4b024fd24c876ec0d7f23bdef2cc1296fc02c7bebddcf66388832d751fa4de4327d17c10199a5184d3a5b65cdedebecaae5d768835239b677119411c700b2ac1dca423b10a61c201388d9a8818dadf9c05db3c1ad3ff43ccbdc065dd87c5bc519407718088cb2b1881b07f9cbc4878e677297b0972af8555e5430c9155eed8c0d2a76ec171a174935df12fe8dde96e9ef1d9047242e9e4d8098ec58b1802b7a70eb69f439d193660b2479653f0709fd53b547e46e3e10537b4f6030cb9ec046fc237fed2ed9ef55ff7caea92ccde29e13f769de8c63e17c8d21dcfe75082ec4bab3499af995b63595233b5d081f210ccb3cdb2a407228260ed704ea58e2ca887b8435d91b2a253697d08391f20f1373eb3b9ec632332fc26c41779ab5bc13bf8fa4c08d8c20ed0f5428433c254650b19d0d166ea307a92e8676076772d1a2373afd91a2e95c01f034339830e72dad7638f24abcfbbb43009966c10bf19e1e3c795087c0dd45da68050dfe859595e48f210d0ae6312ae513c1d2c139ef8f3aa74cb841258502ea292220a745741e1e5a2f24f42485ea7e8bb473213575e6f2ee85886aa524a31267fa239acf96e2444cff48b153535c0d7b84b237ff00f569c275aee3ee23d8940dd2769207579c597825044f87159e051f8eece01fbf097a99e46a4fea6d53d3fcd7d775e817fb0a22a0d59b864a1e3a22493b1816a880c2f89a2c91978e402f0d694285817296bb439c7e69c83e290b80d04fcc4d48d3e82b5bfe05154de0e5501cc87bd8196adec7fc2fbdfd8684938d496652bde6347f09a4f00e0f1e43a5e6e69d1d00a75577f95ef232887f80b14b02c1c7f197697298f672f41ff650841110c9033f94bdaf4e336583d1716a5bd55751e25a62ad83fe30e9b9aa67ad74e1650e3107041ae6961d8895236aa9da3a1c7d86c1c932bac75e5be787ef35bf3f1137ae64a1a8ba353ea20aecc80acea688925441808fd66183ac57f8c0208bc7f18beef2f59220a4ead166410081537503266eb61d2148b95ca962d8de36b1e47cd01474ccb1d5beeffd53164f8ec4bab5e546aa1641da8c19b1b64b145baaa24f8285ecc33e30841e476300ee47cd76cdfcbbbd09f8e17334d0365bb970f69f5c610045ca6e547d239688e2b739e292a337b58469c42a9a1f3bd523423d5773d954d38826bdc46995bfd9013495ee9030cd9c78ca0f4c61cb6d158efce54767cea2c18061b3a9ecf6e0833f361c58fd0919d342374c02852f852c4e90fbfa64b846b5477d460da3382d9dabe938d668b5c14f0a4cce319c8a5862a543fbcaa32291877338766f976dc1536b3fb54fb2d3d07e7fc18a9ca88cb2c87a45729f53f09ff5c90d2da850a82196b43802a391ece84fa21227fc58dd5bf8f45031a93c351fc3108d6674f6e1e96a715c3d12330ed03d09f28d0c063af3e1717cd0accdedc656c12b64afaa33e0fb42639e40bdb84652a74285fe1623dcda82264c20294760af30eefa526ca848477260791d82ef36bebe14635da606882777f79c34965d588a725cfee7cd2ffc14bf7747012c2ddc5e16a42dce638c42450f8234c52f2e6f01d849c4bc67792f1bdf8202480a3bef44694daad2f2fb384e7a1a89f47e3c7cf8def85e59aeefe02f6318a46dc1c79ab5621a0ced20720317b92ecb15f45ef3601f126d909ec603f1160ef253d22821420515694930f4ff533a2add3e200123a9e673c4f258e0618537c9843ae32538ef02280195980d5cc1aa71f8ecc1003b19085fd3e8bd6caf2fbbabfe639a20cee14064a21a9294f1de2819be3b48baf295c707960762b3f79fc08944f527a1aa926d314eb4b0ebf9dd5a2bb0114df060d019c5cb8f5d3cb8eadd616e7c6f0e40ea3fbdaf07a026a7a64faf4e13340e6c5d09414f6f59f2ff8afbb3706db131b92e1528ea616c390bf509efc39460e4a8ed38b247ceb2b0dffaba55f79fc24c17107dde880a16baf8a352f947ad00b6826307d8f93067ffd785db9698e17001b0bf4295b944588735be5855817f5233f51571110998138ac806aa7e3daf00e7959d9b459ce3cdba2d1630c86202256e480e947ebfb13ce9cae12c490f8d7969aa28e772e2c0159a736e02e71658f7dc5b2af4b8ad3a9067b4c9cc10c451b41039edcf78aa07f16adcf09c6ba20109cd988889d9f993df052e1677c9bca1cf1339415b151e827ffb420ddb5954a674012974fa3e1ffbd825dd7e091e95907adf1f4a0f3b5f2d34a2ed4a0e0757c0a71cfa60c8ae8535ff7d7756e8a6f79dffcbd7c0a7e5e043dc37ff68e0a0762397d26331984eebdbfaa83f6138abd7b2b7f6a18634607a8a827a3f2cb490441eecc252ef767606ed3fca22bbac668ed9cdfd86237873263fd111e3825400b26705887eab02e696aa6f6faeae0619420db219dce864ac4f6fe2375b48d3ec14bcdea9438d889ceb12a61692c488ec9fd0bccca0512da9a122c6efdeb2930c00cea64a99688e0a421b5e518a88ef3cdb6574534d49ed029bb8570a07bd6dccedc2d6ebbee26d2155d01495521af28f5789e33edcfbab2c4dd8368ed6fcb9039062e59a888a533765a2f5a0a13b508e14ad851cfd56697ed9c717226ef5829f78fb8b0a739c7955598d7f2c636c1aa248e5e797152512948579273081f2a716c3d8a314447a24dc2919281505d65f5e5d1aec6f5c1f6092db945fce2bf91dbf22cfe80ab7661afa2a7239ef90587a4c70a20fb28af8aa5f63fdad3697145034fcccf666356a26f32430ab06c96655e8a6a831d1be2ac7426d85c4a097150a41c3b832c2b35f8956c0d0491df76ce2ca6e3a2da2ad5f47e59501226d7e9e424c4dd5df44c8a416d4ea30c4d6c7fdfeabcd71831c3304fe2e53d4b10724bea29bc2e3bb198fcf844bc08b26dd6752a2dae71b80a863e9a07bba734c60d10f7d972086c737d5671fa7ccad107ddd77827f599c57bce775a6da4fc638cbf18c3c55a09baba58a9ecb559e12b3eb89a53b987796ab74eb7522b0e641b273ef9a20d4009335d5b735cd9c97b3c226375af9c1730e8f987138030a3fdb9d3d03f852d0796e92829132d6212c6de381b21b962959dc9f80e2ce9e2891e26b775bd714f1a181db4409403bf513d5159b6b356da34187625acb30934191cf2501e9deb6b34d91c9a305f27f5921749cfa47cc4a3ba681f0ae760ccf583808a166deb72bb0869a6a0b9d4dc3fef467d26c41dbfeb2e04e3e963f2fee7f6fbfec13e156041507fd7f105708995d5444b1a8f669d5bb1198d9539b929f3f9414fcd8ec13b7ff510463bcf6c648feaf610441af007abe6a49ee4270071d571afa95165dcb7e890cde1a063b057ceffd78c78c96f7c893e80a8f33e99863c45bb6a2ffcea9d26230fea13e475b2d8a977efecfa819c6ba0aa1b0c66380bb7ca2cff0590ea02f37d162455f63d59c187bb675589d9e9f46f0df340c31b59df04467501fee29a0fb1062c8d501fe9ee049fc518e7017d4120c9bffc91a3a7d3b4e1dceae0c80a7373041fe0929576592e1376c038f1f839d26d26bbde24540b0c10e669b0f997522001e2c968a24272b50bbb5ace9c9816c1454c219c32a415105e27b1187b4cdc17b9d74eccb7b81012c8f1f5e4f1288ab4b04301846d07545ce326a7355c6c9ddf45cb1ef2032877bb49bf4354a937a03f4269db3bd644e3f1c5dc4263a1f5d7b87d55688a2830f1621683572150d2bcad5b698a964244b85b2dd7c8d2a1ba6e208433d6da9b0822ee88ac8af6c413c0863ed146a494f8a48f5ba7888bf06d0e7a22a81d62e9caa9f4974b8d38d2e65c9ee2aa67564a65899292a1b17fac2844fbd19840ef443435aaa9d2c10bdedddd816c2702a6c247e15d715825e69dca230412b6a800812c6c3784eb9f8549cf0bbe385817c891361eb1362c25fed5c1f862916aaad9f5976f457f96b5839a8cfa1570c2602f5d26d901febedf46315035c22d95f7e44ad4fe1485114f3d7958fee0242c4862edc57a504868b3e19d4489df8258b751a2c1c48dff93981010696ffc71a582fc7c3071182144bd61763bdfebfd156734d2bf3956b541ee1f0c553f7a77ef782d15d5c4a29a5c1aea398cd1dc456689e945b01638a3f03af2b49ccb259ca818805a4ae3d2bf71000aa5a6833d049cd8404fefc0d881ef9882c6411461e0f7446e1e36f8f7144e56b80cb847feb1d4398a1c7867fe69dae801f31e7707832fe59f7ad80ef15ec8a1c43efd441534813ed91616c80a876c4b3de1783ae1bcacec44145dc9b2bad99ada91c8c67c67c76b856d3d39a30dc99cb262fbeff2d651a84632d5c7366332405adf572acf4e79da3953704d03601a26efc04ed26b808ac5598ba41e3dcba89d55873427764d1a10b8b5a798e00c17b06de19e0c970803ebc8fe11f67868c66e170c9fc83d05b36371f29ca4b144f6cd830d45074f94d2b37d06b665b37d7be6c96112d9ace6a8a149a9a24dcdfa1f30b376a94daec8af87c5c3da6c79d88550ee7df431353c62f6dc0bee21445bf3cd466b8068120ac233e851fe755dc1b8a6c3b83051d41cf8447e1959ca7c32efba5835805df65849a115e7e508989fd2ac17031e0f69adc57ce66c43015246c99816c6c1dfd717b8ed7036414460f4f2d2dc570ba6fde375ece47ddd8673dc9e9574e381dfa17285538fecb19f9df018e8e06f243ce49066686785f65ff9cf55511893a69a724a49f0b5d4f12ae70e1b00fd9f0f7e022c02397d8c68fcf4d582fcd4f724c5ee83d5f59cad609bac61fb87033f44a9b146d1cd60bf0e17e9b8524bcc90b986cbec5a1027ac363afb44537ef45f3e40dc94427faf8f17bc1c00a891f173f7063691950e60206f34295b336adfc3c046ffe920d5fd1932522ca9bc8ba300ddea80d2238af4520c63683bde546989883cac2790dd9f5bbd21df0924fb1539ac99de19339201e081758028016bb9cd66c6504cbe1c4e8afbcafdcae9da7acbe48f4061620d75d868ac6dc404f8f79f9be557da038aaebe70b7a5a3002e7d11800b3615cb7a1e60f083e91b00bd07d6d239d17bffc341bec60c9bee104d4d82281fa84b61c444013d99ee87842fa2f31e163c130955e0175fdb22fca844b99a673e7904fd5aa52621258e761508d2208540124cfc0bbf4743dd621aa21790ec1662b63a011b4362b7715d18e162b051470b3176057465d67bc425aec4607dd0917181f62a8790246a6b72d98981b2e70538da48440bd0711ba8a5e0462bef3927bf8bb99dbcc1c5b7e7b84275948d1dd7e869edbbc62546d4509009abab7ceeeb30d1fd111b96320b8994ddb43575e769affb1a7adfd62f5686434989dd833ce42cf27764125ab090fb416c906fe7c89c76bf2c4a727c1d9da4e85f315bac84a7f1c85618309fa90e68e1164260fe070a6273930c6a15e056aac495d1ed3d758d357dbd0e12ffe29c9e056b25065325be91abf92d7cbc5123e58356f5c768f732393aa6b333d82e3ddd0728e8e5b47668fe4150e8c09aef1849663739a4ab795df3f7ded416c752dec7f1494f1a942aac639687df4b7c5fa21d0d00e47ae5d5f89866ee856bc8d4ecba363173337884b209672152a96c8491cae62d45bbae239702635050e42e0db8e8a968dac32a71bcb1a103a646fc77f4bac27e15aa9930073c297aed16806154aa4ab041f0c740226b82a65e69526a792bc13000f86defbfb8ca3cbe8eaba2cbf15d2e9b88b6afda17b4136f027933a527fe9d6b9e591c4e41bbe03eb33cf89cf63a30f40933a984c0cb47973b3d4ce284e5184d35bbb92e1bcf2dba8fdcfbb24a36c0964d815ee20a612992ca33e181e117efdc67ddcce814d99538b8c73cb80782376f8f3f9b189a015122ad5a452c470112f1ba0dfa2920a5e31bf5946fbbc7cacaeeaa4ce0782e3eab9ebc701b3b5d01b997378793f360aba8abc3b127a04c67ed25145984b4b130007ffddc5aac46cd97d2717039dd4938c3f07d37b1294b4f67df8080c8368c50919597c499dcaee5fa484dbb4e202d38596a75aad9f8a1022a934bb1d21fe9d6dbd9ef613cd67305fe65ef681ed902096c69ca0eafae68626be14d17d1bac0e784b8336c7a7d2b7ee179a1691c564f85ef7c1f2e9a6d69291e2943d3169454f0bede6a0ba23080b6925ca2fcd7a6de7381a291b67d49c3a56350f1a501b860a63cccbab76c3ab7038e9225eb9208e695609e5d0a5b3c4a57406aa3948f307f91b6704d01c62a952c6d8022b59d5b3ec2be7b70183a8fe8ef4e5146f8c3a087705576beb7297d8e3aa2129bdf55c1e860a23203a32068e932b11b5b3e7b3b760b7c48bfad5c9870b5b9ee55e6932082c48d0abcb83e2de76808ae3724e95290627b2d40adb4658c01f3ec4be7495586cf572e9dde8e3f81a216f795c174df4c6da979a001598f8afa201f6183219d6e5315120c7de44d88e329ca3ad007d786861cfc8a3d9dee5f36e884b52d8aba541d402180c018bf176fcd72848e0dbc6f5b99e78c3f8f9a13fedac8d2cdf813385895c51dd1eaca27ff1a502f91cb373554a610fc3b6e7426cd06e6e863ae3a085e5b08172707d2ef51d003de742f6d42ef106d00b9ecb0d9e629e3803023279fe023c009d4bcccd228cbc0225e30583203b1683d9793af80ef0fdd43b4d952f3131a116fc4d567e2800531f05cfa25e3587f4f342b40ba9a3862e8b9af0c8eac840447600eda13677b7158e1a97ba49895c0e527a6542d3ee6b92e43c5408fa8a5765ca4ec45886e5e617096cabdfc4afedfabbafe15f5feab6a107b6ed9a6002fd95a9f6226ed28575bb96a49da0d7a09ed0359cb02db15daf14376ece36be0cbdf86d42b781fa0a92a433f2d2813a781e51e791e3ff05779e6178f900d0df84c3395eb1a50e2a4445c39717f40f5d8cc7a97e2b903fa73c04cfd4e0d80b3207311ed1ae21fb9311a1be3ad69b59c31ca25aee67e238d7e90361fa4476a7546c8ed1cbcced0cd0ca32ac228912eddbe307df11783e2acf7ae12f34b5347a9bd97e182c7ebc07a1acc9bdf041d785e7c35472e771cd8fe96aae327a5d9bc1ca38874f19780884ef0141e4e170aed56437363ba25424e269c3f2a56efd30a1148824608255a2e1c60c689f39ac8405111a619686db7acf4fc671ccccb437996aa62235e589168dd9f9964a62eaf1b8eb2578ff88b73914d3e37a004266cc81190546034cc62d55ff8e75acfe23427b945939caea31da2b97c45121e21d113988cc870a8cde056bc5f9ff5d7f3a1054ca874d691167a9f5ada63afee489ed3121b7a4801e4355df453ee3504457088ff14f1cc1d1baf705764024bc94ff814be64883a52e61988e35795e53e666095ed41d7af9c6c74f8b72c0ea6100edc23d2ae61e45a4bee35080141bbc330fc7e6c764adba61adffe1f59d63df974a38b3849d38833d541daa97d43bb066910a692fc7a0f38c472f170e6169037a3ab32c096d8b006405b8132aad39b77a1ee48f29eee087b2d2f60a2a8fe4354e64a1c1da3427e111249bf252593af60384e135775017ff9aeeb7a5ec4d1b9d16fa59e1a1aa77cdbb5ea93eff778789d59926bc137b1a97c828b3465cf6249b3ba793e8adc1c3e4abe382ac8fd5415cdfa68f8fc4ea756ee2524ff947935955f70ffc55e81841db1ad972e83943186840e91f519ae99a6c03971c348e94f74842d97fc8469a314ba01de0b8101b8b23fc2f41640778f8927ca7fa9419980159e31ef2263d949b0910919c76c608da1a7785c8996b88e6562ee1d22b81085ee397e9456a417ea42a3797dda30e1d8f4ab43615996edb25f5370638ac0fb1e569d22852489724413f1c9386a962c84e4d1d9d8c02f8fa2bb2d25dbf90c519d794881513c346f50cfaa8f151aad463ae0ebc53b509f608df1c03a333c656f2e8c9e5428a9710fafc8c31a58ad7658ba8d8d7b2db2d33fb96e3da328421757cae898fa7e5293f48ce0601e2c24ae3b0f9e28d50f9fd321393baeddf08b8c4460f01a7022f660c719066f5d0e73cfccc2c557f3cc9bcfb82063be8ebc690896cfc35ec0fb0385fd94fe7fd158dea96124d0ad2784237c130056dfa19181f620c6060c40ac51329bfa6b51ffd84e2fa433f169a18362eb66fe56539af06fd2bf84e544713d4a15f2574758ffeb50b23db5c76ff105bb6bd4001737cab3221dbe554be4eeaa023af94f0d0d0581c222c5a31a081988c22e04e1cd700d95903e3e65f146f687f71dacf1c7fb43371a981261157b952128bf0baee8f498ee79c94dd6569f3c18259ecd8659f34cf94f3e572a744c3488a618e269ae1b0d3700b7a9afb00ac67ee4a9755f6a217bd3d906325361484e3a4e80fa94c5f2cb088cbbfa743a0c3fc61191f3281ab28c5ff0ea87fdd2649d92b127c7d957ee56b3dfa45d2c8056e1a2ea6cbc69c9b124396200722f76bda45b21d1d5748e7361a26080ca9c339f4fb36f81b6589557b22be2e93fabf21438cc4fc69ed7a477fb66349f865a5a35c01f0c44f2ce19ff652c931641ea06a3be4611b30ceb625e4dc90813e84feb7c47edf74bb77abf94b0814f04436edeea6e71a3c1b0745bb9047ea9979e502629c5db148c35f3259a85ad8aed0b53d9f7e6c0db9c36d4ed44572031d6dd92c74848fb14a5198af55da81e482acbe958488c0e793f1626d14c1a421a775055f22198b1fec821f17e8c93ff90dd4ba5b651744900582105b3e560358d0bb829ec24b7f8a48f745195b1247fdecca8606ef60834f1241e977d561befadf36b3a6a5fae4102110397cb094ba90cfd5567733c3770b30de584860b996506434fc661d857b00947fb4bafc386d510d99a02c6f2a0e38992ae490a877e336d6f4fcebf95c9e57a71e10b7d7a9510676c46950dee90dafa8a0a35da8994c1a3df1d3d98e8737481230152c4cf04f65b3ea6a46a2236ffd2eedaaeb5de1795179cb0f4889ee66679c5966a94a3432b9191aebecb1ba528ba694fa06056e572ba23fcc7b621a54c14ea578623be824176ac15818be399f54eaa49552dde882daaec29963cd8e5258f83bc3c1274c310688419843a82ed9d2fd829749201b570d78766be480097654691a87d4a2fd81e4c0227bad8bcd2b709fb228905af8e9ef5ffae81aa033ce9e5b60128eeae52a9501a1bd2ddc1e38c3e638da1c2b4570ee20872989e4eb3d68d3fe5dd423b2f6ce79ef1de96c1eab35ba85ab29d7b6cb80d6450d789ef81ad74de7ca22b176d57777f5eea569a669b27a0e147e670af0b6d901db468536e3ffc65048e3d0936b1ac8e316e62bd08e4097da764dd0fec13203a0b325b71a4a2f397e0bbb26f08df943cc4a445ac85c7c7480c6381d87a5e8fb5405fae88ef80ccb0878903c87af4d5af5a24d3b558e94d764c8f0160e7b12d1462dbef530d9f7e4690338652739afafc8022d9ac88400b311ccc106cffd9ca47b28ac5f462ec18bcae6223c186bc44340b2685964ce7861e720329e5ed8409f67380cfc0a79a9240fd474c68442087311ab125024c0cecf55daca952e79617cdc2e960a81449c8cfb94f50b146255895aef2e185e87f03673f389b46f44c81d7f99c22470cc1c5ba1313f69dae6c244fa5c1e3ffe511a79caa4cd0b36351fc7c14882b310c099b9613fe3fa776e1c22455c70337d822df76842f4aeec68905c17f2f4d838c1df5a94623c53ac30af7e7c4b1c291a4d006ea9a4ea469823e6d216b19e0fb0ceeea6c4d69248da3390a8055504f82ea634abd3a2eb260a148b89bfa234b3b251c419e0880da7d9dd1c0cdd8d5303da542ca37df82a73c8a6bd47c40aea8cbb6839f401a4a17eaeaca77d724abf3bf9942980f54804adf21449c2eefa00f693df2869f7bf5ba8da1a8a5514a53795fded3be6465a80622c9a7797d7e60411c58aa358d73176b89bc071a8cf7922b17b03dffc5d39de48d9fcd363ee71647d319d49b0e4065aeb7ecadf717dd3d7d6c6f4466ab000e30c85fe73f858b23468af0e98aac2cd210a46a3343b1905f9767d1aa15a11ef437f6a1d6dcf07168dfff48617bbbec6a806deb2c8363cd82b41ac749b77f41decacab18786ca082057839ddcd4bc92342f9fe1bf4f9dfbe869cb9c6891528c971ca6a0612bc2a2e0545dd9e4ff923c22d203d8e91c0a95ec40055d1acbbe4bab87810abff8a9c68cbab0bd8383f49e89e40fe404c78edf7f834bf68e39c1c93a42f74362c43e837240e5e198f996c478eb5c5ae21967501dd064f0f93eef653a35e9189252480fd75195139d3dd7f5b44f60b698cc47c449bb8626912170ac7a714ea659124f9c968c09d7dfd337c806dca2882dfe687cec168c99eb87eab552d8b67e5c65cc0159ae4a377cf0579811c566195a0d23a210f0125aab84c088f7e31b3e157f87f1bca749e3f12498a8c6e5fcb6f3ec513faed35ac45bdb2ae2960f79385c734f827b426ceeac69b166700e61c9d7084dd90bebe2af93d9e39fa784b6a24b03085f49797e80646f97d4ee5b519819fb9ea5797652e22487f73feaa0fef58ee86ca44e689004190cf4cf003209ebf7a47f2165fddf802509186828d66ee3a3abe40fa1e346f9da1db7b6cb4f7adc40e0e8ac4c6d19869d202401b6377114bb7ac59294a0a659d4f4e77a027331c73ebbf8ad045b64df48a715e36e4842a3ce998c12115a20203c5c45179db84ab3296a18f4b36494162a62311868e5230cf3ebf100a01843c067eda235bf3de3e04f3b85485e07f7e9bb55a9785a70ec233637cb7b1e58bf287567a70f810666fcc0705b422469e8f3c5253f17072b0e60d9d8ad5105628c6fb5b2041807e1631e9f841edd49095992c290eb6188aa115bb1ae09c936be34c9857a8998987e0e38c842d132db65c4d2f3c7fd67b00711e44e4a1087eb3a2d929e718313447dba52214c4847bc7b24da2039c45bef44c59605e4e556d92428f0e5f78a690a860e738cbde723741758e02caa378e8640e5239052906c22c21b01045d110f046c9b7f42446463552448b6e2bba16d4533ed76e62b938d6529d1f1adeca47a36299f282710351b70a8ae80cd6769624c3d09b1ef531c60ba6a9eace7108a40db0c38a7eed5d9a651db0d7c0919b066ea83a9eb1d183302c2fe55ea1847b5f4f66ab7d6bed7777e2c3632ba3cee2c2d4e611a99eec6f9ad149fd8f9047720c16be0d652f3f61c1dbc964020cf9f45c782db312345ff9f0724fbb9e1a033b0d93afa4ff6ad8f028b44954c48ccc7eac4a4b4c1fa0edf02c963556652471354a20463052e5bb8d9dfe36aa999301dc43067091fd64498dfd5f0ec930b7562f70cf7c5984b30205e1faaee5b40370e45ca40702ffe563ba154933529b4d0e5ec669c790bc3c1f1eb33d9b9b4d4c65652ac896895dcc1fd66e03323f63c9231060a76b2ddbc823e1e9dd052877b1b207e2d095689ab28585d6f3b18f50190301bab7a3a15cf56ee6240e984b69279351bbab37bfbb7d98be3936ee36d31db0e74fac147805be19a1c052f0ad2029b09920849993e46ec5940485cc5bb7c32a5e8676cf7bd7a784a3c705f5bde1dbd378d1d0e84184e7cd8717c865850e4edd4b4f0c2e3898bbb5c53f81eed01ddf4898d3435e1ee47c2f26f103d2a2c3821620b2209360f7487b74b70e1c18cb041ca1f96ce3d2f99dc06af0bb70acf9c645690b64db9304b43653f9d848dc812124e1633157326350daa10799f87d5c201dd3ed5e6bd02b442da0d642db92309d97a9f4016c022e2206ba5fc9e45405761b3157a417500af6bc9f77ac55fcc075a4e15449177fa6256f6721fb282af37fde8c1ba0d022d609e33ac837f2d5ccf85d72c537d619d4faee8f4ff27e5e1bd2344e25eb5a3ae347ad8f97cc4bcc673cf5b1cebd123f7285e0338a6ae8ad2768ebf5d175d031cdd6546b5d279015bb19289f86b82814c3e79702410f1ad45508e169838eaa0847e05890dbc1ebaef7fbd652fe305f39ded9fc04f49669b6249a198f1e5118187fa7391165c104557b2f84d4c854b2fb29cad90220fdb0ada6857c748a802aaa9e43bf93578772e11923baa2a91aac6da5307b2488b6500a7096db08ec662c8abc1e85b4a1713efc402a96437cfc7b8cbeae1461add598c67e8e466b6b63d01efd1e7914594885b054f7542e13cbad865eedf9c3c9780cafa769d22689709e587d822b7f6784b752720f9001c3be396ebd570f1ad2fd6a3c8d8ca65e403b78ee94cf40bc7dc25bc9b35337074cecf503ba6dd53fbaffa647ac24237f3dcc085e28b9d404f8ba1bf2b8c0b83ba6d3ddd91bdfb6460582a5342b4379095079ec70042772f51472a327a84a53b97e9a21d7a766b918f0532367e2357b673a64986655b7c2feace5c80ea27dee4a3cd3df0930b471b9c5f21e309101d2061b4766f23ee68019a833d014785231d879308f7a3b70f318af24bbaab641d3abcee78edb7cc2a3625dcfa6ce2f38774032b016d2ca735a3eef4d5cf2fef8630c832a930a5e7edcea5efd3c81897c0e7fa7ef8d202d105ea12865ebe003f72e77ff218b149df0d30656f9d6d70a0b40378bc23f83a534b0db1543fff7b4eaff902618cf40807100e2d04d428b1bf4ba639a0cc4dd2ff74db44fc54809e6b1cabf5fab18adf79e2762af5b5efe755859fa578b8b3ecfbebee8e77d42a4b67e6f790fa5b6625390171167c450c373471b1a453c6ba777b10f7264907475b48e803d55310358be48f115dbcad1ec8277b9b44c4a80c4aa6df6ae79a81956af49f49dc93193af57275af3a184206b8807cd9bc67ed42e974dd5e8b514f81ab53f4cd7439f4df09b56c704d54c3a15797e458ff1855f2866c63de2dcb4a04c03354fea26bb9783362c4959cba1df21125f88d94a8d0e0e97d9f585c799929a808ea3989f213f4552d70b3872ce58b29ee1861aab036dd3c70181a955cf6f18920bdcbfbd6f21e569093a70b878c0e4515ac353c91168b1329f135a3dcfbaa72b7924db39324daadc4fbea275aee14af06b78130e86e1d7e899bed0ee766c913e25780837cedd752b7c3f81fca41539eee601e2986fb1fe11abfee3bdaa45b278e72728307dd3819fb137e6ffb7e545e2d989367c2f5ffe52c70dd6ad299f98aeaf65b53932d94ac534e7952c81fcf431c61678d44c68ae0ac65df515e23bb3510f23935844dfdf48e0155020b584b6c2fe66a499ce390557759b2d93610952f4e4336df88e8225f3830d33349cbcef836d284a566dc7bafa885e5bfdcb9876f49db6993477e1bd7bc614a9c4fa8e61f847594085c685327d5c01d10e1a413559ec72530568980924f4a82ca0f5fadbbda86fe297401a7fef84f6ec9968c4ae29ccbe0d095ca397fd2633b19bdd45c828877a2de56488034d1c723c7220c1d3c4cf7afd32e4bab4cd8455dc964e304df3276df92ff26836ed2d5faec66c26b595ae82cb410406f46b083ffeb5e5cf26612d3a0615d9629b82f23c16173c4aa3bc258480152470fa3830bfc2c08f079c8e66063b973797416ab4cb7609899a3b5ee70e1a60e898459c6887e4d1200fe116b2eed755a5cab5037eed5ab8e81b78babb71eaf59ca3872b43330a146ba12c2a74c1ed795e3c0ba93f920e0dd313dbe78010ba8ae0f2c793a991b325d854b95cd051c937629dabb877f585f0ddbf8bc9e113e222b1eba024c0f47f5c96b60db69215d8f8db136d4a1c32712fa7e8fdd1db1100ad9458d14f69402d4510ce36c9ad32e36c6f4ff7e80f69b6cb82b0270a72b028ef84536692cce315691d6b10075b1f3c1fe1f1b833fcaae5fa5d334a7715b5c40928e21ec316e57df192bc80aac66a17be63ce203688ce7cbaef952cb3585c7a5f987031ec114871edc272f52c424128121074c966038c68abc5f5090447b651231be3ce7330e7c02f532600366bced32e645401480247dedd3b2ae0fb50c5f23443bdc507067916c962255f1225d4922553095b35ee0557084a42300f4a227c265fe537baf48b532e5114d7587d38cb4d8760b044e81d676ce90d0c2225d91bd39b5c3d2fa03950dffe0725ef7766688f7476adfd2ee10bda02bef3a8fce3100c5e98297e15109442ec0dce0374a6812edf7e112ff18a1ee45667c2afc24632a18c076f524ca42aaeaa5c11dfaee6367b2b4826c7aca99ed9ecd518369b5042958289530e18c5271b8183be0d3ecb9a47593e6b5308043aa9693dca3397b7d44767fcd2055aa927e656c02c4e032957dc3b5f0c0c6701ec24635b2652d200c8e83d36736b6504e123378d4b4919ef61fe4cedc6efcfd65beb53d65eee253938b5cd6c0d777138584344f8c207cf4f048987ace215a07445f3795b66da6774fe54cbfb4355f7f3564f52a5bb641c7bb88cf105334cd17b9c7351a5a281e12d31ddaac7b8ec5221db2ed57f0cda2fabfc1add211d24c2874ab568dceea44e34d23c0a48c9e43933ef3c9cb6942519d11bc447fb0591faece2fdcb237a3e6acc2deb38cc84c3b02f0c1a40a6a32ed53f435c0881ae989582f65d51a1ae57d0239090710d9789411d63563cc1b88b66fb7e395d39773ca69b6dc141433305fd9fc2874cd003d87b26a36f8b15bba9abdf942cb6f5a23e249f5359bf1509e276d3f6b74841287f95c0f9f70ca741710aba5d32dc324169be9813d704496a40176d6672da3d7323850664b6dabfc2048ec6f6a1ac6d3e550861bb9402ba62473c804e784cac619db265ccb689ccfff5d1d5cc2dc12485f6666378f25ff024625809fe922331385e73a85d40484d9f51722234e510c19e01e6321140cdfd7c893be33e00b510252d6c0dd21751298806a57973c035828d729ef8c614f12f6db3a6f64e981da6356ea85de964283b06c6531e062cc45b737c587096cfb08e02166b67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
