<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38f4682195611f9476a713f52555fe76eb626e6c8136e831f6434b507c2018e41e355f4ca090e13862675e0e083f5b0b52bc61cdfa16ce8f767c032478bbfeaf0fc8b7d8c30364838008c9ef7998f1a167cfb316da28d1c490f15de7a1c7067727d25fbc7daa7afddec57e20e8e9e3406f7147e41a52f2e9b4378128c235f0f075122957dc346ae085d1bc475e4adc1754214d07ccc44d78cb8c1d045cfb344ad30864717bfb3736a603a150dd347044b6819380fc0fa31630c950d28c99456dcb0aa6e9d5a273de46c1fe35726e2b09642e8d3400d6ec93df152b2ae87a759b9320d86ac4ccf0d8d162547b18ab5e776d6f29ea1659603fa9cb6ba2fc29ee8a9c9ccc6a8c10ae687e2a147c296a36a8335c9b91b384634bdd128be1f04580ccf5fb9674f7ddf377f28113ffa9ef2a6c59294208c54add9888757b4715fb793fa0fb5b0317d74000631e578457d86e8b148a45a4270618648bdb882b02fe29300c611ec3ab6fbe35c718e56eb6fed776dc92fc8f907039dbfd7b54707b0b6a34f668fa66307f128e0c32ab3637f68b223b3a2e88fc3612e45e7f6c3cc8ac437e63a697eafff15e44990271a08ae1ed2125ae921d68eae8dbf957c8548a6a8a6ab6f57c8f8a14bac99a6791dccd26d26518bbc5e4171e75c073b735f37895be551589c46d465b8a790a80e575c1b838ea7057e89e6b68f0b0282c6bb60a2df1a0f558c77a8327af1dd7feae87382844b79ca2759a63faf540ee62da8acb6e6f50baedbbf7cc607a681794e631a00bff812c942e8d5964e91ab95f2290d6e8b3f052f6ba0753992e949364d101ce2ba2ee2b6163e25e343ee3822c63030dd3872687197aa944db2be0ff051ea03c6bb41ab30e217e5b9ca3fa6f2cfae4e4d89b6a43811408dc7fd8466c8f2c1f62210541f3763f27ef380c8b4fd1d991f5a5439cf55a5ffab16f4da0d94e658ea4cf70fe2677e692cec148b15a6977fb14accc848299c74d929d8bc219f0d14f6d61c505408873b25998a46ad9a4124238fe466738d08c4260171b87c1dbd8db30e91a61f784c5ea5b24683ef2a7ccd93eccd998d7f308ab798aabd7a90d0e8c0a4e1ccc7fd9db438cba8e95e87857d077508497ed8eaeed629b23629740249d0d6e66ef15dd67ca6747674b926f34b3fd3224736794bbd79b94249a097d7a7eb37f36166ac7b174a64c1160dc1989d5396fd927d9b6a392313239371482b0d1eeca06a125584281ac42c20a5cd5f561bdf1e8fdfc5a43edca886bebcf4deb01a27e0141cfbbd2982db92ab2443d1f5c02e2e243b405328591a222cb41652178ee315839b1cb1ddd8d2cddc9ff362da6892e1c3c4a57b9fc513f71916632d8f9d22eb992bcdff893309840c0e0ec66aeb18c866c82b9006f89ea64138b2bd3989b05ae9ab506211c9a1c044eb69af62dcb4e954e397b7be6b653b69204586742cbe0303c2080eff115760137579349d498cf43827763afe6a9351002ca926db1153bf83eb0f4a4277c14f8851b0539259b5e28225aed8721efef067075e140b00a25d5c4e40e22aa3ce2b6494ac31a344202d7e595cf292bb37d98d3f19ce7a1b59731c0dcedec40eeb4e06b9d97f399c850253ce351e113773a0024a91fffcd955cf97868e5acd1e6ffcefdde46cd0366d2972e315fbcabfde067b5a42d65cec89780687b2e39123472eaae667fcf070816a502768cd4964501f88dac1d1cfa52fbbb3cfa99e340703b626483b3bcb79ea17644e28cb10e975ab7e0f114a74a557dcb1aa76b18a995d61ba1da753d5f638e831c2b0d72a5f54487b0c6e8cf528cbb66c4592aa5907a5255082592acea5501a374ae55aa5d60d34f4120fcc98040cadcf16dc33e1971ac25860a96fe3f415db6125209943f30229f4c055a86541c4c3a8b0bb30e6ebfaa9fd9375b73ce76e92161f9c77537c351a13fd34617a1cfbc2801f952a907a30723732fb4fac14d74fa39fc708aa7e80ae9529d188f83c9b75dd1332472bf2874709951bfe34fb75f9150018d1fa6f142ef179d82bc7294f2ed4eab6e28890f7dc31f4d0f97c69d376d78205039dcdc670ad4c0dc1c71d94762509eadc45fafb435e13c54b48fad638b0e4e8c05195a3b7d4e8f0e98a50da0b4e1eb64363e16e1d65eca59a33f6a5948b556914d702d80886e50e1e46babfe386091dbadc7779760a896e2264d5134be0eb6ddc4776f7b3cce0f2c150ab1e70a5acd797981a45f38bf79a0cda49116ebef12e5921619ce4b0b5ab861fe1873f5160aa1b3ead8ecc1955ed59282949cae3dbb20ebb150060e175fbd7c0f2adaca93379f22dbe71375a6d91e42fcd56d04b03521b0bb2c12b9754a317bf8fea5fdcc5795635a88fc59805b0af29a730bc5f6ccb8b882a243a11aebc2d6bf839a8bffff0ce0e764226105383e5ff39568aac25a671def3e8737b03d1c7af3937608f1cfb4e2a8430fc075ca76d5b13ca5f5a39c3103ffb0dc68da43da04a30f893999f3ffb160d00269491a1dce7204495320c57a3d2850747965afda2010f083ba8fa53c3f83592a51b0425cd43ac5359757e48c5cf952b17a18416ffd344360ce6c85f7f0071f7ea878de662a64708045d61eb87fa1e30c50547cb17a1664fa35332650fd76aa582a407a970545984c9f135f6a0436e58a78cbb3d4f426197354cd2ffb6e703fce508bee79c0453c0bbfc516974aa51290f6d65df97f2f568f7e9ead3caf05fb16154d460aa82adda7669df9af5207e94f81b263bc31ba944f8016b20c5f1110e8412cab15496307cb671aac02ca6db9a0f067d643509a9ed0752426621a4ea62e2227ca860fb9b007faa0d50d21c0196b35bb20aeffdabb7d3a1fc1e33952ab5a123a421810e6533cc31fb81e063377a5f27897bdad342f99da0ac83ebb4f75a5cf7d3d79600ba94edee0806827f3e54542644f5d1f54d29116b4e805a42e1eea3eaf6ea3caaef3201542ef6a386fd2738433996d1b5b7103e0ac459bc76a6f0c674396e6dcd5ad6873aedd5f359149b27deef1e6073259a86391260a13b98bc7a12e315922ab0156ca199cee1604ead300d1a785de00334ac21035af5c220299df726318cac407d989abe5623cb7a0ccafe4821119f2c88d6353e31931a24ff0bde62204b47e4d917a7a79c05eba31d22da8d4a4e44811fe91ed6b4e69868aacd3575f67f016fdfbadccd7ef359304cff3a8dde88fae205df748011dad2f56a26a4528e939ab54fd7fac534aab56b3019b430c716f7efefaeabeaac3bac8d2b1eaf0e0a05500483d0d60554905a12c1215cecc1005405e9cb3b5bca092ad7064ebd2c839e4e6246a9a4be292b111febd256c3d532a3afd2d1359b61b6d38538f47251eb970e3b65d106c682bc4718b8c15ec7015f25d16991d2dddc21b65123604888923c8e673c9d77397b218b1c0ea05ab934ce5575f0106e81db149a63e57b9e548896fa664d7cb1a523ffc25b18cb10c3c8da9ffc3b84ce536c796bd4e08379142849cc2e38b8e043034a64c8f4b7a23740db2c6b750b580eb8d64a41fe6e7cb9802a9125e1a94181fb345bb061cbe3f1219c935cb33ab72a2e9de30ea5edd395dba7d3280bb602915701f398005182a03bc7327a00fd9a6ab8ed47f395284685640c25fd3e9c43574cb1297b0e2bb99dd5a82af777e8797cb5f9e284dc9777fee877ef24a49dcafe7dbfb8e3974eca87bfaa0168d7fb1ec5f07f85c1b7b602a99482ccb1bf22055bf879f9b6be8ac7de685117dd9e55eb867344f4b17029dc2389fb2b963c0dc265f8bd1ce8af3c5cefe64e97fab62e3af16f8fb9e122947382b2bab94ec445a63dccd82123a000bf5475c9fd8deb3146814a41e6f61d7fae120167d18f4147f717e2c6bb3f4d3aea9de034ae9b9859e00132dcb9ffb06fd5968b6801aab6e7f6cd4f3a0d06ee1530d2150c8a8b0854fea3329a9e011e68b4ec68bf40074a695611166ac9569b6cd0df62f48474d08a6a6f14a44eaf3bad8b75137b9963e33b509cb4d4e1ece89b77d33cf739d8808ae703cecc2aa13c2cdf7973e03b45266a99eb686b41fd709766452e55ce522c9b78eef7de62420a28a8249c9921fa9411fb2852fa9217cfc00ce4ab9406b47d1f5ae4355dd9b1e8d8d0fbaf9850a19bece93d424b9f110037bf545c622e8a4c414dbbe105d6746b01aefcb64fa03dea028c43b8fac1e9dab85a9dec1d6dbda51e1271418fe1d9c3eb8ab38912dfe56f5620615f831be2adf4a27c3b2030da345fdaed1e15b419c8b31d47cf379d846d0a2fda39f8bdcc1757b8ec564989976475866fa6d768ccc8b083f426a2cb967d685b0e07c623b4983f9b5de4b4f3e14f0809f2827590bb9f052dee558674d909bfea861eb431169271b97ff68d31c46c490785d7dd505fdd7b3bddd5d647506499c0ae3898406b2c94ecd23d79a799019e586e4f259524081341b9d6853a95257abd6c74c95a64454663612d73fb9b78651257b3dbd170d1c8e00f08a42c4bd52987d461452ab47ba6cb066cd437d948a0ccd4a5981718f0d3fb2aa6324ab0077d4c551ddb622ce33177d1f88f9899efcb2652db16eab2c63ba547077a3e8a900615b019f192482c4a0dcde1ff62a2445a4243eb2dcb255dd92e70af509704904d3a7eff0be73c50e3ed32499d4d395fba8b6cc1a5729e93183088c6b9d3d2334aebaeec63049647aea8a8fa504e328f8b9ee3ad6635f6ac02c2f8af5e6e635b633e87e194637856511dcc8581e8c90bd70907bc9781fc882021736647cdb7ce86b596d58d39058c4df082b93dc29f140c87bd70b209f51d84fe26ace844136efcccea0503a7cf5f961dd3129b7765f05fbfc0205b22cae0d23194014d1a312551a4a858bb3b3414de5f558a75fce5f7f20e0c7f2b225680efe213b2831b68fd3dec9a0c3801adf85446d7915c00d6a459beeb7e1dca7d86eace6547dac7764ae087eda7bc52c9251cea93cc14a225d323d0267296155be5597fac9075c0651a0d04ebef3193bed70a10d5c4ee81e95a51de51fc20a5a65cbf6f32787de453c4ee8c23af902670e0f7963e0a0fcb9d1fe0060f27bd00b42f7798883bf3c2c75ea10c0926cf3f3e447a83965472e9aa41ff38ecf21ee249eed80e1689bb750cb4c624df415a088d3e5392639e37e02ae44e1ebd17c67a8fe5b7940f00bcd88c538a8c40273c4a450342291376f4c6d3e52312475e6364b4ac256815fc9038146bf4d8918171910a7cc3c62c370367eaf3169bc74a11f063149866aff94fefb9c9a72c12c5407fdd9528390cbc751f7e4761a3d55bcbeeef1762b9b54c7bbb0a50570a96c725b3337e2b119c8a8a74c3542cb0f9fd79779a90cad864f21c6358e5d0b582b4ba62072303081bcde0e52491707b632175ea18b7374134416c576b12d8d4202430d25c0352d8d9f401efcdf4fe4dc0cc54f1e9f215da9a9d393cd71ca113058abf01401e86c386c5f1097fc64dfec2dee4fc5be54b68c78da00814bf69118823fd85c49c3606703e7cd90bf3a9cc2c0203c840de98e4bd77f09d2f291a3b284389ab8e5ca85dafa4a41c9b3e160f9d97da706c58f4aad6e745c65893659b7b223878b3bbe0c9715bbcf02c98f91794c3d7ec57060f4edfe3c76521a1170d57c6d2ebfa2f5fabeecabe3d55d12a4a4f383b96bed0f4fe7801f660968b3368b29a5c6af11f4662155e51d98e826d6ff5d8c86757a647af6499628edaa2c378231e883f2c01e0ab68752a895b8847ed18e891a48f9025858bf9032dac4cada43c0710abadf807603289179402a2139f9660c756af2de273c67147552d6c5d1ae4ca5e61a42d941dbe9c497c0385c95a4f43b53eaf036c8d03dc8b305447f79e05ec6957d0b8fd1300a5146a0d4617629a753481a7d8721b5bc259f48786cd17c1a275dea52ee2a5cfb086aeafb29bc3a1e32d299759dc97ebbe7074dfa0d5fadfb61ead073e0be08b62dedb84e053e6316bc0bf1d3a6afc542449396ba41b1e5cf703d909e56ac895355e5efb4840d66cae5afae54f167fd0ee407924bace9a7d68e83455abde42fa32f10bf74935bf259ccaaef65ac1b54d0b09a3041233441db644b01d69a9cc15531c50b04317a7b5f5bd61aea3cc6f1e0f4b5d15374dd35d25f991439ba656c9fc7e7b2c6136eb4fe5dd4814d89783bd82a8b3b0b7195f11fc363c1de68c3245ee11da058afcbd611dada7a1d79c01ca69b4ed05c081fce1c4bfb5802c1eba96bd72590fe23592a98ae5fa3a81a0db6f6c779728dece27459d35635addc4109caf807b95df10210c376a69deae8c2cf86b7b795710f778008f7afcbf09eef0cfa80efe1dbaca5b3d735f779ae43712401dd227e6f916d5588a63e23b2f347bfc1551090fbc99a643fc69ae8f4b281e673c80fe9b770018f1429a6402693d58b2066c1a772d57e1504cec5f2e23e2d0091aed3c68c706248a1c35d548e3f75c753d40686472e62d68578782432d10d15820363c1015b0f14e306d65e4faaeca606082af0e893249c24e47762446babff4f70680946bd83081ae9355be78d717552f318c27ace6a2d07837ab501af0b5b7ab9dc47843e56f66e1d0f08ac6a2d0034391c4cbd396f4008b343bdbaed9014fc0307b6c4d1cb40a1de94ef06d833604238dbf4a09af5b8d519bd86caa285ff56e2968b4c84bf3985f9d1d3c0bae22e0e1f0e436f45a4b025162fe27edf6f72576c071d6aa37befb8f0eee0d08280da944a3f36fa15b1bec1a178a5ed9f2c91b4092570c56d6929b2499f08d43a9731369ee7539e59cb2636f832e61c12671068aceb74e52a8b5ca6050026644d41a8ed326a90f6cd68bbc62538c7d8ee85aac4b2ea20ea081edca383561a33d998b80fc917804c861643f492944fc14c2f3f25d29d59c37d32a9cf88e3071d3f17fba3ea881374f4937da3b317fcbd86b1a2d79275e83d2ca861f254af3cbd038373e0b3036d81d2f8cb87199b702170f7d559de33b1602c8c199fe02396ae0804c693c5edc69dd261cd215ced3e6cdf73e0b35fceb85dc59dbf83ca571c14804280ffb0f689f82599af323455c3bc377dcd56ad1815abe146be2b03f47ce29a0d87a468e970de279f4ab6ee3b399c546acb697c3e0a0794990bb54b3bcfacadb3b02438d1c2de872955067cb04ea05b16fddc690d313ceefc79d006d1a35d7558138afeb91b2ad2b3c96a20fba58b579054f2dca90405cbe1206b2d351db395d3c8e91faecf2a91922d7992e95a8ef8ec3ba577a3b50a915cfc1220cd7211d8e07fc519ef43a87aff64fbabba54e3888640d0344fca40adcb9683843217c632bc7cadae84a5dd4526379d569d2d7a7ca4c8b96a8c2e01b88f592a5a91af629485f146d5ea264cfb303514c716180fe7a8d650167a8f51117875e078c2e20ce8ba1f7ed8139e974be4fd44186cf397ed710f70459c66ba582a7791fc222dc5101af5d826190ad51baebfbd368aeca59c2088206e8a5b5b6d5dbf784c89fcdb4786339139d326d5d056cc26f1a5c6e63bf1960c1dc8b24e92862a3c91f192d757a9b06966967caa7656b636f89e200c282e9617373c0a3855d8570f38fdc3f5a762f0635df912cdf3eac384d127bbef9a2d0a46225fd7b035c3ec78a0a7829fc4192294720e1a8c5ccf8befaec0c95ed5b04dda91f9fb60fc17fb9b6bc15148dac996bceb9c293ea5662ff52561dad3472713fded814fded4c8a9f888fd20dd4b932cceb03616ff10e4a13cf6ba0bacf37a45ab8fc774176068934b57a2974e3e30262f9ef010dc2ac1847836c5f32f165ca581f79b7f7e0f9bad47f8294f62a767687b7e6eae92fae0b11ba8562bd2ac27a8007342e0cfa7ca59a4e081404b5d4f3d1b9e3a57111fb2ba682b000dff057ac8f25efc8ba4410e8f30c852d222cb5153e90e39f5d869de91d23443c15a6a7be22b2bcf796051eb2f2d6e1964cfc1807f7e04c056019f6e0cd2a9d96a8cb69b780cd4afe5dbcc76d6fd8a320ec6fc2ed339851a4eeb93371ca9d6e69f868375a680d5f6d86b532327cf0f0d2af4d86510cd30acc1ecbc2f20a9f41e5399f90c075882734cddfa8860970234340644ca1d3fe5a7b98a18fd734423633890be2ed503d4ac1ef3a9183d104a4930c6b36cdbc7337189bf8c4b82bf67c8562b2e0b956bc53ab9833c783b87eb4c327fe082d8af6b1fbdcedbb8463dce364e06ab0eccaf98ee3b8993d8bca1be441447d86354c09f82f843c37db6e18a7e181e08f930d0247506ca841e0c67cf5d96db8aaad769ecf6c0015029c88306da7bd58491d8f170e90336711bb273c9549f2fc5527d9b36993936d285b564b0ba3ce34d4eb14c955b4570b822a74e7f4e5244567574e2bcaf6148308712fb0a602204c5534946295b4731ec375e4de8c7b4b52892edcd2a57980f266b43daf461069d2a81ec6048b9afc7517d62db65d331523a62929ec14a6a8c4f31bab0f69f1bf7ecb80c297499e17207c04e349c415eafcbb50c549f49c2295520abc1a76a965887f1678a3193f81247a9166dd0e316daa0fe367dc03cd7fa2deeb5077c9d7abf40b57e1c42ace55f62b92a5313844fefd17c62de061c2a4bded26ceab6c2194e57f27ce35d40ea6e9bb0505ed97cce26c85a99a76eb8e3ed36ecbdf6c17dfb3ef60160201db09db982bf39aac9dd3310db536b3d74d0b9f92bc6d758348588029ea8b54bc10ed42f5f70f7b523b794e73464bb4f076407511e8cb9ce7468165c81bc54e77d51ae1bc2e447eb53f7990e6cf91c438cf8efe99faf575e6af2a24bd3037726b41e07cf94c286fdf5941f3729892cd997fdea0c740cd25dbdb1d25f3a1c50b73d4a9c57fc2a0c7cbd0c14f484b38431e9ffd52010537a0180ea86edfde8ad3acf58783156dda58627d6017c9b408ef8ba988e5f1b3be05923df17edfd5b76d699ffbc1887f36ce8cdb90ad9e59c17dbd7c77c5310704fe88c14d17e3d1b8d7d108bc25e032a939a3ec351139bf5d94c1480aac417ef2b4c5cc5187eaa8372d0fe55243385e796e00c14417cf00d659c900f970c6786f02a573ce8122e98c1e163f60c316aac005bef3c82a92cb0c7971f1039c3a6ac1b698d03d35107784fb39af6da5f0306c4866a3299e42649c1027ac2e2b6b215f8bbc9917b33fbcdfef3a202ff09f2f43c859d6dd01e98003d6de56feba2ff2239774f9a22f85933293bcffd1f17b8e5dd3bae41e68715f681042afca96de0ed4a3558f29269fe0abbba777cbea3b7e95aca0d7668a71824b0c37677d681b95fd9238a5d08265414afefd6ab15bc3d93e8799c5bbd410f2cdab1eed80489732dcc4e4b4b4e5c02247dc5cb72c99b4e6859f3243387d35ceeb75de2e068b4b1faacfb8c2cd7e920393717e305ea9091f352e9371473cff1c4d237aa2a6a27caf610ed9f9901f11a6d6f653e68d13efa2ef2266cbd0593fee915988cc3f3216506499d42535a478b6358849c236cb3e1cfbb87fd44e7564a39ca4697baae4607f526ee9a1e7eea2526420658bdfa10a03e2465436450444becc414a9078dba0f3cbdfa1c4453ccd313d3ada867aac62a796cc2bd683a0ba5d815d2f734b9109252f281b1f100023dc0fcd31553a1d97678b78d832389065b54cac04b017039d70a55a08a5ab11a689ad777d0acb2e3922ffd1f01f7722bbdb16a53ec2d9e83c2a9a2b30b811d9bf86789a3bf0fa6b04434dd0635267a844dc16c8bcc270d7887f0f72f82ed389cc3fcf2ba8e66e8c219987756bda6494de19a91f17fdf0a6154314b444572d5c7cfca7403ffb6e52dd2fd39f081d29a9b19d72a544294a2c80a7b552f34e2db24dbd56f885883455da26820c4ac9fd7fc95080fdfaff0c11b365a8cd842441633670d01986c75f6e253c067122427b2216a86a639b1ec92baa910ca4542833bdca19ce102d20db3c839981bd21c609ee4b84faf0a0953556b4abba3dca59a9b647bb34a88c3ee10917865b943b65fef480e0a013d90c179e41a0dc7ce151f8c2aef52e6dd4cc4674131ef2a93c38576ee78655e30546a2200ae8f2d48ec521b3f0bae52172c9616844b2267c63c675f049612b77e5d2fcbe63c01b0eae15507c543c1d36e0708939cd6583246bcb9897abfe894a285e3dbe47c2a4e22e9c79593f26044815f3cea0e39ba2e1484d09557dbf87b8a4967eb3a15765b4897fb7be382e3d10356dfadcd5f76e350c3575d5bf88d60285265bb6ddcd993daa8ce0ce018fcfb6d33f5f01b4417573dae29db0a828dc3ab70ea589c02f35c67b7a98493ec666c9dfa93aec7d8035db6d40e75e9de9b368c7dd8f4f6c727e2f86a3e658bb6a5d9bbd609bf5915c914dd8c599594edbba08e216a8b8123fb1ead1624ca122df8918aee3c11f99984419f50ba20e487d060c7137bbd506acef71dd695654ca3de199cca94efd808625283ec6d86dd4277025557693e51f89ab1865f4c48d6a51d5dd0070e60c99d86d78f93ee527360a682408b387ef5f676c52638cbc55f4b836e3dce028cfb65a1327d0db6eec261083d2b504cd4c3f3606968723c3ec05e6d81d9d874d1f42946e884cfc085c724a6dc1f60e9bb86c23fa6bf328a72db03eb12f3244516951ac55a8e7b6b0007d70e2b1b149d4f168f29974f8c759a8af927037dddc823e93f15fbec030a9ffe0495800afe7560801d65c03a255571c95f6a20372a47c93e13efe2e974c3aa2836f20cbb7a45c8b2980a9edc58e89777cc79f19f4c812d59099bc8c42bd826ef7503801ea54e24358bba2fcaa2cc1950697766b3930a24aa5e7ad2a5002ef7fb8ce69d512a90542efa2ad59a6cc02e7e230a9c6ffc660271757f930fde9583152e3c29e65bd7b24249eff88dbe03c209e5e1b9a5ec4aed94131e9d24a290593896b3c4618333580623fdbaa736d5ff84f3fdf1d5b352ff819bb2fb6a2aa2fb4c7f421ec3a1f180c27248e0f55a13940d2bb107ce54e726fb3f5587acaeaddca94971ee9e4cb6b74667c5882c357882a78b7bebe097143236442caa26d30b02ed7baf787c2faf54dcf204b1bc70fd66acb4f5f92f3a55e4ea9e345a788929849578caf8d09280e7cf1758de813c366c8974d635d6bc6bd56950490592defbd6cbbcf11fbe1c705aef2bfff364a5b21ceb4ef5f36a323add61433a2e37b6808c43b11f31c4c8851ff7379b91e615569ba845f8b54e7b795df12552d832fe4950bc8c333746cdba0cb0d5652b7023c73449f7e5588bcfb1c78c320a5bed36898eb7f1bdd88cfe508e12a7af595b08f4a16d1c6bbaa568c03563d8d3fca7700399eea8be3384fc33a5efa34b3691e07a38c72e6e4917ecacaf53a45c88cae9e508fd2971aa432d1c10b68cf38cee900d5138a74af2c0d897fde1ff339cc1b5f82022ab12510a0300a9c2f0833179c00171236baf0aa4314689d4a2b3ff5da7de368611e405e426ebfe191aa85282b7fa957052a4975a9500da2c00126cfa1ce27b3c6c1e14d4c7213dc081f9257639b0c05573baa22040d25f99586b0b0fb019f20bf469e87e176b6d19a32426235388cff1493c0a80531d2a6db4372143714b239dbb1d5c4ab48e071a7a28bf8cadd680fa703941d937f9fca1b1200b055bee254dafab7ee3c0a46c5cc10102573329911228ac3591d33b1ff6518bde316e8f6368c8ebe04c8cc5353e218f4b1fe849e03b380fa0c47a7108fdabd89f0b899df78fc05c8509f4141b330db61be5740265675bc556d4d85ef03546e91b277847e45067387a272c077e83f38700969c8aabc1f96ff8c82dbecc0efdc839079aa379bdf322dc44bb770322eff9b427571bb41e45e65acb2bdd3ca29d176e72179a484a58819c57a3443525f7a54dc4a906af45f495d0ec25ed5a2b09f56447143cea2e95f12908f1260273cf6001b3a7be0a202026583d236d9e34c0ee8b3fe76a5cd760c58baf9897802a604dd2705011da57118d7033c28ffa49163ad1ba4fd7dd6fcf9022d504eec8e31eddc10d428d3ae58e51ac61811c2dd26fab19ee9a31574c45e7922d6d45276879054aef290ef8d3ea0daaa46a2a3598966e92fd8684705115d58fa8e2ed3922c0fe434b22be9264f9a445aca0f904d3eab131f3c6cfa62bd81e3d958ad51ec817f614a4339ac8dc54a5105f48f509cb3861ce8539b74ea5de01536754eb15ae9a1de48846943673507eb276f50602182131000cd0246ff84aa5f755d9b58d6e0fe9e6e01fcc399eab16369183e834bcaab4b6387be1663aecd5d2cd86e6ac49999d1934f318ecdc0f0259fc6d8b88d53ec49a8282f39d3c3f86346abc4737955d8e55c864922427ecc2fd36d5cf23d9b95b1beaf22dcb2f76c75b25a26dfc243551a5189af4e176a07979cea99bf74bd5fbd4366894670cf33bcf21f09190be1c4fc9db2823035594b776f42017f94ba03f10979da1950c6fb1b94dc3b4843f82a73bae8fdbacea9a82a0abb2dfa71f02f9579d14c71f322065bb1ce116a437dcb0311db6f73523adc5abc04c65f5adb6fea85766192714dabf9a0b8738445b9a87322004f3067f3e3a07b5cbf79093622be56cf2f86ebed21937ffb8c83cdbef253f1864606b5bca3b39f4b08ac49da962fde704d2fb6cf12c40e95f009f9fa4d8f272cca7be691f301adfe4efc8af5fffcc02500163ae9d6852849e0583179cfc72442f8719ee43b5c56419c8215480ccc46bf7921bcaec976e96cf9c9cd084123236ebe854a84b7c991dbd3d9867303de535bfb118075ea96cc70c6543fdb53c0641c8a2900c2357fe5cc75af1eb41cb0eaf34bb4e18f4d3f7952fbfc0199603a61bdb2f574fa9db90fcdb22af50217b140f076d6d4611631516f4b867f6df6e058ec3698969c7aead0801b88693c907342222c9742590152ebaadd83fcd5593bfe0949b82ac0ca86129a3cf61679d164025f9ee9d413b16b9ac9d6f897bc7d44c9c340232d4abffb0a65da93025211546121426db60c879b5396a17ef475229e944d60cfa39d6f0095e8008198bd37af326d1aeca74d396d11159bb0d362d856e129b8c451f997e73fd151a39992aec13280e1d7ef6e1cda2fd673426d5291e83ecd663335a89885146cd25b9666cb25764f8598a1aa2ab1e62837e55d576a80cb8687d045742e59a35a2c7f503486e656b9b159bc517d4bceb19e85ed7e6aafd15e213e65389354088ca28c812e9c8e7878c590eff8f185a15b54ae122f9af77b5f063b7b6db2fab397cd338904ef1c2499c560d054f43340c9d0bf774bad00df123b98c0fc4c4274e0ec75d35e11f440d00ab222c7cbb38f2d1e421b0c15ec2867993704f9a2908eec4044119ca7d95030c72bc1e76fd6321e5fa7203dcc8b373a9dd6d645cabef93f0480b79cd0af95a8d034847f1ecf7d1bf952d1c366caf31f294a6ab7aa7ee6868987756b155c537bae5f0c136c7a1e55ce8887cee07a0ef0b2420f5cbbb6097a78c3790795ac4a56f4567979fcd5f3bfcf78bf0ef84ba168a0ba8fef02cdc01dc286f97c58cd9b16ac57a3274c30e4e6ebe549137b4e543adb671d7b70456340ca011af84a9d49e1c12c51130150a13a3f7506ab5615802d05867d137aa70a1e5868161c7a7f77dd52dee5edb273a57db58a868baf42d7a6437cd7831003681afeab8f915a8f1de1beb552f54846a67e2b4ab0a83f45e6801b747a391cd700b0b4ca88b47c8b8372fad254c462eeabdd878e4aa965b70e31052478fff2bbbf59189f5a48efcfc45ef8f581333b65c09eaca64f3e42b83f70a875f0c2d768b520a6f3f5b753c074566ef86bf72549156c3cf5d942ee4108323f77d3423014b9414daa99833a8c36dfa85a16610e03135b6cb60be8b8780cea24838a046c2a94fa3e8f93bab077905e47ea52c36fb58e68140103e8814da35bd250d75bc24a52dc164ebf8c251f17fd53270f25a6cf645378c5847c7e259cd072562ad6dc1ca7aeb5c8b632789e7798f97665bdef4d0bb30fa41666a5eb4ac227cd3990aaf116e59078c2bee809da125917f24f86f94b7bdc5dda61e3ba0368854149545b6c4786ee5e7251838151134d6037d91a0863fd5dc250fb37a376672dcbadc0a3c56bb2c47ae562dfe5fb187e166a313d531059afe42e27c61903384fe0f2531e5e288a145009be4216b26b2d5ed435d570aaab88a1dc3853794a4af64f4422ecc9fe1061778bb5cc4e66ed92d33fe6c360847d30dbe49fb68e83dc45aade1a3bcf8a5c4067c577b8417a7c765557ff805ffef159e72d4f97481d979239285fddb6b5b89da343b1df3d9812aeb013eba4c7031496a098042d93ebcba757d1d1d515eb11e5dc9078e54ff0e702f7dc56586bf4519e80557b9e306ce046324a274d9dc0f3527c946d1c5040cfd6abcdb489251adc561ed7fa0b792a18b83928aa6bcc086deffaf69aa142b886f6bef25bc2570ce81a8315e30a05f84747d9bf6fb864740577db044dc85a26276b35f67511b2a9ed228605e8304481c8067b5517b5f3a0b182f946a5f5157575d0f011cb5d1b69cfe40e3a0ace3fd299507cfe75599457fefa817b6a898e58a93b7867c8b696b5f94a8e67648764eaa45134e7369169c52c049cc6d7f52ff7b2f0477104a329511f98d2d480b3eee2ba4be81d2961f0384b02f35bb39ae8f3be4b61f0e92a4ce9ab2f169dbd5ac819bc0dc9adb2ea53e4b34b043856f20eb55aa75cb7b7dcc6506563eb622d9d92cca738974ae71567cd1ffec580df112eaff0145e16897eb53e7f5520d0b1d4f6dcb91495cbea917747ee47bb6f06b663284c44c2e7959349123793805f1717b89c26d527da59a75485d9caec6779d8160442710cd10bf74496c1487d905bfd9cd99e678b0fca9a4eb11652e238a96d6888bc62ea58568bf1caf8a384c0dab2f8849ea1774d4950c3ef3a4ab29e205902b33e309949981f01cfd84558c9e633d65410a8bbd735555b47c4c2fcc88d10d57cf65ba632e2a0ed3f05db09571df51901d5656dcec6331085a17c8092d51bfb99cd98889bab22db2bf66481eb28c171339e89e289445e2aa4843e96e21ebc879358e5efa0514fddaa2f2c808c44a12117680817be9e1af5d0fd662138f14e1dc1a6a40a8961dcd50480a3908144edc29f53415cf0d6a397f939afd7be4ca763afe899353b578d3c980fcd6ac3c2e98d221c7b69e3e6c749ea576e16003ec8c342d913819783f18c0ca6984d82842e1fcf091a7b79e8bc764c476516387d7a67379129a89d7af6018f0afbd9b83b6ab9d8a73155a92c3b4975dc72ab01ac4f5249620b1477927beaa51c9ab449f93c47c506057ee04b1d7e2229a8e5698334908d65fb20c46aa7e3edf44d7c7e6d16da60c508e9dac9e2619d88fee1e9ff583cc9f19855993085b4ed352d02d096326f9171144e3e1835358fd73faa2f5919a40d55bbd43cda04c909e677889017059a7627b9954417b470504409f071047324b2f209226331c9a0c13acad7c191c40fd2a3e30087314627bfd15411fd03a4f1b5af7b705276683f545f66014593731a68ce8e772cf738dd5914737202890fb04863c27774b8006263a811b7308812fcae314e688a94546493283f836a53d6cde6c6c7cd72515a817b2e56e9cc5d723185ab60d60181bbb3146ab6986e875f160688d29ee427892e04cc09771b4a90448f066ab7cb435988088a81bfcb2874bf74ec2b512c07245f4ddfb02e656aff8efad42cc7a04e130791f12cfac8d368c0747c88f064ffadde79b4fe1fc212dedb40975e84b24ebb7a468071d3a6c03e6d432484288a93bcf23c3cd0655a7c61c78e2e3de7ca0f4a1b573067d74ce71ec1db42c05c776d35e40f3daf94f049c4fdfe10fc40f67596faab8141c45e558cde3ebd57605be99e182add80b645dfaab8f217dd438acf745ddc80725eb51ae119bfe75fccd2dfe7d312b8b4f151cb9045bb6a0a7651cc7e91794901ac10a15493ca79c0f7a830235509dd4c5ae22e41941ce513f9d29ed1cfcb5372efe7e7dc92dd4ded82d17eef4edf2a34f0f268f5d52e8e67b5bd08b4d2949b57920a1a165815e555086275fa968c7dae51ef1e45d54ee09e8d00adee6ba70c031c58544ee88d1401b17f312bb04da6c15b0010669d48a2019777d94a3f14f1d3de5da65157800929254333fd75df77b3fe16702a4602ae244ebe1bf014c3da43f6436a6ef5050bcb171fc669f5073dcb5c854ed088c8b331e68bb0f5c6cd45258e4fa8357da8704e308d23898614019fa15dccd3b146b7d59eaabd05bf7bc533561783a29c4b9f76f815cd438409d1a04f8af7ef34a362b950eb588d748a391d8ea2d42a09e8e486e0b67d7bb3fa94fe96ff3b2ca7ebbfe03778d0b5c41096f83c79008e1418d66cb42a0bc5b8cb25f05597b769252161de064591a83d86e9dac765b22fcfadd3d2e0360bd3c7b2feb6b35ec37f8e0fb8d2237b490bcc2faa182fef37d82165417eace3dbc4ef20c9ffb0e82b630ca033fa6bd27842d499f4bfe81b35f86718f7a59d9fa0193922f5c746b277f1569698a28a2d01da4c66d1a8cc37503ecb6a72be28eac4291458bf671347e3b627ef57d989ac518cba3711918a9ddd4d6e2a65d6e9192df1c3ec651f745fe256cbd2a93003b7154661b209636fcc37f05ad8c6fe8676cd9e5f0a9cb511cb03147d301646ffbe08e3b088bef3e8cdcc4481223c98de7b736a347000fa81bdc3f79f1b5d0730e00f22a044644f2d516bada62f40dde615d1246b5c04d048d3d42d545f565772b03588f9078d5ac5edba7895f4b220ba0e6588472ad175f1aa07037f405a4f6ae746a3be3cadab9184338ae88e5feb0ec2fbc693a738271e94cf9987c48f2722d01562f7ca2bc72b2ebc051e1e03d2a8f567bda693d789141eca8a84c5bab98a2bfc1c6704ce0d9e26415fa96dc2f02b3bf7d639a2e3084907c9ddb74b3f5fdea4c10a27c63714f4971d9f64d952d2fe2cd0cab1368329fe1b3b78c8adfbcaa4f712f603f7f77d8d6e815195f512235fb1f7f110154cf883a3984641c34b4dec4138be6b2178700f685e3e3b307af40c316c7a4a11451820c2c89dc053bd6538780530dde9c5db6badb1f60e6eb17f59ca38fbdf50e0598c2ee9b0d9b8ed06514c6a546587d4f6ac4b4c69c72b2f1d3d298bd1d80ce5c3f8ea0e7e3733d01271addb9d2ed6313bc0ee5d2eab08392f7ab5b7df9fb8001924c1cd0f3b5f53e199a25bc784e0b9a44aa59f57cc74b160dd69464a785b7ab70c14f17140e62b01bbf25c1f66ac61636e1d477973a2cc1c1a007acc4181342fb3d4f4e4009475cf7d3b709dd77e9e97e11e966fc54b5177ee7fa274ab38d35a427719e44bb2e22341018c99fc483d6f54541900e058578f6b942efce116634fc130aadb240f71b315b2d965caf920ff859347ca9b29068a3324e12b83913bec745e9205f11b29bb035a1fd2528e3714996c3f111ff77f15c4437c94caa937ec12cec7ac251d637ebbc96ad2c855156994fbdc0f2462418a8ea46fa3bd759d20a4c9dd1ee4f4f79def1c28268b1bc5c388020b81f0c0126ac69e6426ea17c4aa623beeb01f42db3eab4666dd951bf41d783e5fbf2b9317e4272d92b469dce8526fc0dab72e73365bb73359eb66a1d48bf443a31d94b2b1f7b61f9dce4d13da3e83d76bb9535e3a9537d38ef335c8260b0904ebdcbcfb393e850ec3e85a498eb1c2e7d52d017b47ddaea0aaacf0874a0e7bb646bff377337cdbd9e60239a597c7f4cdaf8fecf8c8824d13e2cc2928ddc0ea84bd2d107d3a0f1739e4785ef48bc4ee40a7e61a69f18360d077cff67b5e23913c170060981da601ac8b648576314fc1b2c1cc010bc85908d19d5194b3c406c4f2f24e2d3e50e6d772dbdb0f330355f675b73abbc94ddc3d20484a723686db80245a194b59e8aee762842f5750bfb35774dc400c0ba3a605450c83b877b2bc263b9ad1ad3f5277b72207c1740464ff1beb1e7a8278a33168119de3af6579ca17bb6424279","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
