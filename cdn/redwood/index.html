<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d12d05b03d2ade024fdeafc7977c12c63e59dd3f5d05e89cb1dda4cf54cbd308b073909ec7f032a630b4008dcb46cae03df434e9acbbea272add053776a253f1d54854541b8226103d2311f70accb2ab56e0f7a9c29a1abba7985ef25dfae66062f1c434952b8d9ecc3b9a0cff30c4c2b3ee22ce4ebf187be3a5c83cf1e65a9498913686a16c9c7eaee7900e891b3036c5616e9fa2e1c267f711b05102f9a359a28ea1098d126b935b676ff2c5bb9a8c707deee10c171f450966d67ec05aa1ecd27f75ea13139a2f7730f5fd948a920a20ac4d735152faf137a77716a04009078c467cb0020a1330f9cf1cf33e10c6f8f1542a228d405c842589e8ac4af6a465decea7e31e93baf5b797c1d76c094e71fbb85564c70e7c46f8179e331bbc921237bc4a832a09cf7ce31b506ebb837f5f7666c67fd75c06b0525ce129c00427cacd7ec90fa8b3b74aa4178c397cc0a31947fcd4af032354ffbfc67afca6a91ac924f88a44a879dcf6cd3cae620d3b84c07f70c21d8426857b64f9cad30125b583253d44572f585a1cf06f318792c70c7ad09732ebe6cb32327e263f3e4a11af1bbd76558f5a591154252d885ff65f938967df94a4930c1893bfe702b16443f7a71b6014afffd198c74555c08475e605534ae8995dbeb13b1caf0f3317912f364f5a04f6938ff256d6ba8060b6c0239cc3b70f8973f1bcd649d134f9ce9e2fc87e4741143386ec2393a6e8d0f7d7cb9b537a219b9c2d93cb660daa780297a3cdd40c1ca0ed329509c13b51f49e80208190dc879feb5080abfadc4aec8ed61f504c0de7be230a05bd5777066991ec0c07abffc4fe2cefdcf03045e5d1e3f61eec122705cda6fcd6b1e9de0357c899636d57d29232d20f072819ba7120a9ca45075f30ec4ea75b7919b245bdb3058c5b1e624b07ebb854f4bc517749aed5813778d48485f190fc610e89226b1854a1cfa1aad2fe5e75cd6dc0df3667a2e958a6eb0cd16c6095d7d7d39d70489ddab049801ac1bd0535040a4aa795c5906f78930b5f2a52f1069e2dfa0081115d978b309d58e122c1e4abe3a9cf8a5459f81cd3910f5eceaa7e3228444cd3e4c00b75dd6935bc0be87a44fe55e9e38c865c29bf527c4e8fa4d9d4dd3a09cd8d5810ff07e0e3c9b20f295c076a81bdc2e50538cead961f3097a45c32838bd1132ef03416447f6e07c94ec1606de86db46cddd603801e5bd5e06cff7918e201f8c3aaa34289e98d1a4239192d194580315ef9a17745f64adb0eec62f2b984e59e5ad7741c8f37e84df253d512bd2324d076b48daacd631634513df40a041a1b35cec4aba2a0d03093e88c7b70196d8a27a2cf5c683803dd1ada7fcba903d5aaf44c31572a1c2d78eff026f7450a0bb2972c10231813d7f77609b3a744178197e87e21a7a5ae923cc0a151d824803c850ba28574d37b1c518521c7dfcb64d1d4a4b9a99e0d0eb0af75f3d44691b01d374663aed7b03862d54cc61aa996c9fd5d289d15b851a69fbfed5eb039d6103767b0d8847392470d21aa31a114413f543695844bac43231b955a5c79ac918a1e16e0b95fdbae768bd47197020d8c229d9d2b9497170c76954b49e71410a8ca6dc045331b87d33c8bc12aab83fcd540859be4706b544e614a045203e13ad87a1166b7ce17ebc05b808f8b85e8ff1daa3d1859f14ec866623d6bb85d1a26df2d468d97d37468216d46d10a9a858720b9c96599e19b165b48abfe1cb347f783cda251ab60fe979c879996778df708d7ed15108128399b08775cd4fff1207ab0e4b72f555be61806b92254721977f8cf1547e2c44f3c581f3508506fe56a470325da91a591a2166a4a71a6db29f9473b951ddb847c89e562932650f400d4788aa6eb7e3d6f918905b3ee5466262e036dc74e58f6f0367c58be1455ea51bcee587dc3cb7ccede94a62854909dc350d81fc4e74a09a0933c009fb40c13094155f4027d9feeb4cc6a605db1cae61b71c002720f5096587c639a3928ed50a3126bfe84a1f925e4c76bd42b2809920026138a5b0c15bbaffd26b302b7f27ee4ed6010c7bbe125f6f9731d00d67e4fdc263cda380a9424b35d4aea6cc2dc438b14e041921dcc83d8d75f9d85cdb70e8a4171dc029f8ad44cfaafc55ede45687cf3fd7f64a33209352e5d420ad00df1a60ad097652adcdb26a0c9392dcaca9910f29ba14d98e3287e2aecefd920519afd35f1adc4cdf95e04c2b38b0c1ed75b924c054e65e88d0ff17411dfe8f48acb873b5eee201e88d28e1f9155b0020d2b91b93b1f7a13e65d3a085d3f4395ec5bef83e87fa207f639980feedb61b6deb97b4d640d253b026413c7ef5dec8975a98a763f11d161ad9c91bd31354d7792cfd1da6d29c80f459b09e716e3bd0d3788317082bb1b84cf5273a1889e0e1a1749d3f64df4c9a5443241d05fac4ad631fada9c8b40f7eb070f80efce0641b9a58da2431bb7c862a29b2c7b1faaa9f98cccfc959e2fea07faecc53591c1e7e19ae634a8d718532a2727150ced6edec9502433fd45c24e1aa80a7ca4771fd784f8126c5360df59f31abb3d7e7c71a82a776c027e57c00e63a87fcf05f76ec84fe50eb87c8b45110481de560c273deefbe16d701d0e4bad01e94397b109746cdff456e5376b17d1d4898b3ba14ee8370d1a376acc112a14c14c1f2bec767ddf041ae7622ba8cfa031166b0f3ee087eae6b1990cb616d4cad44060f30ba6c54b5bbf3fc1346e657090e6cdf3b3f5bca16bae0b4e33e433abc05b1fd185280e3f63000b34246f0cf0f7abc98ea37837a01dd6418341d4a60089c2b1ccd2850cdb1b0f410e8af2b20d157e5e4394cc27f695245cb57163da1ad9bd9e9cbf46fa4508da415f42d32ec060e1e003e8ecdd3ffbd2c33bbe83efa6712f48fe144e4edec1561848fe5faf74006b82e7a035bdd789f2d1fd804961eea8b4981332554700de375230c6417d46a707a757ba00d599b7acbbcbcb1857114b115b5906d17f237f6f9dc030e025db021cbde659f37530779e4d2cbc0a24300ba8968132f377747beda9a8621b5ee6ad06377a92c940ee219180f079e2d3da6815a670f81ff0ab73453583290c828b9d1078ffb0afffb4cc2f50a2fbf0e52c44f39724a13733094f516be7add02248295c8691a0c48eacbd7059bdd129d152b377a88c8340ce6473719fae6e2ac4169450491121de06a477c22d52922462df971e6031336d637230cfb6de012b027cd5fdadcbe21652620b29f9715243393ecc85b27b87e5b42936528818367de577a2b73a267b67d5e27040895bb1ff6a883915469b1acb5056dbf069d94aa8d879e9e3e10843ebc1d7c595a8fbea366eb9a64f418aa6eb8a800edb30d2f6c1e769779b9ec2ebf3ac77273d51d25bd3f0137deb669ca81fd5929a10fe275cfa468442e3e7cf8b95bb9b9f7f9efd3a3ab2a02ab905cbac5ed00c3072ac2196884c5c58d17d4c308c669e4b1350ac018ffab137b3f52cab080c20c7f2e42c69224be594f849e5b37b417ce5e1eb5a7d5abe89e6f88fedb8f657c1fde77d92fa203a29038d11d55a5e68d9f833cb8063a03fb25bb95b82808cff0205f961dcc2a9fa56c43b85db1da9a3fe5731ebb4904f05f951d447fcaf5e46d6be2c5eff3dd877e516a4b5f18d7488a3143f469789f5db1067a88cf1adecb782b5d48586e48f88f0040659353e0be6f80fbf7f84d16d78c482cd05259b18bf63d8b1778220e51f13a3decabacf50ce833be4ac0af9d7b669981988f063fd6212eaa32e2609c0064731325f3e1f0bcd514659b3ae5cb8a9f8a2d4223966a5c8df1baacd34c481b247f19398ef413caa9a7ac1b26d6f1afc2e8103dd32f1a70e1fb9cffc7405898d8e26c19152ab12229774b0ab0af18e59266b8a2177ffb50b7e4bd3476b5bc44f4ebfc8ed9071d0acf1a80fc21160e0daf60e73c7a0d65c9ac2d6f299ddf3a77b65f788b33766ddc4ce8ae75c12cd5cbc96fc5c4bee7e9c99960428be77014721145aaaf619b468f1ab612ece4af08753670726567eba1cd4eebe08c5c9baa1274146d988624c3d052d6b54eca800f6f0c6bc8468b1ce6476be9091a2d812cab6e73bdecafde957a9dffe97e200bbf6aa7fda94fad875b908f6ac36a3b217d68aa4c98da3fc220c7e2018f3f2f17338f730f411d4274a13b31ec5b983f62b0ba5a7adf0b078f75fc459d1955a880ee232467126494f5e353ea10bf5dc13bfef837d8fe52bd357443886cb168ccb1a7550a5a6d453c4930b4e5fa8efffcf1c35d06e8505a81ff220e83c684db3d60ec6d7e763c6be0188bc4281a4174b53dbf900d721ed8ed1d7c878dc58bf19e93e6db4fa5a9f05c9ba7d6d9bfa9118b26e74bc29dbc31b1006df821bf6b859685127385d86c1959c80550f662d600bbe875e8974add5e2bda0681d0f186597e4bdac71ac5c5d7a362eb73581ee2e94f355b3e05f0620d372a58c8ea38798eff3796747ccde517493870e857742864e7901b8047ff1f3f4e166d408aa1bcd01909c335d4b70e9090c4a02fdaa903cbe7c571f3316135a6f56601c8de286cd5b4a3f5b039047ec90f13ac65b8e7458e3c4195c1a48d8225e13cddde1af6a4a7b0c849009067f1a10c037336cb8b051964de3cd3b0d0e2975a3807e5009817ff21eae16be500ca3813c384f7974808738ea1cac2d9dae44f34967d5fae8f076d6895a4701fed2cbaea8c30442888e528d0eb0ea52c0fd6e9cea551b354e8cc3e64f0fd7c0b4dbc16b2540ee2bf8ad8aae10ee415d2e9d303fe259b67481d1699eb80d795266e1aee022652ecf317a526832df287bcb3654e8a5a18951d85878f3999976e526010dd7c1c5813d146b6a942a1cbbc65720d8de24a33b640b49d1a1e3366d2cae8c9bbc6c84d5d942f7399f030b45d2d11eab667e8733f77c6985b52f94f6dd1c94d75e51c80a448b3072dfe3b5afc50ee2185a9c6b2638c677cfba2019243f7eaee29183a40a270edfb1d065e5faa619dded1d24831b2dbc7db320627379ef19a5be1f9db54b81cc0a87826b0c92ed0d5ff9fdaef9bfce9f31a192ea7e97c3bb31afe4b7f9a0685023b72cb9dc256980b367b07ad486a98909f4c3aac994e3eb3e9adcfd3cf3ec851fed510e72c3e45e82fe653fab4b54d68e86c5b9f411ac81f194b02659f1633e84952e9ee7f83dc247b46915dc583e7a9dba754453267ad8a3b30bab9c507146cb51dbc914dbfcb60b7838f0aad54917a9545c20a93578eb5e887f63591e199574a220de82dfbfd23f5a39aee99a271f494888cd67c6881916a757c5d731347938d8001ffc9937bd9a8fbd30bee3db5a603f4f735e0c8df09d71f9655c1086a90b1363f26dfc0226fbd5cd7ad69c4c93c49bc23ec44d536bf94caceafbf7f8887838baa86c55d3c0fc14b5a0e382b8cad9c91c0b942a59ca7106c6d3a15be79599986ce22c8c0dc1277f39649e8fee38633a2a67db7ceb9045f5bd0bca1d9d52209583c40e8c660f99203e89dde0fd28d5e127d57b0ebc76aa9e9ab38b9affa0a4e3f0418b62050a2b49ca276ed74c4c784aa28f3bb7d7fa7b9e9ae3f63e49ee5642a6c4ccdeb8b1112b5fb6c890b8d1474f005e1e50d6be42207c4d4c9a153608b8480ce1299772a0f3dd6ce2ec22f39094effeb9610b5d27d936780817281ca6ef19dcd034eddbf3b53db5e98a1285e2e2d01d1db0b97fd525799a227f932ce6c751b9fe23866d00807edb89016a0af25d0e4b391c8217c77c269c2d28aef6d0ff724f0660b8a2b818d8f27e10d89f91d8f38e3b4dfbb1f1cd8a40b21a40515d13e96049d55455b9bafd8951aa6567ed32adf04fd81a7830ed0f3b0e4bdcb16740b197fc0a4be698626c077f4a404238b80cbec358c472a3f9e00d48aad5ec947d6876824bce4c99df5c10227e03e51bcdcf13e67ffb01601ea4ec504a20870f2c7b3b966718456b228f52a4d41f12a5ac0338b7eab0e44f3c95300cb290923f6c0d7bc3219989845b0ce85eabcb97d087d5221c3ff8e2fc65764c9045fee4376d956461ff534046f8756ff4199a4c9803c6555e7a5411e3d7e6960664469befef1a6807e77e0deb8a6481530d49b38a6469de49c49d7e81a7f15546441aa35b3249b3d369ed30c6b02b9769000f149bb6be41e8283064850bf2ccdd2d7d9aebfeda9e42285fbb278f5060b5fb12045e5712940eacfbebe7e028b7c9fcb7fdde543e60a924e7e861198d141562dece559d8aabe3408eaee4b248d2c5effde4e9a00b63ce42b655ace2cb5ea7c5650c30e3da9ea7394b291d97ee24b3eee49213c72e44a1a8b5b483cf3c8958d130251f3afb416938ec528670f306190953f46d37d92d21525e0675d670352f334497d099a974866d90faadfba391c2bd49fe9695ea4eafecd25a4e6ec8793fce4989e7d510dd456bad8eb3d319048daf594d5b1c2a2b86e52922c358f32e96fb2e427f779633827a1771523a2eb11ce051a2af24e036fd8f5a651c6adfe1ac80e39102af4e9548f5b2ab3625b81e424ad5ad49dd7209dbd850ef6e5c2d68f3abcc26c92f8d7eddea7f4bb8974c4015b837be8078938317c495f1b63a3493633cc4bdfda8b0d1310a23e1ffce560fcdb5120c3851b362c82cfa56ef549ea8e16da995d074f95639d618de30657fb5072f1777efb1e5c005c268456935d25e55387bcf952e10f11fe437f70ec427058ec3dae78381797526b1709089252e15d81e99b487ed385b899e4bfa207930974cb1abcbca1d64dfc3561a97e53a2aaa556e9d1cf3ee52a8476873623843b8e08ab37ea7048e138441d3cd26dc57cafa4f034901ab1a23dc4265826c203d66e5a61b369b1a5ca815d3117f9da77a0d27c36cbb154108dd8c2f8d9b5fc5f021c79164c47e38d536aa947e0ea1450a5930c48da12d8c3824b7dc7009de768f181566b3c46c91d900cb7e1e5304401ad3de54ff6364574a5138f492539a061c14056a9678b4947081dfa770810c3c2e9dbaaf2ae9ec3a9fc80ebdbb9087c60243025ea3f0e1a820124a7b3435fcf3c41af47d496612c585a9a333f6160a2bdcfa4e232223482331498cfea8db5ff9d18742d8d768d182671575cc8add222072e6a11e15db6fde50833fdacf7cadcf855b3b4b3f7f6e17a37f1709fb2a8187a82fb86152e408e78af6a6af024af45f666c0269faab0e357c35cabcaf290930b14c54b77a8736998bc4737a407f5146187ce4927c892d8a381005178ff76befb3e90a4b70d2a1939c42037098d188e43cc2c4a2bd29814364724e7587396d321944a0f5a6601055693f80c47ead59e208fec689e4a8aac191e3e75f2e9b9ace3775fbff9dd3d08a12a095813df94fa2b3a45405da1354f6f243fc13b78d6878b75ebace249b9584e25577dcd799c6110b4138cf296b9628dd08276548d06803a33a8b74a752ceee7e1815c4265621aeb87344b95203d8e29314ea4f051f3a098633ee379307721118761df80a31ecea8b1517e0ff7482356f3f0c1dde4167a5dcef6fb1dab9feb8c3a144c7413669eb612d19f8074a575ce9eea267b281325b7fe5a9b59d660d643fa92e75b572566285cc0f0b15e65a43e6297250d8b84efada9187a487efa8c0b0c463592e7754ba0c715c6738d82e83b78401d9dd83a89b133c5e6d2bda966e7356cdf935c7a581783b28349c0b00566a1f64eb1005358ff81b3b7ca1a80bd020200e6348c3704e5a0e043c350bf72dced69675278f42f247cb89fcf952a2f473921adac1d3dac6af5e3df3508a680aee9b5c253dea336a9f6ed4ae3c0116d2ce2c087c34468e0b56454478b1307a82137cf22e1af16a74389a43235a160879b23b4dad43c5efe5cdaf4eef287d8c848183e02dbe3903a9eb71afe5a8105a58cca14d4372c9a46e1b85d0fdd1fd3f82865531481ab88760e103d015942b4b081c6c0d3b35b97e086cd470f7e0b65ce152a4172683d37df58b49abf03c592390336e8b3cf02f05c2a888cde9b4593bcaaa602924272d7b415f3d02515d089503eff8bbac99f721f853daecf7e0f2a966b8775563e439aab977fd930c188cba966f1f4d530ba5ff86a9ca20c0457164eb97ba0729aea433acb7c5d5bd8e0289039f7780deeb99079784c238e34fed27dc889383778b15e4918dd49539bb7dc75f0160ad39f19c89a1be5bcbe1e0c4861c84dde2b4a6b970c7b3aedf7ac79cb12eb2e694f6a334f314f79ed85c5c4541d2f69d6a91aa5ebebb125b4eb58239e03f263dd667cf3e1e839b277e54ae48e819e098ffe326212133b24f2c7f397126cbe4078d6a1f223024ac27190a5799744db6de3d15dcb695ba57e6b31f575a897288bd15fc65570642de4425cc9928559eea542efac42e40d215a2a317d274f84ded0b9ce02c3cc05d3542464ce750249351cb2487642f8fa69b9409b77624ce05c06ba64a75f4b8b661d1c21555ed8541c26026d6bb686a8dce25e41e9710c4c8a5beace9a483a82df9ea25596e4df4f8597ab5e609e8ad2c0515bd95a2677421f5a09ff92a79e078e50f6b67cc477bd46bc3a7f103d141d85d36c72471b4759e45e17e8679916e18167f3e21dd7a706d1d9fe2d7ecbf695bebab7fb64103e59d759a93ec5886984847d3564d6d2bd96b9bcac3782fd4f2942b5c523bd1aaa5eb95b79b91d42920e1296d777afb26095cca2aa56196a7f91ac46174f373ab999c9abe1ac8842ae6f73a6d846c7a7dc89132eef93d2605e07aeb69f7c51b391bbf6bb33d59522e419563b4a1a661f8317203d2b32d28173ca1aaa25b63eac014b09deafd424ad716faabce21b6b261cb066795077f5391b22af820ee5e934b1911a0d331864066443db4d38cde54db510b0f05a4e964ee43a043d277e37c25e69ef158cb0892537f1c6cfae1c24e28f2c2a8af731a3aefe76e3da05b1659c8ed94527a602c7876a84a5e4c5d2d7fafed63240a2c37c486854d2d7b5d6a82c47df9e13851eab504e5bc4487e4bcbc5f5b13bdc26e7541ecf8c7bb19a2b5dea50ca2c62b48c8b3d0f599465cbb00df93c1ffcf63f17e9c75d1a9df08dcada4a71763079a191362104b33d28c28e8be7b4b9928740803ac17da6f7e3097155bda3421c1b08404c1ed0ebd8b812fd4dd5f01fb21b784477a6d0f4e7d74dd7243eccf1c4083623ca125989927c2436ba729d143d7e408d6bacfa1f6bf93c7a179b44a143ca1c0d6808370fa31d4c6ff23e9f855cd13079168e4a63420e3b76d11db44d623264a74ae26a015f88a03cbcb588c2af1c087cbe28e8c796366a6d22a2212e089e19ff4b0605889db0830b31780e6ea83c6170bc04ea79923fb5777c79a70fdc3bc9d944b3a5f6cbb73c0ed8d4d54ec40846cd85b5df6fcdc87893b755b2fa48146ac5b78be1db485cb2737af81de22ebdee552e792a590dba4547a273ed45ac9d212f1bdcd814683c482b9de3f069f7bf182edc343e7f0df8870e9dbaa6f49f518aad9bd9c1429caf772b7199fdd5f8dd27b384423f5f77a702b790e6d29f7093cdab6ca25824538fda4852392ea01553c5f6482ca0110f2580ce572923e237da3c0fe8fc741e8bac914bdf2cf26d27864dc77b81230f99c9a0bb9902769436e962cadd55c8c09d7ed956a05a94de34e18977a13678a58e7381f89e229c02867d0a7af5e80c8f6172c637a8b49d8b0d83fde0934c72d942d8e6ea09a67e822bfbfa97ccd6e2e68bcbc784be8728a44328a07dcc1f7fda2d2b541acfbada0310ae67860fdcfece1a0ab462cad4001ec8576fd17d6388751eb1f6f423bc9923dfcae7cb5b53cb9cc8facea80158bd9285840448fbb16d6f0df22c82887a4b8e4fc9bdf7b57e86ddab3af2ebd9540a6d94b94caf76afded88d4b9731ad06a98d3a814c5eeed1d1338ffc853a38ab8c9e8e086675a269ff8e54d43e8deee85a22b49ddfa8ecfc3527b264fadca9cee0f183eda698383d09d6d68d189c231c0cc4bcc140ba3e7d9f3421a8c1d6d6d0770bb5a9d09cae109df64149f755d86d7e1799a4e5eeef3c8d0ec50b28aff541ca836d481aa134e7e479c7c7e396dc89818aafde481dd8a8bf672f5efda8870370b6dcfa3145dc1bfddb6cd65b70dce6bde640148c4b0eed008d4a6bc67176b669c5fce52ee8d5633476d9d401140b5be4f65b9078402d6ee6c718918169c40abe09f77d3126154743c745dd430523541edb422b26f5a2640e3a8ad8c2b03e329d357e64cead7b53fd111819838e8df0ca68e85abc6db5cd4dbeaa33b9d1f99cacec768104d38ff6d8cf4051eff0b7deded0f88c0dac58e2749db7509938a66e3207c40dad2b63c310e4269bed50a2b0f03c78b8d9a6d3e9135693304591d87419499a8e146dc6384b58d8a4e31907abbc1612e4ab14d4e15fc104f1a039066dfd12b416eacbe0af19c31406f8c4b9b4bcf02046c0908170e535951858e6a03cd88f16e17fcf2c8ae4eb9b1638797e896f3f658d3606ab4a4f5c23fe9646473458685230d206dc71bd3b3ce6af6ff79b86a333f12edc2febf864c8886464f33e8d7793650c9d02f67d78c1ae6d2f4b04f0279a0ee0baa32fc3983f788877e4b01c128abbec3223dc5f314a391687f275328ada47cf06246116ed26ec477414320d4f1b5369442153c91ed2c88d3964590d403ad6c304779278788caf2306ed1cd85387f3857fab488283d7f87d1be43f772b588b26e2d5bb344c017c22875949710d433cd4fde87b75b7b04243351c3ef18344ee30b005b083b58a6e67c81e6287a04a23509643b937b931acdb2c93e0581e19cf443fb70e8f10ef700584bccab45f05512c8d99261996594c2da3d46e69dfa92f0584cdc0178d9ce42f013dfed4d13e216ff6d15ec82fd4f7682bc07de54a34ea51344070030ecdd1082d5760f25d1a616ae1ef6b6dac7183e57755d4af19bf8da3b2e8aebcf0ef99839972372d469db826603e7e9850b0a0d4ab691cbd0e7f61f8bae4de909180d95207a10f77b832437835e93cb3393bf1797d6954c986fe885e09ac9a40b01981e29cbb1e194ddeaccf7b709f70920695d1a15bd557b216a3845559b19b2a7b484b83f62017c2b0f7ea585985c2bd4923ad55cb09c0aa719f36af87dfe188d6eb8f1c364b03d8ba7225ca7dcc036a905cb6e9919b9b12dc7589e5d21ad2e772b6953b2bf50e1fae3c3fb2803d2b229603f12a284deaf3a997816f9aa3ad8c890d454d306546edfd791c8799c222556a45530738a78e5f9c68cabf57e526c534ad03b39bb57ab82dd9a39644073be9e6d08f39f338c52a2a7b362d26081ebd68c15eea684a44754c87e0cb55ffacd1e19965a1d1b1f7fef87b323ae4f4c12ce623570b531ff5889da1264262a87c91f1ea638ceaf9ae5c6e31a7c8c38ec86138690f09398c004b6a4fb3dddf838c11f433e841f927f0387578bc2c19ebf293b550ee740c8ad155725383e8902a74febffe6ccdab179c8a7d46ba95073d288cb9063226a6c267b0d743f4dc6f7fa1712e0b713bfcfdc6e1ab415c5aeee6fae2d4e07da3569523fc82b0f04f8e52f9ff81669aa4138377efee66a0d612313f3ec7eb27334d84fd2d3f7283855be78ed00e339e94e0f32f3834824eb92d0e64660333cfa80829625382db8cf7ea13a010118e318dc061b60debcc546e85c9da9ede25750813b01c9ba3349078f5bd3506e6c8b6be67812ee8afacbb347cf9cf5500704b5b5da6ac80e9ebc5f09a569559049f6d6778f42f5ee3d440fde0502121e67cc9b53e95820af7f3312fee905dcdcee6f4dc382791f2f9f8555c5b8b372e1bcbd3c7e036777914186a27f2bf3eafeac873959edccf9b414810b9f3c9cb6519c8383871305a34b239ac4b6935c5c75cae8d95049472791de6c1b7efcc84e1c0f9876b7ea5186d598e7d77650d1c0be56a1f2ec7c296f4f19adbdc27c12db92629687047e8c6286318bb1dd3fc630a9e8d01068defbe584d865597473ccdc544afa30d6a4dda65d0db215a67e26d4d8b5419ca0469aae4e0742c9c61e4ecb66e88a97100b4d6fba5affd8d00e056bf597aea434bbcc8633a5cd535d4f33eb3cfa0e5524c5beb6633e267a275b1af209ceb35a1319a0540dcea71c5c02dc0a255045ff32cc00c0744d04c7d766ab2db9198d16b2960748daa2bafd629c1110456ce9eb5a27287f2cbc26525be9f0b0f81d52d8e591ac01aa64119bd8672d84755eabe0a1ef04c6af4c6830e4da8a9a5a529b9f5eec2662d5ee1728c877081290483e6733f4fac2c817befc45832e1f8042f14e37c321895a3b398d404e5e539810ab5ad564d2ee0cfef90400b737ae055ebac42ca681447c76311326ce91d7d6cb2d22f21d872b1818903b25e879badb63dd11ecc0d08f47b16660211540c88ebae5efa96bcdcd155075f10667b7a76b34fcf0e2de9c371b21ab302233bd9ebf6c2ed50aff31c39e2bcf2f5caf3efcac3a4ae0bbfd7ff0bbd84904925fb993345eb5b48462a5839d28edc50393cbc4cf2be5d35821fd9e094c476d543a2a8adfba96d695a75c84a1765b6de6b8761827f285c45ef18d7e47d0486867b57ec807c8db306ee87d79b34234bf01e4be4b1be8f770b992bdcb2d649f3f48e9ce820d257ee351fa89f26dff935783fa4bbeb9db228a3fdd06114957e6957149d3ce16f02238320c5370b1cb96eae9be771f77f430e94e9408dac2f6c3608f24033afb93ecbcd060ab6e4a9376279da5557b2e1c58801274f5eb77372fb5652c3762f5053179a1ce26d470aa348d8b9b7bd17e056ffd3dceee61b602473a1ea5a2fe59949a4434dc498b5af2ed18fe00bfa2e91b2eb3602f147397955f37a198617873cf22d975c76dfd8694a77cd86360fbd243af3c7eadad9d5e62a9737d83f9e67d1c552a5413c287e944029be58d74d70dc4f5e03b229cf81e1fd5d0b70353bf5d5afa8e49f523d6b27da8c359cd7fea03b80b4e06f8a962ea09e9175a9f0d0c198bc56ebee2390e11e7db017384b40ea2e66d567e9ae0e4a25ff9bd00cd700d0bd137970908427a98af1adb2bdb76a3bb2729f4d564fcdf116457a7c04f3efd9ae3ace9f309650391b06505e32b3e9aba318beeedd56257c78371bf39660291ede7036b8964396569ee0875f3730230797f5f2f4c6cbb799f1165ae678dd484f47d4484f707a6831f711d5db30ae0885ef27bf5c50008ea7dcd2df62f2421fc056a09e4be595bf2febb50078a6ea74959555c45ad03a1e2377bac677cf48d46cd5034c360d1aad63c84ead261788fd5bde34731b401bf79e23e3d772b5f5eee173761f5fcfd3b6ad3a126fb24c143141fc35b55b7ff35b4e82fefb6bc3a8ce42cf4817acd64d2174564884cfd04f6dab8e028d5238d49cf0f58dabfd0449fad07efc565379df95927e22a874bee0cd6606f951c8a5b1b9304c95de20912761c77956a1f363628265dcc1ad31bba9fa0e56dd7bb57514fbf1ea01f2de7b40ca8149fb574ffbe523bbcbd7b18f9336f31cd0d0e3c9c7ec01c079e505bfc9ea1b6a5600a5ff19e25b2f252601489b20075b3f719232625471c28d5f16cb69132947e5d659ee898ca0e2f735f3e5faadf22f54075f568fccb5fe50bf061d5dfc775bb909578bac3d0484f6d1368b6636c9956bb838672100b4af9b6b019a6c23ffe4a0a10ecb87ac1662cb0569f9e829e75e624f155993c219d8e7189d99c47c040998cccbb95b1427f70b7a24730b938e8e4a6c7ae0b0d44f13428f2e2ea4b2247769a6850b2bd83ea1768c9f16a4eb65abf2a82601973f4d4da897fcaad3e8700f271d510a9352af808c3c25948717e980abcfd2a786597cfa066d745527131331b8b633b72970d023a37be978d145c4015a267220d9999102998167354d1ba37822d7a92d6a40af6dd85e496b7059acc5ce0de077ff39b4e2074376db2e72d3a05cf659928cc91fa4e240f360971c3609881a2743a100e1b17958e40cfdef8a6a6017126565a621ea304eaa0b54336525a183d03f578f56d2264a8a1986225d34b032c5611549a1622ed023272adc6cd6a085c43b898bbbc49aaea7b851ca50084b5b17d9402e96eda8f26ac0e2d1ebd4715b30a14b293c3cabed4a0d55a9283b4a037e1006fe486d7d5b15e6282d7da21dc77a63f92a04a833e76688ee5c0d33e6b25f028753b7996ef2fe13ef9e2f0105a76d46f96dc92981d740e4800ed5b72d6aef5fd99a90332d68156656d2be7ba6b79f535c01a33db6b6076a8e461a75396e892820401d94288d6487f9cba55976bdb076a9c956d681ff21c5ce6c554ed65ed598614d22328e096ee25326c2f9ced2c35f8626bda89fce360f6fce0575724b114d311c209faf9fb7f2f540d7fb022ae0792075e20b34fc756fce66b3dee97f888073631b9cbb620681c096e3fca9528c3d23a5a2a8425032a9a166cb296fa19defd327bcdc951bde4400a0173204bfdeb1823894e9e94a84d7ff7bbeb66a21bb57afe6331e164bbe9339ed0e615cb8edb80e5f863793d7743bb106dd7711839a1464eb8b75578be3e9a3b45f2ff659e62faf4382adb46ba3913ce0980cf67dbcbf73e5c0914c5b55d885d805ad18cf1f776f2197a821e2d3c3b70b050d8efe711c7c7326ff27bc6a15f14b7aa185c088a7f6a7f1cc783bb736bd0be118f434c8eb5d35463d8e0cd7cb271877cf3943a92aed7bffa5db48006921c47d295e37fc76f15d5ee67637742325277b267b2804e91a66054ee16c11f065a3bec231843b00dc9161bf708d7e271570323aa899080c00fd3babf1bdf95d263a3829961f7d845afe7c0f4a48f27370c096da2caaee4014b3934983e2a978b5059f1cbdc8c5e8eece4a89e848bdc14094dd63dbd00f041aacd40f961266a238a4112dd9b5c3449784e58a3973529b585493fc0a0a3ee92104cc8cafdd2a8e0dc6a29e23b97425a6275bccffa6b161545e9ca4d6e3921e2814bd0713543987f788266cae2d1c62b908971ee01b19f17bc259cfe06a8c77d6cadc8839602366571f2a25c6cbebe757add5ad4a7d9dcfb0584ba9215e782c0a38a3330b7114934e43f4f13dab28605ccce95b83212371f9b6c696e0c3fe3a8148cff3a707ce746c9b32408ead0f74b9a1570d79b14842ae0a1f52d8452d3067dd938ef46fef8f4110ba6a8ce9f54e48b76ed2d543e00d3aae08999ba90c3ddafbbb1c05f5865dbd115d1dbf5f3ddbd759d20d1e2f663b2d5f57f0c8e36e6957860c8c67954f29422ead5831fcc246f7717a657ff401ab432aa06a79d86454efb2f2db22a908c6085af2c97c1bd884e35acc3a29dee7909490083865c9dea3090aa8b36316b0551690928718fa72fcd6d2f5ae583f5bb8c7a4acfd7943e8fe0d7d7040752cd31e89ba386ad2a8e47a65d06f191e5ca3599105f6683fc810d2ed877d872b9e8eecc1bc3ae1a41245ef290bb05d6b568a4356742d09eefc5eccfb521126a304aba76bced7f73565adf5a725d7196efa33736fdcbbd95db8af717283a5f4a55820781fc50566af67cfbd31d9c94243d2f9506cddc9210758101f27a045ce1ecb4f3ae7b7f43b5650cf0b92e931f9ac713e0a10fdcc56164027544ab69c4749f4a4ce456597e5c43ce49b42c513cc37242bf9fa064970d8634392ed740ecf17b4bf40ca111c78d44c2e795e2c813599ea58b693739c1607e51d00a70d7b6622fe62685574ce993ebe93d3973c49dd3ce27227838bd009a718639c556d4c481f1af4fdde84dded7252004b1c3044b9bb42d514588f35fff377ccc8f462bb43251caafd24426b6612e70207c7bded16eff655eb625c5517697cd5c378ba8b83e688dece81dc413f23b844379b0d72880b514f4912d58107b928721d266c25845af52fd8e05b137d3e0c6dd91b26c326a77cbded2f148fc05c4e00e11d173b28d4d1499c9df2b418b5f8ce9643f0880b05b8e2f78949256a030de9ad08c1e08331f0c543d049224a2c88b426a1abddd0be0491e05e6841284578b7e825188ef9076aeac1714921a0627435b4270100e35017f9fe63a23e2ffce9b9a934e39861cc7bdfaa64b0af2cc650000df9111b44c9abb0a92df8d7715d2469972be0c049563dd9384a2ab3909cd3dca31ca2f4d76cb726b2f885da65c2c4fdd408f988f53718737d651d6bc89b50c1c83678178974cc851d44888cbba92d9bd3ec957a352d8b6e25f4387e3ce30c0ada18b3ef007a4b690bbdb509be08587a6dac1450494e1d7a864e233a0ccf5f00aaf51d0b94d285fdfcbbd3840bb605d34439f7cf2c6ab777f62366d002ca685f056b711a87754b4086f433f89f9540f27a09c8ebe6c69020514f7dc55185801c713eb03b609e76f25c72c2b217421b115f817d71570859775b3ef8ae70dc8f9df23f6ff2e1a0fa07a925183025e8d7d4bd17900a1c60fabf7d84e59ddba0e300c0b07dd0ae0a11fb50c0f85d81a90358b1b636aa01370a2651caaf81567f4709e1f2903055f3a173e454ab8ec2745f54d55c88bd33d8a7d0f09e7359d838699d6f11a0474db4388ba0d3cf1cad7caa639de853e5908665d7700a074429072d4c4a4e1751474b2469e442aef7d5c787ad99d54a90a9c3d7fa57efd3670be207b93025ac9ca85c8530a5944f8c22357d00aedd1e8f05bb7cbe035654e93bf775cff5c32940b0c32c60f468698e1d896fd7dff9ee805c1c000da4fb60e3701a9c71b4df6f34714d006436dd2a123a0403ac99fa03c2e5320cce9ee1b65483f0fcc4e8c69c2efaee9a327da4fec7e136f52fb92a7fedee7286a8ff500b69b7775ca68f639f81b0c94ac80dd0b2cf0c24797ee3079a53d93a91a702d610b525164d3203085f7c60519318a03cf8a3f86a214ff15c5a1295b4226d9fa61a49f556be042bb5f1782bed1ef71ed4db911f1839db885f8cd42ba912767c07e07de1cb05eb66ec3f343f66079e32dab4ef67e3eab6f8ceb8c21cc59b3471e991981b0c6b04c1a817e3be54b38c40839a4cd53d852f27871cd7680affd84a9081278bab4af421acbbd6b114ba9551cda3aab6fea542808a11ad8f62893fb2f3375ca94dbd1ce43d93e221e3fa44879915c18aeaa83543612005ef3d1b9568db0977ac495b3ef8890a8ae03b9296ce58c87ade48303088752894c32932ee9afadf39228a86e15a5b4a68d73e6f2bc82739e433bc140fccf4c6c1366bf14b7f1e883178f56c9e0e4805ddd153e66411a11b85184fb4e7c5363636aa9403e82da6312751ff8cc1c3a80c0cd1c15bd43059b87c1d9e76d002d684da314726f885888978e0cc70fd975954f16858d56bb0703006a930809c188ae4784ae1b8ffbee97cf2cb4f6efbea7044dc62fc4092eb6e165355601f292e36616c262eb49b8b09648c04afb0d0c33361e011c7372a2499c73113dc63958be315682242b8a09eab4b38ae36319aabc4f892efe670e04724bd5e5513e23306887f84b4aa35a302859cc9123626bc9b41653be2c422e672846585d0728b9f87b881bf66f96d28856448dd36062e440508249931d1b74c51d54509f8b6322c9bfc91b33d549f67a3f421f9fbc3fd31a5696aeb5296c1178aa8e9b8b37103067a6f3d8e7226dafce504623b92f072dc90ac5056dd9aa3532932d05842f525cf01fec52f211642e4653349818f441cd6cf5b1aaf679c1c340ac2f9e211846ee8ce7c1755b7aa58fe216a3b5088958df2028c5c85be69bdf7ed6b031d1aec1ac9fa1702d491469b7e14a743db42e923f08e31fa21783f69d33b1bbb1aa11909ece0122cd33b1c2a344077c9d8a3f63e144d04ed4d934ee947f0dcf6962faa72aad3bdd9a1a6a8f24af6d5965065acb294737ed247f5d731850e569c869a401269d58350aec7930f30452a64cf5fbc80a758aca824042d2140c619eebc4421c1c108e26897ff265b6534229eb1bf0e312d7fba3fe20f5f05502b2f0e0169bcfb9ef79fabf5aa509cac2fced48de2370aa83265e092c8d446b539095b828eefbb76848347671ecf3aebcbcee20bc140a45b37cf425f9c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
