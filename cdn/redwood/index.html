<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e135fcbbbfe4d44f498cb71ca20f35b9ff0b62d314df5bf2194051625aca63eef8c7f631823df8a6271c37c100c9250ec6cdafb989740609a0c194f48a98ac58ba7e9109731fbc4f6d030e82937fa1e8c82208b6dcc9fb2b9e3474890d378b731a599d99c49ace3b2bf546de4a1bd58d5b55f169bb3c274fccc2ddb583098fa5a7f4f25e574857fa0e9cbbb321063dc017e6838e8aa4663df33292506731140d8788807c850239894e83ad0f1ce44207540c2eac702fc5cb8902f848106d21d0ff3b047913194a367db6289b264498d0df0719648200e1a728856c64efb13993dd4bce5957059bb8ae5d20fc358f07842476e126c6a5021f9cbd8c4da2e81c4e941911cc50f7007a13753330bbc62c6a4f1fbe7e9dbf8dd520cb84b390a87b72ddedac7b8ecd45897ed73d4bbca6cbd02e0088ecbf449276e398e45372237d47136084baa43322eec9a181954180a26ddc08d7147af887837a421098c76f7c43bc5e71b0c98462d6f8d690b3c91b77652ca90285e509d172d4a3e8fa4d1b1445957194c5e576fb524ce50370dd46aaed76a42b3235198e4312172d46e779cda1786e3f37866ccc790dffc113d16e35783bc593cc62771c5e2f69b7dd6fad1bc79efe25183e3ac94573382e12d5ac7bf27269ae39853f4ac87e0f1e628b6611954c0c8fb0cf3d8c02bfd365477afd52a4342a1524cb8cb19a2294091dcdecc03d6b8e30b20bc6204a67472dab099794b84c7b51cf6928599111fa13c19f7e100a60627e619fe9e30e283a83d7a2adcc4fb172ad182077d70b41e7561470d2ff7f7982dcea5618c6f69a355fc81f32318e80cfeeeff988b97630a3e9cb74b11fcb471c1934ac90721c433f95be2a21c2da1efe4b9393f2f51e59272773810d93c343f2f5b353ade16794184e90fdbc7d95fe50bcf60cff83adb14fd568ce5fc43d1d07666b1fd0400ca14ddb4cab1c5eac7e4baf8646dcf8ad54b7c84f2d75381ead389dac832455f2604d92d45719581f1ca6298192634246b6aeedf7036aef78f1e4cc9b0b82fb250adb3f6231973773278e67b36dd8f2b1cdac0829817e67ed9643350eb4eacaf8de3e61492d82de610fec2f58167e62d26b6dd0eac6e4dd03b18f6c63ea2386b830bc016bf74cc56388f408b38cbfec99d28262625070141b718a2d1d27c2ebc8ab7cdef709d8b3b69617bdf568a6020eb5e6c727aa2dc16bddaf4fc5483bd002ee0bef52f13585b742b95c71726b0efbf510de9729b7c308f64580184d5adb232c42291d29c2a7b180a461c10a75f0c883e32763d9708278ea89b67462b8e475136a3aa773701a4c733469424612655f2c73604940cd97e46ceb3a32fa9e0796762387856350c0f552aa9d99601343019b88f9b5cf1cdc0bd8f3e6cdf26c3169a2324d9276ebf69c1f273f0775f34e88603418d26d216c9a8d4214205ff004f59e5de545f1c0f3ea45dd77bfa2403a14721bbe295bb3a620c57558b1ece4a44936a9a788551b2f0bc4bddae52c220f1d53d0ec6ddfec1019d326f46bb5e5d8bd4f01ac2f8c238b59ca29aca1ce5b675fc7a87b1ca75085ea09624678fa8724b182b24f20f4f7920c680f181ea6ae1513f95067d5ef59bb12f034762a96b68cb65c04d1eb1f58493c510a98d191a82a309daa29aeefc0f92b25fd8ce44a0080e3de43e040d154adb36e84f56ba9b9587bfcb896f4001338ea1aeebd6ac1d156a6319d2bff8b206401b21e4f2da5bc9d916d9a4c6c95f8d40d9b983a426eb9263e51fddc89c44b302ba8d8dab730e410d8e50537f2544aa039f482f6ccf8f32d451c0923c0b9f89281050c4e1a871bec018445f72a439d513e6dd5757cc386196c3da0f2490ddd5e97e29f601f0a76483e46b40425be543fd63fbc05618095ee0c21cbbd3f5503c5fd25e8e5ae48042b2f38f73f6b27dc0ea4eb70b52608d3fc49343cbeb2641a4c12ea55a9382499a0b3b9524bfdc63b7a7c4c39699ab9dcff4ec86ef4e14aa49089cfd17b1609d5e1576c9ebb99bd2b025e0f9fa6443239f20a06bc6cca4f719f5beb73c405795950e0f7813e5e9d0606c330eb7abf94b9ebde7d4a2dffd6ecc59ca2110f2688f1125607fc1c4f5aca13a213709dff6bf12d0b0233f8917d86949e926a706856320257c2161e0501caa8109ccaf7cfee5c6bfa197b602a657915278429b753ce1fcdb795119bc68331ecb17dc1337ac98a2c373f4494b003764a3bf4add18667525a8f40f7dfc9fbee4b1ff8d5234211ee6ec1dab0c3fd7dbc9cfce3b8fc67b67fee6b47fd51882d66de95f23db66e9a838e866736a6aed20bdc7628658307035827d762cddf0758301292a1c18b04ac918f7abefdd325ad69dcae20f2bc21434f1cfa1db00476d3d0795af47ba9ffdf4093f73a0781e159a6843a199f5fddfb68c58e5de6b4b211b64c4f9eecfbfbbcd01a8ce71381a430762628e4de7cb53cefcbd2df8d8241b2b79b7ba14030696ef862d30307b350333dbd50089bf71b1472ecd82da834b6721f00f4140548a9d9fb69bd19b18b7b3a7656681744561e7fd20211a7cedfc5bf3d1ea12b88d04644c932b18f78d6ca74c283a7956a7408eb65dff372bc71ed6c470fac660c2b4bf44f4c5c1bf02dec0dc94cb9da0e6e14e31a61dca9de01d1a7c9f7525c34f2c59bfb6cff52e9766e082dd89a99fb8776ac244d6e2c6f1997b754ca10c2af3bc5e337bb4dfbdec225d492273d4e9ad03407d100772dad58737117cae9cf4e2df277e7b60e31f6d1404c49d7e137d6f6c923b550782e50a29e993b44be1398266740971e2a4ee58a730ac620f398f3ab22c1ee3fb6a1a56a20784696adc81726461524692457c9d3a7b4aa5eac50cdfaa6c5c5cde83291f5e91b70a723b542348ee5658b469ae90c8e64cc3424144ced0543b5e688c576f01565489b731b3b3496672a85401fbf2d8c5d075ef1ce9c26982ee9525a0c237a34d722e7ff5dd8ae82e1738b4f294dc4fb0e9e29a49658e70dcf791a19a51bc904f2a1b7b6e7af28dbc41bd0cc2189f3c12aefae33aee0dc6e98a3066706c93365eb3152a5d085abec140bf02318418fbae6aa63b19810a2c03c9ff4c3ed49101fb1034239a055c364b893b6e04ec40108f0144ee9712bd7cf98d0f7fb310609a5a6aed4fabca0bbd5b8b33607cfb24ffb78efcbb118935dc0cb5db07952a98abe2af71e11e933310830fa69b95c294af549a55f3c65709e0937466efd76003118008b50771baa537febac3ddb503ce43eef3b0ee83e6753a65e40f8dc72159368c0cdb9aa92909cb633284114d70e18601f2f42c92372830605b3e6403813f13921b65228683b530ff90185e2ea972cdca40097212c3f1db5d0ca938a0d3a7e3658674cb0ceff56bf9e633676e9b51c875bb741236c692f5d692e7e04284625e5e694c3339f45977486b2ccea3cb553730d4c0f3effb8c8faccac254090ab5d49f88ce0a91c0084a6ed4a7473da36f5b219d84631ab16add7eb5aec7579c27c16cbe5d726443a5c7dda012b5a7c26a2bca629978288e9cd790e56c7e3c2a2ba12d6d6cb4530605032761fbb87c2a227cb6653012a5b8ed2f48b6a842d3bb2c108a1c89a41f12f96e33e7cabee0f40cccf4dd0d23fdc6285743d50ce915a578bc706b624c36df5d8116190cbc8aae2ac0fce8cef5f4980e2f5adc7fd86719ea11e2c380f76092af0a3d138012500a95cba708c1ff6ab25d9b51b1bdc58ee3f80b3f93cccafb5ba02485bbd0e373e8a365f993e38b723bd0389265eb752de5fd6db7461092f00ab407abf7c61e3b7fc5d3fce9dab8bbe9736ae8b5890a486472a401ff8da3ee018b7a375ac4e299404108a7224201e6db43988e726e0bf68359d6ea029b98430d136b4f33d01f0e6e02a17fbc20db3abc235d6e90b51e40a85084ff5e80ec1284f5761acc5a0da5d1951fe1e4b0396e899397463781a8c9d1b3a00a4a3076bd9795607367686cdc85cf49620ba2492bdc6e787522abc7b108e6a7189de3255cbc82ec8c323274c3e24cc8dbc3b7087042d3b4ee4a52b7e0e2f86563d36025a5eb0205866b72e94bda22622a2c57cc521c8b432bcb2e9b17a32cf887ba3c9c80868169373eb46830d6805a2b48ce488552963174e50b8490bddf300dcbfa97336a1a4d3e3bf2b2057c6b3158314003924a5ae9365863c939882d3084c5ae3ab461a8aeae97c008f7f06a3a3ad3dc7d7395fd1141f1980ddd0fdd26f5559d8446ee6585c596480647cc2fd0e2258c7f297f9d8ae85f9d14fc99f9506b5ad3fa08b930d590d222e58335c98b4d9cfebe03b1f2619ac0a4d8be68bac6a980eff67c115d38116564c53c3a133e027be2f47c0ddc567e7f53d0e3c1b871f8f1e4ccdb2d42e2ab594c0c1993614dd7e80cc0ebb6a234e474141bfcf2ba41d61865192f45eab7b1767476aea15c5a5b7b7dd043a965084ce3990ac933e149938d910572b52d663c85e2472bcebfb60b0c2f8c3bba24995d25c10d6d0385aa178ce4076560bd93a5e4363fdcb41aae4f1b90b358484fd1164f26775ef78b5fa99bcadb52ff48d9f17f902b8bcc343086bd68cfed51ea5d5f0f24c7484e721f2e27531bd52427a00d45f05f5199aecda45cdb640f2c0e10939366152bc668535228e6ada1e6015665c8c2d421ce3ed85e2096a1d0559773c5952402ae4ab1886505d74abcbf26d173d60c862d98928949608ad669d19c93a59130978041a360bcf71681f2e69ce3d55cdc939ce695198b33a361656025865f88397bb0c160be571a0965b3745c33e1e2663e31c97699eed7734bee6198d3c1044b9a6ce0155ddcfc896d9f77b4eca894f84aba9f4ba0c204e0489b9bab32c4e8bf9b62f488eeef3999c6029c102e69ef554f8a206d48ae4fc4c4c04a98ab95cdb97c7bec01c432d625817c17e367ec7504ff735fcb8d027bf8117b74d5ba82f57d9d3c0d280adf9665360fd902f68788a6ac2464a494da64b6e287af756d05b2c43c06de402189b083933780dec5a23445b95ae50198036f78b96341614a9b0035d86bd9466762e09485c91c39e74c50547c6df44271ee6724dd5730a39266300c829fb8a8e5b35132873dbc37961eada3be925cd7ec53c987a05f83ba728d32a76a3f8645220720d5562e9e2affbdd775440dc0d36fab5cc1d7517e9ca3626a824b9ba98760ed5e33bb2988a5288749d735a57433d0c3ce9c7ec91751c0d7bd1cd0fa071fe4d840c4c7a137c3babac2f084944f5fb2f788c297844c9c5a01159836ce227a53b9e9a57987ba7b4cc5bde107bfbdf259f20a4dc5799802c21fc30d60e5f0d6bc7f02afc58bf6ca623543044de2be34118ffa5f3093973baa2b88a3774e504ec3afba062aa1657f195314b212bd02ddfadc4345146d2fb72e0b39435f1abe07f55a713486c450b260cddd779bfe82ced5230953e334e9f9b02a9e01e7eedf4f42bca3b769a996c96ab5643f08ecfe2ea7e3c43c064788ff7e475e3c9d728a91beaecc9396375baef83f1d9b1338aeafe0d1899fb94799c8b410f6629c58b7b944ea737b66142913a15880c66a8c154a01503d3d9d1ec1a1ff88df2bcdbd4de3f2b58df4c501f3a43b8fd0bbceebd8c794a69acf39635ab0b7b6f6031ff0b0bedc7e9457cc0d2941ee2bb3c751c0ee10df5a00542e42d90f48854d841058ff41fa8cf816d930d1930b750e9af8dd2766d9b12e6468fbb368b3f94ebf91e20f37e38608e071ba8cbf98c3f5b9ecc98c7a6a812c5cca1c5456294aab70a16ae6d03ca761f196a515ccb309feadf6fcf087bf33885b51765b2c052d0ad0a6c18b566f3de20a7f5fe0029c2e370757371c49d219d59ce2c7d92d5d668a206268656fe0300cf69d556b8198a3a20078239a77d2c0e198ec9851bf3e890dca05909a0b709b4b6dcb1c28978d9a781691c7d715dc3e8a6591979f22967d71cead38e98b7c9ac56eb5f4ae45bcf5594d4c3a9102f4664ded96040455535260e655c06a3a89de3a59508f63bc60b12ffcf2ae12c2c69bb8d03245180594c97eb81acfd409117c529d36341f6c0c90086a09499145b8da51fc07a7dc4f2e21c9fcc40b2bca2c114b88ae4164d164b168a1520f4cab73afcf227222c47b726b232e04a8145177f207b6157f64fe734aa9a09d22ba5e6dacca0c30194dc546915ced196ae9e241fe32f519c9dec7b1d570d8cffecc0cff712b174217f9b8fa91942fead7815ce5c8268d590846bf359abe0441c2bea951ab7d58df63da82f74d72d3964d3fe6ec3d34ff0dad4444bd620c40b63fe21cdd956142818e9fd92a10c22c56e6e95437b78822a72c864f2d3753cb9344b1737633403e6d9e6a547a94b24bbfabefbcd4600ccafd230df29acb4d5f34e7ecdd397aed33f073edc75e7411ea3d90d112cf8e19e8d5bee39e0df6313c3531643fe0625bcab0be376e57b37a87a832066723fff7b575cbc5c5c95d2779530d923d3991f33e00ff18aaa5ec96800b5896417992c0ef5fcbfd5f1bcdd3b98da18962645694af64db4ce05435cb3bf69bf1813abe2ab7921281dd02fcd7cfb3c3097a66fd615e05193331c5c0a4663256758b0c8eadbd8dc6a7be9abbb38e20a3739f19fafafb71170204c635215ee673bcb2bc246e8e686a13ff269f15f1c97ca2e42f93fc3aba3da5c5839d27007d5a9f713a4c635f512dc78a87fcfd17ff53363a485d510569168b6e55ee24f0af749dffae81b75ac3d4b1c7a841514fe77303d6caf4c34ef3d33a0f4d2266397b69574f7455b037011a0caed1d15be74940b82d9ad6104712c79a654237d46f0ea3e16ee7a30dc2987754e166192316728b18dd0853c3aca4f24ad06cd66b4fa2b23b18370d7fbcb81b8c2612b6f801da2fd99a8595daaff454ef144dfb409d1ece09b353e15ee399af76cff20ceacb8ff6d9320446fcb4c96dd0dacb4c38b49678a4d1e177d6ec874d7c9fc0d0661646065b0864bac4c52d7b158f0e4833aff8c214ef21e8bd0a406dd17c2cc4845a4cec687c377e23aef8290fd43e5a348da2a791cfeb93aa952e959906a285a73ef2259daea6662130d00be908da4ac8f647211625605aa35b57d142f85ff18d817636e8ea6407563e0f5d42d4b5e554344f8cf3e45e6c588a605083ca16a0707e18227955c48cef30ad4317969b4b6bb984de01622355c2600e7b0d129d82902bf05f81d2637a8a368a51295bac10ce85263dc35a3c9905d62a595276b969fcc89b7a8771900a09829e240a1d09b0394790603a64a9cba6e4a3de7448b06a8b0584a91b3dc0660041c679d033d88b132d77b9fff7254d5e95e600d79edec860f8198ab7756ae6521170e55b423add28af038ca116a347f2a7a2f6a8f8cdb87bed346ec4c8ea37092d58cb7abf97803bdfa616a44303c4c08eabc076432ef4d846fdb1083829defb333d5b5ab13f7e45fdc45fcf5db6f3aabfe714ca9ebb7555031b25f3256fd8653d622ce12cbc535c0b9a57f26e6d7b0a4f72472879ede774a571bb004fc55fdb014deb8caf087b4fa2bb2c089f2a82e7b811a06169949e2c8c2572ff65e6aeeb7d06da06e668bba505f0bf0263fdea5cdb42511418771404c7c9ffe93dd1e8e070ae0428a7e4405ce5f4eb347c2a45b6153109bf22b9da4fd78c3ac844f0e62c2d9aecace06e78544c427b212098e43d7795724efd756dc3905d19c92ac6e236c71ae3606fa0bf705ff62137ef6847bf6e9f2f08c4095281734e631033a87d54ec2f432f516668e18a8ef84eb4766e8851049df9635edd9803a3d4eb9482048c4c7010897ec30959b47b964ebbe4312d837bea1d52dd15654f08b9b6395dfa445819a861131ac5fb6935346f2f151cdf4158fe69dc55049cc972de512741375aa6f50f33436b49ca0eb1583f53f218828574047d28cd0689ba9e288f18ba3bde7f449c5681c098d0dba98ff1bddb5def1d9ff1e1a9bb3c894affdcfb9edc1960eff615ddfb58e5939801683cc8060a289fd75ecbe7cb1c33fee5f58c8be9281416d72f522e36a9aa5b9f378a6f6e573a3f0c562fbab68e4e4573c62151a5f98b9de238ecf8dcbea4bebbd0eaba27d4e3397a7a6c7b02a8f968d9dff49de0d923f93d595cff2944999de650c80d40ae69eada170fb5e1735f87907f20dabb18683eeae18bf35ef803a693f98bbb5dc51a19042df430d3ac930e04e7d15f2cc8a56c0f621cd173b8f323bb9ee63965fdc3389303b0c42d4642382b1b718e1958b095643e29522f276ab82f98d418126445aa0beb2d1749aeb4f73610e3c4483a84e74282edffd14a4ec0e80f1aa929e1e88c3321dae898af7cc9cadd83b42e9459295b89bbd6c5fc7b9956f1b5afec9aa3f7cbc78b7ce4d4911c9eae28367358146eaa4a483fe715b37f35e23325b00ac04e59b4a30ac1b996515edef9953b0cc045a32b5aa4c6ecfe8a779ed690fed74a5e33308de278dfba482322275ef5b40f7e731fe2fc1212bf2965c0cd2b6de0877b2a20dc4821d6c2b3558463ebf25130db6363eff2a214ee93e63384c947b9329dc984d4a8b5ce695008e96b46cdc8c385d4349b779814773cea6bbaa35682f1b5c17e6ee41c0aac301ac71d6a0d743405e22205c787ed5093bbb04e42a69d1efcc631128c76e6f43525198bee327cd61a4d242c662e0796cb2150ecdeb2de76233986a1fdd7ee4a424aa9345a037cb15d1c5f95b7031ed7a44326343d9f9dd7fec36b77f35a001dddaf158851882261f86a188156d3468279400b6bdd1f5a53c5c21af8429e2fc1c690bb034f08066d4bf84d1178e61b2d5b879c96ba3e647c00b99b27a4d49303fa2abcd0a768188a0308649a5569a0ba2d172b23a85cfc5aa86a765babc0a5a4400b9ed9d0f0db7cc8dcfd5378149147598a8afabcdc83e160310267fec3c7d1b836295465819926fa1dd58420ae4a7d0ca32d820c95b200291f336fdac362e42f0b5757cf8f8998e171feba47b057a63a704abc63bf1761f69a61d908f5dca301f8f1e8ee6d06c0a1200d882b0386e8d58badadf07b5109fe310d989da793ea35ab8227314ce098bcded7a21bb8accb907be34b211852a0fb5c5a30b218d9dc2f9f1f17add692c77d73360d2bf74711d37be0c8df1c441f5c3ba8ff3bf53ab92d69ce102f5fb8f2dd84d32b8c49e86848dda5ce5305c1ac7b6f784a8251a1f982034af503240fc4e4434a40f3962e86c554e7cd08774f307bb1074ed5e3446e0e14df43e65b97696ba628986bace8ed43681c02f8c6088e4fa71589842c28255106fd6a5fbff88ea74fd83f090bbc178d86f064d5f0b18f3cf777ffbcc06d90cd23091c4bbde6ccff372f49ae160a4f51004d50c091d94f57819089b308b5562f9caf0f843b4fc03751033d3092bdd836f03ae5740a359a68ed36a22dff799f5b0dca0ab4d64a516940d4f7e8c8e8f17708f8d1b3f1523332778882baaf4c0ba815b3009eb01ea87eaaac474a3b0dd4299279aca50725ae1537ecb3c64296dcd357ab6a41ace0e92944f57ff77d8701a01296c0883b6f9e32f95e4f635ed345fbc972cf8cfb2b1a48dfd867cc0c59d9a1db1bbd6e13ba4051fd0324f73e381a67461eb9cae54de36de3e964c2474828276ff06d0c39e1f00a6dcc2fe99c8b3d3e43c2513d279fe8d0b8a2532147fb1c6554e8d60f143ae8e1bcee2914e0c0bfc25f1565a382f24f9519598ee8d1051b0697d9a11f499bb5cbf45ed68bc2eff58d6021f953b538202c4d78872b3f1627609d555f98bfc6ecea02c1bfa580602ed9a9c3a9bac134d0b4e579dbd5bf11a30d4c20de1b5f067b18e0ae829a4c92cb614b5e541d3db7145ab4b1b9eda6c7e5c7be83e677c3d58cd58bd210b89c26a28e0fd1accc88664f181f44d101e1db0c88d73934b084a3e40a0325399dcb37045168f7283c34a4f7dc8047bbb1d5ee9188abbc0d6e8004f1848069c85740374b1ea113a9202be231ebf0135aba3edde85d6862ec8d33943b53a577564db72c0c904c12089c3aeb01baeedf3a28a6ce5e35c3621da9e2e57ee4a025f52a11b6687752b88e7bc318ba52f3ebe73e757378791422ffe643d576daad916044b14ad17c45bcddea07d4640f9def6032a2515a53b2e26cf1b8efee0381ecad461b8eebba559bf8e21a1d0599a174ce9f8d1fd16c9256b957b25769a0acdb88a53237b3a93ae2b85fc540dcfdee835ff5f2f0f408a16a6356076c2f845fdd4136cc7ac93dcd2bf74c43b7f4a7501d545ffbfcdd3ed6f1aff8c806dad29844b2f61e85d6acaecdde59dced43818a1ac4ce246fc5b7c7df16fe6443b106afd98b644e9d898255a0ba9e8e79b9a9ad4a51a3af8a9d55876e8dd013922d90c068dd64db1822dad9eae3dc0cb73880487155cb9decaddc3abae506a8628b9831111011369607859848a6319b71a1cdd77fcf95bced48bb8b6cd8e14a1ae5f09c5222d5dc529a1384beabf16a996dc959515429cf828e64754c9e03bdb55347f8394206b9c794f77999a1dbc0581bf2c4649a659b91679443d3c7fd123a66635f6b7da18cfb55af292eb0039bf1b466af186cb072237810b0c2404011aa09b36f2b1012bb686250abace8a8e9b2177193befcc034352105e23690349b1115151ba6959f79d38523d45885bb55e7142218651c3d725bac830cf2113becf0366c69421a86bc95dae78f36e78914bc4e7b82fbf1857b1db77cc9aa6ed597fdd622005612dde8dc2dc9c2bced755308fbfeddbfe5991f86876004810cb20bd44acc829207d2d330d6221e58f1d194da431a07adf9e43a18e1961e75fe55cee777f870cc13c7a2f1a74b3a96d6deb2aac511a19978e27e40c388fcb021c55c86b0f0e3ae1a3cc5e4f44df1ac6951d02d81508d60bd940702923ef8b51c41aa9b9a949c097519fe7ac4b1cf7df7c971c7804c60ebd9d4dc9e862f9c53d5f7494bcd8b4d804599109cf0375b595c6d7085a63127237a94884dc54c6eead546c5f1edec9343d64aedbc235c43a3e24665d46b2615465f8a5221191d97843b392febafaba137b168b1a63cf0705530996528a5554307b5113210cf30a19e70db2402b38e2debb77eb8274180c2f4eccb6dd3d90c04fcdadc8bf9644d419c21d4b44753a01eea93f44eb654a87f97dcbb838fea5f257fbd981f65b4f417c6e809aa3a2a34a26bb5e1b2cf573fae33a3469005adcb7a291d007b6b565372efc8c35bd312e6ab30f881eeb6310a9e052638fb0d15b97750072596ec6fc46b3af2b71a38d5e4745e107bc7faa3bf41e1db24c75ee1fd6a120f0381edf3186af460e2c74cd495ba5dd798099dd0ba7696a603a02eac9e52d32be425baa468824343bb724d7fbb19225d628245c284f4a12eb58387dee8b0561e9e6fc9e1b49928161356113898428855455d73aad831365a528b42c499cfd7fd7b773e31af26ea52e6e6a40cf8b23659611b0fda39902e1da0c33f5ab4fcdd1a623168a62c5cd3ee225a899edc4ac2f9f4e82e7234cd45df1f4665facc3673ddd9e833b1aaae2fe74ed44d5198484625f76d5c90670141436fef201aadfe3f00b58797defba88f3b8d22215f5f92c5636bcdc0290b94fd358c88b4f38a4c2e311772faebbb1cb6e51b291e75e8026d5adf400727dec7da10626b678d43f4f18c3d4b63ebcad0657b26f7006ad4dfed1fe61ad6cb26ed85e8d8a73ed0d7735f46a7b0f0fa8ea1d1052386a1e6963d618d404f08fecfe0ba575f763b0e7db9461b54dcbdea053b97941305ca33119d6f4ea6a1f859b925e5d330ed7323ed8a7cd0934500d05d19741726979dcc3934351928a6d9b1c8feb4cbd7ff64a4419502007a4034b2ae5cce0b05100c4ec61961b1337959c484f3344699e3477fafd046c416a66fd99c9a42e792013fad266c549b69257dda6d8419cc6a5f4ce287c5df2a077b8f4ed2c7a79df8108b09acc24729b57b53f2b54dd0015767e9199885b5825d4ef401bcc59822620a28e7ad36b375dbb3eeb2d2c98a3407de1214efb0363729478bb3689d74a72ec3057e01ff2ec2986252a8c805fd5508732e6b210ec59aa67aaa8f505c5579add751ede326ea95488facb139f509773fd8767f9db5a511101f59084eaf82b475e78d7de5dbc07689d74a266cfcbd9ceb7dff606ccb7c96b86c6da2db2ca6633c7576e1de29c2b07a34a20886440e35a5a6be95b10fbbd28903f1ddd300445fe93deaec5b42933679c5e615aa1609279afd9e3c8b689e8d56ba913018010b09c990899df0e314bb3275799dc3d08be7c7da21a6fb7d791a5d946c63ea9e369a3c03947e11e683508c9cdb0eadbf466569c38bbbc75989cc8cd05d50fe655c810b8393c7a8a4a740d8447863bbfcb30d5410fd1a425944b329a9898f96f8606e63049660a33d8583b4bd764ea01707f32abbf5adc1c5f670008a4963a604f8f7c0b0e9a9e99dcc5431402365f1142100d6bffaccf92b48414940bf9f92378b2b3f62fc7066561b3cecfeffc247c345dcd8237a456bd539c46bdbfaadaa75dd80bd6e70cd355e99fc3c968f52e82c81f265e4c461a4213e1a9dd01c5f60be25b42b82dbd7d20da84010a625503e457115a0164a5fd75229e4ec320f6e87f090b926aab7378842817efdbbd921926b90328edc168d06a1b7ac119d50cdb10fdd516b3e73588fca34c5607e1d5c50396fa463a7ce5be7591cee1496365f81b7cb6b851417f522fcdf396e20d9420d455fe0539f913112b02ea70c6228ab43f88079365ae73d40ff99251edadfb10e5c5c937061cdc7845b806a20bb1d233766a1852d28db98e0cff87cf492d29fa1b3c9a4ad1cf1385a591e38a94dbe6074ffdf417b09f6c8c986f221c50fc4fb47d550bd512dc06c064ae30a193cdfa20d9a6f418245c869faa0cb78d036c12f116e657d8e5b7f0d19be447ac1d3dec46aba6fe5d268ad7231144d40fe51a9e9a0449b3e4c1b05ec64ae8ea6a66d26b7a1dc09537134692904c46748439b480bb5e440d3777caed117c65d7cd78bb2845c2c5d66ec0d51aba3f3b83ed73c0ee65dcd56aea2897cae07869c7f39b97e28bfc8ceab6d5b155adc2719a6962ee32afc7162790eb2a46921aa9453d8102c10f21b2e0036b438c87ded2ad0011fe4906c27018726ed9f5283fb93415c783a7d962fe17b2dfc5d5714f11c11385f72b24bec5cee6ed9dc5cf6c0b7664bc537da8e6b14f1754b5a301d416354a797b89b85bbe062d0e3ef0ebc2ea754d5f26a9141dcb67abd1300fd9f8184afe354bfecefce6a472f6b6ab064dd30e99e40b17fe0f259a47eb77fa68d8abce14b4406dda65e4da6a438ad729c8a81f4a179bac2539bc0794bb5cf9808e7183095019cf824c004954bd0210728ee6f430b3291b37e7ee12266f32ef4c97b82d1679125df9883209e1d487ae9550c25a3629415975c49e9700366e22ab2d0d955dc8f5ea7b9eefef6c844cc619fb7175207b936ab12c5ccaf03e8674cf31acc5234dd7372c3fad7328194b2afc12248fb6a72b63b2ff1a7bcf2bccd0001a70fc5ab634b2e5b9e3539c40e9feec7dd82ba325fbd51a4b77cb3e85f9ad4c42964eb4ac87f0cfc646b4991ec8fc8eb6ee630f89e18cce08d0fdf23c926cb5a7c47a1f2d2e9218a584a25902f181ea2155b21c6106e01d810bcc6ebaaa823a8905a80af00c20e8ce6e080a21e27066d1b82d044c42186cbdc5c60c06d16a79d643a6709c95475c5e5e30bfc1b207e20aa9c319bdc2926eb9f312828ec4fd931d293ae9ef5f88f7b37020205df214d30f9425f155a4ab696a32ede6f643487f5e12bd2be10cdeb25bb93309587aa4d6d6b37a25495f5ae4dfeab91694f5f39a395ade421117d88ad1014977274322ea05d4f1d6847ed620e83c78b45503cd7de6eff8a8bf72fcbde9d1196ae06e4f2f7eacfc975b4833d405c9d43236685a99b91c074c1ce16f9653d548afec21fd22027e918b2e70923e895db074ab822a63994e9de76f465ec77897d165cdda1c492f6f9b9561d76658b75efe5762e7778e8637cf05928f345f362ccbfe52b1e936cd397139da4c7ef40ed2f9c3f0ccd5cf4b0409ea17d0bbb27ddeb0c931b92ddf481953a4614e7f7b6ef45d7704eac461d21ae15232cb8544c53144d80667778d35111871c6ba3824fe0b0d38e25c7d99df32673e7e098ff75c0e68bcf21f60a4775ea302244ac574bc2c5aa2f8d5a7a7d7a8830f80415bc44bb70d7d0b0480f58ff19aabb2711e25a1d4773d7759995f73dd26d4dcbbbf9826bdb27e26c49936ab8533cc847dde281565d69c398f3495cd17b70bcee020ea91e44c4317a4695f01bf33978c580d992c18aa84cbdb51e12495624c3ae4a82aad9255ab2f5e388641ce587fd2d78598472e286fe0bde0790e10435336e4fe1ed266e75b8b8501006f1f332599b45ac08beb22b765a9f149d522e0c45ca275f3b0478f9df491bdefbcdcfdd34fd49e527a6e25d9ded98ff7fc20d818d0438983793ed8d18d36efa84963096582ece61074753c67a8d236b33feed57ca98ffcfa6881ba3c655b1de10aa3beec36169b23f4ca7337361c6c0d784a4b89564b5c70fca50b2594c051debdd67c8a0d1a625c2bb3d8ff2a15dca0d45dc8172066dd7ac8f9a95d176ec0426e3052b65b5334e192770d098ff0d94180484be513670a3f36ec7591f56f6369e55bb2557fa7011bdb8e394a0eed6984241a1c13b23073854393813a5151203c53806bdb803f048f4427ffbe455641068f3e591d146d0ae11dc71a120bc65747d884bac367bb325268d3f1e9d4fb818fdf6efd6f7b3cb18d3ceb8954a92786044b3a4f9c355e3db3354bbd0b8a0bddf2e75c75b82e90c34d5bad02352404ccb5b7b6c79648a1e1e40b0fcf8b02b7fc5243e76295d295c831b1fb3bad621d27206b985f4023ee6698c6c9296b0e0b10c865202a5ea2714215bbf0c1d183a0077974a728128cb66b15bd6b550df7beb2ee66f68f600ecf42e6c4dba39ce387728aa9633ddda124ad1038eefa2929c75e2503f27665d77d0836000637bdfe0d21690d7acd7092dedb75ae889f42d51858591a41958538cb4599ed31984e4f40a6c0cfe28cb062931088cb9fdf88acb1b93fa14f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
