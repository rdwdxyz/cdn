<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38ee8e2996ef51554bbaaa36e8640f43b87407bad2877a8866a3f8fa64c9654978d23c4fa88c79f56ef55c4cecea2ff62323b79529ffaab8f3ee634717075b5df0231b4c0778081a28882febba76c8f1118c94297d76dbccaae83055945850003f1c528c3f9ce79f748dc99a538c28ee406cf242d7f694337d12230c1fa315ee57d8ea5a3690f51e35f5c85737132d1e2b5d8b845c2c8fa75ad6e5d87857a819ee1d94cf0e2e93abb99deb6ee399dbe1889c2d8a3941c86f2af4925549e0323e19da0151d195dd59423713abf17426f41742306a4a742fed3c63f3eaaea0094a7e172c35bf681b2607a8c911b7c5e15267c4dfc51d72d3a437ea2ae34ebdd559bc2624924c99a33a671ebbe6c93ebb1b0a16715ee42071257299119424553bdb213605c58928b7ae54fa928620c3232b408bc96ae41cef8bd95b25aa1fdbd1652e8030e30329a2b12fc7e0fd3fbe1fe5101ee6528062eef534b416cd6baddd5f8c87cf6126595cd1afa4482aff23627e58abe8e2878844bd768514547c8d9b43cd5bf3f4539307d8f6aaf9f76d8ced8a61230b755c6220d10497d9a3eed9686a29ff7db29aefd95615d415107c3a0b85a2c6c6c6af2d1c9acc54aac7a09b2357c9199c697655dc533146eba6763729d2a7023e7529aa430993719f8974acc702d75ab9966e45dd874844e432f274af3d6664a34d87285cd482770080abc5007e328bc44ff8571bcbd0d41ceb247edc66cae004b4e4256fc94dd484062bd3e8ac2e667333ef2a6a7564fc799f6d060c7539d1672ff9d967feed48d11d6c9f3ce1ee84f96c499f508bcd0795d6e0c0e6bdaa2136a1928a0b6a250c8a7200cfe492a69aa56a1a1c110cd99f4b23e4234ebb3d340d954d2d5b989239f368da917be4f578965322d5af787a86a6cdd85eb48495557473c9c1e20fa63e17faf1322163dc0c7e51b0d23fe946c5cbd2fae775860e209d5e4afb685f25f878541ec43b5f2751ae7e50efa82d1d43cc55009ac3697d679cdd08e9b1569b8a916f04466c8270f6b839693bad5636283dbeeca8ff313e28aea96320aa83954c4411afc36af07996a7155a3f0d3615ec8f675b5f5b99b1eca3c171cab6bb4199cda15101f2abedc0732dfe4603a751cd0fa619b2cb4b73cd0cb502c963af97a417689e735a207f09878edc40b54d0fb7bdaa3d6790d2d57102f7e1dcee92e22b9d923ba2564c6a7987fc5503f97aa510584374ea68443dfdc59989b3483fcb1bdaa3ad269e08d57812006048b7a6a0f1d24a1c23a6416b7292ce2a2474f0ccb1a17e8bfbdd26c31385b9069d3841acd66124204446123f3ac6bec8d20a1df9996545989414d72d0e686585389af7390334e2eeb80516a2ca1108a248ead95cc4c1ca6307731dafbe0aeb5a5f52156923836132c7e99456e9a0fb05cb84fa1b72d0a973b5b80e22e84e5502f0282d37b88f77af1d8ca0c01081add7b03cee7dfa4702fef9d92cf291e2201bb81a9709cb85241f3365a003bb7c3571fff96c5f9d23d14d320e6d3a448d22008b1b7cdadfa037c58110655a562cda10a9ce61b632286bb9d937230b98709bc582edfb7b6004f16a54cf2f4384100f73e60f948a0288eb15d30bd07413263dc8597c6ad693ed67efd6066836039e40ef492ff76aa2a34f71a93656522ffe5d92215de93cf1a32950605d9fc6a49a588d74b6872fcf9f08a4b4732bcd2b04c482938eee768bffef88d4f9ea0f30f95944d12daaa5ea36b91fbcb255f321412f3fbc0b7fbaf059b3b84b5fb5d3f3e66fca8bde1751b3d488c4078b217e62138cf17a590aa9583dc00a4eddaed998036390f2af0ebf5f495adfd2293b1c8a8b9a4ed30d4a6fa3bd95ded5577841c4f80aed5301d4af219b23a031ab8f484c8d8f557e0950a0102dbe8dcaad88d703b6c87157266ca6d97c25c4955fe1d1696099d609286531665147ef5e3b099f3eaa9e89eb2c3ec5ef9583303b19194c16d07d7833d4481b945882364fe79fb65614dee2a491065b868eec83df4435447559c0d52a1d9850359a31c80985ea70db6f377cc289a040a736cd81af43845373c1de46519a854e8549dc069c9d114fa05c2779cb2133589ac9fca03481ff3b3db3be1b0d27cd9c6aca3b99f293b708f6e811dc481aa5cd6d659fcc73cb8841e6850748086d0706c799a2b1ef5be65d4a06d3651b011bfdcc484e69de23d88c1351db06cc9afdf56559c4e7d2b845bc33fa1b4c65dbe78679de07a2d25920871b8f3690d32cae947ef79f536c1c304765fe9609f77e5ad31d7ca4392d1c882e2595866f20421367c946f4ec697694476568146b08d1745fe230253da09aee2b9f32a313e8d49cc23f0366f5d5de1cf2491b43dae1d02ecc5450af1f1f40447131ca01d66e0205333e07e8024d8b7e2bf66d5802b8cf483d3d13d180d489023a8cd73476c426e51f11b9c0008d818d35ca410ac6b9f144372aabe2dfcac2f8f48a679eeb4bfc54444e7bff8b55626e7f4fa9603b9f2ff47ca02741eb6b8b392d295c8a9184af7dc5752a25126a778ef92f5860a65e4ecc503e99e5b1ff804ade92a2eee182ab9063755e3e3fad6670a61978150b7d15f58a88fa553df194d087916f70955a8e30ab2e8de7a7a447c11a9eb11fb31da45aa1e69600d42b4f35ede83208d1397ac22d6db7cf404eb3872cb06eecbf651d111bb6cdcb1db2cb0b38aed2f83fd22cf0c8db5dc852679f80969e58a7053cf9879cec400d5c87fef00710b14edf88dfd1d3b542646e783285e2c6c0cb3ac5edeb038d81574ba6af4308a1f2fbffa4041fcdc63822e36692e477096559fbd7ae0568076b77f26f950990bb6448a2aeaed0e7507b4f330c6acff4ff8268f0c77b0ad47dc490d7805718a2bc1676bdc243fda303d631dcd47b02d90ee5f2eb78d9b129dde7a1476cd6a3c86b21e8e31ec13c2dcfc5060501b31488970785bf246b3dbcedd1c6ce08a0075c72ae289a2e866a486a9f02a0f68f6e2ac74e1887b4e11e4cedf64e27a6c333c222ba96f7444b7c47ca0e5c3f8d9752ece9f23d045ac91e755fcb2653b57764454ee069504280f122d5570328a03371cbc78f20be5e1ba5ca8cd6ca5292e5d99926945542252643ab82a82fe7aa084eaa1ed9cdbf0a87635a2d295d45459f08f44feb1124a934d7920b4322c794b1386701286509da53d14f065b7a3e01821cc3b3f2e8daf1fc7cd60224e1d0517445557bcf7cf2fb50657004e5921a7ebd74bf7eb7e23343d76bcc9e52ea0affdecc79bc289294b928ddb413de9a0f76fc08aac2a171c4d579a754479eb75e32328209dfce69873fe09e06ae028c4994b3e569859f93f4449409c1c1d6509236252ef0549653bba808533c969300e556dfff9da78432644aa6bc1a73ac4fcc2a77498af916ef053d4dc376ee2428cfb6d49e5196df62448f6eaf17e2c9269d7d0290168861982c7c0cfc6f72f5ccc9df0e7dc788643b1fedd13f988335d6f526c773d16bf02ec1f4e805f624a443da61b2fc5ca4ef86124aeb013e83395565e0791d0c540a755609837f7cf8c504c34f5cf79dc3d07cd02194e61a0b065563a5443ce1ac79a4f02022248cc8c632e96aadde3c0823f4835bdc57d4dad40208932fe0808e0180f49fe1b6d81b6dc45552aeaac801bf3f354846735a264b001fc152e93f67f7ee72906e0e0137f5a525f5fc21cce6409952eb4285726f99ea23e1793d30bc5fc68c1b9deb0457c1aeb66408326f8809b72db0d2ffb202d342ef6e51b56b329f17dc6b9b635d4b8e02cd11c8c6e021fac4909330ea23c1e665a8af18fb415c418f5f1873ca6eb52c85f92901c6cb99cab290858291ecf9b396ac2f0b4235bc7fd68c65ad82eaff089b3d950f00c3cb4a099bcb985ee6c757c74ac7edb5c18f0c7479915d1646af542ea459f5de8728dfb13bae184a41ce2fdab171c99b382729c1ffae98654acf2b72b733b84a1f896ab25d8c7c00ca6ba6b62d84950c7cdc41a4df34034dc9e07702d3ce996a9b05c7f6e0cfa0f5850c5c5383aee16fa9f59f62a3f9b67b3ec8bde53453cb5c62bf1d681101c1e3e710a38c8c831bd7bf5b6be8cc4e806a2e67a4d10211eb073c2fabff0aade5c3b48e67b463e9d2b4c19b8c7579a60b42f83426cc84167f533903fd1ec7b32ce848e0e806565f518f1ffe9455e2edbb856dbbf74d336d24c978a5015871ae382d4f0e710fafe6a7adee1f797db26fea291426b8036a40b7d498733196ab805542554679e51b438ed42686990e1de1b3ceef4e882a7f500f3cb02ed01674cd2992d8bbae9e0117e84115c013bad5511255022bb22aa864f1e5264b21c205d67230e8ada9363ba81eb6e69bef0dea08534486991a8280ff7a7bcf12b527de2fb74c560c1f1158418704584a4e64ce68ee793a7a3764bb503ab998e96a0987f71dcbe4a796c44c396b854d2fc0d146b581cc7b1e4522a987ad54f77a2f7063793acea44b2cdf0043c7eedd24b22264bf73aeac4111e4f4df0ee816af50ef1c718e28d0da9857fd10b2dbc6248e8d5e9c12deb3e71bf3f459b9777d9c4e799552cd3b3177a62f67e16317cfacbe9ea67e286c6b6c82634685864497de5fecbb4c80e2b8b9807210c2e2d4c3d21b7aa67396b862cd905437e4313bd3c2cb6d1bee8e3db18c1540eb0193e95a4b40f34c937201d1c4226c633944576c5a03c24b1534751ead5f5e5c4889a5bd8775435f5aa7fc2383f04e37d057fef39468a7650ad564a0bbb5a04335b5eaadc4f15d10ee9ae8766f2da79b7b36825ae43485991640800da4b3b2b7a4a2f0b46a3fea4aab0373581911ab7401bb63ab53869d8817e2f78c9b860a2cfcb7187a8f780ea4ab4b1bb59b08b3a263ea0fe3a7e5d69e51bfba189e66d40c777314d7bb269f0c742c84677b9a44a251d46c30fe289878bb653563454133b5d1c21f15bef46896384c3c11f983e6e81108c26c9af928d45c1705ab31379ba72b0f50ba27f2e640db37d04bd4b3edf4e9a56f67dda4e7df0a6e21dfc72de61abe676044e16d8b8ed6bbb82d20d1cea9e6180bfd424bd40dc4270e3bc736659203b2165e0bc7f209a38aea195c49a12b9ac20213c6754b069eaf29c6b60a30641a8b016f5f89ef8fdf63ff7820873d98d2219fed52b22b2babc9cf12f42f38bab43e0f1cc5541b3c5044495d36669f235f1573a0128b215835ba3f35810bd7fbb68f98af920143733d7e16578c8b61f875dde5baec402b3f86a58524a62884569ed783a1ced640f3ec52c8d12bd107e5a2f95825aa0f6a952c02c79a3503266692226cea17eac0d1f0746ac4b7069a895e51fb171c55054db13d7c4a5d1c095762a8b36c3ce9c334bb6c9f9be5c4c796f5f9d7e3c3daf808785893ef2f5ed79aa585882743ca80fd93d945dbc909549cf3d150969b0d9a0d5bc3eec5e3a6dea1f21950906a1c50f680942b0d7907a5a313be38fd9f22e05ab4d94b2a44285fe656aca1e6fa0dc580b7270769d253fae6bf5faa8204987112e30c7c6df58ef9b6d90ec59664c0416d10dc3c66550d0f974380a07a561ee6dc76e3aac541579819fbb44522d9f812338077512a480b97001d74ad3a52f05484e85d3a2fb1bb22f0cf93fd514c09812b6b52069d21ecea4ecbf20107f2be21f00dde1abb978e5ef5e260decd1403c9b28d172fab6ce4cc1ea405d6559807e1ff915e160ec2dd464d13a909c8b71dbf727b3a2df2efbeba5365a739d5327413c0c7cfadb40bdebaa18817f5a652508481cbd38f3716d3dab60ef34afa5991dccdc0c7340681c835c352a27dcc57269d8d58002bb52aa29e6ccfaf71b4c0af7efeef79f5d67e3bf0a226c9f1a4f3cb214196c6b1b44256be357deeb0d750f42b36472131a49635fe4e140423f575c6e3c36b0dfe167a309dadf68da4d360694ebd2f9adc3b9b3bf5c7fadbfeebb9b8ec8985085b767975ade88a6ce337ffcee5165df0b84ebd566f34fae00161023ad5bf3db8e0f22d931600c0f2e511c7fa65a35638b5d501fe3c88a649856365bd510fbd695d1ff94fbd5009484c01427536adb83fedbb80673213151d07fcadca3c6464b3063f104f0ef49efc6c0d0d8de29daf75d5481d8f732cd11805a675707dcc4ae4610f166867d3faec9d774f7c5d95cb5a6d3250f84a0ca04e3d82a86b55460d9fae2ca60c216f123415b26867e2fb2399063acf386bb5d5d245a6e95934d6ba558cb88f5f6a0195f1cdfc3a3ebebd5beab0635d33baabf3a8c5438bce491888e988688a62c6a58562509e4997f54ba0ed9ecba793d2871616b475e1bbb167b964e664dc4ba661b848c3b2ecf066fdc85aea7c8a6257a2202ada6bc06f54c64636e8339a73eb7234797afb96dad3719c96710745167360f99beda1b95b49b741f1db692719772be0205c5ba56a6cef750a3d3682f2a2ce43ec8e21d758723ebb2893fc08acef9524513d3bc67be3705a678ea0dc1323100459a801f103e23383c33e9958deb143b7238f33d534033f2a971b8cec6bfde36cd92c61ac4dcf8a0325cbd7efcb0c3d5e2cb896e72bcbddcd6860f781f8c483bce1b55780a9ef6d37e1287498b615591a1a57822c10af7212275c14bbac11825504ad0218fffffe6b6b6ca10e6d6e05b130958719e605271ce4ffc1adb14933dd0cb1a25ab44f99b4e666c71c276a079efd30241e7cbe05615d9d77638f5127ce1e19243d90c6f666f63eb02777c95aa4d1be779f67aa01ae4b8bb39fe9e187e47bafd1a658c0080a4b44fa470748193bd13939aa01254e0841f7e357f3534ae41f632bf8bc715c5551557ad980fa5923b0012bb96ca3ae54a6b4dc1788ff179da8a8b4e90baced19f366e7b36e5808a52609706e81928779f38e3fa6fd274b694bca16e8c4db44f3457f81074b7117e5237fb6b3e2e08682adc5fa3295a579bf30bd262c351dccf035b0bc7448a32b250805f8dc05cf3f71ded1fe1325a64944ab1f5d16074f8e3ff099fdc81d88d0250f41df7d7644dc3c7c6531aecba0e80f9b2d2116487faa48720559d4aaa46020963d9ac0553fab93b31c6dfe190f25318d03bef17294606856f7c10300619aed94421e409feeffcfc96d83d5f76bf61702632f3ebe31304e72c3aea5dab776cb9793344fff4c3218bba956c25e1e0b579de42e79f473980a44e4152bc7f321c21e4d883c448dc321c7ee359bf54ed59ba0326505cd2a21723cb9759add2f06184278a2d38eea34d45622669d6e2c08910cb0e8f31dda798b3379bcbf7429a82f1386baa7beb0099e70a38ef1c408981c60f006bdb0889a6af5237314815cfa9039eb36b6fac451deecfc823f96d99b2181064c55aa99039aa520bc69d72f5f4c1eeef6a450abfd0fb0387007b4fe4b0995aa1e00285cca8053bdd793f59243bcec02d661047547bad466306428b6ac753fd9de792ed510980dd35b674ffc73086a4a02383e66768ed4b36660fcd5b3544a598669d51024b385c09cfa6b4f52582984f9187e762488b973cc125d3ecb32ad0f055b193db96fc0be409185907b340d6c8e968164798fc69b9e453a649032e8a8540dafc826776e1f1eccd7868afbca4716418f7b9943798755dfa944042467a99f2f5dd088b0e0208747904df0d7fb4ff08a33851db55993bd760b02f1bbb63446332052192c89ce97a200ea53f02108916fdbd5eab91d012cca45bcc1a4d7a43e159a3d330d5b632b178bf32f703aa0f58e182912651ca92b2dc2d0c034f625b22fc36bedb8afd472d4d32c50683c1eb7ad58aba6ef3452a654b6c40fb516b7097d4472fde353deb23032de9df2786800630fd758796ffa49c235815fb78d4e8cac97723d14e55f2b469109383dc6f6fef21a2c0b687dfda6507d50cdcfad89c0654d437b59114cd14388962563355050d2e279e52c39cda3488b68946471343381aa058387c48dea7f08d9426b91e2424f2ce374d77ca652d57ea8c15126b00697d6d613d3059d06750b05b0176e650235efa522bb4d8af02e0742d6a189e5faa42461a22e7fbf36af33b4665fc61b212caa83a931f2d510f5d237f7a10294da096b0d1fe2a3907139dc02ec1fe012dff101bd943840a59fc233e3a83e02ce97eba70b28b7668f0c2c947e30fb42f47f410ebde595fbd9176667e5127de978ce9b756a3e9cffc3df153459d3ad23aa376195116efe642cca36b9c88ef2c21679b9819e45bc8c79e3623827e76beb618bb6090056706991efff13c52af779efb8c81e660a25050362d3537785f0b4c99d9babeed565eab4f526d1cba3d617e3e6b5e9eb5659760c209e12bec513251a07008ef7077053faebfd30ed6276d3ef8668e0ee774236503b337d9f308df9e6d668f547d732d52f48e2b5f1b6e37eb9f3362a284581f1763ae2bdf13c1aa40dc97e359dddeb040344a65e5ec06841c55ab9d6a5893d2bd6c2eda5f70dfdd62a611891c3a49db348e0aefe56c16be9eac564c9c94027a49d85edda2ca460e1ee5c987f7e7efa570e1ec6b06a8aec8be24d38ca5ebbc47d82b4371288dd676e6194647ea76433adba2b2c0c5815231e9b514253697fc93211a9c507061c7ab9c1d6f462a6c0d5bcd9345d489efa661898914037ab8c98ce3e0a623dc4e5a09feeed2ee8b9ce021aa13e362fffcf9e4728d0ad18c942e92a2b034132204e84d7eab259a93108f48ef7713901af438b4cb68b660a0005be1c651c9d8939a098bbf8c8c3a1670ad719cccc5dc39938da8d606ddf5077267da5ed0451566f8fc62dbd92e9238b85e6061547fe4de377a588db38ae3ba5a4a5cf3bb5b29e2970e525044174feaabc79f75c634a9f8262ef581e9a4c5adb29d807d488be6ec4b42179b1f5ec9050f0b686fbb01aac79d8ce1135532e82c69efc59a11f5b3dc5bd3f4b0ac8d59e4c16a9db0749379fe212a95063f6c2131fb323635bb5d0397f70cf6e9199296b6b3cfa24fab73beef20457b3d68b98cc149e5132590ddb7d5994ee1258f6839ada902483c3ad719e181dd47d90d5123a5e21f9314b0878d9f3dcf2a2d560801657d8afab17515f776e67a391403913879dcb066e8e6fdbdeffa9d507c587ea506a991b1aeab5a11ede1c8ac2cc9bf907fab10aa9d98ffaa8b1b29360a7f907d988f871d1893053f13945b58179b1d50b67ed1369433594aa2f65b946b18b27dd907fcc1d60365a7f991b37e3244013ac3d01ba2023288fb100044dbdd6f5be8577a9d4170a6bae41c3b227d6d92ae757ebfd033e151ab7c918df272445a0f58d87370daa9e20178e6dab0b4ccf5f9f62dd2caa94deadf7bf6fe922f7790a28d0eec1dce830eb177e5ac5c58bbf88045f996edcf61f4c0dfbda1db72bf6cbdc135e81a292c56d22f9e32aea9bb726835347b15d92b29506c5cc47ec7dc2b734595493a92da636b2043468f88aa68a053192bb687ce37eaf5db303b4a10baf16724778531c868e4d6690c0c30a8f0da3f11ecfb00ae619db7c3504a36ba054b943521f46fc2dc0f4d13ecdb5204b9f287b236f0f1c5c0679ec9bec01fed4b36279558cbb120e2dc687ba5b1279780482aa2876f53ba5174c2b833fb58ec593534249deffd37651d65356abb3c42b4ad9836c519e92013adbcd54350a75325e4f1c6417256da37a62a16fef358bb535e0040c67b2c08a2d6d2574f77eab6dbf4818422bf41737435aa752fd6b63dd1deb74184795940881ba480ea3a2d4f54f09cc555dcd77e227ba99f58336ad2949e3f2a6961bf0c432aa80124db50ddb124aa99b6b321e38dc4199be5c4a3acad69688315dc5a4779ed2e1d22e780d8c3242cacc949be731fb0949838d0226c6c28a08f4ed2237458610f2cf421ad6fe7cd275a7174d429fafb2631abf4f705cc4b67f97e30f7af73a569983b2a7e59de6afec6c49cd45895a13b4871564a6268dd508e9846ac344be41631560cf0b8e8f6732ca4c1ee48611715dcaa423cc6d13494b3e37683644915c3d82264607a93d6dd622362305bcfe6d7df8fcc9625fe7c32e8e0f89ac77afd85e1ee6c9faafff456bf51577f887a2742bec5da113f3d9d013f079f9779bf376e604cc212240338c6ae8b4670740e75706d09f9678cd653e6610f3d59b50927d4e773907b6a2f67fe91390a3e1bcf8b280ebd390cb62090078ec6d1f4f01a4ed3d5eb310ccbc3821763c95cbcfc54c774d0a465531db24531d1aa975b1354bcc372d4fed6d903d724e681e00cdbf0c66bfbf05bdc216747dc1aa8d26d81b520be5d84997e5673c30dc1661bac2f99f1eb6c27820ea66609cd4b4538625283a3114496fca86d96de897ffae9a7c1ed22b24e10cff4b9b4e4109109f7f6274abac9f54e531a21b5503ae3b027ecbe4fefbc9e5ff7b0601c7f9be7fd4aeef903631a4a633525ce6476ac78f8c580846363ce952df4269fc4a682a4de6fe8beed7c16988f8f3a9db061a436eb2026104e56f44845f37fe5823072a1e4bf1eaa291c1469502d58374212fb0202b9298dabb983038bcd9de5d32aa446e0e7a6c1398392a03aefb7c85cfacd3ab99d99cc2d659aef9f645681fe83572e11eba5428b5808fe678258c07039fd14fbac2453e697c12d3f426d292e6dcbdebf75d304613dbac91498d33cd91c5b44d6e57f106426d7e0ed6911c651e80767b5f7f245b94a26d3a5fdf35e14887441770feb7e2bea809cb5f69f6cba6833078d741af06e296f9175d32c0b7c8cdca951006702ece69ac311a346463e11a93bc1c82bb59681a1efce2283b26bcfa7dc20bde38a986b4e5234cf41ac7d5a5bd8ca2de7beb62bbd6fe24f169b15258f32dfc8c1dace8864fc4d1c8f1804873e603d7e84695929b159e7f48eca1142f145f4efaf434291eb6f54c59d77e797cb9f6498969bce603fac6d3174ada49f6bddb132f32a9f15d490a22911ac602889ae43c34cdad6e145d334a47d5d694c5c7b2f360c5e15ed64a33324694fd095b197fb239c2c7c8dbbe2dc70e2058f92cef7a8cdb2b4d2a59415c01f46158b5bf3d94dd6dc71095874dc452f1b933c8c019147dc8377297c19eb8423298a5c91d2a30f3af094000e6d6d18a89ea2c7a6c53b411fa7157c9e423023c94be39288edad10fce8f7f6bfe728492aab7337e48310db01c5ab321b951eb5a6c933ddebfcdf8f222748cce3e3b83e6a52e280cd6a3dcf21864061546a092f0caa1c1873b10886895370353b56c15fb0165474fb7bd367e575e87195fbf6394a456f11e247bb8c0e949b5d107e9be1981f7b1981cf1fad64a179d5362b1cf87a02b6197956a12a153eff2209df20efb4e41dd5e19f95c327e9ac72ebf2656776c25885f90d096cbc2dda837caea541b0d4c160d2e7f4b25c450f22771660b68b589cfbe26ad8891f847e4f78eb8f272cdd53ae748183f67a7d44c5f63645c8f04f9d140f13445f9443d7ee1cc0dad1f776ed958a11fa4dec60a4a2258fae138956f29e593ec0c1ccb04dec3c68a7e656f93a4237d3cb3ba94bf1c9ff124747d9f0e0ccfe45fb3e29092143f0e438c0c00d329c5287a976fb4d869542336ca480155c8df035d1caeb785e2ca9b544d636cf5096d2a44c194eab7ee1bbb35a7140d81562dc06473cd224018cb52b2429eb3642d216e7912325376a214163cc3f21e9abce89841216ad80c4f51614968a925c51697d975fc159fd0539ffe671c39a6734177391b97afd704820abdcd9651db9cd605c01fb64591905c187e48287ca677475bf170ce00df86b228cadffc9f15460985282b7a0dabbeb99e74c34e07299a8f507f29ca6e0e31357525883d9edabf423e0f4313c030fb9d2e4d0aa6201fbe9de4080188a020f793ab82db992d3dcc7b07f47eac68c4bcb5f02c8ca33e36f2463c2604742530541073577fd81c357bdc44adcc90c4f762d92d8540805256d703671718d65017e6428c32b305dd95e686af25e27d58c72c82f6c4fca68ce39c2eef920c93fd0736c253a5c5fcd2c436da500760a9033930e22f1be010352bbd8621fa042bb120221ed45c76fa681c05b3768829626aebbb8a29c582da43eb3d890353d138b90e9f022524e258b688263dfc7fdc242f3536b36712356f8b728465a6e65c34ff1dc6c773299b6361120c6442878333bbedb8aad5c6c40572e33a8cdc657308a83641b711f2898fb10dc1cc10ec52e713150caede9f8c62b8fd0521f7a7dd38dd2b100658f37d5518e8802c3e3e325e6abad63cbac742e53b8845296005faff4287e9b3b3577d83e599b4000dc387f1ba1bca3f1fc6e9e2707feafa633f4ee4c9e6566ef0a14156be50e030dae0880416b7ecfcd5d009a651009192d72c5dd4ee7bf9a34130a8e2d8696bd79d483cf17ffbef99c5209641ab57faf5f54967697207d42ac679d7014749c6c7b4c683f5eeaa593b344597d2a9d017da1b38be12f50a18795823ef98d202face88805e77509e62c6d529d7208a5a9490635bf51b12a316e0393538dad79cc6ea2db16e94cd6c2660827e31cbfc6d2f3b95e9ac0a12fdbd6cfe7e2d27940223b90e0545ca7228422e04f2902dfd96366063c1ec4a68bbeff464f06ee77d8a62fafaa932f167b83664d3c890eed1865e1bab87cbc2ea62cce6604a86dffc5a08e0c8ab7a9a61ca7f5d0d3232ab6ae2a88f225539bce0a6915642f9a8aa54a800c210e2d78f1b1ab0fdf5789d04fe7ae181dfb5d1edaa49c172107c10db0a69a63cc946291597198490aa8291f37ef3f766cc352aaffcae44f0476d91bfa3e81d4ef9e9eba79e36793edb0b838b89930d9829ff129e8db2086d660a1321a599441e3ecc3d887a2080deb7ca2cdae8c5ad40cf9dcd19702fc412b616613d5bf65fbca207c7d0ddf8a209d2e6563dd0881efd0e1745cd6d3810fe3f659b41f5147a87750cb90990c4d0de4cc72a02f057515ef9cf53426b9a9df138d1845a2d9c534924b66dc44c0690fbb72f1b313f603e41a567ca88eba913572727c9ec26bc9140b8b22858a99fa2b871eff11feed8c07122dc2c4e2c4f9e3fdfe1e6dd9d485d8a25984c88ea56dc2e2412d498d9ad62aca309726d3486b073ebcb1b76e7e24b2a287725ff57e3ba15d7c35c40d5fb8f87e9ed4e243b7aeffecea6a065ce593384773855beec0492e6936859f99ad3b8c35a9853fc60b8a9020b8d2dbe792a0f9790b8e68379d9bfe81fa2f568d706c57bc565cda9b9bd3e196af89cb377142ba084a7b242f297e49de6bbe8fef71515623c16220ff8177094b9dc2036aa2ebe19556a8dab3e7faf99a91ba7c51334ddcacd3c70a43b6b20720bf3519c8a03ad44187facf6cfc0d0385ddce9d6cade78aa16e617ef977bec482fcd97b265457bb7ed68e5c12a52b95054918b5ac598088130abf4580557c34d76ab42a567ec1cc68520ff6866bc4c4baad77d665c73d6604342a82e95e540a029a545293ed3f5e06c6dd3e8b616cec5cdb0916f1af6da4388d83fb919ec7a492a6005a657720ae5530065bd3bc01275bf4632788a59958ca9ebcfd9864ea7838a3d5206d58d1c7e7fc6fc6662e98177370e541f03fc0a497858985bb7cd57dd56de1e17b89503483fd2713cadacc098a2a155029a785fb2e8a0631b1adc983dbfb43fe2d1a74c291b95cd61d13a616982d817236d7b6657839e07724b14ef63bbd7854f992486bce1b8150678ba2e92947b9789b1cd08f9b4bba207e6dc13ac4a5b858ff716b72aa1bedb32025b675653004fff298fd6cc04346e421deff83ebdafbd94d1fadd6a33d269f30547aecbb03f4574fc911590a2a2418d1da4e381ebffd11b27b43fe2ffab4fed57e29328ee7e04af65ee991e7722e2c3ae70ffcbbc4c6ef02420992fcc52a506d65a534f83ff2e3af213422cdcae8505f4f2e316d35b4d5953450e8b03577d0e71a0f5e0e90523a8aa65165c2b6d3e8ee69cb014b264a93527b719cd40ce2677ebbe150cdb970c1e6b30aa7f4cd1c232e55a416d436fbf099f26833448f0ee1dafe91f8dcb06be28000674de3c9c62d40e0c544ec26cc8b5280a2eb8d3709ea024defa3e52549301cadc878fd01b1151e9a94071b2ae00fd7da5f101d031af9aa16903a866fafd47281a9022dadbe8e3afae653535429f2f58b52f6fdfe698976b0dd6444dc6ee524c863e67397f57df3fd9f161685000fa14b2e91454f4f7393205485fe5a97631b55f72343ddb78b9350cdf955c53647a290da4c59fe0745f9adb622cb50e5ed6aad64f17cb14cc42d46f8a197c96c9b929487063f9514166600fa435e9ba7129c61169a77aee3cf578f67c9d9904610b42adf05b5d251ade1f85fe33574a6d1791805a9126dcccb7a56a680ab0facdd25054edb37a1678fc66356678675f8f23185c61ced9273ef6ccb5bc748333f1efbfb3a8cbe78d73c74da5af6651b1116d5140c09f5f4ef8dfef703431a7c866812157cb6c1002fa27f766e61150cf75473826563c78dd2a1d064e91e5174eb260c802becf4d72f50337c99b8624c67a1b07bef89b0de7cba27b6b8267550d363e8d8dcdc37ee2253c4168ebf79f969e563c750484714389f01cf33fd14ef7f0a1970c8372b8813d7e98b7f05a570aad231f8bac40ff10dd79be29d364899bd3cd8b0249666a0b711f2f357c5536759058d2e3b52e6e28693a412e00d26673f07c7be1ca5c366e3fbbc4d5d3d0aec221859c50ab6de36f717661eb87a0cf8a05edcfe9ebfd5a131096c2802b425b02a80838df72975aef53ddd36311e5ba0fc7421804b0a7fabff2f771dd643b169c63689f1f322f645f4981c13f3f7fa60b59d29da2a4972d26e86f684ba35a98ba24bb493e6c46dd3f93bf3f1c0b72ba4ad9ec772d174d4d272bf550250fa50aae57b1272e2c4a6939abd56e088138871ed9a94b6b6e062b57cb13cda4479b48ae995586cf0e040d59fabea51135c842b46a444a3807e3401f448a3e1af0c07b202dc52de9fd57386cab73cbbd5daca9fbd203f41ea67c9e05b080cd2c30dc4b91c9c448db7577fb537b690cea03934a34d1f5d447dca6370be5788e2b135de9896bc768a183dc92d7b6ccc134d35457b3cfec21e5813d68986bcd1beeb3240b0ed6d7ff6d2dbcba2b5354a664db6262176c0ae61cffaff3035b938eb1303872d0466301777d8a369e6ab1c5f7b3e2ef7fbc2161a3d179c92fb4075621c428ae7ea34c97fd66b623d1a4b1d17ae0cc96a986ee78d7b1f933d1435a7e63feb120aa5202c30027d7f69b7f6a64977b5ba467eed715e6e2bbfd7c82c09305f6a7591d770ea084970e6f0fb78ec73806b31fd197c65cd51440b5994c09b6f1ea670992aaf42ad4c028db829042f256a43d3408c7bed0a22a2e423d45f87d5cda29d302f2beb8e12af4149fa4b2cacd8db0384da746d7c26571c54e831e2b8bbe6c4f5d02a237389e248441f687718f6712a794f649d4226d18b7265a80aba732a0cac25ad7fb265034139f333db5d3bfaf45704157a91e6f73713beb0822846befb31197064aafa61e24f2e536d460f3b0172c82a136b2005e1bb16166aa33ca55bedbabb4dc6081dbfa0742578e7680692ce3fc83c096d1ae4c8c714c6eebeac9e4e4878e23579fe905a94f934e4e8f57d03648db7146ff621a88dfcc72f87f9472fea46641e832f59547780c0c50a3f300f2bc70b393600d1e84022fa22b29d27daf5c7b9b9102f1dba0ba13e08dc73e1709330564e5f461a3c7d7132603fad24ef0a1081e1387d86fa2ef531db4c9be7ac86890ccb9cb21f6db6d51a2264fdd67f1eeafa79ad13c67c11b410def89653845ef93ab6218f28dbe8c4ffed4c24578e85156b8f979d0c839c9c30a80049bb0b8693e977570f77964d3d540b171da9eebf0ffdbe14389ced716a3e16f614fbf64f1c08a747060ec35cad6d7e16302e0bc4970d3b604a5aca7fb8801249059f394e7f7b657c9cc7d5f5e6e50980b70af352bab8ee69df801209681e135584b839fd1ece8570b516642d1b30ebb84f7ffbdf894f1fb856b664e37933345b41c2f0d5d7a699050562095bb2cba83f2da662d2e6f0704ba55d6145d1e70c085eec5a78bab3acebe84cde17b14fb6b9878ba38ecb869d25eb6b3ea50fdc79ee83c00c2355b9584527405a903821b5463ff9ffe3f519662b3aa8b4726e493aa07c1e0f7cd1390dd164786d33c437d6fd4dd2ba7e8fccc1f56eebc0a2a8233234ed452969ace8af3bbb38de1e807010bf836e846cfe17407f7335e35d8829e8c40a3a66e3eafda859e8f0f7b4789bc529d8988fbab96d8f41c0ef9d4db2ca5218f1b5ea8fc5d262f62a6a3f5fb70669580b704fd32dfe201f6b4c0568b91744e63c4e1385fe222f7ed99f119793131ef0b4e4414bc3cdc9a7e0880e21970dc9dd442ca9df162368ec87dd05c5a4dcb7b3fc82d147a78f0ddb077cab0daf7965b6a75fadd667ac781ca34964034d230ac0188ecba2ed46edaf9f8bebd54ac24c058a4bc13b4a8a6530c56d337154158650a91186965dbc97f9793364e5a5827cba8633f660d641110d35bfc4e5175952d43dacaff3a558b10df5f952240783f41c717f8e045ecd6401c8bb8834541c9e3a8d0a5bde90a4488dd00436f724cfab23672611eba149e18a81c0bee65751b73f9127d66d25c8ea885802a427c3a591551e81e4efa38d624b88289e954f5651c68b35b6128a4999e865cd66b058ce0cd4b74c6a68746ec8e335998dd1ea89f68acb5ec70bc5a43c916ed2c840ed1cbf4986bb20db24646e2887b099101c08e6e8f241bff91073d28cd8a04c570dd8e5eb746532faf69df196e4a0164f4676bb2fa46881821714e92b43f7759dd824afae00cc07de22cfeaca3e6bcdd939300bd75660da7ee7d6fc75b336fa47996c24e7c7b2157718d026ca3b14f4d6d626f6b3f31ece44ee6c02531261996c25edf2c0594797af75b1510f047dd1f782efc7c8cd1cf2149195658598f65da47610c2b4f45c09ad71d5cf055f17e47d31facba5cceb143b8f12263d16e8e24ce85b3b04eb4bfa0582534a97d96d076b9f720751e6aee1c02e4fe37edc97b4404c4b6a37bec831b474aab02b0c930998111823de49a7b0c2d725eac88e8fe5dae18bd8bc3a969faf6f9236778c27ff6bcee0f5096beca8d9d0ab36437417b92f2f1e3089e8aa929edb0b1a91ab38783632d54a4457f2abf28c65f44f23761d6c98138a45967ed0bc0527c5309398223464cfb903bd3be0d4b87090785c5f82e8483c3cdb1dd49db49c2d5a158aa6b4b0406f6f532ec0197c6274a5de09dcbfbc033d949bad58c7c0471cc4e240e86ff715829b6d2baaf8298994ff0a7712bc1240c9445132ba5a141cb04a3ab4bd5aca8e46b571333966beff88dd86c7260ff875da34040d0ee9b4e08075ff7d9eba6878b1b24147c14a7e342c0ea52b0cd3f44c6a56a43cd0485ef75e01b1eb833928cb9af3afb3d69cbe7cfe3da5f02125af6a845ad9c5b2dfb9a4f34a6de3ddd055dc638a0611181176275438efc5cdacfac495300ed7cd31c539b2a4a743d4d531a3ee678fe1d87514890afbbe8a4416cc2ad99c7b840b4017b49c8243bbbf4397894f75382e203119cfbcca177509f39de27c842083c7537c15ab67a40fb1f2ffb4846386c271446b9a2da19c4a307bb92f0ca1cd2d44beb6cb25f0269dead757e7ba3651658c4055fbc1fe2d588f667b835dfe78ff053503d46df077754ce2c4680cf73d30af88cc49e49d31701223b8e017e2a3153e01a941171ff1dee0c36faecdb0f428c9100903737c00eca6d50c197efa6a268f364f3c9651569e11e7f495357bb879a0925894d5d3bfdfd506d28e9d60d617728a523f8cf1fae7cd156ebe5eef60ae5c165c92ec084fd1c590461cc3ca91aaaa85e8ad6fbbc0e3e1e095e8363b250acd0dad3c32237d939de95456ae4b14b5b8eb456b87113220dce7288726050f04468d8940c93a29c864ab457c935258b1ea645166b99089e27c9f08dfd83849f8cc1391ef68b9f8ad13a213d3b39fbe54892e74f41b3fbd9eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
