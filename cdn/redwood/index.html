<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1ba84dcb18bf9c02a39ac3e98a3191c469a532678181d984b95d33e4c11ed09d7206165074cebcde37f2761afd0e8e321d19db684da1801b2e0bc1223c143f26f9702c55c05bd81de24f34e1f3c9d855ae92b0bc4aa27369bb8cd422a1d74c5fe8cfd15f9bd18a291dfc6d3cfb5ee3e04d3fbf792b3f777a70b8882fc675ac5bfc73046632d2fe45122166cdfda9bb7eab6b9a3c1c4ce59af4d43a792443a9ba6e2733d98421d0f065e1f70ecd935fed78b1a8ee3f9c524b4d85170fca9aeebb7ae7adbd28d253cd2259e39723f9ccc57edc5ac086c030e675cc3db5734c6dd007b68dfadf5a5baf70488f14a78bc8408439deacd504e2541c8f98e240a571611e18d1dd21e76eab32853232281139d152f085af2eeb5ba80f03a3befc4ea14f833883e8eb8016deb830b1590e3b56ddcc6c29b864e5bf3cdc5ede117916f03ddc37c656ce49a1d405a65d2f47770db9862b865791b304d1660e7f0ac664fcf617e34ff69178046817ec1a73862b7a9e22063c78de81644b86a67b7223d3690ab74c72b1eb1fcc41cc2b945325f7f15ead526d22e2b5c018f89bd537e383a38265cf6556126269b9173f55044892195d6fa3dc8169a4777e5a46dcff9a2682614a8355c213a9da92e49d2d8ee1150b6fe9e86a78bc276cee450a33dd8895dc8ce1dc177cdbe8ba7aac88ec023e8cb11454f50095769372b59fcbc7d7a51bd54046b4d79e7b1aa180c83a0e7027a2b25bbaff6d55838875fa9a206e5d76a147a5c7b7ee7011fd30a0342a62c80f8589e444671d664d50111cecf51abaa1893fa7b96387c76ec59480b2e2d8f56012c0b007ef6c93e3ad9f1e6d35a29c65f3b7a6f441f501be049ef8fa70cb4a95102a9240b2d5160c5b1283356eaeac263107aa40e0de88c91d0072ef4778708a412445bd92079a43ed44db8f04e6c173eb657eedd775f71f7ab36fcb4e2f8a3254f6ce2bfbfb188afd443596e326596196d9972a0bcb70368af71276e7a426b8745b935c48080b58fb77683699e84de307ee83afc3d447c61c9c568718b72d7a2b0ab32c817efa618a0ad738081260220b0daacca88d5b1f7b12de854d4e966f69345b1c65ada9e66bc09a4626464663ab1b2e6b4f4a17385b3d7119db404c5c0b84a670cfad90be8515ff5d52d9cf604f6ddd2cd987151e8d47249a388881262387091928203c1975ff0d2c8d94bcb37772bc565a5811a88d59129bf3f467ca1d24db1190aa4112714bd43df29f4435e572cb66c52be81c467b5b7f518790cfee47431870bfe0a355618033019d077ad86d64435ea6efafd9b98ea5bc85b38e4d14c3645a77a97791401a6819fdfe663476f83fbdcc8b59d8514f95fc884fbfe52cbaab1252dc4bcff99164b9ae43a9d77cdee2bfc370cee6245a53c588be8717d19f756bc8e0e63a50c1a158d38dee1477928a212a7115360bcac7041d22caac48855b70e988b79daeb3d3b067e0986cd996c62e9e5f16f47a94d1c822bcb2fb9b2c9015653a8f1e6dd53f674183e72b1d7c2248eb8c31d3df0cfd175997a796e20fac5eb93d12cfc4eee6b498495f7f65fda77c6f6858d0592c1f12e5989143060d96fa35cb40d74adb9bfac144422b9f828126148d19c2dd3d11409e0a919a98b3fa142e7523ac06393f4e79a7f8705f18de2e6e8378c54f06548a1fbd7413e3152dd205c4e5d0b0e0a9e2a5e307c79db27bc4f5522011f88a5f6fd10de794bec117141362769eb213607f1e0da650f096551d82851d4cac93238b8bdc2f7046a772ba693568ff553d5b7dc6e6581377d39a07859e9d9f350a9dfac110aef8bf69318db7ff3cd9fc941c961071ba070bd606f586c3fd1f6887275998f2441620b46526704b2307fc849a005bdc962b7dad926bf6570c66802e83b678925552a2bb29e003c7492012c4fec1c577df7773ac15873bb3176dcf94ee52781e610db9aa8742d4fac72057b84031d8c90b44a61ed92ec4899f03c36f16ae0e641b94e66b00dd37c39537be9bf4ff050e348c926fb72136894173cacbd38392d3a9d8734123180bd93a8b5e09cf473b1e1672d3d5f598fbca70f02a5a6ae49b57d815abab320001e1aedacd0ac313c2630ea96c5276649a210cc45d8dddd38a6c0f15c65ae7bec9b27c25b54c1ff74d03adb90c77c858e15968de5ed72d1ea65b2440e05fcd4bc93142b2f0a94c0669c77b41a70b5d48bd5956c3001fd7f548015a2fde11d798b19102389c8f38c74a62d6a9851c8f20ef60695d0cd82cb87a9f2f4ec02affff6462b16853aa88356804ffab4c18e4bcd0409e4b92abdf54b620e070d579e7fc9ea265807f72eb4532d6d968c548a0f52c4c4bd68fdf02919b3f691750fb4ac01c4f71c79ae27bc922c700c3ea52f72665a75c0034e2d71c3b872fe439e176916dd8a495969ddac79ff7799401ab8ccfe8a20658a58b0975dc624f3ebdbf63ce78fcf21cc049ecc3404ae80206acabbd2614f54378f82a2ddedb3a4baaa1f1f9768462cbc84d5690400c747707f1693bfd192f0f5d8931a044567051fe71681649d0480d310f7b384f517e834ba42abb3fe21b47973b6e17f06bebc4c63dec75fc6dd11791c030df3eec9ffcec3798dfecdb0c055ed91162a0428ffe8e8a5db15ae10280876089fff11bd4c30092664abfa927ba8afd07eb74d0c5f0c972ccd445c547a65fb363e1ef754fe7b43221a0a9fb9f766900a686be1112bfd93eceb2cc3bdb39cd743a8859ccb9629c89d02e1ea11bcdc8903f8bc44f986e17b0e80abe431c67f1f84120113f5f2b14450eaffd56f468250fd6f59de35269aeca69f9ddc9fb50aaba4513a30d61ac0cc2ff96ccca3df11507134667ad0530a9e878a0366ece941426f514be56336c26d9632e89360b9fbe44bac3740612f04ce03b9788e700687807b730e7f0be00cb46ea5c701a100a18dc63d810aa013bed2762d6ee0c7d73093f7a755bdde816791fbd08561f1475c5dae715b3d5da896a410e1120e0915e89e77fc078ef281c096f59757e5b849e9d164ef702d8aa36f16311a042e0b341085713213bef59665a9fc689013ed7c03129892a9f5f4ef0aa7a6a876bad771ca809fda634d14d99336568c3a4bbddbccd14bf6a8badf0a40b8ac59ea04eb15b0b9d94328d77782affb250879d7b0608e7759c1c646c863081def86300c7d9ddb29837ee3255fef6bf7b0e2b248a7d203567e8451288a88ac7c0dde4f411e766ed17a2b8431aa0bf16def89ffdb6a9ba77881a382e9c69bdeafa3cefaa37b775f2f14106fefb26ea0147e1fa6361dc8a5572a4e16716baf219c631683a1ad6801d70204e232a851647df345e673d179f99bb7c53a94469a63a8b6b7dba636eafb7e0f0b86764f650389a78d9d1a4b49ae116eea32089c7d3c4ffb708b058186776e0939f02524de45b7be95c669193aa684b9b036b30ac6ed303ecabef053c2bcb0f43e091eceeacd8a8ac3e99ddfaa035940bddd6e4ec97d6babe83a3c6b6ce54dcb57e9fa090c4f3dc692243b3dc5559e269816f9b2df5e5872c9fdd712be5a8e28b5312780a6476c2f94c466ce85aa5d6673b4266b53a637409c513021245a27474007e0dce54bc03aa70ca705665e5fcdd97ae4b60bf25f2a55f196f38dea6f126d457b36825d9cff858729fa63b6d28a72e7f98e41f030f1668e54d0ffcb36237c2fb945db6641be866dc0795a28d4f837e6d35c7d77eb626c62e8e09c24c080709299f139a47411cb988403d16234b1d057c8c87665867da75a001a1496d7e1529b49c9cc1bcf77954fb72345edbbd6e0e934a5a82e01eb7853eae5c263096765bba9198148479add764f17322ec7c8c548e47cc1b494c0c597998500410741336d6d6fbf1061fc8c1e6f0c53b1a550e3cd6ace9805088f99fb1d46e7b397e75da88468a069f96778fd296f34b3645536e259afe5d65b94d5afe6579bf9779408ee2121da1ba6d12d64d058afcc3f6ef7ae5e144dbd1748cc0526b7b9e88021fab73d88fddbcc2160f2e9a85c08d7e6900d3d1eb9f90924952f6d97662001a165893bf02f7d6e77a3cb8b5fc9ccc8437b4697332b970dab2174b271b4549bf79a9760fa9b1c8556ea7a1ad91a0c850f61b2df997f0a29e0f7f24f4ad9206bf9fe830f6ff19fe6febc9537be269394fc8cadb2e2ad361bb434fdfcbe92a57a2b32474d7238492bc7e79ff3c0105fadfd65f1c74bd65d189e2e6034e3eb876ed7b1ec43080fbe5dc1c7406eab8c798da3c2d0b118b1ce6ba4343fcfc638b96212f26699c538ca1c9da654757ab3e3be69431101dac358ff483cacd53257089366507f0342f06e1b74d3ee8182a32b5fd7e3d74a004f25c9bc4b47c29b6744e75f71a3e50f8701af6da016e20e68cac8d88c548e047ff238877fed8247d0cc6d1ea34317af64237cffcdeb2b3dcaf1280733b02454c00d4feaddc6dfa485405861c5430900b1036eda981c1ec47362fc8c5d5cab93e3d7ab75da05dc7cf0495b6b61a449e8e9a2810dfc21a31876c02fb1f6de316bc0cab37eab30c1d40bfeaf5c2c52364db380fdcaa03a4d5520866a6b167a2e076939b8e1c898e84c5cf831184238c23db2f3bf07e75ed8240649bfaec0b9ce7f3bcfc3b73145812351e5a55d015c4aa25feeda09b0fcbe224fbc333e741a9ac439e21a7c232f27f65bd6cb8791cda1611b7f0564cdcbddbae235a5c47c8ab148e3bff87c794fff84734a241c89d556bb7144e1c93548059ef9b1306650dfaf70d8e410186b7d68b522b333323ffb09c4141fb9ef4f7bfb49852d530e15f53e521c5c2ed0731a5509c183d7d16a41ed1f1b36e892ed7c9dc66b68dc52ac4408083ac5b1016a5e189ae7b211b0c33f5a1019c4116a3cf5e864becdabeeabe37e4b3842ac934c9a7f17f16f1f5f6fcf131830184dd3a4b0a929822f2096b1b9d56bdc20509f199474cc006bd99583ba896aca1af7da1233bbe4a70171b4c3c4a9c5ec9d3d883c116ff6dd9400c5b7469d2a8123e4edcc4a0f9390ca5d13c783ab764715ce9c70f9b51d31676480fb74de2bc1234817b8931f7ce03eea1729af0c222e44fb54abafcd51f79e60b446db70c4e4bf1721b795428fe269759903ae0274995433e8f5d155ee89f41b53c7fe3d5c674e1b38eb2d092acc9ac2a633eafd2cae016be8f58ffb627644466738b3d8164f47e1b3a262ca229789ee085dc5156da1e60029a6d0b4098151bb8f5bd5a1325932b11c4d3ecb2fd27166dc82379bf9f3eccc5719b1ceed16667229ca8a782608e278094f36da2a3be523d5f2afbdf9b4f90afbb5c5fe0a45239356cee83adaaffa8059e58eb5adf6fbeb7f123fc6e84ec1bd32a6b17558b21b56a23b62fd06a74811d1a72d19ea5f5ec3d06cc35af3b229923c80ef58af740df20c0a2280cdb703a0d8f67dfc13b1e278dbc5323daf7d5b60d9b1fcd7e3fafb80be89176874904fe35dfdd998f8914623eaf8696fb3e0d5ed3d62b0d98fbc334abfa8b8668625238bdb61ea2791b7b3412c92f7b6c2ddbb2699a05b76a05d219aee467e3bddcef76a79f289835db28cff81abe28e3609979e91c7b733bb7729761e6055fd01e5963a96d3140cc87f640f770c5f038a945c4ae2b75b2163a8897dcf72ee5b597348c71a6bc97a3f91ea7a7c0124d9d6a80547da3e599016758050371671e3e9aca207a853205611a81c9f6d0bd66dcc384fc2273876b546e392490ace75c0c03b0cb617c1455020f0386ee3020b33cd94419d939ef48e5889026562187710556a7127c38cd137a8e5bdcc781547575836715474b6ebfefd9d76ab6f19565eae42b265ab99f024223c6807b0029df27af5cf3970e59b10542b485b8e24f1e5d162f7ed98c9e8e59c6935c744c6e25caccfa85fbe53c69315628b90c6cc86908da8c30f70a03745f7279ba95cb072ddea47e898641a2f75bb2ba037450c3d791a81d1c2462ce244e08b1eae0a511512b095b61e27b46904d08ed204b99db8f38181034508304a18ad26660cf6921a034f56b5b4d31935142f8c82f4aebd4afa12b550a5acca80bdf6db45051e375a05876940ccaf3fcd2442b86eeb5a4721ac10460eae47001152241a999fb5992c70d80ea5df6be469bcb8f8acc939e87b8dae1badc5195f5b715dc2d2937ab8795b58a191cae1f9b1bae5c24225ae72f47a8ca24739b199629a2e627eecf1e5b2c483a5db629039e56cc1a50ba7fceb339e86dc2ff7e6e40940d21393e52408c12bbbad838e712a5d34d47e472411ec0b3a44571395fe97790c497fc8bcfb0473925bbcd3a261188739ce6b14f6ac013883f41fe092349ff43d1772f3d21387d0d348ab85cd7d57173e597b84d6e1dc4f4ece6e9ac68c62d2a236c9a8b9fa3d7cb3b16838b95aa0ebd671bb5f161ec4bfadf882da7775acd0272d3fb2ad0c09321d2e3281a8a4741fa294c81893eadbba9e3bae356f64c5e2b0b6c2ab34f99f576d060084b96bb572cdb5d61e254818a239c1daf994bc0e75c847d502b6f91b62aab38b0ad88e4b41fd76de38b5f1fa67fd186d1554ac5e1324b8c6c294e68952cbd1c0bf5499b809f41a88f1b8bcab0481f5a126ab0b5ceb273aa22d1f90f9d98fbdca7dbc28745cc8fde3cf05d41940329f981aca51e2a47b04de8bf222050452319d6e841d8a65fed7cb0276795faaf95df23a09470c82d89cca26edd44c4c643efebc04d5ddda815e8a4531c75f560c12b324e80970893d6a10df036f6a5dc51a441842a65a65c126d15dd19552826137eca01a2a77c73caa45837cd944e305b5242e792c27a4c0260cf27fa6873ac7dabf6db7a0751f54cec9826c7bb04385ab0b881906160648756fad49d8b1bbb10f07c6205311ce8b3d36eb2159c0cf428186f9d26fff72f43f0b91adce47f88532f758be20e523682ec55807f3bfb5a78d53076544c46d4c1641cdc4d539d5746ac0c3a596a90c3a1a22dd6cdbaa4dd4eb7bd10fed0fa3c01ff09483329dfc4565b908540edbeda4a719b302415fe050d876029e297d8f6e98e1bbccf07cfcb625721b20955956910fedfa928c1ab371512c5fe23005d7167e3d27d7fc246266a22c89cbb99bcea44adb73f6c81aec77d0ebfdff5a05b19104e77024b415373aacd2d6b683cd95e38f1784ff861926849bffcc80d9c9f9e2114a0e9b5b6306ec5e530bf817b63b11339b3d34433ef14b8d612e48e72b3f4b1004dca5a479a0a280f64ad0139b9cf6a8899c4c63df244e497d8eb86ddfac8671052a2a121806b07d4ccc12ea29b1b95cde53e6309950fe2330e949db02efd60eefdc4ab8204b8f6b7aa4a94817761972b446426b7ca1127d746cfe6b3f929c7a59e34eac399040cd89bf46712e125d8a48e21c71db410ecd9b2c3f35811a68cc8f8d75c393fda53476283da9bd5d6214deb48bac1c50a218af924c52d848844ac5151dd53dbce9edc0aa85f73d2ecf26e404f76fdba35f50c13359d2f4e430bdc4188cc0d5304c43087fdc0b3118b278958e6b5449858b89a3132cc0f5f60ead9c3c3cc112b7061b7cbf8ae49346c3642b9b60d4ec97f5f009178369c43c13661d68f04083cca1da33b52f736d4b1a16808ecf1d42f57ac5d4ca4ef2c3fa2afca8d70074ab92fcf9149b0bad110ef9558bcf3eb94647f5045f7277eb244e30ab33a59b0d016c2b291247fb75b4e09e9cc2d727e8d590d306c96cef75b951919ceb6a0fad81fd9c78b9da4af947a0c98e1eb344c2f77865d678e108b6493e70336307da51de60e4c582b46df614e56f54bdbe8db70e7d046fff37a9d883f8f7307956af8fea53e5cf357ec76fa0a94c95d96d156b5d84ac089cf10b30aadf6d06d3011cdde147ec4109a521c712cc237664162ade21e2b5b0b67bebcace87a1c3b7c4fa0fb2d74496287109fdf63f509b83fbdaed157e951ccc421a972ee4c2147702aaa907c9720c8190f631273ff75f541a11ab474472d9bab8a9bb6ea9a8ecec467829148924bcb46a5b0d640243b031fef5232f6b629187fdc7168f1081ce2acaaaf7053afc23e04005329919464cb7d85bfbc16f538a340d63b71e14bba04185038a13904df20844c9024eadec3d213884d88255d2aacacf01a2968cd4f6e0608f599cfdc5bab718c5acd38a4835b2d4118c26715427cfd9a603c4c8f06af2c462b941d405dbbcc4c876f5fe9de7e2f795a9f357a3361d10c59cd9679e94279e604efc40de7b8f408879c802c76b074615061d1f77bfc2506b4f7bd5bedb37e7fb966a69226eab6073a07542263e06e633a6263243b33c377079325a3d2b4e12152ba43779a9ca53aaa4b32fc2e2a8b5f5e4309327dd56683d6ae081ef170bd2e4faa8acf0485423137829a269807d1388ade6c907505911418882674944484c586b670d8de4349b8fbce206af12a165695bd727b773dbca919d98250379c7f9e24b39c80054f1722f98db41de15a2bff2535b4b1bf8d738112bb429ac3cd0b7be53ea9d5974654f3b9f441d0766e3e65745a8f807bb99240373d052fc037dfca39d6677ffd0b448b1b091f44c5a976c451bafba75ac22a25a4771043a71768b7907127194dd829814bd87cfd61b078ad78f17f239638db8fb6ed455fe770810c3cd80a383c9e690c0bbc9877fe64938accc008b06b841058f0e9d8b180d090917dfaedc0ba2edcc54a0c7dc6db51e2034d4ae79448524378d3982575ed5db22e36b1999bf51ef9cc9a35563a9d34ebfff5c840e26d08be97066a2b7cdcc59d26cb4c384b673ae27814563108846f2330ee76822d5bd2abef0863e475fd203f4fb21f3d4d3d60c4075c958bf9da82bad3aed291ce856a7a25274cfac3a9f527ff6a54f874a5de2b8fc35f9c1d96dcda99675d52d2999c347f26b63ea04d076af2116270e21bbcee9d6c655a898fb697cd54752776f1d32798d20101764613d2763630fa9ddf931693bca2389455b7fae88102e59882f2a60c0fd5a239f50e18d1b5392fd1bf5a725d9e3fc0747368358292a4730e20db9872fdf704757b9d485b600ff99942be7ad8fdbcb89f6cb98cdcafcc769211887f945cd686c9f9106fd16b20aff081834664245696af0ac9071be4a7daaee24a99122268586ec4f955b58f484a35d2224987b00a22ef2756eaaaf4f2849a317f5b48bc65b060cfc6ada8edbef55a028833fdfbd31a9505bb85cadae3d4c1d6c2dfabdc901c268e2cc838ff5dca79f5b0f1947cda491916f9b2260cf8dd4942b3b4c8f5b4120f4ffbb18da126fd6119d4dc4804dcf0853d99b4d153a147a2624eb5fd5d3ca3cc292dd15775b6faac91bbe1ed17fa4bef100264f50ead4ed27bc128f41586dcf781760ca978238889f561a494d937ff819e9e05e524e67c4961c9663b3de022eca6106fa6f4dd5b171c8b7a4d4e0ca43b2ba557c7421407539faf067269c1e84a3988d2b44a2b8e5a439f2d51fefd7f6ee7621562c857eaf1d6a8d9444b2baf48a568250633c2928f14ae6917a34710e9fd10dda22b51976f06861afd446a6ffb5ed7b214b645975ac16aac07d6a463892c7117d6eb57ae4d00e78da90e0abe747b6e1d893f6f58f4039342b05b020b7417ff4117aaf4eec1006e308b54a5dda64b3c5dd63e9b5ccc5c09bd8ead0110a8b43853c6ee35d298cee005e8923cb07add6695334be74a6de0ba2fbb99ce6b01aba6078b27ad7104c6eb435a627a156275224b1e1c4102e8825618179ab1ee4b301f347bb3bc2125176d9e9df3f6758dc7d4e85d565cd8c299b9da1be903e7cc6b0a3cf46a1e57bc9a0bf4156fa761d8e5441b36b8ccfe4c4dd6fed1155593f787dcd6d7d0a05f25b70b8d25ad984755fece2df6703cca3346e5c3bef9d05aa4fd87a89f66cce407ca7a535964366ce385917dc8a36136840f6c9ddbc1cdc1626c1ecac7e18437af48d5230911c42473d3d8263f9db83de6fe6bc5950a286687e7368aaa4f633dc808dbc10aa57039452eb1093ecfee460c1f13cf39bdd08d1616734b8c332911ddb28827af4b9982b402f7eef9160b859c14e316f249aae281a1125445f398102b3785367a21267bf1937fbb60b818e4a1bab3541d2bc158f7b37a31524ae7a9565f592d7dd38f2ef9173c6a0e9d9c6db170232c199bac06f15ea646fc77ee20643793c5ad8411ae044768fac2736dd0ae364e0cb0cbd6f7613cb3e2f665964afe1b8ce29daa668486a5c68398b9660452d8e98b27cfce85b238dca97228ea5adc1755dc716918f0cb0e42ee36e7d6dd97dce1ffedaa97bf7b97e5f0d6ed52b035b52e2904e98c5b21694982e6a364736976a9eb1069447e16835e9add59a246ecb87bbc86b75f77914af6fcf9f26abbbd193bd5067b2d6d1ebcc44f246bf00037c0e87b9df949990c2fe3876009819e0eb502c68abe7266ba408506dcdeb23d77b2fffc87ae0070ec65d40339d0d55b2b81722292d6f2fa441d5585112128610a417f758dac04458e01423f03de38ef7dd1e57f89cbbe5c5466da0c7373b80629939ee225380abbb5acc1787f0ff36d59f46e0b86d3f29bd5a46cfda11d134d9496856f0c86eb1fe5d7916bd9806e1291a77e337cf9912e398f940c1f3233cca053443b123a3386d6d99d94bca14a3d7e1f1667d32d5551968a4d25ec2dfd41a3446f2a8fe60fb23b4504ddb75f06af45a78e71dc8ef0141f93656c83da40bdb8515fc998f8d741f1701f94cb05d0170f1123a36ee758d7c98d4171636de00fa8dbfa7c49f1f3bbf624171027e9fdc2485565f53672a39424f6b1158a7ccc9540edc0ec918993f74ede2adb2bfa2ed0cc2efa35b0a2b49b675801dbbcaabd34f6d2927b7fab059d72d3b2c336090a3b4ad6ac046f253a6b49cf5408fbdaac68fbe047cdf1a3b56f5cd22ff0ec3e3964103cddb12c71d3dfec607c1a972c805a1c5733d990a71b81d7d20bf4163c1230449242f92da414ff9b9540c77263ff5b227cefb52612257c859ec855196ea9e95fd3458de873440183fb0191d75dd02ea8e8e6a2b6b6ea8dc5800d29b1589c83153b35ca23e5b8987a4cdadc897bd7f2cf437e2ea69a2a9e52da498039c7657f86e5a06ecdc5a5242ce4041185c32d97d7e050820144c28b57e69e957688d152cc6ac6e4fe8a06cdb6973b1646f4090cf27223d17443a38734a7ae2bd66c6f7830aeaedd076389544bc4f5825fd4b226d1f08308f276deb713a7e682663809ea8e5c5faffc150071be97c970073c860d31b05083f24f245df32737e23a23153e94a105238d0f3171f5d8b7caa02454efcbd7bee8060966817660afde515b41abde865cba4e10ee98d78e7b135b7d6bf1562a49605bab37eca534dfc6575656050c4a1e052c5611c397b7c7baedfa8a2a37d2fb3ddd3b9c7dad18c8cce725888752501e2decaf2064f7547d8ed92529f7fef52299e7fe00ae0e4e7b31a1bed13ac5563843fe796d39811bb29bd2c0926896c35932f32186d01e8b5517094ac1e1e1b1f8b4584d21731025ae70daa632dd463149bc18b57942ca00844bead9ac7dcd7ef8dc85758479b98792d764f22f19cde4c1f7a43c80ad41c6bc80d0d58b3398f197432611c80642fc074f63712bd0aabd4b6e637ae1899186d1a824e369655930b29a3e125107d6ccf37beb1ea536c1221cab988dd127439e17dd052e39d7252c815f9ab61d3aab43d70656ea97b3e92a53e9d27817e46bdee5472b4d66fbdcda51fa42232a56a3676fd201dfbacdc3bff0394f4e7824c88e6ea36afe30337f8d22bcba32630202212dffc9edbd8510c9aef19b0ecdd3fb08e635794e181a40669eadf08681eec68f2dd62d698c519bee80ec01cb425c1e9578170d51ef19ef944f427cbf5083049bdb720cb170fe5bc1c15faf7ca3efe690b0294194d83a1789788f8ab80f8b9e72aecf077011cc8f43d1aca2d98043e2e3e7c30ed2d7e84496ab15a654810ac09f33f347adc2821e21d5031bb1b641c0e7c52bcadc5ef41bd563117320c20b57d5627f6aeab7065e1a1742a58b8694292fa5c9a19532126b59fe34613b70f2507b3e6271aa594d5db4d5d5f65b0dc11f2aabe15891432e95af2984574e1d67524b7a407c2cb9a1b48ae0f4564abd381af13df8dfaddd284c0de1e45f73f4c3acb478e3df558e3ceb1f6a6dde945500d8f9b702ebafb12e147de9c8ac989da1ad82e22eae9686e5ccd2809a98d84f7d64bfac0a1ef5e956e1ec4d8a756bb1bee6040957d72819f5b3dd5443407741478234e5bc99a71eb44f2a853c53d4533c43a0a0ad036e75a0b68515dffbb84d8f61e32b70020dfcb20f2e8807a8bf1d369119abcf21a16385846c744d7af40656f5aac9c58e6ecd65fdf44da5bec8767edb13e5ed8f48524175c929dacf0e88ca7e0f7703e6b88db65e08aa5a2ea4d6ea6d4f02d095837b17e894efe0935bdcd49398bf523d7a35e23b9c919a8cd0c908569236c8e8dfde3396ffdd6bbbdea988819895f1e8461751f6d9626666c82eeae8e82238c20d0d15dfcff6222e6cd7b60acc81fc90569209c26f31bc3c35996f3cce4869c7b9a54816710d4c5887f7aecce2710a4f7cbb141a3c5923cb47ffd2242379a52abdb7a0308c0163a40ea46016ecb2dadd6a425b7fbcc85998b51ab718713a991116544b900c02ae325d58f3529fe4f692a5f8a5fc83e8c349bca9331325e690d2a03564bf3c86d3eef01d0c88abb55377ef74cfcda6b092924ef4fc676dce7401d48f58af8690de6afadc07a74287b4c402c8133aa1735c749ed414f41d961c48286a04b6f6bc4e7a64f70a1f012f1dbcd6b431f512f6b42bb5ab6fb4494570fab28b8dcd2b32fc8805e9661f9078984de06fb67b80d28c1a3c6ffa5b523511fda70729fd3ff37bb410ef6d00c8748afce075c27e14086b2af88c4f3167d43bc8399f5cfb2da57d6dbbe310abf9c5a37c0642b1124cc82ed1dc51731075993fd32571ab0c3a17dd8fa9092f13863af75f5b71c7e3ddebf8b89dfeeb658c703ef89c6a3c5e0f6d0469866e95baafec55bdcee6463ddc0a9c162b596146540d90c517462ca4e1217c160dc4d93aeb12551194668032cfaef1d3f68477f01beef2a4fe48f4efc8bf1977c343fb5e0641bed2f4b20018b63483043af396a5667e9f9fad2d744035ba57fac423eaa33068f5f2ea3a98c8cbc064ae5b1f3a7f6015f297cd134e747f5b736f94283e667b99e24d45e68c8dc5d23694dfe356d03679835b8abeca52eb4c2d751115289455990aa7de4d4dc21e9c570f44501acba6d13ca0e373a6d320c22e909202cb148da8dc3e69c6e5fb20b73852ac6b2e5bfd7dbb34cc956a86e989f07e47a1f8e479a5111170160a00942efc428b255bccc708b0c012a43187f6b10d2f295eed8947947c1429710afaacb9e41f2fa965abb90f278d95d325b2001ae9c8e5e344c61155f598d9f1e78714f5709def28f2068d8ebc08b71226c3130142a2845788ab750e6c9c5ab9c1b46554f01f9558f9e5485ab748de6173e799435c95d59c60f08065cdb76c4796523da24d7b8c31e04f5b94720524b7e4897547e795c49eb011d5550a27b477ea2342a6151cd678fac2b3abd56c835f9e1a0a453cc24a6388a0fa38b029b9dea621e8c37e61680d5f9c59c5d953e35d8c59fe21ac793e0467847f40402811ddbf609f790b361e1d5859a4b0a954eb0666b3520a9f3591472da5239b10e019988eba8012b3731cbb123928ce652bb4356e5a9a9f14ca5f0e8ba60469e146e29b5f55718b597b37dc4fffc30170d232c443ca7d097250e6d220576de2b6adca5d37742d5c2d199ce052faa76ed4733f76d0ef7623c8a35001118ffbc3e1a9fd69c91162132f9f4efb1d664b33417307f3202b1db3b1986fe2c859563fda36bf642afdb31f72c8afb7fd80b2e0537dd813a49d1ff4617e8fed45f6bc0bc9e139c1f4d73c4710ee16b1693bc29c08cc1ac343062ef842d26e58fbc6785cd6878cbb5920b5b8036b21f465e3dd30ba303553f01b505615a0eac311bc41a1b3ad8c34ecc5d6d7c1a83774ed55c0e123a174390c4e67948f5595682508939159a036f1ab86abae4b382bd7de30c8084c9688bcaf686bb09a821e6bc83aa2ce8835276a0ccc847c1e0224ab2e69f9ea256012476c728a602d47fa525971fb85400180fbb3ed83f07c1480844ac8b2b289e0e0080510c5c20d82879c7c23a5cfaf2788f1e9a789d5c32ee1f8dade1ad03a44a5e402d450bf37f3855159d89a8ed9cd6789434ed77a285ee372bcc6392ef58f483000f2248aaf5d130f5c0d6c81219826eff0354eb7f4824c2267545f965f6f2d9d5eebbb9c5687f9c5916c9bf083c933979a4f0ac7c9799c2cbbdc0201e15412724341b84f0c831902cb3c6c9510328fc9c0056e75622327bcd2b52d85642ce09589c5f311e3f6f8e0b33df598447b8ed7c2adb31f7196f96c82c3a56d67eada1303127fa46274ea99b19125eb9abf837a270613feaf6d10ea51051fbc21fa211f7c420ee48cc69caaddd88a80a2447691405b1dc87ea8bfc30d033d5cbbd6e5340a227280f2054b59550c265094974146e4c7409c5b32526dc32358aaf38215f692204b96f476e36663e4683510ad55a5fed0982d44888b601d24a03f27babb3fca99690468e50d88546484fe65f342bb8c25dfef5f6ff5fed274bf7e2a4615171863f8167d112daf429ee39337af266a51d0e072b8c9540895ddf1c16aa9b48136f6d485fc7015f52960ab8b2e44b7aee8a7b02838d49e603cd208149b7df5b4eeb8f578ff7440860c72f2bd3d1a2f2c18d3ea3c5dcb55ae7095c4dc27aa036355bb464c3dde549896565e574ab3cea0e7417017109158b0e45211290e8349f70f4be5a855085c74cf4f2016aac94eec89acd645d8a13686019fd7aaa589d1d5fb7847f5895bb6dedc6a7e3d9554d8ec94017060138101c7bebcbea4c3a5958b72e0592438b8539e03f8ac46e54c02c130d7f8ad0bdfe7eda1509f4f84bffc1c11df10dd8bf6fa7255cc53a81ffc3b0746f8094795dc345aa3a3bd36da19e37056c96709c9993536ce27764bc393c21754b02a1a5fc1c09a751d3af7d7edf53348a99f1384ecd83bb32dbf3726f5fb87c148204f9ede508303ad8f8c6d2f20532a82ef22c67e7e26c8285273314c418e4e0c6dd7a5c94c2357ffa7f97887404fadbc76d82de49b37913fce5d83f8ef366ebb5feef28de75241390e6eca74bc959982cbaf058d1e9b965e14819dc77af135582c621e91e4713eee578c2f989be446e1ce8609ad0b94ab6fb6d4264e3aae7bb678cd1f7173c9ddfc9e0cacb0dfaabee1182b74a2dd65f9312a0b7fff5c85e66ed786792dc97ccf758215136c52ab2d61fa60ccd44277b506ad9317b2fa343ecc98147a6e76967692f8418893fa8e7ac42063582d81b77d64fc8886e787d2aab721c16ab69ed5e5e4eafba7fcf96257563767dbb78f7b905a271302dc113507b8c587917c51bc8629887dd4ad30756af5b112092511eb3436d424cae8b430ce09b256f999a66d7f81406f3d5d99c80965a3904ab207a2ada0a9070f75af07965aba8634f0a12af88008e9b44205c0bb548bc31b856e61f41c8731604908c7c89520e69d48be656be887fcc289bef9ed4e029200d95abdcf6f796720a031e9c75919d01956e71c6cd54cfab84a29be3a72e381cb7e60eb346983e36d80d8a382cfbaf682a3c116b89b6f516231b6c15921938b5eafe3780752791b2d63ae35632ccdd3d70514a4c72a4a86e2732895faf488c4b783f1d7e40e66a92882e966b89837e4a2d47c4e27ea77002f0c402eec617ecd33a9a6d228838d55935116523a76c49b63240636494e0597e7b4869846cd5ac2ef4e5a0272d77547d9038775c81a76958838e3152a8bca8067f62572e012acb8023943c890c16fef5d5707657873b40867f7795631c87102962670069ce8557604cd4093337cec9df10c878d110a741385d8ee671379b70ff4c5afe716976a7023256402e18d7967e7e115573cfec242a97d51a96be43aaea2a0dcdc166b4ea8969d7efe2792cda4b8e902508326aa99cdd19757c47ba51f97df7f63f340dde2e62352a503247eadcbe77a66ce8a270a7523417359632d2418ce9a79bc856c23b752c8fa93e3b9fe6d128b2ee4ffd499c261d35feb4f0d87d816a6a48db46c57f4a9194a4c4ee894b684b8c79765318b84b5d3c3d8ca956b73e53308520a06c219e99e7f532ce96a0690c4636b3a9fa4ceeb4a933a774c39961a6ee4388ec7f6a4dbc3ba03a09da7a4c3bd8183e276a126b155edf709f58d8ee6af696f102099da48750279e912d3212b9ed3206de6ea19b940b1aa792e2db2df744a47073d4f21276a74df987fc49be23a1dfe90ab1729454b19bafe0be8f0658557511d4169519b7d90e0f788c607a2a697b13149021675f4fb1bc8cfadf8cae7ac5b9e579ef5a4e64d19217d882d99ee2b6098bcfe6f7e94772ae0cad6c8c5e91a677cf472fffcbe3f11602a6a590532275fbb8bc3bb33acd1ce14e22303298797e36b8e31f9376905d780ecb98950674d8704ac0b8340ce80d122dd777bea44782db0b869bdec6c32be806fd005ae0d54397b6d166ee900905b6f8cdd3e9aebf6c4157d5ba6e808b73226201362358c530e0a49d80115a28001b07cce6359dec932ac81a1e37d2209b547a591fbf2988b45a9a0a5d666442ea768756fcf04e7bea00d7d36120b05090c8d8a1cd517760b991ec262b71916f7378ee3a21f7c85429cf2edbd46777fb00eb907400af333393dde2d84e96a9564e2d13d009c70c2459b1e0e2f2479cc2405d16619a35f411aec61a0d927f0fe38e51e9e5618c356bc3052cdc1012b3c18e048e8ba1880b17b3d570eb0ba5dcecf3003f028d18be1d0210209137116d3706beae361366afc915febc5b0ca0d5f9e1bfebb7c404a9165179cfbc830f0bddc78c634b8a436b960f238216d561773bc4c04e0cbb42fb09bd6c27ffd9f8034785aa6db2a8cc5a6833175c496cca4b0b1be72e865ae4de2cc4b3943b6afaa226dc862f0c7867382c748d9b263815921e5725a1aec37d1d37d2bd385a6a021b1a7f2bd28e0b4adfc431f01edebda8fac8ee26d635fe0380342938ce2085403f4e58272511de93bbde4f5a694b49269f4d715650874ff74b2c7e2e3b09441c46eca3d3e3a9ef2c3d9ffb11c41ac5e96f71c6ac5513a1b37d2928ac201fd9d68b4a1c4e4a99aa8b6bfe996106274a146641d8a7ec147b6626ace7aa6763224bc087ae9370f814a5fae3ecf68efad7b7432aa0d645877f9949737b6d6bf4ffad8f8d704879b4879a0bd36eee43f1b97ab3a9fddf6c787cdf4369f2874370b63b763816e828c1c8261152a648fde9bc976a24c77830ba8dfab5fe25bce2faa3d7575face13cc171f8be279de8bc6f7406781b29cd06ffc4e4c819fda6f8db07dc3f23ddf4a523d17dff692b81c51c6995f2a9baf3bb44a794ab0e5297f73f9e6113643dea5e495059696c05953a36dc3d2e328b09520c7a8be97c8c4bf287e85cf62af62719e7328951124e79b4520d16d99d10a495cf38d5d21e2891771cc35be4066e81fce7a82a64bdf3ea9a9ad679957fbf6bf63c955352398a7bc2acd2333d1e3465a7f66aa830721b0c9a5ce2859fec7c0056f687c7a2d19cfb095b3ee0ca0ca9b8dccc1e51d77c8012e1efa9cf8262395f09d26ddfb96bb3b57d07d1e1186f00c4d8dad901f2b9409c29d2189df23927d4116efeb60e1abdb1ed02753542fff26bfe177ddf810405122fb50693d9fee9da873ac53bc6ad2daf287abd2703f5d5da9fa7fcd2ca7fed35a53bc7403c3ba1029d454e076ea5766f17054d94e83d914aa85d5a98bda25055d20d9fe0ebcc37b189543c69901fdaf4375d8f52604f74edc853883fd9131bc1c7a1d0bbbc96b02ca7b2cecbd732f6142989e7d3da22031e894f7075ef289382b0206f95bb52d139b01e6305da14b644592d3a5833ddf24b500e49d7d70ae45671d84b30b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
