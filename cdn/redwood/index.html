<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b13b96414d89c3a2b177987edb1339bac24af7b597cbd31b0485d4681206ee0ec86fc5d1eaddfcb516efb4b5a3b096028cf3f37284e6ad567e58036c9bebedd87cb7d578f0c2f26a51e3b3144649f00f98cdbc83e734c4a9cf276af5ab4bf50879fa4a8de427a6728102b869b8b26488313955c267980e4e9dcecdc25617b93afdd2addf152bcc3ee63ca7df1d5edee64e0a81bfbaf7322a1db0ade6bbba8a9898a036f495440a08bd10d68c94ed386c165a9e3e6fc436207103c06d6744d8053e53ef475a60e923e29c5dc45939e8d28017dc44d5f001c25bc0cb08f56a2d3e0d852b2a91a75cca83e36fcb304ab6605f4562711676aed03ac8fc5540e52cf2e1cf47e13785b4b4600ddfdc7701ae059b987f11fdbe0e2d8b0fd5999df6b89395dfd7a5ece522b9a58e09ef89d2355e37f762ea1143a50df377ecb2d8461e0c3c392f83e851cad8591db92c86b6db671862fde67129e88464a72e85112cd979a0cf87028107aeb8cde24f52caf8ec7db2a991a8129f284fffa18292cc4d88de9b90237d0d69f3efc4e4b5abd37bb12f80a240ae6f3efe70b4eba9d2682677e0e46a61918e388e8704fb1081371ab5903cd2825629328c8a2cc1e4326133a45611ef48fa8fac0bda5549bcbab7897d52126dadca2c7d1a9f4c15e0bf63f0abf1e819f2ee3f618f740a8d3996287d38c7e6d5a60c9dccd68dd330d576c8d30a498b654ae90423a1e534dc42f8bc962c445651ab72e8d4a4129e5d7577549b208f318cd81176c5e0c9160bfcc8bcc635738471f8628e0b747691127cf051171f3341dfb8db11ed9fbe5b31ded051afbe6aed0f2c216a9a526cc1a9b8699bf77ed6339a3786f0b3732c669ecfae8a160b55c393136022828efed41e6a4d2a36d18193934b807447ac98aa529d49e8a255edad1188c376ae4375742a979b813d250a2c449de7adbfa126e53f5a8274c51e13de32bb1fb03dfb84b131ee23e71bc6f9c821009494d2dc1137a44c4dffda6642915c326b60b9fca4953e20545cbdbfb9eb4769ec67ce19213bcdb4bf5ef9710cb22c5a065512b04798b716fc3523affc297eb5291078fa38446abd90d6370ca86e875f9a127363f508783bc054cd00580ae3384730aab3ed6884b99b8af9fcfe9afd5a9f9be01e5ca2ba53663526f5413e4fbf7d438025ae0d98e5daa746c1b25e7d172838c8f17f140972acf32f08c7cc7c619be77dcea685fb7dff25458eab9bc6fcf8c9035a799390aca10821c1eba91f2e7baca254f35bac30e6a3d4986c1a815a1a7fe0b08608ad0649dd5f151edd6b1e1b80d613a01eb0cbb548850063824aebda72561ddde2834bb47fa30a74f52c527dc66943f99f82bd110e75920403b9b1a6df7079eb0b3363d39c7081aba442b5ed1a56d40a001b4a707a09461e7c2e734333034799462f6fedd09759527b1b7b6d613edfc4c2a725d96657e168e35a8ef9b4c59257a545a33f43d139ebef5554ccae7144ad809e3e6d1bd1df7b249348ab4e2576366b822081be7dd70de5c111723c0f766cdc8c15f96d2711475e200d79bb9d466de94c79b3da6410b188290ea88499177bc91076041e88da7d872198dc9a7efea38f839a30cc66eb0db8fa3875de49d80e9d7532d3d517aa597cdadd721627846c456c519a2f1732dfb8dd25206b51621a3d5af93957ca1b55a441f300729d52d6043bcca86da7a6ebe747ff0ae451081c5f0be8dd263697828fcffd2e2b7d0bea6d5bad5d911d80bd2ea47e21608211b3b1a1aaa3d95eb1113f7fd79a28ed58f044162f53cc7e30698564538c16411b4e1ddb5144ff3f7da253054fec34187d32dceb8bc42810cefcb089fb878a1096371343ca8834c9a93b338cab12bf2acbaad40e7e38461279256c842491386d3f0d8dfb33301e6778e402424319db25d247c5eb14d1fe15e66389e397c819f833cb004073af700785ea6199404d4ede9789f30d289e223eda9051f43d978fb74fe5cbec9ea11f8eb1fcbfb823bbdbcef2ef6c50c877e9e4ef063a2f8937abe9f94deb7ee18142d8ad2816a4b7c8249957e8e3053ab1e83a00f640530905e032aaf1d33856911eec675b3487b2e04a987dbdefea2138c282f5f485eae2eae51f67707b8873a950afc6e2bc2908c141b01f7c9c2965ccdc869e1252d94ceecc3f43e7400f9afafdc5df197b70e56fc421d1217c43196d8b76b683ba5ae2633307c99a37585a7443b016068003e44855ff89f35169a054ccb5646807149cf01dc1d05c38c85da6ecd6536eeb63c946c73f17ebc174fd900241c659ce02730c72b1794ffb9d23b6ffe9f1e9f5bc20a8c435eddff8599327301f006550511aef80f5be2b4f4801e9faeaebe856bcabd4a6f15c7ab014385b5661e3dcc37e4fb7e834799dc2040c7bc809da2dcb75231c7ac15bc6f315d0cef6ca768bb22cd7182a90d9e57e92c54dab88c6faf6ba6bcf13b40a46d3efcf09a010507a7a83648006bcd1fe7654e86b86e83507d1b045420063a8b41bc63d1d40438e8dccba2e50be86aae562c36cbd4a7fb90d6c34e7a29268f606d2ed00d639c53d768deb683b14a71f7566be5a39519f73728b01fd8d3eda4f08b978f7eeb13b39e7ced15c74f99ccd8616d00661131de1936453537b8dfd59dbdd677c1e7148c2dfc2e150fe38b62912e5d3b9536620344df47b13e205408dbe4566dbc75aeb5cce8763f3e35611860fe1345a95b429be9efaf8425463cbe602447a604394beacbaff2c652cc4914321d8491b13a92abf0f4c8a6b08316798e9ab0bba1d8e2d0e9bfb7edccf97a1b55cfe10d8aed83e90c050d1ccc5b1581a6168c579194a096991d5f85f21be04bf6768ce83505ddf1607af245ce477c881e1c8dc5f86c9d1ad8cf78dca2be209a7f910f62a78ed3e0cfdff2a940d78a18e4df2f4a9a779e9130a46b64ab88812458d4eae8b4c56ca072b1834059a901814b6aa3161443acd7f505154c628aabe151df61a7b599b87b54bda8267ff2319b9f7048e909c49e64563833931f13884b477b107990e6acba31a418b4a8d40409d8e66ff85b05b5fc80a69c6fabfb342e60a725d52e2a270b1822138877ee0a152ec0f78f5a272f5d7b8a7818c3aea92cbc6a48986d0d8708a6946f5321150fbb8e6a5dc77746fb044a80115993b28b0a7dd58d5a95ec3b5d0140daae97c8db18222fc24c343f28b770b13d3d4f646ec7c8a33c446c9edbc418ad3dbfa10394925399b1e5551f7e770b63e64a9924578cc1d64d9ef3e55e043bbd415ba7bc2dca6d88945db324d31727bf4851353d1a92ce28b28dce8edaaf091a6af7d288dfd492e1adf03f21ff6926b9cb33d8ec3c17348868f9566b9401629419d2fe81f43f4df5238f883cd4e15d4eff5a2847a41fa56cc967b7f4509c43df18015962ecfcca6491543e2a4c4c25160a646354c093b12bfe4ad70913a8b15310aab1d781e5fe22f7d5b626c62ad5c43ccb4887fe55b006a2039d79d89445098db5826964f44e6d61b511952a37b2ec431c7e8199cdb51681761900cd4830d82eb58ef8dce7b23815e3cbb598c840c55b389436e31bb443326ada95e43fb92cb9a2d5eecb9d2f8e73cf941236684ec678aa97655761ab1399d8523e86d4cd57fd10415870ad0a6e0142c8719f5f9bbd31bef2a7482b1e0791e6fbd95ece86e6ceac4fb25ad19bf1b97a759d02362eef3bc342b04d7cf9aa1a3448ee983fe028e243bb00aefb5a1aad3c6a33d24c16bb180f6c8bd0ec242762ce7f030e051929749ddfae893f0791d4cb4b765ca443cf7355bac39281554b12944e497d5ad77c131d94a140fc6eb4cedec01f4a90fa52bd3eddeb12afbcb3216041b8337df867c887bc6d976255008f8765fd19dbfed650bba8c2c6d83a0a089fcf08fe04122e26211bc47d0d9d0589699219108f75ee54041ab2b20a4657a95955e9ebb0299088427ddd074efca5bae9442e7c75bf64cf0700f1f1a2c04514ff0e4c6a305b3186d176de24e1f5f81d4c19cf6a3adfbe4e7dd3d580f8a72ad673ff42c6c5dce8143a92d7d187629539e32d8ecc14f4f4e48bd87c3b27486a37f17cf276131fef8014753a73d9b87326cb35e6d88bcb94c556d0c949ea540da7ac6a9f9414942b7c0831076e2873df4459e7b7723bd0b1f481de7e421cd8d2433d34a16d63bdd206b16bc5fd7407e842cfae11ae3b6b53803d3534788d0b436209b07bd3a195076b5a32b042d9b7d79e4361e9249060a1fa7c772ebca4feac265f178ff9feb9a6708c63c1d5cb765a7ca2e3be8feef533578b30a3245b3d111352ac7c6ffebd11402f4beec472298af74b66f3e7444ceea775536ceb74e3406fafcd5db314e0c3b89c95576a88a0d46e40cd7917743211e70ed5989e80b05b700d2b0953827080ac1cdd4e79be4fed321d01c36028e9681b748843ed55b0e30beaf0c4e8a782c70152b7dd6c3cdbb1c28f6351c00f361202582f2d151ab094bdc8826973d07f38220fbd65bb61fa3d39d14614bd714b885261562585d12c3bfa7e8f5af12bfc576f2d9b2675ffa6eb4130949e69b1eeefa4fa71f8bad8258f2fc54f2e8cd1c9d5bac7e0d887736fa79a967db0d953ffedf1b613081d480e228aeb26cc21d78882960ff151f478b4696dd587764dc52c32388687994e52ff46727ef68fa1a30e73f170f6b2d1f109ec04451510883a281aa955e8dd68117da8b08cfa3f7377a7fe40d76b636f25e98a95c3ab4de153a83d71eb611f0bc47b3acb925605de3cae2288e72283f33816e031910e1987ba3151ec313d94a2bfe54fe841bfff378030a0b0ba090716f5e82e152fae5a6996ae76cc33f5c3d8385279f5e723a0eb85947a0855058eab4bab9f02b76b1f58198de8b53c02ecb3fc18a165773cef4d9b72c43102d759b7712e653ca9c7a1c7d893bdd244d1c119c25cfb5a7e10bb2367c750fdb2845427f1384c42fa7be1b20ad7330932d955b5c018697b94324e32c2dbf5bb9d48dde371346879df491a4e84a3578b88062c0535f7765eb97d6cf3b9646b491a77c62eed410ba4ed4dbf83cb92db694f528cbc1a253e423afd6e61750fe9892afcaf7e6ba336d2c4a038922545e68f35d1c233c0b65697ac20011c00f53e6d7be81fbd461a8dc036e261c89d3c5e5d8d19ec7d9bd65c047fb2e76b59127890f70a41a2254e48dfd2b6715f2ef74613664dfdf4b85bf1e2b14cb233256ec6016aecf245d701437b1406983b1e133a72679b00c105293d26eecfc99392afb684e7532cd2c0ec045b8ba4a9b334e478e884e3cfbc5ffb1f17d8f25b201a5aa09cf92f1c751d9cb8ca524e47fc9cf57a28b0d75b4a475f338ec19791189dfbe2e49e8ebd8d9a97c88410f31eea499bc171aaa273ea0bf7891aa6b7779eb7e09a3f471b485bb90d976c95961b0050e016d1ff1aef47cee668a45c65c28c54dc44bfb69d04742e47ede5636172b9563edad81de66f6df69192a4415010bec7e2b8afb5e0754b881e1fb111a82296f23e5e56cf5c53c5942a81280aadd86c7e80dec1ae3858d03e4f9e0533f831b4bd14a70d449ae83ef38c7bf3dfc001034a76fd4840e6938236e700ce5e423bf444e09dc11ef8295afb847efb66b012d38f2347ec6563265ab51129def504519e220d7e50de3e8b106d0574431ad21662d48a6a60e9d8cd413eb902b9de043c840fdcc1c3d7c70082c3074f407d62f1eb37e72a60f315825dd2132136d64aa16d4429884bafdbb2b710c4ca539dc6bb61ff6805c788ad4f0016e3549ff5a84e6681bc892824798ceffa31a600d906515c1ed972ce76e0afa26de3c298f5561eabbeb748496e695f4cc32d0fdbb6476eb816b2921b1ffd587ad1f299b4bdb462076beacee5e2b13597fbd70e50e843bf11c00a134b5741bc0b7eb34843107d54292af5aa888f2dd48f19ace167d351a8c412f1fa5755e8bb08efd5d68d7bcef5adf2e97664652a5859a13d98acf237ab7b9ffd489a5191633f679e671ad136ba9ae32132f83cd837d5ba499cae031a52ed9966beda5e9de74a12fe89008a53d636e552a98cd11c93447ef086170d0046e874309bef6025c27cf3030bf14666360e3319c65dbdd4d5efcfce12c05d85f143b8115408f89225bd0a8443df71e97f3c25ca8ebf1c955188ba335e9e89bc431afa059e7ae8b3d8654841ccf49ba6d730ff00a43e5b4062e87c9c1ccb4bbfb266036e27d4515b23e4f0941238d4c281c2590067c608aa2944eda148d17eedbde48c0076ab906f6c6b3c4c1d8f149b30e1d235099d9e6539f5eacb9543fab327ce06145d07e17ca95804f961b943c6e8de7c781b0460351e206a06c68a23a73d541f284a47b44e68ff2a4302d2f65639d7dc54504a9e023d7a7648a17eda85c2ce6d60e335160f283fa779c3e127131b6493655065084e1dc7c846f1339f559bfe018579d8f9ac063bac5bb0ff8cc6b334d4d0d3f51663ec39f0a998a41d22b7ba07b667f682c37ed98068e88ad8f4438e8b39f59038593582c708f69336bcf6bf9723c83dd1a337a6f3ed42f43f29cfb182e3e81d195d790e1c39ba8a94dbb0ecb45421d75fcf1f1d2e7bf2297080b5dffb3eb65915fcf2f0da0a3fb8c43ad183606501bc4d960a087b1d2cc07b58a64ac0c156a4798d0b00cd13768ec9313ee9e3d12379bd1ee428125b0c6314471cb723eb1957a985294098950fbf664363f5f4dfdd1690de1ef2ddc537f6f2d8a760e5002cdb94003f8dd3a36e3d3f432884165dd332702d139ce1c19549402fbedff03068ee29b2d58589ebef8a5593523cb496dd780217901311db07843bcb449d0df160da087c4f337f5de04cd9320d2503dbb9c2fc81fbcee6a4c47794de5a5b3348994f5c898db809c0087f64c948233228d64120675be19140c499b84786f8ed49547ff965ca8f0e0e54963e27c2d6448599c8ef3a108ba248e8b3c98035cfb888d106d2d5e6c1663abcaea2e52da55bd8c16703b5c7c87d5d4896d9083e0a63069e2bc6247c1aedc9a041a57641cb21a62563ccff7fa1283afe865485933b84573b180bb9c756e3460c08d1f65e3664201b91afc6ace43ac96338418eeafd3c42452db900115089f20fec02ec22c02f55ea91a5995e805586fc9e279ba322f0334d06cc8cd5a4ece86de1ba21603309327b3815890eeb9784a18c04451504e5e2788bc3f091db1f9c230f42953eb9f546107ca395ca502315e1a159b5ce480765c43d0abfe218f7e5ab74e5173153a349ea9c2eaf70b9ec06b0cb7a748a9c7a82ae44ab3f5151ae08a0d3d847c495d1ad59bbced01cb59a7df27b871bfe8488017a361e9795c24bd7a5bebc90475ae6f0d5311c5e12537f800d8d0d69051c8bfff17856800493e47f6192d0f6b34f21ae7d21c9a3072b81cecaf6b70e92a60d4957721577d126857733f64b5acc028774459c9a59af867846a62c25d1059f1610d830ebbb9f4bf09419de15223e1bf5f54a4e7c0d77e6bc6be75b0b59ac560e880619a734152565240f1e330dafb860a3d5a5c6d95c3fdbb70026970fc4568f6e40abf0450864682b3065cf60e7c31caf0c7f52a60ddd65f0ce3c5a8b63ffce65a47ded7fe8023db3bf44404bc2a821f1e70cd0c309a5a43cd50d1451bae9dedc0ff685fb1ce1ede998c11d5acd81847175bac1facdbe8fb7e247ab5d749dc6b239cbab339e204796eea0da45574376f931cbefdafa0c325680a78d5986e40607ff06ffd778bc79199ee854a41a46090485bc8722e3672b4c43b1dd53640d352944299cc682cbab185c3a6ddcb7fcc86f55ad31a44a9ecd313bd4d742a8507036fb9c79dc242fa83436d79c13eb88500b88885d374913f772a4504dcecd11bb3a6cecc231462b9d0570a160618a4d33a4227b1fc958b71510e2832cdf36febc978383e3ba13f97b151ecd8a28e2bba24cb753bfa94903516e84a81fa95cc0ed061583dc2daa241afc0c7657a0f84e62f33ba7ba3235aed7b7e6ec9cf9639e97b197b85fd4636bd97103ff0f6ffc4df0524ae96e330ebecc7efb7d684f455076020e66ce8ae982712abf59950b582bd4579da2e3357e47c305d12c4fe0b4a8e8f26cabedaa5ca6c42c4d6ecb89e52db345f8d0deaa6143cb3254f91ee9b5c98f9e84fa8886bf2c5b4809b5949e7805d4d08683c50f9513987476d7c5c36c3f4240203d98a7858ea87772171da65472483bcec584a530e1ddcb9ab94c8785eac5b2204b886f1c9ef2b82bea689a504e557239ef884ee1edc0b94567d742a3b1ad9db6bb894dcb77daa229a4d83f080e1c3527f571ae176ad50cc3d93c3f7921317c1f533cfa6b042d796c72376eb1dce629f11ff3d7881e616049a7971bf628c9437d542373e2369bef0fdbdc778b8e6dedc4018e1fdb9094f72ca217ce0ef5605b8904baf37a53f9b690f4d7482305a8d30745771aef3b289205ff7a0435288b52ea4ead0004495cb46014f701b57f1384e9361f28a5d967787f9718351e48ca6beebbfe3b747ce88ec5f620f9758a768816d31a299211a362c4ef2a4dc77eccf62d43e1ada0762c45f11fc4a95064761b91ba4474b49b89c177af6221d5fa07aec70da69c5a9b5823f95c0a4f12133dc8565d9c3a4dc570673b1736fd7a39427266da25956bd52de5f19f08744035856b6abd81919eb61ffe0adab123eb944b800829bb32bbc620203cdba9268b0b0f0c9951f756341fa0cf37514af4cdc0a2d05196c6456aa108c9f962ae84f5fad2c9974e54135f0e7f3d5223b8feadae922b8e91050061bb8ce3e5642395cb55fd9ee3a9a8a8924b1c7d2d2ee9e95204684823f6d8223916cb3a06964df704411367cdaa5cbcc0fe4c7b4e6070bbd5b3dca9e6cf24134d7bd82871820aff550d99b21d7ed7a8d055eda94c6fedf57cfb05d2f1e8b7446464a9a10abf6184074f35dff4da01ea8f4afc1510626631dbbf0f38bbbfce21afa950bcbff73d23e61f83f891f8241ea0ca20504972794a86cccd83c35b56fa281f97bb599fd16e7f75f39688369c30cb43f71d30879fe4559a4e080b9e248a0c376ce172834d1e942aa65a8250c8269226ad423ce1075b85907a93442efc6e7aa234bbffda7521dc6417a90a7722c2bcb8f279351d015574c036d699a2af32a8482c389e9e0861e3fdc3d072642d8bfe1405c6d19895beda4042beb2264531c15e2986676e77120ce25345c57596a0a91180c36df46e84514d015a1b3c10dccdcb8c61791103afeb305102d691766f10b33804e6c3524b21ac275a7073d0f591fd04faa59275aa9d881e2116e952fb197c1d93440dbcab41d575c45d3b8d65c1196ea3cb18c9d8169c2e1cac9fdee64a63dde03ca447ea04d184bc2c8cce9feb2c32be1368a72014eb6f5f25953de25637795785d301fb8c4c81111604fae9df98dae3027ecf09c5cf733729e5cf6250d65d63115cfe46e01483b706e5c62362b9dcc49c6963571eecc3cffc1d2548b530d95a9669de4579250ae35def33217fce18a46921947612a124b869a7315359f30eb4fea6c3f554dabfc8d4481aed63ba1d9709591a635f081476518e52596ee37d179258b609368693751ea26b1d1ab769e5a324a35ca0e4577c1b41027bca6df9bfb6e4d88626c82898c5d0b18ac71824381e8705aa24715101cff79ca2acae15f1d8b2e1d1e65df969f4d8b4f91b4fb2848a232a0b0b2e0c8631ca3fffac0b3392cb9cfddd6f3d437d22bde53490f214eadc71df20cb5a4804fa603090a55362606daf29487a0aed2459fc8c0ee7a07932f0fb7e5809fd317baee22f28027bc8df716d430e83e04c1cf5e0c77aa9cdc607b433a2d733922d2147f4a0b01696afe641e79c0976496ea8f46b5794c01b1d839fcde6c8e6b03d5bbe0683c80fca23836ed420085f3f29a1ba5ea992e18e06050ab52a95d233414f6fb6230b2fc01688b6284d52f38559211dbe59f9942fed82a74fa6953c76f009bf7f7b2d8d8e9be6517343f5b62cce00a067b9738f4b2645b4deeac7f816c78db9afb02fbce2548aa6ebfc088941aa94d6b707dc9f133312d2490dfa8784563d027fb430ece1b20db905c5f4baa60e131617e5f48e7de4c8b1db2d0700bc03ef7ff3b7e8f27dc6fa0fb790208b425ebacc691cd711ac9f4fa29b73b3e1bd10077939c904f5887b4ffd35c26b68707efe30a24147d64f15349570ef482d14789928bc43942259133e48a50895a9e38e1191042977126b90044a6d0d51af4db375b4d55c9fb1f839b4967375814faa2d6085a23d558d30b1a008272f694daa3b8c81e6ec49d81bb3740d4112765a743cd45f6e790a427da1afcd26bf8f955dba92f4b08aecb9da4a1d1749b2c7cfca3ee9040e77cadfde27ded2235b733615c02a60bf130e014539c9ea8804d1ff2ca593d9a0b9e4dcb97f81d2f9323f040eb62ec306ffe411140313446b097d5b93c8a7f08b032bff6103c8184a0b17fdb983bb00b21c40bf086c84735861cd171dc36df6a5d75b05ea7f033b3cc9e3976f75ce33d6995078da977f3aa87fdb78bf25e75d60c29950543181367208a1667e137693b48cfe8ad2cd9efc095bd8965b4cae129c9461fcc9792bd8880fda05f8376e5a21733d0cdc7999e41322f85d1faed0e62710aa9c5a52019c003acab6f9c979e7c192723f0ac0f3627c07108aa1f89874652f16341b7d0f5c50b7d45441e096ad1c4a0cfeb3dd4c8225a1e01312f06b1ba0e356b65a433efcccd9a75ae13c3b63aaba4026286145737bedbcacc1becdec1bbe788b248da92d85ac90186f9710be8add537c84986e7325489e9bcc2fa1a5fd4496efbf4740aabf32815018f29bfe8b6be8cb1530bce8f3843bd56c0dcd3e9914a3aad745bb40734d218e84ce7d421f06a71f78e2425c7eff253a5a0fa7770d8f17c2348f9e8c8c81c85be0a02ea9fe14b1a1a6ce28f75622491f8bcaf89deb5081b2f2f13e355e83a1f19aa37543a9095117610c0984b02c5ead619667ce771a46175235496a93ef4f6c384dc83aad402e2cd0d853adf44354ed1ef6401623ec0cc186bfcd7c21daa3f58549ed4b7ebfc81717b28d68d8e5f3a8269297d50c2a17cfa03b4eee9566edc175730e5785755ca0917a7fb7a83d346a61a2f04c514025123c368773738990944eb95a0a6264dc70f82716421f44aa22938838581ef60cbe9898af826a2cfe688c9740120457c8b06a3d3ebe59bac23ccbd45da6859a27663d9c9c3fc92d308da367bddd2904f2dd84f5ececab7678f841760b720c8b511c56c0b883b1a5b9ad40ee87ff224f195d0104630b4047f152e14f6988c2903c1b08bd07c2a5f4c8acda15f6116a8c61da6ae6fa5fd53db4fac10da9d27fb6e6a13e2e6c3428858ed3b12dba11d9a8e6a0b3fc80e94191ca571764918bf833b8e1d8b25101f78a14218519cea1a505d230ab291ab197ae2b5ea9efc79b87be35ff16dfe65b76e175ca39b564e6fbfc9baede4e5c27ea5a28658571fcabff635392ed4fa583bfef3ac03d62a8f67ac3638fe230619e09f949e9259185bb5845ed38df287684d5702281e13d36760c5e1c4e6751a0903c4848786d0ef8ce64051abd543b4b0d935714faa3b3e6176644271823fe4ca7306717b2736717a3014429facc0750da317499ceb00c35bb2d0684bfa8e27164b2b91032c62804c25ba452fd5b50706b8593ce37205caec505481a41c0037de5b72e7e29ea43f95f019bf189a6ce1d34696bf0ed258967753f5345b612f4edd614c03d74ab5a89aafb2744dd39df0cdd79d7de9fc7df62f7aa79d9c928c1c2c2fd64afaac5fc7877d5bdf57a7db812617879599490cc8981c3c53ca5ca24337a358e497e3e6c88e19a38e8589b618591b0b6e9c65ea0107dc3048035d51ab261074c3b2541bb566f067589f525cf01d6810161a83367d221b570275173aab3f82be3f4136417839b8ce1de83fd524374c974ca0eed97e899bff46e73097958cbc1892a1420dfd53d110527c983df62f1646f881b1df25a5343c757e3173e5bc39c1d048ae2f7461acc1232b888e088033a420a4a8b5811c72cfd59ec20974de241bae8b3344fb86afa5148365dd6b876838cdec9a9455dd3bded51ae1eed7695a4c49aaa46cc9d65cf446e0037aac48dbe293fc19a854e692c7b72efca9ccc5be932ba5334dccbd678a7317d57a34b1f9181916e2dce1fc0c012cbab367e89e974ce8d8723435c9bfd7ecf9d648862363d2a5998b505e98baab6eb5e3459c6372ad2395df4c5acbdd28e3fc3509b5778637816898ecabd70fe9bcec6dfcfa67377651da58cf1760cfc4d44d2c910d14b54c0f327942ff13d34bd7ea4262f53b41cb3e40787e89e483e9aa71323b782708f01c411b1381ab626a2dd2d7c42529e85412d18cef6a65ae2d5e3974831632f6db237c85a142fbfaac34aa6436882b0ca7f9f60c2019425b0e9bec2706afd1776b61e49f398e1ae71aa4551ad85503691224fe6ebf8547327379096e7d4bc2221d019c4ba6e005ae7a3ef6b1100abd60ca892bd022038e23fbdfb703e3575cb9ccde9de2dd23c18489ee06d5de37d44b3fd80d1d40e53c8dfc47066455e0ae0904180195dcbb5b9846125b4e7cb2e2711cb14d69d5e284fa32dbf8d261c2fc35729c280a8a784e87595a31b832af62691c21d4194dde9bf21a3ec5367926a6b4c0d3e4a45771304e8f9187dffc36307ce48b097e78bd96dc01bd16a8334a8e4040a42bd2c78d71241e67a1796ddef63306360b4a8fc22d19099a756e823a8776e6b850addebc3132d9aa253dccff50bcb906835d974e97f8ab6d91cdde079ec91a2cc6a7d4de567bdef0dfdba19594b019c1be70e92cdbf0620e69b1ab7a6105cad687381148bc2da7515e8b4d49ca00ffeced1aa8230ca9dd734879f47a8d2eba4ce9d653e87206df25866db52d7fdc1c49e9d40c1c9372c9c61c60fe13e6ac79d2a9a62aa6beabc64b0b1a0f5d5d1f922ac86d11b1ada9b97fc31181bec9e0d19939d7903e40ca344d58d7fa5ad6f9402c5904ced1e611aa7e5614af801d2787f2382cbe9fd2dadfab7bc3c3a76767eafe3a3921db2407967e10087fe44e18632e9da5c322acc06ce48c454d55d27436c09c66884ea6ba75b36b25b81b6eadc423565a1401ee97cd4ff049897b55dc8a069f7944629246f83064133789204c0d137f2e04ea2dd1e048ba534b51b809c016655707f0c88e514ee8d6af5a445623168200e660bc9f10aeedc9ae53b792116766860f1f7d76a5392f38316fab5b41b5301c54bad9dc8e8da524b60a4d1aea5493a52a8ffbfb98207c232b616b57416ee387d58bb3e8c4ba901561d07de2dbd90732aa096a1a4a8edfed5e69489576a3d43b8ec5ecb1b1db8dc2b826961861752defbe65ad0534dcb47988cd59d318480ed588c9a9c07dcfe7cac9a5ef870f42fd957b14a53bbf5cca21f00b39c925df0da2e4f70fcf2a534303214470ab97e04a5e19629f510f83218dcbd06ac6bb44bf0d6e7d232c5f697a9ab17cf8edfc334bc49a9689a55350b2011be4e26ce5b1e743076d10850a2a2f55e5758795f927522b471b76c41b317e76c4a556ebabac740cfce084a4d5aac2672d8314a3a63925775dec7fe5adb184bd807cb58fd3cd1cdc7a7b0f6ebf3dcd4e5e1f550e40dc718a85d7fecfe271e10ab6467ac431f9bca3e4b60d6f5cd3bfcd27f4b634221208d3db913eb6d3b5f8b1119e8c3f230229068a0c367856069851ce78d7e5b29afc9a70a56f9c1b84c99bcf479ad1e81907b77ab7a2ce35da96d9420ed0fcb0163fc0f9d7330ba790c7d4c2f5a2381a36e80f6f9be58ec7291e6a6f21dc68efe5cbd745379e1a4cc33288c31d7d0037a49331aadb6bba6eae94f00968541f104ca52f4bffc426744f48ccad052f080d310e0fc768fc1eeb3c4b026eff89f7af5f43f7f749c3b119277c64bd4e1b8c042a8faaaa53450002b2a9862c66d3af577120c58200cd21f49407ccc4eb0712a814c468ca7d61cc044ce6ac1d2f949c596ce11ca1e0632f5df17db7528a787b850080324925e13abf7e549f41a8963338ed453da7dcdcce29ad7af25a0fc68fb35256442d82a5f321d937832344d888f8f9f7c00e2629b50ec6361bb3795cc752438b67c8bc03dc2cdf24c052fc07a74594ed8b060e8af28c2c45411e7577d6bf28ea00be6d2bdd0cc2486b66eef345d3e74e791d1252eb8f7ef9dfac03e0ed2e44f02f3349a6227b534757e23f1de73346599d241a935f31bf8fdeee2dc76db0aa6fcb5afca5837e904c276015bb21b2eac4ff613a8966a7eeb29b772e560862d579567769f39dd037777b8fa955d662608a2e9d48106f0f2075f7e593de55aa83274d5b8edb2a4b75d924fe1604585d35fe1fca253f150684eb959a530eb2f8a6f1e3b1053ca9a322661d6515aff03a336c7150880452790959cbdcd2d390c9b3df20b3297d34ea1f77516f259fec7a1a3a1a8c518c1965ea2e50b39d9514307afdee6d55083a61123ff020d39c919e482c34140973ca4990c1950bd3b3e049657bc20ed9b4146117fc20b65de95dfc5327fc75c0d8a594a82222c7cbf7d2f96df0d492108902ea84cc7fb9cada55aab452df0a2fcb2826815e99375974aebe8dfa265541f12a34cd873801726b221cb60590cec155e56ca04122856ceb7a7dbef0a631f553d33170f0e198c0e0fdb01b9246b0d8610d2af122b866ac8ae4b04b63d486cf06baf8d24af765ab2c8da198c9021348509fd34784451d58eca61be46824ae794721f28c14d266e09e6cf13e8c19337a699db413d0053da44a951792c721375e77c9ec469723810a892ff11b3cc37c4b6d3e5c939a677f697f8060123d996612ce3e0c6625b364d8cd2f952261853e05a12c533d2b304a04447d83584a4244f95e0898bdee723a3a39d2fdc9aabade299e818b49d381019561ad8d29febb022c20b8a674976ad71bd63e2fabf1905c2dfa30d66bce576507102493bd5810a10a18889f608649158255babc695c4fc3c26851444f698328cd6bb18308b0f237ced5c41ca4434c8f8f5db29ee2a231792b756e2039346b6999111772fd8352cf410fe161afcc83b875d319fd6f1bf65be6a954c4e42b1a6ae47879a7997c5ebdffe9ffe24fd9109a4d15f95e13e986bb026dfba76e442c1058f614550c003fac0558c093fa7824b4b77129b41f41cf4b9fc1f36072f6aa3dd6bb89958ff86edd2f7114f6cc5786a7ae0b3e4d95a0d7c19d6e6282a0aa37218330910e1ccfe87b4e016eb791b941a26d81b46f777b9a5a28ef4d956ad204d5ca7bc77b4e17fc6d08fe068dbe39c50057b197f9e1a3b72a95442a5cb5dfb4bb7f00f00d42d83cf0a5d0eaa446a0e8c498424f2c1098700baa910e301c1348d2dab27b2e33a9b53e8ed3856e02da3ac25ab6e10e84e20469892997ad50ec81e8e626c0cfcb8d89598d44fd941adce8b7e14782b79ff2f1fce1b4236184bee7b9b2d88d37f049b04506fdb932a91400a982eda60e510ca6deabce63af3923e3cff4e6c2d0cb20bf69eff8f4d9ed0b7bcd5a0e64deba0f936729b1b4a5b8575bbe52bb1bfef400a9b636414dbc811a8985c8c356e94363fca2b7a2871b6d4770d0df27accafebd71669d020d249d24cc62db1052894b4121b37a8c375cfdc1a85e625da2a8e5d11571e57b4170b11bfe0a267b4e565cce1c06460951b6ba3bce355f822b44720eab1c1c8f7ad95cb0d935e7a0938f190584451edeb4bbab4c7adc01f03c9b05061cc3d392ab8d82c234a5b9b080f3202f3d8e48134799b8d91dff3306518245ae1be81d1917fbf8475ede83e4b9ec2d8738f793767f768289c2f34ccf8d08269dbf81ee9440ae2dee5621a4abd6f3b8a7d8fbc0834bfbf20676bda03409ec66b1bb08cb13216970fd186bd294e14dab8519445ddb621672737470683a0380169df7e675a2903dd90f364f974a20329cabf5123b161c468108a62383cce581f7719742a922fa612517cd6458ce0d853138d0557e16cca7cdbb92dc765797c697c4bfd4699332408c276b89fc23eeb3713a6e979c5c15c69059ab786d1c6f27c8c32f153207deae5fa7a22aaed24f54667f6968b6ca38f1eb48f2b0964058af7c107149ffd74eb00e8c7653b028b925af935f8d4fe25474bae3407bd3674f954bd71616231a5de379fb4800c1f7be76b675563de809b2c2400e85f27b4056c9640870b13c47c9f31bcf2a46b630606e815f2dc53174fff7b54a536b045004f1a8595d7b4dcea30153a94a0d92b5cc75196c1354e87137197e3dda16038cd24b2babc652d7441aeef19b72ac323982a3dc50da28680a0d4a8ee0fd2e07f4af881b1ea1de25ec82cb7d4868a404c089cb0b6df2cc802e52728dddaff975852aa295ce341adec4f67d0152d2c8cea9e75006071f0b24d797fd92dfc5a6844f7a1154d875dcf8b138818ed1ddc536ad0df1d01ef497cf14667cd888a0c3787ef9d32967d50d09a7779b8e110461d421e1a9574aeb1cf52dde4d6b8e1321252ba4909ccb1dfcc55859a47cdf1dded3e64f4c468926eda384378e5740540a24032ce99a241876380af49723c44ce1c340f1c3e4c197ee980acec1bd6441272adda64b758fd5632bcc1f8db49b308e71f58e81b69f4f69605191bcb235cf1452c4da940bd6f82c6678d65301ded99a773667b36459c064cbd4f5e6b2f252650d528803120e83f7678de12634b785f517b7f7e36bda2df512900b5f34a102c8298f2b0cfbec5b8a1438219b83244e2f2b6b9b9e706858ad33cfb6448df359a97ab60d4ddc2ef38a69c09e1494ca20a55f6bbde7f7725b7dbe86b1fbb834cc1e29a37d5c669b67626eb10be7ce315171026e1036505799ee3837cf0a5137228b83f3236ae03681ddd515e83f2cc30a186aa9447530cbbe749f2d2f1e4f620ffe615aca181b4e0641a7f88637b55fe7511b6cfb07c62f7d95c8a82c4a707f28cbd93aa466eda9f4bf8ee0644586dd30965287ae93aa7f151cd79305ec3c66a1c37f571d4898a967ce9708c9c0fbda76448fb43af3b86b705feca186a56fe83f817cafb4ce8337eb07a89f8f6e0a742ad4c81852f443f0cf49b8e8a575edb56c9b66a481fce272babf4c1be5513c6d79d1d3bde5a74fcf547bac3e572e6bccf6557fcef60e2abfb9e6367dfc5af3e98dbda2dd6449600b76d420c131c9c235778d300f9cf1de431b52373706d6473c9b6368b7f0152bd059d14eef4fb0c2c54d730c45fce0440f94ca370e73514b2f56e0ef40e00d820b7cd22acf6d9d034fac456925f447902fc2f715bddaae90803ce058542bbc5ae6423ff3f32bb95bb0dcdcf41a9a328ee85e04b9f41f1407844001e01250c5b04a1baa35097048adf2d46e6d57b0cf173f2dbecb8fbe8b1e60e6f9eea303b0cacf8e01e890cc809279b604e9a2bd78812b202165311ec6c8a0a36aa54142e7b00993354237be28730ea4783f9fd1d6bfcf4b315006ae491c3cb385e7ede28269e70fe38faf36e0217b5c56e65711c6b586cb5be5e83d557ee70176b9c16c6529de7d554b5a1370f006dc26c4447eb6634d69218177257e77eb851522eb1193b819bd71bf22cdf897104f506e62a9ee86b01719ac3dc5fee1e61c59fd4a71f4bbf051bb9c347919b3e6a19be8884bb25a246f65100dff18c85e25982ebb11a49eecf78e524c64ae32af68e5efc008904f2e38a0e81ec3a56c466f56846e62859bce43e13bc38f0d1f1c039c8719276239bef0e381ee887b9e68e2441240197eb2a42cc2e61cc20d8a3bfe4349afad0ae0f9ca8500bb24191779233f3f36ebfced83eef0835c1dfa405501545c4a0d81d747457536a42381ae8be7f9ac94f34c9db33ac09a69aa306760d8620eae68603bacb99a2ae44d9e748eeca3e039238c037650321886b91a35826668574e4ea1963d0b3a546deaab9c134a3de497e0011ba6f7f405f397e642ba7617ca0a0dbf1f0dabb0691a70be118c71ed430640350485e13f1be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
