<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d05ae15480272e0e5a62b939483b24283acaa8906b98e309c4f1387e2409c145745c8ca631e4f67c5e84f0f6ff3cbf49570682084dfa740116ad12a1dc90327a15ee77b51b998529179e65e517c570045451089b0546bc7f699d945d6312ca2fbbd9ff9018f993b2b04f0a9ed3a41f6f8db87e53397ccaa0b8bc5600f52055d9e93019ffb9606a344de97d00731651fd20674b6924d3f2babf891ec66c47524935b39b265f736d5fd803e6989ce91bb1a3a88d53f1a7705ecd1afede5e8dbac9099e3234dcadf15902f2f838bf0bd515b9e5808e4661b49d691bc7fcf0ece3c00c80856d95a9a08e97cfa4dd734729e732d284e2ff270bcb91eb4f64bc2d13e72eb9877e71ca36a113e18f3946db2fdd4fc1dd7068326cff6cab1240d83030821e99b7463812daa1811150867f1644ff81f69302ac80fddfd896c4552af30abace973300badc297d40125e04d7c6c2ea73c9af2e727dba3bed473c2a8f8dcc6001fe2968413f833cc2aaee474f4be8147f8ee4e7840da963c6db350ebc259dfc59157a979817db2609decf14cf78dfba93abafb022d682018260cf5793dfda862d60c1fa8ec899309ab854f4b349563ce50f4dc7bff79a97f6f05ef409eb7c3c28a848bef2736ad62c9c3928e1357455a1660edfcf56ec9191d85c7abe2925dd7784b1ce9eb9831aa459e944b03aaef036439a33193325c024633e853893a0b701ee01f9449821fc2fdee94cc6314ee7113c1e5339abd3f42e10fd280e53843bc5127025f5b1148eb3465a4bc9a46f3e76dfb2bf65615d2849f0ddfb0af2f76cb91356932d1ff672edb03a627c875bbe61c95d71b457ae5ad2072ae4e752ea1f67e38b295261985a115f73bb059f316d64fe2ea75d23112c7c3d42c6c5e33d5dff211f167b3ecdfd418a996823d9e2a5af3ec63e1e6e767d9fa9dc65db38f7e08472962445100619bac1211b3fa404c020550c4e92a7e54f5ae1364b3894951430291ff85842eccaf892260ebe277cefd5743e7aee0b2f85758bbc82483e4fb40c9b441a4d56a1f0f916ab574a144ff3add104b2b2d11cedf04f8ad1aa1e50c7680bcce0d844266c3912d617d6179d5b21013495c89ac09b399625851c37e85d432ca4f5ef35e38baa41af6bd4d658a4f8936d82e0c6037045b37bf69182e3cbc2155626f269d770e656c8b991055787e6680eeb4fbf429168e6a307af26f62536a02cbe1e00041e98f3a7a7999acda54464fdcb3b76eb22b33a127b35e0c1a4dd05cbffa27eebcbf9220eb4b1bdb763340a833a80514bf94e6e87a6abee9e0041727d52b6876fd3b5678078259eebf4281a232b09168c966af253759b2c611108af124c608a375b16b87de2c0ed99c28a9e60a88c59e5d0eeff53bf55098c94887b2e2d52acac2743eb4f5e5e54828017b242bab61e319d310afe0297746a145e8b95856f873cbe717f8dfcf9722513d58e74e44f0bbfab76c07fee03dd57c85fe1edecc83ac146d5de110f402eacc2acad57abefa0d35ffd026292e6111d36f4a72fb94bf7b977ff725cf6f8b19590b53e4ed8d34a844d88a133038e3efcd609b23e88979724e2db2e10ba780aadf4472a2d95a899d1bc920052579565b052a4a30a08e473f8f721b5d7fde12280f1e2bc9de7508b39940d38cde1f316975eec0a6aea6bd0059efa390865ed27ee008a1c0982e66b72fea395c4f3c3015e46cbe69ed912f9233501838e33e29abf1f4b9384f0b53b06b967d49821f04cdd5a2bc14fb155fc1c320bbfc2a6a3cf8046d05d09b263e8a731d60584a36d82c16c90ff22005f91016546eb204ce0190e29645cafe45782bd0ef5943ccb792ba9e35fcb232b68c9526b81601d80734bd8a5a40c16eedb0f3fb3250ea033515967140145ac9543d802e3c84f31ac708992c00c92b8868a06b3da552619b0f9da7e4a904204b7b5f7e3c4c13eabe6fab1014ab2aa3393360f5b39374047f8dda3d18d0ef1e66376139ccf2ae804d7f57f829d1fe98680e83d8ce81316cda12ae2a98b7046d62baa0588f62fad329b83b0d13f8d7aefaf45a88bfb1aabba9ccff843611255abd7c63c66ae79df9ec4e736a04c511167512d80dfaeb004f8ad95cc4dfc58265e501aec140f337f63332efd3455ca599a3acf06b7e8d1bb59e038ac0409c53deeead2841df3bb3f9bb8010b7b7563566889e6ae2aa00ddb5936a7dc3fea9120104a96415168d0ee17bd390fd670f115cdf8cb5fde9fefadff030dbf9ba9301a6300dd63550b7bef8c0d48bfba8d9be5f48bdeeb28b7f82b2e28d8b0bf5ae944fdfb56a52b468fbe3453dc5954c5086898fe4e38ee10276a34d6fed8677526bb50c952980db4c694a16c3a2993f855ad9840d3babbfc7d09aba2967c5d38fb2dcc775645f2457a4ed0bf7e5adbf1a125b545a9419d11f02c7f7c608059bdbf7cb2354720e42b784a89a9caa8faa5bfd7e654394a93135e3fd6dd29c78c965414ba08be5f1d268623dc2014fea24e23125e1bef7e0e26b52278a58e3d1e32efc83b11c135ccd97d6429356f0ac3dbc287fc513ffb9bea2ee50fb3905606eec60105e9e5de7dcac5ae885088d1f93ff188e85093858f4a9a8b3af52a9e6097b6da559a284f88db52b13128a96ea32a28282a33a7fa3e0392fa517540e532029be20ea5ce0a29bf620576d25b07f328b7b97aaac6410e0634ce5be4afbcd1bfa33e918e7958aa2b7faca86c6147fcab79ae30c2ca57a5d64ab799e0cef980ee5f5ad75507c423e9debc6b8a4339f0139bc361efc402d9a01923c49aeb284af898aed306cabf2f435ee0d3d3c654d67dd349a553b8a63e169599c371629f92f53f8206c2dcab067aa71426a13546719aa279a1dd9a7e29be830d20fdc621393191a8ba3b4fdf6c5eb54307987429ad116ae4da7b19c752aedc7593fab739d158e21a79987476295b48aea2ec0da0badb82d94ff0268cccd82740bd86495b17f44cfb6df25c1c3ba0daf1de2c2b5569f9353e37a47a9aba4e6d163feb4825f71a45f78ca2433b5a3f98d41863f2012eb49b9f7256ce151b9aabe93125806b3df0625435d6d1cb6fa621bbf4c88fd549c1fb985b84cac0f650a0d7b19412e13c9c2c38c1ef2490d8f89083a9c75904bc25e11f467290b32e84a593a99f081a63505c02fc9e2e09ce514b742c147e4afe6e37a71cce2d82650dbdfd785095d2989047b0dfae99de5b9beea702a61267af682931c01be9ab3fac4894620ddf78bf148701f9e5e3a82506829a60177e13a7119a69553ec149dd229d053c4338c1911e7b74f5604a78a801e1815f8190af6a68a18d17072187823f58244cbf21b3cbee9868559d377576578be346f05ed4775ab112fe1dd0423cce12c1ca820ebc6d8dea94e2ab872d548cbc82e6b86a8b88326c016941a0b9e85099f536f75426281961e0098462d125c8b6e06f0df72b84ee97611cdf6fce92a6ed90920144adf0a6ba05daaf4d3533a2000f8fbdc3568105534d586ccf2e416120b303db4eb94fc5d3821d5786142cf423b686238764018746ac5400039f7f67bda9e5fc27c949f42ab4a9175201aba8c61506f73e3d8fb33d99635bf51e5a9b2e4a6db74e9e5f98e4f10099eb4e666b7b2c8a3ceebe2c804b28b6bdd885743ab3b515b25cfc5079fdc71c15bb0350270a30950773768ff5d2f225c19b28cdd81fa16742b3b01e95c65d838b664f3402179619cbd47bb9ea35b2acf78fbf4fe6619a26295cdd875352ff53c6623c693df0ac0a17ccdbb6c55c66b3d3ccd4d47a1d242c5b632b11d3d028c4b1625920433fdbe32f5bc02ff98da0610ffa2133cfd8470a7fec43f3fc0be692a6504a0db5bb50c31979b5229d8c0142fb453595a330ca29660dc5b2188e3c424a5b2d2614511a249a94c8e9d55ebc940abb03650e0e78597f8153d0bd496f7b4ad1f3d298fbcf3f34ba3df4eff640475e644eaae6c54c6eb6308a6fde6c5ccd93b509672a31513f2d3aa79ddc578c66ffea44c5523864b8f422944a960655fd36932c527a90bb01550d971885f5f908eae600688746c57c9febb8a9a0217405cf06f4ad7dd2af910d8755a2cbc04e415f9f07eb14b49a15bc3195f29c9a50646e84939d53d6866d47b0c24b778439094b34bf608e61bab3cf09dd1d447eff878a2d90c5b64e7706d56d5cd2defe39cb6f08d64d36c3bd00d88a7d496ca2f41f53201afb39d60c22e5a447afccc34e52113a0dfc9f21847da212a179a198548eb74085f9097fdac8dc7eecf651460ead6c7d2449ca3dc1d1eff281f71a17cbc2702620b36201dd1d7955301c60e982964861d15f3f34f3455eb66a094b910dd37caecb94687f1d7eb3d2c8d8896c07b92f43b24edc83fcc42f4c33388f52e8aeb279698a6a3e97c3dae268f9d06648a0540878be1eed65da01e413299d829d0f325b80b84d3fb2fc159aa494a85c24cd0212b3f64d70de9905e0a9c0687dc25052933eb683c6a6e77a3712f10fba7333c2ca3e1234c6f1140a92db325f5d2c245a0bf41be2439f34262bd376fdb3841cb55edee9576828ae74e0d4000d7bb4e7bb990524031344f0c80d92ef2777127ff2917f4bce7c4b8086f2003f4397b8e011a7fa981900422a8281bf50c00d92970aae8012ba4a6b8c8e3193eb705d1e1964d54dbe8e7ef04e457d42c705167fbea65feecb2e8816c2e693563d277aaf4d8c27ebd595dda9cba20f85d522c3fc3ebf0a7f9df90d84661968effff8e05e84fd7e8aee7f67406dedd7ff398c7dd7ecd6f9c9f5c90a7ccd5162439d33bc9fbfe4f6bc4d5215ef23a4f9cb0c0e80cd6539fb6fd8da07019127dd578d9619309959bfd46dfcf6ec3ac0ede2951c053388a5c67cddfa4e608e531d22635e67cecae4a9159dd5c695136e43be0b0fbd1a05efde69e1e47edcdced6e7a195a8ace46349ea6da2fda27d5a93b1ebc375e27bd889036eaa2d6cac294541fc84d3ee97f112dfe491e912f2bfaf455eaf9c871386d140c688eb74a20673aef26f5240c8a877d15e541326840e3d400617957368a7f078b9d387c3523a0eaea7f136ea21130d60c20f9d9de2b5167e3f10bd1020536681ef7c5c0b24838686ae00e3d1524f0b22f5b5f72369b1264d6b8c6d22fdf13e89cf7f5ee8f8068ae9e19f1af9e1528b82a20df43340a460ef8b15b4b4dbd0e7a34bcbd93841f933d6dca14adb775ea072c6bec91a6da6c6f7456a71002473f81d4bd8688f82071e1c0c6f25694713bab32a7300292aa1f2d88962cceb7b05627c8d307d3576226b07b26b665e904e55efd18718bee50036b787f39ca62bbecac8b1de622e2e96a7dc7f4d5930e2bae35aa40eeeb3a7dfb68340af5626aed6caab3184b8501d87f3a419a5845650188c47edfb3f5831e047fe0a11d66c901fb2722d8be24dbba89b8a19d8beff40670132bc3a70458ba70f33c67c88030ab7b8f6484de3e69a0a89d843ef64a16e82bdba1a80bf647855fc143f225953215f8d792cc2b65d6946b9bb6bbdff9fd8ee9c219ed5dd7572194307c0b0dfc2460826bd5fab0994905244e4c757406b335a5f897cfd4a31d857700415e318bb5a0a8e3ac83ab689ca83c98d3cb9ba8a5a155a9c342c97c873fe3a287308f0af128145980166a3d06ca3f7cdc9e90ee2c84b200593d2e799edfde93f351976d9e34c7bf1254ccdb20c7f11c9dd285ac27cb03a162062310e03c574db5ac68deaa333f574ddd1e7a26ee28a1f9720ca1f016eb3d35aa10b2bd2fb924bcdfb8b51cfa82f5c3a0f42cbce0d81fd9af70ae3330e504b64e1d94dec808871ce1657d67fe617c146ec8ccf1ed13228c4821f6afa86b3542571e11e576e3a97311eb63ee3ed3fb06a16c3ff9d9a00035ec6a19e05e1b3edf29009d92086e6c345ac258d3876d7bbcda50590bf660ca0c21496256a9d6d9bfaec897ac23a76bd39b8b81bb51d562a79e9f0695675c7a01de9d0d88956d141704f0d319c641d2df8760c8274f42c298d8103774ebf79e59b739758334c7902cce6cc80d00383448bf3e69470136f86909b25d5550f3c3cc43c15c065f8514cad22407d8e47c6973c8886ee27526bb33fe5d025ba6759cece5a973f92be248c516b52e95f3658976c8cdb9137f311a5d1b7588bbbfc2518d21a8d09d724d17dd374008156d51412aa7ebeb8529675e799ee09700853924ec1ec38eaa978e511bab56173e6b7ee172caae684521df780d069c709e4cf9624f928fcd2d0e63cd95937c32a605367658eb6f1e74b511f33400677bec18e48428187ac6fa0d4028c18e9bc220cc7325fbfa3e9639c7fb38199f475afc7041c1f371607ca68115f3c9cc32f0533f43645d8b317d6f53cf722e47c0672caf52c4231d4efaae8aac3c67c5249f4144a43b664aaca7fdafb65ef4b2cc10c2c3eee56c5f62d61b3da06b8b58c3b88405565ee9116ccc5a59c1e8247ca4e8cebc63b2c8270ba40662b99f5510dcefec37388f4b6ecc2b88a5c0df02bdd649d2d8e9cafea78d6d407936dd0650bba5e28569c418909c86b736ea0c2769f8369cdced45f63e5537074fa9b3a2659b5aca73c4bb3c15cb188420b30c1be69bdc919ce8eb0ba4f3476fc526d3150964a75f5212ede038c904f2348dfd5f188cc24d86c558be2bf47f112fd252f3ef9842fe52a1b0aff1f8dc584dea6484d351fe4350d5bc65c0e07768ac40254c46246adcce8050d8dd95bf911c988b365585d1ebde05654d47bb1bcdc198885ebbeed4b4d9ce09e4da0d9efa3602ef4dbd074b380e3c5a4f32e1bfe3ad08eea8424dfb6f53c9f88627a1721e989dcc0b58ada92ae5ac90d071a94fa8c3559c04b42552ba4e656699c22ae627fc3dcab78325637245f73417fb933ab9f01fc1c834c444477abb76ad9e9db9b1e72329c4c226ac016d8738229b2568d872b48a01836bcce5560ddf4ff18298dbe12a6681f4c38413b4898920c68128e47bae12bf4f9e4565e4cd0e8801a105fe7dd94f4cdd2e3c34f3bac95a4c42f0b6c92797d2241fee8e42dd03094e554267831b31b1024f4927193aebaebc61f81ab9e4a8bfb7e83ab19666d9b0cef825819de384e7abd8a36caabf92b633083f27dc69e9e7792a1ee8ebf608562f2c77cc5919e823fffed1063042504730733edfc278d836af0036ddd144602420572958e52c07c50f9f17ead88c20f2d3bffb2554b5bb79bffdab107d37be89dcba20bebd4736dfea7f4892dc9694ed0510042fa3f4aa76ae3e286ef543ca2a42fa7189efda53ff2de60b8afc869e0a3c6c63e74c7ab5925f6d44e39bfb752aecd422202e2f310fa8b681246a9dc8cf4e483c544055b502dbb073fa9d8cb4b0c8e647ae16b89896bef2abd51379fed51954edfd8a36031e4830fde2d302275cedcef0fb0eaa3974169b09739f0d3f64b23be2a123de4171b8631014204d396b9bcd1c0bd1429a1f512ed9aac2e18680d3612dc2a498ac131d9d2c21533e5d2af03df1c0330e9b222f1d3c701fc39cba8d3c4f3ea102bfec9af8a6a855d94a6d6459443b3725f28d6cc65059bb9202a9ee8069f4bb2f7c3d0aa94c5d180615a9158fcec30256863db58bad8e92f696c554ae2f571540897eff1a6ed8b3238ea2b01d3c2b363ffaa8245245d7a03eb6a71ba905848765863c152f1bf7287b4f2e4a40222c96824ce3435e0d5f100f9f455f5d82ea81a83addf5198e295c571e33d6594f56afbf4a160db4a8598eb0247ca2c4d34fa56b497c8d243fb85c9632a8b5c8f86b87073865d2044aed7141f03c79e2ff89f7aeedddb09e66fc5a4bf5b279302f4126ef85f442e8e0f9b5a2543da938394e4da6501ba71a7dd7b59b7de7a5c587572b8ab46fa2069e62a121c606dc75fcdea335fa36285da54973f344f4c0f149431fa9dd2318e24e0a3a9a51087e2a9b89bbe3e3173ccfca586e22ad5c857bbf623a835b968f4ff49b126ad4c502ec4a1e19c276ed70289d3d20634c504293d814586d9d9018cf653ae2c26c1889edf5202088266f3cdf78771816eb08ef19160ed398b02f633f72a531834c451f4e9603e5582780d0efa2a17426a4d3e1c30bf4cd6d3fa95b155de1cee6d38b37f3bb243be96e270d23afc30f5b3851ff0f74a0652cfe007fe86fd937284a18d8ef0409b5d04aef3843adf4e9433a88c22926b9c1fd11079787adf747c4bf97a103bb5ffa4397d79a3afbe1835cef6d306e4e93be338084934cf267b20dfdaeea34251a99e5cb190e2367fe38c9fb3ccb0890d8e5dac0ade708b76f644a009d6aced5b692892aed32798076d30e0187a8d8679e14b043f8c171ce87f616a06d18d493f0b8eccb501c16767986f12dda7aeb749a9074d5bfeb5c78400d9150e8dff230bdb50b0a153955ba869afdd28411e1fdf06fd0920003daa2942fb3bf8b6c5551b1ab1df0745eae1168f58194889bdb9c60d98d9a0bc10e9835772749e77c321d28b05fe2add98a6bdd95279763a31e4fad709c7ba6bc062cebe60cbf9f964bdf4a115721622a930d07cdb2d107d2f0a80126e2d0fc0386134a154b91012b88b088f369eecfb1f38829ae9c6d6ff28e7c2f7bcf8cdcbb4f8dadd9b8d64d78e03f104c60ed506908307ba6af71c5998b79ee41e17aa7accdc3399eb0a147a9de040cd8ed02921b1e4e3add838dd13b989dd6ed6563db3f868c5f0feb3779d7a12574d130905e5d29b959b13663f16a145f84f95ea0c6ebce7936e838c4073820dd89fd6457786b12d5852e05399fa751265d4bd008d82e7a26ff438cd973ea5f9dc38d2c2865b35a32f205966b6a2156e99c91144b1a171e199e34f15553e8813abf54fd65c0e983eeb692350b917cf58e9125e105467464496ff40b9609fe2f15a92e15391a99952a01bca0f87ce8dc6e9b57275308abdc9b14d77811441c88107dfe0ca53de7495ffa5150564e5b6c013bec09a97bbee38dc7163c0062bccde6ff1749aa8f4bcea1c265848590403217a6c00760b984b54503640d0b3c1fd850179a8cdb1081e2cb7bad7edacee27c18b08bfc1f04a40f8155e100a3ebb3b6119a2e3c0031c37ddc81609bc7d2638e267ab84fd9ec33c422ff9681a5d4609d16b78e7cb2d54886bbb241d5c6485a2bc116870a86f30b3bedef78d2521d2d64fc629370e6b65327220e28e28db5f1cb27d8808c8dc61b28af1e99560951c752c2b302f4d26b39bdb550d4253da6adf919539f11be619197b88ad7204b5c8e7af56acf93131ab8ebec6476ae86e4213261f407a67ecdc4ccf9cfb54721848cf4119f54a8709d618b946d201eadf616e1adcc94bc456dd735446afe341d2d670443c094aef8f5af492781ada11cb978a7ba9900a82338161410da4ceb67e594f9090b66a8b05d20eb315eff5045c90c02c98eae9437417e6443195d1e25eea37b3e4a70b89d3d6e218bb084e76b77d32d06ca3e33e0c3318219e17df017d9495c9baadb841b0068f3bbbc528bc989346cb88052c4bc2a8d32d9bed32698b25c256a313927b6926ece2aa9e0dd168f66a99eb5cd6b2b063c30a02dcc8626bc2f66509e2df411d61682dbaaa467e539a73f171d25badbf0b9a07d40b8784c4717bb5765cdcb3c529c257a4292a645a2dfe37a2468a57e8568d43f720f79812c67b10fbb958dab8bfa1a36b326e3dc492d69a5c492daaf2a5b23e85cf637fcf8104a24a2fce5bd073798318231fd401aee53d0fd2c71a1d37531e9594af61fc9eb9e96ad293245e46a8e31cd422d223e8c4d96e2b94b9241a8b529b5ef60bfdd3167115fe0aed27358eea4d21c6e979ab75b939f5ce3b4ee2b0e8e1a308ade5ffb782563a66b0009409be34aaafeafedc9a564f0eee8aee1705b12e63ddb21d18bca1d8b7883c9fc925b9ddfec7e77853bd705c5d6b3f63b1c4893743dbd1838e673b21741aecb324d1e97e362f7d845f65077e550b9bd9c1a6f47012b0e017c947939a5584fa4e6566e707a913b1f7818213d80679f7f82ab7b03060859dd98bfb4508a91c9180c3f2290b5e1f6a500fe3478a06b0afbea499a4551f8507767bc211ed74468bf2874dff9382cedc387052d97a0de7f9c527db11d6fe62406ff455952c64fafd5dbb1dcbed02df55431b11f7c804f10addfc64fd6719e0a87d00a18f19d98501443b8121011f5ddc4313189dfb3ea21d5136328ff9d30eb5ad426011c9ab028328e5dbd54c106312f7825ec75052ab9cc34c16779542016b4647a6ac69ecf85e1bcc2e4d50dac42602b7a5714f25022199ebacfe85d2945ef4c3f8ba18847d0f1e4ad3e6280ee7eb642cba4f3204247439403f46c5b675d04bb3b33c4a7afd1086442f94c2cd2f0aaf1d4d74f5b702bab6ee56a05b33cab850ddc350db8f969a7c4eba579f3d96381ba7e370a82d0e8fb82469471c4b4d59ef567845fff4b42aa75fa8ac5ca72cec94c2d8dc296e65a9138c1706abdf3558c42112d67abfc107b1832c6b53f9bc31c8fa89472c24f75ca4ed6e1af3851875fe734551b405c340a0a6c8d291c0d7f9ab50fc67f99e4a52c08af17efadff3b29c19697f19eea2a1ecdec544140a11e7c736a80688027edf933455a5a77a62704d450d53bbf138b7fba6ff0b934b97747362eac0afdcf1f8d860f13a16fb6d18e51e1739e8efabffb96bcb152ea88c85806abe21b8170a5d1e90388fe662a175f82b48f84592c9d4812dc5a960345fa64061f892b914f01882e98bafbabb4d68d50d2debf8097cd2c1fa71a91247cfb43924f0d5a35a1b6946d06a3e7c9cfb35035cddde711c14bd52b90d2c15bf20cbb98fcf1a6a4ceb9ba1d43cfb4a41393466524da2c0623b8bef5ffc5130c3f1607f3a030fb1e243b48824dea3ef8a7d227c89d976a441f8cd8faca696132e2e6d0907b70653dd06e0ecae32b7769b3daa5db8941fd8ea5f120a42b13fb76e0d1a892133b542a2570407462c6f92247211771ad8b8e56e8614b583683e08f68258ffb3581baed3fbda59b70a7d9bdf1935400673f5c8556c8fa9362a67c3bc0fea25a54ab5b80e4b7d3e116994bed4b3bfeac7af5fbde54409c3733af276755fa2654b8f9db9408abbb1bb061c836740834c92107885dd652d048061226501326e151b5b199b24d1b10b7a66125425431ed69a55a12b3db7899b004ff4d66ff7dcdffec1beda12a95f25ac78e12214df0b49865ee2a795ad6346143503c321cb6b916091a9bd18687d603fff51d025328286b3dcfff872ea701632c2eb5a8737a3ad050950b5e09632381d38fd02fb0b8fefa98913d8439851b26e1c8e195c75db4f038eda5fd774e9646cbf8cb64fcb04927a41e6813f093e1a0b39a9a810f262e02f8ff3940482c67ffa59865a6d9f450475a23614ce33abe1b428fa7c001219fba75056550044b788566e50614baddaa3126de948dbd9af6f1841ae5c827672049f0cd3bb585514f4a99f4fefe18a92d8ea07a21f149010d9b73652fbeef4c8822f8bf921e42ed79746c09e5fce9c72ae7e45ff303581fde393b06d673b737dce74b4d7ecb453c752fa866a44a6f2108a57536001d19cb1f18385ab36abfe110876c26e8cd36e100819bf34cb31f35c6f0523911cb80927414a030cddeb6f61d0fcaef3a1be285f20bb8cb6823ba2369c826a697eeea90d22cf19f08351722703f8ff47a12e0745f1c4c8dd2c82fb11736104334c258d35f4f229d9195462ac82004e96cd0ab05a4c7f1d5b756dfff029fbd2dd466818ce1374ed35b1d0283f659b3154be5ba3e809bc0217e7e369c441b31bcb4b6a198182c8aef1daca5c259490056a49e997673a2f85f110858c6b2316ddf73f1e28d1a56f8fcdc2ed81f9a7765266a539b9d263742ea16d555e8524a46960d18f8320797d0eddbb6ce3b5e9411118d95e9c5335125aadfcff944c6a153d8fd5139e7e6dcbf151a3b9a9eac2187e92be201b3a2a80ffde8fc65b4e268c8da3c410557c5737b701e2ad8da733860354b60bffbb6b29ca88755158689650db992739e3baae32ce516dfeb8b704e4b371390a75af611c2a8fabe0496413cd46d294cfdb9a9935d2c787592edaac2125c2464138474f580d608c3aa9cd2d2154f397aff9b80da3f054ac6c12b28f7a9f67a52de3ca4dd93523a3c8d6c5cf5b6b7c3ab6f40c805b58647c6cd1bb33fc9bf8260b8daab8d618f1f40aff90d1b350225e858346302be5329b6f3de5a47c4124cdecaf78dc0ec9d0e3eeb10293ceaf67efed104eeb7f2f38c0abda78abfd56eec507fe4a1f53e327ce5b6565528dfb863efb166c8a78e2fa4d36af7b0dd5dedfbe024b148e914436bd3818d01fd7daef6cfa04b66e642b1ba0e7af96f9c5a5a55434c1f85c57ac9874a34eac3526ae0e171ef309742fcdd09966b4fa089be8b3eb71e040f5c7a6e1bb9154949ec9b13ce78b11fb180b4358c42bda3f9cb198dc0d1a92467bcb9942c6063918f2b99b00aac4a3a1cd13aad3a07eed2883ef3f49bf2b82dbe8085601823ed2bd126495f76f97f4e0f6d056ddc7970a537575bbfb6495cf3a5cac5e55a9dc2047598bac3f9f315109f058734c3c5f8431a08be693b9436bd88c626f81b112462207196ee608306d0a3d8a6aafc244f1e209175c205d44f739d0aa438421ec638b4366744e917a3289c77bcc4c79b3aa8e0bd310df5f8f76507df119869be0f8d6a92a243e37a59905755ae4302c71f07a0cad53f7834855dcb37670149f4d5d37b23b208fc01961138e19d4ffc4adde1f508e4f8711c25a9fd77e4cd4d70997cf063db79f5475506c088acd136d78b86862134d0e7e46deabb58aa4f4a9d73a2ba2de71fdcc574aff53cf9ee49a124a70b5931b799e33ff31fac537d7e5c1c07844e01a6e94e76587f849a43ff91894a0601ff79747331f8775037aa54b0503f09f4edef25f8994d020423e902d7be7b144034f450deb1a8d4a38edea53e170c97cd3c278351c34d871e5a51aa9442f2e7f1c694184b085d77a2c8ce6c22b39548903b4873bcb5f6f67734e4ffcd40a00916a293f183169fe8a9b68533d83bd6fd03a4bf8bd64e9856bcb50e3b73c0b33ff170010f8442cebed6a501926259dc0c4176ca6d8c19348334009b30446df2deb593026dad178ca1afeb246acfa43ad6a65723a146d525df01c8e3b0e5c9a65e763cc6ac3fdf8446881d448e5d4cd90b9de567117eff44a5996237ce5dbede995edd6712ed9dc9c6d361810de740092ea5b575767a85492f4f650e52f8a46ac2f3fa301469ad90ab2ffe783bdaa9f9ce9b72a2ac16b6146e6a04508aecb74d389d787ab33e3fbd2c76f1c8eccf24a66901d9a795e41e327931ecb1b3b0ac917f87caebac7ad90422b7222787749849368e4ef4b446b731faf0810b5b44bda7d76d00c9c2944eeb9a0ea06d1ce2ccbe692c9806e807bae49be24f07d5e918dca77a3b708f6ddd3ca3f6df32878ddf2bb7ec719374d87f9ccfb941c3b156ae21180c672149a56affc3103cd1868e3fc309113b1709d82df5364074af9eff331d19e40fb7d021898658356e3370c7aa6db9a6bfcde36196c0a6e250a881ade8e742e3ca8e008b04c316ba34a1da7a0349c3279eb248c9ce5eb74f3095fb14ce0911754c62d8781e097cf89d2906586134dddf2b41463c7d7476816ce03bd4ed98f86b71c278eb25544649f3607532779b919ad179871c0030e37fbc95eb2aa4bc2c22de48b0500381bb1393da3d974e22382045b11fb4d41b4cb43d379a9d448d3945c822363b1521f184f6dceb46065924e788a8c71f86650d385649ca6cc2bc6e6f8a9f8a2b4e081d6bf356fb48e5cb9aa92e97947757ba22263a0007863a85b5de95c98c54df6910db24ced69f43f2fa879a93e0796c5a22ab9934b757b0020f3cc33c896ca00dd21e8a794b520fa1915f6fa120682292e7d2283def9ad4bca2de653c9ee5294ab8f5d707972df72e175086e67355b887f8b6e4f30ca8dc555aa6cdf3663b964189cfb3a3c5bf24d005ec20f6c56b876a5589ff3a41124fd62993504bc6a6862e77a7c631169d2928c50869fc826a7cb16c66541640e88d8d809c65c63b979dbb77ce0b5c030826e050aeb6bcef8d35f1e4d700614a810ad715bac1785caac5bb24792aa1c1aea19b80921d5eb01a0233b7b9cddc119fca75fda0cc758aeacdf2813a71526a59d4f75b6b7afddea98773d265fe77daccf6f3450ccb3fd13a4ab60a2d42b125a5685503d9e4ef635850811ab6a233815fc7a9087daabed95c1c2de973dcf0d3f4d8a12a2094eb415aaf369b3e7390614e9d9d6692144fe9d9b4dd9f9f3ee8823b96cc6dd998b1348feebd7df88957a28dc550a01eb464ebdfecf9faf73485dad1d19166b33df39421931c1952bed0bc0e8a1eab98f5c33a3d9a9eb51e24db75662330d31fbcfb732afd71eec3d713db03822cd0342020439f3a86a380c252b3b3bf723d9e3db9576dc51e30eea39962fc3b467ef1bee939169a2bed3021e43b55cca2f29dc86c5d264d12d8b880c2362cb0df428b435e0886454761aed998a8ed3259bb09564ab46f45714736005fb6d86db596c2bde3189dd5ced36be688e773d4d44674c1efea260561e056b47b9f996f7b1d81462dd0ffa43288ef5725991bcc0d8845304261c86c15df07a5e1c3d98950d94594c2148cfe8d54c8e86ca774da94565509be28d99543a0ffbd679484c59683f6ed7a6a9f70d4e2c4067b96174c2dc74da9132454cbc1f4726dc4920e8a6293365ff5238ae9d4cfd6b2330a0e737097e3862d179dd0cb02de5b6242fa7e9b219dbe0018c4f1dc2e397ba8279cd781c97ef85734c95a70a8c76f06a1d97ed0135c359bdfd1fa31148ea250b79b4bfe64b62a24be8c493665dbaf643547041be2b679842053c59927a6df2ee858ffce1a4c968501e1c69040b67ca8209a1958c253624639d0a09d5d90221564304ffaa7b446d362b9c8d939d1c7634b819758dc0a14d2eb7e15d2d5369cc31a086ce1a83baca54dc8aeaad2a8eef99ccbbe706e1c02a3fe9472586aa2984af68a52a1229cff2322e28c726ec9e1e66617a0c05d4bbac37db141b4e6428f77645be2ff0dac66c1ce4efc3b30c43ff221a792323315318d49b14e15e074a67acb6d0f605aee46444297ec0b0c95b4bdc0dd74efc33cb40de5c008f598caad18a07f5344c51a8a7345f69a9d9bea0f5715809a579af8cfa0a845fbeca9cd0ef7d7d94420cb5ab90e0653c4a14ac854e6e7ce08f7bbdb0c97dfd278b164665c58af5023aedcabadc2dee4598b7b84bdeae22e046a6c181a12d37cfa9780e6a088c2f2fe884acfe4f1971c4eb5cf6fde4b6e39d8f2b400465323583307f9a102faad66d7ba01c71089ad9a6bdb3c0a8371a911bec7a7c4c62bc0489ef1b7a975756e9e8d48506fcc81b9569a9d3a958b080da7214ba33a0d18475d57f1083f1fbb61344261cf39f46b3cd9d2ce421769c75ec3e71fd872bc2c7dd28ec53dd9cc9c4e661aaa85d791ec541a5b55922870a19f8e20fb806bf6d88865461b6ebc6ebeb1bd774a7df87a9175935a4b45ae61c265237831f1052ed28279e43cb68a01ad4d1bfa69111dfeffc1f9f9067db54367bd8df5f77280d9c926d07da7237074d6f6fa3433589928ef8a0df9a49985316586a88212986b710de8a007a513a6617078ba054443f9df85d3a595a7f391f2db2dbd3ab8123fb1537880493a193c290656efbbcfb08c51b8c38133e294117ff923147d063e9ab006e6c294d10d038f0c2c3597eb5d6fe0bb25d0b1b4c29817a4af0915a6e55cb8bccac0e8d49b682a31eab42a57ce79ccc88039c24e9e3884fd9e3ea2bb0d12b511505f58b3716d912c47e5477c95b0285c70186d10216bd81f08343c7e149a5b5871066fede9c980afd837e02d4f636c321d1b150093b82244c65081b3cb97067f4d2d3f8afe93096f4dade62a0375af232538dd744360dcafb8a19e15fee0fff81e4d7223fb83797c8679e19e8411ddfaa0bbf59bb001a3185c10ac893655ccd3c39b1bf7f8e3892070598ef95ac66aa4c677cec0a570ff3f796d42529747c1407078337014ad98f6fb4e21dc85320106573a3fadd7fa02d5abbcb70baba3aafff3d46afdd3bc3f652c33c1e3d256de185002d93f099da85e2074229cedd26bf0def870341c904e5d8cc85a60deaf31a02a9eb201fd2d834def7a4c54339e8aba5621d6ea5f943ef2d6c610ce28fc92c4677d4426bcbd8401a5efdc837c70fa4f0d27a19bb16731337e5aa6f795a98ac0449e3f8c4f8afc4521b39d11fbb4ef45e0ee4f00699e31282a433bbcd234d60dadf900a03a17543b8e98b2d1164babb49a5c6ef27f7d981a8d4fae1a5a9c2dfb18bd1f84e6aad4a38ea9a3281f5e6756f563ac01a138e58b02f7a609c7e56975ad4f6287479e71b7b93df9530b7896f80be3afdf98ccf2c7c55d16bb89fe8200fd23e4e24e4e1cbc8493f6b337465bc5c4cecc68d5c5cdab745d16b6fca286b5fefe84a68cc1e28331905875a7a090556cd2e4552967579f3d2d09445795656207e4f614e70aef8aa3a94e99aad3b7207e4440c1c8a58c79bc0d106e0c01ada72777b09f3141458c32a13500513429869766a213349e1e99d0f7dd3e085055db3e3b75ef8cb7711ce0c617c29d73dd7320dea7f2ed56a5c7d7dfdc6466a7cf595c653ba2a280f2094d2912b642dfda7aff024ddc80ec70788b2ba5e30d49bb0c4a258337c7b7962612fd2ff05a2b0bd7e0ce052dc3f917b9f324fabe8297e0bb8da49b05a2bbc1156979200219ee8c30ae07bbf5999bb1badf4675c91a6529356dfc13d8c1acbcb4d7308f2320ff1afd0cac74d9c7560ff30905390072129602a2c127470a558f7443f2cbc1d93e741ff1276edb788fee565f8d180d49efe5a0a047397c4d9983f73c6d1b1dda00e2225f40fe279cfbe6aee5610e6fddfc4e92a4c1566d0d874ebfd6e7fafa359f22e16cd069b0c151b1c444715a4af0eb0252d9fa42d6f9d896efcdfb54e674ebdf83d1c611907f23a1818144748ef2f2ef52c0927840eac798b54743b5a758a39a7b9e104471b7ade5c792fa99d56fd8a32e361eccbffdb5571e93d8b85bd06230301f010fdf426860a3d614cab6a6acde37ffdaf652399b83d0016889ed37cf6c57b6b1b658a006c961f503432a89a09f05d71ed487f6e257af0e81beed288a47519b0ef408e3b368605c18b38915cae6ed343e3cab4d6b72a3189b05923f2ad5b0848d7db16f953853575240617b49e249f91edb749f656aa4bd8c6cd63e3efb7bdf81ee51fcceaccd5d44c38909040bab8f4c62ae8b8c4c907fc06176af463c48683d16ef39bfe0241042b1b543540ec91570ea92bfccd4bbd2eab7dd425688706444284fe9a4211de315a56a90b2b4ba4ce301d9607da82fdf55e02356eb9c66b5dda49cf39b65533fff53b5a01f0f6274d982cfc2fae8143fb1081ac0187ace8519b5161dd0fa4b092debe4abab25feec6e54ff5a635138783c0c3464184f7a91e6d598fbaef85b8dc1cc003835eef90e8669c6d58a5b1215f8abb85d7bd15bf531a2afcb72b2082f21f8fad430748dc5054ac3463053a22a3b63644d12803588682eb875703242e33635e9ef7eb919b988ede541e5f608b27dad77dcbaae04b43b262f7970218185fb2602d3589d1f33b7efba375059384ffa8226486e2d88461f6d81d250dcbba4a0a44376c02360a0986d2e81eed9fb70c876cff39f408d8d8633d6f732228284a6e7ae4d266b45299ab3914a7f87caa20a6e05a70093d9154ce7d8edc7c390974f3c5636674ba0f7621b70ae09b673a7ac783594c81fc825d2fba5b60ba0c81aa1baf6e7c0bdb85d7642aef4d8fadc78625e813782369b692da7e8f3549ea270a6ad50a2f56b94d835ce43e0b21b1eb2895209a7d4143e1ff4fe3b2e7f2176118f2364e9faaadd98cd06dd250321d5a1d343eaa2b2be608a7c3382a2e436b0c549a10f58503bc63a6079324dfceae744dc4381a95fe1036951fbacd204c32d3c176e6c6f532dc6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
