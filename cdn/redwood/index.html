<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cca36a38380e799a06c8bcd93c53daa41e6d0bcac7b94717cb9e1aeed92a1c7d6e67227735cfb51ee68d41726e4794370420e02f3e48069b5d1a047c8d6c62f6cb466066bd6e32f75fb06a01a4cd281974e51d9aebae474d0363feb2305c1a792c97e01aba8844a7a7a35d8b090b25d2adfdd195cf2dcec52851e769e8e8d66906bc65edbb8cd53deb40c83f80cf456a01913cccb27fbb81755062d6b99cf0dc387315c49e870ee7708ffdbe6ff53077e6367c5616675fda7f98f3421ec3beaea1b241551b4a067ac46c5921e7e9f4dd30da53cb601ea3d21f382aa215219373069c39b120f7e0d66e45b343ded5268c73bd6642c2d1d7709f7b45d0bb3f0aa1f80145738a3eb8723c7f94240fd99a4b912aae79f9c0e29d9bfdabd420e6862597ee38769ecb36ccfc0c188468076ed84e2f6197d91fac8d84de86f63221d7c7ddea7c0d85364c6bbb442aa827f7dbd1c5ffc27abf20c035ef70ea55ef9a5f3cf9f416468b5b415baa3ac37d4130d8b25c9d4a58e666041c5d8842469c7033bfed27169119524dbc7b5f1e2bc9ea25c13a4bfefd042bbd4434adb7fac1e8c2bf95c89ded44b788cc6f31dd6f110911afe7fa622f8fb6398a02e47c900002d925b5fddafabc1d10a3aa2dc305ce6c0d865d2203075744d33156d0871ded0ad6e2abba9a3d65e473c5ee66abb0f19a93ff8811c8a624482a78814efb775f5a4dc5b4c8b0629a5847e761deae79a5611e12c8c3a715384ffdb28d1c23407d9fb1383bcf6cc91f9fa020ded308b65d8201aeb55d68c3dec1340b21bc624fd4dc10fc284ba7aac7cc063be629d145149342e525ec20087aa75c83dd4e21c0b105fbb1363405ab5a872102cd7306bc5bcf6e24805ead1561dc1407276a3681a32616bd27e38c4ae8569f364125978a785e75673911a563f9d2c91bc3722d9cebf11f89656f9c34503fd65ba1f939bb19d6368186eaaff31cf43c6adbf05cda7af6364f5753a0d1df7598f89c9ed295292fd930032ebfd01d18b94f734b5a4b56c11a257accfbfdef5ec6c20b8422d28cc17d3a1a94ca783fca4c7c9a42ee8354030ad34158985133a09cf8b45ce7d24887ea68f00d32acd491ec520ba51be412f078bcf823fccb58dd5b9008f898d507756c49ee0ec4f2de203765ca0e03ac5ce714949f18069d4ccd2eb1e73912673e48290034080b89fcec50e3a2555e80c86ff8af2e56cf794731648460a721ad16e20db7711f69a45176f8809ac60f7865decdab6d7ba160562f0264f88c248ade27f295bbeed004651497e5b10def1778fc659c6407728f9e6865269b3e40138d417993a45eec506cb3527f9bb306b36875ce00decf55ffe74a5ce34448a229564e467dca99719dff1cd65894c777364ac1e7b8d4cfcb74ffdd95fc3c28829d96d73230f6ea729cc305182d49ff47e3d900ac0c830cda2a5edf682184726c25726b9d7fcd148dcfab308aadd061f71647663386593f20efb2e8e1a1b22ab56db450c9eb1551c0813fbd9ab5d4976edf5612abe2324317f11e0de691ba2995ffe381a63a85ff1a1895351a21f821eb5d0f4bea7d20e4d77c620d89d06dd1777a142db2480f44a0df11debf51f3f0115dc36e961e95a76aca8de277a8056fab11c2d57b0dad0d156b2c851b500bdc96f8d9295a1eb9f02a69f0bd134682ea8ae23d5c6133b3c0c062347ff57e4d01be93245244f536d8950f5dbd25b5d2186191419fe971288319491cdbaac4e739a33dd24e8aedb7c5ae5cfaba874a3653b70e363267bb16c90c2a965bc138f79d9b80cee4d7ac0ef3ddf884133c58c180862a771c4edec391e4b15c04261052243a8e0a57ab57034d0d62dfc430c75b1a9e706bc4ce22718e9b75ac288a3bbcbd7ce1f8411662ae60d28cbbfc09d7c933955618cea704983323bce76349aa4b219617530c212d2a4309600068904eac9ca21e3f8945d60ceb07fd9db4e29a9fa4297d67e1455e0cb66cb9b1dfa7167b3c0b5aff033d0061da2477b127ea9f6ab4177deb60dab0c9876253a2f5048faba21db6b0dcf09a54e6f4dc154fe5bb423aeaa783825fa3840e5261e0a9b58d71b8a3b9cf41832d974916433b0f1720bf4091aee0286c77b63b93cb8bf19b836ab45e5d412194dd8c808108e2bb484bd8b474a810472668ef5aef6a746222d65cc46cc3d0e2974103494cc0a84cd11c4a8f965f7e2bc40c8c7a7616e63d138076303d802d498cf039c6926e99141c2a54b93593a59ed52ee52e224f9badeed92ce0cdd9f22f7ce6f8b55db7b8a8751c6927bba04f484b6f09ba3ab1005819a4b65b9c91126823f9f969b6aecf25c63290837634c3b4fe0144d9cdbd0345087c7700e1ad5e70ba6b4d6a2f60c819db90dc7e7e841bcbc282d25ad7d1cf9eba8da5bb8e237848ceff12b93251b7e2a49c72b92e6a170af9602c306a9a71d2493d816410ba1f8112c5ade438627b71f48c10a8b3448fc4f9c912718670199b8296834ba47d852ce48569759a541a0cc3e55a4f10e7e3282b706462e97b2fb36f3127f55e2dac72580322e0d54f8046681e17b8fceaedef12647bc17805d5eb37d809f015bf9666bf1a77f4210b65ed3a2bf9f208e1f529ebe64b05c1da62cf3f7f3b1e69a3a8c5a5129a7db4262485233d09f6836c8bd0229769254cabd7a14e1ef8fac31777a4c6db72868259442061e389e1d328f29f03a99b84648ae43a4563107c1e2571b3fa43aa72a42d3be884dde0af6a5570cb920ee02327add5494efc4e157d01a7ced28c468203fa7c5b59eedd6dd190113cd34067f1709e398b4ea2afea12554a6e4ec395d846a695452d76b900d10516d512d68b31c9869c55a026afd896f1765018fc3b0bebb86cfe179ccd6c1b5076ff139bcb8886ac4aebf3bbb700eeebc4ace6a44f26fc56b879701e2ea0f29cc7d9fb5b4548c524c24877932dd13e859f331fb7cc852b01ee541daf7169ab0e5d6407a147d3b8cc4c02c340599deab52e8d5df7c389c14d8723124b5f75dc00a40dec271a7be2ea75b92ffd0883a2f3055554ed86b44ff9d0bedf5e19bd55be7cf67f7e55f17db63bec91eb65ceed47096d0050e394acfb1a2e3963d682e46af07892a44291b1dbb23399a6c89fedc5fee7a69c5d93ea60612fe8a63c2fa278bd762414395499cef6e382501780608e1a446952746eb6fee12c34af7be29989c7fbce9801fb019cd6be42de155f6799173a8fbdb045eab57dac9abf5ecb59901ccb5218975638b4962559d529a3ef73d032353dace78c6d5774be99160e9aef46bf3c9a3537ae369647f6d1039dd39ab0045b31a332b25d9a8a160e1a1936ad1c53aa6637b2eb4d8db25ffc6b86f40bbd1da18f6e2a21e072e48cc0080ad907c9068a99e0c95d34b6ffb77c0cf122beb481963a53bf502cc4be3640fa4e591a51cbb7052938fd414f0939b41ddee5829a64a33e7732d28cfcbed7f28e1fa97451cd571b7c4638f4874b4f6c717537a9529db37d346f8fe243aa7e754c72f5164cf8502d56eade6c5ed0337f2bba33da9de791d25ddda4e6a41eccac53765e2c6dc7cd5b2f820e1ed470dd95845b491dab3c460829310e3a31b1e2061b882c62d4132899ece922335aa81811e19503bae0a0b16b7ec6b6e875a0769919e1d01cdca3fef84623cadc4c048bd2e0d130554eaa1804f659fb4574b500aa1e233c719069a5031b1a8fd24567456f868b0aa80676dc49da99578aacdae449dc4bbd31b7f72496ddb4ffcb35f87a897f9ac9d22f8c4e99fa1efd51d24b564350d2e154f1dc8fae2d040ced0cb8aba3bb5af4f1ff197953d694a39a095e84f47642d01331c24c546a24abe9460b2bce0d1851bfdfc7ee68f222331253cf17f212eb45797485ddf0466ab7eaaa92ed59d2a98772425c75488f3f51dd83b399fa699196998b1ab97771814d5e5c7e68b0fe4cfdb077a43e48467524af236daaaa5f88abf85fbdeff3eaf3725ab6459fe2eaeb91e94fd2d6e31339a6c80ba23b940250e205fd39fdb4871f8263167d246c3b4d4a128dbf3272eb165e9c499e405bc5c968356a15915ba7b7263b2739f09a1cd985c3541611261c82c5d54582a522c7bc95b0645afa8d0cbc53c1ee0ee99374071a4c4778355886a051aa7ec29f4b8d081fa470a3c8c732475981ee90fad9d3bb0fef8bf14e1b72e66eb14e80c8fe5e900b2520a57b4b38bb5f58061aa70bad71760f0b945a613cf106d1fa87c846bf41c0c41ea0b46c7394a85ac2ff6aa19f335119c208cf41306e388d9ed2269e989f09480f11f0fefa630aef67842ce0ab8b853b522f8e512d122294c6797fc9ce4f38ef741e319bf0f75e6f57d5ecbeb328685f46c00ea662c3fc5a01921a645c62a7aeec374c05b0749578d169120c5d537ce401c3c7dfacc36e303a6733dbc9cf9e3e9102499b0f93cf573feb812f0443aeb831d4aa1aa6793587b44a6d14fe584e9d230e52cf586532fc5de0967fc199f631188b9bb536edfb41affdce16628521fcdb819431c38e826fe055a91bd9af3e054694f2af6b6ed0d9ac5e8e80fd925b096c30787d5679a6366684584f0c70cd9c43adf74e3a42a90608c08e536f88e16d1a299883e39fbeab007f52339c64793728ce72771f180eaa55ec45185a87e2dfb7691243e746f0a68ef695df223a95a93d314e8be30c9d3c5a81f1ed6d928a854d08688caef3fc6ae7b46bb3009ea05d879a152d0b84ffcd2759a82317d1809b0509bedcbf0f02fb8c456a7e2c7644fd54920837694bc0d52895c54320c25f30342f54672416ad470ad3ab81f30c57b36a3fa4a52034a42c987084e63442d2c172b4d0af459142ec5279e97ecf15fb2d95452d07a448910495e14b182b62f23447c608a8920abb0384bb7c5985a5b23940a19ae5d0331fc781c268d8232aec1b116fd2e619f6bef672907293cb0b75255c6190c8aacbb3590ec7baf8e8e8812c789b421c9864461234426f41a137b2a06fb46f056b2427bd8ad3a9b543cb3dad18b206834cc81c6ba0547f926b2379340d514e46071fc7476297bc7558f74e639ce26570485e94beda6f0c550bc21810662c3c91f3040eb835d3a2cfdbe3d52979866f882ba4a0b154025ad014ed14f522cf7a571df8d1f524f610f265f9382cb25be8938c39d401441c560fcf9d6f095c944987d0989c6bc5b340546eaecda18228b1bb2d6f8bc44133eb5d4a1b76828d4c303cf05b85e285081f4c5b6f51376a5e62d631a6304cfc577be13e924ffc2ce47da469f5ae429d0a4d46a90d8a13c093f15197bcff9737eedb294f0bf1d824953b9d8092e25546d00be0606a5b63ed24046544e89c7cdfdae122b25e31123a1f220e7db2086ccd83c8ea118fadfc9e2286a8c2ae685b101bafca3a6861d3ca5c3be84f0d7f8135e48d15576d686c70cb33d0c55901fb397a2c08c721aad5da791dacf4074ddfc8dc4964bbe5b11fdd3f8ead08832be1bd77d0f81b20cbd9f854bef4b87902280c9bd48128c9b0839d65b24b97499cb124a9ea91803898ed532212d5febaca6c4544c10e6f9e4124434c23861a76ef62cc7436e7811757c81d542283e834f2fd3416739b525849d13134c2d41d1481365e411673dd554b64496cf67d9e7d91f635b575a93e3527467d4be610b0a6eee549eef8df3e30a9ccd9154277803fd2cfacfe3fe766ea206484900b330147c43b29476fedeab3d4a6b8e947e845aa2367a8f49da92553abe0172f74c76605454fd14aa3b63ee9f316c24329d601a8c39124e0ac982482a84d0d8e889817bcce414a15e515915d87f2389a40f0a77c73be9fd43a0a4afdf9cdd07a5c90d6eb3c4a9f4782fb2c3221c05af33ee0c5f295bfea5554748952fdadcb7443817637f76bdac4f17fb32210adb64f412f6a9084de8d9a7f13ed4321c2cccbaf8dcc6ecb24cef9b3708528c960c1ae7a8e45556744c499d9b025dbcdd6c9ae21bfde89804e0c212215a2bf9c3b8298e45f34f79a61fb5445bac8cfbe7c4ef427ffdc822e7edc9e56056189a49ffe6c3efb10eef2bd70e80369a8b1bd6ae29e5bf77466b6636ee0e70a3b385ccb586f60412cf0fbf0c213c809d26e9d8b577aed012a8de76ecf01f3e11cb534d7c89c210479c43d44a0a26cfd8052a8fcbbd7f83e92bdaf0b5842a7334145083548d739377375e42f46988154d75ac5e3bc4551021dedff12ec14e290f719d2e6b85ddd01e58249ba6db29e9ad2db7445977b4b6192c6ba1c482636d287c11321869552beca0fc870929cd7dfb00ca297def64be6709a67e763af3f30b616cc6f2a2d25bef72d8af553766d35e2e6b0d53c50c5dc91e8374996ed2dc73e65e946ec7874f0f2457e36c99654f619f7d572a6914aecf414be8d4ae608faea609d38b55212ee3853a1651c3c2f07d5520e4aa20d6d57a4cac5ff9b4e80807c73ab7d366bf427519db9473e6f40387dfeeb85fc9f9c02ba52d6489d35de5a94add69466de748fec7dc9b199208073ce78872f2b984c3c598fb738acf24ce55430c367575e64ae5a9dfd5cb664b5e528f21f7ba16564861b533240ab18ce0d7b8b72c86d4a438ff1d2a3cc1dac7331f6c785d393b535f6ef04f745f79c5be5246470a92fcbe053b22628635d7fca8d3b637a7c0d0a679c2fa0373afa7894a6859ab6994e0a933e58915e3de243e05c77a5b819275df0e5a140acac3839ab1fb009d69adc0dd78ea657e3731aa7b4b444385f2509deb99fea0bf909d1ba6b8603198c56a76fe5a5d076896a7160bdf5e833182204a5bd704aa50afc2675958b5c13d3b8dcfa74e3fa936e0198109c89ae8bb50e21094e5376b989843da62de614d76f2a3dfeaf0aa0d579c4014fab53ca7c5df28d682df58b93be01c63d8243b69a3a6d7a16bcb40fd1127fad7a52615353101a6765fab13927bdf24810e2b47e33d313d681929c22d0a91bad03cb2174ba9080dbfc5e3f9e61b024bbb0d24aa270c8551fc5dbc207b087ce7690b3b12b216014e59c978547b7a7c0b45ca8b09eaf0a1a3c1cf67d0ba8c7ffd69c46918f63a40136fabe889db164c54556a2b7375115b3f6770e22110a09499bff6cb6748685867576044bda32cd1df136a57a3506ab0ae637c0ee81b6bbdfefcb4f9e038bd5b43e9dad7d0837b8a7fa6e3ef05e5d4236855c8d489123e118c4b9ade7b5b8d8b85fc85219809455ea3a39f4d243c5ab05ce5d48dcfb0e7eb70b2842fcbf7ae33e751f42b7a4cbe04bf7a2b91ac2f4dd32d09499b2cf9524d68d637608d8cf9d863f28f7916b5584ab69701b8781d6d14cd4b02c1b01c3e776aee8135c2246e0416bbe8a71efa1fc0d719c0aee0ab1735d3ab70ed0fa2c29d739624e2060564e1a224e6e0ac7434eaae4f47ef3fdf45b9e735a9ef5fa71be3150a0961454dc7a15cd2178cbe2eaf92e0355c88d09abeea264e890e387867107daa42b0a2862ff6e8445fc51de669703936d0bfee277796bbbdb9945480a876a654a3d2cff2245353d6f93ed4af196f0c0bc5d67398230b21bd2f46d4a5ae0688c3b33f136ac4c07a6388b49a9aeb1b34ecce79eeb6ec76d350c30b5bce503828a607291bfb8fbde5da295afa11fd7d56fe66a2838e90d321896d67aad55018880083ce135d4645aca0a0ad745e45f6dc631e76c382fe7624219dc30b4f8c0f8db0312a9bfedb9cb9a710988233b4659029840656282db13536af66c5dbe8cb681ac178fb747426400b47022f31c95d11fe178e4e172a8cf006b3320877291b98da5bab29589c85f5f131b6bacb62f6bcff10142826f61924c8824ca30f260057744a0a02be044efef2a46db010fd363e12ce9f93cba8ef2d2be330d770d8ee18b46dbab71ba7269d039107e0dac93076200161d0dad6922298f798448e1d2f36e5b82c1b2f588238b73a40255b55e73036e94dea8e8bb80d5699aeb0f61df2ab6ead87737c14f299532d5f2e875e3e43f8589177360980a69cbf2d2d0355f3d6d28190e26a38c92f5bda0fc1f41bfb94d0c9f0cef632e4c5e2e7dc5e687340687487de186b8eab464ae520ffa75c68c3512c513c62e0ced27bc4c663b1e34ff4ad13e112d4a88f0383f0f5c8ef262656937cbe15b598a0a6cce6ff937b9e96e7f2a822d229099b7ff2960fa78abc021057f2bd36b2f0cdc8ac08c5284cfa64255e3bcfbfb7e32d50939f0e533cb5db14b7033df33850d273d2a9958e107da260daf2eb81453e73db3489661b81691c90d9b4e3abede38e54d3bea1a2c3b9fc01258f6619c3af6f93168d64a48f0679d77502c15e535521013ed90a5ce0058d119aa48a3c1477dca46c68d46bee35d106b12f881971ee4c68c07f23c48b5b7b9707150047c15cd8e17707091e0d2a4cef7604ff80366bfbe6649005e899fd8d9a3c4abd41b74066ef60bd9153e800a8ca6431324c0094b137a5dd1752351246f73f74db940c3c7e92bcab006ff315dc8777583283bcd58d1b6ace7ec57f1fc45926bb057d291086222e59d1e98ee723249e117e7513bade59188ff92e97444b16887d123e014d425cc18c447f4eeb1d56333d2c862edd712b42f3d401f30f52fe7be86b1c4942c9e0672fae70ae8964b9f6049ab16580a27bf23f24d5245bc452a16ef35c6ba3b47f4f43d393c9c957295a5a170ebba2e757e7df8aa4388e316603e0efbc6f85533d7879ccd8e0f38312b48ddc1ae4ef7181e75efc223960c3c9dcc311034370100c9769a2a9e4a7a8fc013a3473548736aa4eb220f7afa8a334b5a6975d2c6b7e5e261d8a031979b4b6659babf97f0b342a7d10927b976f3593fa1e52c3999d5a6fc510d8a3c5554a8e2ac16da79f4f6a0ca9d8046b541066ea2a4a1c69043354ddcaa2fe79e33c36d0fab03f95d28df66aec703edc4f8e67ffdb96efb5f33189a49d91466b1a76bec2acb5dd7e0d7dae76f4d512058c26df6bf5de8e117cf98cc413af4c7f4711dec9ff62a68ff871db3220b302fbab6398634a9350fd2df30a3a6df5932d12f2cc799234e18ab1d95ac415f8122c160988b1dbf0b4c4b896d7d5443f36bd72dffe9a434e0a70a2d29c54a4dbc2bb0f44d60490eaa742c63a8cf71467e00c45099162820305a447f85a75e182ea905f3e55334ec1f6042b30c3aea4485512fcaf97e0e37d10d09ceecd42ea9c21a1c7e131dde06cf823887b9df40a65d5d6bf60d62a328a55f37ae7b2e226345237869f5675e8a2d53a493febb0bdc899db4cedc2c78e1e902162baaa13ab12d2286cb035de2d2e3d28bc36fc60c7bc4bb934737be4c5569f826ceea26211d8d39a456ad7b87e43df9e1258b6a5cc70d00bbfb861fb53e24e70cbeed3a32d6a56b50181e0241a9d06370d4e62f5105bd476ba0d0aa74c8b550a87762fbb1763eac91ae5be80ff76a3d257284fb5034d66ce597c94c50953771aad03c6ea1da4103257900143e180be88f12d46a623453542c42732030168a9b68d0f1938fa7aef84f9744050770151a5518074f55c7b564a5669237ae7bca00e311b0053f26c63edb5c37e7499d72d31bd592f5532574e8aa561956925b6cf117e0e183a75e7d46df2aadeb59f3d362fee3ab09851658ca477dc3e6a88cccd1f2cf34c49af5b1cf1176f736b20ced80e6bb06c02b6122c85f5b23609ad4844dc033235c3f9fef9bd09cc30b277ef90548082c3beb028d4ca26d5d478da173db663489352dcd53335020da920aa8b4f1fa000e6caf251391eec2fb984ce3be352eb8392490120e684f9259aa013abf8862852bf107fed43d63919fbcf17ccc9505da9e4aabda799790791016f98e9bf52f3fc6dd2c36af9530c9f753798e97a2fe258923483d6f06ba4da6fbaa075f0e5be75442bc2f19cd4a8a00b99dfc642a89230483c670a6f79914c0b66f9361ff94b9f00de1a2154acae4e8c36f7ab9c46de0c93a8f4ffceb37975f1eb4791200dda69fc0202eebe4a389c877e81e182f149d56da3ef9d2b8780fb1d2c6471d982a710ffaf70b501d499d7c714d3e6c1133565c1775f5be2790f19c2ff2ae7f1962779ecead0d93ff4a4a9e38eb4e247024cc50fcde0ce9bf51ca0517755cc22a6fb708e80be4103e871095831e13fdcba5f0cbff942e1238c45688f55ef372b91aafece4c86766899bc7249828a18ed33f26b41aa8248903d966977962313a7e4c1f89106104afbadbee502a41d935a5a015444ce2eea5cb19a318aeed616f09f2e3da26425338475765849f2605bb5e5304fbcf4f95fdfd2529a45e1bc2f033782fe4c0a7bcb209cec8220c8ae1c06e45cd6aaa138b9593407a21b18c58cd5267cafeb683867af845cc0a1debb82c379c43409426dd8994d490c2217ba297ad44f00d8d317bd0afdf90bfbd32c2574f22e7fa6bf34909fee10cd4167b8a6875e9c6ddd6df3f6d2db530b1f9417e603b3b6daddb4400774b45ff515e1fc75e5463b6578eaa8b06eff520a8c3b716f39081c85f0b34b0f0da9b47be0aa9214fa9947fddf3038f1e360fb58d27147897e3f25517344793c182dc1d991f9fbadfd349aeb65276f469456b61c8496ffab5567d552367dbbe9f20ed634a1804393f9003c52f6e2f30f0c71c4bf5239799873d0250a7ca54a8980a8284abc0f9e7f5516d1f4cff2b378f33f664cecd3daf6a15fa368803ec3176da71c8dfa1bdd24ea67392c6e658001d09cbe0cd997647be1b5f19a399b61d0a265f48b6982c40b02af7b0537aee8d9a58c01f6c3ca5cb025e437f7aa2664b53f8bcf27f579e8262d744cfb2c7458bf87eec623acc895b957e0f6ebc1d46e4c3d2bedd156b2c5a791018242a710d2ffbe01a42babbce6a98e01b958b54e2ac95eaacc57aecabe28c1e5924ab6cebce07ff062774601f46911936da30974b405008446899f7357230c74c26e28f9d61ec241edfdd68f9b4fd1c5332ac365fc7f3039efa7445f7c55be15ecf04b136b516e7aa6c98672c29e4f74d8ec516d7c6495d35b6994727c619b10864009756b709afffad4a4e104500ba38fc17f31a2803cfe5c5f8eb58f8ce23a8d67b28086fc104ea7e6b843c3aa5203b6d019f3ce467e50380cbef0c412d914b667635a92af38027b0a625690329b20130d952b278361cda01a65299da55c865a7cc80961eea5829b76f876e568b89f9294b48e1b4f0a0e6fe03384f153ed9f8160ac9be79445acb8af13ff4a603d4411730434f0bf44879278b4723d633be296bb18088f6fada3f4718b1491927f26a0a57de26b0cb00c80e3f1c5cb51e438f5f150dda740c8b9beb2ba882b57bb8134e3f37b9717cc9ede32ec6a0aaed798641c0922e84cadcc2fa9e1a464881e4be79016472b1ae215e93a3a25cba603c70e6e659f2556f870f3f0ed916cdc2f1ca02b39c30532e3d150122840b38cb73f18adef58c8ade7b6923f32d7eb0ade3fc6936acad5076edf569c8533d650409ca17735a07a72630d35dcb9b268b4d3a30eff53659df12074a41f2059eecbe69c5c0e87eda5e2afdb8bfe231377284385944bdc1c0bd2f3e4e157fecf2961573a4a024b6ecf887517b23028020ea39841fa5c0a8b59cde774d0b7029d031d645ce0cf33cab198628114e7369a17c6cfe413425f5de3ddce31ee6ae0d026a8e09186b833899f2e050a56fab525ac086e0eb95797576c523dc26e402a51f6a7fb818cc829e28906b7cea728ff2a2b75c2d537db2bd2a820212139777d97cd82cf05606ebbf6335e35f64e45b2be5c74fac486e5f176242e12da9568e1cf01110c1913e6df065a12df6236cf736a3b4fc2124f11380871ce6d219a53634a60525e7b1d027726fb195e81285808aa56dd4c003daac37d5d748a87c69a5cfebbd4f6be476041628f7cb7cd6a2c77637460fc5d49f4dcfb8c22e1faa895a8d7d38072c45c9b68a92449718f0ed41204e3d55cc09ec9bb6b067f39618fa66c2f26189b66d75b9f9c2fb82b683071f33f2b793af2bb2389955a6d45e014fe4a13a7f680cb3f041c19a0f739c54ab9fa7bc62addc67a8446be3b05a4dd33954fe1642199d5d9bffe480b7dbf7c0f693b80c513f0848d5ce1871f1f7136ce0a474e8820e137f12f23af030b52c296ad28f6d28862ea9523546891b26b9496da0f8a8b47bef68b8c114c9d2303aabd761f5b2e54b59b3001642c5c85f46255cec45d054ede49cb950f0ef4dee0343af4285b2304bdf8713b37a8e0328134a20358a57cd9dccb1d3bb1ac64ed681ecd165ac815a91ef7c78a81a36d6b92d29b5ad96bd1393e160f945ec3ad533d3e33e0d38e3bf07caf205ede473eaa4258f5a30627e954db5f629b9129822244d82a09a483e2ddfb6048d47af8ddb2e08c89b06deaab0352652d40c049ee2aa65eb98b2fd606dca0a29f2e3a680e288f8a4247da366ffb35d7248c7abd1d14ba84bcebd477729468b2c3bd259278138a8dee6f0165fc6cea7b929485b8d59f981d277025a885f502f3f3e4e7a0226d3bc2d7069930e30d03371f2b59ceffce5f18ab3c0ff17d5c528ddac8b9c86376bc81677753877e1bd3e1e806642fc65b9300648ea0c79e5df1c45c6f7c76d9cfa47bc7b4691795404ec6db7d84e4d41afd06d6fd327525a1b9d78fddb60a90e493bccb523af1abb6320fe8837bd73502c7efa2f0477aa0dbd12617255260be17acdaacd8dd34cea88f8713813d9f03d9b70bbde3aee35b13faa2819d80ec69afc45b8ab2759b2e4ed63ad40a0f6b1bdf21d15fecee68d07876eb520a7160a23fa763fcfc5459f69d65da0b6e54dc9b86eb7740471910db8686c275c1c2483d23d2e5fb8f5fae5428941aac34b1dce1909a4ba59103480d354f6077fdb1232271091f68930eb509482ee535807561a3c01bc5ba58145bdc911455abde8e2b1fc3df63de24d23f7944edc82679257c86615e3e610a4928bb12ed9e572c4b7d6e23c6883d406437a745b465aac850e84e7f19f7df78e20d6fe74c798c345a4d4f97c89e08a6db8fa8da266aaf4bd5f0515780dc7c55f8d842e88ca705f93f90e291eecb09a90f3aeab47650027bd410cd5eb28edff9630144300aabdc3fdae6e31202a3bb1f956ae7cbc521c5b055052ead9b3933ce7e010eb0b642dbd462494e9f538a616ac4fc215508c734598e44920acffb4a99cf8ebbbdf89e2d76f6cad1fd0f78de1e8be488b689246bc4dbec1f692acbb2efde61b8589bd4cc05b0f8f2349c93d787289b0dd5bd85ee29b5ed406e292717de5d72c4fc9b6277981400e6059987fefd1b5d474acf3f886f844ae7bcac9b70dfd1325ffebe96dd00927b3a819d5d9cc3c42c8e713ce3bb301d4237b3d6af8cf0b1c2c48422179845779daf557555a3c783d49585a66237f2b44ad5a0832a7564becfa291536d5c65c6c49103c50b7d4bf475d5dab3f935a2013278ac54755694eaaebf42fd3ae44e8f505829091c28eccc004c56b7bf31f51baf3656ae5ccb8c181d80912f75f156fc7c672d154f06ea7d91cf9dca759403b58763cac74a1e65ab252effa43d32fdd9eaf8c46f787dabf26b1c81614d022d70f414afd387c321b3ae101aa47df0bddbf90c45f19d52bf6047d0335670f33907912f49901f215e8a6dd55a46d1c189df6f53729a09dee3f44f8d450123c5db53891dc1d5f23d04d0810a12c006784d79a1ec7afd0e9dfad9745dd7dd77be3e3ccdd8ece3521027eb138f9140b01fc2236e35fd2e626126e43819b3458dbf81965d0a91e2277156bf671a7b1e6c1d2bdb384706346ecffe85edfda72cc6776303df1c90efc99a97a119a0046539f6ba6b58b26a0f9e857855ef8c414d291e66a7c9116a7dd53b9a57fb2013ee3b6b4f0c045f0bb350b0447bdc5c6da4a158cf0bc421e741646cbdeb08b507f624be3dbd201165cfe59a26187d3ca3fe6273eed1864e7729e7045e19403dcb62df3c2e0e31aff3ddc1b7e8786927bce52dc94559efe26c2cf400fc6a4b27db1a7727bf12450a88452434ff69ebfdb48b5c06395e209a2d63a9a021920308b6032fe0130977976ccfcbe405e772d5700dd45511dc423a55124d0e372c5a718867d46cccef18d4c83f45287e2a8a7a14138564bd92c0d1c9d402b068a64870c6383f2c033fd9cad78468521d4cf5dcfd63baa56adb554b356944cbd7181d6bafdd77be6f3cb4ae84cb8f7a90027e31061c4f9371dc5985a77d0106c225bcb1edac7810a976862d7979b291699a3bab57b49397be2d0aa16cb8b915632fef952b5305aa48b59cbeeac323b9a465124135b434e5c045638b88667164e77b2874b1b483a95c3577dabb112333b4ed0982671277ea3a1e5acf1b6cd42a623e95c6a14b1e0f09eefb5901ffc0b7c57ecc760c072e2629b0b4b8d14962f535818badc74c52efd1e33941c2e1e879cc159285fc92c011ba7be146b40b94c13b522d30b728c5340460f6986f1e101ebec7d2b7d4294e3862522f448c78688d62675d490628a71116405ffa165a8987cefd70d9680142e15cf4255affa74af20034bace41891c46832a5db39d4cd56caef5eab767f47e0eedd9ed0dd11576f1bc35d97b7ff8d584b4bea088b895448de713026b14e23d042f656dc32c7651fef21c018700eec07360ef3c4fc0fc46e816944fb03bb9cf5bd36b7a2fef8e44a9299588333222bd646becbaba760011794742c455efc7f5f3a4ac970014ea7b9008097dc1f60429a5fe4fef64d882b27115e2e299fa47903ace95cc1e6b53fc2c6355040f0e81a36b420e7b056b318129f23c67809bda09d270544b68dd1ca6c0e3f9bf517daa7af3e2749262681394d66a7fd319addbb5aaea088c0ce291a04e8985459adef9144517726fb5c9667aafd10e6e450891a8e0526b9d9c9afe9ba8ab0de5577f32d4f60dc6f380d22718396ccd999c5ecc1405fa4b4f3aa1813666c16120434aa715a42d9f35cfc94d083ebb34cf3f7d808016d4459cf8dc9f07a4cbf6d9d4b41cd009e709f04364651ff4c6fcc944efbe5f134651911f1fe8f0eddf79634ad752ad6010d27450d74399341e9293eb3a58ac86185c4f01e9022e3217c5d9924f1abdedcc615dc2eb2360eea1293be43042211a2e37727ad6a92fdfdff11317f69348a59df8b151dcc4b9ad4673655b03701fbf839985c4049be353d1bf751aa2a478d9d2d57f7dd37ed5447761d7ec10305273b56e0a5d03dbb870a2e6416fa471bb5ee2ffa020fded57155121ed8378cfea8b41f77de5a997a630b8d2abc223310740185fe63fea5b2409aba4b491bc64c7d7f06c03bf0bc933ade5400aa041aea345ba723017594f59cb02319215ec85d929f016f551bea7c4b7962fd5cd343c03b67cde3765c5d4f6bed49ea2588f18678bbd1fdf5d1644bafcc87906c3b9e48b497f5196d0d44bbb25fd7a80fe9e34861bba57b27c6eb0d04f38e82da8417583901f60ad74488e1388ea2d6505b9b5d46539868123b3ed4b2ae2e61e13e06fa7d11b3c8fe6d75f716c149331ba37b4a98c42e20decc1721b7591ef21d21f4f74fb9e0d246be9e6eb0d2b0dee1635d022c2b020edd9375daea791b745c3451de30329fd8083aa93006e43267d81188d96b527f76dd105774b1f39b8fdf8bd362ac2b37d68be1de34cf9a811353ceb1d065296bbb4904ebc42917f0188253a25a93cac68c8ab05c9063ba18ac9d2c17276513374c7a0f23aa710591b91b5394454d46bd1cf4cff3173d7df2fdfe70d564e7899e96b87101a2f42735897c5b7547bf2aa03982b6782499d7b046ff803ab5010eb4628963c1f9c5f2fcb1cc1b108e203f258d17da37770e7bd6d66a6c379a6fe2c497040ee14339bc581a6f6fdcc31cf88beb79a33a95c6c6cc5d41c67c521d8d731f118ba6e1b0a6a7fe79cfc90417c95698129c8fd16245bae143a3d1d94b8c2bde30b2e93238ab55cde22e9b18aa5adc3d7647bc8135a7d18cee0ff82a45da80bb5c73e2e41e8123137fcdcade58890444a7a189536d54f85eee9330fe21b0f04c1a9ffe962cb91610b86f2d69ceafd90aba74bf06e75a46e2fa71d3909afc311e6b73c39b62185cce291253e2ca1dd4d38baaa93875b6410a5ebfd817a304c7a8208c593b40b7c6904d29ef6c80c759c070e338636a91b5784f1d0023ce510b8f6656c008af934e1293b2ca1f8d468a80c104ceea654c020adb00d06cf00a7aed2fe66490903dd8fb453049cae008f51cc32e02511bd0f9ebe4251fc4ae3a8a41a6b4cec91c0a57df2f2df04e8dfbac845bf54487bc68caa04387ca6469d55bbd9def6623058cf41d2247ccd0ff7bc373155bfacc217d75397600e8180dfc3a0b9878c25be142436bab2cecb29ab807f04abe3a2e6161439ab8c78c28b3bb861593770fa70908f075e9449d4810627f55d7c45966d2d9de524c1d87db6c36daf8548541dc69c34c93dbf05b43dcedff56a4f24edd6f109248efb98a8b990fe59b8da8ecfec38f2fdf2cf54b406951e099b6fa415f32c844953c695281f009ebb58e1f33abc71648894b8176bae450776ea36b7962b8e44b8753bb1e5335992d6c15fb819fbb96cbe6dd6fd063ce5fb6fc1d3a31ab800a1983088408f7a826fffdadad79b4dd3a311cc199fb22f1e37a5bb92813f1ecb1d6e0f668edcf83bd77c45f99f890169e75c55f001d70d3c555bb15fef5853764a8b1a890e6c2e9630818c479014c4956b84489c3ebd954be723ce5f2a3ebc0aa3a83e7e17e7b430eb727581173e919920717e378165351cc6094fe1e41f32703fd1c1421dc424c9203c46d4010a03ebaea038258488320509ab0ca4c4fe0279095193718328b53ebf6b417482e8a5707db3e916e7dc9a2f66a06dd42256501693a59bea982ce19b27a9cd0936a64df371bf4cde9732d09c27ef92ed369c81d71ce19d0d247213c23e0052c1a8a471b88c423b8a4029d662d4f850dfb4398b0b9b4da6be241be9ed958eb82a8186855db7d7b1d05280554f8738987543683cb9f879b266eef11361fb4ca766494015d4a429d2237a80d5a3c3c62a77689a2c23d1359573803b12d3e3e03282798ee5a9fe5bc1e115acc6c95bf495d78ee902841d8f7e4d2e951fe251ced65ec84b1230877575abad48ede960bfa34d3ab1ea3374d518c30d09e53a069f3d9700eea22e425d388b8a7b863bec383fb3949b0806078caa208c189eaf4fdebbab6b967da2c3aefdfec2e49885d308ce02094128d02652642806a1f45f18ced64d38e752835fb7fe2be215d0e1418e3ce641aefc8fc72054332932fc21e5345d27d020e847d7640657d0cc08bc4510774e059cbc2ded8e376e8ce8620440b80c54cf32b9e6bc2f16e04885cd820277e93665d02bcd64db3d0809bee6deb2c0c153de574cb8d831ed2197d53337473dbeff806c4fbe7b8041ed2143e84e2c8ec6f4d5d4eecdf23ff43a34465124e92dfa15b0bd4dc623daf917d0d81dd6164f48493ea5ab7f871a3acc1efb68bd2f28443ca6c28ee743d6a5fabd685148cb8f2a2e845a01fb7e57b98a1192a31a0c6c23d00fdba545effd3b63c6047f6c7b535be5b93072bfb159bb7adb445b0926ebf058166e134d06585ff7861402ee0261cfcaea05eb238f5428262ddf1f86c8bf1d50bd2aa9d30538ab3205f3ea8e516d9a4fa1e57bdeac3fdefded3f076f5f18c348527687afc3f1df3368d6908b9639bcbe8399cb8b95750234179d04091e708d22755b2f564b1374e5eeedf3f956ac9f3630d2af150780391aff4dfbbf50ad708db74d52751f4af717d8c98227ef612719664c5abe639c7d036e18143a907c9ffd871258ae78bee9762e84169eb320680b6828abc84baee69ffa0b2ce3668db28ac47ed8690e1bc38d8bea7da092238a279ced8498f456e407f6fd2fa18bd3dfa269bedf2986587fe6499d5bae3dd43a749c34ac84aeb4b5661c9982d88895a54224f1f2f141b6adceb03529ee35b00dfd358fea9a0551233687dac73657a5a9fcd1d9fef1d0c1ca3c37aeffb92a6bcd9862e5ca0eeafcaf924241415567020bba20d7b006635ac52641cfcdb5fdc5c169ab41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
