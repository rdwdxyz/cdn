<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5f7d3e6a659858274b16cee88d8c6cbfa156b20c534f942a17f34a7bb5c2c74bbe03c8eddcc8e2b7c1e8b6626e9a97e535d8c5ffe17543ecbfeec35f08eb743bc64ef8c4c65eb86e607a39b4ccd4a9444d63d24eaaf2b136d910e3c811bdb758656e5536a9c6cf88d4a269fa5db42b7c0c1b0c362c283dc463b365d7a8c78213f435a4b259134cba3e2e7a10ec7a24baaeaaa1862eba29278b45253dc9e09191c0a0513ed23afe884e73ad558b5666f3683a72ad5df3fd9e6de0e1bcd17deb43b1cc201b1dc838520369283c089cb7490d4187bfc12547bbcf9c23fab16e99d098505e8850434b39b6933fd586299730fa8993bf0aca82b70e83cc5501718b784e5228e2462ea25e5172fd91b4257c7357697b222ddfd6a256a609a537d51d9adfa78e5c43bd9b99fe4826bd6644df9f0e19d99bee300dc2091d7848749b2cc44f87f1550453c9834d58d1da52324bcbf1e3baf041b450bb69badc7fea4d4c68bc9f7262554579347baca0580d488284e6cb2fd65b6fe0e574a654970fe457bc1886000f5f080bb22d679574f95146d9333a3f0662c4215a7ca65f8e05dacb86a27cf38a9c81a85541fb75eb1f7ccb831de17da50f9b1e78f74523c826495ad86fee62c24bec2167e95dae7e2068e5ad0bf5618990b16fde1d22a90483455fbaba6f5b33bf1f6cdfe4208711fb96cafab627440eecd05784e7b15a50389211b198286f9200ac277b5f5f66042ae491a4a26742cb0e25b6a1b405f203debbe8a5a95dafbebb5f230223ab8f8c2fa96da550e9a96377841a1c179df1882842b5c4c4270dcc5476b2397caa221f6b8983d1758249a0f084c81e5fea8915f9048e8a0e7006aea914c6adff5f25b032b9dfce56b943bb74fc2a94df726efc33f2104114d92d4100339ed64c4fecdc004e3e0c7ec9a0b6ef2bf1cc5aad321ad6df9d227363846201188bef7af2d9fdbff39e6939971ef874fb70faf1f31c5c0a0b07a10a8445d7ddac21e370cc91a3182e69b8ccc4f21271b28add825876646905e5dacc47271b73ee540acd0e79ac2dd7b6c4607cc337abac30d0efd055a91be06443265c19a611c213c2e9638d5b821d305f2b024eee8a2c42bd8b471f9cf3262a10a6fb35e88f078c228ca120d6f286501548fc373d4500e4d93bf524bc64b78a60864813bc2f3671eef4a0348fc9d10247599553fd9439838665b2eda0c1a8bc19c26f87ecf6495d5507f3b64c25a029c92d7be21947ffadfc8d1553600c8e7794015a2235d6d67860ce031e9b0f3ac226e21b1d123fc49bd0e08eb8e6cba769a5faa1d0336e10a6bc62d82788d27cd4cd26bd7c3b9f5e705a9827e23bc59c856f785146ab08efe8ebe76e3f8b13f6b3c9f4d4012cc98a4c5e0cf178a7f48cf24b8df28a32609126852b9f32f47804539218154b04bc3d4581240a1047c40a4abe2ab9eff418aa8feffc4ad31a104ca5c52e7dc59d8ed9600a8d112b60875142f37fb63ae1fd4df1afeaf21d3122c40c0b4c160cfccd2024fe7bc881de6be4e56a657f0d51de5fdc14264bb947b2498de9d590cb7f45ae1af1722b788950ca6d53097b7e40f0ff897ada5a796a42486ac2208244f2c0a08985b1436085f9a20b8854115f80a803230c341c37288202dd1268c2b9e81bc3292c59f4c4139bb624c401884dfe06f1d29ad89f76e28c3095b6b3d35d410d37f74710854c8fd546e1af4a5c2544da8fe0383b146da7c09a7af6b87db93d6ad25bd10e4013f6807694b00c958498dd5cfc440e62a26f079b4bd0d6974cc24f87c90237228ef8fc77a5d967405ac3119d65330414c1e099020800a083217926e8abaee2400f1ebe9507d6f78b98233b91c891e1198f466f3fafcf28459716e9cb702e939d6b6c5f8e32ab6d194118d03f23b0520a48e98ad49cb28bd1761accbe24e04f6282ddfcc708084c278492bfeb9258ab7175085dc97b24ffea25b905a51d90fdd1a25e5b40a43caf76f66dafe9f885ec94dff6c7cf2effea666a7dd877dbd7ff65ffea0ee49274cfaba2aaa74241b5c6c09fc76d1f24e3b3fb3f0f279ae2ef8502efbfd2d5446b88ebc62a19d399536c938ff105c2205e154f86a829f253fc082aca93cb5a3e95cab6db8c279173a138e79f14a2de75168db8f73b1ee4dee8b0227586cd87ffdfe9d815041566588928a54b5bde232aeac73504a0d7fe6d72234832022103735d8a5efaca383844c6b4b864a3c2994c19babe71261754a12519ba9c307daedf515cdf5a4d0f3982af5a31c16085efe8bae779af31f3ad2fddcb63ea7a22f6ae70168c9f468901932bc1fa38b8445290566ef01fa21d752bc8d0682faf2c78199cf0a293f860ddcb77ae590944d25f1829a2ca462a47fa9af0593bf5d229ef44ba812cf082e6e9cce88db8f59a515b64cf07aab467e08ef65feb515335aaf7db0dd9c48eb4d720f1289e0a8f10af085b54decd8c60247e3549eb5450f14c43afb05f58b4bbc5f70a82d5491696142005517f6e5ca0cbdcc8544a7f4455aa2c9b4bbc5b781ab8a5f08a63eef501ebf59efe7c2ec39ffd4b5cde4665ec24dad3309b57ac49e4d3c83075c457d4f48228652a0c308f6d3f7ddc9e9f4b113c6104f3c118bba0f71f5ac3250f5bb6b019600a1c0e617d2e0f37f8f250b0b6ca1393f6851dc8cf5d2f9216aab20bef0dbdf5f2e9b09b77bd542c63f34f11eb9a723a5ea82f1162f766b589863f3fdfb05e1ec7ee1e14e34fbcd40bd26dd4fe022d8f16b5a42382853912f540e55dd8f903ae7622a52c1f9f2e56a3284118548225caed16d25d5f4ade4a52035d8146f6bcaa4c74a81365086789bd3c8745481cd29f021acb9a4f9e913fc44a953258c7e1ed0bfc1edcc28be35d450800ea482b725e0ae86bcae2df35daabc6c7c0c818b2620b065f43c2860e4e338e9c54ab759e12fd35d7ded57fc855555f63fc7541dc3424303fccb00085a1022138746adc647f9af07c9e3a181a881da8a187a56d8d62e470802ad13874aba751ee120eef9c020aadde1dcfbba42150aa5a8dd24c1fd6fc964a2be4997ec630830fd9f79eab868902eb394761be7192c3505930fd2218f12c7041f4269a9fa051fcdf39e8dedef47a7d84553d2d815d482f30576e6e9a17f4e05fcbd617b1a388031f945e8204b242bc161e8cae41a01c7c82441507e994c9f169a074f3ace0fac5a84cab657c80de09d498f8e77f91d1b2a9c9b00212c1ae0809f70ec3eb785dc3335f154ef9a86739edc7b7a3d12639aeeb02b3a4a8b953206113787b14db9097ce45317a6937efacc1023e94f79b86f26ae5ba7eace076e808604757533c7be27347a4628f4c1c9042a913b24de0ee59fefc66df2880c35986519b93ed2c1f1341dae17372c19c19bbf468104a467d90147a2aec6808d7c92fb6a778b201da4dce4bc57014e485951427e6e47fe70a44b594257a2fec7ce42da158fa4339a53a6284071f954ab7bf9ce56f7dd92ae75cd50d9177e53c08161220f00db00818862fb2f768605de7f743535f7d8ccb3741f97f589cf59b2f2185ca6377940adfd50621dacdf4c47a80c256e6cd601ef2a67ba96c2d643d74d3cc484b9f800e16b5efd780026b393d189c44de44d7b41d66ae47cf7c48a6b2a1a214df947b3ee3fc1f7f520be6602594a08bc17dc3d29e60b097d55ab45022964d191c23f969b46791bdd89a1773e03afe73e2d3342f6673b1d1751a9ee82c0314381a72e217f374633a8c65bafb750af6e73ed801b705192bd1ff911d17b79331d4fe31018f7ead2b2736dac6154fe99a6ee48b160330523466aa051256bd3aac061512ea004c5dd1d05aeffeff2583c1f40f7d98f82a2ddd8fbbe45bacb34b03dce3ea3e6bfea94d7a507f035e5410e9fd095b7b2a1c3305a859fc41a33921823c7db0511da8b9ae2015e08b533404ea8479037ed535de811e95ac3a8d9202ccfdc080a21e97c6a67fa22fdf4b9ab07f6a5e553c48967c57f091148b6e34bcc1350202b64a5297263c46dad0299aee7a47c0aec6b7fbf27be38e48e1bcee9f37bc4043369a6398c41837a11df6cf7740dfda2ebb094f6670a4e1ca65a0ad1452db27c753b2b11a394a8d362ae3848e8e19328f238663090fc392853977353a796f477f8ef8b6e66403f7f7ef55aac6742b35fd202042ba4dd528a23d74b07b2e92caa536c7e2e22cc72a1c4dd21699ba190f3eeeded762d8c6dd2ce9ff4a8176663aa09145176220fdd67924f15c996ec5db11ea09abf06c1cdd90efb056df2eed8dd12c26fa0242c7f79ac293861bab2e3b683f618dab19df0a42c372e05736ecd6cef115a3261d123d46b3ef0ea35b1080a3c502e38f78b04df99fb27232ead64fdcda0f5cae0bfd042d1653687668c1a472436c973dc3b7553a155c2de428b8e89fddea97c9e9c8ba49a4bcc135b007f545f8748ffbdf4eec02a98245c1209c90e3e183be6775669f8f01e121b6f2dd14761df2db7b878e315169bf256cf988f39de4fc184d714daf8ae18c7fc14247f1cc14c14ac13e6d5a9cec5694a19168e95c22574b34faa904316eb2b34c6bde4938419df068609ce9baf89f57cec9775aadb71589d0b7fdc9ad9bf7a22e85443c362e8b3d843fe165bccea8549ada9bbaf94c7540b7dc5ace2eeb8bfa9d3829a1c775b292dffbcf62e31129aabe2e911c4a402a96328213bf4a1f6bdbf1c385a68191a3692e4eaccf67a40bd63a8e23a1bd43369d7cfea9a76a41ade79e79ec6d0d5e9bac1b625f9a02875400f20a298849f20f9bd25aacc5d72c1729e188fcb01acb93535cf91c9bdfbe4bd500e76078bb976216cc606db3a9fe6c6fbb6e8263466f28ba1056457f06c097ececf89379fdaf60b24ec992e58b713c77459e9dc2051ff1d56526e59e48637c7f8c53d533050400e429d64e6a6a7baf27f278f2769a7e9aa21a6db1a98f5b8d809778e28f7eaa60426ad8b6dd3389a5e737f969fc748bce93920fa517a2ccaf6eeab68bf1fedb161f3c92e1d77535ab5342c5ebf4eebe489177c3048649e345c2e55d78a73734bafa943fc7ef1350d682b50d03e74bc89b0ebc16eceac19e3bd0f1b3fe7f32d3eacc76705200de5374591e6d29fd0c6e80d800bb03e7bbb02cf60437de5930b4e26ae7378e72b77a0299051220e13a413fd3ad550408cd010f77da7569eec097b08a35423c6816b5bd1f49cbcd460147e9ee6829b730b7f85da24454b61c24fd2a847ac2c9d97e5e8b2e71b0179a57309c0044164800db0cb646b1ab1b61e4c7b4cee5dabc2d5859668b8ee6f33d0c89c022a8efc3ad8ed21a69554c1d78d2af47d4f4584cf9f09834065ee17ec474c804ba66e7ef21a165f638f9669deb9b0dd9c5ece4a2a4281fffe22f829c7028c6e99e37264e09dd761233dc147f094c7986e171f627ee19e1188be471f1c7af9f66e30dfc27924954f8e5cb40d049555792b9d269612039c8f02f217cadf33d0c1d6091ec7e61c1d7ae4aa028f7dd8ab26fa9b5a503ed4879b88c6577904b3769bebe87d064e09181f07a6cccafb4b5ecb014fe4b246664c22803cebde37e6e6d0b7f1c26df302ef838db8bc8c1bb9fd7e638f2c0c2e1b708d19cf07c900880471ef51f0f82e24b6fe8af5e50a4be81ade707e90ec5ec03d8b1f76533fed1ce2f05fe623bc7e3c41f8488f5f1645357a0dc01317c42b30af6f8e9c94d95dfc68a6a4d9125c54900b31c867731451bed2746c50facc0fee38d59ca399a21d710660cdb294a69893fe63f091927bd4e0df9ab70d07a51eeb797ae586d2ba48894141cfe1580df84278728189f73011dea6a24fc4ce5781f0dbfa17a72c384650311d28f47cfdc25f5a95d2acc9b9d87ea53ad7a3735c1f206693595d803e959cedf57a7689d87103cfccabe3be16a2e6ff064cdd2ba5ede1ad09ea44c4c7b13f24bff569f48e034bb94a673e90827b97e0c52af475a8952179ea3302286990436eb036930cbba288041d6b42e3c7136b35c65c70bddd2702e4ee6a16fe9d7f836fc491ed8d24d9c5ba7906b67e5967d4687a96799d348af1ac838f0c67b539a7a959b4aeb6e50a2ca6e87f582cd4c786fab065ddfad36f58fca7ecb9b528c029a1d821b7b2ad50aa6180cc7b0c8d0273e82e425373d38e149052f1ff551fa6d7d06aa2dd540887fde6c8a2a85cae69137120b0a03b5b67a283e93cdc774286364bdd332fbbec5361f9a865367653a58e263916a9fa4bad4bead8614f7b101ce5e15ebbfba5fdd95693a18df12f1403d3943a791c5093c445e4aa7d8c30835e6c87c93e90b95d6b9c745c28004e7e22f292563a98cdf0f26f4f9dba752686041bc6e8a079806043749c8705cf734c4767619c7f7fa25f6dc5165c980564670a7ce40e4a687f39a7f891eb85b59d794e2160460b23d7e64cecc2dc276cfd970e36b1d72f7787aa7901e7142c88f8c1fc1b99db04eb8f9d051c028cc249ab5828e33eca2b22fbc285091a574e9d4f1d590c233431bbca5275293212b144566046cb41f9b6c97c090916bed009b3eac7cb6e6889ec6a8866e53e505d4fe3db97c0b102824abb23f4f2abbe641fc52b083d1648604db927bec3169ed77f0c8a7c0d0ce65b5fb8fc0d880812ec7c815b0b1634db9dca9905ef45feb59fb64d5609d2d46495b8fb361f24fa2954958db46a19436592831a232672962953611bd0d98adc12f6e0309d373aba70f4c3af32720334fff16d165444cb1931f769cec2f4f9bdd5c8156d5f04e3148cade7a30f46d166f30a96fb364c51514f1033cd7c29d841f7b81b740f83d965a43ad3b8c8dfb0d7c024d80ff5a092efa6b8ec9cf7cdaf0208a64a6ac2fc8705326903ad9009db209590c794141129d5b585d0e329a3fc7a682826ef630d35155a4e399b46f1df2af9beeafd14df0c70e244c49ff2c6c2cddd784d82d0d96aaa16554c5a5c3bdc17703f4c39beb06ea581a8de45ab8d2ddf0c63dc73bf552ae9feace5dcb536504918fb73dd030120b3f64d8d4976db7e170a695fc76a5d022b2773eebad1c98169635a32526cf0709b8870481a6d9e8effc2bd4485f750e2507f6dd20428cd757379886ad70c9e683c5ce96d87646cceabdb4a8472dbe31aa426654ec292f3ba8085959cc3bb86f877eb8be0b6e714b3ce79c4d831dcfc33e7f9f6deb035fb7bbf26eaf07b14b20e809ce125c42876a5c08dca23243384de9824f493a2c5320686cdd0b11847681d63f6f3bb71f27adc307e88b1c02f89239dace5f5b2a9e38c6e4eae15a6168140cce887e724bd9a51e3b2cfafcced7d4d9ae84b0243c54042bca0a7dddabc0f1c7c42d0bf9522bdacfe0bddda77e41fbef33d02a2903e9636dfe0f9c86ffa6d5b291a034d717ce96d39dc027e8a0ff76ba8d1721258e9672b6c610460c3a058fca1ca5cee10eef33b8140d74d092345daff71aea0ed5deefce93a20267614cdca7c515ceb928fa12508678b531d4cf30f05fd2e56603409e475fa2a2bc81dddf9e5c777ab215a90d94b2e2bcf2b7d933f5d1b9bdfcfc3e3eaf924e693c75d912aba1814f84c368d753505f351359b725626d3c1a8543bc7083b771aed81762f578c84a7e5f78344cf0986ab16c6164fd913d6e3c62bfb4c0e9dc76e5e37a4689bfe4d49b984bb5e7e068c7536d12f665963ea94c2cedb49ad1da61b50382eeeddd6d298644d1b95607b34ef378c9b16249519383ec6ce53ec3eaaed05626c7a684482107267179b386ecda6513655d521f5a689ecc4877c3c2aea1372e8730504e27a5085c276a843fe0fe555e3f5c65767e28f3605577b58f1e41b1321f7142f266349a6aee2e73a491581fba435e78f62c0055babd3e3ccb23c5b50485070222360ea92ece2162d6aacad10ec92485d65c60724327e03a3e2f92f9543ceec4e3687e605c5e14f5d3ca4574e1c9e91f75daa1a638751fa49e1c6c07955843b575b77141f228c1f2d666673b4e04a8d19b77f6fbe05178b638a2f11aa2d37bac037cfb54787068aec6c76c12101c21eae6e8e29d290d0ec13cd18a6f4e60b8f9cb05c0f9041a7fb081fc945b4bbb7ac8f90fd7e3ba795f91e26aa57533568a91eab1596a795567f1b5e686b1f5279e24d632c74da7719901859d4eaf94e7c39aa056f4522eacf9113f992eccf84bc66c31c955f930baa38ce8fb1724eac6245fd000faaf89f636c771171abfdbd61009067ac124b4017926d18b635cadd0af781e866be116b57aca463a99182b3038a68f74e70acfc2fbdf315d6c3f8d570cda7f9fa07c007aee08a042870ed51a19514e21d2f0293553b11e2ddd8f8c73f7250764d405c06aef2bd897d3dc40238e120635f8a9c838f602843a539fc8622471aa43d55bd61b481e6d566683398f4078cb48e46bd39fdf284fab76f2555439c0a9ff76b1db6563ae30d2e13c0606b28f6c6ceccfecc97edd4c4b15256b4426b5596ea2b1e71598f4d58aa78de5c48a7db7b4ca65d35d01eddcc59cafb41961ecd7d8c9ad069442c1570b0d8f38f418526e92f7232f9ed31dc145fdd785d168dbad8c156d11fb8a1e259514fc7e4229d1c4ea3c83248b8e81a9f8984a03c2f459969eda7ff3f545f5959ee36ffd8f4b7493defc06fc4d61ab18a0f7a3b0cd30a759746137d27a80bdc64e2aaafb6975d9f1228e18686f3c52c6698e919b9a45fe3cefcb4c94fb1713c7e10ad572fa7216d93fb2f4fe9a08f7cd89a95575bad89959046fb81d8168d47d21e7c8b2f811f73c4dbb5e2f0e9d096f13a808ae5f966832c40c797fbb33850ce6bb1f7888a927fd9e4f4ab8674b0d099c1f2db53cec84892f006308b58c02c7715d1648a06e2adc59223fd1ba442997186a1f9c59162c385c049335b00c816416270d770b4a15b15fd2344e3d93b368efd53683ff983f2e796c2dcd94b991b919a497f03259ed0e532ab7b77fc97861c22129638cb6dd19f007af5a7a557455ae5fa5caa5fb3ba8920d17c91e570c33c1af157b32f18164246b694297a9a9e38626576d6e323fc68634347bf87b2ca1c21b1b7d55b14e95c01bf07b17045abe69d395ed92ca17adb498052380552d11bd5a248fd6aa6192313645e7dab0ea88fb5f4a6e262e28ab52ddfc9464e5763e732864874957f361e66e61fc261942821887932a375a3ed05f6f5949737233c41734bac20f35fc6a3c891ab2553644ac1df1f359b100229ebc89e0739e41a69c918be77931f39944950f16d7de1da88384ca73f6bcf5b3e57d533600dbfeb10619d260d744b7d8651831f019588d92a1cc05ae03c4987c4f5f1ecccfcad42f8af990eaf12e3245f91a5082f71830b2c4105941911fdf0c0ea0083f90c8f6cdbf87d673b008864311b634f63359212e6a858a83e0daebcfc47a6592da2f6f1c293c8fa5d28dc25bafca1a9ec0b62a3dde7c39d0d37f86dbcb9168265dbc2650fc1ae16a0f98561467ddc67ed44bf228084c6cc0e27abe26216c7acd0ffd53e6383c72c177a67043929ff8e9328fa5dd90f6d2858c230adc5c23d6149a3f9b5f869709c907b4723e177842933aea2f5ec38a218b76722fd2e7061fe85690deaa8f7e8f5e1ddab92c4e9b58d64fad3006dce12163313743483834ad00e708457e8af6b7a135d79c169c661c4e40f3375e30949967c6408fa31b057e7ca7ca9e5903270799a8e4157026639d91c29d1379c73757474190645a7d646a5db8ba4825dc8d5a0a89632b3b8b964f3e3ba574bd7a7c95bd97b6cc7619e45bbda9067eaeab3bb83a62eb460c112d4dc728927df7464068461ccef32b087b335c11d13117f4554f350eb888b12464780e220a57ad1c05c2b3700e829a2a2113569e1dc057bcff207799dc9b5ba923343cd96ddd6df4f7c915ef3c306713aeed9112fa3c50f0b5c4ecaa490b700066e5a3179d065554734d2417a19c1e4e051a619e2cfcb4090c139971f644c8c70456728ef791c2ed25ea46e71f4dfaa893de2b176d4e3eb9beb4cbc516c3d8d4ae9a2badda570b8fcee247d76b2dfeae8451ad2ff5f91ba27a1d932458209a711f74ef86c1e452ba80de6249b091584e0a71e3ee276dba9be883436f5ae48d22a27d3dae7f3bd0df098f12402fd41e7d7d394316c452dfcdeb0c476eb4b278f1b6f126f509432aa3c15ddd1f00ae18f6a921e0bfb117c55124621b970332e041922dea53e57395d81a5965743c41006dab63f5166da1742203439f0ba15b3a19416ff55e9f12443638087c6de0cc5c16d8612fd1254a61dd56ed985ff08e60342b27af6edfea50587b505eefb37dd8218ff1477ebc106dc60fa82c324656dc2a26e77ea846f9c66da346a686269138304a558b6c89b8541303f4527d91a836513c37981993d70f102c4b41ab20999c25596d2a16bf6972381619861a5b1b7f92437f049f131e4e0dd9b89be15ca8d605c10768bfdded7eecc30e133e757febf699e17e3149f4ea9d2ffc31f7a29aa1851e6cd7efd17deecc5497e82f7d73df231f22e80b87d018fc60decfca3ff82542bef92e7817fcdce397150cd4811dadaeec4890e6c884d43d7d057dbe6462b886c10c8b6b65e789ffa8aa0dc23cbac64077c97ab765401d7c0255124f64478730f3400124feb59bee749471032f9eeddbfeda08b63bd538ef2b7a8e56c39c726b9f685e4a496661e9532dac38c231493acb2a869b42e0db52867aa12e07c5e51a2c5299007cff7487f2f23ca6a7a0f922c5577c5f61a132c9ff3e90a3a0c007b5d46b62a6acc230ef396ae51fd3585fcc67e68396dfb28ec8c6d2bb02b0b8c8606836a873bc159acf1aaee852327955fc80963f21b9f9d1b2084bda6cf6db1664d202cdccdf9197e75c69684f408ca1c00fbac09a4ca1f84f47f5654cac98e49d7573580b32ba492a096d89b002ba3dcb3a554f79ef7f61d02ba104e9d336b95acbc9a65becf4a4d60533593a5b5696d6c98b7f35eb5fd67b93a6d8e1241a2dbff5fbbe308756f0148398df0ece5903ad24b290cb7928eb9b4e5527a873bb3f53946c69726e286bf7fb4deb568ffef4a8bde423fff7e928f454e17573a1cd8948bec2996ede9b285ae700a946c9acbaa867736105087c7544f221b0fd456a3deef8694eff484a9b9e0562cb4c43049aa36571d22a330926992bf39c523c76f653a5015fdbbecb1a6473c1fcf376553377c41bcbf3a6a0446ebab4648388d47583776024e79d8b94d01529f022bff3e1b950fc0ce77aded68c9a1d63c7b49c40c019952a4e8c5e61f042056b74ac146b86dd852937e7eaeb00b92eeca62b4f95a8596335ca461c01d33637121fc5d36cd4ad4c858b78f5f0b81b5f322ad9c4ae268ac137d44e3a231b9a0d99cb50ce6fa79f0554966d50db729b822f6bb7fb36274143e7c0e7a763c2a10df66b6795a5b0c2c3e5a84057bb6ba46fef06da1f1ae25ef1d22d927c51fcac00b18d01b9ac724bd47e81beaa6e416beb91f3b756d58a4ad46293d74d98a602b8aa48e6f22a474271ff111cfe1f26df6a4f041d1e34767021f462a2f1d363bcf6b2be5a9537a159adeeaa7447d3842168c12f0244c37d6219817351654bdb2a4e4d10ebb85e18cc9ab474d2d9cfcbb9ffa528e8950e8f3a27174eabadfc546eeb6e5669628004d7157dfcfe58d63ccb84dd9c49e5a637ae3c98f431414b968bc5bdce099498b67a10aa96373f706d87ccce48300779f7292bf594bb8e5f27432f9c683d6ebaeb312ec70df6382ff2f043b5caacdeca67b4e91306f28294ca1f601650a34b0d06098b8835510c76f92c0d514d43223018eb7d667d55ac1180fd496a09802ec9f47b6b5ce3feccf1ea1ec925b0515f8630a0577a29439515f2ef552669c15301dfa6bb1f2976af5dac159809f10204df65364e1d40337e4c3a61618fbca69eb49000296fe8782b3db1bc1948c4ef5ed744ee298723c469916f3fc86192f6cbb2bc0fe76642639496d2b6caffa370544478f9bdbb38689f86e545b18d4e0413f4d46172a530f739b94b113d48bb3c4c2d89d9babfc2a82687a677b20d1303848fe88571eba2e0947cd9304e4b5ba71d9d8e10bfda62157972e31c592787fb199adfdd9b527af64cf999485318d9cbfec32920edf2055f25a30e67fd5913308a03dab785177d61dfa5998a0328e4f1ec68a27d97aaa12cd8dea30e6db543871c9cd4f765b256555a89cfb38479f36da611c569626d8d4b5c857d29cb3b9615ba0ab19f188096948dca6abbe6ce5ab954d3e3abbf5705f1fcad4af1b132d246b5ce0eb1cfd3ab20cf7dbfb1b9b2fb99a348d623b293f23a2df678b6c64e71903962bb0a37eb7baceb613873a9bbf764b5402f79f30f5b7d4db580cb36d44d43f54b7c0d5b9fff73505c5a99609b0394692940461c3f8024a87b7a9fddb120efd167838a65766249d220751c38a1a0494d422610b1e2780423d77c57b95b1c49502be9a511097821aff7d29744a80a5e1449f054cd3bfde8aa92fb19cc517d8a5f7b188d5a33cf7c12b8aa7e70283de5f9bf45665da2abbe72d7d1f3e9d8cbf81bd4a0016f4e9eae083bf09f3a4a73807281d21750d1214961077d736313884d5664de3cc1be0cc87a516cc0f54b35f286c0f51638247cdc1b311d7fc97f7ccbec3e5e060907ea51b992748ad99943db52959dc4931bafad3a85989d455e07d76f9ddcee94f429a1f332b4bac60f85befb539e5b74660816c7bb8c0975ea4f8d36a0ec3c9e84be79fffbaf7011af4693603fe6b0224018de09f6dfcdfd8f8a9bde7bcf8daaaf64e8614c5fb865587fbfc33e15cbb14d188eddc732fbe1f5d163bc5180c032f0ce95763354f3d8c48f4b8d2404427bc28930b1f8f68dff82bc15ef14d65671f7bbb469ba96af7f67bf4b4b86da064bb0f0dc4b91a09591e91a3d87166c0f7b8fac6c14c68a829753972e3330e5edca71bd4a9e789d9d0d2996810a09c3fa925a200caf989d9fdfd920e5089c029ef7addc92dad6eb29d3f786f8deaf53d0f3d6b8f24660ca0937dc171002122df180e7a7d86c0c7314fb8a3168773c6ee42a6890a8861f4b5b41e26d26db849d441cdf9085533b5ebde4c28a56c15faa2217a8ba34db7f91d08c52d16551c319145d4f9dc091fb7ca0d79849de4b1cce7e609c944bfab2f98da3c2559414eeac87447ba11f5bf455eea632ac2f0cc8c615b3695d2780f9e5eb42c9252bab5fd0a16a10be1b4a5fe32c59a6b4a43397c56c3ca8363e28e49a3aa9d1d4c51e960e018469ef6583d7d341e7d8db105582796a9c43e7629e3c0de0a3f7f1bf7de48b2e9e3b5d2a6afc99282f0fbb39bd365f8c421a57d441be664b4afada5e7a2b03e690c9728b732e74656d8cabe1d87c880233616cba03d4b1598a0f80af08d3d5e28443b2d7f6f89d6aabc18dac0037bb5d4aa588c647fac98a2eeccb4a87fc6c832a5c3a51489b30516ac67fbbb7536de05822834243ad28b6c48185a99f9b43caed66be5c74f918723701e50d0d1072116d4a9f6363d9588f5fbdd7a79f4bb717ebf3fcfa029b4a45aede412c599f8e2ec1c08c7dfa626c81bcf8dc99fecc9d5e21f5495ff6b3a837ee5ee3be81b9f10dcfc957354bfd5f291af518690d5a658fe657c66d9546eaa03442cd969cfab731c21ac7afb056fa54a2879510e143ee83055dd171d99addcdbd99810396c66c29721b62d230ef27343ffdee3bab6a5fe02bde5289fb0a97be73cfb2cbb0f189cabba642823b4b893d8fb18055c9447da04577da0ba897c8306a5dd8400c9dac462ac300e6de54873eba5c7c8cec7a151eca8535c12b924d31c668e3029611e42ad3b0659787b6632049c831959642a121e397aba0bb855715ad9524ef70509e9780a3a9279fdf20e4346d921f2bd93a12fad1eded70c9734c543e37f189f85cf0b4220965a879423b02df6f970f7990f538d845b6fffa65d9da18f3100cac3c0c42ca5860905f3772e4a1c1a1e809df2d2085b06706a5d7a3b9e8510383f3d71752d68ee7b5d00ee93df045769b9e3d4a51a44b64a74e8bd9e35eaaed7eaa8ef21f03ad5406d962dc27b8d4810a2df374607a369db5e9b166c2e448a6d9935103ecefc009d9d96efe90732c18d90e7f9740ce82bcc5eb109fb70e8c4bf4444d39a16786c0a15809f6874182c75c8a52b8fa21d0ccdc6914abaacce23a96e42735f83a4ecd6799f4c780c2d946aefbfc97604d46de18ee7a62368171db82f707f1184a72a4444fb0cda7ff53bee7365f0435dcf530a6fdf1527424725e68c8e9f68debb9cb4cf09632087325e5c11538dcb0aa42c4702e6d56a6192c1ec1c077c7252d1c153ed337b1ffda2dc53dc29fdd083161d86d305f0729a23e9ac2a62240b8a9ac0668c69e4401bca702266b2a721c9ab2c6c85f0d7e5801eb478ddf06f995af12a078b4fb462a17993a923905242812e903917b31e9fb31fc9dcc362575b7d98a574f696102930e79aa11ecc6040b559843ec589333d8efd7d8537cfe49a5c3cc5fd8d03f5322707ed3bd41d096b2a86e43fd8b8244519ee9eca47fe3cc7b48afb080c62480602474024e78c84a63a785803c2eafd9372c1e2a49094defca12b163ffccb2f8d978903ed07a0d08f285001b23083409e48a5a104f67246dc3c41c76a99919304589a8073d0f3a825abb1b897c2c90a0e42d5ce1c0ca4cafc971647100fb2f95d65b615488356ffba81d7b3ef7ad49c720b02b3ebf79852505348d9a4b3dd4aebef1d2f782a59efb2d67d5abab444a268dd17aba23430dada365589f60741cae1b5904138585ae43853b713e5c9234d08e8709948dddec086a1179ac145280d57733f855d15d7527e874b30d3f80d20feb34e5a3d04be6bdcb638cd7107a1bf02bc2d611256e7b9189c21b46f1dcc974cbfbc17abd184daaf4f6ac82a6041cdf94dd70e0f59cf220696a6d61b13c41f7439c7669774378d0fff1e6a30e11fabb43c6040beadad1cb1f8c5f28defbd385475a1fd06430eeec113ce5b8c394a46d0ff389d8376408f945b874f609b031037ef3a56ec5e708216dec5273a73db379fbf862d3d6dbf236fe699125f1419b6fef245d3d5442a2b4859342cc33097eead8b7f6da1566277b89a0ce875bbae0f075208258b811423226cf2c40792dc4feb89ea3a8cc9013d6a36bb3b59883e248bb924fc2f025f593f887e2f80fa4db521d1c57d68d0a6a439dd60455581ed90af9831e8516258a87dd1c2d460b0a448f9465cd6869a852921033b031cd20ce57c1c8097f2652f5347caeaac9c84babbdc148dca2311d9f9523806e4e8b84497a7a842b083d4167df31a30ffda56a801c9b779bfda8f0972afe62d4c61c9a01a83fd9701b646a48bdac4c15248319ce976b731cec18d1b24c9694ed436811fbd5c7426d0d264f634848c4fea4515f64a841eaeef8fe567e8947ab951846e2d54d3b5c5571ca1032b587511beddbb1ea2d1cf4ab34cc9dfae54b8d3f23be82cc1bbfa9f95687832985122374e976e616d0461256050e454802c14d60b8dc42e064d51626f955dcb455a29a3ff674d7a09dcb53f558580bfddd2738cada920e20ce2fdb35bfe1ed4e546baa7f19530dc21776506d7f3f7192910a281b69c94e76b63053c97949c084ddca5e8082295c2ee74de14c730b470dc8711c4a9110c3c13bf3c7760e735d083366f5c77116003e6eee3235c24191f27e8d68b9a7a8570449e42c14979775f6f00cc13892de4f3d7e73b77272a630e54bfbce9088f0df7c30dca177b488bdebd9af6dabd6c3eec9d45bf2263104c5e3936f7c0c912f2d3692481a7e4b31b1bcaaf41ce8477ca97d7007e56fc939f7c151800717be404c3d62b99945f39ffeed7cfe3bcea83df86e63756687179172a1902565bf4da0513611313dc67b9cd25cb92f3db6057755e3ac82abf7c4f76bbce57e0ce50da3caca2d2697ef1faf038b57a842903a33ea4ee299aae5f08973a2b3e693188e4e1a9f5b2d7e27daa7a1318416810cacc38ceb25955d1330f82f6e2fea4bb8419a953ee73e933c3522916c429058ff028ee54308567ae7670f588fc0e38ed34b70910c37ed81a8736361f07ffd8fbff5ad7d9354beb8b6b548aa82e720f203c42d5fdffd57936b71c2eb6e0523dfd48f67f229124a34e5e34f6cc7f4e22a872776bc59cb7bd6f97216756ffee06eb09fbb884553d4c7678dda20cc16669508a0c662ae2de4856de3893ba4a99d53a0b8dc31962bcbe6fbe91e6a11d2ec1bd4c64779bb3de45e283dd0513b5fdd88a63f52fa1d0bf887fe0c5949eb9b6d246a7575627e48d7e74102b87df682a0721f5887e1ee5abbb217c13abacc631245da211e7c947926bbc2274fa37b90cf8d09f9c3e0d3392c56b035f78f1abfc2f618dfa70b926b0a71147478f3c58b659bd329bbfc2cab5291b15cd331d1dc7c2d9f825ce058f1cf231e4421323b65265ac6ca274efa976dd515ffbb92f52029f78ec77a323d3d925e287018137200536b7280392bfbf35fda4fd39a962b886afad250f8e98ef53e011349965f3aec90b0a57ed1e7a3d68c7e45cba6f25da6745a4cf2cda8f3aa07ac0f805b211e942706aae1bcd38b97b8b06a1945e0ead2801906827afc8b845902026b924c87e68a917552246a1c116abbf5a51b3c9101a975bf82c98d1802347e73808f6dfdeb37004514729c83a4ddabb4bbc88a982e0303547b83a34a6b9ff4d72304b17300f5dbae067824c99293d76c58b252db31ad2b168cfc63de5ff46a2c70858ff32738db03ac7323ab91386e78345af84b4a02958c5469d47ee49d90ee31c8894ae7fa2a3abe83e2e89b70660cfa5f47fb2c57b88e31ca583be62ac1bd44428f06dfba59852a5990ec33b01749cd5ddbe280d41ea1a4a7b24bb5ef40e944f4ac4a36204357940ebb640f2c71f9d3fe038a21be221c46088c8f928e77a4179da2ada19d897111adafcbf135f5467dd6cc1c1e6fed2cc353b2fdf2aee07c8b44606ed1798e41c6993f86fbfe097b9d3a74962da8f3f8a089d84ddd9973b9289ec15bd9d7d8cb9b8f000878e453e3da52b7ebdccf8147ce42e5aa4b88ffecf89169915ea936a141104f1b28362f27f9b708a1f00bf00abd408596f6136fdf1acacf2792b80a652c3b4643a01a78d831cf12bfd0522471c22610e0caa2be37530f9c834518a4925d244ccbdbc81d252e85e8b1209c8d57dc2d6b6fe9e17ad06610a99abb1e3df465d4c9aa630608101588683fb22c53a963c6cd1c2b80df79ecbad374338739ed240fb2fe756dde7c202774ee0c229ba1e1b77ad3d85ed3ee5c184c64f7accd2c25d0b2116b3e9418de70055e478609f6dc5083695af5febb748b2ef6db3fc37ef26fab1f847c38f71c2a1fb1d5a856811ba6fd5f3b15da640d2241c8bd12790a7a0b743700bb9521b33408476b6a4ffb78f1532d776f40fb22a03580a7ec8d7e57d33322f84985cf475b72b7ffd72f8070ad068ebb605f6c9eb39be5d049d744fd94ecfb055bdebbc0846a4a542571de1d9cf1c627136ad74702b910a4098ac94dd15f4f1d39e696a6e5a3764fa58746c261f8acd48a78c581afc87d04751c87b97c2780f0b3a6a6ff7c7ccf305e97121a8a07d03c31ac716c7f6379b5c211aacee20829139ca897496160fa7523f95abecab6fea173c158fe66ef330d60a110085c1491189887cc89d50aea5e1f669bb3286842564d452325b2a0a00fc56b2505527ba9d0f589b17e4c7291fc245ab5deda4fd5fba4ffd744706a141d8f9d95035c8552ffb755ced874e65113da100bc61996e5bb835d3a51989578c6395f64a1915d2838cbd7f88b986582c0fbbf4a2641896f50eb05493694738760e48edf4affecfea0dacea3ab924540c0fcc8a41b7bffc1e631e4fc632bbe08dee422ee4b8ea07689740cd66e6c5321227e4be66626833c79629119b114c7db965fb9158a140dfb797d45c645bd630eeba32597219863bccc475e18ec3b159d9c460fff752f310bebeb811cc029a975fbf7e6f335f47f1bb3af408f2fed452afacc4fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
