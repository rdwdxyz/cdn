<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0832c3a03243bcbea239714cda8756973e1a075e10aa1c56053115d8cbc1fe527701519e7a8e8077ab6cb51fedb0fdea53293fcd7ab15913cb2515b30ba4ffad43b035f7ae9000837043d615a6a20968a6b06801dc32d39e6320dde9612e5d4ad09862cbd2967504743e4d0a6605ee8062a44c60eb0b91dde70c40056b2826b4a56dfdfabbc9befaac3a864fd73c72e6e0f43b7db38606647d7c55701555fb01dfb4d4e5d60f3ad6630ffcef690ba8295a2fb64fd600732f0d673d2eabe1aeaaaff3020521df5b3dc94c7ed5a743902f0fe8c5a760d33e350c326f0051e4ff57ea2c935f1d3dadda0fd6897c923e142ea2ff25431e32f3622b75d19771de1e9abb9a12c8d4cbc7a842d02d65a34a4051e98981154218e1b9db239d5b1681407b662e77c68aabf950b0cbd98573c889209ad7f2ffd89101cdb94cc9e7af649f2ca11fe97412ae5a667846ff59b4a86fa6c2074c8e8a934c4603bd76490ad95b139fa7c88f9ca723defaf249e673caaba5869c312dc427d67505be745b631ef5e24d538172d3fcd8494c8bc017873befe0305ed3567926579f8536451a721c9f7d440b05a3151e26f16eb6e2e8d8c04fd698651377402088daff6fc509a4c9b954f17a6cc8b689beb1a8bf8729b9e071dcc94c96298df00d3985de4d0fe0a2609102ff6aaffd7f138b3391058bf6f3d9886eb8c44ff6f90d810dc5997490e7bf7c01cb67efcb5d748b931d509fb390ec5a2d01f615fb1e02b38b92a442d222e0505cacdc26df0f833c92383900cf719862af2816901f4eeb7bbeb4727f602cafb513925f8ec904178f06d1dfe2e88e4a447df8265a0d93a3f1eed70af4843dc781619a569291241b311dae394ec52b06bf2998de9ee25a097b45a2b313aff3b9295eba4200693df907ce4d41de2595264fb35ecd36cbf706428671b0a3c5440e8705a4d9d7408173fbb580311efcf8d682480e93b05d0b5dc10549753375d5b2392c97041b0997f09380074ca8fefe1d4b9c112a9108bfb9669d69c4889170ae0bff6ff084e7ed7ed61ebda5471f7998d00e0e4f387a89cfa17e9851010095017a7f581fec4feefce30507c52edd3dbe220310077d75d7ec380e5d1a4697587db4dfc0ade0fbb8751ba53d47254c18c965371adcac1bc95159dfb317f00a25b0593b8b023daaf106cf975875b465a6dc85e6f396879850b1d39c7eb47e0f331d86ba1d359f27aeeb657ff1e65a8c2066c0cfe93ce212672dc0121b6da566180562090c5dbca6c5174e973f6abeec3b461ffe71b2de079c7b1619c02f7fd76a3eb200992e17bb935736977fd1de62fcf22d97aa433b1002bace5506c713474b6a1b9ac3e3fdbbc63c6ef19529a72c72a526f73cead433e5ef729042a7ab44a24c30f17273187bfce1d7f9e5dff6dfb8a64df66f50e0876aa5d4404679e47f68bf2d390ad3a9f7009afa58794971748848f5811530a028437c57dfdf2a157a9390df301ab1b022320a2bcc49b01329ceb4cd3d29bf877e2dbdd120be2aa4c74461e38fd344c13af6fff9bbf2d62b48a9f15db4a046eb4f3c9f5d3486da0f695c81b5e120e337930a7ad7ac8bfb8b6d46695e0d56a3bbf116e76c380ee8099c032abc59e58f84f3c66df807c44fe73d07926efbed58e698762052f90a216ac6e0ce8145d30a0c31b7aeef439a1ac97c4c84630df5a89728cff62414338314d45a0d19b820faae332163c907d27f2a092eddf67207f5e36dad8699f774eb103bd20c87b29d24183f17836922ee7007a8b50b1f185dca12e1f49955c67a9ca04885bc8ac6a11fb70309c4bd865c5a51d0b3ad4bc8ee1a300c3b480f249e26fe8f6abdc871676d8ebbfa94d4d338e739da3bea4dc1936f0a81afa9b8f6924d9ecaeea28101de85566dd7a52a6b49b5a316f92734ef5a5c784db7c41dd2f29b4a9e3b7664e58d612af7d598a9a0127f6b4c5ba9c1b36f92506fc4cf1b13fb487c6b440082a81e3b537f01747ce9bd351a972140859db0bd093fa8019cbea3fff1eb4395e12a2426740932de17f203e0f946fb562f995e1d763283deabe5a56b07a557fdc9daf2c529c11b82fe2b37bd86e736d6658e853be8f34fc1d4a2b3765148549c71e9348120bd3169b38becb3c39c05886c159931b9c3e55476d7baad662c8358ee7e5882c24d2b36537f8b716dcf912244c37e0a860463bf9e7f69e600636a9a89c3ad4e92c4acbee0d621a06661c9861be6e3080a04410bb253303547372603f3853bb6f7f8cf063a60175cd771efbb54e347370068a92d42462cd436f4ca2f67ea7d6c0e5bbe46675dc5e37258d0a62ae006c130543452fb4a1b7840a159979c012e27320073a47fb608b531557229dfc3f46112191cf568b1b97b64327b7417fdf613fbd597c59f7b48439f1fbc207a7808378a4305f81d8a941e6a08c5bd09d8813a66eb509dadb6c56eca4443eecaad436feb07ea40f7525957b5f637fca2c41b05d118797c0021c8a3d80c21ee6b543a66cd91de1eb2f5615568b8851a2607312d991a68d98160020e9ddbb371b4e29cfc9c75b0c5db10001a3e132c172767a8fa50b2608d3141a472b9378456edf40478d250555152bbc5a8cd580d8e97214aef83276a6678177b98cda74edf21a7a5a4d2a9d77707f47d08b910f259966740215557eec9d8a6e76c2fe7ac7522f4907cfcfc750a0e6e475c9834ee92f7beb70b20303fbdc82c0957aaa67b5bd2c80a2e069d086cbd0351fc69ae834494aa739f076c2d48304235f2e932977620c7f221f89baf7c5bfaaa7ffe5c7db4045a9a9ecd9165cc89d7ad011805592b63cd1a4a66115da926ce6e108635e08cab2909241594d7d59ece1b38f609267a8143e071b243540c826531235da68c202c79014e0f5b6d44bafcc58fde72792eac492366d22bd2b6a97abb8155dada97efd1ca766b638ce4a18e8614edf41aa678b5df0e4d6ef2739c308b53c81f932bd2136abdaa0930e288d09b8e9036b2ce732172138c9f83d866b8e11e18ac4a87b00a787c57186506a73f7e1872aa8bcb7f2585a7c93b09f9e523d11b4c0c7724f1a4d4a00fbb1ae4d2f5feb5147b5d0d3e4d5107c7a6c02374242d052d5e0e82f0525298cf378f4ac60b6b7f0d3cc8bc480bccabc42d0cdf7293e4d116ed8022749468abad85967e99a8d97c093e3565bd4e8dc6a23b2b680515cd373e4d958016abd1b97b12ccb6a0004ea9da8b5530f4a6407e32838142f32d919d63f09592ef8140096699e673aa27f900b00ab488aeacd066c791e5826d88818f3d0e46930fc7fad941af32b885ee016772abbc2a5685c37da96ca04baabce9184696026dd82c600515c57f5177bb1c158b736808988459e1154dc8f171c500f77c8ec29949ff0a92428e57af083ecaab1664a4ce32adec99c0d51bbffc02ac2a1d7dd47ee427eb890ab806d17da1441ae801f75ae2880d37cb37cf2193f251582b59ed925b49fcb95d962d53106f2b23a532424a4ae574811d6b02802ecb450cf06f38f1f34cdaefb29f86449fefe8a4c727a55333cbcf173d89b457c157ab946590944966a92aac8ae75349f62ba9a49270dcabe641b7424d141f038a7de49af4ece320b853c9955eecd154a6b0eb80046f179881f612375798e7c282a7170d18591f81fc2104e23f5b358697e82021448d2703d4dea54776e20751a21525b499b9c8113f83da017c77014fbde0255129bb8f2c39f27a678ebe824d609589ff73346031a550f4125fcef93afcd5a9142a24909790f18a4be91e2151e6010af143bd1bc78d6f2e9797caaf36c71a9f6d69cfccafbb45cd5916a86c3782835b823f1c12d850adbe1c5b58f0fd7821755e6896ae146aa456dc8fb87dfbedf53837ba41854ccdc9727bb093e12a546f13e2da96354f292a685e8f4b2d490ed10599e1935466acb96412e29f0fdd363dde222eaaeb717f805bc2be403149571594e2608a0e2dfa86e0626f70a3cdd82eda270d2cb89fbef50148ad73b68bca4888eea67cf5191762d66055163b1db9d9f6076cac6ee40d43a4f349726799565ee6951f41b4050acb88f310d904e9b08001bf943af61c38b877e6a951831580716e2a638fe25716a38686e5b8b707783008681f0a7328e5dbb2198928e9dabfda6eb48ad393ac69a0353fdea7663470b2b8c3f610870eff67b0a6117cd43d6e348d20e7008fb487bb82ef4039e904cb1cdab6b2332443b6c55f1a10a7a77c22844a8e55d61d2c500576683b94b3b9b8cf8d57c084070bf627d4ffa580ce0c1572b29273813316d3e3d4bd5b7450d897d6ed5c7748b478e80ea9708f91184184f42fd9c7e39bf5dba4195b8785541d95c0474d4f8ac23b8c8b90471f59987f0e738c4a2f2c46e99bb4e39a28216be24747b70ba9f9fd0e4125859024106f6e5482954132b7eb3f1733e8d9a16d05be5a6b4d39b8319b91562e2bd65682d640c0473a6d03f98d0af2e95182c8fba0afc8536c941c33321a42670387d90188956bcfe27fc011ece612b83c05c8b00ac4f20e73bc2c52870113f16b0ca5f5d97bd536791243bd9deaf05203a4d68804865b9c38de692b9c6f6c2a74f376751b5c535c09817c95690999393a5285f9ca98952ee332d981b15ecf0d43e7c1cd73608d97d5e1cea67f4678bd82886dc1957c74ec1101aae27c879df2649f04c32ce8da5bf5d67dd375ff2bdd0a08f2b75718911e0ab136042747704e220c912959c84ff2b8d88564fd29c4ae6815abcfd318c449597ce06a3023469d6e65fd221957251676df80ac24b4628ca4cb31a1716622bce49d0cd5515c51aaf8e53e83c517c187c3cb35da5aa6c21bfefc9405bacd1a721a00f769622addaf68ee6017a1955d2c1e1896a9b3e554f1da940156dc61e312a57f7849ad6b93130457c825fde80d70bb0bd0482f0c943d3a3151e7906364e803dded1d78717b7b39b136d24ca40345688672676d2488603603d2dd55f94d34900567317403918542aadcfccc002173b44906f439c881355feaef8fe57796fe2d7a7a2daa504697afc2f5c74b09ea28eb48aa07791cc88b744c4db00df1cf765f9cdc5490001b0cb791dd1957c325f413c2394f0ad47f1343e3c4835126a1fdf71da15861002a5b4f40084ab75e096ac4b6974a92db51db2ab43694dfd6701d9192d057b5e4d64af26bf127b3a8069043631ecb0296b3c6cfcfa63cee5c0cfd97b43537b20b69d8bf67530592bd4fd80f6c78d645339e3e039518e76d955f15298ba57668c936dbb977ee9da29d3d1abb0f907f75e474a1dce2d626b22ec8aacc751572412684017ca1a6e8c10cd3834da00e1ce02915ad648f86c5f930a9559f78c044deff00e6cb6775c35de90cd994236f0d441fb2d0f48cdfafff7b0366a5f41161cb2de4b3e7f5f45a6e931ef06ff3298869873f1b4404b7ec81869d44d40ce72ea8470b9ce5e137d9ec975c0bf30403179bb9512deca9d0bcea4e0816a1e6544bb1591ab4e1a1260fb1a044833020c0e18c173bdb3582b7d9a67f6c50680f699eeb24cb98862c9110508c6fcab8371eb350cc817ed7b3c68262fe5bc3233af0e9c383b09a53fa2eee7799e7765cd0f302e704b8b06733a537e8d3ddd72f287f28a251a43e99abdca4f1c8c1c6fef0723e5282db8d153d7564c16575bf66e217c7cacefaff55a177cd67a51a244aa7fe422857630737cb1a535eb5aa0ea1b9279150be196c0b6e02c8fc5f534a2253c2ab6c1c8dea426495c8f8174668e6838b23e535a0733d8458ce412696f5b004c5f49745a92ff63b243f67a95398e9c59991c9dc205e1a9c309693d59a041cb4c62d77509c8d5d838defa061fabf54288696832847d97f1b32b0c8f05d037115ac8f38ebf96aca5c0b3d145adaa7b3cd27ca87f3d244d113acf8ad5e2a92668ffa40119e3acc3462aff06b764149f2e9fd47ccd36c38b669a5973b7369bfa979effdc6cc0fa505d5eee57fc6c4e25a2be8172306a8833b74a7fca19b4df75b938b28757437657247a389b7f2ca310e5a052726adca7532410ba57dcb056d2ead0466e206a4ac76d4a9d2096a697120fadcfd3fda6996cb4531eb8c2e6f134e0fd1d29c9abcadc4c99d15b68e4c6a24f286b121ea7bbad9a3278d82fd99f41fd6f8e76c56a925e6e0f24b910bcb3d8f4046a1d3c8578d1e576c1033597ef436ed40af12df8f814bf7d67182f7216469fad1530e06f185ed50d772b8358775c3bd8643578665923dad83033bb3dfc053f61042bff975865d0a2010cc6eaa3bca2f33ce82f343e140fa4f7d55c8c70a74a9d4eb700911def9101fe5e04addcc2559bca310903295bf8cfad41ecfeaebd7d54ee412e7d187022eff066def504466289eb3f3bef6cf59a6282b5f701fe5f16f7c6aa7e1b87ccca7bae9df7f0e6e0086d50d3158d2b5dc1a3584e8c763a3e8517026592fd019618d0c5c4da1a5fc166fa3a1d5f9e3ac8b971d3025c13fed52284f5b377fb359655632586efea374f64ad7a33c39255e26cd0e1905702e26ef31471046aef52147b1fd408aadf67a859b8083688477dd69098195cd5a62e08b6a73329bae43e03e5b33380790eca2e4259a61a14c4f589f699249af8fdcfa8e5cb3abb78aaf3e4456e24591a086d4441037ac99f06798253b27ecc34d89f16c68383f40a4df4655eeadd3538cb517a49c0024fba90699f13dea732b5eb8c73728dde1e41a0624f975078820cb02e5b8b3ae71fb3bce282ec4691edc0bb61ee372fb83a87830650d1b0b6ed38d32eb1c33fecdaca6c81db24bb234f6713face120315a7ae6bb11e32376e545361e13f1acc228e88d85d3e37e2bf08d4209dae2e33f02a483d97d352e690139d97020ffb6835534217225906063af2ee54299d4615b87da89e77078ad51d9ac48f9bc0a8af59a7799023e2cce8f9ec78edc74b6185a16a58279258ebb26dc28f565fe915406c09f46b7b988313ad4a65ace9ad46197964f55c69eaa4cefe29003010e6d65e1b465ecdb227410b950477dc9b9db56b6e789e732a34d7b28049ab4e24edbe19e972c9764d49dcdead751663fabe147a59f4f59a8ad7624e069360621724d9952cdae0f5bf63eb233cfbac5300eae25ddd8a2ce82b64dc28d5b4d4eb87f02faf8215e548e29342d44f927e42c4870689937975af11bff62f342350145330876618b4755b872a412adba85165fbb90099163a30efa0364ac6b9b4733bdc91619a985ec746ba1d0657574250be4be537a304b49ba955a29f293a848be1ab5946d05be41ea16c79629f190e43b8f354dd30e24e1fbfdd5d75286d4b9b69285fe02fe41dba7b5a7106dbee9b94e5e6892318710fc0d3170c71f4b6773483d34aaa863da8fd3dc7c0b458bcc483017c4418be8f05f8174fccc26acbfce664bdff7091bfcdf8ccb974b42df09497731a0184f2759d41972d9d8b6fe53c618e3495a5e22a6826d021053bd4c300d0fd9ea0ff1d2c9ebbfb45afdd5334c131d47cc9a30ed9d1fa91a033a716e1c8fc4ab0e6fab19fdf372c3bd35aebee1b9c0d4e6802cd57f5feb3b54d21c511de9d12a95ce15c76d269cca31c14107b9ebc4d7ea666e7fba38431979b2ad69326d978e3823e275eb84a6194e35edfe01e77109c213331528a742f3e281e8c7fd5b0168831e047de9948fb0988d86ca31058f0a8bce2c4bac9c342e26249791af95408d6b4413dd10f26930ba90c7c197567e831c968ea7ce0d332954c442f1b8390af165a147a1e0520b9d12b8b5a0188c6fe09a17883062511f580631c88cdefb8a4382880a243ed64de393c9d2eb9ea67d5a66438b84f5c37a562983b3f9d51ac83a74c21cd2c7ce238e9a8aef1a20204781e243580d30b6dc24cd5d52932c4c68a7a43d8d4ec11918b2d6afb088576f9d23af26a68191d75153e810a95e278b6832c2b448e8f5cc3bf784ce66d76084d9074e269a1477d3e8263afea07ae3ee73bf471b1713d9037acf94ebbb5a31d6b8e0486c59ae3f39d4739fc0d06290c00c57ef0b3fb41de6a3d79f529980b30f9f9e4fe38d1895dafde67a09ea1b1351dcbad219cc8f91a21baf8c70d13078f01e8076c310f5961132ccff1f39bb63358633d59b526b5092195c3fb5bd113b6bcdd26483bf202bda1f42d3addbd8bd558350236c85d55d0cd1ded7420a132e52499db80b7ab2b843c3802febb2949ad438cb3f761a890ee808a1a771c9901d8f71a289a3c0db6dac6b0177c4d763ece9a0ef22c41f5ec488f98f02d4782a58b7f8b9d49365f95b9b2397236f9307c01c444fc7f770b200fee24d05ff3a2673b280cfbc8da8e2f67f7bcefe17775972fec323fd551d5a966233d3bf0459eaa311ba22246a3c89f98bc28509d25478e648cc347c62dfed1e632928150ffebcf8d50d07409c237be05d90593769152ae51780ad4b6de0b476c7e58e1bf3a2d5320b84bda0f0008899f0d6bb4f671c805d0eefc988396eaa1fb97e2b692be79b44e900a7617e9922891bacce0e923dffa6bdc48edc29fd0ae47902a2881176fe97fd16a5c63aa4381aef8b4720d025d81280356a3ce596cac5af8d9a68415c40d5a0d3c6426f266bada161ed0e08681dcd4d79e17ef7fb49ce915175c9b37ba7a5934bb7465736b2be0276da2f577753772705ce29b2f99687477ad4e963f808e9863e94b9c750c486a8763d8889b8bb71a11fbd72d547b00112a2cf0df2e143eb29661fae8cb17a601d13796e8ae3aa93421efa8a3a31438640e4f1ecd50789c1c43017246d750a241e68b4cb8d2e082e246a2f1c5ab79ad4e9f56bad18148f5d306f40c0027cda71ac6de31ec9ca7ea448bf127db217a653562dd668c0bcce66490409739608ca21b4b6bc6a71bee36f99384963b6d51901e871342ffec1e9ecd1be46f11881e920fdbdf34e069231b823bbe39ee1189135cbc0c98682953adeb66da22b6ece7db7dfca71bdd832c799f50c68aa27ffbc9bc1b4b5d7547939b352d7b788a19b6c78d33e093461ac4b8bc4ca4a423a61c89553c9dfc5610ab3d014992dea9febf1095eff308de0c0194ccf092b2050df19eca5d41b12264e11a19655d31abd518447b403afef4b4db99b4486e174c294a4af811df59b2e3fdc5d0676b17ece9cd4c4520a1c4cd995f97aa190f7131d328e29658eb79d265aae47bc043d421714cc06549870e1e3a31525f17041d011099d5e6bd05e05642519e5b404acc4b07fa153953b6c16c0da7324f53d4593b420b34fd1d4cd93349e4cc6f33c6e4a29d8a0bf69dceac60b4cfc49c4f5b9bf9eeab1c542a9c1d63330a51ba89e81b77fb6a76b54a9c267c8e2296c73957f8a14105b1c5e8a1d76e637c8e45a3323116cea5fe076941ec12897162a5437748ceec74194cfe82f69b39b5eab9b65ca6a7761a6cdd189f2d381d7c9215eeb2a5f9b58d762e0713b38b6d0dc84f025181e4cf32ea8bc2b8b3fad71ba0d080e3768d2f22416956618444aff35cf6392fec7b5d341fc1b23f4bf8a779834304e7e2aa4a40dbeffc809406366b42f366d748e5fd7e1b1e3f38dff1aa2bedf88142512e882fa71be892997360057efd87ebafec2615fdbb163e0236b44bb06c1c687e7e05042d0806f7d173b24fb3c9d6195e270b7d83fa49aeba7ba1d2fca933239daca49266ebd18c7a72e6a6fcfd315b0a7ce85db9529f1034731f5c04e07b292b47d608ba7fca0b62832c44a469e67ffbaf67dc7f608d4b6c5685bac8d99c6c5ca8ae7d4110bf97fc1cd2d515c9bd99b2e4948ac07b3c24472b5aaad328d047d77e9e6c2f8c216d4381b5881f5f59a880c35be239e3b0161f8e2c77479c09947acac7e3592c17c60d7886e215f21d7e6f9f1ce8d0ddca6d6b2922217004d7417b60e7a1591a58bed6f68599bc6fa5010b18daa4a60744bfc94e2eb22867e16e357d86b4b065f6f39f2150a91a5928a02f4513c4d2ed630331fffa93c993e6aef8c6d925ce54b000704a4d32d3e7d07816bc73f7ac7e0bc682affb5dbd0b0784e5bb9ff02f85e09fb4a72734c23821594cf4221cfbd24c25cadfa53196d53dae9d4bb88af90c0b463c8129dd72bd196f246abeb97448ed9b8d216c6cdae112349bb936a0ddc8f6e5feb912b5c1e45e9b917784edc0f9dd339565c416be587b562cdae8f2cc8fc2024981ebb20b59a003d4cb84bf9f2e1c13f056ca2603338c77e6997f8a3c7dc47c62b323bc1ecb80939fe76df4c57fbf00461cd3979b05f4c0f7180df1a60df0ab2889fae93ef33e911f3669cfd503cb8bb4b812417d1ae4dc335f8ca43b1d29baf48569bd341479fa3f33c4b1094a7281c5e8d6581c9bb8aefd091272204e20811b161466c2f68d16de19465d34287c27d54c3b5a20e3d3bfa50e670a3d9ab7fcaebc069adb75032ab9206e21e4985a284080ca1737bdb6dbcb6295094754bbc9bdcb51a23321f96397f961d1240d6503dcae9982bf0d2f73f4ac2c96e538c4089ae5fd3fd6209319eb9665f198fe46cd582ed8853be5652ffd5e00620e6ecbdb1623f55eae8efba99eb527499ac1f2950b60098b247c0ce405a44b458619d58f3c5ef4790807e0f6d4541d1aa2887354ed990dfcbcac1253da03c7c6b49cf5ce3eef3150c27709950f77d6cf47396fb15d89819d61659498ece579ae388dea0300e58003ff984407811463d4ac5fe205e81f9444af589b150eeb46ba9b088abfc7f44946f0f5860fcad49e00272e301b01551fda152d53be8cf832c3184c2b3d8ead1f9f82c9688dba2f77fdd8e5cdb76619e2edf06ac53577a532338f0f13044f62e7c51fc68ca4d0b894e9373f3caf009ca9b8407522f26d3077007a2d51cf5792eeddcfbffa86d17d942db5b9ca06bf99cfdc3ffe7fdbe85cdaf8ed7451a0a1b827349bef8bf200a98fe142ed12aa965ec0987106d99886229e0c402f6626b7c1ed68d2a16e406e21cd18aa2d9cdab57b54684a650809e7653d779dd4f92268284537cf6f6a061bc336248795f63b5c07c00d15766c90a7efa8011859e704388b83000b16e40066eeeb2baacd694a627abde152fd6b8f1b5b9706ab7cf474e81ed6a19a7b994bbbfdbc6b0888482607f94700b9d05230361d9f51b51542d6a2a489d1bdf97d18ad64ec9524389e4af1542d89ded9cf025722c6f6f3e474b3fb14dd29d8bc5135d37772349d1745bb5b8ffe26c7a9f5a23789741fb28712857aa96b3556c26197495a5cf39e6d992118319a5c164569e982c90d48f39c377f3d957904da806045244d65a8cfa0b6c7eed57051788a37877372592e0826e101bf2a0e3ba284f7456b51361ea87bce6591cb4013fc5a0dcec73f85fa47cd6c0f4298335e0661dea3102f741c4de83e2497fc8b6741404951afe5feebe93fbbe1c708af23aed5935feb0bf4819b8c1da58f676be786e55d5a5c51311e23cf7483f903619b2861288b60c0483596b7e3af9034337514c9ab8c7da0d8aed3fa48a2eeac228d25cbe095ea398bc400dd1e196e769658792f2a051130bbd86d2d9a956b596f5a3503d1752596cdd511ee1e1a6dc6b00662219b19d439b53a870e11b5ca9da86c594a805745dfc23d2cb410aba6418e3ccf4a2ab1ea8e9e7fb8fd3e1bf142ed1342da474654eed8f96d103fa355677bcc684d2d81d2981aed80cfe2fb082bd4a44705359e6fbf79bcf21ce4af8e4f7ae82fab1a0f351d53df17e0e3959258a1bc3b9006a8047f1286d5d3c1d9d44e74126a3397d75d970bbda389efc007bec44a14bc35297038d1a87284ca996987d92868310b44949e21afb863ffa9b3728def9242785c72f55041eace7f85867556e1974a54dbf0e2a79513c1eae156ad89252d157163a227369f63010d3cfa762feba7848b044bee887a7a815733c9244cc7d1f3de80a5dd80850600e40f5437dda8bf275beb358700490cd5b9486979794b9346eff4b5236040d05fd8695912e45a609c814151e312517b026efc315a20c6a63054d53b0b55919c42337f0601b55c8691bef107a6ce7e61eec11b1c08394d0afe5258ac860fc0aeaad7cf15c673c2457d06d241aabb8b958e15735b3bdf5defa61cd963f96fd3a7b9a19b80c32d40cbe6cc50f272604a302fd5d0d135cc7882b23432102824b1eebd574d578d5c9a704ede570bd59695cfa00fcef1fad7499c02d0c4b94bb239357bb2e481e5e4cb6f7c2407c0c29ba32372904b8b28af246390bd36901a9feaf4c7334aac1109885cca0ad94c44d31d11a7bb68e1ee45ef7e838facb6db41556fa01b5e639a8e9112c3b573ffbbfc2f0910a745d9ab982b8b71204830c1efe45fceb75c3b48c03256820a64d3ad9fb2c1d8b106b7fd1aa89d324ffc765cdd3c0a9b519b11614b40a1a0103f94a19d258e2e765894c9d59b1a255ef887d95bf8398a945933827b9f016491107a011dd9199c990aeafab7337fd7846b80088edda5bbea57cc224edcbac19d754ecf1e0e503f6034e1327ace745d9bb64c94644c1f801f7c48abf4bed8f1d18d6f74a0951a35cb8400714d67a725e9c0757fcd98536a353a70dc56bbb5ff66e40a0f722982e903a4e83ef4296f044792fc9d43f9462dc685444ebd792e30676dc13d1a25411eb4f60f1ec40f3ec9db232017cde417a1e788d8beb4a84feb4dd4ee122ae502baddc7e6f2ede9aae14a3893a4016eb6af3bce46ae7570eb6a72a1732513a24795c50c2b0b78a24b94d75d2bc771353dde694759bb668ce289cf2604787a8918f615636e960100c7c64e4208df8522347efcd493e64a197e58b39c0d4f66489b804824fd14ff2c617d5a7c6da8464bb6a18510382b38429a98952be8091cbf7055160bb6ac8cba7a33bd92ebacf7c2efcfbf1033e069d71a52e998d871e58dc44411acf93cf91d26bcb38641cd27ba407577b7e7ab74ecb2733182dddb2b5ef73f9b4f14016f80675f5ffe49136c220988c8b437b8b4456621c4ce5dd2c64b4680411e67b82eeaf42ba6dbbb3b952c720fc7a0483740688f3ec751e89439dda802700e0698e496aeda0f3d753c876f66cac712aee04ba8852ec9e710de2a5a171da3b63ae11a58bde8a4b3dedc67e21f24081ce61065ff416f90d93e3dba9d92b1c6eed98bf1e4be0e3ddbf7978426abf7f701f64a752f193e9b3b2d72fbc0ac66ec75cbd1e86effd61a7c5c400862e1780c0f3b11b4c6855e2d661aaa286a9c87be680354c07ad0bc05e1dcd218f261ecf195a8e945ff312619bc35e06bae5173505a9dc8b086920db480d0191642adaee94b754c6745b4d5baef9fee7387490cf383ee6d4bfb95d6b0588d35a858de928d825d7808739ac09c1fb857429310e069a10578bb0b96f37b37daacc544e7c8a97d353a43530c0a0e6efc414724ea516c37c571c6c624cdfd5122f29bd06f020c8a3994b460a36901e86eca3fa06b3077f2387c675f1847be6bc42863de32d9d3efa0f684cf4227adf4d8338598bf52c0b3ca0c97cb4b1ccb277d6775eba9a6a1bad45cb3eaeb82e17f1e806ec81c0760e40cb46e112fbb56bfa551fd16d770de37b2bd591f42da0b53ecebb1d9c6e57e8f49edb6106eb27470a97ef9737ed83ef8d050e431085dc64bf8e563dc3fef69fc61409db948be8ab7d11efab83d3f6c9acd8e8681ce7cf1c447eb2c17a0d818e1ed88533ff8870665ca5b9cc4a6987076544a9fd61e16e587726d6b56c325da5808918582a7ca50c4cd5dfa6de4191fa3a48e3dc86df297e2fb55630c06a8c84cde153f9789060d90f9ef0c6aea729c1a36e611576d71594bf707a424800d028b6877cc7a9df3ecabbada4e9bd524f4cbff2739847a0a7c992a3a21da0bcaa17189b4d0f951caf45fa036f906aaa4bd794e3eb82b27c8618f5a3c15656b7417aa40849cfa5b290a84a2c33073513cec39acef0eaf2c0ca57854c6b9ee03313fdc64cea6c4a894a1b338829cf85ef37da0a8ed45e395a20ba5eed42c69a83d987a9419950a767bfeae14cd92c4b6c0c98fde1c9b677c54102d43a28eb4352c90273db0fedec665f2cf79d53c639c754c3d59adfdc8e76b6e5cb71c5ec0cd3fcc03ec5dee76a822a2159f7d8dabbaaf6f0ebb49867b13af86f27dd42c01741561f24805045c6a416055cb18f5b5e800e0e2e60452a135367cf0aa9b9dbe8533e00c7b5dac6b961a11aa34f27aa37b00bf3270f4a27bbc298b127917511e141fc6b221beb514cf977a86ae205baccb2ff00ca7dafffbcacca892bcd7e1959760da0702b4d745aba25fc3addde1e84847497e370e2d7908ea69c527397d253ec4c6a3381c29e66b3a6566c19a71e63c4d340363dc95200075598c6940b656caac13aa9c7a279630dc2f1d5acb99907ce006d707bb5bc055d9338eec231224d444c30eee0be41539e2ffb763f7c1147c8a33e789a1ae6564935745f94b4f0d911651fc5997389234e8802a98ea394961f74cc3e8f218f589383dda74cee2d5b213fa283d9de177585660ecb12259cf532c3821149a024d689677ee053aa5edbf5c0d131c862a2a2e3f945a3f36a4d61a8b8e7434c8950486c465318b0f0ee0c2156a560f6603e23853fe6855469bdf5eff203b9971ab4910b6ab296de96cd933e95407ae17eb923bbf5b3de206410e9eafa42509eb47dd9a9a421982a1d3ecaf57486837667f2a70b43d458a00dc2fef304f3cf456fbc227505d59a36897d51f42c062d8a3ee9a890ebadf80a1fa47edf92cdb4dbea3e546b401f95e311543a221d2c749bce1e11530cb4b5978fa2700ce8607f152344101a4603b8779d16bc6cef63cd117653df2dc7cc1678c403b9f700dd9c566d4d1e832952993d62b2d280a7358418a0c7ec8a0dc161a5b5dcf4ffb10b5a5cff90444c6a75c8bb1be47459f476bd28a35229fec4f56dd4ec22c8e6b7d7cad01c54bc52f836c7b15598a24a41b4cc39c7e3ace3c09486084ab02001e4bd62682cb7de3e723e746f052780eca93ccfd2bbba81a37f06c48ac2916c551d8b4a4d730340835f3bf7a4837ee7a4ca43bc66c4fb0b520d85f250b566537d63c0a45626c28cd1b87074c1d128bf5d3254631045e1812743d9071244cdfca4c3d80474e785031e33d721ddc63d687ddb856b6b6805434597544f014713ee5457a6267272d2557a157a5988804db8308af88cb43de5bdac82fe5287e4dba16d77141f9f246a4090939e1f98be701d639f314c7bf1a181742f2e5a240615b3cf78c3d3f74819d8f99a0df627098b7d79d4d553bb36c0d9009bb8cc34732bc88eaaa6ceb578dca214a0ce964325433220c560ae6115037075110c897d184a353f2a6041ca49f566b0780008c1a072797a281430a26fab5b820540b9d5011226b889b986ba079b30c1d4ff81f8e09e08bef6a2739fa3b75d4e585c0c9bf079468cecf61d9ac56a1d47eadc90ef884b0ab58187f591b047f75d57dfe2d9dd291a4262cafa95212d1388abc5e4c12dfa9bacd1bf31164e2d4b0eb93b90ad7e58fadfe62b27469f5c5f3a39c7348a7a2421f3a774d38c1a7dc458d2efcd11a3026bd7930763e81b251f0dc59fac5151f856aa96bd2fe77990bc7a57f5d53d8f17eeddfea21cc56cb71ff5254491edeb27523e992d165460e4b04e3ae8363fa19c3941dc4e9eb576a8c9787ae0dae6f29000779180d46847c43af6756fc9c7c80e59d6c4311e9c48fad78afd275f6892031706380407b42f11b79073e2b2e7e6ce2e3da3bc02e39081ad2e4f0a48f0dd554daadecab95c093489ad238e5ffaf15592c23430dc67cab922111b4c1a72f3f0968fbcbf659fb46a9a90fb923ad5f62ef14921cfb7d90bcc589d059e343023bf000db4d813c0aabccf51a5de47e0ed175b201a8fd59fa31250964e9f2c807b62bcc487d8686d01eafab81adc689fa6adba03fd677ce332219dd7370e4e29464b52b98833f9a7df586d82d291c4f4f6fb99bf952ca62310c18cac5ce03025abb98bc09fbb55e110faac8bb31d17e1657152d5b2749ef4a5410b7c6c2128a3838479f3e43068236586be590fc7f09c0492d2f5c9b82bd80a104b4dee8392a85b2cc2d898404ca5a6db4c5048b6c0291ae9df5b096800dca6e2e906a1a7797a7508b9a056d250300c210d7c03643f9218217c86f5a1a8e19e4186f557f849456eba259c43bd81fc59c20cb335942b3adcfcce372428b77e87259ad68e298cbc828fa0e6372d6babbd4decc859b5b0c024808b4fc37852d607efc8285868dab15acde41a080a984fd66ea312e8756154c00ec72fe5de7edb3cc28cbbaa9a534675923c9b670ed8efb95cf7680d40fef93dd3ae6c7cf5bcc7a36d042c4f0fe427f33dbcd0761d4c534231b17bc8cbbad026917530f44ad9f7e8f337490e9dce9f5bf93d250077963bac3d7e1c4fec93fafbbf4061f8a71a9badff378fd2ed55f48cc041da5442b854c7a3e09f47c9f51f49a4c9a2e00c8c58a057c19ee5474cd91bb6e977ba37fad4a8ecff2607b499bf3b4b0aeeb36c233d47883f0716cc479ceaf2f7ab0aee2a919f1da1f40acf19c2c3b1829b4aee44cb0fa6fa4946f985fbf7d90eb190f67ec8b4903a561674da781ec8dc694f5d3dffd57900e3c86cd09c96a54db14f27d4dffb6b42bbf83e798c4befa15d47aaf221b5b47e4965c1735110b9a803a2a7d944610189a13216bed8ca94e82ff5609aacd56465af63ef7bbbc6018f6b81b31304ac58acfb2ca5b2b08f977edf764baca5a9ad873e8810b4112bb1ccc0b0650721f3fc564ad8b75bdfa61566a295edf2a9a86c333fb24be2f2436f7e7b0ad594b5e3a439fa1f7ba8f11aa3bab3266e426f5faa2677574165c539b103b5f29d6ee7e059df551c3472cf88c3f28aedac30e03633c399bc4a9536c41452a3ffefb82b3c5c7678e6cd3f28c35befa0b6540dfc1008a39505c5ba522d7be2d0c515624ce820ddea8fba773773d1aa451576c59784a9651b3e1ce846b480296b6cec4f4d2cdabdbac47ca37947049a327519f9daa0bb07128efabf92c27c4e55af751910f17ef8cd41a5bad6ee901592f17123a4a93054f2911ad14ba5599a54926ac9a5140eda4f8f2d054a7c69d6b165a3fbc3dd26ebfaa89b0b16ca26316051fc108bfb9e8c04b1cac38cc57e1995408fe617c08c8e314df346e02ef9c9127dd83fd9d88a588dcceb93976e685ce311849a3e342f036c99f943c5d0ccccbd94a8ae9fdafe87ca85a3de9688e194c3bad6901eb212f8a0d4b74d58ba950c18a0784cd08d64c38f7b5d36679cbd78dcf6821ac1a4f482a95ec3df4886f353507b24792314ee40099e716041231d5943e3aabfdadc4c1a54aaf23af3f99554e90b42b54f53b7c1126e10f90d27440bbdd3832e9179816981a82cdb93956b9091561d491a35fd28c481f9f44e94ceae281d7358e89e97eeb4e9c2d54a916689e3e654da538bef8727a3968c7cd980e62bca2b29603d1613206f38d05cba76e6b43e044379a36ea4584a559d22b2c54e6f8a31c31bdee1674511d78471ac91595aab5562031fe41cceb49499d0bc8a67c0790065420a4ed1f32c99f5f3a679666d89234bdc04e648be3d9ada5537cf68c3d7a0e8e3220aac91baeb7d5d662651d4815518ce2da44499dcafe072063835ac407fffda4734651bd52fd7583fc57821426662457fa992649744dd7280a3368b253793fe6050d3796cd3b77025ece6e7efa1d648a74f9e4f195d00fdea4e5be9c30613f16428211c400a255dc6d6f175e77ef2fd7baaead8076c91ff817dc0452a8dd71835d4ab66068e0e09217b6b74d99b46eeed93523460069cfe553692be5653e878db73b27bc636b9a72f9517737c1262733da3ded8896adabde104e2f92442cc23a0eb4df21ad568a8293cfae391e0185e39c0f659a436c698997eb4d9baaa0298caf0893973e0d0df72788ed44c8b091ce9f5f0259b78698853a85efcaefaa9080ac63ee48c923c80b470c9c074131cafcceaea697bf6550c6da2ec12c522aa0a8db8bfc472ac674048631c3d166ecb98005d64d303d3dec8cec0d2dc76ca1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
