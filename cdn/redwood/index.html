<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0caf3885bca69deed23d09febce807552fb6d1e4fa5e8f0f83b7582e4cc315f71759ae9395fb50ba76e54114a5c1ec91fa0151ee3dcfc1c91b397aa5bae5ddf5403459cfee37cbac5b1d5969d10161257bf648b9460d1878b4184ef7e3a3d5cf42af1a59c96842e05cdbe9ce646703943d03a98aba1efe03f154ffad6fb821e895d266af40c83b5ee3e7e8d5bea455f41d4d18c4baef95c7ddfb246f6f888e4cb7fea15cec715f974e2fa2c1dc7233a50022b220511f22f6fbe8f6d495f1cd3faad76df5b2776e44833452b478531a8111287a2597abc4f8beb9b7c9e67c5a1e9090aa809460c8b4dc16deba8f178d5d7b96630a170ab311f8ebe85f06d659eef2904ce1ff71f35c0846fed8de68fc24aeb9bb7801cadb2d77fe7cb20e50b049a8e906df2fa264183b22496c414be5d37f2d0182283b6180553a7af237c3a3eab36ffe8ce898f902dcc7fbc12676cfcf3e471b5f42d795b7de4916ec28e210e062dbed58c2371d061be55028904072aa09eeb0779d7fb5ecf7cf88c26987a8b59cc5840aef181c6b7310a46963bb32e8372278400aabe40be11fe1c526c00116cff930074aceebc69f7ed109c6cf5d689dfd15f68e1221d1e258953bc81050d3c9571615405b7b580d341807b0844ebb28a3d8b2478b81ca307d5af3bc5212c04496b2a252f84644be7fa2b7a3fd9363671760985576ae439f5a9d2183b1b89601bb93db0e61891b74b29c76896d5309ec3daf0acd9ea24def7eeeaa50b0dca6a474c1649b9fc139b9c9059629d6123f9c944d775ff01e837819cad5fdead0b491bf3f2db6d0944d000ca20c5ca4da2973a8880216b01e3aebe41954e41a923cfad907c27d3c6a431aad2ed70b37cbc482970956105d9815d4d9ac5909463aab2fdc949068e6b961285875b72604a56e5749ca8648320025366e12114a52433ab2706e77d4a444b37d64fc22cc70ca134b25fcfa8699a329d0a55ec05368ee048904476869c27d3f2bfdab1720f5a3155bb98418814e6f0d4c42b5b43906bb84fb6c6d058ff82b8f6d6cc23f0f660f5d063d3302c1dfc622bbbd69e5f09e2778deac9342671882da09bd77e5154a1fb6f82c8f299fc6e89d7088db9fcaae50b8485012703d9a33e95584bb41275d2654df63ee52290c1efb963e62ba4c077d32503f205207bc6df73a078241853b2b9d5bccc27cc59614d46a69a5bf0130227eddda8fb4af7026b6b7eda7b9312e61fad129df7e6afc27d5c4e0fcd825180d0431ef4b25b307791cf8ffb9d4b7f6c0250fb3fe59beb5fc6af88989d0aede3035a91658db8606d53fb94fad8bafeda4f88b2836d1cd6e656da04be5a2c39135f1fdac117c2859b89b952070cdb48fe7c25d44621b1a82d7420c73235fb1e50df4c75d06be42f218d3360ecb5908a6601c52386e48abc62233e64276b24f3709b64bf88cceb1704b63f414a4fba3109b3ff3927955e4b7250aa833bf1806dbb3259cf16e5d3e10fc78854f3eccaa7a51786d56f7eb1e6756c460c91de5923b249da71301c8cff6ccb76de6c5b7af1a169c9504157f40df1a8a09c664b2b3af76f0cd74f595ca9a605f7ca68b7aeba3d21b66975096231d8c5c7752ac0e44ab61e26ac12193c6261ca2a40d83e285db2c295b6184a8209e690379c9d538036938af5598f6166e36e248b9c81a6b5322854b925c2ed5a946b8578497007dd498f2b4eaeb9902af6183b9d62f7609b43f891543a9167480adac3e3c50a817a052045dc56fc1696c258b0084dbf035d9f9d4d8cf6588daf0352108854662c0790173ec7388d8e9c9a7e596452170296acc438c858bafb841774958886668822ed4baeceeaae6903ab43fa5eadccd11c1677c87f0333f76326a44b866468bed1c14b945a4d6e73574e7017c5a888c0a1a80698b2dc95d0189d469369b1249de61dcfce8bc30c8ddb5ddce12c6c9f2e3c45b77f1be795c8b5a1ee61ce0acbfd80ee4c20d748fa8ccf73240d07098dcd54290248bf0756f14f34c63db4fe801c4933930485d83abb57a9a1bd95b8eb2a331760676653441bb4b0c01fbfcced960fe92f678862857f646412f026b831abd831361a34fb73db6b140c35b1f1898ae948746d5ed3c3ee39ef5884e9774ac08a518a5ab67ccd7ba18406bf9f8aa8736a5abaf8930b579e41b65e5862baa4208cc5a3693ffbf0541ca39de0ee5e350524e644e058bfdbb8a04b6bfefab410b971a18b7ca25843e65b4030d1c1bcad9738b418ea615be6dad65b463e7174e0b14983519ddaee88bd23c6d083e1568b2b05cbadb649550b059a98f34bad9dbb0dae5e40b7d6f94677322d8a3a8e0159936d9d85fe43b0c4b83e0ddba040afd80440fe1c898d1153814c8814d579d1b9d0eb5db66d9bdfd15d10c883b0a8fa9507e1005463e1795e9629cdadb5873ed8985aa637747d2f1e5f0cd2293c89545a46e824894b9be3490c1215362ac2cbf9ef004235d346fa107217ca809777964e61d783a9e85108a91a9ba656c66303f00dcf251e09ab7bd566e240c5df5c86c880374bcb30c1dfc369a76a92e6ba539b8fc7ba17ba06c7aa5fd67d3e84147f2c08ed19a3c9089a3d284a0bb82f50483e28ed21c79b40826f597315e93e00555e1ddc57dcc48b4765f48e5d23dbbf546e60c4f3caa54d4fbcafbcdb5a4983185ea789a203e546813f878d88d07805c75da601bab52da58db6fa91a7b9d6fbe27d5867cc3669d07ddfee9d2c7b5ab7ed287f4a5c92747f4ce3bbc4bc7f090244c7bbdee37d75041b64401398540732eb7981b34c8f4de3731b8f7254f1d3ab951c3267888660b28927faeb366066dda32e6ff47a958f6c3e7ce4bc97e6e6ad204c49532ceb655fb81ed227e378b27ab40fd27a75a216a4ecbdf5d6b557179cb0aac8e28888a00aa7a1122b7f6d722913a10c7def675eb83ee3a972cd2ccfbed533f6fa7866a4ca1a4449458fc9e335bd40326a4a593e1d6e99e708d6ccba1aac9af29a86d42debf71e86b7eba22eae145f591deaa8763863a43c6e41650c4b5165ae17cf5cdc3349461bde86322b7de660c164b8af879788b49cb29b46f126a9e614ef78f4c16211c81d96cffb972f6005e96ba35193fc35ba1cd0d3c49d18f2504c2d017d7dd2d2ba51fa4e635bc0ae2e34947dd8028c52b7f80e9416557b24f50dadc77dcd5e1618398831edf0d165771aedcb383ffab53021551647d6c21e5d96c9c915989f5e7dbb7fe02a562ba2ac8295f4bdeea4c73aed900102d53af3f0e40a780ca5afdc78b29f681f1e95bed210457a70c876154e81263b22bc96dec28a9eacd287818be417d1b5e929a3834e70d31dd2323e6a62c77267b9d50285e641730eff8e2aaeb96277f737a45170422ebb7a9b555d03ee217c0732d876da57089b1303a713296c92538f6b85b4f0ee16cc1c444bebaf5a0cc0a1fdce2316f2a9c3752b50074ebc67437b0a287ee688380afc1ecfef0c2c2f3881439fc703969a1cf8a701c00cc736c4d0a94c6f53ccb33c842563f0d83881afb22d491ec4c24b44ef34f62731298c5223bb2efc0a6c7efc848c41bb2936e3e3a1ba50cc12188d63f881833c0a181789434ea418c7752b15b63117ff52859c08fedfce9064eb03fd308e2c9a53a291e63eef209a9f81fc9dd09a9028ac8eb9a5bf5da42e4baa338e0d7696b0ff68d2eaa9b3f9d80ef523ba6e5f6117c51070181b5072d388fe4871c2c48afbd99b33004e615e65427fbbac1ea60e6f989438d2d184c5e5878f07c7770a8adbbafc4177aef7bc1e29ffbb55905c68846e861e7f4fb022f7eb7627789227eca77c8214ffb3afaeb8df74fd18cab7581aace91cd6926e19839cab226d62435142500fe308305235baef9b0de305ba102b2e8ea401d890536df63990de9184d5a9897d4dabdc110eca6568930ddfce1f84434ba7e90453c06a073842526af585c24c53ed4c59aae39e114323e67f4bc879788129b12accf501750300252617fe2a18f58003551442bbf78ae95b57b223cbd80392382aaec0f930007036027fd7fc26962fed9584abba8c766b544f1ff8033b6125347f7c6bae3081929546403cd16b185c344d6d5ed19d8965d7802b26aeef30062c44315367f77aff688b589913264d7c2943e49bfdb025ab12d2b39ca0cc20f0e8513c4704aabc8cf6c4d5349c25079a7847223a8a3dd7da4660735d2f20b22a9cbe5d45dd85af6a7895927fda0bf4c9a9af1d6d5bae71815b32a978cafd430f4664c546b4f517a28aefd2f8fd8162db2e3424394116faa179af8d543840d62674668335b2243a249b27a1d9637d26f64ad02b471f54c2a3911c127ddd81f463c4bf66f1d3e82e152f2d640316dbf808652d66c2605a2da067dece4539e055b07c8251bc9446060439ae9249f7dca050a88200fb30694f483c84f63de2e5a00766e7b974702c1c2a155d2644e59efbfb179a31de092b73589eafeeb1d231b4b0d18cd9339418d77b80d0d3e53a0bb35a5a8356bbc71d4ac5089a0a953bdddd18c22778ff440c1577ccc5715677ba5072c46468c56a9be0f4df0a9acd86d847d64cc2fc1bdf7695d8381f34691c1b4184d72c771756448b64fe62e40613d4f05c9ac94211f03f9ea41f92b101e494535afb71377eb6fa14a357123f842104ad582fd6f64a71b6ef5ecc198b2b0da09b84ac771e1558ae1ec95530dac47f9dc3baea28b09b50c72323a4a723fd948fc60bcaaa4f7f2c70e923587a49f339252e73a88a2703d0d8bcd6baf45c2aaac56a7f4e16460e995dddae58aa210142a0ef5a092ef25ef7f7706296d5df1cd2e1e9de0141e3e0b7483f5cb967634780f3639dff686948c8a8bf3e2c05550df5fa96ddd85df3ff6cbc8a4e6f25513a228fbf7ef580704c48cf99cad2063b09a5036c581ce7abc83d6066fdab13cd3fa3351073f7dd6be01e8cfbb0aec0e9d4be32adc231bee1731d4b098ab359a0e33e3c0f9ded1a91202590171a800e484396d8177e01288aba3c14b2d8ee9bd9c9777762271ef22cf73f53e28e7d81e5983f72053e02b6bd85fbf5813ad93f851b72814877dfb76d46fedd970b324f3fb94d5ea816be933244fd082ca27c6c48aac2136f486feb8b9e066dc2cc4ae84692174b07e358fcf24ae0500d75e66a44c2979f01f2aa2024803bef24102372f11dbc972671c0198bb6214f10501f9da1033b16ab49860d56e2d58933f991369056a0229d251f88dc400064e2cdfd6bb2ab016b0419eaaf3687933ae5ba2807a5e08b11780dd8f1f2c149cfcdfd76875dea035a26d4e109f67ebdf033421193546191d6c68c0c119550dbe9511afb3451a2321937b8d7830bee0368cf60ac676015023be21b2aefe6d4299a3f1b1cf4009374ded29e6acd3c96761e9e2166e5fdb858b02d07830c80bce3ade42eee4a96dd9bb1886c69c0a3bdee3583a26013c32059929d1e39d7a5ebb86461b065b55be2cb7814858dc1ad1c205006e583f61977222d5b10a854e5ca41fbeed183fd3374fa121a236169e3e9097fef2618b5c814a931b21a17cdc6b14534bf74638fbf64cb01387e27b5840d5cc9cacb6d14bf1dbfd7c32d28910466ea6758bb5d9fd44de253838da16918ad05cf8f1c91f0f8e15c13c7788068278bd0d85b9b73c54970571fae82e77ec930285af8a79724b7a50404eeeafd0988cf61e62377908cb44a0bed08ebceb5556ffab5892cb4d0af8f5484ca32aef112cafbd1ab1d2835b647fbf430c6258d87a548bada779fca4d7014b893704d40825b1f978bf7f9d0050c041bcd17942e89d6ae3128a2a2d74039b37d062d42180b29a2e0e6a0b4878cdba5f1fd399cf212cfb4b835722e1b8ed2ee9381d7f5a8e931e3fe5336aa1b17c5df48eb6108f5a6e4b731d5e77061a28eedb3e57623e9279c88641c01f1252173024a13a8e8314b878ae05c844b39ac9fff22cd5fe6089911306c091554320142131f7d49bd4969efa0ae369cbdd836f4cb87de9fae6fdb0a09da51a0c44204520b7e220715457de6ac966f975c6efa1e3c0083822212dd07fc142b1d2dc93d9fd59c8ccd7947ba9fb9960d26495b9976286d3cb7c94c92e8d062a5d969e33a43f8afb03891f43efec4f394d4008a797d1b0c26e61a3f9e39ba2fc166dd9b6f40fdade193bfa56e06a90115be9131415e3424e8014630f960afbbe332f50221f074e2dec0f3db7f10f6d601f0de8f2039351ea8ea8c10b9da9b975046139784bd1a37be1442a130f788f04563f65aa92dcb9f3df453a48aa6abd9f17c056de3fc387015a4c42e9d506cad5cfa7d7a0095eac7e30a495264aa754d4970977dad75d2db0ddf9cd646fd1028ca75c097851c7d143b9cd143dfa8877ede3d795ff6a0e1959db450c38be04e29567d65b591329fadba5c35ab0ad7771eba565cefcd1e2086cdbe21e2b1c2a5ce207267160053bed8cf00e2e74eeb68ac1e449e5239f369916bcc77f2b4943a1142eae44f0e0cf5ed778bca1aff7706c6e6d10469d0615159542a465cfae2e8cbdebc1fa5afce1466d58a43fc6ab3e8b48d00fefc0981b46cd15426758b5eead7b7437b04c2a5bde510419d920d89ea54c6f88bb29a31734b82cdee2187ed87157404796c78b2dfbb16f71b8800ead8d3a29ef92169ae472de6791cec03df869d040a75881635c09709f117e91ad4603b01f012e40564c3c337011cd271207db080e81ccf4bd917362061fa70d8bbee389f811a9a46d91f281630c901cbb41eef1e1f716deaba1c14010170ae9f8a0ceb4792b37921cfed2ecd0c5f51677a38c25ac6bb40b5720056697ef660fe82d8a81f9e1f6047558824a01b38bfc9bd0637b108c48c8bbdef21f3d39de69f459d31cd5e9c840fe669e57400689dc3c68dc43b094ecd9e27632f72d67af905db74fb0d64162f7349050a2a5d83b47832db5c6c6126140e2266e26c8a044fa47cc6bbede3f8b094742f4a4ca3e49de0da8ab8419abfc736c0ec0056689775d58c50aa447ab5fb56be193d6d9000cd502e2e6dcacfd448b5b064e086e89f4b767abf1d83924ae3cbee1553797f4570dd81b1695641ca7885d1ce3ef65cebfc26f60f4295cb56358410c87ebdac98b2440adf3e911980f28e7e7467d15829a828d73c69e1d39db5523f13d23be0c9cb17958d6e0f86cb0cb525a756a725587444e41cfd455740b33af3fc41ea97d4c447db392c2949636ebf749413659a2158a1d4a079da22a4a3abeda9fee6457bada13c1f74b240e29c3bcddd7309d1b03188bbf6dac4e20ededbbad12d947d0ee3d0dd1bb7796b2cb1d6c1d4dcfbf2fd870fcb26b00f519c44721dcd6fad7fd0b88dd6c306098b2c068c5b0675482819a7251725f8330958456dcaf565e7e0d9254a5e1f2ba2273ccac944cf88e9fa9ef2f91b8ffdc224479d9e7db2b59bde0a56eb84f0eeb10233eb702b2d4e72d71fef15f760462146808a5559c04667d7a36f4f3e87064f7f20c67a3a2e2237ce3e0712d439e954695490276df946edce8d04c3cbe7be32ada2a7aea874bdc3395ee3acc04a61776110f011fd2257d7e7e284624855715b929f74276362be28f3e0c70e049217f2518f270b5f77c6f8a8c9acc124d32a8376ae6b96e67e18486a89707d9206a830ee145b6ce1fcd25904746610ce3d1e258ccc057ef205d1bb3106642813ce6da862416480431943b43dd9bb6354564c31e3cf78711cda12b5fac6fc904188fd5285863cdb0a2ae0cf586ff9b8e7449ffb8f7dc6be336e00003166e247fdc33e45e74cb65f840e18819bb7d299ddce6c30d294903f74db4e5ec984caf5945031d461418f8e9fe3dba500689cd166a52f54ed17b5918df66dc125b4faef471b70a4e2b19541bec06ccbcc22f7b9edcc14826954417011377b899035e1ca31b3673dc11c56f80a98f637bdcff4ee14722bada27a8b533776c52bd1a3fd2b743a23b83277ff50c0ccc12ec42db21aef1673cc8d7bd53dfb186277907b19bdea2173ee752083a5f370e8cfe7a0c82df33206cafe51f2a03b745c442158e68dfd97546cd3dd2bb19563d6ea37e585a89824a6a904df73ea903e4a4ad489eed890320d4f1f6b4dce488cd197b2d943a2553d43e699045c62b92c07c20284187351d60158e14d2cabb7637c5561fdebf0cbc40e59284bde60ac4e76e4d81292994ef015b28ce5b878003b6a69831fbeb9130cf3f6dc36b5e738303aef57847458cdfb0e1c4f1db7a96b180b8acb99db47190fbbf561dc03d7c222cb5c3928f016db13cc54c7045f955b68de23e3eab9fccf81829113e43610b151494d502e3d4fb58294ba4718616a5402cd923dedddaf3c4f3fc1e481c64dd7941e83acffaa693ee5a0f4fad4f3fc60e8d533c3d2db557fc3ac9dfca19b1a24c726b2a925b778610f763eaff2f4eb7f10a46668945b18a300dd487f610722d8d97c47b6ad6df8eab22c7c5aeb86ca58fdf89c92c8c9fdbde7bf29be0955f37f8baaed86b393b5d47cf331b052fb3a515049974219652bbec2185fac7ab3bc8f6630f88af11ff809bcb5c6672524ca20efd5bc93e2129c1c775bf8affe82df1f57fa9e84556389a7890571a56e0d5da628ad41bec3c26a26df6c3109bc4260967cc662251a97db12eaeeb53e41b6e2602b05dd3a3b8ed4cf3b408801128f884f555458a759337c2d3d01a2ceb50f728dcf79284652f6c11e51899ff06c1abd4ed8e22680aa60a02c3a086eec73d13747d119e7caa06f4cc9e549c7071fc4b994cfd70424f24a933097bb81b6ce022e656cc15bd3f3e43185806cc6306c1cebd9c0f01faad4c3ccf24e91e11b8ca69c8a0c86bb0813830b06632b66db77f2e6c2ce837d186c04a43c5bc96b94f290703b97581b79215043fb02fc5f4444b9985bf101a086067b7ef7ff2ae001c48d088f5e5afb26841c3b749474e429bd8a5f8118f616769f5e411101f601a0d0ea9cf32399f573a3749fd2ac1944e164132fa734de0a31a6f0cff141b07447dcf51e01472d1e3d081a8ba9eb384282adb8a9eceba8a5e28f02b3304cb7255f209769f9841337fc65abaf8019fbb15856b527a2f25b9e0ef3c0d245be883d5d7e58c32743185783c914be98b287d6062368b040c1177f95e48e3d59e3788de7020082cd5d3b0393549ab920db46298f76fb82d53bdce550e5c78b79a2736389fb91ce2dc1bd4089034c10a27c5bac9b25257892a697578ed681e6c50bb986bb72a1880fb0c11b90eddc7a3ddc54dcefce4c7515f804a1482535c4f631675b603185b3b66e6b34ec553549556eedb5d08ae6e0ef469dc221439de90edaaa5a6d2ce2847fecde3a0af2680581fe2ae748547b536b3e76b7f9dfe41a35b101201152eb2c82a836ffc69edf392ba541e7addc023bf8f0063770db246f11747f08b45d2d57b3ce36dd84af75983f698dba7faeec205084c283066fa8bd10a9f70438ab113a42b0ca4119d4be315fe3c592ae397b642dc1fca18d80d494e37b6ca3d2d58b7b0746de229b0b271ba8f7d83aac101c3ca34a46634899d3e670cba0725802c8a169c89a40df30489a1cb0cbbd86feaebb7abbe79e571e9d1cf2f2bf27b2788fa7e0101d5ee8c1f928bf21b55c39096e82a7c456e5fa13c181d53c31df55a4414b085029b153bb3fbc00c42717e7e07156516b60009572009caa82c1957b962d4531bfba4ddccc96227d0e5ef8bd2f4e04036a901c5145485c269a714346891578b3a27de501cf44c8f2577959f347e7eabe3d88d4cffa31f0d2b299a8514626dbe64f0f264a965000b4059eff39ca342ffa8346a64c5fb17c927239650b5e7ed2ef022ce50da9e8a598dd3bbe2d719a3aeaea57d552d9c208fe7bbcb6afaf0bb4701e1f1751d63c295d485c188edc767a98efc5c831f8bb034f350b4d0854fda058cc1792773a5a9c65124b5dd7bdb2eca290c81de3c47a538de05d1e0b8080e47e1f8dc9ed2aba1eae81d3d8580163811ed1c148209eb1c58e92b690a6ee70e0bf852d966ae2bf228811ddbf521ec1392b9dbb4c983db160a502286893b3b8e1218935b87bd6f95a06e5ef5d6ec34e398338720ac99593508bb0765b2acbf2446d0efe3611a6e82f8c1bb21388af4ce98b26c69a62ab03f5bded157a6e2ce669ba9f48d5d5fc4b7a14b4a46a04df050d801cfb63528bab8060da9ab754309d972bca38d5b2c9c68781dcca593a0fb32d3a87b27c4cd31ab7190e40a620bf37fd54ab90068801d924fa0d0f3a1a7db3b9c28f192b2dce1c46863458d53b33b89bb25ae1ba42d3029665010cc2bee090ef2d760cef27b9ee032bacc622e4c08ba7f76f2cb2aa346e0eb1baccc6536ac1bb37be08e34c9b5c74e328bcfe38c1921e34e4bacfbf672bc4f14faf849e39a22dfad4f800a8c3878828a66ecd41f9dc387c42cdc35efd8035f2cfa89fc95299589e2644f3ed8547674efacb0f06751a7d49ab7e6f12a52b3d888834e65c41e1327bd1d24e565b4ddeacb0073fb29e84b6468ca079c08e83b0ad0e138436721063daee83d9129035035ad3150d6dd4b8254cc03636cf1cb40a83685fa6f97780ee8e564cb1bff58dae949f8e26873944dd71e70aaf63ab1354ae091db47382fb11aa78575830a44db26f047f0ac31d7abe6c1eceb7bc98f755e5c4ac57a700cf8c8d0d91a8b91dcd09c5d4c56e76b9a65b25f396bb3e2400ceb5ff2d93a8bc7eb87fd5418df33a6cbf413bec174b2735ad4927ffcd9bfbcd5e41ac5101564150959923a5bf62cd1777aec372055ebc802e49853c7d4bea9dade950338e24d7794fcebf73a380ba7bf6575825efd451cabfdfa29060c26f5281f276f12b557d3f8db65ef9f16b3c69712f50d7dcc2bded1d09d0c2000ce4ce8f2a1118fd3521ae1d6e949af3a63b1c1fd8a292bd92df7a81a066bd22ffb0966ee14768b62b247199cbf42ebd9660928c9084f19f991c855fb1abaf87a5fd69c7046875fb265afcbc8b241fe0e7c2e665f9be60760fc6bbe6321b317484ce0d678beff15fafaf839d06820c8f6d551d15a0d2ffefb39c44bd2c06fa9bda3eac2c0d73a1b83256984a02567498d185c0b93d2ad56aabf5758415945287942d78eea2106a1da830dbe43a9a2fbecf031f5fee9a9af2191a3eacc8ed7ccfecc9dc0e8cf04c5d1e4b51aed235927fb276504312187856f791c405784a412e544d3b2238a86200824e4b78aa40f87b7be90e90c67c5da85cbd90dd486b142b1f290336e93b71509b34dbd0e68f4d2f05cdbabd9d3fde521afdac61cabbe570fca4081205f5a6dab8e7b0292cbf6638be95774051ff71089d73d1803ed8d0576749b40a6847cc31a578edd05be0f2cab4bdf714b26a4545e4aa376b1fba7c38c63dad7a0dc1c84fed72b43eb0bdf3db3579a3fe90ba9f9ff1483bdbe0e401a80c02081c2287b234925b209babb7329eae2f4a8371b220307544cb078b59e46ce45ce13a58f152ae8a5696d84b2c884e99447a0cd7f343a8689206c2591d33b3bf49aa394250c7ab7ce4a0baa990575fe0c8017ac96eb8a4596e1196ccdaa1bf32b94e41bfe6c8ce0445c6d62bcf93c3eafac1efed39f7587e71c9b31e4bc9499e8176b95144bf2252a9ad5254b95bf503246e1bf63ed7233e34ca910825f89aaa9be51859dfb8d33282091a05bbd6ef6e4033ecd4327a16a905e1bba2797e13bb323ad0c3b538196bd5db1842bd97c7b829cf23d7db81fbf85cbbf76924090d060b568b4985f5b0fc30418f047bbe77f43aa42096621979092c28c1dcfb1c58247416e9b91e916e50d1b6b1b79661d8a5a84899c4abd65db2dd2b9aa8ec17d0f4d7b134212fb917355ec0dd2e57838c72a51c1d7a939a2b01ab2ecaca5fac6ce60cebb1345bb26e24bfe02d80b52d2bff8e3e3c8ad6cd2a29115f4842b92bc4184d67cf2f9d6550f123403ad810555114862c37555fd7478d8270e4cd54422f14e1a1e6747a5bb3f723c05c3cf3e3fc319cfe0855330d142f1d7e5fec32ce66fe293ba287b8b2b91c4fe6b5f6cbdc76993da55da4339e766bb03eea10e2e53735cc24e400d08de8fd7250f5020a29e8fd40464512be4f43b7efac39f6af25d5a5d4d8cc0cd6146268de281cb56698e85a0bf0197a7f7d810fe333d49f96d0bcd6b7c352c6f4826cbeebb2e300def9391713e92bde5c91b10a15ec3465a83e0d61e1eb46569b1d4646424b97860e948ee7640760834ab593c65d815442576ea72447e2ade5e17823d29d3c245999a9d6e3b34a225b35cd30481c41f5d4f31c035716a9a6c34bab229ad450b1d6a64bd22870831e19e2db79f78bfecf264d7acf4b455110a4a3f81f6b687d62a081f3e195b101412ac6542a191bbfd0f494181cb7fc6db34b568845eb248c618d70a3a32703f9c0f1246b0f11d8e3964a9fa1999a67e620b50926004f26852283823592bd07d7e1e7d53e9d4619e24c7496a477dd4693c5fc6589ebb87229b63142edbecebba07529702acb132d012dd7281be72e2bdb4219be8bacd447a33201d8bd838ac14cd6086ed6ee3cef9d0ea85387c03e5be70cf6d31c198084950bf1520db73d69564163c13ada2ed63417e1e2f19f915ce1e66b616eb79b4dedd5e6d4c7ee6daf6fef08650e619b16c3e1010cc0e372b313a1ee335e7e5a6b935a55d05e424a1d2b2fe0edf3cff49e05631305ea51434cee0898ee398813a9126840548fa163390ee8ea4e8509f1c417ea27e6a23c9f828a8ceea0ca8db7822f320de7004bada9b28c1060084ac2e652e2186efe34f495c873f07b71b914b98e670e74096fbe28aee0757ccfbde9029985560f8049c70206a6c607ab0841c8abc8229b66f170c522ad625cf7b7daf15dcdcab5904ad3cc45e199aa1c867b08d583cc60e7c48d9e11d946e1fbae4dccea88ffb780ec8abcf551735940e35bb93e121b5df253ce3d4038a9676b392a2572e461fa3a410a2557b18eb059eab18591733ed90c6b29887f3f23a612f80d76f9b812ee40d5b015daec5ba94e778e53f34618efdeb0147268a66f29c99e936c4452702fb777250a5e8435e947d47ac7ec7a7bfb666e15ba6d4155ef0562557748e5354db0afce6b7ba6f79b258c223807094715138b71299ed1c777982744174fe148f2945f5e9967fa8d2d7017cc486012b5c1ccefefc643894880f94d59f913ddc362be0034ba26be5cf6c42dd2f003427f55114ea82f896413e8115786967998013501dbb288c09c8aba7de9d243b6ec98659322787604462ef146626b1cde196aff5389deeebc3ef872131472e9f1a676be24442f62bc7798db269a704de389cb22927cc808bda30eab52235d271879dba16045e5cb6c9a7f0b3628a440f4a4c6473a77d1f4080debd10190a1d91dbf9d6ee1a7ddbdcf6b758957eb2433f5103aa04c37fedb3a96da863b5309bacafe6b54e12b0671f4e347e34dbab92d899a8e87710ac9f74f3cdc4741c75e23e0ce7f7f8095f7e7935e81d318318ba43328273418e0090ff0258e69a7e259e6fa6f95ba9dd7a23e9094e3e423b8a29ed3d5420eacac78d795482e228a2741acdc37d15fa25da7b3a5923509b47d961e4542eae52a625b80a5f5bd891a7adc0ad13599717da1e4e9ee9fe5b37bd16d7aa7f48012486d117dba07c08c72374782af51bbea734e978bfe179f5758356de8e0810f9a2f5a567300a2b0def0bec955a1232bd344dada74cae2c966ba27fa81ee313a9b96701aa8d4688dd2246aca3419d30b977865e432eb603b29b5642da4a5d7e5770f4baafdafb1d4369021e79cae95c607e9a619800ec58b8c158de06871142bb6071a297c44923e232e9566284b21fdb04707090f45c68f907ca324266e7d4f0edea0cea68e3a7d6246736b37c0350e2a35b59798ca08cfb39368a92a66f13c2e6fe9c8ab0590184dc49c325c244d1b854700b4f921bb660eccece10d832df326b29b840b8264e9559209df77eba1804b7b0b5c343f0fcde39803e7ee992245635f86fc8806ed19d4024ec692ca0d02f79ebb4ce28b8a5df42c6b8cc4ceb33b0a7db1ec232412104c8fe155b17cc381b16df494ef7bfa17b2296fc1eca3016f0f94e9a84e321a2a2d762464ededef2c4f51c6bf827d7a042e9e1a44b6d38e29c5e98014593f03d643ff092ed8ee0d6fac1f7954e9036e8e90b2b09748d27c59782ba3574be36d1fd0f26c13b43a3c08cc66c2291b47f2f4119ba3da549b18ae53f5cb2895db35e0a8556ae1f197cab5a0f04bf64ae389542dc21d6dad3bd5849e0f91e433b84def678848852e3b54a561e3f60cb1779e86541f612e5ca63875091c21c004b4124bb06f3cc7675c08cba52fceb483616260899150534f697a71854b9a8ebdf64a2d277401f81e6c7c6d95bb0d9b6441c3d83fb7b86558492a01961d340115c55bcd36c0108391f30b243e3ee640c53f6e98228c01a9dd37fd376b7f38c255b4d0567fa506604093f24a1603fdedab348b4ff2011b15e339b6f79905dc6dc604a431bca25e5b02d8d8d1efe2e8ffd036eff9a2170ab1a21148668d2a1f915cbe79c02b755fe29e988b68bfa7c39c4570c3c574ce41482d5899aa2ec7d09e134f87a550b1e4a0e340c40d1d671b8644279f37788756934df4c3b96180158dc20b2ce162a743a958edef3ba640e712b2c52842d104c255f2d312b202063107cf8c274e94e226e4c3b622a476ba29d3b20213fe8605b710a5c9b777847c5f5b0117e7c9e0e308375eee2afe98c5ece6f985cc3f8c57d6dcb24f19cf7d01c33e7a8767647ddf2e6265743123582ed207fb7b1da1f1217085638ff880fd344a0f17ad352c97ca4e919b1c9d5ebf9604679941f8dead2c173af45db1eebae35623dc84ba44db40b876d6919b0b0f6234c0ddc2b8a2d3cd00aafe02e8db6768d96f3693686437995feec1fc1b601add11713c78fd63c65363114707f852381d9fb4ec03d6708319e48471af787e787a07332c59899a3be8db6c19d86e7518e1a2b5c4ad84f4591f487f29f785152877cd1c759f2cce11e8d5fa069be1ab1110e0dfc4b90b91bf0f8799ddcf5eab1efb8e6e1783f1cf3617d4e93bca453071f1455d8c1b997da39ea76b8233cbacad1c56b13c1d04d8580161abaeaadd701e97c25abd3b482008c4f1564a578f7d8e62fe3c55d000acaa4c36cfd807d7a8344c64ad85307d7b7314ffbfa56195aa7b3d66afa33a15d0712ebd171657df5dfddb135d368d34712f1a03f43c411d3ba4337228b62a6cb9216ff2bf6cb8a07a47f8d0acd015697e42c31c215062d657eb94e7109fe4317b22410c6769da8b35abeaf6525ea6f2c9dca821fa5b2f78bb365c55687c1aad4d2464c43c88cbde39c6f4f4c89da7cfac113f9e54d2caca70473e6b879245e3b50eed64b1910225312ecd0634ee6ed1e4a93f7d14cb9436816f72841149458d6c37c08f866d95999864b99a48ba1097918d9fa19e99f4c816fb5b554c7916e45c866d8db2f191de772894fba49b68c7952bad8eadf24680ba285e6d0f6c074387508b72daa2c18a3aa894792f70f3601debb0ab36c5ffc18b46b78f2092c79945b415103c488f1ba3db8e84d0b52cd56e9fe7816b30a2cf5c442162e6564a939c8355bdfc4f5dd9fbaae6301075faa4467f897559a166b107e13d8c76d74face220a12771929700a50123d86c254b543e27db825987e82a8a2a36c2680be32a2e2842d86c0b96116123dedae36899722c60910a4a44f384c2d18fb06964d1bd6199a68f3bc1780a1d7fff3eb8765171f1786a67c00851fdfecaca0da85fbd9196030424d7c0a624de1bbc91ce5f8244704a07bb04f272866f95aa2c5b80ef67dfb02b5e114badfba6754bd761cd6e0e399a8ed70cf621f9c0a1272ef5fb961c1a7a1f3af69fc97bc27e24d080b4616380af90ce833a44e9924eb3ab316f6ee144e94ff88199c4d37f7b3abaa1c890021ea49aa5eadb0c6ca107303c165976c5e915147c84706a704c79ab60bcc8f0e87c80449627f7ec6005791ebe778e8c6ba4c851e2738ffb309206ad85131c9187882570d58f0d4257849ecf1936d7d5b612c5ed3305fafc45476f09a8e33a172ed459acf5eca4f2826d215f53ac536e96ef24c455a06d2179f65df214485eafdaf4ddb0b3641e3322437a560ecf6300ac5db307003bc34218c67832fa9075906de8ca1b50670a565e55c2794cbebee0e5429f87d04efbb505a29a453e8721b6edb96d3c64163060c163da5ca71ef0e81475329ffb62168c6689dcd696a990a49682b58a0a4df484be91cc12311408ced4ebe37f670a532a4455903669d7ec20d7812a749047da54e78116bdfbcea7b21f3c1e3eb3fba5534c1343dcf24ec6b47fec69de2f0c30b79fbf6447e91b0d25c9a6c0ac911bc9a4ae242b22e409a43fed60a8a4b0ad786d2bb4a187998f67a37b80bccf8ffbab1a4d03de4244bc46a73ff2af999582fedbdd3f782cb2e0bf48183d9d040d66db302e797f0227b464217483b2915cf97cb82917a0511958874e97e61bff25eca4ee3f025c225877881609ceefbf48df3cd50da7addef905d7cd1741a836a775e0c2de4ee8f3b30e34b5e47f4bcd9e3e379f4ac2083cec2a8d100b728c67d64349311455999d14bba5bf2381bfe32f52ff22a28eb1fe10f75fd6dc9c4b0638bcf071bf3c0a40ab2b6e44b0ff34dda7a0aee00b3f3502bb9c47bfa74fe55663b43fcbc8542cb452fa1ea27c5a63a1df06a2420967ea4d20e813bccb5be5acbd44b8bb8729bbfc047e037e12b23730c4bf3e769a0ab88751cc00e126f134af3ebf10c114f6cf49ec7a6e1babeb29c76fc6bd1d2bcfa0ccedb545b6b0797ce7867375126c9e0bbebbfd2a1b79159623d9abb4014aacf4272985e91c7ad1c1bc9701cc2bd685bb37635399056d350c73fb020803f0472cfd50f5c4dbe49b6deadfb4c24273b0424bff6e0668dbb51ec074817341dfc39ebb0ca62f67eefaf65df39383eb42f68cbad54b20b862cf60fa76e0206f6424033a92c95c651df66f849330a0c21c631bf1d0d707c6fd0b2daaaaa3ffde03d49371e7d97f3a2d14bd35f3dfa9ef68ef6736d145d59fcbd06990f3391d66d418a669842586f22f56d70cbe9c4ea5f889dfc843d285fc61595dd9d25fec1341f7aff0b443a42a33331f777e7fd133dbca18ff32021286fff76797d474057d01f7a629847be33f5bd8fc420478aecbcdbd0e04e2757033ff946783b58819f8fba371c972eb3a578ea55e05aef6d5ebbda3631fa892ec24c4d529f04f6baebd2396d873e7523cba86a10758ab7b5de21ad73246eecb4d59acb5430c140cbad960377fb5f15267c40a7b9926e286903b9cf01dc1c62bdc4c3dd5feb8bf76fda6c76d34fdb8209aa9a598638282c831044055bd412243cd411644e6a056992402e6c5a601402f84317892390d4612bb6a42039ec850bcc7a2f4acaa4e28ffda540a59c73e9781240b8034597aa23d847f3c281874c60f43c6d4bd4dbea8f8bb67d49e969c596f726b0872b1874cb91bc28c004ba4b048f5a374f6d14ccef716501ceab8d321eb3b28ff9b6727e9625aa3f45f19f74065639134259d09d68ab21c36e21aead924b81377bc5eb60f4c1a5d6f7b4443a6536babae2acbf42ff2fb71708acff5651a3c2973cf6959c33c26978bd14b4251a813e77fadf94b1a589428563735b0040dd1c645b25ba81d727a5cbad1ac30f2cb01655b760387810ea0488de81c154cda7e74068b1b29df28a369315b2780c0421babd6f387c35b0e0e9cebd16c8ec39923175ee61f9abbb08304632071f3472d773776ec2463a54dd37d2ae85504a475e9d6ae04f9370b1263716ea9436795f12dbe8a6978aa69e42c2ccbc8b70249319aecf2868376741120f7754caa4527e01625c338c34e542a16a4222407f09fce303c096164d5c09fbe03a7d47b6d957fa0c42c8d3fa8305f473bf2ca53c6234d884cc790441e225ae2928c04254a28cdcff4314fe23628859cb4e58b8d417d0534ba8753e8839faaef26d8ea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
