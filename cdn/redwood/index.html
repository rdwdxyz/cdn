<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84cf7a7fe26f435803fc11e9a856db2d430cb45ba8f1ab1f70ac53ce09e96c82c572e49e3c9f6949cfb909f5255c6ebee804c015abe9e1c03afde147a5f21efbb8a9daec15cb68e7467d2fc0461553bd2c5e065c58932845c4740c8034c1f4a6e2563db82e92331d58307879fbb450159ebb8bbc62cc4b1867c7376931d41b55025b93034df2e9546e8a1a742f6bef85a1d67c5d54533502e1dfd90c9d8420e0731c219ef55c051509cb487f2c619b9c103c45220361167d43b72b72af5dcf1647e2e1ce926b83b6149faa44421acc645396fe91bbb25fa3faacca0f93fec05e38d33b0d01a3bcfd88c1656062f022e64dbeea6e1729c8a8428daf9cc3c96fc317538cce7525fda9c14f9caff1ec3ada925efcb894a5734829748b44e1d9864e415596731c5e5b121daec7d1dcba7ed4f73cf9ebadbdf806d87f112b78ca87dabd942aa5bdceaf10c535f06ef83e4d0e4e8f33dfd89c15e161148bf0a3e60243c63d8e0c97f85541154126248b59ac58d397495ab30f8d54558d22c3f45a0117333b79460cce926dcc581464d7abca6939c149876eedade03de9a26fd9aab7b1353e78e80a7f1ddd499b96a11484af7c2c86185433ab9fbf8a1ea0f798c0d5eb40b10a77748a5b52db394043ebce6ac064c9262a3eb67f93874cf4d92779e1a09308f78da18f14df9fb82f865c2feb924c7c4f03246215923c3a8a0b86643072fa5b3f145935846b9d4787670eefd0fbc8ae489c2ab78796a9ca0ab06828a725c829cb57ed09b01cb85493d11db667df5eeb86eff780776315474c98bf71eb3486a3cb8093499f905ec6c3b23198f9f90b3700de6a90f7b315a7b7d6443ac8f6a59718e18ceeda153a5c2e1f3c07674d251212e413c5b50b5d35c4aa87db54f07d85932ee39e6de8afd493dd905d5c6775b558502a04af54a99d8cbe674f78d674e1b111ada8e783fd9af6f958a1422284a7d69d9b68aaa0e33f58552946e462a3a6af13f27a4f848c2680599ad51170dadc35932727f9c487b72e748ac9e4fc5571f174a2e821be3059c1b05b0e1960847012272c0184ae7e221a4b675edb09cae4781b5b22a7a40591020e06e8a23fa625ee2718413bf265f909a4c2654f962d86ce46777aa819eb363150c5844c9814e2e32207a7d3a86831b347df02bb2f66c550bcad3a3dbdaabd1167be800c009a95a57e26c709eb54f913e69167710aff2c061443a5a5fdc645e0610a302f517226333fe025e1367649cb74cf759445b03726e44e013218ba9ae104bf27b13c871b8ecd5c77fe8354d2cae0dfd09f28db237ab39308c2286d18b5c5357ea9053e6821c7714e0be9eb92bfab3edf860e15e1b2597582da93a6855835d36f5573d810a34481cd9941cfb96c602596be3ff26e1542f976990c3ac6e95781bf19ab79c99b125ffeb54ce029d1bc0a582b2aad9163c6180c31228e35f7dc7707006d5bd14af7912a5bc93ec3960b98cb56e339939ba397889ce83e34065805111b066aa621f9fa1ec6d9e2f78b174f6a4ca7d1ac63e8e4dd6f48ac1d193d8771a05e85d1aa14013a3a9baee070c474aae509eb5c6cb64ff8709632b97037cbbbbb92f5d7a73d3da156524b00a72cab4d0d99dea5962d478ec4e831ab16e04218d1d04f3d2ca4e7ed3704421f37e05bdc5e044fa7a2564644815fe893e5eba0c323c11553b5eee08601512967edadd07bb6084be6385fccf2265b5224ea3aca9b10108834e3d82207d100f477da8281c741b73120a96b6a199e54ae42e87134b708bf1a0fffe808be352e295be970a2f581e7b553eed3f56b0f3fe917ac5f8f2fd78f5a75e28c94e8da552cce631524015b7e35a28124394bdf6e99852e944b2108bb3e10760732b38ed469afb751aef9957a76651c374c1154002672aaa864766c7be37c9771454c6124747ad41157b63cd871341571c2cd0ae60c516e7aefdc6f5ca30441c75c9820bbdd629580a63a4691c202190c152f7e9703d5bb6bf6667139cbf51f7bec3d6d9ea8a8dcae4e59712eb8b3547f177d978b61dae7e78383cf0d1f090886ebf1283ac2ad36313ff0adcaeb1e8668b6f0e04f397f9a674ed46db8463dfa8d9f25bb4d53a6f1f3167a6df0859e99514b0e25ef4722ce79c4e785f37e57b5f0d91bd970b447f5f4f639bc8851e9ea65f0423a51d863633bc392e15cc9327fe058b6afb9d33596ef731b6ba50cdecabfb1fdeca9d893dc9b091cc2f1446545684eab605940c20f3052b9db77e825f0cd09ad127905250bdc0e2adba28b3643209532a947e6307fea170623bd5c767270c0c4951fe3f864a442036c36e1d18d2af155df64d25c57d84622aa8eb76008a07855c0b1ebd33a87cc37f06fa46c2cbe78873adb105a1f4a848c6823530306cf1bff5e08660de78a3723f4fae6fc081a47b51cfab60183161975c48c978c99c394882d0e165642baa063b5bfe1b0d8ce956b6ef089257209262980ffb448dff0ea5f95616747058553a897b23907d27eccfa6d3af359c7c783f3a3b94d4044e063be83e2ddda6234725ad8002030aae8687ad35024ac7d180fe45ad78cb5beeb357aebe0cdf810b411591e8c4adf0174580408905d56efd8d459c53c2f871cc0bc7d509fad373bdb3868b55cad53fd061185cd7593b3c5b94aeb03c6d67d62be9e744d378c1d61adeeca6d5c5446ac95a4f0625ba432ba9880c3e4fab79a7125825fb599cfa255790de9e84c49cd9d12444b3b610a31bbb77716d8ccefad1fce0ba396979f5b8ca7c4b02ebaeacc6f9f6a229fd3746b2145bbf9392da4568d6db77d7bc5964649f20f95a0cb6ab83b3e8f942ca28c2537e7243dd6f3b2b51454cd1dd09a6281415b77b24c4b8792e69547319167d154207321fc7a700a015e203a73d042b8dbbcafc2ea01eea7450bef62898b678c29d76b41da769be9240f8171b618669d586c4cab9dfe9675e499915ad841e282db06ea76a024220d9c7c604269bc7a3b0e212c5fd316efbbe4eadab4673377f32da766e352a9b17b85f24fba25e37f0393d82d4270909db6d3295d41db8c32d3e541e64f253b57c809b4981d171d637f28dee0cc6df70a1729212d1d0da31c1b562805ad612da49cb45766492cea217f84852ebb6ed898c1881138356ab958c282ea8c3ccaf5f0c45a483b7573e5c32414d744d710ac98f902f3d522eaacd16b7b6150bbf7a26bd7074f803e8fb1808de1b6da780f33264d85426f8f4a82c88e1d77a5b1698c09050a00f6f30d1c48822193e4e160b225afb218e7aa9b30628406a2a3d8d6669e3f891a5fad447e9f682fc7ebb1bdfe522e33e95ebc91bb223ce9813eea7dc3984c52eeb5fa907215ea79b67f6c1d8c9a891a20111848fc31efb2aabde187360546ebfcdf9e182c69d80d84dd1fcee155e2d81fbeca2b46792413b67a68fa3b1a59ce33f912f83b2b5c6643c4a424010c0ebe526fd646e46d60b63a415a83dce7058676695c73f6a94c6cca99560e33856a0b4fda7cb5bfe6550be926e74e407db26b3d30be8dfd21f5ebe8e842c8b9c9a0bc4ef15fd4537e8b3c57740d680cf4cae70059b479bad962d83fbe1e7111cc434c0ed7c47d9aee435b2607528ca4202860c6cdd998e14c20e3143bf91405f08e851a75dbe92fb5dd6ac3564e9fe44d0a39ebb56f56747e061fa35b227746f7a1736c4bb578f5e9d10bae5bbdd1793188a43a46b2061daaf8cf0dc4cbbb9638caf3cdeccbc78aaada0a4754d6f5832be336cbb31b66ad138819aedbb1af2b552f21533881f23c9f50261f2c588c61e6f967188a583f9f56942cb322f299fb49f4a7a0032b0d50c2ec7347688cf441a245407ca8a645b0953590067749f655db896e744f1f91fd28a27d0b1839fb448b62713d7829f4aa1f348ef5bdb452df2e6aebaa6d6b0a4d25a5a0c9127fd1766c2f994ebbfacdd5cf71105c83e0874fabef323c2ab456fa4d194c500c54df89a7c18dc4d2d92d7757dc938f7e136d7c52b576d40366cadf273bd6ae8e399ba24ee482b034fbe0430a03eb8b4886548f7cfb29f87be4c915901632e0d81322adbe60305d6e94d8f872c25350d55ad11201258eedafd3a7bd3a0bc8e3cec9029406e0643649133d0a5bf5adcdbf3f44e951a2e74984f0a09fba41574363c8c397a44d8d00752e8d74983b640c33e0df52b6f24bbf0293c7790662fc8b347cbd1f7eaf3265bc568e61c28a220a1b2aad61f6faf19a2576e975594b79f3785b8b88af7fde22969a5f13407937ff9fd2513d2ce1c01c8ca45caad23172c3d9799f5d4f73e29fb582ae26256c8d974b5ae8e9dea23cca11e3fdc2946262420aa5d196231427f6b7e683502d1bcca51577e74861ca4995e53a4d6bb486e44b9c4ab343a336eb55e90ba1cdb0e504fa170e84a5527753f94efb78065c2ab79a628b188b48dba3229ccfba9d463f593d216aff70284c5b7b793b1181d7f08a0d609ed93d702da67e485586561c735d6cd2365c147d184e9c415e62b09a9befb3ac0b72519449614c0e52f6cda29ceb571f8c78a3b0710b498cd6f53ba2873ce56dfe971d35552aba0bee96e84950ef13ce5e9c27523f9c9441fb17431779fd71a5551e234846d8dd763eb701197e2d8dfa37cb9602a26ba9b1556931e2f76ca64f1b48c59ff2b2bd6fa42ef4129f33e83b485e6dc910af9e4e866630a065bae93f54b57ab893cbd14b8debde3968d3f4a03f594f04af7e1228450b5010362c0b387f83fb54999b215088c43cc247c0a4f2d07c5092c153ff484c9e9d0d2f04111ea3321cea39235f39072c2dbcabac5e6ac896a80e6fa431211a2a2367c5ce5c6564e0484112e4ff3b20a252bd05c9bfbc603da3fb04878efdb60a75d71095f67061667c8dc929d5dfd4790bf05944a408f269b22466700886e37d23fdac344ce98aef1b675c630c38e1936d2a3ca03b9f683265e1e3a35899c222ef066a4ae426deafa56d7ec33e58bf7866a58c8417c49efee3b0ebc9f2fa295c2f89c723f5d3db14ee587031c96099704cd1c5f9a6708c94e10737145215c4d4d4196ca472778c6dc3542956b9072473d91d6d7ab986f687d4d6dc39da5842a637493e2c7d876ced60d97687fb7ab52f7250b8e10dc4b6d5035b662b2fb64d4ba553dc911eac20a9657d1081ef17cb19cb28c918f445c35f3de6933a3eb6674a2a5b2018d37cf6a3131f3788c16208c3a6dcb0ba5dbddf391955e4dd763fc14304b5171b4645d1c05061e4ce95ae64f14521dbc5486df859724ec256914339a62999b49c5ec0227a5ea990425fcb317eb4324b62fe841c7e2b25fcd305a9281e96aec33c446a83008120460945a3f2fc8a41da141a53f9f9bfcd3f56e271077ebae9c119978ea187f972048ed34fbd169453d9f625007cb19fe23cdc9e5dcf906bbfb6484de0727485507159a1fe8db9766657142c847eeb5d1f5f6aac781df22ac069d471537dc160cd3c273b0a3de8ca89ef06f859902bb39281e6526f6fd2f1e8f9f4267915b990286aed503af6544a8765d61a57cc46b9b68eccb130059cde5a58b3cc19b55fd69a1e454983be037474f1e365cee3136ed4ae62b181eb858b9e4e454af166ef72478ef4bcc3e8967496428ebfc8f9d1537838aa4b105c68a5de18df3566840ae61b48a3307f3c341688619c2d14dcf8253b456c59304c6acca3bd38eb534be37fb10d535b9e3fbbc700c8b835a00d775565c2ab95cdf9f210e0392980732733e27d66a23e2bc998129a75579f60f86ce400ac0b2f5aebca50f8338d01f3d65bc811308d8a191719ff64753d113aaadcf9c4d278d59ba08448bbf310c3bfcf78292cedfb9b509ae2ae3f8912dd90430e188afa45b9519a72abf9c8c0a39696cc4ae81c951837c4406f1901c6fae468ee73402f04cad0f663713b36974c1679231b07d66bfe9fd511a843d5e5428d24953cd38779af18ac8da621a508e2ba7167228ac38f5ea9e221ae4bb4a3e0a204e59686a2fa446902fcb3a761068e242b2b39984b8efe77bb6c460856e029a4d9011ba519c11501dc3686a1333275ec60382f832631d31a24f0bf1a6019898fa339825dcbc8dd48fdaefa34bb5574569bc76384976e877a7dcc95ea3456defc7236c0ef3d05820ab5ca21d516da95c3d4f59da57689237735ca48a67b3a17565aaf80d5c0ff8ed3dbd525ac0d8df22994686e372a0c3d29f05a83851173123346bb2a9b5ea91ff88c90289001a0f583b9b506169c75cb79f65811f9b84a4b0761147e7e5a04816abca24268e755a8e2829b65480c89f04d476bb14dcd71733c3040545f930104e53ca3ccd7cbcfcac888b90c5ba820efc3e7b2b01a27b0d96f5127d700e51e58f42d24112ab2a88a5d6c7390a0ab290e9ac09dddddfc7fc9fb96f77b114cbf2bbc782e2949506e43ef4234c98148d074ae07bf2c4fa78efd2636d13cfdacc296ea3bb3d61c7232abb7546f7dbe538f9c403d19c747ff6ad33f995e7c5a70fb5e7f3cfe059091fe308d9afa94ff7928483ea62cca3aaf7fb380a00df309c6ae26c439046d3eea1f598ab9bfe391f3d77660d9550945aacb8ba0077ee8ca87a8ed2e2d7b95bdc3eaece7220aed2709717f85adea4254a6c2a57be60ec32c0197e71225d98cb678fae5cf6165ac49828682d744785630effaa0eb6a6fd9c9d54b84b385f2d0636d8d7a2d4286045f27126569fef3c38c745680599ce03273fb3a67b3fc29757745ba7a71647f60508277cbf420d1d195c9632fcaaa7438d5e464a2fdbed1caa08f57684cf79be712d1d93624c59b948bec0456c081fb2902a6ea4707cbd6c6df2e2a645a59060a8bb212e534b262c7280911ded6bcd33f68837c2cae0fa6cb042e636865bf29b1ba89b26ffae53aa9b245e3f14da4a145fd2a3a55f9c5cd324284890a7f745a52419cefa4fd33cca21ac0053dbf8cbce70ac4107fc9d072e2ef14d130ba45b4b4f255aff851d855ef4a04a8bc9fe9ccaee359a30187cc8aae9997ad6d82e0efb6a32070f3cf7aa9bebcadd4e8846b8e7f3537828e753af4b4adb27f0c0a8e43fb87994d6791d06f5bc76618cf6d97e10b8571e4777cf1874842d2f1eeac5bffedd6d07da50067b8f5708d62428b526fd6fbce9b803063c7f9e3698fefdb32e296cfb8313212a0ed7f7962ebab2cbbcf7159be4c8819e716f08194cd8f38242f0562a2ad1bd83b5f467f12049c83be43d53ee0b64576731bfa93b4b5cb90a929d4dbf6a929bc4920e68254d532dd0db6dc4a9a624c378e125cb3dd40f08e332ce62488b7301a3c1a6bd6630ffe2fb3a1812f36b369e0783fcd7ed72e1f38c0986de55ab897a8a32502390972a93c79c11057ee9cf5be5834277c66d5bc348a57e33a485cc45f6a071988d820d13644c07e359a68587f391335444056304efe3003d59e7700ed0355960f8a98ea1035f36ab964d34dec4916bf8d944c41b9bc8808b14e3d15ea470738bffca23171be0f4ffcfe9847af27df1cf48b6125c9c4975a28b1492256401cc5440f5e1cf0b606ce96ba655a02558cebfdef666b941c4c781f62c492717059f2bda41569e42a1908379e2d8c268a33fefe652975d566428d10b06f3fd31b26e736191bbc0a70d9dd20debe33bac2b2e5f86bf225b8a0859148518ca5aab64658dda7b899a87dbc4709499f72cc30ffe6c1699c8fc5ac981d7cdd59c2c7d78db5842a1fd9a4589ddde20818ac15f67942ccf5547cbb18d3e01f62f06e9feda2163204e2ab26e7b103927f13e9cf2cfaa234da2d5641c9aa3475f3735315eed3dc4bc490120cb71074c23e2a7d323f9c9015e100ce31dd283ae8d3d949aa957efd865eb83ade0bb430c2fcdf68341e773fc937c376368b28e95a8ba42bb1754c67f2bb84bf92cdbe9c9d22e2d4d19bb7414c50cfc5d35b6461ef5c1ac2e237412c0f242a51607d2740d53684ada7071e768497c500f7eea6fc3ad3615ab7a6cf12ca8d159d29232880127a090254f04f22506ff0d881b507b83fab1547da548bf0e696b2874cc43fd2fe09aa1e229f9b9aa31151045bb8ecbdf442a33446dc77f0561303940d7990c36a7d314a41635367a09b7f245aa16a6ff0e6e3d6c5e3218b015913b203e46f8d7eddf90da54ab62f25d0afb87008efd7c307b08853dc4fe4dc16287a9ad452d44f5859c1374d9518dee4bfa6109f1477d3911bf43ac7b28813e56604ae0600dcc1d749c1d227dc67e885ebde9cc4e17c2e40c279fbccec8bd1a11c8c54cd9a18dac697cb9f33dc0cea25b39a5721cec5d4a78ad3f14d9c4e187bd63613ab42ad441e6f7ceb477586868ff758120a34a5a28d31fc9de637378ff42435396a8c732e13ee72ab6ff275c2d36825cff78ea389e6f9868e7ef175ea22d430d11bb64cfc35454b8345d28f9c4e084ffb5efe6be35d6f686d3c7deed1af462a0d0b7743b301a8d74bd648a16d9873cf135f179cf19ee03fcb2dd8db21d32cb9c046950e3f6e4944bef3042164d6dff964d8e16f6de808dbefc35769f179aeb9fd575208721ce91d631e919a6d29080976bb0f6c823f7e9fc7a7e38d4c52e9707834d545f11767d47130a2293cbd56f0fbca440b4b9b3ba9183e721df993ca5f32f19e51f9b97a2786b3f37d55dc79689fd60c63226036e00c820f77d090d73ca2a68a54aba735980c835f7cb4dbccb1732d07238527cfc6859c6f40036aba074a9b4fd0b8c2dfe696ce85a663b0d14795d7d4c7d76e6957829c50dc39be6daed018c6b2af3c2dc5de1a5e4127e58bedfaa1404b3fe7da7d8efe7ecca7dbcdf2d2e027b2d2b67bb82c77ea871a40254e59c4e3cc4f83cec83c14081cf3ca0ece0f8b987bba7a46f013de1773448cdf8202ae86d35945e2144b3806a210dce912d091ed806e5db8fdcb75746bbe30204904e104a6a16a2f320a945401d35d20d3c08dc0e2d6d2e12e4afc14c8b765246579ca91a70d36be885f82e7dfc50b65c35488388058b6d0a2907f1ea2b11c017f24fd2da6f9393f9bba94579bea2fa334e44086dd06a5ec3e3af45121af2373550d81194fb7b7346b4df4f298618b788b261058a0ddc039afa05a04efb9612ea81b44957faf62e9a460c9409db5bc95f949408276c12ad58679e7178d5f7760cd60ffab3b05daf0b64e1c284349575bbd57e10237cd3ade32b9b70f83ba7b3e68dc5dbf02e02df600b513666fc664e5b5212150a908738e15d8e660cb2f0845d96630b5e5de844845138178bc23216d23d579030b0cdee27e9e273f26dffbbcc2db289764f311b7c5b031f1a7f2bb6b3c97592077d0e616cbfc7d299101db7b0e3af19c06dc6974a40def7fd1647946262e3c27ace5ebe7d3d322abebd779ca4ae08cb3f666356d21db1087df0e30d8c2137a21969d56b1897638c8bed9f1313b774c2d08ce61cc1f0fb0e41a48318876175f8df689e0c7dfd48ce465db7ec2387ce3768449bf5bfe0ce5f9f252f108131da348a2b7e086f33d0cbaa995057d44c8b2289b379ff83b9cdfb192c84d26e3532520fcfdc8d1987def6c18b01d38c0b9c4213e80774eb9c7d800f52ddfe1c0a9bc98796edc6d0ef4f67527997763e545c90d23817bf0c9a30882296a7949c67d017e9a42a9badf3369c82b33a3fbe11601627979cd17e91e793d5a783fc3b651abfe068c98eb8f06cad41c2ea08fecb83cadb2cdb208e7b4901bcf936f762ad0479146c76f3c73ab91a4ca490f7fce5a7a04a0d37a9e14134f90756d72420bc1a687cb3c763b142adb5d768ebf1d06725ef284629ca6abd54be63ace362002a7c77b48caadac8ed77eaabec0f399c667ec41c9b0bc0d5b98a1a9cec39a999ae63baafc6c78a11cbd03a77783c703c02476594e24419556391ade7c78f32113a8e292ae85b8976e859e711327ca20d866fefc123d4313ab0d758ebfc464eb1a436132a16af6c34dd36fe75ac73e2ca9abcdeb003fbce1e0fa385b26f1d7ca867ddd5d07bd55bb79b4d5e797edf27bd83de8e017de906fa523b621ae468b9c72c471e5fc468e1265aa48d012703bb61269082e81fb77c364475af5d3ddc0a3187b3b31d0a72755386b32119a3c8b770a28298d3fcd60aa92932e0a599fcb70655190132248c5ca66feaeba2a058f06a52272ed814ddd5997916e24e511f64af3be13d50336f89d71f647aa081fde0f5fffe63cdc1728c3eb470108ee0e0d297ee7dedaecd67bacabaa40ea88e9c7767af0cb167d55a212c7828d9746967bbb34f01a950d2dae20f645549cf66540f77568b27fcf1d3502c41f75adb75a3ac195004c314ca2ebae062535a9a9b4bdbc6cf8ea605ac7d605471b5291defac07d14a6795ddb22739708610b4880780567d93693f284e032ca07ce7e7a1662ed47184220484fdb3112de5ddcf495181296e90617c34f0439ededb0494bb1bd91a3ea1f05c3b25fd90e1be923efae8a1920c5cdeade0740422dfaaa489275092ab326dd8da40e9d2c2d91e12ff3b01c6f3a56bc8c5af889f7c913c7b75d6606903b525466c62901aa179b30aae42b6991a0b2079c775caff5f3126c9137befc40c701299c9aab07dd2ee49459d355c3b532daba851f15d1a42f3e40bdeee2a5f105a2f6b5fdb54a0261be50531deac505e6cdde32117b457bfcc1d9abb9be122513fe95456715acc18b09b0d053b5e04da967e68aed16340ec7ff3bba00b1cf566f9c1f12b77df16ffc5f4c8928b4073cacc3b743f01f72628062515d2de9a40221c25450740a997dab74a8c8e70b7a02ae29686c5d989eec1c36ee07cf439de48e399cdc888dd3085820051256aff0e231dcc469d27dd3385cb3122ec17ce045548d067290ab77b58648c11dc06d4b633fd3b30a58f3e8cf57ff8a4ea18869858fc3f2065a46986f824cddd7de4971c42ce8772bccb3713e14ec54a28ad7aa5203b380a715b326e34ffded8e1067b577a7be7f1bd706869dd8e27a2a0b1bbe8f144ec3a0fbbdcc6a49a47e66b3e310d16ece2e8c1784e8bb3aaae50ca6d4b561acb81219f3324b9ef9248143f96c1ede13f0655426f835a486d6cc6649582b1d41b00635d4441ff14078d6fb94f9e12595a784e51126a8c9977ac5e6b4fe3d9fa60638493869e4c305fbaa6e0ed04b1b3c6f5f9828b869c60e11533be3e877d2cf8f9ac7a680938a7438dd67af739589f16196c1531ceff6164ee77bc4a08077ac964f2589c885f337001edb47ec6e922004e07e525988d5c301245c39e5596c35b9bddbbe715efef65ee36966c8f974c47a26c9ee69aab55a62b17628d8b82388d3795b603ca7da89a37f19ebc4d0cef848a04f8e53f78987ebd0afa05f1a77cf0bd39b62362cd74f5112a2590948c9cf998081b02a7ad25e24d0d89155f58d0ae2950330ea804c1bc63c744251cf0165724669f30035f6ad5efc1e2d91fbc091f71f39804a2b3bc127971ccc94c10ecbf2c7334398d5776adf3a962619eee83f108f188f2884bdf3ee45767d30244c8e73736e7fd8ccc659de9f054fe02d1dffe1b9590917688c91237d48db1ad20f36d5258f0de7f3f559613b1f87508c84fbbc92e5a322ea00473590c4d30a246526a28634adb1c52b94b223cabb042153bf4130e2e291f8bd5f2d4a382acdf494138e02968125726857bd33fde82d3c79720cc973390eeba82888fab3d089e3241ab63fbefa062de2b11a60a2a2d164906a2a598925aae39ef37436e3a5f883bd0cc5fbfe884d3cde8b1b6cdfc4e30f02ebb63335b69992d6bbfdc3f9d2c2718c66a8bfeffe01d72c260c4e73432a65b23ca7ce27b54b4919bf20d729299c9053e03f434460721b3b02f95c15a1ab13f420500c34003d8fbc3470ad6b5a71e21d94342b03227b1369c27f345cc9a5815cefc1b26933689cd38671e4511a89200721a35b861577516662b27fb251c2c294230e816618db7461d65633b2d61ece41fb13ad4c105814a1082fa6b57316de9cdc901a81a77c425b41fdb8c34d64b8ac65847f62abe2fe9310044f1c80cfb18121e551f2c66cb208f2a3c3ca7d8402ccdc6072dea3f80fd20350d375cc5835342e7d16df049a608c7fb84bf7f6ffad2df61e402054d60450afe63a172b7358edf1bc1d1ba771eff927ff6970c170f110e209feaf294627882559c37489e436956af0e95dd1ae7a64c43191ddb54cb40ac8c75bbd071f83db3fafd052a24c4b6073a30c92e60419cff707e3f892e035668a26445d50781ea58533b99641126526dc6830211445cd11ecafa7c6610b2e867786fdd8dbceeca6b60a14d859a81b01c7c7b242aec668dfea3a19a58d7108f91157ac94cc1088f1dff4077e6162b64207ce33746b0f7c1c04ab02140cf6083ecd1f8f001cc48ab444e2896ecadb21b8c97e286337f9e51fa67a8046ca81ef8546b833e9e322e9c95ed807a867ea67397e9e79bbd193a1a758381c1be3fa5c582d7c8ac932c2224ad6aee9ed15d4f6a2a152a570c8a5f3f115914521003be2f7773263bc2803feeb9949bff8ad4b379353d8e5a833aa6f55c9560be3e7601ec395108304a46c6f34301e2c3f3aceda3e01b7290e1200dd84995d848c7d7df86e854e9b3aaa3eff3ea21320c4c07ec00c4e78f8e8b69836a056f58b9092714786d1b79c2c0ceac4153824077dbd71b09edadd0084f58a4df398f80459c37e124de18b76346b5aa76460ebcc82361203c928af56c7cc1dc4c1ad0b6ae43a1dbc2b28c631b69062b95b8586d48cc69ff7da76fafe4f67bd19d8fc414cf130d72fdf518971ba90bc29b53093384df8b7768079eeb6a6d790b9fa2019b2c86fc7ffffe0dd1964e534508ac294e1bdf241cc67ceb908b84ff55de03e0af4fa9fbb6de80f7727bb2843455950f75e585c44a4f786478ce0c770c066c245520cb3526daeffda1fe757076c4a6ca012b8b9aedcf2fee8f7812a3255abaee886374e0233e10147d567dc53bc67609c3a6f7559dc0c1d68fdfeddf839cbd6ea37edf2c1308369c21c52a2f4a477b8aaf571f4434751a19403013473d56f82a0f0fe1fa3729bf3ffbecc374a579ae97c80557a4cb290dd95e1807cca607f4c517aaf324183b0dbcfd53c9f504034ff39582c3e72abc9e0be860317ca9d1cbb74749b7b528a83ada069a9cc8ec2a567eef1bab2cb61c3b874e0b5227a1e6e14f20031da70a4a010f396a55690023a1e32acb708ac460683daca918668033a0b10ac3f5caf0a59117fefeeba983e9fa066ea2c4a4729ac29c3beb8dbdc77993933031a08e542948537e6136b0c67e72bb892587c1515b899c8945b933fc4f852d40999dd52ada6aa15d715d53bf5103bc483ad3495d950fe99ba9c6806a47f4fc71e5ea9387414f51157742a3bc2133fb19731399266b5c6de4a5b75788c9d1060ab77eeae0de25301b3be1bbeeeb363c8a290838548a0126375e983159c1ae5cbc53f3732308a842c0472a3ef2b44676f053a0e3a3b3d231bb26aead2e9aaf6750e3074a9485c1825653d09446dced410bcd21ff7b6f9f5a45d6966dfb844f5646ce0bd873d18602e965578b6c3ca555e88d43fa97c9e2eacb261b209de055ba5cb638bcbc782ab21066ca10754438e22f06a4341cf635fecfac6e5cb78269a27c973c258c14cd061a881f75956c6961c37c913b8c582ae6d610ff607c991c65be22776c95e6eef302203e400bb15f0da5bca863d8191c0fd66752f29ef696bf4f3186670fb9d3067f55140d1a201b54e340bf6297cea56fa9acb0ed0b86836db0d54cdeaa54f4569050e7b7105da754ca4aade36a953ceb3a36acb90cff22d47486e60e271af6ffa4d0ede1341d8d931f72a226da11f6f6279903a6e45828a5ce9bd6c946a0fd1bc1308905f71e4361ae2a411240ccf0606035f261ae18d9b7eb18906d4817c5c1363cbd6e063bb82c1caf62d135e651b42ebe80efee197cac10d4606f93cbc7f829a87089d97ddc91ac8fceb5c81860fa248242a92f36b4879b2ee0c1b187b762a682169024cc1633cab054f0ed7d7fd27c00b9f61643417551c611a0110d57b032216ce3f3d8e4c796c63c73522c4f416f38495e7ceeb58ba3f7a8906fc69901f45c6fd6e9ab344fd4e629483077a79c240db2edb4ef8ac37785f8e5e5550f0f9f0fb2b011b258d17d318f148c2f7077606772550fa2c5db5711a71b938fd1d6d2a520ed8d0a845dad5926df7114eb30456d625c8515249b4a7c9e2eeb7815671658d5d3f8c7ee1924325f1f7b11ba48cad6e53739ac93ab522cfc1be275a91b1d20aa1c2bad6fb0ba414ae95920c740a6d55db761aea933994f4a5a0aaab9607b4d0a33351be20e284f2e2f0676bc56963ede251d363153febfc4c7f962855b675c0e2201994caec86a9b08b181c45b1d35e2f2fe9345bd54aba60f7bf85b983ed433466a4f943cd5514c69fb64ab3db94ca2711203e992df114c60939860c19643e416016f1c4446252812ddcce7b10330d7a06db89525f2736f805d989cdecf9c74aa48c744dd516dd9e5b5c01f3f671708cbbb28d27d4941e25774d416c1dea7dc4c52f7f0b32a8994c74d7a8978923830a021989a86f50dcb20b3a437a32e0777df205ba221b5e432e201b2c863d8b5ef8ac5662b7e1563480bc26fe7025525335b856c81b00565c42c40411ffffb23af7ffc64d3bcafe146b9ec531d097a16af39590b53c2236680cfff52c1b4abb22f2a370a90efa5316f27657af964deff7b04263c19cfda76f587b4ab34c7661713932c8aef14ee1cedf8f7d42a27ac5148d68030fd43e00c7172e82fea22ed836583bb75095a13e35b5d3d32a1e86d4cc0224270cefc0c3e27222f280d23449c31d0b50ffd008fafd2b966314f5ee052192c9ee093c8f1bc935e333614888f34108a9f960556dff1c53dfad5ca6d0376da89ee28ac5ce02731bdfce94fbf56dd8dabfc9dc90684057aa5018c216a4c9a3b95c398856057ce02a4eb384fff490113e4269679e53ebff2a42538d8c4d24c1adcedadd9f64237e68c52c7b309a5f46e6f035b3c9efe1cd6a09b2628c855e86fd72c2497f3bb0af8601691375bfdf84ce3da92ef1f9a9e1eb70363c84a892513a9b17cc8684a1f244e61518c384c1aec44f7f8f5b1679025a5e8318ff57737c8ca1fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
