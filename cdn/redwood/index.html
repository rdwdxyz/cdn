<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bf761dac192825c27e16c5b000efc1283ba8f7ccb44af942d5733b327b126c4a077f0508e9fd863f3d3971a45c2b6b9408ff788d93237be978508db90e6539f23ac08284ab464141f64490fc52c7cf618e9b3eea9902c6aea3f630be1e1a336f79fa6020643901e11ae4b7e9506c5661cf8c4537be9808ef134bb929b0324a9d60c1279191ccd6a9e249ab2d264390f810ac905e17dd5a632aa13ed39179bc33c2a0819d6c65e1ae005180844de83c8aa6d7419a2876838cfe043a6dcbf48bdf5efcd1ae23181c899e0e835db2bdd975178410c4daf1248abd4113f70ea902d17aced17b40c684e0110a6d395486676f654d4f027376648ea75c0743a414dc519154eced880d379a49ddca90b91ee44c0fb195f39287c05af33bb275f1c60b5d5dff716dcfdbea6bbfbf8121c547efe6647fa8dc441bbe2a2496fae7a5b83ca5336fd2cc066ab7dae98bd1f8a11523d0970a4a7b1ebe0cbbbac373f6f1a4611415174a160348bb29057d4741092507ff8d77dff46423997af280f218b32e986eb721b7884b971c957b07bbb3309e53bdd09aa36e7ddd635b3b54b86652a1108f00a5af334257ff978ece8547fc3e4f43fe066369ddcb1590894072aeb310fd8c10199877f59b0f6bad9526aedc9a558ddf93fa3f4d32e841c521a5d958d93b5cd9723676842637ecef0ef8137c4de6149f62f08640b83a695596054b1ba907982079986747f7c27a6dd21a42911560d314833e901b27e6aded368f7a727fc4f45890f5f97e9ebcd9b6f76f7e707781e50cd43a67e3fa5f52cfa20f375d77f8f0dfbb3b0da6ecd242f0cacbaa7738840158bc627ba7f76a9ec7612646e1440b7946c495b14285243ed0a54e776d07ce9b8a4cfc348eb10c35789d660329d80a07a8d94af41eac4ac20f2bd5d2c78ca076b295d7a473ee70fa653ece8e5f89bc632102925167560ff77b9125c9909de517b984d72a98cafb13b43e5b5dde31f76c9daf20d46c7430055b107dc48e0c6b90bc51392d3e0ebb8bb324567389576f275b42948f4dfa444fa0bc043e4d0644783d18053079387c73cc16a63b415fc633a3691b42c3b6573864c4c05c276d05cb3d777aab5cb22dc9940472f034645d3d9aee76cf3c63558f4effd531a94cee0b73d132e1e6ff43179dbb008b4592bc61be0fea8c401477a937ed525839fc213a56d2ab3d4392c29b91dbafd10b546a59e8edf5934f657089a1f1995e2dfffe1bcb22e54bf124999e555e664b24fef4c65f8988daf6564bc17095fd045ea0ab6f272c4ce4e9e8ad6b49042904792002174093ebc3412a6947ca4d2984efb1eed111da29858af11b22325d1befcffe3217c570b3cade3ce55cf849d43950bb29a11cee1f5b957a85e724e24d9fce6cb43d86c1df9b0497f0828769b69a583c0b26ad4e21bbd996ef1eed19f8fb61ca51e93ae46bec0d571865840f6b646c5e74f8089d19ba9fd265472846da45d83732c29b2019814b21f115e4dd085764d7f7b1e20a7a23d253c7529edad6754f5fe9083142d04e9c4d6a9a5e6d9a4c04365cc8611ddf4bc29561695f698ac781aa7143c9b01e722f6d5bd9981ec61779a9f957263c128892370c4b3277325fb37d1cc95240f4b7a2d73428fdd856625f9f97a4016ab4278ff349241847ef17a5169e8d339e37a56fe44a47643bab3903446b2251c223b6f154fce32c600671057b3c50cedb9e100f50c7a14f9829c2620dd50800fbbfc4ff1ae6f092ffb22140f69a0017ff435feb355d8865784582352880d0a0444fb5606d9eacbd911a95c7842fcc6831278e0fc6b5625c12f05966c34236662e5aea07ef0ad4d2c2c74b60ae6c61cd501e19b1cab6e952eb2f2307432929fc9f0ec7d9d21a89b579f7cdffffe17d0a8a6500f111123f8488e2bd462438590b379e0b7c00cedb413346da38d4f6fe6e6e5ba779cb2bb98db6019bad723922070d30b071749e96af6a4d5ceb6b546496f5e919ae8fb956a4ad5546af28937030f370bc11139007b8766c6596ab4e5f9a8edb40199e1796413b5cda3c87cc42aadc0eadb88cb1ec7ecf20a9b36062f8c3c1e8586c7f9c3db672764f57621f7af910e83eadd620830b6b4faf0967fcc442eb7fe2e82249ceb704b50ff91116ac229b76b5744f5e03332cc15a96ab91ca70f3569b18c036fbb87cfa8f3b12d2945f79fb63c13a293d48462db8de0c5275c62ee482b2bac7c4231e6438ed395afede3d7ecd0d0679396c2d8f2b93867769aa479ef4e10a2d6764496187d454ebddce52c3b05a7fa4ea05154c2b44c9d3edc7465eb88b541f1f3f4fb63582cb7d64ef3a65120964fe0b4431da789c582bb3ab6849982f5b6ffd1693c4b958b441f79a1ace8af3205d1942e5b1aae2f771d92b2f9c0a4f1dd535a0271568cbbc13ba2514c72af421ff1765abb93e259ac165efaaa06a33385e89680cc7affcc954bca9e9dd0d57c0f5c4c19232a07b3d40d60a6fcb815ac85794bfe2dc17fc1564a9bff7e9a22c2010747742d66c52e9bf451a4664dbe593f141ac2a91cf14b46a669f8f6393efbcf5256691e5f43b359cae8c7712f1d47338e675332fb2df87b508e102009c8e5cae9d7c7e010d0632a08993cee47bfbb34789fbf39b246bbc52d032a5eb9c84ecfe85244e9d0583882808ea4547e706ad54d3eed2237da7090ce155eef61faab6befd31ea18ecce0be29c9b294d85727880426215788c5ceff5115fd90d0a1c09e9f57791a729f6154e55f4fa55ec410af077fffcb8657e2e51fdaa2f08d9f0d2ce6bd64afd856a45ccf48ae9844a6dd78d16500d1320b14d6236dde8931cf5a6b92d7e1a187d7e983d9c391a7afe83251847a62b52205ee9486a2d5ef35ee1595ec33c4040d8234a799d56b00c933d05dee03f7827b07eae1d67cbeb7b25bcb248314601679d0961b7df24bad5285e4fd2fcad7283935251ea065357497c966fbde5c931b54f9df72723cffefb0b9c1aa6bc040f6003e8b9fedfd2325d593fc5ce184bf892a5e2ea7df13d72cb59e985d81c023ac3a1c01e212b9a1a48dd9b4b4a9f3006fd4c96ca544d346c88a236412207a891dc1f6af349521958052be087f37f2b72bc870b1f5f85059a81a729162961cd97c02cdf5b615051d1c38e84c29be43ed3043d82863aa6e6c3007f3c37291c2938ae392717419759c3113948d579b3abe07ac5511c642236b614c49fc15407e628a4f7e710b412176a125f9df0a1b2961406a44246ab161b9b7efba062471e85d3d76225de3f7f86f8d27a424be7474e240aa1bbc901d92ef3905fba713761a1500c70d8ac5a5d69b2cb740c2b621ca44a67b0815fccf04f23e7760505580b5724d1faeae66c6aa426b27ee8a2de71f9f92d5ccdfec2fd8c795aac23d977025fcdaa74aa0bb92f0951d4732d74e1da962cf8055ab5d25bf06eea016d823f0e60db8df15f94017c3d8d8ba226a41d11d4ef9d5ede2a4d1c443fee9182119ff70834df5f4de7f531a963b52e3d7116ff828979b90cadb675ea9e4b414540c5bfaf41065062d031d1e7d798d9b0add7aab049722fb26f522d346f60e4dbf2df12b2b220091db0632fb665b86f81d8fde0a2919f701c7fdfed0a05c6ad69ab4da87f96bd2cac760ca77f12b917d7137eee4282c01f6d38a889ebc1208dd63a07e2a38af6635c0bd9df6daded451d9e86f2cd69c8a591b0d732ffb4b3d5dd6510b91a23bc786261732c4096ffa0cd422c5aa6ce88b8df7f7a07533914bd422526dade8a202c429b5c1b46924fdd4213f204f9d292caa6c59744f1ed2417ff282fe7585d890111db25ebcc363b6b20f2458d1f58322f214337f1067fe6e1f897fc85c34fee7af2d4a41c51aa670e889135b999d65dc1ed1f85b48c9cedb3508dc4f93f0ba81dc8083f6840eebb7798e828b46496fd2d7ecb5e9d976094f79dbdd23632e5c39d523e4c6343e1799abba2c720a049047ff8b800058bc51cffe4ed3594904e452013121cd5d502968da6bf69f4321b3cf8b15c5ac502783b454760c169674a10cbc6fb1439d20854e4edd5bf032c94309361b4153bb829b6cd821f79bbcd9380d8d154718182b0b6f9dfaba778ea37ac42358ff336f942cdf94d621e9050f4afe81eafa8084ddb38acff40826f22d9ca527f3a2e2492c58a7dbd0cd687f61d7b465d2a85d4ec2e72bed8f1525772c55c27c0282b8d6b625c96031f2cb178415c79a4ef64eddf50a340e8d9b67b5cf3b0ada2f5aa0c44e22871878b77be8418e132a4a38413ee740b183fb77bba22794eb3b6bd50875a9990823706a91ac09db4b6035c46001c9cc618cf4fc9b4cf27aa2190901db8682d013f31126eeda380df3b0dd0a3fd90e79f72f065791555c258fa8d16e50e4bb4ae400d5d8c5077e72cb032a02ee86553af132180e441b34b3bbc5e29dfc3fd6a2281a5cc102e6aa4655d50d035c866123cd5c77fc7cece3452abed20707d253f909afd0b60694fe5dc31b1d7b56df1846eff9ac628149ae37686d7d50214d1d21bc92f555c166123fc4cae959e33fb6793b2fb440d6cf587d10c7fe04cc2463e88768cdd2bbff10aafd4f33d2bf3f8e9184278a759ce355044a91ac86f697df94b77d64e1db79eddc8ba9ef18afb095cfd7adff96ebfa005314d32e1fbaf39d8ffbe0fdfd2823a97b69e8025d55827234a35a9d29f403825b51461a0b94a6c5ed3e283a3a014e14d7538e2fec2db7659eec8dba0c6e946b0b5c0ce1ed00be308bbd3a5a95eae4130712af2b51adccf4663092dbd65e06481bcb3147a9fad0915b2e7cd7331edd6ad02493a13c89539da25094ac3599e719ef90b6763562495ca4baf8480effed77e49426eb3e2fdf29f33ca17bde0ae412b255d0db42c5e8ff0eda7f268f2347ddb40f589918634f3cab51841646ae20f80e77ea51ee2b0e6d4246c4dfae776c6fedc11b9843821c84c55e9937bb5a9db4792cdd5ee02931fc8265587f00b0d6ce785368dcb1ac394d480088bcbf1df2e1bc70defb2fbca9f202cb835c0077ef0d759c7b310b69f4ada04a0e14ecfe5a3a3f8863bcf2f4c18b4d0c13c3891df0605bd7f8886b263999542b6118f0b0925f26fde85b50fb1eef61d28d679328ff4d44a1d6b73b20cd2a85a1968567713b69d534d894001a7be49283995dcea95d8f5a866a7f27800dcc2d78becb40cb7bc80956a76c40871cbe26f31c6b65738ef76a8f50c5adf6070e34dddb90ac64087cb3e8261281df2d38627d14fe1cdca609d82d3ea665f76c30bca7ecd2d063f1fbeeec9a597f4d49ded90a29fecef73dff74d21dc7a2a894cc947a29264322875d26facd6306c9cfbe137e461acc8171ba324ae931da46be5dbc17dd7250b8c4a7bb6847898c6cdb596b58376811fe7bf67847850d5a1e75d02a385458e78adde7be6364f4659fcc62a55c27d5289bb562c042dc88398b995ebf8d58aad08d4b839a13980f21674faacf7d044fbebb071a0d5a8f839a7da88715d608deaacc2b3d60cc20a6bc5b75ee422742e3fc5b7fe87cec61cb5ea209786af373bcbadf59a80993c37a39d3e0b8323bd0f96fd02c71e7e548bdd00da9a671a7a16920a9f767077a51ae1ed5671d19bb43aacf58a5587930290f51f2e361140ab9ba603347e8eb66d3f3605d180a6bc449fb92c42777027c9c0d781465311f12552dc52ad9f0fd695255a7f3c55a0c271958fcfba4e5b9751d7ad6127d98e2423b453d39199eef1cb47354e951e68badc43120b5c77409060f9128167e56e3f4934e2c2e014c4fcf5f0915946ce3e3e85f5d4230ffc07c217d84badf7f0e3900fff421153decc9d46bf111d991369baaee16dad82950ef6aefb7d6fd7bd97b8ecdcd7a1c6975929a29a137b8c45b566bd921548ace011cf0fc2ed8e019782691684d46f9fcbf185daa589450367c93649e89816437432a64c43a89cbd5aad1d2ac3cf58ff5d80263e3ee63e60ed0b5276779e8ca954733766a3eb295e7c225cb66519814408f41665729022e474340363a6c29a69c9f8ed481bd4c416095483230c08fcd45e662888897da33825fdb814a60d0c8b057da9ee90104088aa5712d65c2a9a90e75e5983cd56526c5bef5c69c018970bc9f88cbaab401a14df74a1eb7b249301f3691e685453d5ad13ef4934520908aebd266f1dd3ef8c54178ca478d305c59cb736eebe0481f88a59c2de16a095e77a18bbfbf9221246eeb16a6068becddab0bdcc3372eec787b340debfc021ad44c9d3765b2bfee9c034273e67855240c87378a76d4ecc364cd414cf4b3cd6cf5aae4ccc378de9ece12c93ec18b23d57b7e2733047a6d58ce06da37187285a7de16403f7b0fa4640bf3a52b1db1a8f9f3c270f461235f364e0a4caef303f81bef4d3b777a2f98b8799c4d086d4a1b80fea3d384c5738d9367ac6d363ba1dc3faee63537f1e6fbb65892ae278452ace7b3579078d284a81d54aca6dc90bc5fa686ca63650d5e8a3841c07680406cf3c828c44403c030057b80c462ad627837d2d2d0d03214b472536a4755f2f57d90e18c30687906c8be68f8ce139cc580a42782f7052a47ea280013f82bb26e478b47151a816a54671e2ce8eba8342970409a56fc4f2483fbeed39038530e3e5a01d2c98d3f1a11eae3b988c52b615f67e92e781294600d69be1648575a5001d818a33ea4adaa3ea8414934ca1c13f5ca46755766da13c18f2e90089260e466b8d00b839f6a2629c6b801811e5faa90acd59c975fb0b6f09caa2ee9c84d6c16d6ef41f89bda629c562d520b564688dabe8fe16fca6d0168196d832cc87018a196cc461a222edf9a90de24bcbd91cde063bdf2f3636592f82177e7a3dcaed0e2cad00a94badfacca7aee9fc4a674722e4bfc05a8f87485e503e7ce343ea45800ad449024d1f7a70f11dbb09d1dfdbe1f69f9b13930d95e9ad61ea7a33cc95678a3b35c9761070c93a4898dc3c013fcb6a9791b33cdd20accc718793ff31fa9250324a2056fb8ac4edd55c2fd9b1fced791a87eccb9c92e54e6b8865b0b38740a3f3f4b70e20bb640fb8839189faff4b309a9933f56175bbe19bc97c2429911253785ead5317ba11d49d54303e548eba4d864c92544ef7d6583a0756a9f3d54a59eea442cdd6c573b44b6e03a087a8b93285ff43c7501e82d0f4f6dcea57e7b0accfa8cccbeee9a08353ef00f154c1886df7ec5517cdd0c809b196bad495c172b20102299a6dce795ea77604b30880362398fe34e06dd5606542484a0585475eaf4ac70176689d24afbc7071fc0c20c4343c2654761412f9cbfd29777e1662b6b4f25fc6fbaca2701a2b9701f1c3b6f82ababe95f6d4ca8367d815d67cc742a0b02fdc4830f5130139c08511b6938c19d03109fb0bb4741d63bf0663ea7676f9a74ae19fddf4b60d45d010359ab1c200df79ec830889c3d23c0ca5fb2e39114a70eb5fa40cd904fc60c286043ef04296ac1a4a556a285e626d8f1701e8e5ce81e4d55410e9b926440cb6e94724055e2998c38e1d903609961653e7c4193e16639b3e1acbd838f4573a3ddb0a923b1cfb0ff7085cdb0fdcb21d0d2686939846e2b4c3386ffed526d199d44c406fe6fa57ea23535c722c757f6077be33f4b66e185cfaae8125f7cf8abe44bef40ea419592ab79bc942e03a296a4746ed4f70b08763cff9a76b837b824f77bc24a2c4d67513b578137331bcf529f03c9be8d6f63f361c2b3f776384162bf861af659dbc43b5c5936aad9bb1821b3a40b3a866c2bd6f2fde711e6c243852613eb6038c059acb3c082e694230ca096f228b465880ab8f5290b31d7ddb2f1710a4926ad9201059705441cf71e8bc6abbac2bda3fe0e74b2ec952fbf31a6517b59eb2af281d50c34c7c22a3820d38426c592dfaf8b44f0e08bd990ec0d7617e2006a42d773740230c9bd709890c9e027515aa49b66a93476568181fb2793198b06a2f57e38e9cda8e43554db4ac8d4e17fdec5beb83b468c29199717adc727e9f836be2f467a7025572fa5bbe7d50cb35ea0bff48a7abf16e53e41184c43adf573d9fb15f487b0c96151dad3ec51b38b8c9aa5c9b8e1afc0a42339f982c5bca9cc68b92c73c97453ef4d279e840d6dc33511ec5f96a6e8c39cf6a7718971d465654bf21fb0350fcb7ee841af9ac4056f2c4cb97773082b6181841a78c63d97ab4c8ab6c47d1fdfcae29ff7352e97ebb215e0254bd9fc4bdf27c10d208afb32c138782812b459999656c143d3bdbc0a07d33766e331c23620065ad912b8e52ccd6209f4c57e79ab8ca690c97d1e2344073268b0dfc6b19c15e0316bcd66e7febf9a0fae68b4b4ba18c7283fdbee420b64134f8ac9346c65e86c52b9c6902c0e0df1c52dfd5e1793e1d4c46b86e4268a01537d84a8f779f62105e094a1ffc56090855c1f62df44f8f1de0b4b73eebc64ad39fb8fd3a684c70c96b8ee3b70525aa978602aecc8998762ecc05be3bda3dc2b21178d2a7ae7706a82f02e59677431344e5fe22e50cdb80fb0e6d5945459384957bbbc952bfda53c6759a25f84d9046087b60b9dbcac5e2dc8d66a7980ddde4404fa4135b90b2a671f4e272055bc0e17892c15a1821dc855372656526482e1ff93755c0c64bbc3f3b2267bbad3a896a48548c48ff1873e98e77b022fa3e7dfc176667b047e4ebf369ea6b7a2672f102caca736618a29e4fb859c566161a5830d7f193329e82fefcdc7f22c54a62ab12ed8669b9d67f1174ac31fdcac7fada2333359c206990c98e80c70cb501f172b57d340f5c92c9a0c36317733c4f61257f514128345fb13af191bda3af22b625fca441e7b6678de884f5e4987435195aea73b377dfb89751bbd735b41da80bf79d1c170293f643080fec0e7d93d994b16572da3195a1c4a2b1e563948f5f8f30e3f19d52f5caa3e6a75367cc23dbd1f6a2823aada7e341b6b39add226b6f12ef9fbb55d02a0f480b00d3ec5095c2e3a0e1a6aac5b90595c973579b85cbe155af139d1ea0549baa3615af8d1dc6dc1685b2210678b256015224b7720a79ce4682e25dd805debb8bbc8c031ed54ac4bff416e400d9f4d3b907faf441b9b9e135faac70d903edb74729f92f770c9f0d54e90008a30a103ae236e4ab2c5e43aa3e14916048b86bfe8e71102dd221955ca1c45f16f59744ab9e6a44f3d3687a3573468713de61a691dcb9709b7107942ffee3641b8d0f14bc470bd51bafba548d6c1611645d730d78feb41a35f70d8522353ef3690736afefb58ba988796e471c36d8b063ecc7fbe85d85da825d3373323f4835a3654c5aa14d37586c1d2c92842f2fb48d99307da6052cc9fb540aec662239c2248cf93d3674ab53616eb2274d948c8e16bcf6be71835223c4b5365e12b028cb11e41a9e445c0801ffe61b7a8617ec81b138032de697c8a17895cd2b91ae776d2c5c1366b0a7adc1613bd69cdefae76e5f85d6b2f94b90621a1263a4f0467610b0663bdc021b670eb9f835d86d0786407f5e847c2b5f7f469e1240b357144f4f78f697fbe897336e9e257bd865f7fb8d3590eee85c1418c18f6f1c3692af92d6daac54da2dcdb0a56182097b4b52902bb5b37305aff27b9ccfe79ddb20b7bb07493d291d40ad84772ca36b53a06424ba49043c66b5343fa31ecf013ff48b35fce6056dd3922385849c79f16bf014d8e8d8cb98727b8e27e624cb4bd54f12ec2635a52134456f2ce6386ec62bd9fde227e41ecf648e917853019acee50ee6771c728464604076bb0add555207636ced7b33a997adc6206e992ff9d08785e3ff18bfe54a9a1f25f7612a2d7f154f1a48cfa48c7ace3aa75e1a3f905b9789caf9d20ee46bfeabdd4e683101bb07fcd8b402a9ee0766bbb6676d4e22576fe1a079e6621630bbd6bb71a244a0c4f0ad7d82493865e028a30bfd5a3f3642f153075af219883be203e8d79cdddbf3f535f1df9af1e690e1fd39a2c1f248936c030695581bee080f4e2f392e28379e49c2224ef5f3a5dbd71e29253ef0e1dcf78fa00819ed83c5d43b8eb3e2a08427a80059d29e509636c84416ea75c91341f19262d9ad8453863f03df65cb5a127a5a70f1f40f66b491e396ac70ab0ab91f717ca302ce4a00e08168a752f151aa20099aa92fa8a0fffe6c6628cdc4a6570ae32e33725f62fb9dfaf9b072dc599d84fc1e242c09c3a827293b53f2db3132eda21a4e5679d99911df3030b0b7410ab1de8a5e26fadfc347ed8b2f1709210766e552f715e9b430bb05223c6260d21343e4f5f3af691540b8210485cafc7e7ce1234afb12748985dd39fe69079c5588a13334efcfb8902c0d69d283044bfde87cbe27e0e76d3b43959ef10e58e71f16b7c88e6913be1ce3fa98707920a9e60ef1a9defa962352eba6eeb62c758f8944ee357b5fa96d1afcc950a13d5c1aa60fa4545040922afceaf6f1a570c0584a6cee06cd90a87741e2b21ffe00efb14a175c67370330a537e182eca424c2381b9390ce74641d4c88eb5b4e7ac659435684b44512905f966faa70195123718f4bcbc0bf34f6fba12a058e14d1a65e0c276fb49501b9cd3c864d6934dc80d90c46739a3f1a41da520010279ac97947807b5f6649eb34da887b688d0d1cd8fec5421c5c76537d4b22462e21d13696274761dca6dcbe6597a1ebc592326f134aad44669910db97d098c22842953f7279277580ea21b3706a9c2fe0f4648805814629cfb489dcfe47bdcd9c2cf8c4cc1a3c369772f32b919f1b7291c4b59cf21117e3303bf840e4d1928f406f48ebb0b664b7aec038273498d31fc6edcb427d5d5a2dfb0f62e7d8bb7905289ddfe485ebfe536cc73e8f8d4b84702fec77b153d320409e464a58e8e6a9473ce34a9465d90d70dabe12f750a81544f863e2d2680e7db7f9737a5063d1f206e005b3385cd90774ce677e54e4e2dbc24ae9f7822a01a371da25df01b2c2e65ad96720a8d1331aa48e32ca3f94b6b0ed7d885d54e01ca0eb1e2145639721aa65d235d5b9725de391dc9d118f29ea01f30a21e458df0f237a0056ccc2f82b526fac7f594019e3ebf88901594d58c61c992bd79247b31a09260bb09517721c07c3c51305d13d368ec113812fd27e1bc3c924deea9abd956a1c617e8bba4e0fd5f44483c781324347dbf1bbea80a3e8a2c61910fd000a018e43a64c509d432f931a4ef4fcf6f493c53edc2b89b47542c16c49ec6bc7447c5cd6ed4a4cce0fab251b0ea0cde74b7215583ea1740d52c9dca7b87d4a9eea19d5ce5ea6519bf7263bb067f83124ba314696b0b46b3793f36132c0f56883924f3f2d456cb307a662aa85ac5d9bf86f83aae68850286a1c9eed901fc9b4c90b4670c1d1d2dc1faf5948b665d65763b28b7520c792ea698b18752a6970daaadaac1433cb6763b442117a7d4982f1fe7da63ce6ff020a2834de632abf2d1ff071eb97f2e42fd3a5ada6efb0c91d8bac91260f1069fe826105fc2084cb483a0ef392f1d2c28f41fd64b90835b6c5937d520c01ccbf89e658c5f20081a98c50843cc9c3ba9feac123d0e75b062911726891052bf10751c874b0ca302f5615c25fa252e7aa453e690ee81eb2d6da246d1081e1005a687b3017dc6e05c876361db66e1e9d55de39c05c38006c6e1efb9594c2e384934721f15c67c3f83d48a5ef177b73c51c5e95d571506500bf20b98d1821360767504db6b7125b4bbe051a4f685e252ca49d8b0ee360e379f85116d6b3c4464ee8759ec9d89d1a4a5bee92e19425b8480586a3a0895102a30fdf008cac1ee152cb30f1555f0c2f8d4ffa0ddb4b792fc861cf8dddcba12deeb7c07ff35873aaca83e553bc9acf78444382ba7ed38a54472e22990b1260819d3388d83b8e0758830c6a3cde155c2580d7c703794c825d15eaf45ee053533669305cbc4ddddeeffce6935b1e7e423d690c7bd84570981abefb107ba841055292b62eeecd522ec3df3d2955cb36c5cd86e28add2db030f2f298265f58cbf99a4e096c1cf1129bd22880088e32e368c957460bb87a00160822fa16e7494101029ab4a32d612d7e81b20a347d45e497e64aa22dae9285306f369705fef414a32e342e7ee6a2a3cd6ef0b7cefa0e3f3713346ddcf62e231085859a61ff17bae4c88f644a132f40d9313f4e0af66678f550d75064233b9dbe5be594849b82e634f610a215541d22de8eecdd659f79b5e437358a1e43fb43b92c5d3dab8e727c9f0da812db4ada448e80d885f23d8d3e573f3f6c54fb47c20a959a0ddefe7918ea9cd4502f0e394649d0cd652fd8aa16c5cef508e6870d7ec024b508caa75cc38bfa2a4d2215edf85b065be3c43f91cd60ee1dd6f671768d04bf33ff4739916dbc49def8303d4565f99c0436fefc3fc63f7ba5c3d31e566a93d0e1263a6ed0245673f8c8246a84b77db2bc1c325a57e5b389290bfc16ed166b8617e1b8272da525632001a905830adad01aae55d940af5431371de327b0d2eaf220f7689286446dcfa22d6f56303110483f0a29be08bdc0e25803b7314604c71c4aee1714fe4c206bc9f8493ef70654170a9f917b6f02c624a0341c18b892c8a299035e2edf6231c753390b22334cd86b0177dd53adb962091cc08c7323a78b8b1391f1b1e310550f7cb42f2330ee39392e75ffecaecfcdd2fe0b21ee9f9191ee185f72fae0241e208da9be60a3c1767b2ab880b20c1a1a058a41a5fe3947d16614636fa83f45d01a7d3e1234f599a80d91fb695f0a140ac6cbb78e2513d08badac0d6efdbcebe0ab6fac69861ce4e785b500e95652d99cdd4016fea7b0dd8b7b664287c9eb776a362ed5a58bdf81b4c9db99d4dc62a97a6c78b5e895c6bfb29386010aa9d130aee4db03e787c73ceb077189e86ad9d234d0fd22a9acd30716fe6cacca223418c393b1607261622923da2e98163b7b153dda43e4b73c64bdd4941282bb0784bf634bbaa86d0012deed7702eee7b6663a04d338ea8733a98edefefa4d11391145e1f3e4879e657df594d5f3a439ce86a1a4aa3f0180ee2fad208ecdc8e509a50996be930c66dae3c1f2f2e50ef788e73283a239d44d85136e98eb25fe7110e3c0c6627fce7a50b98a4dcf518f98db30acf5b4f8c43f2e09100afc06349b065cce1f771383d9442a630408499e72531733427deed6e09df16c25b116d2a40503227d3442fccd5fc0e5c17e677aae2b7026ffcc950080ce799cfc284234f32b6e46cdfb31581e98be490dd96915e7015e0ac2f89d92ef00b5f6c3168b1f4797770306ecf4ffc0d6aae66abafd197a3b937f62c1834d999ba58028dfa43e7eab279250a8ed5621556d5ccff6546ca672868b15230d62bfd9a041627aa8e2ac527ab4acf7b83db0fc17c56f77762a8cf074ece378c1b4e5063e5f1b8d44f287b04a960491aab981a04bbda4f8266290b41179c510c83152ab88d7a310fa82d757a8c65306616928c0442181ce91f569252505b9377ea338e4e74cee5eed95b86c6c3c56b926a89721b425316b222b6e04c9c438970fc160d4762d78889d196d1df367d137cce28095bb84f34c5182b747466add0ff04c244e8d49c73adc33f882e87367a7f8fd7b3409e49f16b458542e783066dfc50ff60538948ff5542618180308bd82e7443df82219b3e29c547e7e6578b1636895d1ec5996bde90d42b3c861500c0bcc92332134f2040dfab76e9e717632bab5606011aace4bb1a8257cf040ddcfbff87cf6e18a727612f0afbf4737ad09bacd1249ca77267fa11ae71c18bdb35c7bb65c7fdd5f917e12a23fb939bea50ad8e67cbe3566e1153764f1b0af7a8f2dea35390086976ab2d96a0dbbfd49689d74c5e20d985a627d9d716e9fb207d672b56b9032c3f4b2e910a80b3d55f18c92bbd037cd211c100283bc8a1f514feaad23fe6efb663ac19a5d9739ca729c415fb3e29eb1c3286222dde71fd6e4d30959d7bfc10ca94151f0c838cec869f3fc25a93b7a120000f08477a2a8dcf251a29d9d6f9d7f64476a62be267997e312d2101ce37545e8d527ec7f33f23738865b992c1739aaf02e43cb34499e2f1af97ad099c281cfacaffc4ef7fea3bc5e35ee34e9e4bc8b98bbb28ad4aa5f20d71c23cd1fceda25a7342e4df3aa718afa5cc1c495be3285ba79d5f376c40f43e32f7f2e88f70d909cd1cf1ca2bc3f67cc7b0035148bfbe0a662910cb30c3d39a331a658a9557f367727496abf223b091a880a0528edb560106b3878a0e2b41860d3c27f980a02e7eb124c3f55df3b535def85ec18049252a361286912450de84a72576abdc80edf0368d4f45780f329336b8a376046cf37a3a0446ee4e4f7c8333395c2cf217c1894a096c931711f58dbdf19e38983ae66fd3eccc8434c128729e5bcc7c11ceefc67653872a999dbb62efb3298bc7a5ed60bb2941ace1e3e8c8c330401d145830795ac5b638a7ae77a3474320f406fedfdf3d917aaa041d19b811eb6a9d5c1fb72f466c8f7aa72d52ff1cdefca1c24ccc5dc1238a634f2238b6a8a2f0babff58e4870f672e35a4b940a2819b77d25716420d3c1c4ebf545ef39e3c8aaeaa5891df71426941045b0cdb07669b7b2eba6382e6b57154db8c5501a36d23d63266e8f3ac3daebfee01b7e030a4f0467a9aad94852a0c003adb4a379edf8c34be53dd1804f262586a0e7ce9e55eb13e6589e52cddd91f9e4dba33f80fceb8cac7fdf5a0b298eb96b4bf0dbd59a95b15c0ed7ca16d805dc9f868a72a22a3a3d41ac5d0f37f89262579704560808b77edb1e4951ff857c59dcfe5f6a417b5db92ce0d59f91bb20a1c80421ff59ccbab670e48b9bf1094514de484250608a936d2d1ce0af78786fa1e6f7dd6c9ea56dff588cb2628a931e269f5de53854b8781193e780492049b4b9b34421d526f4a98529b947473830ffa403e6505fc3c25c0615cae3705a0897ea2a1feefa09e6f35945e5f6b08df3d4c242876182f87501352d37e40e54fb21c1ca27f8b59a7a1e8edff5146db71302b6b177c746ca6ea53918f4607eb25f61cd43ab1859f3e803e43e6b7b8cd7717256988f9ef09c9a7e7f24af7e6974660d2aa6872aada91c0cc41d98d5aa6e59e787d8ccdd32c17757f3e71022656c020f64bd2a395b12d79cce325091b17a0509f0144bc5ce5c9c7a19595dec5dcc99751ef0ac05aee664489e627b5ce5b0e2991b72e38c25334ac4e0ee319959be0530236785e28a8d9939b03f2c4ad5cdeb9e5ed7e5e3fcd24c2065b3643aa34df03efbf921543d17446348dd79136fad97baab672bba1b04c8a46f031ab8addad7d685066f0ac63d9963c6891135b2331e4edb9ddeb041d7f04d05c09a496285ec73ac339b10d2aa7e08c55e64836e01a55b1770ab7e841f85c889532c6bcb0cb296ffcafed54141451e16c4e38062fb8e6b0f5cffb72d686db0f176573c6353f5aabab0342d3a657c9b5c18244a2f1e71f7dc981d74d167152ab02c2afb18c4489394cf1dbe51fa1cc243ef13fa7df095223aef4c7d6a2804e1368eaee7cd5c42271c403ca851612135e6704f3d19bbc03211a93a7b9a53dd3c9cdaa7e5e62cb56d97a3d0ac6b23128ba9a86ac25125660a0527fcb1e75079137f949dde9837fc9adca2cb5e4be638a34f8d044e8ae4180f1c066cd1ecaaa990f4d653f34e26ab337d835829edf0a6151760ca9b0f43a26f5b012de5d2c371e523dfed1a761fcc56e942469b635fc74a28dbce03da2f1cadd1a63428e734fdf352914523b7e8eb4a674b13da0ad6d3dfb4e0729d0e251f80da6f20574d4ff83ec9c54632855d2e2f8d49ae3223f57d5c09786b5575201f1fa5a9e93b206e72a0d6c47f93171cfdffa000bd18909d17df3c0087c0de8948c87c34baf2dc10ad1b3dfd891b310263bd35066e27482c18d6448457626c632796beba5e9ec548db70707b7922634d52796f0942a0956290e749918344c1be7ce5f855045227e3ed811796b05fe9def1a5c4d729e1ce808024bc621878da550e6bd4d1d99eb3dfe27d8c99354f56cf0db709e72ca0dc444a89c68b1edb9256d2332132881794451355b6834338711d0aaced0de22e0557842086abaab102e9689be3d5b389bbdf1ec994315714749c66730c7590393788f2b24565f4b545fa4317b09ebba737c5e26f371e39f8bb9128534f9f82ddce004b3722c6ca0ed240a8882b4768f95e9ff9ce6ef50fc334f7da370fd3fc7eff7d87c4d13a48007a224bd53a89004010fcd08b1204e63aa47a1213c6d37a39da2fe62c02ae037101bb47516aeb089cd8cc52846c003586a43b42dc4a67f15929a4946c36e9c7e7cb3e4316400c5866ae49caa9ac2bf349822934cf4de5d4dd61e1b62030f9647123027f1fddea52df0487a4144a6381c29cdb2b7d41137ac9c530fc3dc7fc1d2e5f166e6490563294b0b63f0ce3598c8c13436a0b997775c725cabf467f023f7625f1f532133d9bedc86dd4964019e9f74b9d782cb947686a31ac3ad459ca09476f8a0e46658b7e9cbedbd633358d456155cb0de63bda1b6f60be7d8f1372441892e1b58ca7b0cb2055a23a55552767bd293a1d110feb5ba0f691c4e001d9bf9ca09ee7c347974a4f299440250fe82b790739bd044d6c8e6bc32ad3db8d39e3b8be36387cb17bd81eda60ef8d46d60e83726f450c78ffce024282f41ce1fc4106cf9dc44cb2467fab7315d7764c54f85bdd96e8b08d18a0829ee0d9b7fd7cdf8020ac0302774e1cbbbc646918b9d36fc3975ab5b37e8046993e08563ad99557144e737a818186f8484279927960321922f7845059d03178cbb58826bd2bfb3076d11cdb7c4109df497c41086cf8765cd2c62ba33d639985e5222b57b7022ad1d7ce6c4e398078590b79426468d5b1ffa942a2e22800c871384db21ce04a8e2ba7b4cc992e651f975ebb26eca6e056acc2fd605b62b184f1563afade7f81677430b0e6f04d1411ba56920270c133467f0f7531571f7dc8b3325241757149c16aef7c6716e06ce8f9ed492c3ac758ff8c746ff3f0dfcd21a75c8a9185ae1da2f9ac49a4d1a9077b5bea553e2e7bf2a44aa35d5066e203954e349aca3859d8b5dc48ce76fb29840b37ed9489d56eecc405ee85e8b497be2ca60e347ef486fb62c37d9134ce04d2a79a07daa556aa1b69b19a0d3da0977544cd0f062ec87117c4ca1a5d728df94fb34b86c2600c71a9bcc8aaaf3f029b0ac8d1872990d8827490c697f1a9361f961a0ae84d4d0bb8adc3c3a5071aaa287604011ad767acb0a171573fccf8cf44cc53b73a660e79a7587452aaf4447c7c4e41317907ca08848154218334954500ffe213e052ceb7290eef212ca779f84bf1c679579f4f039d59cea10196c98164203717306328e730abaca6a2cb748f51a37b926f6c7d37e207ca7f5249f4281723a740224d20d26ce8c739a35e3d4a5f3c23c5b83bd591b117e1c1425063fa297d3c7fd8a7d5a90651989f84c5eef5dc656cba75d83c16d7ae4d1f4239edc49bdcd9f7d68b4bcdd26b016a77cb8ab89208e5ae55da15f5dcd61f06639fd589de283d20b457cdf4e97e3ce0173858c9d51c475740d057b8a9aff3d4ee5a11b636051e5ce806504ed4e289c1d57d0ea87d46c272442f39102db3dd9c610dc8861808d528e277050910faed0d9bb54f3487ff415dbb6dd5400b40125e4de6a752387ee54b281839510996ecf4a149d72aaf27e5fc8617a151a9133f28e49c71018a702a34afdb3818f0bea7c40855e1f7d032dbacca42b5bc0fc75e02e71019c36b854774299825c92c648e7db757975069634a9d38bf0e7b11629a4957da9eaec1b1c0e4506192072f7732461d4a5f2d6f14dea9644374bae627bb9b402922de707404f99aadc315e734125fe7de699c084bbd6388be593e5f70c4573bdbd2be4e3b135aff24277a146ecb6c70abaea539edb4dbd474b8756f7a53b2366eb2183d7b16f9f8aae88038efbef107fb4fa90b4ef857973e281c06db64cd350383373a2c8e245437ddb534f62952cc901ece8046e229cd3316a75837ed2786c0d04f16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
