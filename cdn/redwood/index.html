<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32cd6c3996335146e6d3973c2ab00edee720f90b4e6445a7f22a836bad776f38705b57ccc77d818d315bd0f244409a42d126be29b67f2c0fe452a6cf1102fae3d3697a70bdef5616a5d1d02789aaec11c91f0c2229a562f626e134aa6d6bbfd2e3d92c867d894979e8f1698a5903a27e6284c8cbe2ed548c727ad9742f37dc7e8ddbd7cc2f296564846e30b494506425313f102cbbc0931c16e23cb4fb79b4b8165246027379dbe5acffbfd8509273e82a9de1a20941b92a78d1319cf2f87fac7adb46aac702fed0fcf7136a665fb79fc6a50987f1ac1fa05a96b2895663fa703f7645b968f501a67e983f9ec68ab11a00ab472d3bab8f6b37531efaa91848d21a0f4e1008690f2e5b77f171295954c49b17ea044d39fd9709887cdaa5a7065865bf748b266013ed584648087966b02039e02f54f336a23b81276faee60c1798c4078a9dfb25abf0bb9fc06d0ef23828b237738ce813f3124ec1d2d87a181103c553ceecf63cb9d9db3bbaf33376b2b1612cc0018eaac1e71f2479f7ecb6b00fb886fe1288c80f7f304324f2790e403b30832187f64ac16785a928ce8fa0a1480792836d349829f9be8438b638b55e324d8cdc888c324b50894f11c1ff42149bee67f78dd1cb95d8f34c0de794f2592d2d75b56319caa1bade4a488258eedd2af9c4b63a8f55b1b41cd61fec5947b351272114ac25e75687af21e5fc589b300de9f28c5ede75eebb22cf0e06cd6741da7fcc4c69782000d9784134a26564158645593c65abb9da63b60740eee6df0c2418be5d7c2f7f24c8b762f15a06c2297996bdfc45800b811480dc102e448d17d2962a345242675b9fc86d6f5c463eb6a8e43dc8da58b13fc2bd3a1f8858674b39bbc3ccff026327e460b80b2b299323f3ece034f639f3bf1dc080f59c32fb09d2857a4f21ff388bcfc603708f2819859074d65725d2ab66facd8fb7d8d239e4b9d95752ea9f6c8293de0865c3b8265f9a2210752ed2c1b016609b3fa36817a6125217d62199702df3d57da6033ca44adced2812e2ac496431ef754060f49367ce72deb83dd03e86e566e6380e98f98b9f5bcf1ab7fd3e88b0e427402085c338c635f56f4a9ebf51357cadff78316ead490b8a8599c95f1177036db5c5ef7b49c8957730bbc4e09cbdd2d3d7d39c108e7a129903ec011c86718847e3b975d7456797c51142a50fb60a8cf9aadfa40e8e9c86ae2146a25b34052c11b3074bcd8fa8f363e5c9288642e0e9a6443e5670ac37815a1b916f410ef304e3cb76f97692a6698b4ad16a6e1b419a7bdbbac85f5f953cc9fe3333a859b38c87713fa6abb1f30024b3ca79ec0aa4d4da8a7fbd781a0f294b9b84b30772d1d2b33ae3eddb2e934b94a99332378b1d7ac0fd799d7df7d53239d25ba465b4aaf8f0fc2fd18a3c5031dfb264daf76d503b00c8cec2114d7af70a306773ba90269ea3fe4b31ebed2b4119c9936f955f4b86f927525ceb1bcb2fb3ccde8ac7ef41302979d6c6ebf27ad1226c75e3ba2c2c8faa4dcd539b26c5d32aa6debd32e73c233e9cb06a4818d5aa4755014fffc5ee38cac468db82f5144d8547c5d976148f1f208a95b92636b4e3ff452939e37b4c28f49ccb1ca7a9e661777c469844f825f67157cd94c07a80c01a83171d7aea280043a430d711634cadafe04a7cffe04ecd6c6caf188a87fd6e76844870f843555afc6fa3d1c7e1a6823794ad722676a0a5bb12d4c6dece69183b29556ff08e8db78c43ed64fd544067d580b151af00d1b099ab0513b71abc04486c523f312f4111fc3a940f778988592521f89a2dbfa6a3db29d00f22de51381c92fd00e68e704be4526bf238f3ced49dabed617a8627eac4f04ab7717e63d1ad77a3c55343f0e765c06b890cd90bf8bf3d4b5a63cc10efaea5c352ad3840ebd2e4168067c4b7ce6b6049550f1bbd2bafb53c200e2b8a7b661a1f7299e1ce4aa8d26fd45b40e0b15e0881749a8556f99d646190615fe9b0132fde07886b72510342434aef0c4d53a16cb8b505900f4ed8669a8e2d52b58de2de407d5565238782d9a77b559c9e1dcb98074daf6f2f097e73f95834c8446126aed463699d3a4f706d48d09379229e491e49fd43228d67b5da7d3f1b453902dbc7d5b8645f47e28f26dbac0139e988e225625fae9284fb6e67d192e8f266f534a4b4855dd18ca15ffc34ce3beecc354611062564babe397cb96fcea415a03c1e3b75b63f12db73a2ca3f035ad4e93e7a5909393eac025ac133954699e2f0a24a51719975513eaf1f09f412a91001147bfae9726884e8eaee0365b85af4df206b9162ff4868dea2eb844ca1bc73ae5c596e6b0623d4d9c8c3ef89294866aca2c92c906f409f60f6d9f1ef30d408b54ea672604c1057d4fd1d5d266250aebcd35ec4089b9f00ed28db420e743154f285a7fe71817a0c752e7bb09592459462b3d562db39dfca6fe7fb182a8090616fdd3b3814d006e13a93d65c5db1f55c1ac75478f6e5141a2c398d3ac84a42026eb0052002d4ee6cd8537eac15f581d29e344a1c24827485b605639aa2c189ee8b85cbe8571b20a30a88873afd5dfc4d4fed0ba6a3c16c57eee174bbe6fe9afc71810e609039f70e99f15183b670c48babbf4307b7d789fdb3040a80c736942f55075678e1b17d5876c3f493070c27fb931a76e58f42f0ac297d03f55bf070023e48edac24b564eda5e3d40328fc1384e3591db9aa439a65b77028a90306dc2111f10395b6ef094f327193266feb3d4b1b85231393a78c88b15a37713c8b8c3dbc9a0e2849bb50773275731a8dda342b13070cfb6d36b6ccd03a97e5f8a5fcf588687a5b44cda5e7428920984f9cf09f4199a525bc24f5f5960b4f834f78f3958ff24b31c219a0f23ba592464853154c32466e2025b743ed9437522b37e948b2636b54a2264bf0fcfc1232c379ce7bf41aaffef03a9cf47a68fde434b53cca3b41ba0fa49634315c24d1a666aedd9d7750d3fbff22510bdff5d6ec753a1203d4f96c86446e1f23b462580172feef494b627ebbd98d68e7d5ab026b9736b17d386bbf11462464167d5deaeaa3997b4c3f48092c54735b69cfb23860ec6edeaad4b09778e850fc1d4a0b4b389fa71bfa2618b4a05c3aec3455e6fce270cbb845d352faed94ddfa7434e02c510116177f8c25a8653cb4b5521ad247fceec256530211a3de70a9470ff47910732d7dad281b18b52cd8bb6047d9a422a21bc04f8133c6fd2f4e73d21fa015db6395e1298ce179214d29ceaff7734550d482a7570d36fc56e142c1dc68b300bec1ccc6b92559bcf830734e545eaa12fb7d9ca630812a95be88c97b325a289df06d51aedac8523fae2cd02ee94e18424086aa7a80d9071049b5d9019e466af150dfd97da40b09b9027b705e6f8459ac62a489b00f2eb7e87794dc2b48e39ae638371f3615fd6f793781830dd7f60a281031199e9fce8852293e5f71c88bf038be7588352a9b4c991f853fecd78f5efc5ecd6a4ba984963799fa5ea4e323d2ffc3688e3a4b72375629de7d6a2566e805c3d61fec032e887438cfa3fdc9714eb3e56d6c64e7ca7e08f3d8c0fbc3d45db8225372b1e1cfea4d6d008e2f48e4c6dd1831b34482b69928d4f7c08d73d4e65ae364ae99d1013b72f53c28b04e01a068893d0457ca0fa42b4dd177479f00e72302b2e2381d606cf7a3422fd4cdc9e4d36da76f171f3fe76707896625fddecd015daef794e4995176a87f6e878cd9cd635974d25809bf716338d14f03b10716add525d1ade7e51e8eae68a0bfd46991b0b2f4d9c98d5e8a370d230f36490d501b403c5536ea139c447c259cce58324ab2df6ee936f47fff2baa174d2dbb98832c24c49e34eeee793790ac5dfb3214d679d1c714b7cda889aaf0fe0501a9739f4d1b6a733ed4cf523529d68771e97e07b25fc5379f999c59ffee0dfd3fee5dc50e75f3838a80172307daa18abeb8000f02fb7319b90b15939fec2b980337f747c4aba70123ca6ecd6611e1169940b76904873fb6bb6417a47a09d41f40f4aa0120366652035acd542f7d5c44ceade6844e3aa69decd405b57161f687aadfbf065a69d11a7b1c3d5af04d8d92d2c78c5e44d3cc9c49797c1ead46498ffaa471217de2a07e9bfaa5bbeb5dda77489081ceef2023eaee3e6520919a0137c11c0036b518ee5e4820385a3339b06bc55160fad68e3269c4d48133810982dade3d18b5ea3ba6619f352c5fa8b65ab47f712852fd2b9f1004e0e63aec31e36221272198ba271c2d98491ed3320f8ee838fbd823eef5c7fb5af20b402dbb92498327b4583874543c9e1e8b464993376aa7601cd8870bf020a12270a35a75793df7c01cd20428f7d2a41027f1e249de94a13369b9a5b888b3016e2abdb2f6bc9c40ce70aa5c8d89da96574f007e9f399aac2d662abd865bb7d7f5750ac1876235bce0920e7a8acacdfe6bd18cd8ae00388932d0ff33088034bf422819f9d520c427734bdb4c73726752e301c0d8598dc534495eb0bd53841fd4faba4948a6c4b683515916eafec8e9830e093054c0c7ec05748cdfabed26d0099e831a6a52d113455ebc3b5a81c39ed8a26206269937c457c210483f756a5076edd23b7a98abf43bcdd85d9b4f4390c5e6d4f8e49990400f304a0c5693b5dd396880a7a6e4182f37346436d4d383ca5abc11a73975e0eb9f89dbd85bc8c8235dc2c37804a48fec9a9e081b864e0c8818062d298a6f1188b10b9392d308bb2f19bd3d1a4b47cd80282433d12ceeab2cf98484ff992b29328e65fe6adf26b8beb05ebd26dbf6d4e6993f4cfb6d08fad7c3f8cb1927fdf9c45ad517482101f6e6cb1348611568090ed9cd253ee121ea337da5cee80df8f3dfc5f9bfc18b2890a79b2db514ee9b19aa483f649ac4832bfb736336394a80a74a0b35300a9b03c590c57ef15a38a4776312b8e8b4839a89c049569374453a2276e73d0b7d5955eb3e2b0b8f742b0dc866d1934b10673efc60961235a6c4d2971716f666320d2c800394ebf6c9055c1c7e992c0b11cd1e6bbd94d28f20a09dc076633809a1611eed91e2f61e0f1740bac9f13f6d112802e19bff1051aa8652853f8f4459ddab74fff8edf4532a9c2c224bd870e96c3dddb18d9b2f22b430ad06b39ab1b85d93666d87f50a2b27b52d244410cf5fdd649509ff15907e5b6b8e74a49df99e761d3cadfefa2b29c9c917d0978d6e145beb1f2420ab7b5e27c03c5e5fb7b0452748018594f1a9c523cb1955529cc1bfc5c7c5674efa3bbb059329a492a5106c5c836260a3eb9c0c99518b266ad2fbca33dbb895477d42ddbc811e3346d2fb440d527ccb98b47a1b62585f11effe6ce6751ec2ecb348003b4be582af3e4c5cf19f52d1f63adaa7e20e53400c420b558ee031848771d9e88e3b765cd45c7906000efb5aab24ac31eb18e3f932d66b7999eab2160a35d64132b219c69645a0a555599de0676b34e9b1922946b7349d726513aa627ec1e23df73fa7135a45a402e36f0f63a740d99f4529495e75405df38475ebf0734d5d7afc51ae127e1d72d8938b8210d6fa07985acc66913db146658447af0b4d5110d15f42a13e8a93817edf0433e0dc417a4a9815f546589c882b4033b894c597c36e46650522bfd2e0ac62da05beccb02946f3bd2d6302691f18a0b10ee18f0284829c731c2b84d3d9d98c9425b3f0aa23b71db7a5d1277e3675e14ffca62db3f082ccb3d2d6c2e54fbd673949021d5fa09da6e316624e3e7f5ceb22b8dd0d4aac1c4799b95831976db72df075350bae1b66c58e4ff884ccc60d43ef0de1dbbe9f556eaf87c063fa59c2e1d7491bef87c01f79003672eefa83178f40f1882bb80bc6b8e9b4e4a4b464f077039ca8d3dba8e05b3967450ac37ebb099e0888b995c98f2bf65c24c903c9a542343eea549e98ebe80515492f7c17bcd24b9591e22e9749a761889bb908d8f52597dc0f0c6122bfd225dce0e0bd415489f7e791a05823899d58bee145c3f2b6e700e514998e646e16a7374521f89e4b9548412839d656cab39b4713144f7b2aadde92c7b9f20a19c49e0111a4c31c622073ce71fdccca824a452a2e1b33fb4afb86e791fd99b3880fafb49118c9524e82b81b4d2487c86194c55992a9d239ac55013b309f8d500639ef2c6b3ef8a0b77f2c6d401748d1edbbc88a53499edb1cd74737acbcae1577580b3c472d9ed5f6df9603d4507882e2d5fc15f9e485cc4fbd73313ecd7b7bc6f3ed36b130dce6ada83d8e67629d543d2c1adaa5154594f0e7821cf40cee6340b40364f03e8bf0315bf09ec8dbae3c68f79eea97308bc5d0b46e59a97d0e0f59941941be2f2752031bf9c41672aa4911166c71926b41d76f186c71710560cd5b9a2cfe0556797358fe0e0d9599f2cc97c45a358c94b7c6271559666eb5a664905d5f3a8ad942518e6a74a92c245a160d065c6939b2b3563fcf9475957cb88a776c2dbc558e8caa1dfc001bcd83cd917f05ac36b389769cd1ec1c33b5fdb5e7d1681414e0513c422c9b13edc01769b843c7b7de7c7dfa529e7aafd45f814691f486d94c1d6ed856f3593a90c4a9f4b2e767ff3dcc040d9a8072d608180e12dd7d0394e82b051a09b439b5e8d69872393ddeacc5e1e0fb1c939f42f56231389437513dc7292c04fdaeb9907afe6b6d8660d053801b57b940a6d419b96229c012b832ee0887f648eb8eed289d1d739ea378d86c28703ed03666c8bb3c569f226d70d1cb83c71449832d348d48c84bd4d57e526e5c46af1d623bb487c871f363c3fa0f83a7176f09f67bb337824227e78375977d8dbe1a0a15303caf412d4a70a2c407418646a9746a9428a71c77656b977e7b8a0dccfa2678164107051a86321c4326dd1d233b14ee6d13c458a7d3ab11a4da38d5af788f1e7bce5814ef2f5ad6cf47b7f406cd35e2fd224c1941c336b5db2217656457022ece4fe6b5d8eb35e88a038b99c5c4cb5d9c6e60dfa593cc2014b24f6beb35e0c6dab4c4e1daeb127cb01dafb39149f254d9fbcc0d21a0b9511980aa3ce09ae75c44a18c328490d8fd3751a9aa8036e21c20caa757cb95b10c352aac3bd2aac39b3e011389f02e3a30c696c4f13ea281dd908a8721ce76976a7fbbb1a6809736c8ad3eea55254771cd1990923abeb09517fe4049fba804a501c35359a33ec8d71c27d161f145c814464315a2d016f6267262d0d2b61d499d6238f03406828594e730afaf7013faa7af2035916a630baa1af0c011f734da1ce447e8b798494b885a056883c09762fd4ca9f6264f2d81eacf6aa7b4ed7b72ba937b8316e6971b13afe689022a2c852c0c8404b854df27f72558fe3cfa0eb2a2bd6ee92abae52b895c4efc68f104c72f2554cc637d95756edbb244bed5ba4122b6e0ca4645d1670d3ec17a10821a0096d96f67d221cc4128c1253d59d0bd1f16970ba285d33071cfcc23179b56b06248482ca464947faff90ef7b3e81afa086f94e543faf68223ddeff6b1ac8b2fd8d6a468b4a3bb4f8dc40953cd0812437a4169ff90b10bacf610fb2ac02c7ee751e0014890a9f823dd24fd192432cefefa3b817a2f3eb61cbbe21b64627fa5f27322cd48da8199a3b2c171e113982bacedbaaad774cb02f5ea52254ad4ddec08f478b85193e98c1aa4656292089d43e13ef5f9b6bdeccddfe73f23e58989f0bd772cafec2d016265054f4b42bb8886f10b962ff9c4c3fa3f54fd4ba0cd7da6fa9fb8c25c56d4776642e5eb223d5f9510438701fcab03d6a5b915234831cb4cb5ff8119fdf39c324e50e552ce509e941fa7aaf534ca62ed29823e55d60c69f7379678b633c53cb379c8a6a5b5582d34e8e1c70a887b825dd88dd280f051ce41fdb4e8fae8fb7ea6a7d4f021e74d984d8f224cc2b92e1fdf35c15d6611f8e40c88ceb28384408dda50fbf95119be0eac58062e0e834aa5c353f49156c73ad569dfd94dd5bc38b64e2d268eaf473692d59d52d1dd38bceb391f728b419d8bf10ea5af6ed8e9175a8b3e7eee9340fb368958424662780ca39714d912f7667018718930139b06a7dd25b70de67fab5c2f79747731c9f75e7bf370d86283c010f58dd18c38494c5f2074d4b729abf94700c68bb8165c1390429451d8f15e61ec811e277c2928d62a41fd03d5357337ad9dd27b17e24eac6878fbda8a0d7c50ff8b3068505d906ee2358f71be964c8abb8b0d55ca8f007c128c3d7ec55af2dfccffa2d9ecdf4258bb7f5e0db0959ae551343f45530273732ac9b5760334729a3daa741fba9355dd2d2c58a5dcf3adeb1809048ec073ace4bc56057ad3617465be307b642512db62f70f8827a92ea11a50f3d5caf0725c8e517a662555e67ff9ea9933271b270420eddac5d1ad7964b7ef9c227af34fc0a5da6e7919b8dcfad5d164146ab9e11266551d38db83161cc21c60e2716d97377078fbadde430e778b7d47ee0cafe35ef9b82c1033aa10e14fde5eb3ef62c974c502271b05bf94cb9b0b51a5361eb9cda37aae70f9bd27aa0512e15c20986ea295fd5040d923c823959c10427f757f18a87c3700dffb97388dcf877b09046e019b4c5385f68363d7053e413845e6062681391fc9792bf637536e145b2aa1b40fdfe43f2d6f47d281ff28323ddfe6f1a33aacbc82c4bfd097cae0ef952b0915783267f4e0c27c1918c1e1cf0125a31141381c5f484afded85db99b2e7f5e8371f2f8622f7bdb3c035294d7d2a9d36d33dc09fab0d06e8dba474be6e651f8518cc15529edb50b83b7ed47d032e6d5965e38bc30b40184ab831de119c6d334ff0c7ddf255a43bc6b556110e2f2294f66c009abb2e7ab66a2ce2f3648028cd29d25863dbfafe9c120065e0b08a0f31e3edab174ad37f43e9485a9339c3957be806e6c786d3d9fce3175bf63d8e59375d53709c269804983a1d64a54fc3e70698d0af3bc9b1a75fa9a4c77565d8a9ee8398012e6d688bba7efbe5a6472936289e7bb16814bb1f35d91992c00ed05326427cb57212f983a1448da85fb880f0fc77f49764a724564f6d622fc6b2c5c9be5c3fe10a23604421265f2ae9ff288a7f0c49a038b8ebc8bc4fb066359b65fead070fbdfb1ff50b7a359d2c744bd5e7e9f13a3ae0d519a69bd4880f70238953856b9d589bf3282d0efe688619e494a6c7f399f529f83b8d04f28a96f6e114d53d3d8a71e8e5148a0073bea5a037f629b0945bad2ce7bcf562a2da963afe3455bc23d94e989b45a6e4c93c2516b980bf8c732faac8a70dcc71281cddf557bc8b7956c00a9a680b6882570b65bd0cdbe9895042ef0b1e2634f4830787e557f30ae836c092aed93bb1290a92314792b00f21ca4bb5baa0f6143a7eaacb31076c1ef95ed8974e4fd4e7837b3b4ef14cca9717a90fa9c2b6b9f2c9f85b53ea261ef19c36f8b02dfdd5c1fc2afcaa9ed3aced9165b40efeba68c3dea3eab9cb9de30a16a6c0e3c2e7e66b40fa65d62da4e375667ff7dee0267f615870273841f39a81eb43e9f39594a6595a6937ffc9cbcecafd9e4f26834ea64a2eb93a9fa860a429082ec63e02796b11371de9a02a715e0075803eed8aab677000db76af87c696f0c3fa67fe85e3e5e2dffe6a8cce22a490689e47397ba977d3ba1611b79e0c6f07e6f32b506e01b535f07bdc1014403476161313b77f9eefa1489b1000aa49dda5991dedb795a0f71efdbf4c8e63d27438fed6eb0aeb733c7d12007cac1d3670f306f1661596bb3849b31512019c19b9b6a80831b419194ec70d751253c054ee2ae2a4d207113cc792994b651b2c32bc889ce1aacf8e4f8a589fcbea0d7cd4f1f747fe498fa6616848d608c0165a4ec1c08c50d4e1fa3ad31787cea9496478de916bb7c82d32cfaa24073713cca07f72ba339c2e5725dada4f4551724557f47fc50f1720c337607239d7ca22edb8d2786ae4111ed1757a967d9fd40bec6c8127463fc14720e06107ece5c0861e83f458e3eed2e7df075d0dde7d2504cdaea0508ed734c9da7e6c80c82bc584808625abcf136c48e58554c6b7376a63507e07d526712a43cd2afd12f540186b07d37147e4026d274b3b779f7b7a847a5357a24b1f791b33e681eb4fd457165e9442b9facdc185ba36226a2dfd8644089aa61ef705a641ae9e2b9453123a0c09295327fc018688d0ecbba7944d4d3871aaea40167a9b97b831b584d706f651fdfd17c871373c97d6b6887c8d4d360e591968fae026a418d92ce26539ee49f25820e2f77b740ded955d9c3a525b4410ddea9e3fe65432f8d00bb13cd01626573cd8c5490317e5d25b14c40dbf8aa1848b94c2f3506d59ec98b077de40428f11e3046986a77ae9fc778924b387ef75cec2f525d4fa2f9f5ee54aeff6f78cac68ce3ea1cd87f48f39e5ecd616a9e1790566049eb109909be2a87133d3b2f1d4f762bed5e9e5095c6dfd4a62108d0b8aad571b2c75d8b008d25bad0fbca4ce86eff5cb1db5b09c1e6f85b99663e53d2b3a59835d28c6fac24d6a048f6e4ff2e0a753f5930b4dc09e5f3be125d8b36c5da54f2b13d8d7a21f6553e24086dc91eae8c142c8fabedd652387a8efab982096b34660c126d98bedc512e42880a6075fc8a39b529dd891903f01bacb657dcd7151ea2c2bd26f98c7b2623abf40b678224defcfbe4c53370850b56b55ecffcaca31c8bed4479ce9306854bdd185e0d39e1458fd67dd01a979b440b68a7301a6efff670362628f9d65244ee1392aef939e4b98f91390a15937400d22e1210dc036b21f5a1d21b47a4701df4330fe2097d0dbba25a552049e593fde4d3cacb32fa110fa2e8d5aff959bdeea6fe53af69f768d84148bd5aed1c4d56c7625c670957783c98787b9ad3e7d712da7afa182e97542c56d9f3c3b9d86526e5976990bde86e5c681237ccb901dd3a50eb06fb50171eb32954f619bc1a4bcba9eb9b9f38808fba6385ce904816a02e41dc80e5ec176289881b540640ca2a12c5d0e57d5a1c77b82ed6ab4da5134c27337a9dbfdcd21c02ac4bc02f1fa0279651e232179d294a348bc74e238e584ccb5c48888793ee98e56420a1b9fda957fec23e6f4804f2e486ca49c65f8cc47be4dd0093513ca75a521b24c94a1db31cf8bc618abf08abff742facf2a292f400cd7cd9e2dfc854661e3332a61672e4e3557dd7f34c8df2f46148661512faea16cf81b47e20b56b15073c2f376fb4532e0480fde06d8fb74d35145ab57c7a1049cfa912a656cf41f943a6bc9c9947316db06c3c1980395e8ec250938d0eea95af3bc165a4e369ab14ad75cb5a41576dd3231c024994ed7a110769d406d87e252dac1391ce6211aadb1c3307d8c16ed99bb0082d8593fd00e37041f56c754c439d1aaf37a724412c7f8156f6d2dea4d8631be60ad262860f5c34c11a5fab554d7e34dc87e9303928cb8d200cc69799d77fc747117c1baa11bc2fff99ae17d3a4db6c54704622db218929a98eb96f4610fcc8b1519047f04e86b2921f99efbe8d9276386ab26b3408d13c34f190d73b9b5b9c9f56e107af347b91f42cc8798378545dc081fcc331df98b2fd463f6df2b3e5d40fd8ba1396af4c159d798e61f14fdcfbafc4b0c602843e7d41b93671305cc09975395b5fcc88e8ee565c2d0094c3922b47be4345542abdc74b48d7ad4cf2846bd9484e562c4378c7da89445230b480f8cffc98a9800195f4aece56a64113f1e5bfffb7cb5e9970e35850d762101ccf99a6944c04bd2ea0dd688077d108c826410256a14b8c57206ce65d861c7bae667103d64811c2ffaa80075a8679bbbf68d1b3bb714a3afaec1d9f22e61647413a8957a7acc8d0c08bbffeaf65c561763252e408640ce4913f74fe77ead4e33f66d8b88bd15c07390e72a34015d3a11f27ca8303afb67da9dab494515490e1ebddbea4757747053763681e0e00fb17bd71fb1b815ac822beb815a3a9fa52faf7e326d05be3b69a5c76cff29a7ac91ad7cc44b530075b1555c50126c42eb75d377564af46db9a9a43a671f35c7cb58da8ed984a8507c25ee340be7db99b0f40af9ddab853cea2e993bc7b11f915213febf83bbe535804876f23746e8708554dd8346319d0ac11348d529642e9973ccfb29e3f1b9c780ca51945dce98ceadd35390d66b0ecfb1ccb9ca80fb53483fa9ed972bea2b20d52ed2e04d04c920cd5ff7e95cd1b44529a67a96af645fc97730a38539a4b69de665eb410769807cdb18e2c1c96eb72eff7e08fc5181ef224c40d3ac5e44554da9f9ffbea5d525dfb02d0c4677a5252fe5e7fb3258e9862f4cbc519190e59f61a00a8155d77b575fd38d4f823dafba8ded285fc6fda5249a3c23e5d8fa94d1c3bceb6e5d4edfafff4d61e55d26b9def9a445479cd9008d236b376e1875d2d910393dc94b976a29c884deb63fe1c95eb327a356ededa151f5e468ea73a0194b6cbaa5ee5c387694fff7e349324a586d2d7041ff7d16bbaf357db1c8ae04c390eaa47ef8a950d2a0f2e3829c513a64b2311e95149087ad701ec29ca02d9136815ee7b16ad627c25ba9aa374b2799aabda8b07d3471fd512fe0591721c6736f8416aab0447645e4be37232e136b2fca87aa70c62c491bd074926e1cde3e148c15217580c08954c805464e340f898b3c5dfe54a93dba0c7c99912c3877934f7ce3aaffb135d7813bd6afb85934e98e370f4d72addaed1a22b3bde978a6a89c4c54c3786e9f26e09d94472f6ba98a3e781f9e57474104c92d463c3234c8b36463f1432bc11754aa72392796812ae8c4b1a8a5108fb828be292cc506dd07862288a1de411e363f7a5cfe183245924a6816f831c4f1ec78dd1c6807bf76b408ffc31fd61e269429e8cb6648fbd3bc4b3248c05cc18dffd89e3ddc00b23ec37d87a376634018d609f51e3c1018c807f431e2d7a726ee9af86d4e2680921c96d15bbdf7a0c77d1f77867d0fd0919f12964ba65ca0562711b6acd54b3f3dfd769964f84abeabff672df351385f9dab8626390dc50917289be95ee8a46861b768a859d4590f5db484bc1cd4c8a994083b36011aa0489af8a59c0ddca5f6bb021f679b56382e03865705bb4ef896f67d7d06271e0a22cfda0be93fa6054baabe46f171e73db9f377a3af30df6c8928797a7bfbd5e923b52cf869fb93b2d9ae9c69155aa3423e96626fbbb0aca7a551f85fd870dd68f28d2a88310cf3ec00cb09791885e74afc77f50680e30084e4914a8edeff181bda5f011b69efe844312d77e1c92e189e08b7a4881fde343c5c3b995a7bd4b15c1bbb6121c3f60cf9a3122cfc2bda2cfd460a0a817e238a39f96f425c56198adbe863cfee051ec019ebaa250f600ec6e6361c94068c8e0ff5423e6c727f6c7ea7d358f6409e13203faeb60ad6086e6f0a8aa0777a051dc325c980c478e89f95e898b761cb53829bddbc2c516d8025f67499ed1938447784288fd2c548994d174cabc7504ec8eb4f94018acaef1c24eabe98dec9cd27caadd9e65d1157570373e7beafaaa89ce4da6d6f5fc64c35df77174de18b929634675a2a6b9a3c7f4c14e50b542b51ee1d214933ac8071da3bf0b31e60565fd6e534571ef2f2193a4cb60f44bf13e31df22df2d67a1d74f0fe2d2ac8387741cab70416524678de6b350e17508b0b67a672196ef0343ddb09ded0203450f51b137af75cdb86efed8c7833341cfda03346b9085379c4ab28a939fb63b2d200f13038632e5d4a51087e2a1539a71f496d3553cfb70078046867f45efa0d2f8148df412585f069ea7c09da2e09af2fcd98c4f61b945a2e84a34f8afb4661278ed407ab7da5fe351186a3225799b0f4f888b7b98a5c71b8e6f9f372a86821b5fa21a0d4d91a89a53ddfd86b9b1450c4e760613aaf1162dd2191095577be1e17421cd7e910cf2bd76be2c1e3c03fd7d362c6016626a0a2cb78a957449738b3199833129bf92496172c05874fa01a6caed74f10f90b4b4380b68cf49d637cd459d95886d052aec164f23e0e181f38ab2526cd9d088065bde5f8e84f804ef5a34255c457ba95eeb4200a8fab7dcc96822732c6f8057e5cb333e42da9ee3dfc3eee0b784dcc590560721f8663ae7adde46ca842ba5415a93ec3edc9c03b16ec61724c3065c8a2e439bc6249396aa9adc3bfcaf3a697b8dcb58c59611646ba94bc9067c396cf74ba970c9dec871f112dfa1f1dc24f4d4897b4049c71fbe25e19b22cb7b26a1a1bd8719d7779961b22299a5ec1043cf14d46147a28be655702236a360f822b9bd06f0cfd41c49b60db071a9b9a029f160557717a74171fba3a790ebae519eab05df8c287128e587d2246b196edf8dcb6f50b94d3c63b68e75bed0395e1afe515203d33028ca054227119066df22f719c923f96ae371446bfe13f6d24c7d4259c45f115aa9700657497adfba7834335fc6aa960850a2dfe560117ed0cb0acba9018db95131f735efb6cb892d41f4c321385c858449400957513fe478ac34305f7b5285b80ca6e992bed231fc4c241e3bf6d0c4acd824b9dd96ecf2d59a926a451b272916d04f3b7ae3e2b0400eb7a671f485b64d498d72cfc13f43daf9c6133bbd81cc457da99b783fbdd31231e43fb11b5657e44a22832f2f440fad76250ba9ba8bf03ae2c2d19abda43e740a585c31bf526d22a8d62ff1048df38aacd9196e28aa7b766ef84653d697c3c015b111ae942d10a8d065a0621f7131f0996c518ded7b9cd959b78ad72e7de5e3d308f892c09d9b573ecb5e4a9eb46c1128caad9715fef2b1f03fd82b45fc975392cf4864c3680e5413084fc170bebd11a0e3c356b5856c627039d39b3a399f7fd210345968fe485e397e9daa44911e9914737f55162ab4e1b70b210d00ef8079bcd9cd4ac72e8d5bac0b5193697f48fd89de95d8aa52dc1c3407b31bd814f94c6d220a55499ea66fb8797ac40859b3bd9f3fa122d623fc74a235df1d42fcf701bd9a7d3dba2137849ff56dc3c9d3454bd5cfd46fc61448a84d3258301f351cd16a440550cf692d41ada59efb9bfb747e267f791b769fbecf1c509ecde663763e20e19c8e5f7e82604de1d446541d22377aeb408bb8479b7cfa0046d82235717fa34ecaf4f9299531d9fe1a2ee2c69bd48c1995c1e9f9e854306ad0a40a343f6f4203858c1ceb4400ff33ae023ae294c0d4c717c95fc3772dff36df226ada544c8d2834db14c5996b0c873d58d1c641a2b40a32134aaa5678d64cec06e9353e3535a7f486e2075a67115813633f7d292bf623ccdbdfcf026c74b39f30c548d62823539d444d8070005be9302c0a421ae87e8105bda880bf0b8294ed590ea92198a328e4ff3654ed7892c6982eb877e427af7ef687bbedcc57aca85c421d3e437441936676c51df089e9ab3c84b2575e067b22bf78f570e4c11f2e218a1f65efe8d7be8e819dde353dc42c0d9788551bc8a648fe805361b55a42c6715d828eea3aa126ae6f862b0152411e6a797fea22a1f0288ef12079823a0e018271e78efa6e573c6f6fc81088ecd7fe092a8eaea43a8e762400d7b3d763277595b1181a378c4238dfd96216894c9180d468136492047ea88c09ab3f1ef855314f637ff10cc13761c44eb7e5c2a5f848bde0e402eb386cbed9ae6b09795b4bb449ac8b0a0a48158faf36da0fe22d7a4228c30a9447f38fe78cf952a68fa06d447e665f3896c8d05086bcb1e46e25964fb435f50a5b15dc6ce25b05c1e42b74f06fcf4f430f44e694183d5c0ea70c1a3284dc0640be2f1d5f0b0da2f140465a052e824d498b61f1522ddb1b9fffda8ebf0b019cfdbbd81a77684c59e9ea9e8aebf3fe9038e87697a8e4c962ff5faf91c550c5330b5834644796ccddf17c9c5506a5446ccf7accff7bb49cf3d2556014432f63b58502f6b40b77b41ad63d7d2233bf6fbbcdca54534496553d22f859a46a3496f3da0cd1ffa2e00cdf21bc8c75965fa37a7d2bc7f9da65183d749752585de76c299066aeae16052f660cd20b996af18e5ce8ac6749accf7aa2154f8fadd3bf1530d00140b997ff90c4b01fecfc6d28ee3f88792bbb8c0462b3a8cf3b746db5710575931caebf9101ffe691ec16f218bfb03a185494d7d3f26417a7ebf1e87b7131a59bd00060275d2d1f2dcacbb20d4b90bc32eb6cd1c80674754b6c98780495920a70fd4f8ea4ae57cfb059434d014c8202658ff1c8796cee8f67bccdc19268695b27bce5a197104f614cfa43910e60b5c49843a4ddffec428cf22c3be0e59c990e0fe3aa9c0014e4f3df98de8e72de29bfaeb9ec1894c8191c24865a416137374411cc99e9687f8127a4978d05fc79c19ecee108e9c1c3b18a275fe117b59358581f7ce3848efceaea7a51bd07a03950e1b3da5111d71cdfcce7a56693697bfa6df86c6027d6dcfc5a0535e3f2e5d12446ad7982bec612f7470d10903694bb041224ecb683a87aa107ad0c6eb12ccfca76a3a2b96f431184b80d85576dd7aff2abde2792a576b2842f0819a244bc01335db1dbd3b7fc65eeed44048b2b8616bc15a59d6f41ad7c20c874a7aedd9575f1ff13bc35b1c536669ddc5052eaeebb5ea104a70be5b7fee03a98dc2813dab88a011c8d160caffe331840180d68f79f6532927c31af6cd249f120db4fb12028ce44c1f47e97a9cf6e1a08468073607b4813a52ae30df13a428054195b701d5faacb5bb1d52ec93b2880791a7ace0fb5f304ddcd6657e19dabb005547f86b921a78bc01a384bea38329008faec7918403d93b378937872eb87e87251eb64f601a6c846570436e0f3fcbc80a43f465709714b1a93043cf938ef0298b9c70f19c06679803471dfa097b5184c5cbe713a012ec1e1e3ceef83a665d478e5d933704b0c571707eb25fd4b41e633b03714b605cbbc84c1ed81d6d07966cc089011494135b98c5256dbd02bbf738a7b8b3882fb386daf02bf116f52306f4448aec24691310c4d093501855d489db901d8201445181e5f5cc640d238cdf4c0ae0a84d73de180de9abe4809bee48f0adbe1cf1cb379515a9561e618f52f81fb796888102d7096ab2be1e2e9af8cc54067d9719907bfda2209146dc1551e0be2dc60c0dc927db9dfb5053214531e2e6508c0b4c0d50231b5068f825448b96e1c2a9135c3527a28faa7e5fa3e0412d83ae1c8862abb9a172264b6170aab8f27cf88a3d761e1952847ac908a3daa947874670080fa9f87081dde7cfde565773ab87eaa9cc47e2439d084e1b45a767711f912cc241cec3a5247a718122b6fb81b21e1367ded6dc5f24f53db6b567600fea751b6aa896e7a41a088b795c233e9dde79b7543ec5f8c395a281fde334bc358010f6049a7b4cbbaad3dcc82cbcfb21803598f70e1d66337f0a428a2e59e483a3e847029ca578814cdd16ff0646fd410a824e3f0284d690e4dcd96f5bef7241c26ace0b718f094bd974a93c9bda68a34d90ec142f5f7291e7b77bd3acc74e455d1af7b640a1b9afe443007f33e60d31c75b6040a956871e9a874963a315a8a11fbdc59c553889e7e0eb62485f6fe9fca2957d1bd8f7abb12013a039be6f2904802ab0185d9d6db0952ccca72e344cae564a1d6195eb7d220d963a13a1b990909f765f58011875c7b26da65c9530f4b304c708077165af840b27768d80bf19d518d30357f7a0bf73c1dcd35868f0cbc9113f4425b8069b256c534ff240ef2152ead1baed4b7e7afce1b706fa084de62816bbb9c6dac3368b904b4ccca4a9247164cd53f1c7a43854396711a2263d9a8afdeaaf5b024fa04c51f8c6bdbbe5abc20e06310ce9b03a74b233e8f31121b95baf06ca63fb3c08cae5604be95d9629d609695e8c0424bdb66dde78177028d7efc380d7989064baf32b0050277bcd49799407b4081cd687aa5249b80728d7976a5af9c01d80a6a582d73132ab4efc1f0da9e1c65e0e580b97e67e87f05ae18338fc74d05f19dbe4da977ca83a68a813ed032eb3e1da6cb5cfc318baad633bb1a26890a8140cb8b35e7a6f6f326fd90617571e0837792fa6294352b8199045d99e58b6964374","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
