<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80fce1798ff058fdde7841a9ca97b04a253cf8511b2c0b013208279569f5af3f1df6cbb11d36f8c6a36992867482121ba82371ac9bdd3f6f07509adbbd385ce22fb6fbf74f65f7122114e93d477235b032b7b9734f8846f00f964cbb333cd7b5cad35865bef330ef6dde16f3d6574274744885ccb9ca18950a7b2c96dda2ab305a059845b4a78210d48b3d6945cf5d4ce33b8eec446545d782265cadc7e52b6391f6755df6ab2b2bb7894c448e3f208e68fd59a0e37f3401c8d81dd9428be6f14eeee2dc0899f0e9666600bc5849f216c35a86a9aa93c66e65e2445b49888ee6587ce4097ff35d213ba18f7b4578c366860f5236491644f948131d4d88ff20464c74f4686dcc04d3f7967c79249c6d8eeceef5d224a6fcf5532439beb171fb09a5fa9f81501d7daf8dfcb1599bb88564a98baae16283fa056d3f3564874702d0708827e5fe27811530e30dc2d6925bcdc02f3dc23f4df77b4f5342daf6c3e4006a50e0be95b7ed245b6ae591eda34cadacad43dbcf3ad704a62e5a0609b55d0acc6df1d893c248207c3e29c635dfd82827ec494c01867aadcf7e1485648c8f0b1a04a69f49aff6d8a54c985366d43fcae2689c77cceb94d3ce8d3557dea8b20b29a5f1f48c1cb737749f41ec5c36e3943c146a6b3d19bf3494041f0de5d702cf4bb6b37d0074702edc107e06384a4f7b843fb2b36813e904396293fa22d14b188244c7b31099353efca957ed3e15e85828ff7162cf3b222883e8a0e8e1f62b9231c22326e3bef2ed23196f5ba0b04bbd42e5cf1dae556f782d62eb8b6bd3830e974ad111908cba6647d057e7e612acc545deecda0e8e85c4955382e2f374a453e37e17547790c1a70b2209511fc4e34a9dcb1f7abc2c881c792dcc5d6cc6e790adc37966a11845c0b2e822f265e295d43c8a4a97147ed64bc183f5e551a9aeb78517b7d007ed5dc3cbc1a488449f833fc340746990e4d9ca0816e0b66a4571b2ad1f413d2ec4c181cb7444792d291416d3351ad2a0a888254a74eb425c48eb76974f1dce282cccf617ef1698980377b8f6b3fb6cce28642db8f75a390a458970c5764700183aa03f472462adf63dd6dae0f6db121313eecc555a1e5350c7f99ccf4248d48468e01708f771643427b0de3a2cb5fc0ce594d80cf64f8c1ef33061e299394f1f2fc41fd3b35c88cf99e0676a995aa98f20baa1915b9c5794b77044e4601fcd886893dcb6c3c3782823983539e47e3786778165b469b313b7ba15bab85d4f448c9c76aeba644ee0232350c961c95acf3096f8a2022ec49d84e4e98d5674c891b197fda2b9ee41005dbfbf4c39185c18f9170b5bfa1f849bab3db7ea4f988ca7f7faab9f3a514a7a0c27094f05259af0790fa67a3902084cfe4d6d0d2253cb888059fdb8497441a7cd05f86d25858fe18f8725e1c6904271a55f76ed96683bba10ceee536272db781a2dbbef9278c8a1e64a5a488f8d37abd01dda225af2b0ee32a1308d208f0211e4e331995a2589a0316fc379691b2a403f43c7f31dcfb712584608054c7dd8fc1421abd1e089c9f391e61e4b3e5697e773ad163599e0f79422c9997d785073f169d4ff4a33cc64c7acb02d1904d5106ddcecd01c100bead448d5ee80c43947c7806e8f5b29137f7d5220792bf7cc9bfed35fb6497b2f44753883cb59b279834b8a4c8f5c5287608ad4044a35053f34e5fd22af3ae64af26ae72828c9079eba12fad5d37f2a8da38880d9d1bec382950b258c611fc33064b6feed14b8e01f95ab6677ed6fb27cdc9aca86c2eeebb02e334bbddf7b0bc927fa1438db632a4c7498eaa7ff8a8b85a0bdea7597dbeb9a2e745db7a76e5e3c25dc5a44a93b880713dc1769c971ecc0fcc4da8427c9062925afb9368e8bead75d22094ccc239a4a3e7f647539cbd76afd0c2181ea9f4d6d9aab0f2b96b8e1d4e2d1f39f8b834d05d043e5d0c6f21cde4045dfaf10b9215b7f498cc91c3bde352df935fe8115e7e3e905ccf5a1d0bd875abd6e01bf37529f3d6817b3f7753c191b6c2913af80b4427b09246781833046ad51651088c96efc3ed2fa89f95dcee6a195d0113f08ce501691096ae8a61628f2fc7ebd7589d708defe729c1e1543fabf5d9198112eb2f7437cbf74a78423aa901f6b45467cd68d69309d121b7eca31cddbeff9ea96af8e8205df40c1e563d020129f5a361f3e869bb456c4e7a8696ea62f4d99346fd140ba8b6bdde6e3b2f57137f346079aa23b5a71956f29bf90154f6950801062a9bdc60a0432006fc3fe6b8e4c34bafcc32179856c9ffa7d7ffc48e57749a2ab56fa0c9f7bcf8501a1856adac4c5a3c433e005cc400772a1f34acf62aa8696f56b2179e9ab5f9a264a6ad81369c4069dabb9b48a3b4d33c632f267722cfa7cbeb9997a839dfb9808e10db745c183795c1fbefb99e5f254282b882194887ebdd750e99654cf7bd070bb7e4aea1d52878d2009f6b9999e56a7df04aa04bd53b829d5675d0c808d32780ac17ded009c52b9b278d45cb2cf173018ff07cec55aa0e5cd517bde68bb1380ac77cd9623b86f234249c50f16fe87e37a1839e71e1b0c43a97bbdd841dec63bfd589ddcc82c9ddb64e46f08db01ff901905b1b61d36d5c116b6a4a9a7300326e8a700ab8be9eb29b0467888f989cb1cf5c8f79d1d1ba9c373e9d4b6f5b25a03e24d583037bfb89ec83bef16ff5b09f2004fbe84c2b7df4aa42619b55189e515c4deed62ab9bd050e5275c1503651068748fa09b7ead616f9842eeed7725a0305e9ded7bd8e3b3ef11fd1914c4a1abb94b5ab056b8384475e3492824f97d8f603793c3ab58f496502b807fc2e925f47e49beb985217d22961a44184acd715234fbc5361760290dd087901eda6c1401b7cf3b5eedf37ebef916c39dccb7ab0c609d806f9d409889e6793759a11ad126f43b0a82187bde11bfdfef41dbfd54cef684368711ad1209cc58dd3b032261ad1521ce7db95486fa43a5bbe5823abd12dcb51817ac6cf8fcaf66f9b30f0797e5002e5eece195cf8fd4420532267cc845b81472a7c1f2bd985d812057fbc08d96be7d14b06c1ce8617318f86c0e2fd8d1bfa89bada97ef7918ad752012e6eaefd7957a2fc7d275067021b7bde3b44afe844b002f805db78bbd796841406eaf4dda41ad62bf59df8e9ff37098f93c18682c1f73ada8eaaf9b2c7588e9d443500b0a48fd725aab61fa1f18523fe530e8dc9de7855372fc50f8e598d5a2b5e2ed1030c9e7f8489acb8e4035cfd44744f6162ecd088359f7f9da8afc819bbb1d918eb29b0d85cbc9eb0e9dcde24b9ffce1ae8b23b3e47ebc159eb5a0805500037261ecac4ca57fe148a691577a65cac73ad447d6e4056fdf684bcc05d0f659777db03f987e658fded16959e1ad16907efa608cb96fcc8c81cbfefaddcc291df160f250bedd8e2e87a6c4548373d287c4603edaf301b0ca19a10f0eae353faeee4de153bd6ef95bdb060255d674c3401c7188cb0251b6bbd4455e0cd670ce871e8fba437f020e93dfd771e84bcfb0c5a3dc4c3b503f8d7bb71e8b5ea65917648ede69499b32f2c71c4e7a313262c78cec0baa2df47b4c0fe82952e4200c9fd8a4205e8c0705d9baa1e410b49f27c885cda6dc05bd3c93f67cb4a6f3cebc3330f66af85c0f0fbb642eca8fb06b5cdaa202205ecf261a15c9b263a8c551e4989946ce55d92749e56b83f32a7748cd224eb77c6c11e7041a5ed14cf8395bd074fa25430040cee9ab7b64faccb4637dc27367322efb9241a6589c0d172fb7f799a839261b207dc226a84e4dc1bbb08e81139b3eaa3ea56eb49b445264dc79c630448292a728a2ddbfcfc0aadf09550e19450d8a37b7ff29191af35a5479354da29768894854a143c8ffb23d2cabda768cda0e8a3c4561f670f4262534e68d6248848b5db8886aa0cdb4c45c32c544e6f2f5b4ca47aa41760eb552ed66d1cf2309221ef5e9cbd6bed73600180a7edfb6248f7bd9146e8b7ca0afb9ea44f4a30c5a2f99eec03e5b79f23d58e07c96d598682bfa9c6d054f307ee4254114be857cf2f1ad7626508be0740df4beb18b5db0e899b0207afe3b5825364b20fb600e11e6d2907a838662e6d5da18e356e56d05dc8b0b02eb1f527327a211c797edc5b1973f45d55ec86e863263278ae12b32ae25ff49e991a8fcf4377a3ef3488239ceaba28bf76f604323c49cd0204297743941c8eaf3f83c74cc9a51436f4168a5f90ef059c602beb69a6d9f6af454d703f4fda21868cb3f7463c6a8edd13cf4de69bb52d251b1543abc3664fa8b12f714c9070673b19ab1e0b7500add26e359ceee5a862f0465026d582e354aecb5da42f5d37f0cd35d851f6ba40b7a77030df7b2579a3df86bce16f463b32e352944cf01d3f0866a9408b96c3ded46eb2b869803b550bb53c289ccfa166c1982412824440dad19262a9072c2af714b6dac333ff8b00b722fab6699711f0c536ba16229cd3a1b3d845980beb09125b1d9d8c633dcb911fb4c1d3228c51a08bfc2e1636ead311fd0bb89f429b4111c1d147641381e4bd9883298197b47c1acf13673cf9416ac15383972a3c3be964c86586dd8c1eff3d7a59b604a11a6c27be312293d9b1d383116172c65d5d08ac434250ba51507250e53ca74cad9ba2e1b4dfa3417a8d90522a50f2d52725ab00bf9c8f4dd3691f1ab3e353d7fa1726aa72773e2210415f8cb5ee90027f0fef1e79422b7de3b5d5e78ede515d576332e2df9347978c17b12a7783693bee81266dba87248bdad4820542a368c4f25b207b8610bb39cd90bca3805f9ec420d99d3cbe0300ba4b57877deb2367cb126f346f23f6de3532c9db8ebec431b484cefc441317d185183cf04c49d5b44f1335d960efa2b4dff14c8adfce1b818c5a191f1e90363509af43e41b611e1c8953d431bb90d3d1e1e6ebe27b7835852371618d98b2dd8c16dc43813ff19bc3a0e4722e2a5207ab610928ae27b511079b245d6e522c6b55a5ff8dedf0614ca76bccae2ed97628cb95e7f9c450047d0b98fcb8506c8475c78120fb70cdb87afd500ac4c476ca4eda3e452d938ef9f6a930caf5054c4cadfe89718de70ee278190002adfae35723f36885aa98f9af3c4ba77b88af2d4298dcd828d1ab023588f8c6b7defcfbfc5c8506971472f16f49e74eee21459a49fa13b02e893575fc7ca3dea32c1172ad275b5dc8a0c173ed6527873d2da3661bbe9656effec71b8fcfbc0285ed9eb0799ddf98978ba33e0ec30b7d18d5de1b3302f1e4a761aa19dd3026a8b999b473a11096e85d290e04af32d0f7ec48e384f177fd0e502a8e1c8a1035268b5773087194e3cbe65e6464d43341f30db23b8df53f14ec1c0cb97f163e438c4f2f2a05550e13fae6516c960ace33e4c7b22c82608c0230ccd8e24a3fb826a63b1c65e8a7a559b199e33a1b4798d2b9b228f0b19e2b6fcfe8a901ea8d118b89705da84f4e6e357a020ad6a93a9da657193c87238356212501e2c109a2526a117229194d2e9b88974c4bf4307985b57313e5611a3cf65efeb3a78a0801053721622c763c01dd45dbd768c5930999abf893b7814718b54d40d4e74400e323c9cb73e0651c6238c4839b778c9be9da92d154754406e5a173d48346a98728cac9c2edc9511bef658cf7c3512494f717bf210c368dda75fd353ebf0a38acbb4d7548895cfddb4ffab9ad43f9d91475b347536e7fd0c38c401c4e35a1e4bc57f30bba6b69d18115a758d0759d3a1772c5d894eab6910057f50d10797045e25804ed6a703d3490096bbde8420db165fe163967634675661f53c9cbc2f14123d23b61c5991b91ca085c2b9cdbce6f2845e1588f7ed7d9e3c8c7ea47cb5bd45b1d1e09bfc067946309474221915ff326d4a0a47c1e731f78f75b9ead3ed3f83916c9079892990d3c656ffba084976ee14231d4f92eb58f1ec1ba5f77befafdecfe2f1670e5d63b02998758b7af18d972eac34468f1b8d7ac56b0c46762fefe451d4e6f055675a1f03c57508211cd38b4faa0e75a8ab560bc24bb005f8665e4c30a951ba9b9b60f697f0d718d4fe252d2869745749183e8faf8e1082a219cefae6527013c41bc9befe385206ff107deae9bf314ecdf857f7210427ab40f6b1f1364e4afb6325768898bf7d27321fcb4f367802128a06c2c904020a413443d9a3460745c99bdefa45e2b8a91c512bcabb15dbb0b3d5a97943d1d4aa4b02e015e1fc3e2da5ddc3343164b12161a838e0b84474bce70a58d0972529ed96136d6f21ee1afa083622f9bf5fa33b18e29d487005f271bd63750dae4c5d8a296d0e72a9718e084d1081684cd6220a6320fd19fc15c9585a48b117339301eeb67f05f8238f3dd20c71cc19cd720c65c947d7441fbf6939b015fd505a7be76391382d23af3d8acf413ad88b9c2af4920783e27e5a383ce83a11a751d3d13cb1d661410d8aa1198faf329237b94047eb468782804afa0d9b7046492ac4851e6021ff0c9be6d73d680ad6ed50426fc88e70b937f6b64a3549413d60c15109c30d847b696630533c73e759ab972de19ec1339b4f4c9d16175fadba219a5dd92e02da8181876f1ad03b17de86422521a90875901536e02bab1e30cf7185fa5a9cef771a8dcbe3307d35e40b0fed443fdb5fa8653a60b74b6dd325f52a4a91917346f360eff8b1490085c19f68f014cbb4ce3b8ac07e51e132ad55592253d322c56fdce2e48eb1f2d0515be7279e562470212dd38e172adb913f572683cf71c777576683925baca111eba4ff753ac120a8e1f309eaba92795dc20289c147fa8a962648a05233db71cff1e8a2620864db3b18a8992920d13ccf3cb4da71ee0ecd8589fbb8d6d2c1a4a9f804546465bb474302929562a4f05115c4b4a975d80a8af25d45da1841c28be25d20d4a4300c16399a07a0ce1d3178acc575844c9889b006031af7bbaf92293efcb5feb621939e5c3a4028c8ab9d935cd08baa24c48580e8c578d9a40a7a7913090791a2cd40cdd36438ddde21d357f6e315b6b4c255866beee16647f2679aa5264479084bc915fffdc7de13eeed48f0b93758c2a8346ec5dca09666f21f8f4de89052c1ba589dc3b98adde43251133ce99b6fec305e1c1a96cbfe8fe1bbe8c4678fc450b1f2843a06f47f3c2089fd31ca2b705b9b68238eb34f23ba7eee533bfbf22c8fabd9c7587ff6e1035c74d830fe35dd1d0e9f807ba7de212da60c5e6f6c4455508f3d10f1a21a50f40d9f999eb6918e3a12111fbbbec40c7cd9d64c65ddd17c673aa22af72c343c42ae3f72f340753a573cbb361b5568c2c95f8f76df555c5b3c058ec98ef025f206cf307071df4dffd2fec55099aa5892e87fcd6c7ee10f742f651dc311c93d58b5048fbbd3bacecdca2b21486128477fed6521e94fc02781f41a630fd925be3b975f8a56ad1aacef523c84c2ce5927c72d547a1dc092b79518ffb596e09b51c4d001464f66a4fdb8962449e5ab738b33e48810570ba0e721784c897e6b87cfa3817e4ab039200d897a2334f3b2dd20d5ff31983a7bc6623d4f750fdec24505ed8ea93460d0fe0e8a3506d8b44a8b37ce60451d5da9806efea75708a4e80e631c6571bbe52e965efdbfd4bf01cfcbfd6bdc9582ca5819cb7334ab713126e50bfd00891e782c23f2d2afecc11c73308f9d05b1f5bc7ff6309f38944a5c608af7b1ed6063732ef2b165bce847255440fb36bd9e306bb443ae209a791e464396e50045af3a71685e4bba001f28c23d1c7eeba7d14436aa8811ee6203e0ad919cf4434ae06eed72d520b6b52cf936fba89b1b3d288cbf9d5c6a12400ae094357ca2a619f685497e4bd8ff985c51ea159c3be5a583cf43e8fa9c974a5f3dc3ea3388eb064360df48a0638887538ec0841dfa836630ef8fac2ef11113346438ad190a98fbe8714de6bc21c2caee14d5f4649c0b45bc83edb549d806b3d86023b60acaeae3e6f6956ea7c5466cbff2b1a4381ea983e763bd96a0758d8477ab7ed807dcacea4b857d18b36226d6d68eac1198c56a7f6aacf031b0c650df3ac22ff5be635b6d3915a4725777ae5a1159bf2928969deed4f85aa11c5e09c637c8bed804448810c7735030188ba556b966aa798bed1fdb58e90ef4d42e2996176f7cc5e05ee132e926f80702a27414c982a173b5e0f0587decef504ecbbaa9797f007a2e7c8b1c99f79002de7705ef5e1b5319ec06feaf8a385fc4d9634738ecbdf3a328e003cd9719f27a3961de4ee1573f422dd77e30d55e7b204feb6ed05fda2ac9f215bc25671d7f20b4f2f1f673812dc290181a1d5a2d88486db0b9a045c6219f3ea11e5d15f4587850f25ccd77f870478c1b91ca7c5d8007c536e75de8a94fe30aec7b2083fab4d002920b6a02799427d8ad8f4f4a20ef033c7ca429ab16b01fcfa6191c5ad17e6dc80f422f8b6caf8d4401f969328b421b0f480c4d3e26fea9b4a7d60494838d51ba3c388c2a029e20e16949f0a141f457af586cc30354686ce207fbc8aa03382e2c5f2ebdad17aa0dbb47de2cece763bef747fb852c958677457f69d11414c8acfb1e8f1540d6dc1a8fe6465d9041533063829637d3cfeb9e02e62f4ccb73ddb5489401d2c77a16f798afc4c1975a99ecf6b6247e74eaa8aff0542797c60bbc02091d8586d0c30b8757ebc11daad00aae0c62348770604ea78437a8b2b5806a890a7d161c6f22f40e2cb3d629f49060363333be4643a3f1b93ba31545a338d74bc7ffcd7cffdeb19adcedecd246cf8e2d789c76b727998309c3a6e911e4ef3760083ac980d53b3fc72860a00a119ec1022f890f0310e748e5b85e88fd9545eab10e3f949760d08814cace69748811418195b6c9155dfc97813187e350510a1e8a14204aad762bf5598721b496dda3ed64d8349098b35391e9e47a72149fc9eb3b9229e827d37cf6af6997a0c8b20bee2927e0e43082e952a2cb969e5a353d314640ac774fdde2ec8b5dfbfb1009d10bbec5f7bf1343bb738e23c6db11b24ff10b29e114e45bb95fceefa3d3e263f4c8f0de5bb2a3a58bd5e6ee8e78baea4363b69a1767f44d1184696d21838f3845385241bbd627bfde221a7f6172a7c5debbfe153778361123814041265806bfc10c4926fcde9a68414c38f3794e01baf2800366fcd451653944f027a47d035fd53a2ca24ebca83e13c4c0bbe7c548163bb7e7d3d0d4001ad71c724cb1dd2104fc989a155c871c9ce16fbb231ced1a162bfc4343de8dcf8ca1888fd31667b7da74bcf48a6d8edf77535358529876140620838c1551a9648412800577459950e713448f25c9f397c6e24854d5caf20199ac74a07bd69acfaf40d0c722ee47fbaa825b87357c7bc7bcb602800b0457ea0b8cf7fb2ecd34190cccff39fd705487db7d802e74e7583fee5d77611853c8f4ebbb67bc75923000cc6821582aee35ec29beb686f686d7e6ae813a605f1908cd09b8e86697dccbf4508beecb62b38b0c44a16534afa45f81614951a279019ee81ff05e5bc86c8cb3136c90fc21f09f67f0a3b6dff140f87e39568239f4bce7f62ce6aa9fae9dda7f184e0e16b4d498a6ef6a0b96c4a2adbb7b073aaa27c53202003423282df12575e82a82d1b627e23b984668c7ace708583137fd9e1a3313dd7f04358a9523696dd91e06a4d1437c44c718bf31e69ecc25f83fa6e50e781c4889c1fb45602549e1bd98ad0c6355e4430d732434efdd0f55a7bf0b717103fb9e3b57130d0daf1c3ced342ec2cfeafaa611e8d7c3deb08f0c4859c9e3b03e354749b0aed7c185d8a07a3150406dbebf3f1bb94b086790e0ca596655e5ddc6a7a4fdef83dd72d53d2d4275a4e1dfe77ce21ee8c6f8649f732102d064bf13a802bf68a932cfb6a560c3e411395a6e07adde4046d8252a9b17de673b1512761fce30bdeac71804f6e918ba524b0fd6fa0cd6ec72f775900fc94dedb6fe99fb6966a9d1e1f886ff89d4c6a3593e84c0f24d7175fca6eab8d64f6952502775e68b652098d79ba677620d9f14a34f479ff5f7b7b3a51f01eaab9a7ef683d07aaa4c14dd6eebc5e0bbc863cfed939f8f77d07a093499c0e960363fbefa1acac9e66af1d4a36dea40f9477132666ddbdcbb5afeff7acff8e0f36e5a95faa55dddbd6a22bfad473be1cdb08ae7811270d571506060b2b7dbdf56f122ee9d8bbb45d58fe0037ce357c5845485234b042e0c11e4c935192910926ddff9f76341b776d81527d1a0afa1f0c0e136b5dd67b43cedb29976c96c2ce7eead592232c89fcfb78e8fcd1a9f36f4669d40eb3f4d122897d8f497553f75db7488ab2c80bcb17057a7c211e2ae9e28b94dfb1c0dee15232a9cf4c097505436c0f56e87fc191f36585c6bbc9cddeec403c249255fccfdbdc476458cbcfcc9622d0b562f8d03ae94cf8e53d8d69c44729edf97f6d47b5853d6437727c71cf8a84ce022c0b61328ede76c1422f7ba85c77b3cbb521daccf8e1bbaaa93af87a4fafb092b3bc210c607ebb942fa67773ad0da448952a606a0f7305aaeb8c1776b16f31ac0bf061da25866e6d668895fdd60024e22c9d8538323d71cb5add10c9056caaace1710bb171d68873511beb89eb1ee791cef1d3ce54d6778a1bce2bb81306919b74f3c7437a4e6555e8f4515fcc56297ccba2a41ae3084cecb3353db9f362b62eb935a35845e28a492b998000f051777868f1754083c30bf55aa96f97f4fbf49aa49f8aeb68e3b15cfb79aaf722e45cf6236e32b5a8d59a40ece94f380742ba4ef7eaacd0340432eb9cf8e3b0f9716f4a2ba99d802e970dc60317d430caa01e687ad9b0c8b31508ded4e57740e8720043ae0c14826db98abfbbcdee67cdf8afc9b6b90449865ebb07f9804bf062c5a68e1d82776d0bf77c7450d90c208ddca380f04a3095beda92728bd497ce637fdcdd1745dd8c64b8601cc637d1d381715c452514392e0bc696776977289effbe5192e68f7bffcea61803ad01bf57a27d91a1137db5e5fed061a08bb4aaed07e76f127d483f0cbadec8c0b11dc2ee42de6b2970c256a285a00d44b8b021235233a39599c55d4c62ccff5f1f6b5a9e058b2d47e6be254a4c81ed9cf5c70971ac55bd3007a3c051f922cf4c881819368826d9ae04d7db04d1b6bfe1ab0d0032c83a7d5c3f5d792cea095f666a0f340153164113574cea0c7cd83e3ba4ab812848b3dc924ac32a0dd4f02e5b5bb2f88bc52184dc7ecfc4a04fe1f301e7df293fd69e2cfa05b02b0d25bb1b8c63aac8b9796636e307efcf147bbc914627a8132313bde40ac5572f38eacc18cfbf251217320157c5fd4f0c80784d2602ebf93ddd921ace9e7eda3c93c303b5aaa29214ccff69004470db2343815605d8694882d586f0ba375ca744e86f95120e6aca381cd77b1f502e4f19a2f590acfdc5b3d42cdcbed6af0df16a52bad6b217ce2d53665c65693b49c8ff6b6920c2273e8c22354469bf0079a835da95a99a9422567f4bc9e476f1db6a09d8a746ba3dc089512dfdef8ab2489d2a57d89f1def3e885272b0da082be99fd40e9e4953a8a86ea8abc548114c9cb1e8b498f761453e9eda27544e20c72d57ffcd2176bad5898afd75fe2acc174ff7e2c2e855cae26a3d08ab6843ddbdfa75eac4cd0647c4924c3a90f7c041933ff589c0b59d6651d42810bfe2d57c3a66b5279d11f825baac794323ff0d61e6d8e9c1d5173bb4542d178302a153c3d367764b6dbb7f005dabcc15b7d0b6b1215cca06aeeda8c61903b953197e3ca70f5a151d7400acf4c74c808d8b45bcdffcb6d622c719c5f076b54b46bd1811d5905a8fd7c2d492832241911c73a2881b37db14d2d45f04d7ed211981656f4a0426093907a76d3e03cb10b52f445b1990dad530e6fd1ff7bcb5597d02023551652213bfa2f72f95a0fb0d6894c5186461baabd8a1aa1d60b1d3ca628ffd54d22392cb894e938eda0b21b2a86b700dee27efa745493be041b24b8b5829baddd9d0ae45188632565f6d23f0748a8c90713664df5c7ca1db3e90c72a2dbfb18cf21ad25d71f709ef1aa789b64879ca8021ac697d85549778d64f5182e766736bcb18ba798c716c9a7e1f2abc64018f828b89f2f3d0de7e884a01cc22085426a5aa5b686b044bc84c1be1cd2a8b99dcee246ccbb6625cf065ef3e622840a7a44b4771b296805ccbf5faf1a32afd9b4edfe0dc17f9d02173b69e72d3e50d8d27d2b7de827ab257a7f205c40498bf9ccef568e75b171a43129e5b3ebd836667a219eecac7a8ebcfab1bea460e70100c31c22d01cc49d3dd38c1da0931474d221487752b2cffb702a87219a3c8336a032fd43eed1d405aa72b716776b0283d51fbcfe9c7541f0bd8b6564932b0a8f857bd4dc3133efc1373c460426d6592645dee04934437aaed6e7266d8db46d9bd9e47f4edbc5dfde9bb40f1a4537a6dbf8e6539b7508f7470d8e369ec0e863b320d689ec483f73b099ffeb4e66d86c9878c6a5ebf8b8c7a07306687b472df60590102331f8d4e8496a5e68d70fdca196cd08b9f7c01cd9febafbda809cad30fd35b9b36032f025ef200f14bdab04b5b156d3f7e8b6e208dfdfb0b4b0c1f71ea66e11b26bcc028586861347bdf32953546ded47a79cded43c4aab1c974da3aa93dc09808450f7798f46c638ce8a7434eb12efb488183aca06e4e75baf2550988d741152a5ecd6d7ec6471e58960a40e82a71f96761c0246407699e6396da1500267dda029785fa44720c0325a469844bb665a07c7e5103a393802158e0a2ff6c491763af5bd51c16796dac390b7c3743ce445272915c2876561b574315bab703eabfe85f655dc29869da5c2e97a6618f208e5f715c1ffb6588355151ab81fa1ceeaf730aba2563f2c1393c806ec8f6c7f22aaba01a6fa8c13a398ce0c9a81b5496217871304eb3f9051a3ef64ff7f21ad31dea2628ca628f24abc8b4723539c574f370301082d80b7b59b897a75867c30b6386badbd73cf6593fed1c3577af127d65a3cddd64e48a0a862aafd5c84372a8fde150ec20b2bee1546262a8d141d7e6597c24b4d73bd48e94fed1dd9db4e68616e20c474e6e80dc0108f6d8077edc2541fd1334029606a5e5b7644b5f68f4d40ac07aac39e79f19476b7215c276102e35915e8f0313fa11a292995f89df5d6e30a85ff4e701b253568ec7b3fb820ae8379164aadd8c73560cada2736d17d9d8f060f0c08ebd641ca07893b0b988ab490c62763385861ed936960886930e1dcf2bba3f526352b3b31c737f77e5ce9fe25c967a8816b09bcae20739c82a595a486904e4d67c91475b6f2f0046f747ef3b0e5a9b01a253f1c527a72918caeabb0a96ce90bbba6bee5d1f3d15aafa9f2a1857c270305b6d724a02d8ee3dd114b8762cac74593053710b59fde290500a90726e83fcf0a57bde037aa0feb1bf7f856b244bd10051bdaa6574d0731cd6b2215b426e0e3100e93e8774b6bca95b3ced3d3eef90f17fbb36db7c64af50e642267ce903f0dcc7cdf479ae915ece92aef30196ff1c0b2960990551ae97b00063e4dab6994f7cb4569f84bbd676b16d27132255f610b304af8a538e2c9944bd48bf3874454f5d5712d6716723c8502ae906666e171d5b2be3f02ed9d179fcbfe92714b28c43a187b86168f1d76c89a1af015c0837fa4660f3425278439e62a20e1292a6d3ec40a8babc23eac9cf7fc548890999170c2762baa2d79306bc8626831fb30705d1af2ac6d121bde4835b60f70157a83f0db9cdd04893198234abc0a800a49605216e2ca878e42286464fb18ff219582bf4390385de5c5829727d6c2608fa989af9d334dcf8c596d47a7ef04d42e1a78aff5777e8ae61894b078c42d25a3b0ce5bc13a7e0a20277a9989605a25dde2994d280adf52be5152e2f25a26ab950e0679999d18a4d8a7a8be412ae8652cf48c3b76f644da47b7964f54063783e2649d39250cf64bbcd1872fb60f3c381c129c4a71f4358233a6f6db841ebde10946e29450c7dccc763c5c89fb0dea0289409bfbfd02bc05db0b3135d43ce078961240858a7096c5e4816cece04525ed4b8adcc8866c314ee8c945eecd97bbee3a5b0c94799607864b7dbc37eb72edf85125327b3ebd2c142a3aeadd21d24fa369106ae00a136b5b9dc24b6e0ed41ce0d2e4f95f7500811baf893f3f9b0ace0396a6530b9fb4c88704896a2729794b2035028c369fe8bbf79a7f3c60a91352668370f31b92d0a72696fc2be7085bb727c4575508e1ff0aa989a515cf7793c06b7982f5b3aebe71f672c5dfdaac54430c2193b3da636484bfa599dc64adeebc33ef1f9b4d4e73fff06abf8a34138811fa3252f545dbf8e06a02e3379eeb4613313ebe38af068b9bd76bf0b679523b19ff697db90f8d2003a349e82c42c3854d33dc26ff332159726c0ac297d214a0ca7788717f3ab48ae53041cd544426cb41888d1509ac89815fbd04c052a1d1695858a1ef2eb0555d55fce19946a14170bf98b3381ca6296c530a32767e76c833389d5d8dbc4499c1f51f48f96160ca01cf4b6f2a1e2f6f7307c78447a7205dcf224c71141b391136f47ff7abda9fd5785c456f2345bbbb6767abfe4aeb064d393db93717b5f1a0189529550a823139616063bfe21d0b7176496a224ca7ab86b38460009ed1d42275d16ab6de3e748b80796f1b007e777703b8cd9742d7f7b56033b1b7ed9a9e11fb9725c30a47956c1e3448d5a960ab98e892c4f82ae76c1519fa2b12748e40d83b84046dfb398eb5690bb581bcbbe862cd0da8a68a5d2f0ed2dde0767b0416a6d46d30a5d17c1bc07491b3017d22c979ad87fc200c9f16c7e6de086bbcc693887f99fd084bddf581ebfd004168c460862e663633614f088f3852bcdfbe49b63151084cc36775981922e8275cfc5920a8af6340eb9cf9e72bc9dbfece36038488c635cbf659da63afd2a871a80c626b24fe8f7052be9257e503be1f01c5756fa77003ba0374044be02b18f248e7303e4ea6d70fa3592094cf70756adcaf0bb12bf38ec4bd4858910246b3e14a6484a383190e9f65238e47f3d9a059639600db88c3d1899a451a495b2637e046e3844e55cc50a88ac1a43a5cf3f57d923553734c1ffce8d3bfe412c9bf0a88dc06d322a83d8d05500ccc7c2d223ebd4489e851fde7c0fca005cadc38f194b954e48697d3b6875a303648502fea433e82bf5acd88cd5e4aedafc58e334ff1930ef5e1abd2743cf48cfe9f3c7bd6391f0bba4841cea68c71f2801182adbdb30f1ee8cd44d647df592fb7ec0c4322d0433023cff4a59d7128b40df5be09f03a4977c9870d921a0972cb781f731cb2c35e3a33d37e85c2ecc22626594e560a8790f9e685c39345f871b8e8022e810695f22dae0b3fb1ea32233a686c7200cae52d9676e32bdc5fa157411de5a680b1cdeb698adcaac1330320246b8685f9dd1f783ba6fa76834ee25c921cbd60b03b4337311437999290c071450a6892f8d44f2326779063ebef66555bdb712afb5afd105ec9819d03a0ce955b43bc07f68433337f18af1bef4c54ea6574fa9f82d876001b607507e6bf7e824fc282a66f236b91476ce39b66a0aeb09da72fd3a47de012ca1bdb1093b57b63608715fa6768fb0d6c455a913ef5509de97f4b0de44856bc1c4c50a1e8be1bf24a8af6d3c984ec382378331896e964d9bd13409e3d42aa2d8dc362c84635ff32a3e9ad1066469c6e959da4559e0c41e8d8e93ade1a902a7d1f76d093f93b0189b6f04adfb34a244abc12e9e70ce238fbacc6cae1af3e32ee1ef43a8871512f4aea805118bc1fa3e7f9130c7b6f17c2e0f531bd5af5a9d00c7c49d045cb6a2b7f99256262db72b34090b2ec76b86a6ec7a749151a889f05411ca535909483f1ae6bb517c2a32b582df053164b188b2ea86c6a6379d96501e967bbf05f993e363e1cdaf099271568dd06a2a8e280a6ff3a425e7524e1d4b6229b5514a1b33ad5b1ffac7c78ea0d5e70fb58d7ac0fc8aa86d9a2e6ed81b0aed330cad037b56f117406c75e066a0ca7aa1dd0985689f4bcec56ad7a2b8d470b833ac73fef3e64bad461c749f42f82aeb7b8d64a8d34c4e18578e870ca54d141fbb5a6bd5e99d8d773e76cc48f18a9555294a13a33cebbfa6c6bb5d9acba012aece4f089eec9c7ef489f9607fca560d65f0e9b61a3e5d56d4be23299c933f39705892dd2a63ee33717fab3b344d1776e9c81671bd819871ef9f92ca690c7d4310057c59a0f3261a87a9f299e67a76dd39921191db1e81780579f24bc5658322029bdec30b21d8ea034d3d641320eaedb720e17a6428acdba0c5a15016366653eabd6f1d207cd6ce8313c15dc2376455e30590870b7f0a9d5b13ff2e21880f2fe0192496f491f4295daa2ffa41533d10759baa0163517970c053415d2c4085ec99c3720ed1b762497e31ad4238c8ecf94a591e5f2ed8ec0619e2d118e2104c1fa18259b4c3fa473ab6d47ce1298d19af474d76abf0a16f0c5063f10747929086eff68991facca3714c1f198a6041b2d368b36cf4f1a0f60453b17a9083f88be56877b192c3b5dc24e94d7d25722dabd03a2a254012aa70821fec4f860676e7fcd489cb135af4983665852cb22c60b43c29304fe63074af6b5fda4b0bdf0656f0ee8bd937cc77cacb8c82049d0531831813b59a09ca9777e2f1b7c193f9659629f826ba5471215fad71f906080ef8f0963177cc5a28df61ab3035651307f2138917dc26fdccd1875f03985dd5a5a44e4299b820d8d00254221b742f2df136c68c5a5c929ab8eb5ebec084c0ee655efa56bf9d39a69024004380d01c9abf2f9c23be0f407c5527e998c0bc87bda8e7c4d39e161d7d592da74f0d547b592f38685cfd5057d15926cc04dc2708984e875963399a2d3e15e4d4908630943fc783ea14adbb92f36ceea07285efb397fa2292a4d6ee69e75b950c1765ed160d4568db483c09c3f57de92222f19a8cdc45ac0a8720842a89f9ef68a8833084ec716316e62adfb5f3e3ea056813c0ff1bfcd0d2357c1b65f0a0acf241cd4437e59c4b426b38c2a134bace04cf9b7a77fbc52b724d958c2b41074296750378ba45eda34c1f706bb0169ad696d8e12a62359722ea4fbc53f8d26cb4f651e74363dd34cb22fbb76ef86d40930d5909510451677a61c6b350c9b43fae7238ce100679b736341c04907052d43c0da913e30ecd7b38161cf07a762dc56c7a2c1f56ab2fce3e3c670428486c011bba6e8cdafdb4b9d77dabe489bff8162d280bbeb8550b2cda05bab52032fe9921f89168f60a037cefd37b568b7e184f8588210e299078ae0ce284c7144f8ccaf21c4d32b67971f20e81316875cdfef24829fea551905319b62e544ba38596e93a7055f909d25af84d89f49e906aece2445419a32d47028133a65bd4b14edeaee51107c277f88b4d711fea4e4938b08b5f99ed8db6c68052ef6d121199e2c2d245acf2cb7741a6197f8d18f9e77ff7fc69581aca498eabe73747e331e585f4bde11f00eadbf59f613438f8ce2eb158aef52459961d11b274c1472e274b4d307b732dc331d3db198bfc781642cf5ebb6e541ff8041d5843b075a5a1ccb58bdbae0507fed9edf24dc6fbdceb3f5281f155391752aba6cf05780bbf74c7d6d34e2e337556038eabf6b8c8fdd1306ebe6106bf217facc17117acd361f3de3dc7fe798f45f2eae2806d5e853c596232d606c726dd2bb627bc208dba69412a0b6074da34f80959b59cdc12019afc4344a67ddca53b9ae3dd0cf6e6c1b0ef198883311976eafcb5952e940b27b4155899fb37cb192da3675f041b3c8c0fd214f36452a7b810bb0173e93969111adb95a9ec248673f69b8833eecb0b5b2b5f96755ceebd9c2a77cf8e1440f27e95d3d72e64e831ba28f7cd5deb5081550655dc483187063beaebb5ca58807426fd70606b6cdf8b5429641405fba14d19c82370d195f336af7ec418d34b873445ff00c13f6891da008fde71793dfa86d0adf2f224fd9f08bdbe7513a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
