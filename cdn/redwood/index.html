<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5600f0d1ce4e859ae6c463f5c17cbe073505ee5f012907b571732141f107c2832e37b7fe7e377d912655cd6f61af8b967920b73b26cb08af4d8bc229ffd6d2e6fb6e14b3ed61efc5c38a5af6a34977c005369ba2b79680caaec71638093101fc1ba1978123d771c972d4a027afb99a19aaeaa3e160b8d19d0e98502062e2a7889506dc37384f72845d0a14737b11f1918b3d72a81a7d9f98af8e7509cc3c13d5e93955c6b7e05eea0b61e5cbebc09e80036d013fb6ec9caa15e5877aed931631180999002229346a997cd54a85d1d5a71bbf26146d2e1ff8870a7a47193b58eb276794d442bbc2bd80fad1fa691e15ceaa00ac85d6d7153e8e6123325c9b88bcf122ab2e08917d52da50df809362d3b10f120e5229f6db6878341907997bb97cb393f1fb24160833af9a21f8d379d05e3518f61641e1c983e0dd7a2ebf8e4a557bd66610445084619f6588282dae4a070c06992aae63a03668390a77782de2891d352025542b6aca260af779ffd5b9b448c9e92626bb9a2fac7ff3579be361c0bac7a44cb49d736a3e23ad350762b557d411328af05b9bca67b7a6b4bd46585b48109592324058edb709d47c599ef4b1c8cbf178b283a079e8c1e5b43c5c272f8344c063f7e56e37cb37365bc617277d4f8144b2bd696d8a37d7d09149d810e416a69baf1d228ea95e9d1a0dbd1dd3779db769dc677697a89dbe191b76ea67f503f9ad1b31c3056693055b1177777f9fde79eb9c4e4b540f35200ad2a565ca7ea1f8924390485961a9936d2a806b77cdd07302b534af629acb780ed72d47c5a0da075e6270a17e5ebbba2f7f2cad8871cb4563e29caa5f3351604115d87b94794df6c2689944acbefd73dd6affd78153faf8049462696da10f43c322ebcae832151cad05ef7b37de7721f59f04f486a69b75ead589bef343e252826245ca9605c0f6dbce9380ea2843aa9949be913906d108dc5ea60ee7ba127be016bcfd417e3f2fddcaba7ef74676b20a131c75a85ef28c8efba3ab39992877a2a50407bad0270d43a64f2cbc9126a0bc4705cb2b22d901abc658b4b3b371fe09b2ef086a7e60b09caabc73c5eaee45709100429b725090d492441410a27c0153e0e4a997fc2f8230ebd8a65d22854775faae1bcaa2e0aef2cea837e3f10b48051f36dfe6604c8580a7161cd832439fd5e45ecbc3e36644d5226ff9b326ea5dc003748de8626776b1a895ea80235bd040a14295fdd5d1bced74738682932f25fa4d48e2c1c9c37cb0bd426c1e8e9fa5065f3b49d25dea28c84b6aeee5ac2f31678e963bee90bb6f266f9a219d73ade6008806717b81bfeed5ddfb9d185af8912c77fb83182dc0038178831ccbb6bbc2358919035c12d360cfd611c1ebae68a89287b4df7e5dfa87cb32c6fa219d1bcc2bb43fa23124d7e0cc9d0728cd3077063ab91f68dc30a3fde230208679394a0e47989e43766fdd8a74a983482221a7013441159d8c227958a22bb42079d6c611a6758b88c34d5d22d076c894fef5765faf354e62a7cb27e5aaac32b1ab17f362e9affc5d979c7c791e80016dbb001559723c1b5eac503e68b06750fdfe3685869509b2a97e640fd0a59fad810779b67b91bac1d075062403b7a4b330afaba49ab1e6f2c944a4ec2413831279cd93c8ddd16c8d648603a8778cb83d67d085f6c05e31cf4188b17bfac166604df973a5bad4358919945d524970e7ce2bffb73d0282d8cda60c952ddc8befab0d6213081e41fb758a4dc28564ecd45a873771b77f3953aba2a022128a3ad21010194c1e7d5106d29ba4af58ec1596c5c0bbd16b192d493ece8a62c65d661c8ca3912a1dbf15c24050a888a8e139834a97b1e734f9546dc41881579c81f144ccb15d58ad14f5eeb017cee029247836acf7c64f30082945a319ed2f9293ef194e8cb0e4eb2cf30eff5a9d50e52f0ce3dc59300ee1b9cdfac7e71c76c2115d384924cd71ff831b9bc91c26c50a567c1e2640ccf2a600fe999385122cdf6a1427225da325bd375e3bff55b6c77bd67c3ce755caf8bff118c9dd3d0e4029d9e0f9d7e503f84d0bcf1cf67759b0b13b3f8dddca8ceb6778948fcad1761231d35716ef44628ad8b4d734285a26f89ddb6f114cac733c11d0c665bda9dfdb09c91b63946f6217675c3a295f72d21360ad8e1ad8185e55d2e6243b7d3699a610d398148fdd169f05a21968083880bd0ddf1903ec34dfd0760e4bfb10e106ff398c740d0cf15a6276d8016a018c0e0276e5403cf2e8580676ecc93f9299d6280a29fb01163c71295f396ccc04cd636d4d9c3eb6bfea03a21bdb85f06185207e51e85183c48909041dafc27ce794595d34034d1cc29cc3ff6ee36593d9089aab1b579f6e0725edce06f1ba50a657c2d0c7be9859290f9e6823a9642be5217bfcf82a1e0da42d509e725053e791b1f39cef6731d4f8a3a302afd71a12998e521b3511c3cf8f6a718c6c44372660864dc01a60a02dd1f07c6796cf078283cf862fddb084f1ef91e63a53933735e4d70292a2ea1aae82e253934bc15529060b49aeeccb2c2838078b4e0a800926037741732a8760b22a6450612134a0018d8d189ef2a079eb56f7f0cd7af6f6445743daeeb50d72b8aae2b5582679607b738b27765e0c85343eec69c8f369fc0123fa3dd7ad20f7db24a1483953da7a01700773bd71f0e6284fe018ccd097923f570803ac10600004a60a3ad62aadc497abe39622a53453f367360ab21de136bf8c132f5a873d2353ee49e413e77b69217a3dbef7e5969f82ebcadcbecfe0223ae751d40acad26d93588265f2ef25fc9a688064eb040cc126ae962a92103233239856afaff70b0829478f3267d690fefb18a294a33f3bd46c634a0e6ad12bfb2c0f08e34a82096b823081b06fcc5983dedda97512963edb364e1f76c5d0c70ebf76e39aa2c9208353ef1771904a09e9d1cb0cf31ba5b74e71c316713ae7d9112ef0278f70f7c93024f9b7359f381077973783d6076430fc917aa8232447a4007bd6fe02c3a9294231c3a4190c67548b985c5530ed02ca2ad2ce7def308bcfc755e4abd418d771def7eaff238171914dd5a24475439303204a24b501bd8190bcb6c5a926c4ffd307fd4c658be1ec510073190683116631d0aeead0c4acc2f34659e56b56d35668f3035f88b2c3528ecfca196354621889bc731e4c1e3cf6293aa43ed30966fc3f3e31aed517b8b6e5a0a8a149b4add4d63a78253de616d8202b679239c5640ea5548b390933f6be179dc9c164ed6a19cf211208ef2acea8f0f7445af8b3d5f6b089645c9efaf1e79e15dc6adabd76e282c26ae962c189063723765ee8b405f4dd1ce14df332cf6fb01220c18aaf25ed634268d6e5da1c0e6ac537cd8af1919bc4954a1bf6238b30dfbc68d5fa6387a4a2ff7a0b3a69e42400f72c313f8ff075594b48320918bf0ed305b243d3f56a1a5fd3d2f5ab5c4ce0d9067a38b84ef3d16c2ff8d870fd2aa1459fc39450021ed3b3ca1e005f9f0b7f45b51f0f1d77be39bea8ad039988dce1d58514a18548699fe5fd79a2f51414b50e7b869086f990f3e1446c8dd5485cc8e821ebfe604835b18b7d22aa45dd2bee37b2ef7ebbd120862a7ce185538501ffc67926afdba8f1d0a298a9f3f1ac38854d3b13f8614ab1c5dcaabceffd438f7a31637cd3198473ee4efa9991073e239acfb91f03af3d32f9aff5dd0f30e434959e3e5cd6e158b0734cf75979101df5a35dffc87c48ba8ecb33501b4c2f7ad49bd84714d3ce0b524106aed7bcaa120dc09aec8bcdf1ca72751a6bec0d5c4ae77116f23317664e9073e326b3ee71194bec6d214b34c351cbce7ecfba4c3ec867fe9b6eff3482e24e21f2fe730022656e419302a136a18b4c900107a0085e8f9705501137618ea42ccef04ef42a1b621e72580322a54c54d65c3174a4a18c6563d42eeb46b1fda173c0fd94ffcb8d804f6320fba10432670d168af65e35ad6c427052c4f662769f9a46e48fc3f7bd6e2e672264fcb7922aa57852460be22a02ac3a1de986618ac112e1e38d9e8c5cdb7a80130161447cc0676f8324e6f0daa70ba6dd90c965dd5060e6ed0047dab00e3141874efa2984e25e133a64009cf832ef0bb45d97aacc000d36bae84deaa8a2f95adb15749b08a836bd0722889ad9c057f16a53cdc13ba1a0518b3e68f40dba83f78b234b25797373d84dca477c1ff6cc9bda84f9e41491569fad03311e009c0aef77b4376516611580d532c5d7ebe5f2479554f26e96e3e2464bf1390cdadb094e5a3a44af02f5e7b0ef717244a4daa3e48f3591fd92803e6024cdee8f1feb2555f2046b2ba35f817f87c4773285735a4ed384ef64443d4eececfa3185d75b4c5cca11bcc526648068981733cea1b3fe3451bc00a3bc7d281bc1452a32087299b04737a2a1de68ff53f45f6631c71e0eb5a08cfbfd1f5270d12d269850a6274b480822d6b8b30b9d646a9f7de3c9b9e88c6ec6a0d5dae979d2fc529cf4dc0603622701eeea48d55c6093d991ac74b1a70b6dde22e9039749172a73463a3736850e22e475480387ca9d47b2c0fca29db28c2d6824dcd875bb54f49fb9aabee15c441eaa56c127969e6b79a25e3c034c7c52dc9fe1970c80c926e2178b1772c2beaf3792dd19e3b3a173b2bab7d77068cafc02e2dffdf74741b4597ee01ed2b525142e82985e3f7aec6fa47f1ab3eb70fe1a619384dc456593d9a64b88db4e0f7e5fc3482c634fb8d1db573c6cb33824339d99b9f0f39c7568a38b818b8765d028dfc0225afab563e0e64b2aa14a93da8731bf69117d72010cdd992d60d066fa5d3f7af2a084eb50308d2bd5645b8bf3e90fe2cdea31c7e5ac3c7d122e3bbd99d9bf74145277e664aadb11469527e6b711d08d42424e6f76b3c4b5f01aa7b574f3141be175ea8e92e459cc807ad5f38d704d32c7ec4a98c3a3141c7f8f268f3751804608a44924f21b681322fda59729c963e200cc505bede2090bf429950e6971e4bcb60f336a2ef35218cf698e1367bbea32e8254e0ee69e9b73ef8a3abfc133d3b21e00520731d1384c402b83b7a586b1155739064417cb5d63939e5ee02ee6d42bf7936470c4f8d2ed2cc089430cd3bb998d7c3b54413542086ca870b99483910dbf9913d827840af824835cac83bf3fbe4faedbbe764451cdf741d4f871ffc3e0877795cef4c13eb5781add832a3d80a6664c9328b5fcdf4f73902b67aec5139f17a15a2c6e62771badb48337aab78d54ae70f632449953fbc665c70e3ebc19fb8557d89e415ab5ef3f0579a793dcff88cdaed60e0a5ca18df473bc34f94c93a799c1bc65364da3bee475a751d0d6f98e2694c31144312d00da7ea365c58fffe4ec55321c9b1d71b6fd103316abb07850e600008fd200add2f0f8e40092d7dcaf22aa3e7ce0174e70c9062f60e7dd1c5eccd57eb99473fe29050140bc94af652b592613757a9028cea0ce06ae250e9133bc893bbcda9405ead7475a786d07f7777847d1f568e1372776eeae27d0fab47c615057fab0997a119af2e4a9a984d923ca7465d8180b2f4b1782b542b835f8d29a28c2062f506726b117e454d37e865d3a265caf60d180c249341fd269b3299f450fd1a70c41e31fdee17cf8d65117bab308eea9f490429e1f63f868810c22e1c8377ddfb5f7f00d643d2c93910642ecf0b7c43a8d4ffd4c0bb8eb905b732977002d174e6643059b140fef8dae94969b67d4ca9b463e1248bf258a8ccb5c6960e1945a70219b2c5dc5431b51b8fb4a709cfb67013274bff1abe6635ec47a07218320bba4c46903f3b783f12ce0f52b9962f0783613c3c44251781c9b306654214fd052e7cddbfd11adedd98d416762752d4efe57b2ae169559f47237433fc4332c2ff00bb4a18f7448fb8499be63fefe7fdc85617e9d2f90fac9e67905a158edd8f49fc4d9f56fe2b3c9d478422113bbdb3b3db3cce92d64b75c8fe06c4a56f27a111ebaabf51a6d1b7a8ce15cb3b56db458aa92ce3ea3af22d6e12fda02c907eb77424aa7fd242f2b7c5b7daf0e157a82e54d45194dbdbae725150ec38c5599e2d5e3fce5d873845685528f88c43f55da7eddfe1c3f41f8b98cdfbb74806bc4af881157545c21eb42d6cea897f830d2d09543a83a1c9253eeac190edaa2458176f9b21a3091917695c8429af862b9c4caa8e619ef9b3d5193d478dd5bc2415bf98e300987257bd7efd2f428a980d0e3380ff4a969ba37d34dc8b0b1f221872c8a1f835435f6f6b085401e36b97b2104279e1fd1669e861a6d5d6a9509ff7a1fe6e0be764843cfe8c441f22b9cbcf29d37f2893685ee9190ab214af33afaef71890378241f3a026a203641d20cfe3e5ba1b9ec1cbf141f4a2b250ec1415ee3e859e1e1fb47a4edc61310c9c624ad9b47ff20a71ffa216229f80502a8229bacf4046c2b2251a02df42d5893265ba82c9593ad92fd1bfd80cb0f09edead73a99f90d81b141070db901fd830b9c2c111c9dcce92539dbf0880ad99076d5b96a44be0d3f668af81bfc9e8857b96c0d094e02f288d22d5041f296da45ad1aa5770ff4ba6690e36530b6e1f1eafa3c0eaf27a233086f80d8fb2db2f5ae488f50b9ab93470180ed48726ba1cf49aeb3b4e8827639acef475b736645fd40a6ff7d9df02efc0eb44f2211a1b9570c5578b439b5c707e9ddd214740134b44277249166517e5019a445f0f077907108494cf77c2bfa816b575efaaaf8f4f0830389f214723996d3f51e9201fcffbb3dc676704dcfb70d73ee734e5d3548b96c1dcee85b89864a63490225b43e97edeb92548d2f880f39dbdbeaf68ea2ed747772e1aa0da63fc51461e446f09913324cbf1e85bd292d58d0c96e1c8a29b33858bfd54cd7c63526173eaf2aca9c2a511e0986bdc7daa3753b62bedef3105d4540404381e9d1658c73462cee2d42aa23008b696cf4a9d57d7bb78cfd6702eabf124c88aa00a1927fe4903ebc5eb533b812ccee0343de1d6e864b56f17610b05acd20f7296434a4fc939712fd1900e10c92d244e35772fe34f5c9fd7ee6d4f635b391a89ff4b6edb8c1b503eaae161fc25abe97a886a211908499fd60f5b6d947410cae86da409de1b44067472d04590d0817fc22df0449a9baa10d41441da768d02308c7143cf7e1608ba91e4bc99212231b1140005807840bd52ddd2a295279f60c2d13746582cd451ced154529a75c63e4be9469c32021198045bf30294c31b78e304e21407b63ac64ddcb61c7486550d433958f742dcae28d0657f09c3d1c26e635d9e835f9efcf675532eabde92ec04963b3f7d017134b5d051f80fb93a4aa1d4ec6ca23376bbb23c6e45a91e377a71636a977fc6bfa25d3fc3cfeaa2e7c44ba6c5a5140eeb39e0f6882ea66fa7b5c167efa8806b3169abd6f5d3a463e669542bc48a1510dc210d726e35ea93294f92178e3a7ee9595402f0b119c3fc1fd44f223e0084ef6b405420e7b4be67a0af203907dc49f8ef49570c7cd9ef24322bc3fb3cabcfef07f0a45dbf57f2aa52701dcca3a5fa72d1f7fd747b32c8719ac15ea4476892018251c3e557d578672c2c8d5a50389c581599287763233de8ff9fb49b3dc6af9cf018d70d01a12329a8e82d077d5a1348b58e992c00cbfd588835786260e2fbed3afafa105165b0369b54c29e3f04802310365a06a7edab0eab6fd38bdc951148f6d2e60d6e57e28259fca39b38b80314c164d4cc1dc2a58be535a030fc6ab8585a4752d431eb8c4bcf0feef0466f1e12c24d0116d5d96465e6b560249518eb9e9cb39b0bb164a69e7ce070b26f8edd8359a9a791178f023303aafd27fd138a2498f1baf75ea18d5b6a7f1c919f27116c10af0eabc45c1312fb75ae5fcb37579ced340e057e8435865f3a7490a2fec574d5078835b129fbe8a8e0cc70a87945bcb7098d75203dfa4e0157637a65ed00937d3188ba7d23d91ebfff2dd55e52f2cac30fdb3ee1fda257ca6065a3bcf3aced955c1f0d2815eb20e40dd1eeded1038e52f40351dc70333a0538217f359e793ac735a9a1714afa335615f94f8308c16e2de8ad74275f158a7d871c3400515f37fe8483a0770fb2dcb6538bcf7cb54febcb356513baf89e1b3f20742d7cba2cfa7d625a98811c96d477a9ff76d81cb1d2be1d1d9e3e621f94bf4887cfaa4b2d0099a3c5dfe4c83f5d7a5407f716265b6f627f539c482c996308769668ad0013cabc547cb7089d8cc68fc9c5d0ed3cea9e37df0f39ae31e4b39203ca5992d9c9fb0f8f204cc1569d02b57dba2423c8391d7e024512ae83f08213ef2d525b5bc44f412f05479527a5a28c1409aa754be0342f7fdda72e1d6c7594fb84275e80aa7e8473baeb9e030361888767b64990a380f3f41ee3610d85f460b1c9ff4ca553b0cd2c83bedfe92a1ce7494c9efa27fd26bf16cea4539f444a9477986118f08f1eed0a28248512092e67b38666d650da989dae93a322a613b01764db4f42200d0934591c9933f337d9298832d0d9b155b8b0f2e22911d9b447192ee16dc93775b849517f105e9f7445ae3cd9b78876d7d652e9798b582ef0866209ee98d7ba5c2df6280e6c64f1ec0475395c05efa90bbc175fd7b429a8f2dc0190a1c9cde18ad52000bc90804dcc5fbce21e644e5baf6b32a29d7d96d7fc8bb2626f9ec3b8751db247ad740526f97cc9913087970d291a619a60dc9e047a1c53aa1c59ef2e682eee51c610b8d693f34defd0d826960839fa8535389b36a807ef8f7573d75d932c907915cab0d23711650aefe3e7341ce70239076979f7fb62124e621c8bdeda5a5c0f4c1ccccfac15c21313b458aa665ad96370c30e8d4ae1ef3322399e0d9103692e3de2f7ac078f78195f823be554760c3d3371679243f7d3f7b9190bb7d05e918f831fbe5a5695f40e757854d9ae21619bc1f7dfb28a33fe1d78b9dab75dad399197de95958fd64b65f472bdd95d7e930a12c6325b2afb97d5489d1aacef3c4a4f503a376770169de49c8a2226ca8308eaf25012f27a16e4b354ca40ef44666b4af0823405004a317b1764c32fe6d383b6dae8659d04b17b608a6676e979e3496e0e69aec1cb1f5dfb438d44252e33f27a428dc0b12fe8df6d5d7c10b412ceef5ff09bf7cdffd05463128cc2ce33f3df4028c05e60a514b54c83c3c4213635ed65e4cbbdc5fd26849190fd3f150047b2fa68b58e52fc757e269ce42a803549607ded7765731fb34ceade7505d544af40e4da5e7ea84cbdd087d88bf1ac54bf9f812945984a0e1c3bc2e8cedf8bf4a6b374c70e9f2016e01e93a245ae455340e3268d955fdd1db754c43b8344d1f8274445b437925830625b38947eb0f221873be0c825206275bca9c2182a36d8b549b822226e909db3631ba36afbe714386338b5d5cae7374a8736a262c9bbee963c21e649f1440bf18aa1f214d9305fa0a7800d96af48a701d0b76a4d7b8979514962bffee1bb085a2f3ebbe255fcc0af8b7291bceabae1a71a85b791e040b468f6b4ce18daef0d8e884a213f8d8422b5690b86e56889b4ff9aa923976e64da486816b84a5829f3b307a948b35b5a14ded4f7d6d28397ee3fcb9a9f00934d41907e8037622658c9cb8ec930735c63930f1cd519689a712957e1e89f5518f39e0e90cf8956a8a1d1472224af11e2db69521cc2ac6a5fdf4c43ebe9aaecf39e46a65a37d315edb2e6d37ddc4a735fca9aa0bcc5cf5c2e7f65671496c92b57539f4b00274126aa804269b6538fb1eb8defffb6a69a9f1dc6aca7c1ac4485a74398a13d01046681b7a1a48faa9608201cbcfe7ffc747f1687123e16b2bc05d7ae57c6601627ac8ad94e40ab744b0d741b791268799faea45dca103bf99c78206a0684d5ef32d4de785b4d64dbf9e24ec0f3b158b3110ca3dff502a9f6e1a03a1b33c8bca3a78fcac7a2e3c1ff7f2ac7032a9ae8c1d16fc415f466ab02778f15aec22b7a64a32c3fee92c61f37780179beb47de76cd21b28f4809ba6745bd694d7ad4f8cd1fab469cc5fddfc4c656385f2026b6f83122d148073bf8350354d53919c2251f954b00759fe8e44785c97425811830870c098bcc9b08283a1d5e3133d8b62a988525f20a3f6a8deb339af2f7dc0ca78c8dd830c4a8892fc7e64312d3f27f9d5fe0c094e459440e414f00fe6d803337373ef025e331a35b055e69661ca912625112c73e99bd37127e8eabb85a90cbe0135c7d02e698626168b50b5a947b1ba6379a789cb91f6e3696769a31dbb2472040f42db99e2be71833f6a10b220675033516ab8f221e81385c3098c6c114b69cb7e6d9af386ec3b79a1f7ded261c487f20962e230ae63a5ef856cd90ae5d0f4331045cec51e4898a6c60b63f84b6c8810596e420bd519fcc0cf78b44a1d9ebcdd4275b366ff7c08c770bc1918e57f04e304405d27f592574675832cecc988f946b9465266e245ca8d09ce7f0695c6ae6bd35044421ffe0a78a120f246d4528a0ba8fc87b1305ca4c73dea2aee16e4a71833be657d2af10693bf3087617b22a672abdbad706f5e1242fa6e0d12264714747d2fb391b0745ec8ae15f75cfdbf0aecc48f5dc400f1cdaf0d4bb2d3992a9cd07d5344f7f31f09d06e64135e80801a2fbcfadf91db62334ab7bea3b586d71f9bc9ca5ca77730a40822fb9247f82b3c768e6281cdb88d46c4b9903040f25cfe9025ddf2342a00e424acf96cf5db4c0c31f97e379bcf5f37dcc5962f794eb9262ddd1558ab40ae015a5193814815d653a89a8f7e9d7f084dc9100654fe27e29902ac20d11136886cf5be9e4c1569a90bcd9fa90fab0acf7c052205c01201ad1eec1536c371c4d7d097425069a5d3c2ebf0594a20de067d728430475edd6b9c1649315fbecc9256950f1bd3d4dc4900cfc5f14e2ca2b0721bd53b2d8186dd0e07226ab3a161a8ae1acac9bf70ddd60e6fa65ac002ff86ac49055dbbe4ad01d4638f39b4d61742e762b860ff9c1a1a2eb7e0dc73e326d31787937386bbbce39df0a944dd89b3363f73f422d1e2ee67e3c81a988c8a12245e1d492ae363848d62c2aac863556edae967f017c0f1b069ad3af7cd442d99df7cca98dbbf239c308469cf12625c7055e12a1841b704957fd33fadf9236f3bf0428153845c2371be76c1376e43ce4e3316b35bc3006f920ecd542600dcb48b764e454c8f6a24ab28ee0775e2ce2f016c70e3a3028523772e98d9d38a391aed96d5a225ef1fefc44190b7b7966d13725d85a38df638dbe53637279f75515a544da69f5fde6720a3b86d82d56ad279294c34407ff86f9fc301b68f0127bc0216d3776d374ff93bb4b91ae520a9be2adcb4f5fafee7a7bb700d97d11ad88407f0c6d06c955f37315261a7d22a51830034db10fedd59fb55c0d16dda1d584872255a4f440860faae084ce82e39b2dd987d1caca0a25557d9ba93a53f821190bbd3c9fc41ab7c5af636efc39ce82646d922504cc6ac34599bc232286321ba2842e81470273b81f10c84826f0d09d4eec73e61290f8004f9eec3becbe1d90339e02f0beddfc2bc1bf617dd48b5280aa48ae78824e64576a7194d37ba2808672b77bb73085a934aee68cf22e96e1f2a75122aeb3d162ce1c7a2ec5df8c006e21fa87ad40cdd07d19a945b1b355c6bebb63670cca2c90bb5249db94cdf45ff25590612aec78c669e69ee9c84e847bd681a5689459466027cf1e296fdac40b9c16463c2d8499a3808e1656694b1a5332b13154b26c97f77f58a2bee656e14d201330028d3e230e9240275fd64e8c6e3dc38280a892c4598152163795441e2be1bb3892764a16e54380e184c78b68d2704aef69148fb29af38e6fa9647f465a92f373a4e1bbcaf9aa74aa924e7c6a9ddb6f10841a568ca8c52f9c08257b758b4156a708febd48c8c48f8dda83db18ce88a736aa1315a6af59aa431e6349e918abc5ee448c35bde16bc43f00f343cb3b50c7335dc07e5ee54b263ef0f5f2a6938b6bbbeacba37c8b29a35ce437188ddf01dbbe80e6b3dcc917a32bf74e1ac75ab7c538ed6bb961b89104d294172687a5fda8bc20ead4dd7a1cefc7ec14d24538a9dfeb6ea7d465fd8a211123380c76dc19827df083d22b6f477b6ecb18abff8eec0983e2bf2b0dc7ecbfc4a55b48c0dba4081564e3ab6b5dcd1c2567f3cb11f2a0e492b6cdedc8685120ae87ecabbab0a894595b681b3a0bbd15146f764fb4d9ddd62ade9abf8b025037892f8187fd2355120f021ed16a0095eed870c3cedda6cfd73b1d30bf2e3882209da7aa57142cec2cabefcd817483e289349f6d315dfde1056bf9b16edb9594cc0055caf8ddd584640d8d4e2bd008cfd230ab255b30ddb90e698c09f16986e394463bfe8bdf86000c41b99cb83c5e39c7c9d53a46b020e6036e08348e924ea5c7901976162179c8a7429155b91fa2c98cb33b9882cee7167068b41c15361e110def6bf03f08d7d3589ddc30b6ba572732f551df1bdef0beaf1b5e5b4b5fa66091de1ea58ad2f27c2bb349983a6f185777716fe124cac6a64da2aa071f5abec394b8613d67d2aede4a2f018c7ebbd6f608c243ad76fc525243521d9c8925aac8c46d6246f7cc8e81b84599b51da909f7ff80ebe34467b25085e8d9e144ed46cf6e4a5b896a066697654e89fa9347bce6ded560d3ec760e0630b726fda334a05bc841ae02ba70b05295edbe77008b150e2bac7084e416bb76b608ed3aa9b0ebcc1dd4c6eca678e32e14af8dfa022dd6ebb72e91a2d5b117d4769e84c6ff126bf0e3decc2f66ca4eec1a203cb6cd41d1fe3cd0ce958ecbe4f46dbb56025739af2ac019bbaecc18156e438961a981b99022cb158b6452ed05afdcebabfdbc9f1484a6486c099db7a900607dbe0b6bcc1e3b83fa5414170c623fdadbee0762e126d2a0d0de946821c3c82c11f631ace2bbaacd975af50addeceba769b3ef93bfdb64367a4888a31d45e0811ad11c13468d9ccaba90231f720d46d47e4839943db7c38a6a9ff9760ebcd2737531002ffc3deca8c02f420112d0cf801926565342f34ce6dff9d3d793476a4a92aba20bc94dfbfd353faa573eb8e162ca97f4bc76251f8ebc5ffbdfe0bfb43093e96d2d3d4e3aa298505e4f06dd608c5d265b9c2be9e69c57aac1df7e8da98fc78f3f2bc1f6ccfcaa21f446525c222dac455fc6a5c5e226269fbdc1e7e196634264aac2c9e6ccf97455af47b16f0b7bc77e0e47e364f05b881aca1c2f5b2d7aa043b6197bf151c8dda2d2e2b1b8d04d201acf6aec236152914cbaf284446bc6dffd6df98caf80c8e7c557673e5da0ca3f2d431f08c43fe9b8a879f68e9a6db76617ddcf437a3185c7547336dca66e0159bb300226cff3f33c44de81001a6a9a27648b44d280bc8d277580335adee9438a5c61bc660a0c85557167ac8fc455c91c53a6174b56b0c33f55bbfd2236e71a6e94fba6e9bb5a47365f2cd064cfa19be79e0e93be78de4deb51cbf3a9b6e627d2f4e18689d0ebd3d8082479d231e3fabf832974ff8448a9051ad19416b90ce9c3bfc28ae999dc4058af7beac5fb9a0517986d8547fdacbb0a38583d8fe4690bc903c953bdec29cfac9711fa63152f967c6924191617a197893c447e58130421cdd20430e78df821505f9ab1650b5ece4bf9f4d473cd6c67be741f0cdf807cf41dcb2155bfce1a8653c6cab26a209e0492ca3c7653dfcea0269a91805ddbe0ee22757e661c36cc5737055f446cd6b0ed32ba65c3ca98e6bf1bb8ddff9561c1ec3876f9b2484430482d95f4bde0957935fc75949426b85f9bb32687d97a408720a7691db6baa44599b69189f517e281c8ea667a53f81e3db9a20984c7f805f9eb2dd0446839871c5a35d41048f6498e42e7e554de83c387258e26a6f8c90260c6266fbc3715eb0f8fb59ad8e307aafb135ea4a4e2c69c44ff87fcd84d7420f77c64d7b62989a23c3d79dd34f765eaf994e3a436253b422f7ebc81dc15efa85fd00d851d8fd2b90e8f49ca017f020681acf09bc761cedd45d03058d8e5f504edac256c04cabaa028ff062bafa070d12575683aedadfe01b59119767877a823a275674eebaad68e1802907f89133a6620fc7b9ddde73cf4117ffd9e92d1b30a9da51249e242bb9f3ffc19c8c0f1c00eb79e87d60c38412f22e77721d0b9b4618d766209a8302dc79586e0185ade96eebddcdf602b04f66b8d3a040d98e65569d706ea1d6775c9aceff8df9ce43330a5dbc0d8c8ee52a12af8d9e35f0cbcef3ff6bca1db09f9a7661cc7cdb73ffe31e2cce958bc077f5945a8bfb6669160b8a6218173f85de76baf4c28885f8de9409a9d4f324492cfe1e528ff4b4a4bb931d2c5ac295aeeb19184a05a748882b946188cfb9a917457aba62d893d4cb5d390d50e831bc0fa0e5fc08b9fb8f3846a4a260e015244ffc7e60353b5ad1ec9b3e250a57c61d47eacbf2a94db1e3f4c01854503435e2dd90838a69345c553a0b7f65452c9c6fec4123303d88afa0c5f9907cc06689eda5bcc7abb852f253581a024668636c32c46eb1bf846f9ec1a46e45447b019fadc1750df1160ecdda70777c7e61bc7c8d05bcf028885fdbdf52a28ceb2f7a9eea04b45e84bab2ee3c472827e335dd1f78fac9f11460609fdd65615b3fba02b85eb7735c1bbb8b3bd88c87674f1ec6b29aa89a9f120744538697e026c60ea88dcaaf91dac1ad201dd47ab33b712a7db463f8bc9e75adf73b44deb1af14132d904b2fbb0a1860f895d7df5c8a5a2ccdd25d528c92955a2c6cb03206e42ee43a228bdca998949d9417477ef48a9b5ecb9f84b3225d2881126d2265156f6d510db269fdd6ae656da4cb67ecd335b51cc1d59101ee038f16d45a9cb747d17d26ee56cbc676e8b3a7a33fdb61ccceb35f34b9b58d5ae9878c095f39b48fba8acc1a9066a4ff24f9f03be3e4f352890c2a5a1eb09067b6a77c21a4c16f954526a25fdd1dfe707f49520031e8c5ae92209b9de83df06712849eb6d315727a85c9926f8e8c3c8adf1c36d2fee43db67e828b197d00a4b21dc762df943edca6e70c00fde03fe54391b487cd2e99431b7f9ecc268bfede9bd2f8e1dc484c9b672a133bb63b0f96bccf0a4fd2662f77ffab92bf6aeb522781f487e9df5a19227bcefb494b133a52ff2f5fb78203c43ec776606275f930b2fa7064cc9a6cff214a9088e0b6fa6607d40ed9fe060c7f4776cc6af62ed7a0fba1b06dea166652efe7a46f7fa6b7f6ca04981c0d95a37cf783ffd737bc5bdbfb3398970b7b1c7f1eaad6b2d2764da8831b6c6d3f0029679b52ba2090e62d93b0153941f8520f3779d3566fa34a00c0f40ac2a0efad3332d752cd16010d45bd4d72112d16789caefac9c25a20463b2bef2851a597bf4a731869b6cd94e323e570a9ce0a146c230da24ace9171ed76433e08b6835501e80aca8da61ce4f1e651ca67a5bfaa08b73528634dd6d35f53026cac401e10ec12d77ff5e86b32f493728182b285319acb1631528cb50fe6b133195d013e19d30ff30f4acbefd3028c40185158c4a71a1aaf650907ba2ece175b85c02cda5eb24f217a544af8ddcf027c6fad7b711d83dafc2061df1cd3ec3e0b896580508ec5b7c2bd0c89b13ce8b12ae1268a471137b350aab625ae94d10ac11ac2a24b7b26ae73e058f342b87bc09a4b14f6892bdabd3287dd2b67f18d8f273286743a0534208bb97b9f2df41b471be55ee5f78ad638057cb0f0b6a727ffdeabbdc77accc988255a593c88f2b966323774899f70b252c8ee6b8a77ad2833b3a7da8260d6f0791223698fa8c01a64ccfc216069d3d411e3d54f0c714f8dafe7eb5d1e0ed1d4475d9f76e291183158c9726ee7e16969a0396dd6c92bfaf524dca7f86d83a2b0371d65ad1fe5071ee09921001de6e1ac6ba62b941b0e956cdda5cc24e32ff47214e31511cd0ee3927b151718d49f92bab35e646d7974a26d6afb29595435c27db9be481b3851cdb863deceee3daaafd44bef247f89d219f257ddb97950001b2c6f61b0c8f7724a6ca1a84c0dd93cfadbe2193d6cd72577fbb99facaa2b0bceb1322dbcd8a0bdc276849b99fe7eaf2b0fddc5157d3b84b4ee068ab5fd87f3bdb1bbc632c3f8ec22c2b5a2e2bb21bfbb326d7b27468d6cc60c4c8c0f342493aa470c1815315e3bcc1b0bba14270da92cfbeb600e6d7e701358426fdf2e489260cfaa1fb98dfd056bcfceb49dba4b6dc819fb0d3e6f431bb491cfb43d455e1c2c7cbf1a2b9478389265ea06e9a5acadb3ca07e365d8a1dd690b32276ef638c334d0ccd1765b29154c1cbf226605db2b1255c9cff4a4ac7eab2f1dbfcbbf2e4f7d5757d2e409442258533431d95a05f3e6a9a8e7219e160c70fa684b55a4a15cb4a49050e1e8bbee69c5243b6d87f111142f8ad225909c51fdcd6270a0d82a8e6725f66cfc88098d695842222dfe3aa9f02d24c1134d2967d4c9e17752a6737a10da3f96cef212adf6d4b37506414b824f989ed7ba4791a739959b6f357ffe236db5879af21497fce80aa50b39e5cd14ca0207368127d4dabf9beac0ec2374fb65cf24f6afa60e96ac458b40c407afd19b6df65b1a07133b607946e8c679769c3dd364685a38fd8c8872ad4cf5f83f99d1e9d6f6fe0898eacc82f450b5737ffb34c305053e8122667411c8179f22a815ae3d9de1860b55b7f20bc0f11009e3478bb90e4cee595a3f48b6f66614c174e9b5bb9843809fb9e64e322982ef82df18786c226d571759fee992e513f58f3e175a2645b699f3695d5c2b02d0244a16bf79b1212bd8045bc2be65349290ef75a74dccc395509ad1eb5be3f9898223abfeaa94bcc5dfe6b16d21928935bc904af1325c7820d81bb05dd66ed507b203c40529ddb7521093466e635eab81d88c58d370a2e0824125b5b4884462dc5af289e1ea3d450cad481900a724f9248471740a23d69850b5659cc13d4cee7d1955154f21a77419bee6524b5ccd1e75c24b6c20a7a98d83cbd33a11b42977131deceeac2ca90784bec1568d67286ebb45f7ac693ba5f44577d4f5592839fcda5dbaf7e3d179249b54affba96b35c2e3be1ba920f01f3800f22fb9598b12542cf3438eae557990f198ca457ad6145429ba07c4d6e2d3ad05d158e26355086ec2ab9dcff0514a1dff4f30778218f2b5a410ac0cf7c64b9e838791735815ee095fedfad247b5f5499f7a0b74fa5521667935bc830bf2b9730b9dc322acf9566d1331dd2aedba2ebe841c14ea7d6d35eac890ef71145420fdc16834e7d5dbf2d3556964caf0a4aa2dfb37704cd770ac92c70edb0f5c88ba16c8a7a90f8d8d618a054a94d9efab3b3a5e92469302168710899c87968756f4ed098a640b54f1229de4c42176a610ea80d597fccda7e247e3576e55200871ddad0cf1d58c1ea20aa53fe5e97241c7352717434cbcf5890372b0dfabc103c0c06e6376fe87d98005884df7f8f6fbba8866f0fcb4db36559fe873ef2304a8a21271e1c68bd3d222b4cad4ff50be851e9bff9cda9014b64fcf3dad414313cd0865bda5ea87ed79688eaeb00189a9cf60989ccdfb3b55224aea7c0974af2ff6db814c81358f6ae9e6cd753e38ba794042039d03bad18eb04aac9909a12cdced83061a24e81cb60772b8a7006ef852244c65343f7acbbeac15ab51d3638341de7a8626d16c43d5f43f865efc7c01bd97c7deeeef045689aae902e4af30d5ac200b9792b81b05c30c3e62bfe34ddaf7a5f49d69cf0407e714c290eeacb733d1284ac62d1578139fa49addd1ff4edfb6ccaaa529da9c6e6b04e03bbbcc8d5594323b8e6cb5bf0d776cb6476bd486356e462dc01562a1d423ab9cec955007092cecee79e933516abc6528d493f8545b47e29c6320116c328c591b6c8922128bd951a9efc643f2291ea9f06b4bc926a937eb2d8daacb0cde21e6559bb8aaab6182862a70a8fb77f819a0a1f45480b243a00c220c1a74e86cf1b7ed14e1d4a64b9ec1b9b1a0844f504945c8bbfd2ed8fd91a64e9df3cb83df5900576521abc94cdaf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
