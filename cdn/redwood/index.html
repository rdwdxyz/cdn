<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2046f93f84ffa1926c5a222b89f2d55d999c79e187fb9bfb3834c74a9b0af083083cf3865f1c4b931deaf3de754d7a5a79208a02681e8b5b2e7003fbc91bb8ae8772e6323dd3316d2086c57c4f84fa6be3af397fed81a4bcda6889c3e8c361dfd3bca5980f62b5d397a5b1c96d0bdad0985c582932294a72e60d87b185b7d5f2fb6b472c3821131d7ac34a21fcd363013441997d9181c366e2846641f5ff49b39b5ae73fb40f9272c7ea2852c9af55a3992993addeb82f60d3c3eb3c8caea727b327abc73e5482ae5a524019befd61330f3d7fe9bafdd9b52ba6fc572230627c39d406a439fa2f127254669ff923b3bbeb0cdcfdff32f5f079f56f7983d204c05488d03ac0122807c99f7170f19ef35689b40c97c9a33823ab8f80163afcfc62c0609474f7f717e08c1f97f12bc241ab5a16de96690fe25b8d73753540241bac58223a2b22322440c0741f5b99a723ae45ba6418d31168ff59e6d0bb3448b7f776a9bff2f22588de902df1511829442d13eaac4a64401169b3760a4c7bbe80394a7c83427bba57fccafbb344d88ab55bd052f3ff4a127d5537252b37f41235d97fff5ac8e1eb803e5bf851f3122d6137cf81d704e5bbc731cbf928feb3d639ed61ab96d940fc53a074497bca3a5a2c040effb03d70611b32888cacac4c1215318e381d6d8bfeb16f084bf9701cb1fa7d7591888b6666eae129972245e07637d3a8a85839556b4e8d3d03aecd3be82f0926385a5c30e8fefaf2ffcd99dae0a624d1cf28d8caa4ce44da22c069360c880f1dec43c493efbdcb73cf2c22b03f5e9feb47c1b0381898745fa30932f3acfc5bae70068a1e084a092391419840350e9a0c31b4bcb1c49e981a58e00930be86161519a9cb58340e11b089c1eb5f7a1567f0d10df46ba0caf70ac1a9cc2b8f6bd40750f776d8162dd9d7ec2578503b8bc8a91d4920753e0a3fa8af7d0bd34229e4dd4b3056bf0188b34294275f32c29abfdad10d00721f3af5b8f63a6ef5e5e6f72c7263c1fd44d919d528d06027f9e9fbb3ea9b18f368c502f4db14dc3ba1b175df3c9d20cd68e2ef121610b3c630b7198b3dd574cc41df5c57ae71f839bc54d82ae27c34b441e47a6b8a7518098f246fda6b961a767bece5cfa2065df228a53fa1f9007553210e6d1005e02bba1bb4c155bac6c751bd94b6c5ceded1d5f4bc1cdd494de170b332031c51dc9357fe73199a07aa524b249273a8ca5490ff9ae9b44b0fbaca04f098d0f3146f4165a6d7562be2859bbe2449cb976251444e2df6110d7d8a162683d5b2992dbc96d37189bc7e0c652194b916a915bab4e1206cebb41e938175e7dd094630371d7deeb61b4d0fc2b098c768cea28569cabff3382defb73d3c6ff40a4ec060419735446a8c1e091f09f8216ea200009780a4def1ae4089ebb804d35a443cb69e32bec4d3f0aaf0a8117d251928d6a04ae4b22a60e8378e8bdce6dfd640231d411d34da29b1095292a7d286ffb68af736a3a3a01f196847a07fb1161e083bf8b6a7885132add213bffc674989825a5d4187a7b057ee095661715c476c17e38389970399ee817c39fe38bdd49a939594c8ff223fa424efbf985ae0ce333f2ff7ea243ff2e38136346af82f69d75ea02233f5a6004fec5b0dcddbabc4094e11fd211919ed8e1da282825b1a9bdb03f137caecede0fa11afe650e0bb817f53c0ef070c70881dbc80d4c35f2fba7eacfe332d2c7129bc496d5216985652f2163cd04b646d28055dceb853508efa0645c9163f3b7e0e46ed0db882ab8dfffe14df13b253bae20028db213565853ae7efa2840095991a897c43419e8c058dbeda45a9b2ce411cb3a7c6a636f01504e2692ce582387624bfdacc2c6f9b095daa66c9043bbe0c73690ed5df98834ab1419533a5b29b8cb5576ca3c983c09bc9a0c7559c3316df04d7eb7a2e425f56a4535ef840b4416b3b5934fec56f2d34db5e16f4294f49e9789d214d75721719cfd552ba13483b77fca9f85aa1dbf756cefee728b5b06eeb1eee21c834559fcaa30a7e2f278d403e2d0ba1305294d859e3c8da17b954c2e861c2784dec5c86e139af76bb18d5661c6e6b08192c9b0d39768525b982f8c5ec0eb547311ac898e1ed2866fd8aff1763983b3916161299abd48936387a22ed035fc970c967679d84782c8763175a10af49338a98b14a45abdea319dcfa952a6865bc92855eb39eeb4c941a5d6d3dfb2a41ea7c82a1313e9ba59396be21601168eb75d1d80216d7c38e45eed7dd9b0ea34749639e7d9b12f0f646f8f8aa99a3779f2bc1d9eab06470c221a4e88d679d5da016bc05ffa94552b388d2232b74e6ff9580ffa43ac3502de6d41d6edc308f6cb9482db6219a5818ef27f269238ade1f688fdbd89c2d88dcfcba205db427d6b9fed30da72865867a30e6b792f6b5f1992034c1b78d6193d81458fc4aeeca94269562566e41fb3b8216adc8a6be270da8f4af1e722e5a2842208bca762c7dc1237669380606c01d6f4305c9a0598eec5a8ce946de49a37943b7318eb78665ea4d9634e0b3da182975e010b598f306bca4850ca798481be8563ac25801f2acf7fa72174d71727dc781839ab440dcf2883631cc143e9e3b95c695d6d082c0bb5de93b97f57bec26d03969e5bf072aefb9271cfd8c7e7482d391cfa4d9cb246e0992877dc97b066b241f907c2f144dac7ef6c87b6f22a379929ac3a78ac311aedf8b23a438ea9302c150627282c6273a12ec14b45e4970cdfddf70063fae6defcd5695d80f8facd63a70cfe3b3f23faa58d0940f2e28642666214f505a073d39ec07d292eec5770f6fca07b8170f0ee8d113fbfdc3058a42ec2fe22d966bf9b338204770bc525bfeb46d578ba5dcba685fdd5bf8d213db4d72fa60f61755ee63cf4d6afbe7d3292a32e7d17e987eb14be1a41b98ccb0d50b732238934b0127b3efc96870537f20deb714da4fb48b366af5d5d45373b3555da5f475bff513a6e5aeea3134a0b61aed9d98c45a6d46d26602df9daa7cc80f3ad33fe42e560aa341ac96875bea0e6ad7b854349a62d548f0694a9aa07bdb4e2d09994a93ad85f3eaff7c441d54f30599904de1b07e521d09d6ae2ca4865b70fcb810a8ea267032e177c6898a9504f17f7d8de40ce624b94205745a363ec81353330487ea8120299052961cb386b4fe7b219f3b405b92b4944c6e34f9eb198ae12c7f8a321dcf7639667df8a81fee084401af2b593e61b9d5d8508ff492d64abceb92bc1a375cce1285f061e52ea6be884432da9b57b4567b70db6dd811419e992a2dba55a64b8376a1b9626fe874d139eed6c43f732e26ec98cd668952bcf855fdfb81035cb09c1d40f45833e95fb3bf414a84c40784ba27ae078eb9bf2654cc2e8baf5a16b9684fe33de2c47be30132af12ed56d9c708c162a855902df2065ee434e237a2d45cdabba86c8ba399852544eadba6b242d019d55e2cec07b5de157d0c84080c185c445eb91891354c53f2251964f91256da22c67ca8822be18808c2aab389cecaae347ce35470c402c2d73e0a2ec9457fbfddba89a857fa4f62793f37f34653cae68bb222a5fc106b0b53fc854fb4c51997c83869eb179d350a0863c2782f479d5db891b22ae86531b4c147f94863e38869e69be255cb04c3afe3416b996afc80a3ac47ee00c3322729853bd878ae7fb6831514f7555d65ac7ab42293c62758516be068437ed3d78f8ab2f7bca994a6cd0543ef003191229ff36222961ce3a13498cbad99db599308207c518eeb4fcf6eb196915f9f592836b86d1cd922cc2e0574594e1f39034f9354fdbaff69b6592e53a4e209008d8448239376c1aeb5247a1e0de261b28ea6fb9b5907ebe740e3b94f0184c3191261577961724da07ddccbed828d7ce193470e475ac36a347a2569ac778791b6fee883a8ee10089d32a7b9cd5b4a045d42a885aec4a9ffc47bf9122164adfa63703904289abff5c2bf340422f818742c2f27f3cbbe8dfe5f7a7270c7678fb241bd3b92878a67fddeecc7954bf3b623c49322082a531f56cc5e405ee10051c2c32df827f51a1744b4b08001f4d5e02d35d9eb0b5b2d300e3e341377ef9f92b45b43e872f0dadbfd7030678ddebcfed6a0806a2b0558eb1bacf8d0b06f497fdf6853c7703765d474d367f1a6d241c7520e2e6b5e3d65e09d09a3e0b19ddab06e3fcac56d7f2ba3cdd6bae88182fe78e00a73d5d23854fc1b3e903ddd657538e50b1ae207b5cfe30f99f080691dd5143c3f38d362eaa4532496d15e2793b2b504de27780f48208c8d3495980a5c68113631995e401641939a9ae1c2390853a884dbd51f80e43e84346d9659d31e93d328ee7dacb49297ed4b343dcbe3d05537c5966a9c721097ae0285bd9086bef027fed5c91c38d4e08f66659422904efc338758403f50e4b20fbf45768d05b08106c413aa0ea5c32e03efe71d5fdada4eb95cd01d0cccdfed0c37c75d29fa8190aa9189366728ce5d7e90161854f81d5e99a7e89f6530f5a6c922097d10839d59d7ebfcc5142d49650da8450c16b172bc778bc25fe26a7b72ced94fd472782540f0d890149bbbf5c449aa0a918f97485b70d54c4ffac43245dfba4550392075191883770d8548bcc736f5a990817696996d2e2aac3cccdc3511ae8c710b826bdfd0205a353be0dbf3871e4138bf7a5bab989ff32461be3657ec0ccc6c24310816f4f00e1ef2f020176b3dd807e04b3da69dc0a20aa67bedb554f02f90575af43d3c1140a90bb63db0d766aa441b50f8c4d1e13be4a75ae2fb8ec31b43dc79d872788267ba2743c60d16333665afc2c9b417b42393699a274a5b10813e1e0a0fcbd3f7eafa8d303705c6c5cad335c2c5d96fa7010d82085d48cc2ac311a1fcfb5b524857bc4f427c294f3f37b5b6afb0ec53eb8e7504928e7e2206d907486816191e44005a1b4c81ae5e24f1cca5a6389588c4925de48511be5e55403cabb108aa385c0e931eae3e2efc3a04ef173ab5986e2cee09bcc2a5562d66343d4bfdea43b53fae195fe906006cc3e72292e78af4029e7b1bfb2ca9d2a418136eba47bedc9f2305eef27065f8bbc0e9198d9fee1e5482da96634790b1262674f88fd3b85f942584a8e3190509a43181ab6aef8fd7bfc4c49e6163c78bcfcc46e7040e3605a715253b92315e51b56a10e8f9abb55f9d5ff69a2cc6fdd39b9c245281cab70a9c717a36e96f5d79ce07ae79c33f727c20f59f68924fc31e4fca2174cfd67c7314c538cca4287259153ea5df977b0cc0754b4230d60f191c7e4d6dcb8f866ef6e47b4a14575524d2ae6a9b45920ff716088c29a1b6d16643f15cd4e815a01b47b39bbf14878882e3c70eba00f941e6ec88789914ab764fedf456ed085f465c22a95965aefa2bea53788769b37014fa7f99be40ed5de569ae794e2a25ad74403f178be1fdfa9211722735ea19b79ec611cb98b51108448a73b931523c4b9d59a1e9578ec4b73b8d9f015aeb623128188190e6cab27f184ea0a32120c4e6e60b99183d7e5ae04fa17da50f596d9c6af38c49c05cecd834a8e4b85d2f870bfa75e2b5996fb8c22f2476fc4770611dace79a0e1f60d12d1396e14033ff91514c21d41757c0f7257a80d9be3f1db6d5ecb7ef5b9c25d1e19cc8af77c9b571f694ade6fc11d0213be1398c763e05528896bb56565d60990d7e3230508be67fa693a0b6104a92c27afe7ff1ff241241241a6531d2adefea428dd003267b0cf8fc9a2c1002f30be4432d5a822aeaea8811cba521f55df6c54439ac0283e7dfeec66bd28fc0596e9d08c3af3fb0f0f206fe1aee859305904e3923fb3d2d71febebe7ddc9147a12754a1f9bcb9aaa00a56de430c3c645d6a1cce8ed2232a6665455c9419a6d0f4f20441ae6a0cf0cfb51988ebc0666a2fcf3c8579095432a706e2090e4cdf840767cafbc50df3249fbd1c414d1ddb87a3fa7fcede63094308bb180a5b46bb99438b727422cc7834c1cb6c2a224483e184c51f31e1f9d01b2c3a10dbdcce2448cd19618232f689f1512464bb49b0c0ad5c9f773f61329671661c01ab3d7fd991c4fd31ed5e353766a8c446fae151a741dc617a8efcfc6646a7e147ed47dd5c4649eef245a49829d925650d404f1ee670644719be38f0b0daf97206c54d2a99d44d2aa664ab14a33e8dfc65f51fa56bebf30b5fbbacaa9bf427c8f33015f28fd23527c96f4f00f3722181bc20e90ee3c8fbfdfb00c7c86be4b7f79a7560727b04f1d8e35e1b458eab116eb04c5ba8e7384a4d30f14d9614614206377f38e9048407391e9cc00bdeeb0337ee8a9be06a68b388b69974c31f1032634921833062de3f094df6f4037090e44a6fee177ed21be3534eab64907267b412ad6d1d697d16a723411de6508b337c125f2eb5e5f7a662bd1a23d1cf42a20a290acd04940035e25277b79cc77897332d074ad131d77df0c84b02905a02bb023fad6a90385a51e693c7cad3d3fe4f8bc1af11bca5b2b7fdad61124c7d17b1f548bdca581530fc22aa7774528b67acbf73e441ce175c0978041a82c177914d84d7b5f0e01ff3ca325db3a4896cdc81771c8fc726b06aee65222526bf0886ed06b1a92ce4c9bab6ffa3344bee32f949500ccd840aaf72ce3ac694cdc1123131528d966fe022f9cf23627be36ff5006f2f141f25c7822655bb07c8b9810c851cd11c6af36f33e90aa1f6236c97fd7aacfe2fb6dcf5fd78ac5761218621e658fa3f8c6c3c0737ab68348d66e6f306478cf3e98831d89b44ccd1c33331d4b8ae2e77234c6e7e3e254d814cd12d9530b1af9cb82997914c42f385172bb5b7a4e22aca05ccad879fbf1f9f37146bbff6ac64aa362d8454001c960ffadda151190037cae52b8024c72dfd0213dac34248ec7bd1ec0c9fe9b68fd04900965c840735e0f6843f56fdf9d9fe7353abd5c023394be72df59046615a892e6571341fa34cad3d3235d7f7fffe78c2ea151bec56f0bb0f1174786bacbcc4c7c8e91273bfa0ae1d0b90ca93f3a2c1b58ff9aeab9f90bf47ba26d2baf82a77367605eaf3b67805ebd20da39277d2f7149772cfb6b98922fb3324bf3340c7fed85646d36682632e5a70d39de7071ddcaab2b1dfa681a9a02a4b15a7879cbfd306c623f4df949e45f3cfe94ed74fce5156c41dc6cb8082b97838eba02bd831ddfb9a4b3595d4b0c5dce9b452e9c4f89c3f73868e05cb15f1110c16ddca3a5b53751ee07476cab58a8dbb591f15fddfbafbddcab7bf2d772778abdaa26ec6e039b38063149e2e806642f1403640740f2581dfa577e66011dd55807c8d410a1cf86ffc163dec3cf580eb0fb332bed4031c30e76af2982a5b3781448eb508d1b20935d54a132a74c159c471eac1c3ba993a5292e964bcf4193d506e33780607dd5d813b6d679742cfcfd17bc11344e59c2893693c9cabdcfd0782ff219472c029d50ac52499f6b783e6c041a20f7f29256bf17191324f41d192e6e842e5dc0410f915a674ed9df86bf7bc88c104edace76df27822925550e0725c6696ff6aac66893f1cf0f13b45a7585e97808bfeeec8cf87bdc77f0e7e158028a1ab1692eb4ba1bd22a651ec982a835b21348f33b4db1ed20fa68df4ea955867dfdf9472b2c5e54e6b2353b0c17f2461f6ec7b0314ace605e3a0749fdf6f80c8a6f04e16f1648d496562cdc7d5cef47479466ac126f8d713cedae76aa1f0a8d4bb836b83b8123ff8d56b757ca5c17fe8e1369bc6f7b7a62057f46b171c6561cce308d9aa1df2b807c5da27471936d47f8985a6c8c28ccfcc30303d1b85064b2cbc3ed83c7a04029ef5e0108c68652ca7c21638aab10276f0dd2ccd12a83658a9fa564f781a82a383f1ab5dfbaee480d7e8f3e9e77cfffdaa27b4d19661ff5e47597230c8f711d172153b5bd803dd177a313f35532e614d38b22ad42a34a5238bae5c5f6eb928d7a77ecf9ce9aa5f94bd174d79349463193778209a0e4a0858ad4a1bc5215c492d42cbf6fd4ae8bead98dfbb6899f83c20ca08d36af14893bae65c8d1c18311f852f513403a74089089e52ac30e805032c4ff8578f9cd9fff86d15bef028928dfed99f6c8f6af20215326088235baa7a107b6eacaf46aea420f234ffe06381c76ec16805b7e88c358f9a9c2aa5aea2d6984ebcc229f24edf8e819d6cb06fad13232c1cec634290106934b27a7576a1360de16007f884f29293b993b2da987b0fac4c9671cdb8d37564ff2db29bfee94cd66be5154872d5405e589b979491ac3167481d3761ab96b344efe4b8a5d0556a5f663c2d19324d19ee7cc6be0921378649b268f835b1bb246a40d8a7927ff97a3a4fc3bcf4d2a99a191786461d40d617af3e664b21a62f5b4ec4d75a7d1f75233bb937355e70c4be69d94bdb6d0e07803cb0188d1b123e6d303db1bf73256d94fc00cac0235b097d829da53e76b557764b0ec54ce73ed112535451cb756f065439da5b9a5233ece844b4f86e4a1ad690ba27f7cc3d974dc2321ec82544ddfeedf1f95af0811557c2b08be27d0bfb76381e5b7957c1a92d24c87b3f0a6f27625735da0c7f4f8ea0b356b0dde9cecae0e5446ed2ee17f0ac1cddfd300c9834bd651341eab5291635407532e887205305da281e5759b368a706c257179d04585f6c3021731df0488b9079b9d76e22d9c1af164d5aa6c91a527540d0d107be7fa09a9c4f66d181b6a99681b0799611959de7a4ae7b3c52c9bf1044bf97a9f1b7098c971e9f906455e98d6de1f1336e4a5bd2d569763aae36a92815117e4d4866a52b05ff4abb3243d744ccd243f43078713b591b5c466bdac8b313593a87ea65b79f96deea26a711c6c11169926fdb8c564129e78c18bb6290383a3842e62f7202bac2f70ba1bc99309e72c9de537d4a6f1ce8a15ac8f005d051c732d9512fd95a27be14a4efea76ffc4f84f215c9cadb59f0f6ce9f2c6ac2d70778028439b663c8ef195be170ddf0f0379c5a04db651fcdbee02aed3e4a331cbc40ad1ef371b397064ec1757387877c3187d882b856a7be44e649daab559a14c7b3eb783042f9bc566a7246258102bcb0e30d543da205470b8af31b43359085d51ec43f7f8f85a0556ecc1dae18b1f2af18a08e694a64c3f7805dd01ffade2cb8476c95f791aa5983d60aed7996ab4818b618b2ea5c71b51f2d0cb071f04a6a632303705682d444041aa2d446e32f4665515d466dfd07820cf71d3664cd6d4bbd4d9d09d26b17c0878cadf1e9532f14f071bcf9ca6843a4a49ab5d774be8d9dbcdfefe6599afdc0f5a27b34bda50d94443dbcc77b4b19a76822742d36aba7f899d084b0c4221eeef05ebd1c80fd2008b463decc034b495c1de3cf094f8782f4efa32f38b91e4dae199cfb2f2c521c92b9d2f1b09dac5829c8cf0f52bfd49d59c27d91376bfad7bb8463889c54a6385473d48248ef32b906ea0e1916a076fa357fe29e70c5c9fe802888f0e7026843ac7b6d49dd8fbfcaa21389f9aa864ba643ef9df4585e1996d08d7174cf6454a0d570e70e2ee01a2a2a8be9b36f200028af288578ac044c1c0288bb1e539d27a12e20bea9e9fa61b1e0934197b5267a624076bb169fb862b5a5f0a3a26f7833ca057494e51bb3b38c765d4f7aaf9434968b529afbd83cd09b3ea7f3787c7f492b3c6aceaa961c92aa5828a97ebb5f3cbc05d9386f29b2a42c836da1c84798b7a0aad272fefd6d17585ccbc59d294fd3388e6535d0300f94fcc14507f81e9161ca25ad6e61854ff063997669da5f6370b48e2de6195114fee74e42812ffaaef408c36bea7abaac6583aa334aef907392919075e1139b8d53066067ce50c99488cb1239941cc98daa8d8b2917510a6db51e991a46b4624a8a53eceff5d25ccacd47bc5df557760bd4b8ea8d16c38a67a7a450fef3d8d8fe3b9412094654d5bcefacdc50d5e5b8ea72614ee4e582b808dc776dfce3735920132fffaa0dd620dff7e3a3cc2a656973a452feab5bd896769a73f696bf12fcaab0b7a36f83a2e64b1f136b20a307b4039f410d215703d58a7b281f6b08f95ac51103ea4b8942d7d2709b0da4372befc757ee9092a201a69a0298d7e03703453cd6fb84d33b7a1dc90a7b4be9f03150a1c87de66e7e58ce590ddcc0a7aa5231032c1446f1ee2ea90e3da16195c35c907e339bd5acbfdc3cd0c1be877ed1172f4296f27b139ca1f69d88915b464e27b884266cf31d936c850beccbd4b429642480c0d73a4d310fcc9dd27603746a62842459fd213ef2336e02349a90c89aa055f901d95ad6fc548ec497389529dbc236647d262be193c8e85a299b8cf78e67788e3c78a856da71b669756e483ebee707a697f29c93f9100d3f9d14f4eac2792aa584d353cf058e231c9af2cb87babf29721f0ce47dea9c77a1d97ecbc2a4b7ebb6568adc5a110323c63f4327e59b1c59f539a79fe711b3fbda9436548f3fec3c31659344435bf560d288a178cb101f9e249104a3dc15dcab5724172ba429f0082d1e472635afb5c38a103515b262e153f31fac62db67177dccd7cc19d356e42cb48aef698f603d3244d4becf05da9566c1e0216cd1031d83438e755d7fbc0a916edbfc90b32983769c3aa17cdb8c027d7d820675740a8acf6876b9596cbb07ae329eeda38a938a00338ac16afaf07795816594ce99444597a7c085e8ba0ef300d29f1874b7e8786fdc2f4d65d418c532668622d04a2ba5f87b8ac8f3efde997e34b6c3bef1b05c3ac833611f513f227c182e1be8aed154e0ec7ec1205932cf6b00623a971c646487929bbd7f20a3900add283bfce9b1a8684791b377f1e1caae25ec5419546466ca17c663bd020ef2ea54b43fe780aad1ff302342bac9955278a2155a5a7b371b7303b2d7a073abf54e29021a94cce42fb6d57c01250bcf5f32e6edd5b9ec2cc1f17a1150f40a672bac119eaacfded4a680233de128871243d51a39bcebf21934c967fb099423a1b19b4814ec2ab852e74ec41fd9a96f3c72e8e216038bd20c759e42433e927fcd5378605cacfa90ff6dd7e68397d12ff845bc5f5eb2f1b63ce5a31af43bf812712ecafcb0387c6d744286cb765bf091a06e0e412bdeb14a6d77776aff5c22de494c549497be1808a3c9ea1337aaaabddc2348c17628b5f0e323a89c11ad1f232d4ddec0949ba736af0d690fa228cd2ddd25d3e01f695b851f358a26f835288242bfc83c64888a7611f7340f509d95541e53c3cc60ab81eac80d3a2551c8641cd14dde24f502811e2a1563ba3a00eeaf73dce3353bf2a921f58c646380b31edd7f4db7d82b7b934237adefa276b1ba10ae48d0d319558d15e16736997ccba448106c9ff4bfaff3a93391022df426f428001d9f3d56924aa61f2cb4836e5e407bdfba041252f566149aebfe84397ceea676c668cf1602d740d1cd4ab99fa779f3b17996becd739ad8404248a55480c22ab819f0e463ea73b2543047df71899b9a392d619bccede011f8f05755d7541106ad3770e33001cee84b7ffa0226847cb0f2d1409c33e2bc50268c9afe076e5dea0b2fe70f736a52e3ad1251adb0a24311e253102efca44b341b58f08d69f47ba51099103249fe3318b5ce41d0e0b823e59afa743bc3474c2cec43987ec7487b98240c3f50f0f51b4639a96f2616a245528ac316dc403e75e918cf5ad779cf6eea7d8e245350401dfdd9d5acf1fa65738bf9a558b473a7348636f28d1cd22ba78c67db77e2f5b0d9a58bc58c4cb22244fecdeacedb9e057bfe5ea3ef7a6ec68b9601e08b3bad67b33d2b88eff83f25a42781bafb81a38cef40a6f87ac609932163c0aa4eb4773e23d7f78aea9ea191d668a81e72f908dc2ddf276d48391ceaeb6b633943afdbb1adf708ba400186d0ee25f9b4539e81fd53d0fb6672c07f709123b022a312c866af34d84aa679cdc3655d112ebc96e71ebde393263f64ee1d5ae277acc12db5b0f231175b194501379350132188ec139b0665a2ee058f3a3022bd097ede469ff85dc8ba0564a95858777194863adae0e71a0c859479466ebd6f9f2f7cc2beb2f9619656aeefa6a1a36f5a7556ff9e76b6c74945b1b8622b90cb385dc3e03b354b5533eab8cf5003b6028564f5459774161c81267c486ea2aceac788c1fd03179ff1e17b5f2751ac00a5d5e0d28225560f6806d7559f876e433c3e21aceea06ec63746033f28c2388d9017c50cb05a7aa77fdf33f9896e30199c37fbb3fe902bc4317f1db45c1e1b35fd1a8f996131bb9e0510845e9ef5fcb216cc0735b3b9d1db308f4c0847ca9f86a7219396311f95d8f6d100793340aaab0d6763c8b184fd277d14c099f73a8fede11a5587489ded5c15b4e646a961a37b639840575228a1787fbf283586e7b2265e82ef64fa8263ac1cbc7c7cf8ce075b775584e72cf10f8159b4949003b4abacb6428f1ce63b65c9300c03e5d4d75e7e5b6b8f4ea7742702c773c88ffc42fa54076d83ee2d97a698c2160ead7ac60589e71d0ee364a79394de0c7e1f1253a8b945aca2f34954306772fe4d4acbb22e1f07af1ae6635f972872d8a88e28d9d43ffbb70c1f338c0fbb1826c2368521712e6e748456f59bfa777e1e1d6e240225a024322f94404c14e733483ccc0b941f1ca51d08b4cfe296ab6404077c0ab7cdfd5bd54e783ee8e2e072d57165269c3807b51af0e410e2817bff9236e2bcf01effe8227f4996fe38e524bc226809074860bc72790b43261e43a37bb516a3c0338712dad261199d5d28e668e32f49d3fcf3304afdb415e974dd316da27c7f675237d563192ae0d5c3f4ac90cfa8a6b2d95adcfbe48380212f011e7de08f0f2ddd3751935a85d6c09c94906bfdb5a7c73c15fa649619d5a5ed417707bb401f77c8996eab4bf99009b339ad4a565a66bf65fc5c751f8a22259496f8b84ede0da78f117904a21534cc7ae1db8695eaafa087e6e85d224b0e9044375f0cd92828f35623fb4de048946e0546b853258948859569788b04f12097dc96f3e4b2d808772d605bed1a6314219c0d8c7dd4ff7f10abae9788d357a768f0a04f10b1493d2188ffc9d5bd3ea3c13e5ed75dfc0c801c9a8ce8f9d7dbfeef794ba8f7703e18a6543162ef44a7d71532ab3021dfb83062381344817976ff4456315f75fdf4511f9384602e607c7148aaf14f8efea888e105406acc8192708eb38d773e7b11764d843f00634aa447d45e0528b4c6994eee84b8dffc0a7bf2b798b04f4b8f35ec0276d811d7df833e1eb9987360d44d8b52bda4e61a9b1dd8d0655b489d115f23025afeaebef058687f6970bb7cbe8065e599779bbb13e85caaa69803e422d1bd12a9536140a5279890de785f7fa3e3fe3981f7dd52a1d9f8aa59cf47958431aa7390f6f3780d3cbabce9404c3223ef4adb4561c94c88e0c1e6c31a1890c0a55faffd1dac9265e014d94ae7e503fac381427220b589bafe43f9852f0dd9e259856510de737a44795a213a8a046efe1904efb9b228a9e41e18407291fb7c14cc66826321621338e411171b4b5acb26757eb02d878fc46c27fd4b537f16ad74d4837fe7086b336bd9304b14a84a33fd2bdb7e3a723c023a7a2b13c1f5036e984c8b9334c3d49daf444b0c3c35b398cf25eec51f2a99d88835a650ba0e981d4ce9ce37498c3aad0291b4360b8899963b234fd10795aec132ee9889f0170f0d1d392d0c89b3e69093378cdf7e3a0110dfaf3ad99945066ecc0b714477aacd2cb990c9169690c44427ee81c1d6ff2e37e89c68a48bb337a52fcfe2b6a9b70c7be355dbf525ed343deb42add767deeb73bf89aac15c9d25d6c38c0c3f2aba5df151b026bf4e7991da19e5c8b86c55d1609d441cbe8eeb2eb6b31675e30648c54271748146a77122055741ce8f9dce3daa8efb5a0b5b200d8c712de037ccea4396de484a128fdfdd9ed5d62c358c445a56bfdf5a9dd7d19e53d6de01b417e912b7f7e76fcf45bebd5c3081db8540e1d96893e69a5fda870be40c776ae1a760a73fd56fe9a0cb061c83bfe70258f3593df081a658b0e9760784f500e38b610f75cc37f4421802ffa78927a2134a4f8142fb800d33bceb52017d48f58e83020d0bc07c10042b526828214fcb4357daaac96483ec3f40cd8b170c3a488822eb00559414a670bb8c31683611e3640ed8b26fb1759158d7058145f25a2879c0653016b63d907b12526b757523eb931ee31d7dbe9023eab62e3f45d404423087bbb21c5b73c247a33ef1ec33927cc91e13d64ea8493704db43b43ace84d9fef4d8487a666f6c6ada648b6af4650388df9de5d7a942de9f1817c352a6f2b412048c5aa67057510694e79b016df91d743226ce347141ca145223fe46bfcabf1cdb8e040e5e536251b748f9a4798458a02ef7e37e99ad36a39f2c67411014d21bf37e3af2f5456ed21a7d7d8f3cd91176700dffc612298a42093af54ef83169f5cdc41effc381c8cc2588c6716f1b7170e102c75278fdc86f4fb3abdc75506eacfd3edbf83d707accb3094948620d606abde7dcdce75b6854dab06ee9e9ea132944810b70c6ed1559efdcc942667cd4e87e4a75691dedb77046c36fe750debcb84afa775883f87cf448cd95396a02a8b198ce2701a5d52d018a7a2234c0fb3df3e70f1e2de17351dde0842184be3449a087f6100cc5b1d4d3ef1de2d245a4e50c84996510186250357828d99d146492a024d75021a444dcd9c7c19ac83b790b81146d99ecc4f49e7e66cf0e439ff70da9288f515da1cdaa8713c9881f25eaf5ea3693ca7a7fb430bd5b5b19789acef15d083e95ac44b157b6271c4430316489760c14461ad28790c8651b7ea58905dcdc5113a4c51bf78538a61441b0f1c474c160c34b520a2f6dbe7d895549297087bebfbe200416359fd0254203621aa3a90838db74ca304cdd3b6df07256e627e2487d9027c7e86c41f2cd651dbf188a959b6c810dbbb160fcb282717316fca473715a6b85f6e4941bce795e47287c8680a1c4e31ec568d4fa107d5597cf363e6b3a571fdf2714a17c73aad78a70e5d58c0008c774d62bf939278e9f6be200da969bea0b5c6b5adea7c5bfc7f1deca676857af2e740621572e2e26116e0bdc58d050bbb4f6758f504e59c0ce92f136bb4cf6d745b73730609af425a231c10587be9559da0d7eb6aadd2f55a9bda31415956f2b073483614b3037d18b61c3764a4ef04fa990d382cfe749d8f20c6480f1ee22c4ee497be27ff058ca546f47ba4ef34b20e7296e2a75c8e017d9fec04c5a54d9fbcf36e70a8995266c35d15a3d15d457c56773e0820a4c3fdb3a635d7c78b91f17e175684a5373babe95d646d2e368ff77b54ae6db54919c769469e51e80c38c7c092636fdcf3d49340208a1e90f740bb02fa43443b6bb2bb6fa3fe13f89642bad8350f197a48b7783df7827a8d81b4c2a0173e3af009606166add558b89f706bc5c9f7570e15bbda6352b5497d1606154f8aceefc144ffa65f3910a8db53f42b15695034ca5632a5b65df51b565927e3ddc29269b9107e5a29e810e76a4460fab98e73a2725e5fcf6c94f8f02c0612ecb21a8b42e57f0c806aeb723e462fbc84ff03679bb1ce0b0e47b0aa3853f20d084cbf0c336b9237d854027a12d23f7d9a6c619e7798be2f985d6df1b62e17fc0714bfafe71d673d391f9a6c0358a60bcf7e16cef5c2736a1de1f85e14ba35a1c05f002fb9d91b7cc39bc8053b2f5fb3289c6ea1524ab3c7f436b9b2bce9ce044b9372d40b2f5009a437a8cf1060cda972295127c850c408e1d1f51765b474e34e5cfc1367a55827d820b6158f2507cc6bb76de44f37b5916103337aa80532a4bdf522c8c7a4afd033d95c0c5c6b5b07f1f2e15e939f80bdcfdc3f19f10b8f6b6c6bf3ac72d873990b344653a30b72628c5a2d4689d063bf88f516700e26cd44a477cf69445fc1f914f6ff9273736f339e3140d48c2c7ee37c9c5078416567b65ad8b9ab9b0cc20d1721cf81ab5c6089023a90bbc1705b9f789f1d1d6c5ae194f7587be17073f2cf2eef453ecdea0a55193cf8cb4e8dea28f8925133fe4516f6655ac1993f76494cac006a297ec45dc3ea2dc81d0e45baa424bc4d3e8f9a74c040e25b3642b7daeaedcbf891925d013a5b7a5e2e9511312b6c1f0c7cc6ead4f266e29f46b45db073aa7d09a79ed5fb35132883bad10cb777acbbc714b812df4bbdfad3eda91a9d33962cc9725bc4fb671f3fba9427511c4f0058bac44966d08069557fac580d2bc42af9e882598a2abce31df68c41e0fdfc362e2e69224bec8b721026f69c3af8bb7b9b5f49c025f0de7eb85d4ed129354f1a4232bb9f1ab4f346b33a53a470a2b15d78475862ae1c4b4e45633ac133771eb94d3d9ce04476f7e17df5dec5a53975461e37d25491b357d74038819f66fa3b3afb9ba13d29b3c6cd1b8f1dff2c63fd3dce1a3c2138bf787fbf4cab3441b6c66827119fdfa425b310a11404290cf7dcffadd6365f3090586ff31e213b5992a595e3dcc22597625279eecc40e4f72363cb195383e6150a7592ac0d25d2eba266e1429c076fd45b024bd54ea28f5cbfee465cb17f42667591bc0aa46d220a58b18a293f14a0305e460d055f71b33f4b33bcbbfae5cb9af28c6e62c6a311dfdace49daac832534778d3548381cb51c78cff8d2061556afef8a358e3582c2399d9143abd3adcd29e61d1289b8c76f15afdac75a371e3fb98fdf04edfbda668fad05ff86da80650b9bf43b9966eb620ccd5ca49fa1f15eeceff2afd67a0e6b04720b82e64332b255675880a7d61d3e86e332e5e1018f96e3adbf77ea962298c507751dcf6b896558eb1219679afb18474f7556299bb419bf6399da017db85d2df4405e6261a8ddbb76a4f29caf6d4fee1e7ba06605974c0319e2abb4adeddfd32e73bb132f16d75b4b604c1840f1fdcf9c594b2ba6d85c41913bb87e2c5ecf59eddc3867c36d7da29767952002950e1f037fcc8124efe3479abe467b5f30bd7c0e5a4d996a925174c406c3d06798d1607ee0abb3e427c152c5e401b4f251765b5332a2d83d267d39a9230f89befd40c1e9aeb61ab61f40d1eaf77be7c3ff3f5f80504da8dbf59208fe4311f4304393e6d259d4ca5ff6e50d2ac629922d724c3402103e5765ae4b23aeadbf3aea7f4c17eaeaf66148d6e2d97559792707adfeecf8136c29e2b07cdd337e387ebf7213a9ca1ab36e117925fb1f3ec34a308f7e65961c0871b5bc94635952b02ee57c2afa4b91d1f1a6a6e65200363b8cdec78b6bb95f0e7fff936597bd3c5857b6ff38925414087c759b90d9fa6e1759deaefbc4435de9b2a02f9f7bca1d58924f7caad559bb932435acd1516fab20a11b5563a7dd749a18a54ad701e42d1fe1dd05ac3da56fa1a6367a2f0308cbca5e9f25e0f073db0ced70c3fca74b8170a699dc89a88fd1d572b62c51a48f37fa58bf1cc0c2846d286e6897a40d5ec832d904d8922e9a70a0ac9b31845d188cdb6676c402e096cd08b0e9ebdad6c0a28f46d44fe9f676685699c37d1c4f4c0426f6546aea9b27fafcf74ea5dccb58700db8eb23ba99b27139dfdef2c4ffdd09ed67d4f5bd36ffd103649d4c5f65e759c4a3017d1b5ddc8a80c5c9e492499d11b9db428d9340a90ce10cf6eeb8c7cafc8d518127474455a9cd9a41288eca55735ea9b8d2b83444482eecb27900ab3d955280aa5b437a5a48b1067aa322af339797bb9f9030841f4c44bcb3b2d8130d1f32c7fce8d04bbfc496b292d0e73c2ca8701460290c2546c1533a835c6089debb54b4da8a811e6f3c8c6ef6b6958be0df5cf11afd3577b064a615b8d51a3856bce7af9f949887c829bd66c743c1a553b832b7813c9b975ae6ffb02fae6888c9aad9ca7fda3ae6b414cc80746a41e6515d4cc7e412ccb1e02e16e5f015e3c790950fdeda1e89f4c8063f1c213d762d8d528f7f32c2eb2a21029d328346ad8bee54b9f1bfae8b13e418544399dd00e805406ffb3bb1598eb532abcebf1910e310a7b2302ab39b14b55720cf00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
