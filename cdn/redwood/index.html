<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5603765ee21f3e43612d2d455bac3b05d50d7328def15af52cc2503b272d0b8c3e8e64adffc0ab5caebdff543119d039218a2a3719db92c3d815cbf4397abce5fbf8e2755821d7df8e3cc28060c1e2ffb39d87001cd448c88f22e9f885afbe219a6f4dec0d296d5f6525b4261719c68237ecd343a285093b59d79ad5e760c3dacb186ae15c58566b477524b4d467d84d3e304946ff36b897cb7942d2abe148f1ded2b2efd5ba415996782f7cd8e886400b73f1b6375b4a9b358e20136a14ebc53fac0d486c62296819f8eca5187e55567a17d10e577d66c88a0cb84ba9762906cfe9a6dbd85a2cd9b3dca8ecff476f4f49dd724e7029ad48e23f1c2b4b6530530f7d11c7b4828ef060355a9f82a313668a9f37afd1024efd5a12e1e98482f514207e235812b325f9a1d59ba521b6e321dd21881a0f3b69d9759245c4799c4d7b0418e3bdec5d3f4722934bc1f0ca624510bd904fa50500d013f19eaddc7342022b469d2fa5fed61b85d38220cb424b1b80e4dac648e187bbd3d97465ec8b8cec89e447c9a2bada3727ffb14d321a66dddc640a5d152a794084e1f1b241ab66f4a59af92e13c0421aff360b6996effe72c56c27670dd30c840114ea898128a102676cdadcbc48e1851c1661da5dd314e8332efd20998cc7bbb32b2ca722f4b197f00c8bdb4287be88d5c6b5517c1c83ba0f950bd981b39b734bef81da8fc300ac0d464fd776225ada9c5d78a66b1acb5315f4c3567a76390167578f63776e8dae065fd8913665204458618f59e8547fedf1dd04ada64d28ac289d8d25d7f3f6595c01bc81061bf993e5f69748b3361aeaae7a21973e9066c1c734832c8465b7b482744762be1495a8517103c0815cd4372142339137d833845076ce71a6e238691a7c6cedc31baab303daef81c8c0d983ba57becb7c8014f3bd8c9907ecbd2f0fe4be6ae9ec7fd460743c3dd6cb1146a82377e6ebc6d694e8040dd2e5e9fcae76532ff352b939e36d3bb8f673b00e5247376e04bdebc855d7d32cb427489224f7b798d7f2198697b2679d67835122744a782a4e792cb0ae317b895a34c809595fc6158afc9e879259ac77761927671161f6dd1f8973d5ec491ee50b4584713e309fa1b1d9278bfec1e98fa57ff0b151a15efb6ce5b5044abc3f9af890e79faa019bfcb950c110f1e0458cd67bf1b7af4ba4eac68dfc6c8b83ece8b9a5861b0d210aa2ccd8f760a0ee6709bfd372808276a73f5626861c234e26471270622b1a9e337f94b86e455699e1cf719e2ac5cb9be9dfc7aa264badfddcf10b0e5d33be6e25c20d4172e8703f26de0e92f8620f1d8ad441dcebbd78ca8a2602e2eb9d67132505936a5607a9235398c8dde6a105b077344836b2e8ba7aa5685dc2c7de6195f0dfa784999792d304c8ab845da7304ef54ecc4a490709dc92fda658588653b84465de7f4c71e24b02ddffc29f04b66908bb24acda19d163b1d86c02eb2e7374c6cee83db856f297e359f1dc5fc2ebb135af14c1d5ff7283aae401e58381444417910acfc03ec8b06899cc72799f602d2a92ba29eb2652387b5d2b5b821aad33d2356d742d8f8fe1442cfb2483f38773b24e52069a408ba8fc8a6eb21248630f2157e3cb3e26a31247a481ee97d34e5d0c2df4327de29be8f35a24d5f552219b9bb928c2319c47fa824970bf0ab0cf845d603e46b02cbbf0cffff67acf56ac233f57c99f345c5647a02afa412b8473ebfe4c96bd44fc4fe5cdbf859507a7650d18f206a8143010fa8d0821cc4680b46204fb8e655a473c1dce00ea3f692de5d709ce6a366dd9fc3b4120d65e70181095e22de82f9273ee0fb789c80e46bbe0bcc2fe940b826c58abfaf7587c036ebb32723546829a75f0c0ddd634fa5542a9fbf2a3655a4a83204b23c42cd746fbbcfbd3019055a3f236d2184d5429bb465bbb285782ad669aa332da7714994d9edc39e2312b9474cccfc58623d7724150219ce9029a34ee326bd06d8629360f5ada781c0d183e2367d1f99ae612e1c6e1d0f8011f52031de44de8a4e714dae8d1596f780571c5e115671bba3fb52192323ffae3573d242bc054496e73ca308d3b546be0d3a9339a03079a063b0df440c5fa0109bb6cc331dd2f2451003395b262c9d3a72632b1267c0ba5e858d54a5c6024b99a0e542fb5500e2243fa70a0acd78af7c4cf8c73fa520b442bff87a1c788913df062b78378cb845d462e63893fdbb14feeffdf78def85cadb0def20b50bcc3779f87460adae17224b8cbb7ca4fa71fa29a8661ece3efaaaff5b57c9e81c0af5297b5057b24c28ca7e4d56c9aa4aad6400b35320ba5f6c5aa4156a2c02c3ba70c92be03cb30c2767b5db101a148957142767e660d6d597148a9777ba920c806ca598a9d1e56e773ad11b434e49f83391585ccafbb7dd3222098c3197c5797c92f279c2659d3cb05ab7ca543e7e348fb790ea0b0c190876635a9f235df5a3cf6c8056d88591360f210c752996255f49995a7ce777e7634ab94ebc5f6ec24625d41502f3437e1964676e3362a09b63e89e25356a0c68bbeaca999adcd4b3e359b9353a7512372970fa19576d6260f77773580b5046ceeb946327362e2d9e77f3246f4d4adbbfd56953e65d9a6e33bfa99db7717c567d58aa9b313828bc7d5065f42d239089ddbc6c48ecadbf39931ab5026a68e589efe6b7aca41069eff92ce8436d5b1fbc834310f47c17b5eca5811402cc9a94e439c76434a041b495d03980d22579e0942d3ada935daff82651c71632fadd4c48458f1a44e6e1b55cba156b65c4ed8c81b98d9ba4a6e8ace7a0ae219e7fef023e771a90d5f8b914a56a24fe2df09fdb56a67fd31dd2cc3a5e76882f620dc166e20f581ff0e878a7aace1c56ee5294872e4c0af883f40fea210d6cb2977316f7f97330eeda5cacf70bb479bdbba88b3a8e292f9e5fe683d71a7fad1736f2f41d37fb0dc65cd65baaec22757ecab0bfa1e582970a37aa58a80918958397a3ff72d870bcd398ecbad1ac2c163cf08de61f90b6e3f42fa13178a3116c3d6559f5fad6bd9838b13ec528b54a4984993b7d60e7125685ec8820f9a267d45cd1a253fe6a67071187ac2f17b2690b8a20d36bb4b42cfbb0e6c7d67706bfaa7f633efafba2b48309fc3a0dfd1bf2c2c455a5bbf2113989726dbd2e3da60e13e6379abf40a0a6cda01c038c33d64c64633ca23534c105776bc2d05adce0bf8f1e17cb8083c918cb8e39f30e8d5f03d76caefe4437619bedb8b6a7662feb610c3d3f2e822760971413b1830693b9d38cb5c9b8a1b28e21f42c45e571d1db0c914dacb3d2a766eb2d0a5c9bc9f1e49b1c055dd410d5f36eb4c68ffaee4f2b849d9ae61b9de0366c21a472a1f7c57f53226c9d05efb94bfe2024572b8864e441c65b5c8a6f6c53c87e03927586e2ac98ab8f162c4ea0c8883548d65c28b0772dce9cb7c259890d598a80aa446daafe923d479f2c51a95f70c42ee1b04151346179ee93a2ed8ae864a870d2fe9d981af476ceaeb3126467d17594273a0050a8805f419dc3f7686ad763321b7caa85443d42432f407c3a1f8a956629fe0d5ad56790e199c7b46a4eb0eae46887fa7dcf0903154e4ae44c077fe2ba82b93270866ba90a931fe93886298848f660f9017c28c0d9b0b99077c74288b58d8f6c11a079f23b5b7fa7614513a2d7a9e05317cd6e61b34d2e2b34397c6ab5ee52f3f47b9b8268a61c7dd6b08c59b45d554bc10193bb24ea3017598f9dc57a772462ef397bcd4475cea747a02fda42aa7abeea696f7f2d3af85a3331ac8ef24a48cd0748de1250905bfed6005bb2248f043ed025970260785da6bca40b7b469b1ccb8ca46568e53d517b91672bb160d707083412f23e76186abdbe8768f92c550bfca5214f76de14232c321afaf2b4f5d4617e3335a13a78bd09a9dc316cd03b6ce5e1dda35fea02d4e6a0fd8ad796d97e4c5cd80f04b5db737a61951364d8304ec47eb3aa2f54375b0af9408830aeef65df9cbda7d2b5201453471aa147574a7f98b4ef0b2c8c594fc763bbc22a845eee9b367e7c08da482590086e5b07fb7c54e87271a131f45e7f5815061a196a8b48fa450b0f0e641e0a109c4faca9bef9bdef5b2bfa4f2e63fba5245a25dac545b8e7e2180205258f973cdbe13abc053faa1d6e131adafb106a0502fbed0dd6371db753efa56ef640e746a8be90e51e7796aa44c3a2ad90e99fd042a67382976214972847ddfd458d072413a5df05b0bfaef134de6dc71ca62fbf929ad3bd7b0b044e6ef481ae9233abb81e5dec2d34b2733df956b750a50dc108d3ddeecd1bcd9ce45dace9675efba1ffa38e842e4d1285a72a9bb7e19dba25562de2699222f1b760a8683df0e118c867e721b6a2b9e0bf0818ea0c5df2ac1762a946f1f5e0f5eeefa6c937eaf058387a90d9140ca8a2475250c9ce78ec594a5e4066d6d26b5966b1a4dd10351abd114dac2996fae260a836aade4190c184eb7e9b7c81d3e441b2679e92eb1f96dbd2be2da7cc96fce7a12be85d59551ab120a0da93ab9ae2f79fec7a89055a802d9021cbc4a38ee7473c7ef3e618fb862ac03d4cabcc12a8c8b8b17019cb104ede7b12ba387fdc79da2aff7239ed0f0ec3fc8ec1bb3d90dc25f3a3b3445848c083ad42b599a636adcfb9bcea5d1e5254fd2dab943918e423d901dc1001756de4afe5a2a68eb815592d8b28fe06f975539b2fff58f46a48d24ef42ba3d63bca6f46a03d6d32b6064306fbf43fe6e5152a3bba78d45661eb522187e52f28ab9d976040baa904b5d01b3e108e5f07fdb6bd00fe85a93fbb4440662258d2f602e13d82cc8ecbd7f778788c065326548c922c50ec96f66b204fd2784216263f338ed08ffebbc46ee94fe12da60e925e0a660e74b39e6f5f0db95887bfb1f289493ec42937945770e021225e3ae2bf11a49567495aadda63eb55c8fba565070988f96ae9f40f6bb7668e90d5a75545f4bfa961d779a4b4594f1da129f621b0cb7853e7e247b6646c50e00d1b16679707272841a57ca692db69656fc9ae344cff83144ddc90d85a19ffab126cda054fcff80a9e169245f7ffec7c4e260a6abb5b3c39b7add709e75b9e6998da7a40bc7987803840e33611a2d62a6161e59e31edc5eb9b432ae60460a3b4ab1706ec44200bcfdd93ed0d300a33e4f09282086e047cabf5b671cc5b36fd70af210b287ba1c64d8b2b7e75b318206237a27274c09aab8eb26a96f43cbba5de6622117ebe04fd84aec2ea4c6bff011ac67b05c5b070e48d7cbbce65fa9b41c1d6dda904d6194b51c852cd122cc5b7b7145c4a31f08f00e01ca1ffe7e7e468892005d42f88467bb80061c841170fe6c15a050012458188e465a965e58396be2c3eb7443f7713f215b2275ec2c82d0c89795180fbf3585968f98f5500a6066ddee02b1e541e426f33b48f1266b58a46b75fd26cc82bc6550f7251ef1addd55fdc246d7965d94985c9714e3f58f0c04e35b6e773167a197877b471401af3949daabfe3d231a32f3f23e7b8daf2f978638b5c1bccac34e5111e40c8c0de1c1886f9b163aa2f0b3fce26cd35b3bff053e0ce841828d5e33e4f9652444880a5aed9a96a101167a19a33337f1f90b1909f41998e9b2afefa7a43824ef99f157d5ce2bcb400bfa2773af9b66b59e784cd216ed518fb5c9bcac71e86ef799e7d6c0df8fe4f18e4f59235c99b460e475d7908387bad1e4859bf5c3e6d912e5bc400d967b34012d91591088c83156cdfd322088c0fdb51eee37d09864654d17c2fd93e70273ac3cc50491b30046a11e969ad8686e7056f0a103abdb93e3c839492c316aa463782f1ed73be9ff1782386b5296893c3e72535b8e76861158234b95dbe73cf7bbfde0f2c6fffaae7c4404cee4dc6b304930c2ab3a77e956580b329b34617d779436273a4c7d9d28d2e2e120e73be073951fef0d3c82abda7a5ae24aa61d366268aeba7bfd1add58f901ff36eeb518e284c0fe45d25124c6c62fc4237d9800b2bdb1f19b847c2206a1cd5f931fd654a910fd9493eb71b451806c1f9273f19fa09c055cc6406325cf2d15658e58a29fdca54be835da37235b5af86e5ce551d9f402d41bb5b1b9449a3b78ea310a8487992b06748492999a1b14b414ddc491d2ba8b1e2a3a9529d56ac0130042d2a205e332bc896193e999870b12f4dea923c9c99812c3cadca1aeb37666cc07db6366be2e83fe88d84102650b1f1f10f7d6c6d65f25f9ed6cc3367a9044a6e6c33b22d50a8f29e20196063ef5d8da82db6a6f58197ee12348bc5587983c1ab0b2cd81aef3b174bc37cce0e4b2d079fb44fa18a11ee717c0dd179c363bb51ec46ff1548faf90b3a3735cccf711b99c8f950a8d05e70484e159c36726e36c8b8a57bf6467a44d3af9543eb6785b8abd5210d66fd63f8e6487a03c97a78fc2a7e0d4274f995ed9b358087b320e297ba6c2384a64338a94c5ee7949bc88c7981da379ebee81a893189aa412b921999a6773e6897cde5f4673c98671af1a60a7b8797c3255bf0e0a4f6ef5062228cf96ac0845b9456b14028efa54d81232e42c8423af192cd5383c109309f3633742cb8d8198c0021cc698e4732e2b40ce36d94d06bcf84a339c5d8c8af38442fb0cbcc49b9505b25baaf03cdafffad1b1cfeb1c5db174b549649f6b9c872186b5e0a2e1640fb375058bb2e9aca20263bc0a64f74f22cc02c9a2345adee9ca34ce9bbe40716a86e4a802499523f3e17d10c64c40672fb2b6b0a2c7a9ae11d2defe2cf3475be5302137ca1eecab3bf8574b8ffba1f9a5ebccd5294093e0c12dbd48cd4c497ea285d0132b826b4e62d00d5c1957321b9ebcc8cf97b58f5bbf9aa2697de667b473c3f892c226569307c7b4be555814b396aec5ec4ba2198b29793c96f8bb3e73fe5c552d69fc21c718d34a8edc0d032a79f8546e8515e06a1188532c5338f82c2d67adccbaf2d5c2e9bcaeb73233a4e95ea26b771246efc763eefd145a005f4caa210ff9a561f9a4b8ceff0535f499ef657433519424a9936b6c6ece6dec4aeb19eaa21cf63e1466ee13cf1522a2916d44d3630d07f5d12bda2dcfe4589f841e2aba57b312695fc72503db50d3e5cabca5353fc11eba7dc73b62ff03eee4aa034b33d15a683b8be7b36d0405b9139db08d809fd7c313138da137731d8055f67b4ec1529e00f35cb7820868771afbfea60606eed782c36905e54a56e34566d236e4847c49a14fefb093967194eb5c5bfaa24bf2f23d5d902199e67243cf8d8db88e825f20523e28c59637bf0a2efe69773d0443784f0a7157542942a9e9542559d063dccc77e049583e41bfbe64edf9a7df6fb15d594ea6d76d5204d008fd72e1db76cf2c17c090900a84cdbbfe2bb59c31bd376ebaa76b478cc94a1b0045b3c251aeb804f3c615684ed1fd46491602c4b39060fc642ebbc323de5a3867666c2cac2d182e65e97653b0ee7f106947da7a77ccaad02dc4a6959db609df58cb849851e8a796a28eb38a24fd636fca6d3367b4b712c9b90cc267c3e31b00821439000f0e7cf169ef1800a82f69c9a423d1ac80832c4ce8bbda359fd22204c9fc00c141809a2666832b2a0e87ce55cce1a62a732f79692adde19f75cdd71e336f8f9abf3d430793854203a9b57456a6a959173d3b57121215a4cb0284ebf589c722fad3a1c96a7a757954bc52abc3db705588d3a866f5a0eaf5ba493b9eb32524407a60b89c4e45994a1c2bd93cbb32b68073731e4cbeee19f71dd4dc30cd74df33cb4b271a688042ce514c0408c9bd0b8e6448b879090358a8b918c1e193c209ce8b397ac27da32b2d6e88c72dd1e713cc5d5a2fd43a243b9da2d436b5beb63de6485805800dde777cc4e70010d99b45bec518e9c1644bd07179aa09fdfd4aa1e48fd18976040db014d86ee9eda6fdcf4e33ff77bd565befd8c68b188adc53329bfca0a01f87108e3ba9ed7bd96046caeb160cabb4ff52d3f6eb615c8eb57310abda00fdb2b8ce6fb0a6b547910e313f090432457a98e906da9d6fd9831557a71a326dcd27241630a03135a4f43dbab06b81f94351f0bfba98933e0e4a94e57493ad25c9d950720180105c78c1d697e821de6c39622db52a0defdeadcc964544bff4ea2bbae0cfe1bdfb8ac0bd6f4c6263d0b7276e3c14db672d4c77c06837ccd93f6c23d8db736a2cdd5a09f2dda45c39a97ccf820c54d8cf117d9dcdcb48479e785e80382e95d90df74f49348b0d1863c04ef703d957a7fb3ea20e20a9ee642d581836954d8e66455b9cf93f06d73845547705c0a93aa5dd90f2477c470e325cd647deca16b851f8dad436e787da3e0772eca0f5a012bb7adc19bde92d6e2aa252e392fd36ce6a118270f5d8a664571fdf2ecc1a6ea15af89a270906814332c9a562ffa7289127718ffdc4c2d388faeb4c2e5030b059071a02120c314a48179710a80afc99b0b27aa49dce51b7df64a1d484dc8ba262cee14d10eb1bb1245811cbe12e52bdbea8645ebbaec221716e54da4bca3e9d9a97fed60bec9cd92a756c25aba68bd35ee99621bc2105443c135099a5091d1cebbe200b816b195ecd5a30242054dfd589a6d557dc714e3836bbdc4ebec8f0a19f57e06d3a100c367a3bb6a6f4dff22d8c0f5540b8cb869407ca9967cc7355328381118f41cfad5db1523727cf029a38968b565b9302a949bc70220d50226256033385b159903b6699be4fea56e864710dd56edd32a8ae531dcda4451da952a8d5eb6cae59b85ea1ecf283ef54db9d0ecb412ebde6770c0e93e02369c6b7057ff19c3d6b9daf87f603018db9d7c5b230d3b266698834922b953c47c338d76410784a8559256e5bffd1c9acca8e08f1f72c5c0b7e9baec0b7d193b3bfa2789032d367c340504290a8a2bf0af9c95b13dffea0eb8a191811e07ec757080aa9661b8ca2b00af88dca423f0f95d7466c6510a18fbd77fc5d0a417b1968650e92630af2a69247e7a9774222ab600dbf1f3a0ebf3dfc3b49bd82f01d0ddf37c6c62f86d2f44350bd1640208c055457820d3bd464f5634cc99ba446221cbef9e3b240b65d920a1b7f7a5ebbfebbd630b4f4c9031e1f1b1e718501256be14f97cd9081e81625161d21929c6b094f68d0826a28ed3477c7e382b25fc979b76112de199b7e640e437972833eee28fca228d726efe7bb500442db16fb07e7153f1c74880db07709c52f950ae6016fdad06fbba52690081d8571346ca0e9d296ea6c9d68dadc750c87e1b460f72999371032f20c50168ef6dfae479a5cb4f8d027b9d99468e5f44cb8b56dcf8ca8a1579ffedf90fd75f982324bf87251131d75b89e33b6baf4d1cc89247584f3ce311ec817ad6938e13f79b0f94a4b9c439f8fcc5acbe49bbff856ed5e3420efdf1ac247636c0aed0380020dc84ac33add0e3788e772a42390d18d68045567f495790c65ec0479553de6c062e6566b3fb1975aadc0cbea5b00d25eb5cfa881e546c16e926429b347b5153a3a7df59a80f9f5459b05d41143379087b1e3b676635478ccdd6690760ddaf8002e4cbf7b45ef824c90c5024f14cfd4f6a200e3df76f8574ed9edd9cb4a8326a380472ae8c2700064865199be3c31a16b1de2bd19ad56710953c90b1453e31d4105914a5553b534eb4c734b8637d3969b33a6998914d1b721ff98bd373d4c5bf73f6a243b0c6b3514168b7a7985fcf812923fec1ff1761fa97d7e4fe1d20b45a9c9ad2da5550fc841b05bcc4e63593bda7202a5b4ebdcfd31345aee7844c84667656291f0048e0bf29d013633e7364a47298211ddd4263edbe46aa13d70252c4f85031929660db26a427fb4ccbfdee9582f145c0bff87b2c7d52c423615b6dd4de2e5a52afaa40a24401dd7fe33081a7f6c990305b8c169d266fdf7a693a5589f263ebab5c4a91446646c84f12922890c0b679a2be51830225f467b9ce575589b4b2216656fae589c75172234ecc4416e2dc4452bd73e13b7082bc73d17bc3583efa0dbe2a2e95cb877e6acca5bf7e98705f68458739d6d88f09b890f73743f7ab3308577e469cf8f283a0c17eb4f65946b7de8c0df7f16aa3b94461b45b6569ee321ced1c63a8fb1b5781090857d6cb02f5696347a82461a1cabf361237fe5d106abd9da2dfb11129ae4c024762a8394cb15675f7566eb33a55d42466a12179875cb63aab6f575bb6cd792c6a17054b9f3eadfd6a334b382764c2be0ef78e0088f4f8a0616d4b2ffe40567c5f6554db588db065c4af4506854537552d6d10fe5475dc2e7207e770edff3cc236cf0838d7a63efe6dc05c3f513bc614470f641228f339c7a2bdbd4f1c09b1d2b5bec6b38b477b4ea2a9c3d865c65bade7f37e386bf2c45b0c958bdd520783fc5d4c26bde254ab60a7105fea2f50ad2dc3769f861984220806bc11b1d6bf514f5a7dd4d40ad41e7fdd468d1a67375e855996740cf7227e5202cb16ec86780915c76e194e41b4392eef9833193b2ca0e679485a07490c3aeae1972ccbb611d3be2fcf254a58c960835ba356d813ae77d1576bf1af3ef32d2a88f8d6cf05c4bd89c2517c77558b671017fdcd9546ca894c9cd9978095acf2fa3dab426adeb2a860bce501ee6ef64f9d7e3b372d062ff7e3063184fa8684c5fd6386359d6f0880be5e816cd3a55ad62f39b6950f075efa94c5a9e0b6bd4f881629f88b0880e4385ef346073c91727f0e53d3138d95955b51ed70743b088b4422f4d58dcc5ae81998cb13d9b85f75dbafcbb2bd8388b89178d4091d6d48cc98502a97f33b868e3cf0b5322750a28730861808f24b2bf2457451df436b61f58b789e0d1d8eec13851fe42e605bd069d3bbfed22c4e0d9acb9640bab88279ab5ab9f3a17bfc00569f65f4bfbfe46f248727c347672e01c4bc9c9e0cdec0953aa153ee9222a65ed1627a32c051fa27f469567567cbfdae43ac729a949d8a6e7d295d1d729380ce7e4f2c7d52e8460940f0995fc31d042bc9423cd87909adf35160988184ac44723879deb9236be03c9a658a974fe3fa40b6de0405b20e1100203dce6436435391480fa7b6d5095fd8ef4a860fb3cb04512ec2c3466f49f357351ef6daa41d06ca5fe45ee484960aae659d6a18dbd8d11eaa660c131cc6b14a5af26df678372b5c574483797cec3837eb400a88819bc5d8743e65ad4e16440b64d44da76d6d94ace0c5c111b66278b5d26887225b2069ebebe4b479ba2c3875c329c49cced08682672b896b297986604a556d9d55d5eb60bee61e2f305614bdbb40f135504a9338a4d7811f4d36d564a2847ec25175661a8f870e35b4bf75942c99d67384d7523eadd9d55cd07315554501292ab19d63eef3872bf0ab7c48e2d788616e298a0d7b81521603220febf68b526655c317ff9c48d5bc8d9d0c72a2e392e9090050542002a0f7bc6848802f81934e561bbbdfb3638ee691e74c77be40a701bca2efd56a6f898c7225a1335a506962c4e7eed5834e93a883d249b70b932009be19bfa189ad488514c38ec32596e344a5c31cbffc6b16bad97e5f7fe5c1b4443879f777e0abfae6418562fd3343e4e1d9ad2542d3fd454ee6298aab34ab65362d2c1642e5132edb5b12f7c5de9fabbc17e6493b4c2b29398f2ada5fd6673f5f3af86c0bf12aea4e2350da1b3d8aa6b1d0ac1b6a475589265cd0c7ddc57f8b3c63f57a56d92f82e62111bd2d48c4f39200522c35708bd94cf5853989cf9170897d2de67e317658bdb953f0c5a291561e7806550759917ffef55571a2023b940eee5b8c752bff7aaf03aa67a8ad882456a7e3eab8def71bc4932ea49821f815633377af5b4ee2ec1629be4b44b38a26b4ea1b912bdeab026a5d6072929a8479c320d1fff6b45d5b740b2ad9917392ee99c06900e37225a8a111263f18109dcf78ededad0d103225045e9a3b67ff91a56a8d3c6f3c439a0d31e503705e1f6cda74e2926b6187f96cec6dd815b1b4f1f99f41d478efff01f5a6ee62ce6e1037fc4fe38a3f4f7dbf474e600c472732f7214a5eff9d30cf61d2741a2a8234c70fc2dbf4f41981d91a9852f3f9b301e01f8f0ee057f278ffcc56154dde5f4cd6250e93d552d7736d67b26f28501633a5a445120c715df085cdd5242ec10cd2cde771948b37eade9978b4c6896d4e8ce352f1ec8fe115b36b4800a2e0f4009e01f2191c6460fcda28b74976b2ecc79b7fbadc11d75d7746b3635f49402aea3eee9a8a45347fe4be60fa5fae4196a3b39ec33b9b9eed6beb2043c8fcb9aa6219052abfd493545d26c546d879d336d29223042ab178273f77e2694f64ec19d83e9a65a4bde01f8aa666d740032fcfd7b59dc36b58520d27db16c5bc6cb127371d0797c98cae92ab90f17394f3c4edfab277cf0aa3fd12257b3f6698c85e0157d837275622575eaa9d40d23da9649d28d268eb4af5da3cb7e3261d58f319c291550963de6da7f0e3d51f5cdecd70b438134dab214a86612e8e4d9444363fe75cf6410cf5b7aedfb07c494327a86609c7e185b024f99924bb07748a52da42189c4c953d2e734579d629c65fc11097a62b4da65f1c9e7d7c9f653166498df6108d02bd244487c7264edd7b83acf93b863b029aa6381ab194ee8fed20b6c0ba72dfd07bc756d827ac8a649e00776a4af871ef3053cc8668725f109163376bc70df722c353832803e21d131726e1b96b79c66742968219f42e820b67613bdd02cd9072624d080e01e47972502270bc9b4f70aecf1ee7850c94a430ab656127b23769933f6853f18c5d8b06459207a5c5a3e208ea5e09e5337026c82bffd878b201d147c1c321f0ce4bf592b47e8017d3ed35f847b0f365a924f7850d13e44996ddaa47b4fb433cd4edbd7975532fdf36f1dc0c881225bccdf43d7990354b8b32db035d44add78607a44158f31f387736728f026a5546fc28679b8c11f6d47931186942cb524442776fc7592d1b056b5698ff0f059d385b6ed5d0adfdaa2fe98688f366df989dcdff72438c720ab0c10b44ab9ad8d69d1b55c9d6dbe9f95b20fbacf5d947dccb70650cee3406bcd8b116f98505fa147b8ad13500664453e8cd9ec9becc396c32d01034892692c7f174517f2c864073a36aaf2595915a8b134718078ca9f6c89ccfa29ce35193e9b368a2a540fcf0d6ac0ee1d74a75c336b74cde93c5b438418831a12357ab0cd534457e88d47609b57c38be93a65c2a513d2fd042f9162f27a581a45ed1cceaf0cdc098024d703219addf06cbe32840b9b130f62e220c7db80eedf6e893342f7d4aa90be6bacd4d33636150fbe46ec2fd4f94ea58f058f7f2d6491d990ceb97f83953840adff43e0013e92911a593e6f4e4add49ae2ed76dc07cf83bb3bd73c00a13d7a36daef7d4e15763fa6c82b49c3d6c449c4ea55e556efbd06783fe3f06f69646b06f10495c03add8afedb02ed5f6c9d629c830eaa585eded3dd1503489129f377505ff89a444a943d605ade9406990558ff2661a6622c6a45cfacdedd07556dbb3100123b60df9ab4e056fab7e39299184a1c73e33cdbd14715ed7ce5fc2107ceebd0c0cc8e8856eed3262f75b881ee5b1c8c6d9bf1fdfb586e68470d43e74919db160ae8c9ef110deb9003c4b49f2bd51eaafeda8f96240338d909b7d01a85e4e59f5c7809f5a974e6ffc6519808223d0c089e876b9d823243533526b1fbbe8989d04ddd3f04ee08a9b6db1dbbfa3cb4eded23155e4fa87ba21e21acf4647880c22be758db1e65d40230041f5cd2ad3a5358fa31ae555f291e1f76f1a7def661d1ee480f9ef6a43d56b8e310e9c29b5b813cc866705632d28a33feadddb0d66d379a73017e7d855a5abee0b6498d43f6929e2cb77d6ed3b88fc907a20bf872028e9be2fc81548fd9048898c337024bdb0d6631cd20f374684ecf3b66dcb28d59bd6d5822b005a2abcbe55da3b6abfc5930d6a44f908143d75dea01fb4727b3216032af23bc4a1b35738a177f67b05fb0a3e931ae4508adee0bf3364823176b3ec77ea8e326ccd5054ce208cce6c632107667989b6106021815632763ce9e4f075eaaddc57cfc09fd01abce40f38b3268ea33af5ca75a814e91c9cc06f3f7d4145a90f0b9e7ac6c3e8d6aba0876f45d1693f62ec68378bdbe260c973e8ea8d86b18e5031491852cf1ffe212b5a3ae1ad8d6ae70bcb71eb6d136530ba461b5934de92fe4c3bfe1e1ad5f61fe74c0f5be214806aefe1bf56227b9db3e0397bef525863982555ee7b9e91a88904830f421c2227c956b269db78e5a2051c81738f7ac2093b6c4ccacb20861d1f5118595f370a9eb95fb0c4dde303dcc69cafc09e8fb27a22b90617d35d3b08f4790b58145ab824e5b736b2b3a96df36dd2390f1197dda6ae1b82ba048a02b29bdd8b273056b4707589534b9c2c2366b1968ea053476ff0e61bf3a4c0c0a872584f966f2645c53f77f8a6318b0c6e3f49e62d1f1decb2325762269751bd404573aa8619f775023b0a75ae78cbf68e923a6a86113ec8d0d7e84b4e6e839008f9e6aa458d4312ddb71750fbcf2e1bbe5e5848616fbe9ab6bb629377b9ebb4319d4612d873599306a544958ddb0f12f1eb0d20bfcc79f6f7105fab6b581bdd917726a73704514fbe19377aafb00768286866240110215f9cd46fb337721c0ca3974f2766e7f069c13fb6e24d7da1f2b033bbd692322f7d3fa3400404c71a4d342d66e1466ae7a338c9309e2e7d6a1e0f0f2ed64f53983049620fe5db5e45ae6fdf277579ba08c3c89006390005b55d32787bf893ae50bce2f2e7761342c2cbb602fc039bb10a696a49fdc5676737f590f317ac5cdd3a7f07f49d7406843d6a1cd44ecb5649e8c48c08148d6f3ff5f160dfcb50411809d51b3ee42f2651d89df765e7aa3af44784d2b1e552019e72356bfc18cf967f9c9b8188ecb5ae8619fafac725e3fd31663d905552f6693db07c3b0b841af3fdeac7c8d6ca78612c5c680452bd1687cb1a78f4472657a60e1863ad78944b0793e25a3c6afc9c1388f7f087b77a2bf6993acb37445be1310bbbb5f02afb5fb359ea3899753afcce0b9a19732d822969825f3b4f814308af2f55cfdd8f373cbfeb6037d5946e5720e28058e41b43f70d3bab120a403f1bb030769fcd03be3f7b7c28b12607a8209b9482c9060f8ed92f6448895a9407ff782cad61df4d829a8010eda060d86c8a0959c80f31676ca49d212902a4e8ec19726f92242f48620802d28c3cda936b7b694c438e34fb9ffc9c13a9fbe1b49e6073b330d96a3babbd419999cb601550656d0358a1e3c603c1d5e48ebaab4c29dbf5e361bfda351d82f426ae6602ccbbeda718f3f3e030ea056773a5a5e3b4e6e6092abfcadeed19e557caa6a4fc362598a036f7c26a9e827f4c92ce38be0e8f1d80938ed213c63e5bf91926cdcfae9069186b4ae6a75b5cf904d9c54866ff2f8b90fda26b1df4a3236d0e90c03e5b5398ea44a1b66ba525c1b5ae744335abb2d63aee1404a63b0eae15f1527af5c82efb3cf6ba2b05bb77e9b37def0eef0b80bbfb5c3199381032602711764a067d66078de7b7bbd42f9963998bdc324f4b274ef934490b1dbae9d013a31687bfc87bf2982c7ccafde6374022d10489d9449c2aeafe2703c7ab4727ead64fa2b7f95e95b464860319d3e28cf59510c523cc0eb6655da02faf91e8ce3244aeb18c9342083058b1e7293d151d16ee1161ffd08ba5d829fa089b58bd1bdbd0e9135ef2f3017474e4b1575a4e66865bc3a02b3f4fda93cab8b03acd13dbb084ca57371c827f4fcaa873731516eb20193675581bafe6afa9e15a6cadc5f2de531a3724fbf25e4cd93cf19a1b4abc81eb17ee208969ea9ff0a723f736e683cf3c01fd3ed5f2bd588703726635e0ab10a91edf48fafbc4a0c97c68b51312853e26ee1896010f90d263120a7882e052b3cda6f9e885141984eca7d1d52dc56e310f917848cb795315840f91a4e31e72e77eca98ef4d73ecc65a036d770f59ff5b7e5a96da068f06ccb3da715195d1cd92b29d65a1e0ce5ea54cb640385175797fef2b327b272e89781837bd930a27318176513a68057a040fac3a750eb9bf43d85fe55ab68ce1b3eafb6e1b1a182ae694a6b24b36b77dcd9753ae1a12910029885d477211ca85ba69c80d46660dbe3160112796032882d334a2c1fd128d2e1e5396c3ccea2cc86ff4d6b006fcaea800c7bd2f73d84c8ed9e7930df040b0544dff929f766cfefbe54a3e0605bc19ccc344579598a44b7fa7f9a4f2d34e674adc5f9d7fd8699aa293bc97e8f86426d58fd48f2e600d2c0de715fba672c3a8f220ee700b3f53284c13ae77cdc73a3309c83eed78dbbb0377e3acf5bad3194fd5b975598919a0642e86745f1a1d72e150c18fa0b2a1e2cd3b6a1616d4b4bc924b1a8844be76b5e80cc22390ee244450f147cb8e5201c68f66a20162cddb4ac9bb97421ef520a1c7101e8a4850dab1154cc2ab9895541cb8a4966f6e194e6efa25ac134d60ad934187edbe216b1a8c2f6f7af6199c6c62ac6bd7c4b00efdc843410ef7b3c5752fb3ef1f73f0ed1e3237a4100601bfd687a898cc084ab65aa8f1edceea4c8560ff1bf1bd039930012ae82d02054cf50301bb47492a12adcc5f495ae0a147bf1a721d2b1cde4ed7723c492768291d49a067176f5702a8920acdb042782b785177374f6a1ee79c8d2773b73b9a5a903c425467bc98a6662b0798cf0cf2dd5bbfc10776cd685e06fbc0c1db18fcb020ede340d3b28ceda649909ef12c9e384f99e2026cda252ea24f2c95e745fffe985364138f47e6629781fa31a273c5ebe9c443140a0d3bdf564a086ca1391f9cc5c4462e00b43e654ac27bea79286f58e4a17e3ceef91b0a5ff4d21f6fb02feaa62f6b9e4de1f7fba882e68d0d3e3766373aa2096556046acd7ed905a6d88e19459b00c1c4024b71218952392465cddedb650762393c20d8e969472b7158d00e62dc4b65d68df04c4df9727a49efe3a4f7a139c7074f9517a287f6e84671e1ad7e2e067395aeb57099b6d60819d1185e89d524514077c9ca819f3554fd6a85976cdb11baeef99aaa1d750b475fdccbda71128e1b4e726694f55d6b2991d513b2b953d11e4c349b3779922b475a3ae980363bf252b78f2b063f3ffdf79091e54eab4778a04d3070d5d4efd84ab2ea710d4ad01f3db5f40ecefcd00202ba586ba37c5d09234d416d54328016126b3977d6629d57d41b1d0bc1427e516585b80f665682babee0a05293134ccb84c9a4d46f1abff79997684017cafb66e0ab2973c19ef772c8e71ac437705f6e6e3862c7e7b99200b94e3ce519e5937798cc3d39cd55995c2eac61870fab2d9b25bac9bf77000b0f8c0135543e50332b2bab1b37d61e8acf5ab271ff4663acae104cce9d364070125dcddb1dfc0e6cc0a78324a60c562f4ac7b7ee93a19c22389c12d440af9522f4846f4d21f9496293762c72126b18dabc88ea439fc5194c73f42f369e302d11fff6e82e7b01d994e1765ece97cc4eb88469c0e88e0a0cdf1264728061d4c780e60ed46a897471280472e10e3010f2c54bd7ca2b470652618d01f5a72d97a31a77bbcd31d418409690df19da620d88ac5012db773fb68edbc3f1728f71895b1c34ad6f5f2e7d34ad22407d1466f73e970f5d9713330f7f27602fcae9b23bfa3ef889bad47e68a912219450334d4e1f0341e3c7c0d34296dce16bccfc8d688636959ceaf28c570003dabd58da88102d22b017c4529d06dd7f48357b938f96056e1d8ae6f7a71c719879132d051723e267b9f4614e20361d444cf6870dc1e1763e44acbdd57fcff6e64820e9fa31666f1c87c348ca903c4917fbf83ced9548ef9970e07a07c44dbc84a62ba3a7587a9530f680867d35b1f53d4f99b364b3e68359658d97c3f949625577698991b0811fa18eb1252627f48032653d5d316d80f1fd0aa14b6d084c06bcdbc59453147072ab439c5f7a871eb7246c6162077a52796db4d3ffec6f152b0057a04c081029","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
