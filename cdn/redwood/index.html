<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5aded6c0840f7f268813600f39bc97bac5d636ead751f626a8bed952dd547b7181eaaf3d5e613bb938938b7eda786ee0c404ebba752d63281a8dffc3db6e49219bff602f2a9b2abc8bfecdf6e78c9ca11bdc001258647883fa317b38e47f749f806dfd71375a1ac329978186d3a09ee617656be09f2c8449c00fee8b132ffbe62a20f3a4563f34e9b3d95a3724d4d91e797b13c4c92ccbc4ab8334f612fbf6cc0ec547d055f7653509e6452d37e230b5f3080dc483826fc502dbf93222ead8482bc128c2f9efc21c99668fc80b5a4a4a83ebf67949e388a75300253c1d37b73f45f91faf1360ef2cf50798c8ecc46868ae6aab0352b3051138d64024b5d12685dfe4c5dacf6c2bb7968c5aa887bb5dab40bf055a60d44b9cfba7e7955ccba1925a80a6b18fdb4b0ac86c8a487e4d077d970abaedff701cf3f123710396c4d3c540d282c2ebceecb07485b9bddd7f198481d19302d58c67026cc30fa828ce9f7fd7e60c87e6de834e1962aa5dfc81bbd01820a689426d482fdf6ddcf94549608515c7073542e3c299613dc1ba429240200247f4ad186d4fcfafabc255267b504784a709cdc3bd0d3aaf67552b613667ea4571bea6f3ce28b3650623767abe13cfbe6b1d789e75d85f7e8c9c8aa863911216623d1cece7d7e0cfea5005ee930ec1db001385d76143d630f34f57d6edc6129041df7788ba7eb56696c0ceecfc3ad403ac17d1296c99ffbe5388244946833667d973bf6e0e82223a0ee9af1dbf5d6678f362abfc7c9fa7039f2ef76e8f04335ce6fc31fd11f9c1e466ce9c6ac4e3cd232a5edaa46fd2d628e4d9d8400750e7ea394a4e86f44722cdf40963559f4879f174b1df3b7ab66de78f0c9ece8a113b603e9429865a43922e7972ef52a2d20bda844c5b838f59b87191effed7b1041988e0705436cb32e144f648b17f49bd9178981c4045d83c04f3bf67770ed30bd0aa832ff7d8b3e12cb3cf2bd7e9790585005067d766007bf1e0b92914d73431c470080aa208c8b716b5b83dc3e765a3f0ff2ebda2ad106f1371fabf3bdec6fc48db48875a1cd13e462ecf0a53de979246ddfb83d75db23c25ee0da89f5a2c7071ad2431d4385ad3bc534a0e94a960a41b2b78a0cd97bd5dc8ba1966b16774478a562fe23c68e0936ff98f1d99669fdbfded97b0584596c04e0dcd0111a56c76e17e582c375ca999c33eb996af71ec699c601f20c67ffa23ae716efcb944619b1d1ba17378c86278ddc21151bbad47de1c5f773fcb03a13d131683c7ab3769c414f841b6cb1cc3e505fc97c07f1aaae5f8287e73e5512f94a9ff8e3dc5fcb879be8bdd9d28c1520825f881e4a9fa526814c944f93b185ab33b8a185591fdd91e2c795b2e746230ab9c51191a11f2057dd90b4c4c4dbef585a8c1007d7823d41807466e76da7172a7832135dc709986b8718e5bd5f886041a63b5fff37017e1f94134b6a9679adbb2bface1f1355383c6c1e214799a7f65b3ba7e1801fd55725831a7a9bd6765f63b189b8dd26f7c55617ffce1fb72a199147cbb9fcdb4a64c81f1c2b4638ebf1f83bf61c3e00c478d8144c5067f963caa8866133772b98f5c8ba1e4b5599ec6e6f0756232f1bde4ab3520dffabce5ec6fe662e8d460f81c7fb2a48571c5909d451d9492a0bb8aad4506671a427e25bb9724887d8572a27db230064af01c7bedd3af61f4e870fb18cfed49ec3d9ceddb3683070bc868070817cb56be83121e16b8760eb8d5450fd675b0c8873ae8e46ef471211398045f5a0ae7d34f4873982460c5c937482099c1ba2f04f7e323688bea9cddfaca28661559a7c4a1bd0b39be1eb630991c3181a6991ad7a8a98a4f1a586005a27cb63c60a3577a49db568fa509a118e292da5ca09fd36af6adca4b2dcec1d46220e1491f62b6a2d057a32f41492f2211b01da58a9065f3c2d29d0361d9536801fab9c065efc18836c9ae284d4018ca1e863938aad4a2835248c703f498254166371489c0cb8344e156317f6ac617d5c1cdf5df6c82b85f26e0f811e47cb720aee7c9b40b8cd35ba47eabf2c5b5d29b385c9a0dd50d118948f0190de326b10473bc622b315e241d83d6c69249036f613daeae7f3bb957ad4ec6528fa07f4df6022ecf75e9f317e9c28e66c9ee751b5f8d059210013d6d75ed40f8976408431f17505f37f66341a7d2cfc9258b27def9e4c6a3407ad55387c39e46d4bac528599c5a073fccad0a3dd13261c09dd0bb5b1aadac7915ed339752cdf140a9d1bddf0de262fff7edd3cabb70cf1f4b9a776dc7cacf8e76584aca84f64decca4c9200ed5940d64e402a25f550b5d903777623ccb937de99536645d446d65b3d25cf0d3e9429e2abf898c74c34d2eda767fb50b6196c2cf7ab8375654c2d81c1a104d3626f304424bdae96b105ac2df9e5894e2f601b2b6648644eccd3336071b2b41ac6ddab6730f305eb8f2b3335aff46de81bb2b19268c6c3e4aad7335ae678ed344e903a18033d519ae564b1546de7ce3889cd2adf1dc1d6376df17aa3c6e45d826549c94eb8f15a086fe0109e0b8e6c6f69174b2f6600a7c74b9b4c5947970e3a54a3c79425ae8314233c6eb09c375df51d5c8fa5d43122f61ee08e7f4ec99b1d9cc7781f3e26f63f8e0ec046a7173ee6b26c549cf293c8167a34dc35687811cb8502d79b7b1b9e35510ae54d34480f47756e7c50055e5f57843ba5c8101c880e62b81ceac15faca7b2c5d22466178dc4dade49cdd9f75ee448e91e1bc05d2b6d4fb5ff01c8713ca0f7799042b8bbbe098094f91b423bdf499bbf7992e22b4ce8719d3cc1dd7b780d42f1d8d2195cbd66b6e4ae7a3480b9628985e4ca43bca0681fad6dada81fb9feedd7ab5716d00a270db571800f143b2916afc6eb7213c01648086915bf4fbbc5813880e4867d4466a5abad5e65d9abde4a9f34f49c0bf6ad2be49da801c225491733238f7cef640c715faf6dff62dbbb8748f23da301da79285e07944348c68b415d454faf9527cb52554cdcefa9b66df419315c073b5d08253b4b1b6b7f8d082391c6f2d8d727551186e18998cd2c248f5c67ae97465ea9136dd7771b76448e719af503c918e8f34b9980a95a838067d8b184feb4038c313350a1f89adf0ba107f0f4a771566378894ecfeb99e8372ef77800bf5551347e5b725767f2d9afbcbd571f3ddf3bc6d46deeb74cf5e9fd6b6389d8b2d01e9e492ec33c524841f18d9208801e39c8f928c6e55dd01aa679111f4164f41e98dfd4048c46ff4185a6c07f6615c2371e0db07079f66ad675daf5e80e6a0b2bd37f61ad3f602b3d3c00f9eb571bb9bd9f52d4d18cb228e61f09477fbede3afb08d085b0419c6c03f285824a20de281f3cf6327ea280febb0ec08fdb860eb61fc71bdd8b611291e1f7160b784ae966cb878caf043345a54ddf8e24822528565685e090fe8d953908768ec16686c4321bbb8c8d05d25323faedc8a3ffa0320889b3acec7a5cfb974ed6d1d431737c2b92821995d9c8eab2d045726b30658e1e6713f809d5720f5f37a0d3ac1c7ee155e9c76ab0bf0cbc5560909549d7034216d124a91509071b6d2b94b070b42ea029a98d8da63c68da33ea1aaed53c3c7c84a376fb07bf2127361aff6cabf86f70c8496e237e078faeebcb9f47b6abfcfaab2920cfc7b1156d4426c799d56649ab912a664190773b9f8e79d36eae5bd57a8f0fb5cd28c30e8c7cf0ae069053be1f2950370d49b93dc8ff46fc5813801d99dffb08c5e92a2484a2ff2576b306b15486d701826c81bf8047916ab9a3d6f3fa34bfafdc3e54058b75b8e37f99cddcc9ed7cca9b89b28bfc2f4644a7eaaad5f9481f8d940648a220dd5aace3df2adcd3bf42e53455be7193859870ae4fcc965a0e8187bbf94a488de7509a3c6bcc51b2791aa61d2cf93627ab9e6bef594ad7c2b9c29d8709e9e0721b4cefa47cb1a03cff42b0cdd2002f35d58391dbc230fe3df3d41a1957765a677fcb5186dedbdc91a12d0ecc0f180796b53a56a64204be31425d8be2671e9cd33e71f6f9876def660fc20a01eab1d9cfc29b2c294ec4541dd63ebfabb8ffb2a4807179f1351f9e08955ccc866b4e162819cde59639a42811c9f2b80dfab294d72a5c9a89f55e23e4fe45703a4b79a877e6aec0a4fb91808c877af7bf50830e5343d7846550a4b8b9210f2272bceaa810118ce6806604a7694fad8d06b7bcf8650de89be961fed9bc69f46c60f7713fc68bb91a342819c671a2f0f5ef9cf1bef768a8a04a7b46ba5819ecd2ed770e4db0cea42102030668a2580b468916751c851757bebb2efbc2c6cc597e78f200d3985c3e83667b4e3b77b7f3cb12955bd3f58bda7597adaf304e8039e095dda924440bd71ab8637ad99ae00f56b3b46b9a118c53799561be9920a1e6f1e4364f79376381226a63870244784fb8e8af2c9b2f417a0e080aaa8991a08344b3459db77155538bf7183f14917d1232fa87afaf8b8477b0a604e6f1dc0a4fc2cb03dc1131403dc509147bd2838b1e2157bde27df43d11903bf00f6bb605eaaecfef9ea0830566fc92162d99332120403517b9a89790985f8ed04dfa719a7c2576e91ef1937ac1e5fc0f61abc7c01423c0f0654abd260799085321adb8030c6042aae6121469285adc6939556eed15d23d8f50450a569d22571b34c591dd5ba1980541ebb9ba513bee91dd64d6e679761d8c7d49f763708f39c07138636a640c2e619ea10233d639326de942cfba2fd04a5e16515e0e47c58c54571334213a8c33955054245500fe297d1d7a44ea39f40668072eac3b2139c16c24f56577637ab57d6a7938e929f6873ba445e2bb129ad6f0521b2944ef1e0ca383573399b4dc93267d98f9fcfe17f1a53c96b2fdc04e8fa0ef9bc5b04c0181fdfdc6ccd4072226c5a6e31e641a945d697e878e59dc326d68da7bc8bf18be9b9b0deda18b2c6444bea01dedb56ad086bd39d9451291c0e7b191192627670046776cc37fe6ca8635b9d4f6f9245d698d141e06c421fd48781f698b4fbba83a0abc0e340c939afc399327728dc4ab08e1b15f9d17bf06adece878f2a6c39b189651c2e2ad6202e04726b917860a99a21ca1b2690f08dbbd8ebb1334eac95efe7fb2975427588ea7191eaa94cc89ce3d22a556c8be04dc3ffd80be6b9a9e216caaad55844c9676a8a766d01c41184ca3e7e3729f2a6d999cef675d6dc91b0118a0fb7f10b32cb33d6f29579b7732459487cb2961ddec0e3342fe36768d2e67478a1bc8bb0ea053b9c3ec1333afed20d9dfa2511a7edad1d9d5405598fe8c00c225b8567d8c046b8fba323b227da9639db0e470a7efa842201b54798fa1d1f000a0cf24ae59560ecfd8bfe49b4196bebc6582936283969a47a99325707f9ddfad4c87e96bce4b0950d14c6ddd33b3f1abcbf0b9439e11003f7949f43c0d89a8f714a9f4b5d3391d063fa513b21b1a9e3b84d5e5d04d451439b84fc47184a856e2324e3faed1de40751f9f36dd0d858213d0a9918851da8d1cbd69c441a2d5b53700e673fde99244040d24bf6cc11585b768b2d2ebf57ab0599fddaaedb0f2a9a2bfc9571624fe8f6d86d5dcffbeb05da9173630362fea72490d60cd4111b2b4bc7e40aa7bfaa8b6eb155925d92d58727a5e6c98c7e50d7ea70c94b8706b072b1e4088f7e4b7ff3352492c175db7c7ac6fa019d9a456791e00854219cd492f1a049fd52a08c57ee6d59130c8f290401dd90b7ebc9e16903e55f9c9af1b2b14ba68586830e7d8ee139ef27ab3048b59699a743540ccce83c21cfae3ed9bb4b838cf555923662064b25d42a528f7927eb7792674b61fcde3212123bd6dc26d13643b355ffdcef42c888ab4ff0464c95fc47c63d267194abd305a09a26f0d7a6dad1280908e0db37f2d444cdcbcc1e2b767b441019e9f669b4b82d6683c5a477f30762196432aff01f38d3402572dccd1006477730ce7f95a342da6b9ed41aaf82c529d55e01829348208229573f127b7b3e52555bba2fc605e36f7ccb086b1a3bdcb1e35b5e165dd15fe75315205f608a1ca745144f34481a41e86326ae10777f02d03ca336e5615777b55ff22f3d0f11a8a554c1ee359bbd596f99f4a28c011d39610f9ff711cd019d4ee8a0b1d3276d24d7dce5d8fe62120f4b2da83607ee61141f9e37a61fa9a4f9a6c7eec2ae3cf45e69fc55f52be31de05ae630f797b6306a59539b50d6f622abe336112867afba18ff9998053f73a9c2c9865a29ab04b4f35b99c3efa4dac715e9d7adf9f9b1759b6fb289c3c598470f692f3eeadc30a22c5d869c3209afc1c546529b341b7f8946220da943d104c7def69274aac2cb1bcbe237aa4c9bcb75c02b857e9bda3940b29116d1c6912ea46f3f0c027e403015ecc0c5e2ecc60400237da68347cce6d8aadd2c74b3e997b5543c8bc8cff95485d58d9c53b5ac4912be4aaaad938b9a2a072595ee3355a7aa30e57732aa9e10df518d6c86642c21cd529a4e372db732936a0ac260b609aaa4e08bf1fa4c1fcf24a0b9a2df9e7f35967166a9b3051e68c2febc42d16aa289280ec40c3fa8b1a077c831d287ed9175a289fe8561e727a69232ff23151d88f6801beb8ce96bdcb9b1eae77b881539db341071493d6ff2384bce1edc9a899a478c954b17f070f9ba78e9c50ad228069505096280595ee0e0e1c5848e03516edcfc6279a8d7997236ee48b0574f64a4bd21bbac62bbdb6f9a754d0b13d8327423b4ddaeed87e514746c97bbec209611bd8b6b776b6fddca7fe41f7db671f9c80c5da7cb96296b7e8cf8dec41e8a8e50202cda41c37ee066fcbf66a4c28bfa017130598c1a2ee126f2714238465739ed0c798d9637c55eccb787003472107a47e73120e09fc203396b68e88844eb078819717ae483d8f832d34960f7bc166c76f703c1aaeded03514d4ffe581dd12c03525d786cb581d134dde8115959188bf99dc10eb2475b41f33b1d41062598e4622b380a505fa6d9e7e737fa82f244702cbc41d4c9d7e601af2695adfe57e47fe885e85859a60d444ab07d6ba90f7b12857c974f325290932d5b52f82ccee5596b185eb83fd13ba50e1dfe89a597056842109130b7867d3e3e1fe36dab9fd3c1d0dda2bae6913a0ed929f65c631e07d30f047d3ce116542ccb5da72f5aea01c2a52b6cb3af13a4a6c9cf8490b56a28dcd5e89f4707c4fcc1c4162bf6d88038bfd4976ab29abe466c2890f6e82180e91e4428676e099e52441cb0bab1a678e6005c4f4550a90cb3b91517ae4eee3cd2c0a0c81ac9cae391b0acceca33ea262ccfdfb9b6de0741b1f9ff86f04240268c4aa293e0a9f2ae042aa51540927c1a3df4e90e62a637ee70066c3bdd02531a0f471772202c407988cbf77356f080cd3590c5da01c7a22f5272be15ea2dd2ad981bae94a287da94beda5213b0c9df790e36ffaadb453377b899cf6970a58eeb3d079954cd5df768f5e5fdd5a88d1148af9f796ac9eeb9729457aab97020fe44b9a8e0b93c0e322295d0afd7f7c65517a93a2e7a1833dbb061c2b25f65c96a6e334457997ac92fb70d7fa8f1e24b81b325dfbadb03172d1835d76dc3c9fc9d863a6eb2b153c1d85d1a633e284eb606833c84afec4937708f6dbedea47c15e45a4921e3683f1109ba00c6730cdc3f2ed5cf950303fc12f7116d30cebbc67dd778c0b90451e0a3f3da57d7bed5ff140ac9b6ad9d61a371f67087ca872908a3859a49a68877d1d46e36945e91be167a9e35cf6b1b4564d1a07563d72c2fba198c0e94a87fa05bc8b0ffea9bf252bc02b81ab57e79979ba47c328c1cf3419c4ad392aa34f02c5d3d09c12fda072166a71245fa190c99093078779b7c27d4bc5d001d967e2e9286a7b1f07b20445648328e0e52aabfa3f0b7cdf735d446e8d7311ec6c4eba141a3ae30f9e7660a1e83163ab8169b1395ae14c8698c1df5e3595a55f2a2e2a6bf928d505d227cb69bde86b15b37b3be3d49afc83f6671ce9aee8da3fdf6972a20390a5bb509fe379698563304a2ee0b97cf2f5aa86d8a6e1d5c728a711fa5e314c9ad71de46545763b716aa78c62b4e5c177c3ac916b2606862090b2646764ff9a01f9b60c8baef541deeb916cf270223c63c8105f827cdbf9d6e9f7c7d55f964c187b3e5574c0ed104ed94c4c441a50fab94296acd0de33fe4987f7f676d09e6b17f4ff3697043a0c94621e39e2bac887b20741c93aa60446b8cf69c67104a3e11076d1da776b9200719c9129d9101a2362cbf82fae7bb94ae7ff081010848d2df7aab6a90d04aa2406e6fc73abb45f63b4903ea46b5c0d1eb6e30cca395118bb4dd0815bbd48d2292355610f0a5672f65f49d496fd594a5d63cdb42decfa00f86923ce9e1fb498df8cfdcb7e9a6363b5e7403362aa4c2ed33e9a069bdae8d15c21baef7eff1d09d1780b367f4e8d8a6bf504178c566b378c92a627c7c536baa4ed8b22c2698a0989a0807bed1b1e147d1e5edd3fce709aa44a02188eb92b6fb86334aadbcaa7d4b175c541c13f4342f8625cf310e1cd03b71e27d64c2978bd91c3fe1627f853bffeb32509d83202ced0fd41de3d77c0259d97184851e1762ddf4c745b8c8d8b0efa56f01135682534e164dea1a119669b70c69b1628231d9c232a98a7ee79b6b3137160fd6e1a8cffe252c532b1256de522483f4543a31c13cd85de14d606cccdf6f949efb08c24a1a99857a2acdf94eab55254299aeef7bedbd42f0845f9e31447c5c155c00f45cb19e88db827b72403d3d04fe3e3208e3fefc1d370b760072fd8c5c43a7c31505e45c597f215544deae1ff6341877600394c2dc7bcc5b22d12e2dafc26ba8f2724a95bc97dad5b21388a1dcacf1e847eadd66a4b008960e329eaeec8a47e3aaf5b55781859de808528c94f95323918277b4bd5c648e17b50d79f69ad1735e58fd8af2fae14cec89c72aaf43e735bfbddd7a86aafabb232df05fe8836613c645683a21b20d758aa39175f82db30ce30050f6202540e01baf698a9b4f3361a84aa2b8ba769f32dd2c01c21204d32263efb24c934d2c4cf3a966950d29926830f386fca21c56359c2a9206dd87b8835776d581b5474c1f9b0858739030ac916066a4c08cf1bd4d90ea76667a333bf9f2f31f5c88c4004f5ca5352a9fc312f48848b61189fedeba27a809435e76a7df3d79f3e839a00b31a8f6a8ecdb2c5522db6a5b0f82687a432443a519f6bac8f5409991c216b3fc15440d2acb921bef74c8262965f9bfb02f57ec256cfca52dfaafa03ab60a0d84e4ad79fc1d825b1705367d30844e7373c2ff05a46a1bb4218ddf8c1e860b0b8c73569745482b07528cd101a5c1f2227dbec2d810b9a019fcfed24c448baadfda8dd4e7f2bcd93e2c325b94ce3d4bb281fbd435623827495049207e4b328440d6ddad092bf727a71b5349459c276209038949d75e85bbdc5b9127239da880ca36f2b2c0f96417e9198b9e137fac7e396ce9b3cdebe77dd4b4e65f7701d124cd1c5c2309c39448f6be979b86859dc90326e8bdec3f4e455b11e70a500b96b3cbc288ef1d7149b0bec4264ac5bcf5e71b2cdedfe55b684a1208407d7206cd441051324bf5f8cd8835772704fe9ba77a411e6c86d004a7254a1d7d33ac0850023f809af4b3b55b856ef0000f5c3272fb33f36f41cd766943d3f4fbe6c8ebe9646226d7cb85071dfebf2d77d1d57defafb1453015c6c744423a3c3c4ec3dee0d7f4703c68dc6250bc95310b4ee1117be4a81ee987a326d14b1820be81e34b59539cf706173f328d507e10101318d9019df5939c9d1b6d6ee8bca2e75a0850d8809ce663764fefc0103bd57f78cc08841789f0133954bf0bf061a2a5538f683fb6cbcb76a101d77db317e55eedf2c19a55b471833c750c3fad7a2e60a51507861a86cea7b50b4d968caa4074aebc163195edfb6bd46bc69e23c41a6c2412e0363c031f72d7a781f3d7d07002a128424163c38bbd594c311d45e130fed62d0bf6b357e67c272b196d0229c42239094d54a9a1cb92e65e895202b10adccd741df43f1cce75930b773386c12eea46ba2ff558b6d3fd44fb04281efd587bf91c088a260edd8987681f0fe83ae76bc3a71b08553a7b8cf6244ba0ad400676741411a54d917f126317840fa4cb4af95e2b700984b1162df68b5ef62b006d8e1226a92b4cebe2fe310c8a7712c500bfc5c7fd18a315d99a1eec89f82cb3d14f086ec00e5788a7e4510024f5d5de0e968702c2788e72e5dd218d1382047703f4ffa017e8deb9c6bf28631a648c9f0d6b68606736dd29a0b29cd7ea3a8ac019fd7e360016880b50b982904b0af91fee6443a43ebd6fe971c07b10cba735ae4ce605a7e1f27369d13fead145f52199187240ea96f1b4dbd54102a83da1f694bf2f9099f87a95d05c546a17ec7f25b5952b228372e5801e569d00451cc6653cc8a57f346238f9f132e055eaac0c873ce5ac6bb7dff56e33aa78937dba8ef4be62dac4ef1d35cd415aaee952891418a44faf5ea41378fdd48918558a450fcb8d8af8a8882d2c28c5533d0f75ee9fceacff4146a83efc0b35b09e27d1321ae1a849e4fc4bc222c2e382c27b14fce504b65147bd9058fe2c5a75cad4145abf95669bd1b33d566e4617ec3e72eb6f771404bd8ec76c12e2d23e505c4bdcb0a0a90726fddf3ccc46b188801a652f1cb5e36cc568303f50007f39d8dc708875819fbae86caf6f88820d7d93bf56a0d87983f41aeb5434b902465d37e930e4fc98ad7b33e799a1852a6eeb7c8443eb07f8d2fd40673d88bac1b4421ef6424abf66fca15cf6608099c8ae2bbd833a2ac16a86e6ac89271460451aa65316e9ab5052f0bc1185d4076d70fbc1eeba9011861f5b73ae66d70a62e2bb4a98a12724d7ff9d56650c02995e0b7ddd461e3c8beb9c7ea61566ead00ee4986d41818adb2461c91bdd2ca91b9d4b3e691254dfad0282975d619af5a040642f9f05700269a4c2390447149ee4d0e1099e27543bd4054b933828e2bcb773c2e20ce9d941c62db67becf55bcff374b998adaeb1a8dbe8d653d1aa786fcb9a1b61b88ab98e27d4af31f58d0f33a54d0a3d56a238c579e926e7093ecaad9c053037bfa8326295381fcf0107e51d487619965da0b5d2211af6429e8a90a03dc8b565cd11e995817b77f5c9ad66a6eec77ad989499a0ef5e3db18794b0d8777295d873eb4079977f642d519e222bb225573ae3ac6c95ec1c079d22147b686ff5dc119a61823de5daabe0385002654234ee8082a12a652ba990cb86841d2f2a141c5d787992621b2d2b04e6fd149cb7cb1d5ee881f0b0a3c0ac60faf4b58078bceab8559ea74151501aeb34aa806f34e992fc7ec8bd15811fc526150c26aaebbb39cf13c591183baa7246f9daaa85e897e0176fdccbc1c0a9ecc47869f1b06f2f0fe5014334f6d21a58f6cc02035f826fb086492e6ecb424de87bf4b6e741c0da8acf939cc9a27b5ce9de5f666f862b372870e201b9b484149fa153c172283c7dc48c37343f233f4884aa102225c2139d344114a1f9603f73029abfe802af0f1bb91e71fd1562bde226e849070047fe62ff8ccd986b91b542544ae780d6444eae2f7bb5af75f444d22e52aa6c560de535632e6e7a56c795e3c19b0f617644447f3ae7d13b20d41e7fb96338feece7620ab0c119ba684a2a2e7ac8abfb3c2994dfe01a1940011ebbb962a752150c71182e4a70fb4c51e1b1379530505c0f4e6c0d1656d3c22a05a1e676f980d9095109bb7eb634b91b9029cc3a4d0f424a43f51eca43c9e67a892a5348c8c788daddc107228faca920ad1e3ea16f1c36da328ba15e92b78abe9957f1be99e0d57850b3d643507e103b9e48668b4238f87f4269b16089a8c0fc351bde908f1f656831f419749c51b78cb1ef814402019acbe11f2316ed5d3d42633b64c54ead6d2051487a52ebd2319de69e04fcd80c730fb31f6f87e0580a20e3b6c72d5b84bafd5bad62bebae749acb150d850b5295a89623473c09a4f077d13449c5150c16102b167b70420fea4f5ea91d562ba827ac6b3e49048b32fc4d90cafc633415bcaa20536e6257ffd9efdf6d7cc1b7d5d26388035de54c4dd1c92c0b3c14a11cf7f9cb44ee18db06a00db99d52f4162baba18a9a54e0b28fae83afb7d1c831f6a6af2230f886a991eee924314124cee30d9450ddecd3521098a36a83963782fb9ee94b4111d85762d42587199848e4e8dfe25b22460a9e5b316a69f785153ca0e4857c167c632c849df07a947019077365c564f85c21e96fe1b12ac8bcdbfa24f425cafe76a72604092bc85fed9dc99ccbd7473279ef406a1777379fc0a6d38f273cf24a65a03ffe605adaf24c45597b71dfac9e8cd1f15d07d5deb4d7fb9f845b648df3f23acc79943ba102cf4860dba8ef979e7b323def7af6879d47f47e57ca012ce9ee44145242e8f5d542bbcdb983654fdf823bff5871efd6f5a540636ba3fa09704a3a27d2d8ad6a3f908f39fbcff57c989d6e76c48b7f48b69058d984961097356897aa54aa66d87f2b8932f1d49d3f62564df5a8873f850a8c53865540c7b82d068760dd428b568cf9a4d1635d57d98f85708bd95e9143ce9b4ad374d44ffa50ed22613d435443e95d8689dff3bac57eb59da1575a42b4b38a89e31b280ac36b3c02627c07965cb569b274e9e5aca56ab74fe428d84dde2ac32cd92f97c3ee7c195dfe85045a08c7875d44554994da2d010cb09852610da2e4425a1e5ab7191a584d99f5c1809612ce0f29eaa99b9446f9b64ef3aa9d298ed4bd52800c605492bb253eb25378aedcdba8a59048695cc92324ce4fcebe1f7a961358743b243421983ede13167af2132782377eef18451e1ec5ef09413d6bf6c48a503f10771a903b73544b0dbf7cf4b0dfe7d182e6703d52f542f0c5848bfb6e151e01a4a0c62b4bb8dc0d8a1cef1a69e842ba547d49fa745f65c550ff10b5c96e3b3db546ad614c0ebd02dc92eb06021593d68676d6a8714c6eaff89f5b28bc5385bef84b1e9b14db7173337bd07c85baea5d34e0414e065347759f1020699f3faa55064cc09186cb43a82e0c06ad0f9204fb42949371474602d7be1883efc81bee02fdbc3985c0071f2c8c8e597988b628c75d7e7c23d9a098dc4ae103e526fc670f7e5bf1ae6dda86692fa11532f981a912864c5008fe8fe959688900699821b2a7e7fddcaf2f09c95dd56c69a31cf12a7e18416ec579284accf7fa8e2aca005a824ea39779f8613eefdde4efebad34b4b2f9dce0a0fb681b92fd1d217dab6de2c347298ed10c76771eb02533afd2f18b6cadd3005767728ab8b98d30c2445ebf28ed1114cef3601bfcd376ca96ddfec9922be283b2d0d5af91c7a185b733fec7364a282892ba9460eebefbec719a56a0acde757b37157b6b37a8db671f13cf1bd4e792f38e33a321b10e85f48de3fdf38f2cb7bbcf8cbdc0c18b2f1a18a057606d079295196b9b7e6268ffc92928ea0d8d783386c8445380b9adf3c1e9fe3a757e0c103424707d4aa6575b35c61a014fe8b5b1db3b1a71838e06ff160dd950dda43ff67dce82403fd0a4c891c05305c1887386c612b6a168fae6b4b85da8cedee2b5e478dbc841c1fbeb7a602e14d425b2ee654a62d0288fffe0701a86c9d8e8da8268742aeafe028d83311a08eea9379d28d24a9352575d15f32fe11bb4e0221f116179bd3ea3550be2365bd71cf96075cc07ad4fc9f284445d19b3439868b8eb85bc3cf6668d56e3b21f17453524a7798a934c4f643769d59d2454fa2368720f77eb3b6d2b56911c7181db4fc80eaed01a688f054a426003e84d672355c7b8df39bf18e74e5c43d839eff1e79f276ec8cab2fac90043006ef9e0d4d15a873362732cbaeb7907ceabefeffbba82ba04028a113c0d4d1b0aa9331d202da19bcf5242374ff81151163b7d5360f5bd86dce493eb030fe4f7644d519b7062682b1168552c0262a4e8c2e3b6d8eb882e2dab3dcb03017d8840e8b031ab5af2ddeec7df7c378fdbb39eb9491fed85bb880795114ac653ba3c694254c80da66b55ca969d2237c29d205833e84b9d3ca8b59f36625574dca859eb7a1ca86fe7afb5bce3b482b519ccad25a8394a0cf22cb154d6b77e9fb9765734acf1dbaf1ecdbdf42ac7878b4d73e0e881ea9f5c179752d435e9a0704544532cd1e7f5caf69c5a56b8a315ff713ac7228d9702b1f38f4747f74ca939d0ebdbdf769c72956b844565e2120ecce1e1d28bbdc9bb590217e93c6bc31bb63fbd6e4a800196c7facdd050b1c804d4fbebea56959a83630b8424f41af2b22d9fa5b9cf40a4d1294aee4aae676ff152f6a23b1e9a13afde6a1743e54bd18c2a7ab2491d6b9df1da79cc9566f24f28ab00b64b33a00e4ae100558effc76cb661a7ed9ec14595afec360cbd23ab9619924f160dce56201d1675a657bb5baee0b48a25e24e3d2bc088c3bd270c509d24c78d222698bfba3424595f3a4f233cc689c4e01446de81071d7bdd9f2c6dc6d9c35f1ae988dc53fbc046d6f9af4040b5b658d45ceb447a2b3de7bcc19399c7261bc71e196bbbfbf5fe410c45c65a68f1727f86e7e89bd2dc843c58c79c05db1ec552ad6a63b7a538a2774bd5e3ae35e5ee79228763b32d0fc8da9d55c416a3ecd3340c125d441ecf6401893a167d59269ca09bd522da644f99f15315787aa7ee2503056e926ff82e4720e4d5dd73338b1d9b3d379edd5c53087d5c2a0b79af06fc756291b06c097bd0e6e0b8a10f5f7f117c044f07ed8e4a0cefb0253f07053224ad8fb3fedd004b861a85eb1faabcfcfcc4ee702909f94b6e6444dc885541c0dc4727bfcd3c2e8f8331cbfa04b10f310802042394a170eb1d091cdcd6ca8ee7eb03c62af1659d08068dd532d569a59ce1c90798d1daeedb6779222a2adf67c79af7b016a623e89ce3c0eee576721e5789763a9c73866675dd4380292cf4fd8d3af7dab4c000fabca915dd233b83e1ad1404ade7a10a467d2c620ace3be90ce47d8594fb24cf546ee1b955b41aba79895b1e2ced3127d60f3bf3a91aa3e699b0932a57b33c9960442b7ec5d724084be76ed15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
