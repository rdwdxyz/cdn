<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39d21d639d91fb26190b23e49d4de68a22d3eda39250b6cdae1b4cb50b5a769e9fe5625e661316d1de7e651f22b1ad5e2ebea9f3dd03e50236faec9e7e7c1fb6da2b24a770b99bd8e65546014d904612dffdf94911c7636e7e49f0a243d30e38e2b979162de98dd701c862a4b9614e6cd8758898ff0516b4adfe735f0d772e699930a773c0d6d57c25944d2663addda1054d881e9a85a7f5c4602545bdaba368cfee3ab56cf425b236267b5ec6f5fe50b3ef8ebf8d887c38ff5454092b4e0daa6836af45ba0f159331c71e23637e30a1601eefc293491673b3d1eda2d44cd0b02909834b61ec281a7d5fa9250b46015d9c5650dbb338038140868e0b0031ba670db7b27069bebaf4636c623d57b096a5c1b33e4f25d271a69c6e5501929ea05c871c968f4ee42b3890393c8281358304e4d7bc06b95bc49519123dba57e9b2027d6e5cfa2758ccea44445b5a393c94600daf2d1d6275d9fe0024ef63504ab2232d4304e63a2eafcace4b8b6381f26c6884a1f74213100d5712ceda247e68fb1b32da47c2a91ce17abe20b37fd2f635691f5a99b3970d63f0e5e8d95746d27fd7b264f543beee73a25fc6d430670046c6ebb1fc21ce99c69b48b168c622294eccee89efcfa4dbb8f87a3d157c6d5b237be3e656f652f183e0b1b955dca5837dbc43260bc47c995deb7a7cbb8aafeda2cf93840fcf23824eeef442d7f2a1a370c0f6cb533357230fee057861a306d7f8607aba76d0212661f718ccea4944359247633af07fa2b2c24fb7c4c9813b8087043109d70b21b56332e1fa68394c813bce028b2c66a88e1f437a6cdb11d0f9ba5c120e8fe36a26c10b48865b5f93d6a4ae3368df196dc7d0635918977ca194d1e41e96983dda9472bdc1fcc4b4a5a7ba28490ac89974659cf9c0527beaa00108706b42a35763ed0fa8781ecdf04e8f68a1ce79f36ab10b6d0ea0bd0bca9a79f92b542c9c49b354ea68422720b816a1e7c8f6c2124d94ca3e284acd95a3ad96448efd77ca3882fbd0737522a99f10403a25416a93ef8c19151afd93dcc8eaacb3015d2dc41c0f7fa38b09a79ff2a62db856c35153091e0303a171d87c2c02cdc62f6361f4668b2287d3bcbaa2628b0bb7a66b38ddb3cbdb2eb659987a5cbfe52577f72c7c5d5103b5a455196b75b80f35cd02bb79c1698f79d47654fffa232681ea88f27d3eb1e405a7e7750d8bc575c0d6b60b4ffeabd95c98d0397838559c32da5db706e4923e908203320c523606f0c46c6238805ca21081c2018171c240e7fc2e10107a8b57668ccf58d1c7645031101d5492422dcc03a835e9b68b2f89ef8155a7e037947243a482585eb630b1cda0d9d7b063249e6c3f1861b5206673ee142bbdeea8c0ef8b2796e8a7840c3ae72cc3eae235d09013def87e63ec0c99e26cd2a88e6ea154cad9a72961b76dbdee0090e07fa3db724c8e42bace6e623a9b4ff5c4816a31f9f268d4618d40a584349b3dec9e2090792d6306a149e87aceb93f12eb2a0835d938b29cca45137ad2aeeb721aa6b44f0036399170940691d57e0aa47487f00e56023402cc23b27714cd6039a3497ff61c6012c5f4e2d7fff1255dbafcd2949685dae99c2acf7628792e6aff8484b54e9236127474e7c11b17db31a8602882ae23f7600cdd527e5c75c3eac22cba9007e014750ef0844618bdce3d6f5621c4e1755ecab5fa1d557f711cd8f7df21a26de3dee8a6ca64a7db9c755cebf72cba98986edaa5f45654ba6ec9920acf2543ddc044032484b07133a9d8584e25fb39faddcc492ba177b7210ab79884161832fc4a83138c1298d5b6793c78a2614e6396a53d563c6582aa13276fbca399b950cb590334ca96875a9bf24ebd20a4a4724be52a4a8f51252e9c2eaeafecbb72e525719b7bd90b9fbeeb776a834fb288f31a6027fbeaf10f428bdf1f925a3438fbdd6dd7ba43784caadeb1cd2f890c1ff55d981b35d4a64dab737ec2b21727759784f86d51e5963daae727649782c782e7e89f3eea7e5bf7e2c27d2dfae8ace592b8626121383402d103ae0ae5923b33e57c76d8afbfee31581e5d64e9e37c4f3f56ae6913ea0cd0f4e73f5c4e11cc0fa0721e4fe14c37adb464ce133d9a06e686707e5742c59af1ce5845a0ce73ba690531bbd0a0ee7e8dedbd771d802a0fe78e098c30487580eaa8dd8e874fa3274e054ec7d68c7c9b42b1abf95a9a0c77eb0acb17175b480f13923c1c2e47bb60013819dfa1a1daa9d89d03f570a9a9d7f983316fe01ae814c7b669e5034a7b5ae076b03aa9e861f434c7c9b6cda601c7555a3c5ebb74d4e1449a4e837d2ed5cd4c25b09b37d8d3b42e3bccf9d285c9b3ac3f08e62f176d5d8dcd481ebe883eb1455a2f854060162537bdde3ff93916d3c96607065d44afb60959eab5689e64fc1d121d72cf704e01239a4e2724501573af8aebaf7f05eb1c59c167469da5cdb3cdb9bd87dd0a9462af2037ec9345193375cd91b9c050ce4cce7d7b8d432095a4cf2a27d195e83585a40aae0a0d9c96554611b7195aaa20f73a66a06b84f2ee06d8b5223285b7ccdb17ffd402dc417b6c0c6d79294ea53d0423e2019a704b22577bfb979df869d0d8c3c14637209600561ee6153ef95b3c1017f432e6efdd535b64b8b8d4f7f2424d0fcb9c80c0b6bb31a12574c42f062d7e9f61288c69afa4be84ad3271f302552475fb265813c77acd172bd3b7fe552f4e83b5ab8461e82086afb520d10de74c3aaf77f6e86e0ed17a987985b9c5ad8b803789c13486ecc5d06688346f7c53a18f61d2b1d32effd285650a1f26e24f1e5b649ecfeb344424201626f1cb5f441c9e969c922ab1353d0be4aa0402959bfdeb4195444ee300dedd3ccd236fbbc37afe598f853f258c9c985dd0629da17c0994d546f1fefbc5306a9c6ea8c93a8ca1e219e5a3c821e3e9f35fcb9d54e5a34d3aafdea1b550095ba88efab63b6add09e1206cea2fc564e0aea0ab4ce3a59a79ddde416e993211298ff23ad6827142a42005113f25466a7822db9bca780666e999fb7d2f025b6841f378eab13c90d75da2df390b2c2efb665ff0a83ea837df584c02d88998f2749ea0c0f6d3feb3dc9035ad26b2a631cf5ef74e219a7366f5860ef06058de81c315665ebc4679fb7b16ae2b116bc849b529bc271b04880d784bd149be2e4b0b6716ff44a6ba065201ebc54eb6caf788aa2e169ba799c28e3c8daeac9d9551f37aced3dba1ccb94c121fd3edf92f7ad663881e4fe0cc27137e9d5889575ac5c1d970523737c8aaaaa2095da2daa6997ff4307f4e7ac0a11ebbcf3af22885ae976fe8e956aa1d23ab730d98419cf64ca70c23c5f7886c88a12a66863057a76b836313ab56ab2a5ee896ac9f14b312bf0e643a83fc8446a56577a2b484b23e60ef481967ebfdc5e3b7a1a4ffeb16c46be5c648dc898dbec9044631921965365028f47d0aa9ef46868da8cbae4ce8679be47ef0eebefbdff5ae93da67bc3943feba7c90e7af1473cd19cb274e77ecfb9a73bdc4e514e4cbba0ad1495dd539d31a8eda5b8fbc1f0eeb16b2631ccbfd3cd6bb504e32d62538520fd08a42646fe16270452a1e840e7830d8d7269df74e4868b12f4b87117f7490ab132a3c0fc7f5fb0c0891774cefef26813719f45003a24b8473f03d77b0654530d7dcb67e26ed6d7f0d6c0d034d05f7c63eba8e3d7cc4152cc7dae79d1cd993b6c3345282b55c47cc31b7d544bd1f392f62ec612b103cdd145a39f79d17da86aa8b260dea0d51fe679da630ee2360282eb082e2eb5c9fc53fe5ab791e401e816aed94c48faa6394b500efb9d06534387718ba805360b3fa8c94d6fc21b5d7fa7947c505acb74a74b54f1d2ef447ade232bbf59048dc0cfa6cfb1283a59bdadd42b560a04a08b537cdad50213cdc397c0349af76771f60173313437dd8550e2971227421358c5333f090f46705184b01b596f5ba62cc22340dc9ce22e37f46918b0b3e7bd45389605ba9c4c37ad74828aa19b84e64a4279b3c0860eab793ec6648cf968bddab723135ea18e6b54de0f2ff22ec3f2d7522f510884c0c8db68635ed48cba929866a92852df780aa63cd093b39f0a15767367a71a22a4ae78cff68809a3adfef5cf05f8b9d7346f8a5f2db4dc020b31ff5d9e375e8784b7b1ab92ad56da14dc9cd38d7c868991bf61c032c024085828162f445441cc799f5659b14022b98dfa9f8dd2eb81faa08c579103ce3c1bbff1205d0600ff28e8253100ef1b21a6e6a07b0d170082ca06694ec6d8a5f0a8a203c347b4855037113ac8f90f83a43b359f16f77bf97704ed90b67c563940de399e39bf954a7add5bc9b874c908434cbbafa8d292867e69b280f5731502e49894427d0ff79c51c6a057064133f0eb2c43ad4c88736697f5f3c9255b5f60aef86012ab18838c6a7c4897cedfa34ec070abab8896c4daf3f99633d2c4cfdc987bee78a1ee86f96391c266d08a784c4accaf0824be6105e82479ca5fb228339aa35ce2c4e6f6bca32c7e4388950dd81f0325fd5a996e7b23d41a5c685ad99b3d8c23f960d7804399ab3a580f74aea8258c1297dac489b68fbec0c3c3d3805dbed48318164086270906e27fa22d041ba4bccbc7a49561e8e46d418eb6aa31d1e35939514c9a6e921fc4872f38518f7eaaf1f4728e4b924643f0378be4b71ba286c3104a61faa407f29e86c96e4a0119b97f762f52ab7e487601466f16baa21e847ae94f1a6025f97d07254e9130d4a6cff3feaa24c0f0b576148eb66eef983b182e272c3c73408a032825ea9b4fa7c8d3887e56f15fa1c2f3a97ef5f2761b260a3cca6eda81e4909da7886cae857033dc08bb989bf6c8bff9a94756b687db3a7f66ac2fbcd087a5802c6fb6f82b83ac8241177847e5c5c5a4ede7f05cf8f990c47c9bdf92e9a387b0db83cf321c4b5e2f2a95e03b98da7fe5c5af34ef1d9242848eba4f198b36bc0cea18369d9f08dc83ed9de83ace733abf2512de48790d68ff9fbc5bf00d7e9bd95ba3729ba0f559db788ed6e38eeb275d8966e554f08fa0f0f62a3643a31119b2e879852f619c4b71c3f4a5b54c5f5f3016e0dbc367088641bdd6b75a708175164c422d2cb3871998c1634a2fa5f14547df9e8166e89bcfa4f5d7c24ccc428d7fa52eb87664c2391e60bb899753aa64caaf414b916680b8ebb2ed16c81fa6f27d9e20518b69a0f79bf0057c5b5c779eb3662c17488d4ee9ca276b92ebc71da99ab41f22a1441b4a5b93523b764040a630ae404d36130f9c5455653572c5a7e77d9ef2635499a8053abebdd5596716c7165fac4c2e4d138c763214d2bd4bdf28b40914148714368d120c8c80cbec90a805aff0d57ab8367c0fff491085a4afd1cfe5bfbf35e956142fc3da101a4a32d9b22dd28f90b77e7fa8b14b983e1b4790d8f234bf9ac6df663523b2f9906c11737a5fb9f08ea6fa7340ba41879940b28f0afb84368b5c6a03a62acdfd95bd6110b6997636131ba574d35bd039a9bc4b924985b306d029998b12bf8195baba2218b846d9cbbf065a8d2225c2edb230f1ec4ceb5f4645462311c98055fa82255d47210e9e720939ea54e47aba93a45bce4c951247ad584d059a07af13ea7222dc62abbd3de05d96c8e761c814636f7554851021eaac5430a85ba4e59e1074169e2c37fc6376ea3a9cffaff3ed86da94445a950c5807edeb125966a1f608508f986bc9d25be9f0e7fed8537e3b3d4b4c3ac73c607346aa6721cdd959e36a3705c328fc2a3ce3581f3ec8da2768465291834501b451dab9abec99ea41414dd5f3128c13dc9aa2023fb7b8033d7ac7f065e7e34c017e9a9355f8473517cd265b3ad5984563516f7dc2dc50cda63fa8b6b75042a07539632e359f632b6873aa87bb90279484c2ee536ad70ebf2d416847ef1c09d8a16cc91af548e29ecdf35081cc1c5197daea63e3e4cad52bc0f7df29165022f594ec706ae45fd5ab6fb11ff9ba1b596e51cba015f7cb4fd2fec9ae3d256f87efd4a25067d81295685c4b7f5fd91272a7d9058b9360bbb4842b935b816296b13d1d6ab3a70851744e1bc539e61fc88fbd3dd2a2245147f7a63371bf8ad41ae0444fdc7e05e5923561483cfba7c204e658e3cf19f3a9365e1668d0e8fd631ebd591be8f58c824dc8c3384b2317ba5f5c8ec6707ca68131c5e898b0f01a2aecd7a36f5507330224b125349d4d5b629f784f44894a1a7dca2646d115d4afb48d0033ee9f569e4934216f380bee6b79cf91c8ce4e81afa88c96e5d427eebe9638b0b11ffb735f6bd78720785b8ed33b2c8dc2c170ceee43d5d16a19ba5fb079a86bf15c0d6ead28155ed6988c7d7dcf60027827672016afc656acfdb3a1bec2e222839f12a1c0e4c4e42e1682dd68b6a9ac0ae84973a38d70529caa58dbc955e1671990414323666b1dd15db11c099018e6a72cd70f33eb4039247c5f5ebe3a5ff6a91c0bac16a121519568561e9ae9089a39e3005c640cc6a61a73af39f709674e7fc508744265cfbee92067f6c290b4c3daefb63e4494057dc823dd26f83690f554a47e1a89bc672e7071410c1f9d34d589ced390b7df070a6b2b3755885924457f9cd3392a1a128dbbd3b72ff2f6ec4565aa3f337ec0c7287ea251344562cc6eeaf9995b251b5019b51d23e4cb5058ee64c8379a8cac476b78283f5193ea332b99d2c0e85baa16786bcd8560fbc7ad46b70cbd2e9b115dce20522860808b9c6b71d754bc97ca619230407b4ad32545adf061b14032b970a4e44fa18c154bfb9d9efed750f89f1cca62e7d47e00a854fd3587d6d97b051c23322c93553817356f9bfeceb63b9e86c65289d794b247cd7201bea9b7b1c517637bd42abe947a95f8212904811268cf58f9ca3166bc0d49ddb8a4ede51631efd3269073b06a019b441f2fd9ec95f05bcacfa9c0a8b339663eb3992780d66bf6aa007ad67ad31eb767c8bcc9e29d9bd4cf292b3fc8738fffbe964d69e27e1e74906c2c8326f681c497480ef5a4882a6991de4afdaa9ae5e9c5a19d952d1c40e627f8d17a0888aec917f8998a3433aa8d3cce4810f07f81eb4dc1e06e3529eda94726e01185aa79db205b0a5f6eb4f4c062edfa3326066683107e764ee42565938938c05a1341317d8a717214fbf2bfa199c531db3084463758a21a491e967bbe61eeff8dd75ae322df1c8536d09514e162faac7b4c3b8ce6ce688c04e76c568fb3d3c223ac717a2a77de8bea09217f4b0efcf9173c5508be6f5a4ddcec76d13ef9adc89fa3c6b3bc4aecfac197894625b01f5570b66b5a264ed172cf951fcee80aa86e9a6eff3ce980ca86f434fc9f8812c82d5844f33e19b395a1dbfab6b549c1526eb4e50be2315858533c52cfce058f80e886b29baeacba6b13e011aeb10d0125269b786a5251d80e79de6569691b6cb7efd918dda4af511127df24278c2583c5f76de2703d497e17c9de690242ad22b42dacc919f6e23733474d19968cd45335a36920f819604cd8ffed646ad4db34becf5f47cf9e3261abf676a5139ac3436b86b1cb1b16f2f102db8dcd20c9e683c84e5dd68e75647a1b88ffff6d255dad09c7e7d6ae1c8f1bd5bef359989f1dc24d9bab01f311546b63b1d3a09fa5a754ab3a9a37bf663e7d7afb2418dad4e6a1cfa1a34dbfb5eae2781cc4f78240eb9a7d017d296426df6b3644dc6f5ab88bdeaebda9e8037902927cfd12df232e7354a4f05fb1935560e59741450fd8c65c334cae86e35527210aa3b5d19c90e94db490a03da7c4a8b63dda4089434b376f69043d4d69fb6e258ffc3bf5e460094af73c093a65a0cf40c44fa7cfb7dca4e6f7f9babf7027d2924d750dd5f73b4f09a4e63aa5668e113918e2dd961564a00401090f838bf64895cc7d6bf90740ece0dfab4c93ac8414acb5922b1812958324b25e2be01c9662af9be8f0543386c4dc8ce5ffeaa2da97e3b6dc996ea976fe96d9a9da7287e43e751e499f4349087b6aacafac58f34fdcad6edf97ef59f83ce9292b6e62eac607fce87e429c38188567089f1e313728c9bd75e4c06e734aef163e9fa072c3f343b03624f29918a505ab01131005ac52db97c09a938ecee2a719ec0309fcff11b2492001c0109dcfb8c630430ec69aa939dd13ab6602ae91d0b8bc219d19fc45136cba74b99dd99f228c51b1ff4fe309ceab4e9c3bd93582f696edd03097140e5ca2581c1985c7daa15bd0cefa27a57ef9f09a50dab78891703bf7bb297db90917f975f1c6fb98e024fbf08a39d26979190edb663332384a96b98a044937f323def01bf8cac7ef5fd4d9515113d94999e7dd5804fd94b4e4bd0dc02ab192f41249da339a33eaf3a4c2fa9b290bfb00e7acf4b6c6019c7545b997f9297dcceebf55aaaff160a8571ccc17d2dd47aafa34238c41d3922218127b27603543d92b17340893866c8cb1ab729b00fc639bcfae7c04afa8589af5dbbdd08db864efd69e5ff8a0ea36dcdfedb162f8918c7ecb93e2c08f904cf2f66e909a6185ee815ea06242b7730a54329d3433c824832f5b8458d4e2fbd1ced31753104b1de17dd69a9c84d57621470c0027b9971d34d2f5d2fa3c33a9158582c92ec421ab597eb84cdfb23f667739f1032a6009349ca023aba87bf35d317f663729ea92e48ace7467d386c7da84634b06fea5f5d9f1af43a0543370cdf87c1b811e8bf8b91849542df46a3a1be3e38c3bc77a086952adbda039e8e7544cf7afd618bf06f715e8a8187a5f8e332d62829a7d7fceed47d542bfc19472562006a9b884e15529793d63593e24a109f8bb200f461b407d10d6668527e38c0f800c70fd815d274234ebd4103fba0d6ef7b65b46b56e78581bd7387b0d9ebb5db3c0d116650c831085f39bbba4f2e70db85ed404942915a2fbec01f01ea21e2f1d86109cc6ae64707fcf3cb11477c1d32a6f2846afbcb9802841b77384d1f5ebe37f21fbef7a0304a58546de89272867ffabe149edb29574a2d2c7933c587d9ae219da4f70a77d3e1afc0126a915379da30295a36891d2f26056d5c81390939f6305261efcaf8d6464090f99f8223aeb5e1ed9e8b0c7d1b43b7f7e177d1f02c3ae2b16d160af00ee8fb93bd67e00a403d26911cbb89b15ee075f331aad60dbe50eb6eceb0086022f85a065b84f9777e59b4d9a301fbcaf7aedaf632af09421c33beddc8c6808e785f73829f8a6b06ab24913f50d8fddb6338e0b02d95afdb9bb099107c792abe6bcd9101af8cfd9a9c42974e25cc72fbcc60acab79c752f8faf9366971aceda7229df8c09440364f9562c2ad57861e8a20983ab3dd9b39291a2850f2cba6c660ce28b114045427af396106d26fd138c93989d2ff92338b104ad008eb62b5af86e06bdf0b5e18f3eab9d8758698461ee550e1031e3c2c3487729f8d5a191c5b9ae696cdffc365bfd86f71009f1deed6c0747a15c7f93e0104288f051aa20ee7b9f9344186008bb3530d0e6e8ea76cb7467a5c4800321e4d84eb73b7a68b9749f501171942edab39808df6c5126003ae059c45d29da4ae2b3fcf7a60ec644d472470f44e50918c706898f9f41158142a4e633c6bf2ca091a97d97628c809d5d114f758e876ea114f35a95fea7a27e9e8d1b3e1b04481600775bcb73316d97d6bbfeb369129ce62f6217a6f594f842972840abfc1f0ffe71a52e0d784d2f6bbc781f14f4d00a00092a3ae3d8428699e6bbf1eac615ab6e17c5a111501bc567f1352e850632e6dd9c0298f9d25719e817624981e0329c51f69d83bc6ba5375d3a39bc027a5b33da6721aa26d9b36d68905b14ad254820c19855b85a163b74b49765b4d10dcba8f3182705152e3572a5d7363320a45a3d98f052e2fa877f2299fa0a279b3d731d101b90589a0627e0389a93881741460e6b59e2111e7a12293dde67b12e26647847d490a763c781761353ddbb5e77e1acec0a580c77e27b2a476f42f505ebe91ccab03b36f932fa726d2e4243be0b43a0191519692101b9c94766473fe7a03f0572f0290978b8ad363cc5d880eb176de37eb2390b645200bdd5571765922be18f80050437fa96059fdca96f6400c52383d30234119462711786be9205ccccfb3ea7c2a03ec175ba9ad7a9b79ef97633d3f3155f391a7ed4c1363ba4d122af2a11ec697c8fa193ee66846381f91d4a77e99c321ae2fadf4892a4dccef76a4421384f7371846b010246884260f4557efd3348b6a368cea2a92cb74061dadeaebd0304b7dbb69aea61bc0322e373ab26c99b353bbff188735b13f804e815c2ee0baae0846c613ebc44808ba4861b7a62a6558c05899fe5aa636e888835c019a7a07cff4cdbed99da6f24ae582dd25dfe308e27d6169636b3929b12bc29bfadb562e72e05d02f4e5952b68cff57b9c53c28a3f2e3710f58d9431ea51b0b76897930b5ff05b02d3b27dc6325d74224ef2e8d9f160d0f5845cf189ef95a14858857cbcad28777da9a55a8c99c0dc6f5bdd20f58279a4cef4d3cc468012bd13bcc0361cea721729f1e85a7493cd78a37c79adb964023d16f015eea4fc7bd1e1face07dc2d7e93032bc15e1696fcccc6713c148cb912118d0e4a31b8793d4153a378eaccdefb46b4cf267b487eda96bb77d89085901feaeba05f7204a0c2c4760cd35f4c331f7cdef5164336c0ac68510a2e2e5bcb313f572851d8393abb13207f92be6c40aeba72134c172ccb944ff39e34290b02c374408718c4b19a14bf281bc832bc622df6e5a4eefdad85ea64805083dd3f1dddf5babc83983211ff1636a21ba8316e85e59c4771721082cbcd30b61f32684e8bf6c6830302ac45820ff5a8a9b0076e95d3d0006877d0ce77a9074c9f5486eef9c7f665750284458a82bbd0bd84bfd0fa341342043f4403ab2ba97ee76530d94f2d02ef5871354eb851e5c9299d931f670e4b64380e6f9570c7b7b49c94dab2bc605c8452c0a424242d068ff2d6fa116393c17819fceaddc5055a47c7b44233e7307e68deb28e150fc724a2c859892ceb6f32cfaa583481126f8fdc07c224dd93fbcd196edc1ea6660cf57dddfb8e4188d2ed1419acb3d3902286b57ce1e9bb770a3aafa5c53ca9109f1ca8358a620f4f003e56e672ef1687d1a5641b2813e96c5d686b4e62cf7d7e25d4f565a3ae67e10389963e0b34d46aa20904aa0d2240665c6e3a0b244f78191f0bcf9e3bda08476ce126e0ac07df21462effe44448da07f9f9259fb215b23145764f492abe18b5a291657eb2fa8a92094f061598277ab42e3362d8dca1350d5308b2c4717e8e4663d059b1607652c4c5303c113760b48dc6514de9e76b43a7d9183de2c321300de4ed27612d27eb6b39a06b9a2efbb2d8722aa401fed08db60ce796aaba44092c322ed206331149b2616b933ac9f1c7afcc14dae5e221f95e65458b6632948b668b64020f7319fc3d843f0917407b1de73b2c41cfa74139cd22f8464cff9bbf2b8336cdbbcd9fafe0d0dacecd05f41e3b2b15be55ad39b7135918600858408727de7ca3cdf2d485198bde98dd30fdc31341993edbc9430218c4c724ad2a89b5319b4e13ccc34aff2cf436ae705b09a185cc017a8e1ba1f5f7a825dd1f92b80c5a6bfe2d76c1574f1b06cabb3e305a6cf6cfd579e6d26c2d83f8341364e51144dc7de30de04b306a424f509eaa30343c74d8e5162509620f16ac9d24d3417ed07fec6db7b1ca888ff39092e6524a109032eee11c2998412681f9bfa53f935a2059ad4e483d28147b98de34bc5a72148dd4abdd2ec7be990530627394deee2022595ed34b93124f58ee91bd8858bd0206545f4a48cfca7d3db731648d593ed81c55bc70cb626ed3122ad294b7f309754290ab480ddbedeb65ce6286c5efbbb8e7bdf6237b148f0d77ed78636ff9b67216558e4357b5f5f8c743b1420063eeffb1de9d89655430f7ce052dfb46d1b18c15d3e0dfee5edbe46263d2f55f217359e7ae0face6f1738b641271f0a9dae8e2a65e5b23ee32892088c5787c816f3b5cbd4221dd329cdd6f49452d661c8e06bcb0749190fdcbcc0487f3f6e70b996971bbe957735d45727bf51f4f39d9328fd2cba7c6af7344b492972b4668c0c741856b3b27c139a09e0da2d08818aeebae2b6d30f2fb195d5fe9a99bf4922da6b75f4928d2a18abc63405e9f0f9fb8b75e5129c96bc3f78b22f1e533e64c8ffb2bb4d8b622020953cfcdaa1f5632b6fd48f7601a0ee1b8ce9ca4385abbc85352a382cf342c3b81a54e6a63e5814c558c505734cd31f4c18e299f260b56dfc953e629561aac18968529e41e01f180b99560a56ab1eb29d2a4dbafaac194eaa4a5e287c2de16db427dbbc9c0ac1e259887a6f145bd93989b907e86943bf05a47b75ddf0bdb71c02a6cea325ccbf2df477369b7d8c3c05b67ef208900baf7af0c096e7e08f869623f6c7d2293f419ae8d2f74534069c615dcb803acf36cc5d325a5fbf2694e2b367811a8ae3c729d13845338fc375e65856785785f2dbddee4c29219c50c174fc10bb617994ee1d1b4cfd4a4b80e592278e09728d82fc3a0208ed308bf2d8e20a73979971614eb15fe6e134c4d143efb6c4ddaaa9efb8c3b9184fb5ca0d30db41db019105bcaef9dff0663403e947bf461148c9b0affc0127a2e15bd84a715668a228f72cd7b181376563fb8df30530be724cf7db0b29f520ba322ba28010b12b2d094e0fd4de9862db61827a930ffb6d7c674853903ba692e6086b12c9155f850e3a14e0600492dd2a38bf36219ad4aa7fe5362f938f0b23634046e5e5cd7fea4a888c3460d9a382aad924b274bd1b793a9cca9a5a0b8a43d6d5d80b8ff933d392fac228118db5f914e21fb82cf4f7853eb7d98863d767f88f4fb9118b0082082916f50864c7852028bae63c04ca4ccd7d3460180315c7ae909cebb4d2f3ef66fbcfe39182948c68ea12c44213ef1678d7b2f8326b3bd6698d146c214e55a332a300c57fab840f95fe61dcb0bd2b85a4ab237970d5a9fec9c4e53d9089dad3793872ba70e764798b4ffd3f402f9cf646f068fe4e2852452d74a4bc61dfc43bf3b8735efa254c684a3ad6b994d2d7492ec0a63e59038a0896a914f8b573300e415c5dbc254e8ac5049b12a7c9d3eb7ccc30d8d65346cf52520bc97d4f0a4ca8e1f66623fda21aebc9dc153285db6b28d2a4c2a60012d2c44bedc6c2a08e6acf7a83a047b6566b00f42ace7812727dc77a2e120da7f710f9c94c63ae3ccc7814393f89946dc6195a48840337bb4f3366d990e0b1a0761207c30b09aea0b43ad638dd409734101d1db92fa527160f00683ac3601846385bf13cbe7a01b1f10b921ae1c3d37e927ede70ffb58623ae3282ed3a57e841da8818069dc7ba0f1ad67f9c2ca47535030c262bf8da130a23ac8137834461a52465e7c4498040690e3c0d4bc4c108bff387a4b51cd56bd1ec51d485c4c7bae5c6a673ac6d42300cb58f3deca9182458e8bda21e811253a88643c14c29fe9e8a664d2451faace30747ccef6822f3e8e10c66902a5e2feea99d714c6c31e447255498664f9012313980c7932c90394b91dbc6cca1c122d38bca56b14ffa2135ffa4acf4a74a94b376e88b0136d2edc2b6289e9638dfdbf1420d340dd6b6724be266380742dbc0312ac2e9fd5b8d687b777236c8ea6534ce1e51162337493ca511c65c2aad231314fb28a3fc78355ced48d663daf68c1b404e9183ce59962c98d932b007b66aefec4b7e1c5b983965ee9b0260cc5005497ffdd716172c4678714d7e74110f49bfab81cd40eeebfd54bce3ca88a6e047b3ba313b34c6c8df1f6a5405eb3a57b555bbd2890dd98e8c2754140f53cf576772e9ad5a7c665b2d853fc53e305640fc562a09cb91f7edc967514387cf690f5cb8adfbbf94bd352001bd48d2aef24694fd01931cfeb3504ff661aca311677d2fc2cedc2413d0c8d8aa0cae5edd41e5034cefcf11aa563d973cfcf444945133f9176b1372c47763a9f570c98dbf4ca205001a26a8819054950c8bd1dbd3c8631d4ec33c978aad1ed2c38422ae7449adc88743f8d59acd88e7872c34545a04bda2bcb685dc1aea6a54fc73e601f0e61a41373b7e6e6d8c45ef82bfe4b32af69056a105e5be6d1603ba12490d32efd24324e39452c5cc409f2f860cef84e8c67dc0b34945458daecf0feeb2101541ab689425a94e0bacd8cfcb5ca48b703a48cc8e3806c333d47847cd62dbc369ca2ffa8b58d16d33bb075150b18fe2353b4ab037041dd23d81d13db657bbb75204a9508480bb65be493c1bc11f58a90518303536b4bb66bb7a03ac2d27bccac8697ac2cf4905a75f1e1d5b82078db3282249a60dcc84a03c1409905448fcb088afcf4fad2d875a5eb8e3b2cd7df2928b9f29bab6f96389a24ef5f901ea6b0aad15b62c21e16559f9afec1ef963d028500cbf6f56e2e91152281f49f17ea7be1429255b452452a69c6c9df88933d195aa3d1f819b2c9dce2a8237569255c73044f1f8404c97f21fae6ef0a42448ea9b0585caba538a34295600e1ae49fa8334a8bb5ec0d7865e7ba2fff21418efd441cd6f01dfd993fc0451867da788e29dbeeb9bab1bd39846f2e63a5b5cfc65d02ed04b9288a5782b7a2d1fd60a89f809728f1d1499a4f541d1a4b6fbf60d8a23a988792a1d1d52d8d80e4d7b4d9f6762c9445b2a695c04724f6e878482cf66ea9402dee1720748c55dde63c5e407f9121cd13de135ef6bd84b951c95bfd8363c1258aed4dc689809369ac5e92573a50c78c054df62e0fc0be262ab32feb2a668239048ae69d61a421d8af5c4314d7eda9868f25c1553ece718444839221dfbb5ca82baee1d4454f0fc52f358132b944c0387a4f70928816836195e07912cfa2d1224c63d3fd27a25371267de53c1b5a027532d12cf1b81ac85e2df2aaf61b7a9d8963db464ff8dbda135258b912cae70d51db0e548d7c171f3266ef68827073853aed82285527586665b167b205b1057f1fcb471503b14d1f81fa4301872ee937232daac4bdbadf08cd5b40a7777796bc4b1ff6d82235149fdf33f393e2f98585ed88030fdec977c5479ff7a8c5e45d1d290b13a55823144e2bf7af72cd5734f48bc3b30dfbf908c9a47fa319062c0a6fe5ac16e7feb006911dfc267df84b28a5534d5384a46c48ae7338895a0a8664c61367eb4c53069e5e4230c85844bc6e5b63a2abbe4dc0b217e200d8bc4bc0fe47fd6f85fa71944d9ba4bfec1606e02266e948b06bf2f6ff5bdeab3e4751d20f352818dcbe863f1d8abec4ce3fba2c8789ead6dec536d81f842f9297a44e7240afbdaef70bcb9b98be16f8d148a8e74897b6628c632e3111be22efbd04c97f848fd56a1898e0af02d9f3627c34e6ef40383bb6ac29cf3d87405826f89cf29f2e9a9680e4599280efa1aa212bcecad910217999cd56aa00966670d11663dccfdf0179420bb0d67335e1e761ac6e9aeb8039809c9af69e2c05a58b8f16e4ac66a03174f3a6423c5eb776a64f47de7135965646e5d09e1667b163a0170eb2f1e6608d59298917b93acb8c3616555a55d49c6b6f3bc7e637449c62c1b00a210b7ceafea604d28b7bbd26752449c0a8be1f2dedcf106f667eef114388267798bb750128d093c39683eba1f46acbebf4003ccb5ebdbb17c08c796b9c4421adf3d3b8dbdc7e440e328400130b1c96d34da4a505bf36112414ffd39a73a2acfa57170a77cc928251a44d16b31d8c07a5bf19db6565fc736c0fb97212844502c7edffdc9c80ab6c8e570c842dc057e01496be006315244526026859c00a2ed91562eaa3c8671ca41c6944a921f9ce0e364ca083b01f2598c3f403c1060da20ecfabbce8b0bae38fd8d0a0f60189519f8de0244fc5925625b79ee564abf1c6569cb95efd2993c4b7d38f68adb84885381e96becb94165c1ee2a99b86b096b193256eb9b28648891463b85cffbfc56793292f08009ba4372e284d5aaf4f730bdce11ea9cf570aaf6b9259c35ad2bfc5a1ffe78f11a76463fa8ca4d6d262516f17f717c5fb967be40a7cd4931d0a61871358cf7fa323bb10d98ff0ac3fffb2e46841c6407ecd7c0c560d5b7e74bd1393d3c8e45566b86e39c2bddf29776aae75fd2141e281b92e56761dda4b52fb37c4c9d68ac93801378b4b97425280f033a4de2d411e87da79d3b7e3c875279d05838cfc8700b53ab9d75ce20d03037851c0f5b8fb6f895121c1130b4c8144f1ffc5df9cec6553df79136bedeb512dcd9521922cab9abc14b310b7e299c297ca14d0fcf0a5e560f3dece7be3617d3acf7b41b15bb1cbafa70ea7da28a3379ff5cdf6f3805ae9b1d66c2aeaac21032a622a6ce9644dd9e71552e6d44753c310b6718845a5ce2c1653239b132212462fd8f88aaea6262cb0e4a15a22866f954c1bc86442c1b25e1ea0a37ba28bf03af99313c865555e8398603bcfa5642bc65bc16925df3ddbdcddef997696de1bc00429a7cc7ed02a8b5bd8ebf8b3735a877bd329cbe4db4636f086724396737607f4484b6c67e8372bf96a0be2ad07c18eb315cbfa960d7147c0a420324ddde9276dbf03c2452d77ae5533a9f427146cf7c935fe2eb3b017ad918ec03aaf6d3ec9d54f20e292a3168416a222d829d12cee016bf793fa9e9004a2385631b84f54cbb8e13e7e3f5812ec22fc846e9c2a803f94fe56711f1be63b4fa921f16b65fbd08bd60f028cc9900b3bfd553b4e1bbecb9c8475bc4fb143ec26916484013d1484fbe50408d5a3f8921555eb415671fd28ddc8fd61727460fb7d71bba678fc27d8aab0d5ca116d5e4c9c93ff3eb7b50268ff49abd7f26fec3e91454d17c80d46b94c4f736efa944fcdd68c50473694527285d80cce58596d0a4e99743c7878912c948927edbf0af8130f6d701f16f2d4996952ec41efd483797356e265fdf279aafcbc93202c7166b442af2cdc6259d778552f2e13bd965e0dbe4701abe5f29f50d04827b80b6bf47ed4398cbdbece0b09a3fc30e0675801e67724f0770df9f133633d37eb36e143f3c259457d734895630ace12d0cda6e9fa63113a3ca3541eceafbb90535d1fd4e60c2028be90d6567c98964859f2d32bc4ef4fea77c2f70f8da38f88b6c30ed3a709958a686b5a8a07d3199b9b8c5710cb38f6b8b0675480fa86f673f9bb74daeb63bb4381016432a402fd7d655e857a36c0b51637b86a9d5892cf6477ee00ed22a8cee38ee454bb20afade49c7029b5c44f9ef1b37f3df4de86a3dbf420c5425a7b34f2e50fad8b46489808ac6681cbc7b6b5b0eeedebd70d4719c6420de4910123635e8a74bc4c459618c52f06cf02ac6c80621304881a7373beccc3e154a504e77c9093ae5f762bf1509119e5454d56ccfadfb28019644474c074c74e55cdc9da2ffa9938859e2408de6ef7582d1abbf5fc8aa30cf9716c03bf2615c53de24124eb4562c6871232faf3aaa3d1047f6bd9d4587520ee957f645c143a5e2f7e65935fe28703af631ec06759672b10e93d754aab8dc55bd90bd622ed67c6b19fe6d97f4c5863219b5af917153e8948e63a3dd0dab16873e9f871d4815cc787de6745580f74bd39f826db73a1040890d47366341eab9f4fb56d37148a05588441955bc5090b1f0e1b60aa0132b13f27fb0fcf7094eb667081b655cb40cb2e723b80d7b14f0a7d427e7c91a011075baf3b518460a394a86e534ca6adfca5dc432c5c6c1f4bbe1b98d7cc31bbc9727c7e081f86de27f3ab8106832587b14d04bcf48443924145c34f33c3a5b2eb3d1ac938171c000577c717b87587d9ce515651d42f7c152622375f9abbf8641185ffc5cd826932e4db1e191023004d0cba7acf50cb96b7042fdaab755480075f227e01fea7aa8b633c78a997ac696d7b692fb13d88a59ea299caaa9647ca5566cb4a1016b5e4baef06590012f7d6a574f228b72d4a8de824ae7d93a51b383ece2d4374a0a95644325882eac177a76370abf4d058832a0c8342eb1365b87c21c0c060c59df34495bbe4e50465433c067469d793fecc3b11","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
