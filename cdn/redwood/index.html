<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9807aaa96fb37775729d06a0023242a11d44ee165e5bdd62d3daff75bd33687a9949684f4d6712d4504665cd2405f84a9d58c40b851ea87a0ac10290207d7df27e072070c3abd467a9112b3f83641a6c147eee36e80f065805193e99e79920c15350294bbd5d0518ebd07fd6cf93e6193a0517e019518255a1403e81b2f5fd52dc1664b6890a800d6228c54334dda44ac2f4de0e3d9ab2f33927870f68c3579bd24ba9cf67d5b04a5ad9570647111f735ff9ed2b1ab34ea709db72bb86f4d4c8ea953023a7d19ba1decbf7f1e7256383f1bb8a9f50f277862dd61a1e2159a83ab6f0065c4b2a2a7337def26ae8f97637f56e14dd83faf23c1b7805a603cf8639d7aa96a1c5dcb7aa36c362eb1d7e164e5171f7f057d168b0a7b21375ea4e0aa0c114c5e9093e213162227db6c37cff0649edeca6e7879ed3d4b93002d1b83ab78a2647f48684bdd559a19b56ec5e638c7d517e4bf883b589dd2dc30539e82344af317aaa9e77e8b0f3946cfa15e9e9f6bf0fe63e8f61d7b15503513aaec9d01ef1678ddea4345e5cd0a25020018afc594d0a2cbd6b70b198b8cb77d35276fc2e7284cb8bad8563034b34cd358418b93bec273330cb620d509062927d42b25755d8a51943c5a1fb8215a3fbedc1c7957f1a0f944a48eca831a6da36bdd5d97a142c338aa76d7854f7333eea9b6ff4f251e941ccde48c8583ba731d104eb62dbc02b8966cfbcdf044d5e925369c3617d79d67594d956b7394f4ecae5f71630b0530699acdb45a11af31ebcbe234bb1fff5f39bc2f6fa519f7903e8e43ab85618a7f5073a084d088e5c70635cd27ee00b5a308420ab6e24812c43c21f82e6b3405a7e808dbbaa1403e4d2ce047b178b61fb65bb48bccbdb3fee173c5daf85d3fc271502a2fef4d3f96047363654813585bbf838b4ad888c4abfb9f9c5412de7b93f7ed1691d7cf660231b68f5afe728e0727bd0a7ea41b1f59ad156920707e1d40ab84ef058f4455abe3a650497070aba2019e6a62ec7829a6beab4fca5464dab816b98c6d2a38c09f906ee27864865340f7c502e34eb519e51fa09a7b895293855f308d00e44198a5cc990b8c57fe4430d5f15610b22ff977569ce98de65e0a90babcaec959ea97f69803e3097a2bd040140d2ae3b23162d72a4510542fd96048c3e2d05fb4b4139fb419e24ce4bcca44b274f375276df66b95b053b3f24bbe6a4b704f9fd089c8fc34fff1e70bca54f60053996c1e6feaf4934fb99af48c727b288d167e7eda351a32eecd76eb6bb4bdd8daaa810f51b7c9d4cf19c2fb6ab56bf068bae91381339e0a9797080dd78bf45211db0ffafc56d7247d7dc8577ab8b3ab97e4b60b5ca1d27fb8d2dd5e452de57c9c81478a2e0d0c738fe3125fcba6b7bc1d1a007d9f4ff413431f48ceda5423f71b9644c37fe8b512ec215e94ba774d14cc8603d38f5833d607f1825b62b25529312d58cfcc25ce58ee79e78516a41d31547b12700ab6147ffbd3497b332b8a8c3cd86213b3886bfdc54ab5ab6578b17efbe9b99ce736e69ff827210a16b23f75b555faf3f9f49c6bf419c22d44239d89caaff88f0cc557f337b69d4542a7e39e022612c60e8276eeb30fefdcdeffd20a2cbf8759278cccd7ce26215277eb85fb16a7b93b3161a3457d14ef6b3e486fa0c7f070585d61e3424bc75002ca314961451ca5bd7824d86fcc8803a14f04926a6d61157af34e6c5ebce5d9a48ae183e35d50c9bcfcf20d8c606bddb74f200611e0fc8fb5f8dc08cc8a34aac2f1117deeb8e69d677ddb15a4b80440dfbbc3c714339ac0116fe7cf8acbdee35e914933517a56804e29aa2fada03bd3b1b36a8565bc50f66651e9184499710ae72f8b4be407c162065a91cf558eac58738303eb6e61cdc6b952463545b26802344e5214e5a4384dd3d00943826c58d5ae1ec930fa752de19b4e7cd57075934e19f510aaa2304377438dd9157385661a90ee006c31f7277b1a9c2db8d311ca2925705d41368b70dfcc9b6b920cbf875996345a9587586d06bb20147fa4d8a436d11a5ce10b210c90ec1504048157e36eec9c413c5661b0f143ebeabc21b5d61c6d2470fca1bf14e3ce0d015928a087665f559e67f5326fe62b59fdc1231d8c8310f56910b2a49c566b4097d4d885da0bfd76a0476e1beb076c76326bc0537c4ec374b78ccd8942e3cfebd155b0ad2a022e856b28a712d715cf653a6cb6823b58c9c8e4cca92c6c1aba72fd96a5cd441cb9675d0ca48de5960aa38188865b2e4c503d548475aebec21c0d04a4814d03f4e6c2c76b64087e994ec43bd17162c9e8a156138bd3e8b6e8c4e6ca3d13d6d373126ba86ee58aacb314c8ea6dc856a1399f422826b273ec78e44e38fae8574a4611db6113bdf030fd9a82c842de99842e1943bfc4aba784cf84722678c7321d2805d18742a1e75e88a09d7befb1663a9e57f87fe27135cb29309ca848f3bf80b8a4e474afdbeda236a18b16a1a608b77a0b85a1b9063698a3d6d6c184bd13e864ecb1dae7e086b27fe4c7cc1756954a15aef0cfb5fb19751dd72c27d9a4ec183bf6bb8623d2272496630e22dcbdccd16fee44243fa6048d708f76c9ff2e06f2a80642c87bf5f09936adb8791cc92927e084b93edcad3ec0dc45a7205ec2c9311edff0c78d36735bbc701c67546149564315b62226633152e582baf339cf79ad80b787eced8f8e9fb6561f3f9417e53170a17c92c1b4d0af66a7cd01ec943994604732672ef217f5dd6a95f451e65b48699598e66e05eb5c6fc21cad62daff19dd2435f6b55c2272d5e088e3d8dcd11a2fa887aadc08eac6b2ed0442932c92a76f8a242d13991a7030ad12f6c73913a3c252e48851a5b385949659f477fa657e24d7f0bc26d85a02fd6064fefb2e2b2f3ed419326f505a36c60d950aa0f24672c4c5d24a3ce6f61d70538d706d0917905c01fecd7b04eec42d94f184ad14e98913370bc93fb8cead5120624eb16ae1a4eea96b4bfc35be9dbb2956720481e29136966600d9f647a8d112bdf2c195503e153406b5db901def1a78124307eb0c26a3f2d925cd81c1d439e2d752642be8360dac2e23eb71d7b463857cda8072aa807cf88948635a58f6ccd0220e74b452cec50f74fba2324c55fa4bf741e4c0d79331a24de722988507e1285e05d23870113abf4dfb9bce6ae86cfcb44f9f4b21ba9535fe0a473893e9f75e8d8a29b0c71e1a6c7970eca20809d9bbe418d7a94925ea78a145d4d6c0334adc7a5831592464a66a27d6dc558d5675f6e3a88ad7dedcd4fc916ec6e1b2242c2861098c2403e9d2da1eb82a81aab25d2abf3ffb0058f444a077c344654aa6dbe814f607e5ad0b4c61e1835358f20dc9576ded75ffe5041973f37d9389b2099c698ec60ce0fc5dd6d4eb44b5cb9953221625d2bd97ec2bb1d8f813d2672d17839270c17d3d3c7ab745d156bc6fb716d521963ad4cf9a8e3ce3321d74de68e6df1cff8eac56c21f6d7a967119672a9ef169a505db7b24a89d0862ef3923e004083b8b8a8455fefcc1ab3171bf6f6b3e23deb2533ac93b4c41d66bf8391789404ad4be33d58f115ad230373cfa1fff17e59d2fafe41186bd3add6b9ae043d0c04852d411f7ec096c7b85483adc3cc2d996fd0c6be876684b31d4811909c044e2f59134e3d4f71a320af4e582593ecfe97514374a26774c0b8029cdb3b3f5cc0da8d5a1280cf310eb8224de54a061f0cb33df5bb6b9fd393c3c0a16b5fc1762b956d9a245958be618927b891645fdb5fbfc78a6b4baec7d037ba168dfd9dc55724da8134c0906b1a75ae38e86d2581b29df8e4788db9120a7d5b0b6143ed6bde22b23cf38f8273cf84cd15fbab140fdc902a83ca2fa0c6741b2b5889a68fea8e1871971f7eee95e70195e77ff067a447d571d7341efc21839f730cb9b9f0a9678633a4163763b8bb8253a662fc1127723da42df9399d2d7de8d5d0dc4d8d88687291a3fe9140c1f754a633c6567c9a9ffe9a39d6b85954690ded773f436d52236be55f48480e7d3f740271fda19569c2dc05f6fe9b772d852afbd3fcfd68ecc80c7a65f8134acdb54cf77c720692151df082b9edee3b674c07e72bc51152d9364cf9af0bb926913f70146fe42795a034e9cd13e3f6c2f58bc34da34abe9ec820cc1cb7b2f4470f547f530dcb52e7538df6a1af41a5181855ea030738bd96ab3e4af0deb17fde0c53fc6171a080085004e517a9077f156eb1fb2cc83576524fe64969de54a9fa1fba069c25c85c98ab80decedfd2083e4b06fa4cccb2cf25569b837feeda12ac38884c9a6bfb7621989b5a533207f8bf2262ec9f29a8156da129715501fa31d32e3f5c579acd312bd46a6f23b4f8a1f64cba8dba4e61417866c7be3f549c32f0f15b1104d558b256c2d85c71c7b626677875bb49dc6285c117167de775cedd706f882b861c6c091fcdcc4eb3220c68ba608c9fa4a78cc4a62992bac1f719f7a40d9a76a38ab582cba01e70b349580a381a8b6c87480a944a9ebed7f8968a22a7da51a52251f5ce3db5083a6ff131f32f80bbccdd82bc12e4a24334736b9678589d2ea1bed873763b4a0791660d00055918cb268082349b7bf4c53f9cb9b44a2bc05bbec23cce98b14e595005c2144556852a481c59134e9980b2e9be0207369428b582ad6809d4f91b2dbf3f4b0cb05f0d92300c2a9cbe0a53add28ca90b3d0ca9eaf2bd53fdcb46c1d01fa8d800550471af4b7260aee2d5a0383ff9abcc90db4cf4111e8ec75e9a08d09570cae9e30d4becd388761a4e311fd74277598665b35ae312506b17bb437e7af7d5acf5d146886cdc01606659e316e9149930c98f17b3e9ffc03e3a1543bf66a432dd079d27f5c9ca51b03cf8cc38ec4126c0b31e866370d6c162d8c135b0d9d2b148c55192ffc0642dd0f81fe49140b6d8b74933239f8261fd026424c534745f2d7d769493c0a8dde188d129949de196a903b0680ec4e89f11b434e287566b965e6d6eb2dfd5c5bdcc37a803b465c4c5cefc1ea1df093c27ce6cf09d52695442d66416610d519d83e0bee5ce0975e74dc08169911d70f4c900b36ea9006971ae5f075199fedd5ad6768b924f2031b7b7fae9ea5dfa01a992d338cd36a1b87ed06fb278ed43478add33f45221214e8c82aa4294fe7c0e4c6631525b60f684285e4b58d7449053bd05d8d8c48861b98ed47409e7c83e86a24a936a65b39606996f0c9eb99b663a80430591022facaf4c49c433c852d10d6eff58f6410a3b04bdda8f21f1a9ac6bf5b92692f5743ce65b774f691bef73e1744922b710e88b7a2e04c6640d0b515b69dab6628a6e309eec4a28a047a02f6d79140041f2b752b504d4012f862cb48b41ed80b4165816cc76b6d4b3d927fdc580608c77c7453cdd5b744c3370f26b606ece1f7eabd255accb26e370dba7101f897d242bd1d544d3eb0de154938695b8912cf287eeea07fdf774ffb24206964ec58747f3fd13d04c938aa33b7347c50b118ad4623088539318dfcd83dad38e3fb8a436ee7c62db2c199803a477a014decad8b556ab9e1ffdc65af72c4cde81a71fa515bdded00770ab52245ce783937708be3c48134d57ca25ef04357fdf9d7db3d6fc228b29984aa7bc2802d0108a0c90f6521f47265fec460407032962109110fd743eef76390dc3db3908d24b327e26f2ccadcaa32eb92df9f04544a35ec4750a5fc6774105fc5290c47b7e4dcbae3e5ff02e048e796d406f73d15c9f0b246fbe46b220fa24396fde14c2ed069dbecd4aee2cf8db57f029167912c41f92314a6ca9c07f3de7fa56fcfb82725df483c3a82671190d33db8d79b8e47ee1773a993549a2fb7f714504f7e1f48744ef8224fa06a0402ac2bfec681f9942aaed8de1d5597b8df4e21d2d0c7cb635d04a79e5d549aedd8b4ad18fa44d41a5f5aa2bc773f18cb2a848019aa93317e807ef7173531078b008dad52c0252e6101359a9d407fada8e7e0359073e3738b082715d43fd8eb2d5b1196b0a5a7407d510432d50dc9efa5bcb9eddb6e2d0bfb11d4d4dc6422c87632bed7384bb21ab31676c752ad3c617d667223db84786d0041dfc529c974bd743ffb7c78f8d62d28a4abf2b06b3574452af0eecd773e2e5536b58bbe6bd49c7f8aea83a8a6255707ddaa8b5ecff02019b736a1963c39a0508693672a594d2f152f9f234c93bea9cba86f39a5ecd45d05de743e42fbd27f52cd872a65c8e42edd47d09dc8e5de4f6e8e310326427748093aa135465e42da061eb211348c08720e037d345f6a215fa7230d7b3eed57bc06c04c9ae59941c25e5d8ca5a266e987a8b56573b31cf722de349a07c6e57a49e5a7dda0e4f52c0e408fcfb0027e7ef4f13f217ee829b083e53132d49386253ef7302ac9617e3932aac252495eb0eec374944f4d62e19c499be21d906101bb0f2a4e1824c96e3e00e760d28f315a0392ec4ba461e571da154223aa7a2c7b6ac78e6142c456f7ddde597ade3d7a73b75763d8f0d37087b5ec75e070338e0cfe8f05a50a9f96cf1a435a5ed94506518a03686bff252ca913ac499a19984016828c3cc3c996f889aeacbd77035be06d0409d08fd45f1c62b97da86cc7d8af7d8387b84898a90746870fd76a450fd04ef165043282c384c03728a962a816b878b144dd2a825e6f5f5d3d400b2789dc4aaaa86b4f7684b8e774ea6df8f208684377716c54c82d0e3f83f18d4f5063b327d1458d50d3decbeaf97e8d11d88ba45dd0c50f653546e3d79d45b83c499b5a1e92c4d1eda6c9fc314e87fb5a30ca1aca0b58b89336a91faccbc9f3aa558907c361b0d215e3e0ecad8dc5b86609abef6c5c089936127c6b6f92c28d0931c7cb9e8f9e2e172aeab210771e6d464815aea9761b46bb3a28b36f0f315f83fee8ee43aa9667bd636ef92f1f70070ec48f36b026792be667c5668e35cdab8e412c22483db4e06945ece4d2cc83459750a47dbe3fd98441624bfb55a0a9edba1062391ff73a6f50afe2269126d9286201c94c613f1dda1ac98411a250f47bc539b53b97c71045cda30f6f69de92da1793886af2055c1ff45bd3511453229033910ef5f3a61bca629e5923aab5ab06bb5f06bee78a53b6b72fc81290e17bdafc71d812ee4fe1470bc894e92a9912b3385c5695d72b4da54ccfb9272f124f5a8bc994b98539935abdb66e0e4d01948a30fecc45f64e0fa23fc78814cba9c3b81a2f57fb1bfb9c19ac58e698a2f34676eb8c3b144cf22f9f4cbdc9656bb096ac6824ddb5a1a4d9ccca91cdb6060baf6557abd9cc3f40e793e73c1b35a1cf61ac35579243f1ed55c08576dfb35e8f60e50beac9e58ee8171dec8318fcf24467bbb4cc2106d8ffbec4d2670a736f6f9544193a43c014281349ead98210118d9d65b874fdfa73911c553aaba62b22a063744afea83bce942b367a4165472e8e1c72ee707d1f980685a6aca0e3d707dba0ff87b362b80956f42a1b07821193ce023d02b559deaba261cb9228f028c9211aab3ef3b1891c6302704a69ed698941101981be0f50706be384a94ce7d33434d640aa9c870675fbdc5eb5e0d9890a03b55574a85dd8fe612c2eebf8abb92c652aefa1f63aef4bf0e8de6f49e5e222db58bee76dba05894d7e04fa5df8437d12ba88a528772aea066fd1e98a9bf7cdd178804c356846703447815f35d3225b93f0efc386a18e4f12ae169f4942ce0ef8db68b910e313bafcc2b40cdb7e68831280e4bd56bee028945ba4df6fa279b033b4fa76774e9e6ba26e076d6d3b52b92aac6671176912be332dafeddb8fd1655e37b1275444938a58d8b33b3ae7d7d99ea4e188eb5039b25c51099ea871c8141d318db3f09c41b71d0c572a4bdc71bd12b5aa502087a889239023fc12c54816be9fb7d1576e4589170ee89635ca1764effb6746c05a18ad5374acc0baca7e6e2b41c42f22cdb2a397dddbba84f699f4c9aa0213732220e6e4418c165af5a6f8a6aca9e97285689470d251162f9006693bd7ca81d92d80ac0289ff3214277ec49e2d1f3c74bf20185d025c31ef982272a2087de9930e6838b851afe754bdf84a627be487b9ee788a8c57f09cdfafce517dc6d685b21bab55031d99b015500f1a63fecb60435cae635015cdde2cadd7c422d8e6c303b6a1d65b6f96aceac8e3780d92aa39bd219731e53af12f295aa498004724ee807dc01d6af444fd43312b1e3a594c3ce59f85b57e4fcfd6dd9ba7e76fbd9307bb207cb21439c50484781ab3a36967943bc03cd08beb4a143be9e4bfbcb8d58a77cb4987b3f82ae2d1b829a8a29a03103a77531f37bf3de046b60e1041717ba2b58123f424a8129594151a64a46f29682843a7b5969a4c5ba5d8236c284c500c4d85c27d262c2198cbb4e2faaac9ae9366665768515af014de986f05b2c4b29ae26419d53a27f7d494675b32c8119a3f1ac325241ccc266b7d9a419805613311bbaf76d971a9c8c343cf661a0ccaff588b36fc7abd6217eb520b9d3f767e0cf377a3cee29826419b210bc42b51f047e0ed03d651f9ed9ccf4f911d072192b128ab21fab422b0b89f8d787aa2432af020b6da9e79e8217e4045492e3c4c308a4f5e1597568ef569bbff0be51688b9773f801d87215ea932c92ed02dd3fb6c71839b383767ad6315d295d48feed7bdd8536c3f282f659db495c434bf6723ccabd55f1f340ff595f252bd09640d977ee087d40fa0c80e1baf654596e9c493334c489ae83df8a1071f1a3f339a9fe8f8134c5ea047419eea1d4c6c577eb8cbb3ccfd5bb3a18bee4aebb1dadc28e87bb808473fd14ce58d4632c7d77e4e3582bc8fc24b3e8008635e0b0dd64b978453c26cd4ca070481afce17c405e8dc88c15a268f15fb7c46d0124228d63287d0ff02908e0b300c4a2785eaacd61844a7e6cffa6e349fd7e6eaeb2b67cb9c32599e75114abe330ba214a3a2e293b308f6e8c1fd5b7c5eb0a61171f402f58c57d1f52dd38d63cbfd23845906332b00c71beb670f9de9cbf718a46dc38ae1f55e230016f327d1086ccb267a30bebdf027f209b681e4bd92d89e03afb96a1babec387d6d6ba5feeb801a82a226d60416c3ec2aae05db9b46db309e2817ce56aeddb36200ee448273c5ebdcb04c25dcce1240f7fe30b8110d6cd693b21e5245fa15621833fa7e347d26c5495ea8978ebddd7d21a02aa37f319a6cd571fd54ff4002920b93cf199e39961dcf1663cef8035f999d06e0c5c3823b7098acbe68a9960b937c63728b11e5860e9ac0bb2e9ae2a9345ced8dfb8be502d15d927b77780cdaec8385c95ea8c35faafb2dd4cfe8d8aa89cd16e149eeaab0c2866cbb8854b9da6cbcb142a28b20051df78bcb21acf8dd3a3839811452857f4154db0c0e4a3e0232a9d789c4ac75a89d1c4a2b4589562519ecfe2febd289a146283b4df66d6e91cb41ea9942ee2137d992eda093cc8f82a6f095afaed574b265cbc425340cdead1e1ba3dc753e34ebf6e0c750811de2280a4d1b6a6dddfef5ac2b717abfbc91ff0c44802c2945d816f7eda71f2fe6c29840ef638a83cc4b7b3f37f4be699acbfd041d392884ffe5cd52436b420a6ddadbd3be1a0fca7fe9bacb618a74b0515eff1285baf7dc732396d1da97b9289fb32a8b1689da76ae2643865dbaa2a0f559c1aa905cfd5eb13131428331fb4dc8f22132ecce241380e9245115198c105e7e10d9380ca06f31d7cf560c68a017c72bdf720d67b260b27b2014f08cfb8d8e1aada055f65b65b687779d9730a12ea4f5471447026e95cac21d38e53b97c5c3371478dfc3ae911aa68e446fa800161085bd656bda4e635766991d877b1baef1d10e8c8f4c18482784f98b1efeb12e62ab28bc70115bb505ab930ca24f338c1ceb54f42fe014bcea1cf47019c3bc261dfb8a28f21049a7c308e4855b261be2268dddad899417ad323ac4cc0c020242173199bf392d89d5ff78d609d6c5357b0da0c2e1e7e09293617233b5ac4117600de810a99dc0d31f6549ffab0a965195f2d7775710115446e5b8e480ff7c261f6e986221422b61eb5b34c251f4ef701b5798a93b58b3fd0bc2d93cabc9b761491c54f0b2e409ddfb45612efe8a84740ab9067af3cb36e060e914104d5ff223d7c1505ab9af4e2a65e83f907fa4bb2816b8c54c4024c33755713c5b707b72b3256112961cc813db8233f33d914481e5e309c48978491e1848e0e8b1aad6b69225b19c06c9f8a8b72c633dfbc98f2474bfc3ceb8f532ecf5dd06ce35d78ff8fc1abaca60344313f3b7a82c04ca98adcefd287ff59330d6bae45ee196cf6445b8d0e2c5ce5e2fc66591aecbaca3d9c964b08f0e7746fc742d80f4eac967ce5ddeac6e6d34becda9e418d5bc821afe773984be0da902f69fd747f2fe9d8bb1a328cec86b4bcee7f51ba06b2faed523d30a0893262078650d026312d8d926b959aeb364f71076ca3c13ba10c1881e2a4899c509cadd46889d3802c3ffeeda056ecbef29fc02a943b71d0e97a560296e0043785ce967a002912d5a0507d90a7c9d670ab032e67a397a0c007345fa8913f0320e0d1a9de9ec45fadac406f732d959b35de1a246383616bcbd0a3c067e076260e37411288c6864a0868904ca35ca4cd4c8934d9bd26a9942773ce25f76d224567a6d700c27a9488d6884563342140522bc71fdc652e031de88e891d7869923412d8ed37e0c27604481a1506f63b234c922a5dc41ff5f2fe3051d2d6661fc1267d976a2a551287ca6eb811f40c75ecb0f08bfbac3c6473dc06fc269777953fb79725349c97ad345f18382734edf45fb9c52b1561d892d2999a7fd4dfda534ea4aa8796f546f1354eb7927949ee0ca8f02e255219ba69bd5f55ff5a8bbc79d1a2ae67b922e4c97703420f2d9adae211aa0342fbd68bf4e6a981b44fb10c01eaaffca16b5f9cf25b5435d62ba2ae618def2a45552dcee1bdd9dced9e7af4b6abc02dba83045eb7d7c17f47a72320fed7eafe0dc1eebf051e7494fe7c099d8b8da3d0baf35e2acab62cf2325060ab3782775c8e8bd7913f5fbf2d57b72999079baf482611d1a6d14142ba2d1f9fcbd148b0d5ccc915566ef5bfa8465b169ac14582762c398eb8a9c1fab04a81e0f4994e544d0e0d949c7f313a17b5def88e33a6367d9a5d92b9c4a061af2b6718f90c27065ba62fd4a4c1f3a2db1f0a0fdb69f384b886eeb755d45d0c7a41efa757796996b7426dafcf617b4669157ef419d99ee64432bbe1623d018550f5a82ef15207576b6d4dcc0def79bf3030b63597695ab851437aa6ce4cdcda2279d9d1a840bd655d95bb716f25234edf166f1e63240a678849da045d654b151bfe7ef7f5bcc37f1f51a96cf9fd3c856b9a855783976b65f89f9f5cf342d3d6acb93c11004f4d440dd82b51a1d3baefda3fc6bf3cfb36636d79afeb5ce8e579afa0dc395422aa0e548ea9c5c488d4fd246dedfae9a45590b135950b454480f33eaa885221d89d5a60005c25dbbbb9d1c2585c4862e6184420ee22fa838061bddf7ecfd6d7635465ca165de865ac4973fb64f9942d64800844dc2a02818400ff0e101177e8a18e308f39f07d93a286ff510a6bc90c8961bd3ce869315d823a83470f91686bef0e20365eac68b0257b9bd50c6280de4424afc2357898ea80092b24d88d5f0d111ccca2aea5b6d10049504fe67deb052d7aa9a39ad8bbf5382298584493dbf4496a1570f4798986a57f17a0883517766c791022b1502c62acaf74e221d8a9cabba85727d10d23f6fb99af2a1ff11a5513fdd624f972fc5afaedc2531975705d44325a7756bea2fa6d46a95b0b24a7d89eaf158bc0a0019e179fe1a2afdcc05f4309fdf9e2b5fe7027b1de4f942d3686427a8d174df7b2874de700e2dcb33e9d0f9c376e51f3c081bfcdaf6437dccd606e84fe2109dfedd755aded9018576e0e09e007522d0b34e9ac53ce3b8ce3e42864c8fe521bedea18ea4eb9437493f05e4041b270720c60ede4142bef1e3341af5948c1c87723a22d3fbf9bcf278239c239d43fd7ebc2b13f244b6dba085a9b2db824c3a5c7f445778a3ec30dd3d296d1613194b8fec41e8079e698913994b15a25460840629ff5964ec1e1d9a2091ff3a5e4344b63ed0b97ac60b6b439229fbfcfb1d8b9ec0dad1a7702a0a417be016491f86006f0d8bf12405e80e07a72a276606b91ab31908ca8d590b2e55898906dcdcd0efb0808c7e8634c3323256ae1092b3b7287467f78ea183879df68ed905915e807431388ab550254b5fa38ec8a9a4cb5ddf671fb7b06544fb7f5649f64b987492ec1f4aa5bfe17cde0e51287fef1d760178d75040a3b5d3892cc04cd96aceb4b838fbbbd3ccaee943d89d9fb9ce25989e7c63dadef9cb9bba70b97d6acafa4bfdb70eb718eff72fd83e9b4c88681aafa9306dd6038d1e7f2c045c8712379c6990b43541a164228f88889d9f87aa80e8d1370819dfc38d683034e26b3e2cc23a9aa9d69589b95c9616f7e3a65326c4ed6169d3cefcd7d3fe3ba3eefee8780177224da0a862031189657a7929a2edda7d0f859e8ddf10839dfe798109f27a8da64b8db07fcbeabb04e896ea3a4ab0d2dc567a33fba1f10faf1215ba1d46eb8b75cfc96ec8029a3bcd682bcec946d58054e1302f54d54abba359a2eb09275567b2f55527d32440055ff154ec6d92fcd07fc3495ee65575860fe63c5e5231a7baabf2db805cb8d796562f0c48d0cb4b314fa7e79627707360b92ccd06b755bfe0a827a9dc3842410cfdf3c9dd5d0e4fdfe61b4253d3abfe99aed48673365576331e35a2e23a38b0c8974acdab8429ba0306ad39d89dab7f35f5d549cb0a42498684214b371d14b1a8455eefe05f96ab18beb925e5946f0498753f889f6dfa45660d99f1d0f91ba2da2f5ad084e50b377763404701029058980d0c1699acebd4114aa5930c8400d4f9c3b7877c1310c137d13daeff425258ba4dc4221aa60047d769fdef7d1bb3f015ed6f2496224f8a691f23246eea12e679988c3d36c8530f31b64289c5006d5e45f8ed3756417f2405d614ca363d6d99243d277256f517733e668093e9255b752cde607ef177cfe61dacc4b493bd6fd6c4cb308647990c8820d817dba451183a21ca84995f75958c59ae990f7fbca5261ca4a1844520924d3c27336e6e665521261626c03739f057ae1170f9068a60df7db9bbe5a29c981801eee83f08f6fa97fa3388630eeaf75a8f719467530e5937b5f5da40362d164d6db8c1b3ce9ea939c690b0f83f03851f201e81d2073581513d8117681f3953d56989de38bac347c6fe359ec518352b08b902e54239d26507cbce6bb0a8aa09d35fe2076e388bc7e8b5398b4a08616f708c2c74070f87bd0ddcb3e73e374fd815149f43b08a2b653bcb0f7bf9d2381791a60ff2a0b48b89c7eac2f887d5d4f16b46b6ce68114ba87bca1802193d326446a75c91225adf33f3907271e7a22db4cb8f9be9e33894c2bdcff9a5cfb71415fe03a0fed05e3eca61117d8b46e713457d8418cd4113bc6040e1e817fa7f5570c087367c0388d6a5d8eb1f254da8b234d41111520065c24bda65e37098c8fc0f6522bd659a5ec4f6727a4f6ee77551ec18bf37fa6d938bae18badb92e151d53ddba375a37b01379b03e9f0556480f89e4173e449b5c6ec734a659f12b536e178613a971e80be1a7f0538f61c5b555876d08f5bbd791620e50c8c9106f86f0e4b1f5bf70ca1fec712d388a500f8ef93d0df7187f3ffb6b7e70f4ec50f6529035caf1f00a15bf1d00737a33554dbbfd60037f01490b287bfbfcf823dbf42ac622605fb1dd465ae8b69c2ba0df8917b22a0183a13ae226f49296fa205383f1e800ea0650f8c0be192ed20ec39a601b67ddf80bdb52ae428cbecbaa78a21c3126a513963db982da837a51c02997497231aeef78525a20e5e083fae8c6a44912d13347c03b66b21b3d42ad6e2924bf8695b254d257a3d11a254da659f2130a527b8d8cb877c1cad151d23f556c2e07e4e7da73a51a262195545c552f3fc26abea0d2f68673e57dcd0989997f2574f22e75d76271642efe775da66f2713e65623de090ee7c5542c238e666fac4fd5fe2de8acb86d8770abae86c0d466f62182ef37da0e97b091c4e1331880164b33523a6160fbf2821fcf5852ed87d401d8160de1a9821a576ed890c5f3bdee77e62a25f36c68fb73e5cd26e673f554b03ba6e6c95131096efc3b3447148f8adf4b1add726412aae95698d0d447abcd52679a3643c2be685740f9840837d14c9f6b0301efecc714ab6df53940f3cff5931034f01ca80f5cddf3fb759cd06b4cf479a3ed88fd1be70d4b87ca17279876c0029344769c22c3663185cb977df1dbaf35c538f5e7379f14a34d4f8a75ab3db6e452d005e0f536dbd795e4dd8293b84382b200a2f242b95bfb865567d14020c7afd662d69c9357c1ed35f31e15dd5026832670ee804bafa2bd4ebbd0c29a0ee2090c67c7b5b781a41a39af7814607ddfa0717dbfc07ebaf53c50d328bf8efbce843e7ee9ff664c4a67e2ca99a1240815d07ed6a0dde24726432018ed7cf362e3d82b3bf4a39c8463f8c9ea48cc63d8b947f5d2370b384036d426e3f219b18405f05b28d7d87ddd0e8229a6e5e77b5abd6cac1c5eed8cea62b06da8fc747c96c4ecb3a33e6a559e20b500bad3d46f5663588f1d8da839b886a34d004ecd82fc79451ed4dda4f79ddd8e9058c49373db1a0980b7ed3b297ad76ba9e09e08e4dc8beadcc4c746bf994966911b3e652f35218667ff92183fcaef05179d440e49033ba6942f5941d390b1ea2b7e1fab305d44b711a8605b561a3cca517185de6b101a509745c13c42e682bf68b58b57d803fde9db0faf8d8520b2e363215ae4763c41a21d4bbe1decd2ac8014aee0e7d1d27760f374c0a359d798a62d24f4ed703c5a5cc849d9d2d2accfe525adbe2286627d21d5882f16e7d35ed8605774f8c810a39ecfb899e37673c2648103432faceeb6cb10a850c6b6f02519642c23704f77f06cfb594014b875529dfc09e4166ed0ed240b70b214325e44283aa3aff2ebcfc7b09c99b273c0f6aaaa23dcf153","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
