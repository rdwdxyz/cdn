<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ed0ab84f4fc06671de05ba76a454de1649995a045aae9f97291ba513cb08881fd5440acf32b24efa9c48a41f50684280133985248b8b2e435ae72bd8928b9c8978918c34f2f2b4792c6d33ce84fdcdfa6fcbdd5f45c44212cc247b08f022e530b98e7dc6d58e0f6a633e1e36b0f0c02b97a5a5e7ab73ab3b798886a9ea9843e373b924c09caa4c7ec348d40e058761dc0cdc88159a1d6a0ed229a1c19fd5a27ae861519357fec12e12dcfff3ad2d4cf2a9b191ab6134a6c7913ea544d4b7c13b78418156a219886cf3bdd1234fbb9334ba5a8cebe8621ea30caee183dd76ecae0e220c07ae8dc02f21ac8e8fcfcf8f00f9ad9ca1e6e968f9717db502a8e20f1c37a79e4321701edb8b1ec0cedb09dbbb6de90d5e3ad236d5b3f7c14eca926aabef9aa95631a692ab322d5743e5cd35227d8637e659109eed6c9c52844397fcae33924e83ce5212d069d1f31e7fb828e8b44a44c83d967318fce168a1ff9ac7203b916c2ac1fef3eb063b9f951adbed1a3f4aa31407277b6a139cf92dd8557e2bdec2dcedf016fd85d756530826f2380d4e2d3c0725d588235997a41a152864da02c6fe324b32a682cb76fe22f4e2138a14fc477eb7a57325514b31935a2e87229104d1a0a83d3b676e5e5b97ffde4a5d8d70388feb4fc17919dbd0556be9dce2a8c1c98004d7c4b6a5dc25c5f7fb7a75b24f6412c43b603fe417d20b80bd5883333dfc64a0dd76e81521ac5451b354a14989ca223726d2f7639a6598a0d17f6bff33c37a33acdcd0692100c0a17ccc84f81e904c64ed28e99b6e65033687e539add931f7b4203d74721694fc2da5e45106afbd30d4237f457117ee0e53c8929c06eb6069777c76d22fa48c8ac7b3418b98add40f01702e961909aacbfdabd9c7b4a2c0281b1cdc73a8acce6497f952a1bc44f9678f6be07950b23e3475bce9cec8fc1264c5e87ee14cd24dbe954436a7438773a98ea8cbc654201b052aa989548c38569ef0644a110edd5eed499abbefe91a40e89b9fa4c753362187d68145b0556d0b6e5a1874759769543a462e7f213afe643315465764346009c976b7af93515df25939f39a221be40eff77a5f454167507811afaf0da69491be0517875a6eb32ce09cc3dee2e944a58515859110f27106db80cf0e1b9d66d4567b851f10536cd84b27f66cadf9f68cc644aea618beeb119467d3ecf88dcb9fda2edac253e619c1f7a59dacbcff0e636c185684a91e2a7732e4ec64cb297090885c56a70508fa3736d2e0908fbb79a139e909fdcfa584b379d27dfd32c910d477bf26ced549f417fe0b478802a05a8a4b11c9ad23e56b4897de9076a0a15493cf517b2dc372b49c9a3e3a7ff6ce72cc8b0d144502656b447f88501509ca2bbe0553658cd55a20a0003a546671ec62f342a2dc265183ff0e41262a2f39f8625101220733b4a4b4c6ea8730cde9c30d61d5e8c9a29d47bbd2574a176253807d77b932e3ec449e8a4febc58c96af9cb75673724e886c25b3d6a87c94dfc300c70078337942832e1849807ca9318b99238b7154e6a0a26ced614bd3ac445be8ee2c01f3954e3def5f7fbb60b7684a377a979dc55c70342a0748bb4e60e907a835a6b9aa2f0bad6620bc9943dc31597b486d33153e4e4e6b438624341a4163309efa2d5657f3d8ceb10c52cfc00bda93dcaa86b6d721659dbee7b3547d48c6e911d3c3729f3d8bf53540046af0e038aca34eda6ef302e423ea907815aee65655c4c35465d0dafb34f779c48aae3f044bd8fbf095fc00f2fe92d537817d5b2a5236e304035d59e867c063db28d309c4cff976de46840e82cda99a3bfe54ccd8ce19feb519fd64930487ccc01eb8753d5a2979cb21501e01d3103cf39ea8cc777ecef5793de991eac1d2c978350aa25d4ff61e7c9666faea6135e58770da19f00f35aca2507dfb33e47ffc0c24cf05357d7e2cd8fd30de5a946a6477ed2aad7f0817ca620a35cf4f25b944d1fc9127b3ad5b1b44eadf7318e318bb71d836f3c5a7371c27f6414cfd20773bf18e8303dafc37f29712e2ca0e1cda2ee8eb6cfae808ae88f16439cecb235bc1ba8585394da6f6c136c7903690a58f7e0a4228d2651e9a9fb747bb2ee3eac50ba3d9b75c08fac8bfdf71a8ff8fec233412574d60c02d760394e1f7424f8a8850982e9c1850cef9d584fdb1a3d8350f678a65531971c15a1704678709d28f8fcf1b987567ee63f176c4e76f0b78564ecc5c464e82987adeaae8900c013fbc86c1dc408e34d8ac11597af4f7bb6094a88bf1b411e2510325e4551701c20e3c8ce303fb52c38df430014f8bdf5ddcea88e4c074904d48ab54754e004e4b19a35548b42023320006dd715cf1a1d71245272e5242dc1ba0f14371bfee43bea4bdc3c0784b1a8eb75782a7882baba4d119d3e5474faa1c185dca09a4ffac19b8e28d54cdc74682afe337cc15da7cb859cd360ac9220c48aa633d42d211cb03de569b907941e8cef3e7c1665b9722291828f94e583759e3779cfb4d240503258db191913197cc9adf93075fbbc3d8690c476a01a3175350fb6d7506fabc0a6c7c4a464accd241f7f6ca18f8f8ed8006e4bfdb4e4b38f120538fc637a30737ccbc430da4e5301c68722ea49eb1dc8974c0ab98c16aea9f164432f48d22f92367bc9f986977705ea6b708d6b1ec5cc09d6de287422408859c68af0855f4384660fd73e8783abeb914ab6f0449451318583be6b8ba55aca2cc725279e24b5dce32e8bd483caf97609d368d1688a66e852c6abf45b6da0edd3f3fc4448d4126d2c509fae2a9272991fcf05b2a96661c40ccce728d627fd0471a80cd665048f532cd925327a856f4d12c6270f5d2b1803963eb46b2b359a2ab856cd87d77a23f539da177923479933abfb3c26138ead679a5cbcc0e8716dfcd226bb2c67477335ec2fcc7cfb66e7b29ad5c17deb9efc3c3c0ac25a7f12d9fb94960343d5552530a8101aa4009c11a5c839d02c153c7ce8e73304f41a28eb353efe82e1956d634abfbe5e52560dea5e099e465f831521c54568cbe4cece663c76656dd2fb3deab0c262b9f6d9cf40a55e89830e64bb1d0fc083b526b7a54613e1d4b60e1a0cd9e93a9abe7c9c48210d680247eafe37292a188e6c5e2fe22d3b256149e158b775814cc2beaa32ef5905c2518ac74b3ca6a0dedf031c3010ad0fc89847b80867ebde664e4eaee34b25f527124aa8bf0a32629dd8f0712a3192e80a868a30f1f63d8923027b49aa746b5e09d2217b4506ce0ef80e050df96effa992bca6ec0f32408898002de2fea3f7b63699ba3435048f7201145d59c14044471e23e3a35cc234f21f782a1ab67701ec01622b2540767c88521ba3254dd234552c63d40197494e141c9c696ec794e27e949e03c4e64b9a707d251a4acb89c1e54613af14539af8280200bf7478acafe6fb015474b559c8c48d8b9e63016f185fb446475c54b7d23e03b02f4bd44b05f01e0c6367123613ad249cb2c2c046ef61614deecd975434ceed6b480d166a2f1cfe18bfb7eaa5cd8d34cae346742322970008999f634ad40b783af510804e307fd6d543b3f558c9948792d7f48000ae651057d95f86dbc5fea073b20db1bc40bd069b9af8bf7c2872060c99580fb2e465308e085dc11d447e969cc029f373c99f0746e2e76737843218215f61d848eaf07b870c1dc2bfb2e0c6c0d48df8f48ee0ec37f07d02aaf90dd455af03e1589ea45a5102d2250d7036db7d3af472192f7002fdc0dfced9cf2026700df9d1f662854ec71cff2df5214c18e2f42983ba501f79d274b4715f8f228c58da1e8b98c470a2ad6396dce0b9340d0d3164514a8309c003d59f40518e34ba805c728277c14b134fe4d7911d26234091def1ceb2f9a7a126e6afe4b3683f72ebd755bd1982da8bc162f1b896f98e1447ce590be47eae1c645a662d78cd87c943b05232bb14220171fb763cf7d1bdc6c0ed320a0d58048f5579451fdf6f48798a8835f17d03ec559de0920fab07dba6290ba3343da5a843eeb0bb6292c3f14013eb0de15bca0d574759b69fd2cf1a750c2ab5eadc6e214f31335bb539f883db102aa8ddde6e504a771e4b183f980b49c20ecf9b8e9aab9d1da7f2ec20dc3746dc9458e28c3efe38c1054630dfdf1622822e2ad76781e1925bd239c5d3c1e0c56470ab6ce9795533840c56c4f60a5f23ae018f636220bec0766800e8ba2adfd39750952e642c831db964628488cbec1f5bbe3f6f8f31c00752d0408d245c83078537e444fd5a796e988e32dd1f2ada30e0778adf7be06eec05c71e5e2288e7be2e191a59ac9507ed46b6e21aafc3079ff0640095d02ce377cd6ffa022bfccca57b920700300cb2219a026c8ac1c8d8ef27aec8bdf98df4ff7ac076fa6e79f7aed58c7b5e3ab81582fe0870a021155d0a63ba6390a3a1a32206067da15bedbce5aca69807125c863ddd9bd8a5ad7a531b5763873a7f05d6dedf7150afadeb847ba82a64780a545f77dd3becd9bdf1f37c1ae45398670ea4c85b4345f703f7c31dd31323354c86cc552a9c644fea6e7345a180c69a0113999a7c3e61102e1b50ad6e90855f2cee9107fd17bb0ce7980fd65f503b6429020a23f7d1e84ffc432a504bdebdaa32f8d83463d9d6280b9d3b9b14f067d3dde5a5d437452a16b6bf37bf461038f8ad3851178d0b8f2a4fe940105f4f92225d92b9aaef1eb7bf56e3ff474c3161aae86dcf4e3cc9c0df0d281dadae6c54297d207dea3cb223a28c1dff1fd8e3776b660d3cd0b88a48cc9d3a39e43b597b34f229bbf87ecaab4d04d053f97b4218e38f76944b0579130f1e4a0eadbe373ac47c87ab69439de50ce41dc74eb00d763fab96695269660afe16cd1690fbaddd51615a240815df04a04a9d7633787ec558d0a74640517de7e67073451ad3d0613eacea34d1626e3e7da21e1e80115052a6ffc5540e63f2317d6ce1bd7c4290d9696fee8f60afeaa9c9d70cad8c61e8e593e7527d3d7a8c0fc95a7c39a4c4a47b87ca223a721af8c307e0d33e51950030aee7b6d878f9b5ec51838c89a96515f6a45f0ec354d3d3c91c82d27fddcf35d1efae9fbb7ea413bcc692c7b3feea3eba7e7f432f169d838d412159d3d5d8e290a1d17dd5923ab672fd6743f08904c87aee802fc793b19feb7febc8cca462dc693f8630ee182fa2c2babaa3ef645fb8a453de1211a8f70ec8b86938ff08b03226a8567fd034abc4a271293587e46210be8f45d5092df543859c864a391408674f888410ce605973113195268971346d02e42daa58b9febfaac6053fe58a257b8f4dda6023c5776a43f5f566ce3b00efb887b5e03820ede14653e7e060f7a19bbd077821317a24cf44fe3f466a639b47d6491c8d05304ef834f8867ac03203001b3df425df6415b4662ae9eb4291bb19fd87cd2631ee266649fc846ec58b5146ed0712527c7165f3c33492da5cc5125802242b15accc9a3094a50fff8e3574b89a2ad1450655de6705c8a8a5230736e94f68c50bb402c869173942cf328f4efa079572e09a6f092beb64e100d503fce147d8abc5454a6436297c711d611f231d07f3405b702b803fd2924a007b37b4eec0f3557d35800d6a4bee2f944b1004b9282d80a9bae68d0060a198a2d97ae3b34496ffe0dc658c32d3297582bad90a495b624e43e6e547373800fe6b66c1bbc48e99964c2fb926250da189ee2cad5cfa73de97522ab53ffd5ebdce744d09f197d4258dc4311698a5295807bef87c58d46edc1bd4fe96bfe55a68cd4b79a1af28a4cc94990c7cc0686ba13e2cfb90022a175f5f7fe6c00736a2de1ccf756f79a57ce9a6f9eef36a8f619f7faf2bfc53654dd66917c2a9cabdf11d96711301fec503d0c6aa46eef0df90e35bf208651a79121c2f6420c5a1d77f8907b78c235c020abf820486f0b8357e1666bb76b28d7062814d557a1f592137fb5515186579c4b19a192a6c7871d32a431ce6a2ad0cae48b4b0678d3133db77e07cd1ee6bee0934e20852c94f2ea8753243b3426daa559f5e504183eae52ecd994318833b360355386ac5cea90f9f8704593e39c396b1222cfb3d807b0134d5620caaddb231ba4145a6ebc8e304056f2046ab0757e2a7c85f34d5f8bc0dc2218bbba75933a5851d27fb517f077a89576f3a3ea63324a1fecd91fadb1d5bf0d9fdf293fac14d11526fef0932128bfcbc3e8796d16783b7e0e9132affe0ccb8c94fb74d650ccbd60cc5fce6d54b93bdb4729596e49769d4c3e73110ed237549bdbaca43cb08243ddefb0f947850aeb5444f95d2534dd6d28b756f0a3dd932c7cfd647b74e152ec874a1de787ea29723fcf5e0ee1d391ee724afedea6f1f3e6bbfbdb55822de7464beb4a1eda0bdc2a46e237698793b7829c89a9cbf441f08814849a626ed39dcf503628c0608e27ff51984edcc8ad26350e84a376c872b786feee9ee23e48748f3def4a71446802dc47fd78ea95a194b775f80a43a50b59d6af7ed8bc70fc5c265ef098c9c0ddefcacbe12e7ca7d37bb37fb51257934bbc75cc6bfb2bd0a9a0c29166b7b8b8a4f22a4c201ae7a867b411df9b3f177ddc58270d1863ea11099320d5c071bf6a86b56da83cdb9eeb0178d19e12fac0b2e391221c1c8d31b032373d663b782d38abde2795c6442db534fd965185d17627842e13427d3a363385a244265a1ef508916821ca69be227770a4836f1680dd5bf543b32a002f15a17dfd37eee3eb41228cd4f48864df0b5c720b885cb1fbde0c83c6e1e4f62006f57a86c96f5f5f2a9696bbfceafa71bec83f4c5020eb4f22aa4d842eca8ea8103511a24157ff807397909f3b8f2f756fc03ff18e7c37da104e3ca892db143a28fa27184f8901011d53bc9e76b2fa191f27e4ab9cd7eb2cf8b743c8d9e069b415111c508087bd7f5450c7f70970deb3db2326fd021863be9a33a2f95f20044c7fcfb49cfa7226c7bf3f01c6f254fee67ff7d4210ceb298ba5f40ae20221fcf9c946110cf416b19f10bdc24ee1bd672530a804e4debc0275762a515d6c46985fcaa4b906b369f384422f159201f60ed5554535a9a9bd07acef024771b3daad66ccd8f4e1ec1de65bc2910458016e5e2e7cb84b8597bae14ace3721b159182a979929572048117fddfe9815df384c4eab77c6eed2ad05609454f35abb2fdc46009ea24611e247e581718d5a162bf68fa9cf24b4953e4c824df852d97704adec911046665faa3d92845883391988e7793e74f528ca980ec7c3cd23688e81031aa9397c7392c11b58858df76d7886199197b0cee920c0122aaac683d174f04d0cd8d6a129c2fb5c0fe3c9efcef2b21d306820ebf0adb8942c317223dcf4193af89f352d4ec50dd0314e3798ec72691c1544a6ce658a714f1f360ed781bf051071943c58b06095a62ba7186095daeca3300d34cd12392e45a32d623f140556bcb407aaf94e5caf3e68c84155e4e170fd4051654f90d1a0250fa84ed5439b222d3bfb70cc2416b7bcc3e63a9f8af90cc838543b64574b7bff30e45c4205c6eca31e9a567aed0a01d630fb06d39ee45e86bb8e0406d4dacdbfd70fe998677aeb98498a9e4becec44cba52583025053200e4e8249559a89378e66fd583eaf697c389bd0072cce0b279945481568a5b4b7812254342af07ae54f3c844da464877f3d6b616e79033bd455e332bf2fb663233fd6cb5802d39662a6473de13b784a7784c4aee73f806fa95f60e4b7e8d94ed6e80a08bbd471b12bb90b0266d3f58f2ce6680e930b962549eec57b6eb66bf14cd6a92c7b5df6c31e63f2404ed7e7cc0fe0983a6faa9193f740ac636bd6714b4ba3de5f18494b60daf113768de5a6f3a62d01ef2e7156f8a0014b8a8bb6bb9cee5e33cda2ad6e30439ac35975e36abbdae9a57dce02a0f77de0387b49a36c8e7c4c928ab1a003bf3e9abe9106ee84f7f6dde8ec035998ae9b09f3cae96aea3a6ab4f0477efbf476f6d51bd9a6026c75e63dbebc0481fb4d81988966a0e038b67732fa65e19e10450715d101e249313308cf1fa86d87019003ad6d6adfe9dd870111ea7aaa8545b487b7437cfc109a6371495d6357cf992f7cfcc8f9fc8ef9ba9ae3f387cbf4fcbc87eebc3d576c72a247e00d90adc84e29055ce40d94d6bf70b16e4dc09b6faaddf6277048a3f21836b6b2da13d8300a6faf9c7a8945c76041f5fe6478dc739d2bda9fd14a4c043aa386ddd88748c705e00c6b6a6cd620da34dcf4f9abac05aeb9dfcbfead70826e57a522f60bc4b4396ebe52d3887a20056cb51ee390595c6cd90c653be4574dd129af48b095a803428154afd010f655024abec89aa26d1e2bff32b983178276847fdd30d3d4e756551228e88884ca65b1a5de8546f48778421bf126e8a88acbaed3fffbcb36cc440f40c9822eb4a27a156d97849da4ace9a1e003617a568e49bdcc7ecf9582880a4b5fa73d8a982eb70727b9097a257be3c0b4c04474b06581d3a42c5300fb50e55ad8e7d0a426c59defcd85dc46c34a894fb8702825b02ca388989a1f5e64dc662cbd0454ace21110c4ef054f22b23b8247beac07ab4cd47af9eba6b96e80651e56f4f216c8572a8ff93bbe6e1988ab49a99c32e0f69c5e945e980f80fd1ff9c3dd17f909b7e4bdc32d067d0db9a1c5241934e95b10953c624cbb5d00863a10ebe667fb4e5ad51dea6faf7b1dad34c6f0bda9026d99538567d0ea8d8d1e15e9afd909c461c196cbb2ffd7888143ea12a9e1f33299595a9a016fec0b734d7320b8f37ae61f33919d97d5aae31bb772365d4de6a3c84bfae3bf9f0893a494c9cd705a0180a91bebf5fd7e11dc2b516a0738f9bb084484df6727729ac55a4d8181751d9da4063959164fbc490c4602559817b9647f47cebe0a9e0ddd7bb72f69ae445124e8efaf9d1266c8b5acf68f15a73ab3d5522e691a12e0471f92bbc22162549cc719514f90db82989b69be9b39780670aa10cc319128e66477eb9e3030688321c8bb7fed5bc52c58fa1bc3ecbc19c04846ae845e4b8e21fbf7d887b9c31498f989850e3627b072995518fc1cc95019bb032a3500755b549a5d924e517042a97a3d6c72da13ee56737f572a0cf205319516c1bd6bfcf325ba3ce6250390485c0dfb7bd28e6fba1dee3a18e634ca0604139394cf1c160a2c61faf22ad99365df51912eb8d3fdcdb99d21002e943de4fddd7b23bd3b72bf29619fc5a1b5fb19a01e869d709003f4f2e62f7413072453970e64ecc1bc35e9d0da3baf8a0a8cf78e9988dd8ed1be0ae375719995ea6b52ea8340f4f772c6b2a32318c0195df6f1b30cb76b45a935e6d684a93a0e35f890aa87ac19b39ba76f42374a12150a0bdcf41f26ba2ed099d6ea5b1c0bdb107375dd0cff5a3682bcdff368a42f6e522ec2ebc16c020e9ed1840c3077d9c2fdb6731ec56b6ee7f5a49219e404b5cf52be644c7bcd2256f83427cd3451f1726bd6bc0e2ca689af4bb5b15944478391b63da38c04b5a755c7899dbf2bf688860ec943119bf2ca0ad0cb4fadb8ac929bd6e5d64b38e04960d74895d1386774751afec0814c9c93b66ead1cba0219b631f5c3b1e393ca22b486e0d2685b54d8a12d2f152d07857b721dfb0e8a45a3a2fb3b522ed997a8946a0fba55abefbc77892a2d13a2e4e45aa79a9d77a4d25bcae67e7e53121a7db014463c89ba0d7c2e651baf9992c3678beefcb10a2ae9a49df651a72fcdf2eee21f1c434039df52503e97e3e576e8652946576aa22fa1718b8acafba4893bf4068fd86811ce93484241770415dbacd5543951e9327eb69faa4f4e7f5622b0884c71f7cee6a12be90313c4bee9ba8f4aca603c7ddda95d722b6c31f37fbea338ad311b60b71713df1d35592057eebf24382f2139fb16992e3244ab1be8bde06e0917c528070c25af19ea7bd1dbe2757a4f405133ee12c87720d28b05c3f82637a3b57564e28b53e107f519845669ce80bab65e0aa9b52b2395c1e6246c2ae9c75656d6e9193ce07bb4646a50b58848440ddc53b347fd41dc9f6c122dc76fd7065fbe6b16397466848550cc434e5046f4c3569484332c12c8789f32fe532ca4ca5735b7c591b6d3e89388be2e34e2dc94e0cabe74dffe01dea78a51b26ce1544ed8c056045a360511feaa3606ceaed60136b4cc2d026ac83e570274dd54d4d360e056e6f56661363645c9c4edf155dae554efd38bf2983edf6fc4806717f211b680f79af8fa94373d74c34cff216b7a57eb28ab695a22931c542a0849e34b0840b7b4501b29bb71d8bf3fec953c9c8f59c0b67e26dc1629131e1da2d975e88b16ec77f1799144a0774b5f35f912b1152f975a872c050f3e2642aeb0fecbd7c96190ea5a3346c1f57adae348810fd5b8361e91fad649b649fecb45b6cb8f0469a562567f08a2d6a8b161724a98a7794d9e300dfc858ffa8fd47915e4fbe1e4b99fdce0eca95c656ef8affcbc43cfc64f1c548245de1c1b424428201590a43503ae2931ae6f70fac4d5e89f780cd211b2401599a62b550aa016e01b2556d80ddaabbdd171638f46d9557985d09ff7e24b9ecfb69b1c749a3dfe1643afebd4f99cb4e29e224ef29facede597f362e566f6dfeb463a7585b48958ebd51af2af17039c483248cf1b12e4a726378adde1dac455c3cb5ef71e59a872481dd54ecacef40df0b072d4daf347426579d542e5eee7d6f7b2613862297ca4f9c1b425cd8554e7a1fb001fa4a63e42a2f8f3c265c2bc675eab49922eff170007d138395bf338b0138d645fe8426b2373f8826f0f2d258de9fe7d1d957eb802b2257cace68592d30150a6b17dc021d1407e7ebc75432c44e65874a081d842443238fe46203e7e2898f27f3b5050794745fcf066eb89d9eff5c31d9efe9861c472c849a70cbdee8d9978cf27fbadcad614ea6961076277a78738f01b174de018c157964ce89d5b866f98907a05c84d8d2ae04eabb1640b90f50ccfff02f8e0f0eb307248f03fbd99abb45a514630921fba6236e072f4884407395e3adafa0a06c5f6eb59abe261b9fb20f3f416b33ec73402ae93e0e9c1649046c7f8d3262646096a2d96f35b9141c7b0eeb9e3e86c7831071552861afeadbbddfbfbb14eb73a5aab06de2fd6f49c817fe9c82d0ae9496a3c4dd47d9f84abfe44350a406882d0aa651ed9f014d4f11680bbbcafcc8465d25efe36948590a796983f14a8acdb8bab24441acbdbe363d68d757b833253dd34199964c94d525c8817f0f0cc1981cff03418b6c4cbdfd0b9fba5e3311c2cbabf238edab99f9991ef2df2e0669c396968ea73f8b06ec7156fd345fd40fe3b51d1b4cf95b461e82c4239a7f5ed605ed2e91e85c571881d2d586c7fd4a59c463c79824ca13f8367068d9fbd2742295f25ee9eaf6ae59e26a26f4355f55f251e1a35af303d43ae992ebf6e46542b6946173358297c23107b959a0465ab8cd73184dab90d98cd5aec68d557d1af8001055d09f0134741a670a3d6e4d09561be0737a211c6748fc1952c2c926de20317271d5cc80d2efd99c2eb20d629da1f7221683d302a7388e5865ec2ce064fb2c69cadd05c9a20436ca4bdd5f17029931cfc1e35a9d6d17c4345e454cb956906e8383a837da8036e3de06c5c9093ab0ab018f7e863710ca1f781a75f8076b421b357443a04c1f451570abf11826eb2901ea6c49626be865784b15b818b513db0f741ce756582cfec2a9a2f3ac0caf9b70f7a27eefe0de1ac44d26f1450979835dea452a1b76489183658ec3a1af162b9e4476f347001bdafbb08cff63c64ab47d02929824fec2b06390c2be3c905287421f1a59c44ba1935cf81ae3a1e2756cb008161ffe9cf917b92b1ae6f336f45424914179885be76827a89293bb650ad056443ddb5e439719b6513044638adb18e73f26fe584334484230808ad5ec41025c51f584b582f2cf23f2d227a1e6ac96f461d975fe084d8a30cc8428549b3c55ea0bcde70916192c402538b202396e9d94ed525d31f5361a97d35a493523cd0f4326770e1fa5f10e8bc9373c4de4394e13d55ef1fad10c0fcc738ebcbeb5687df34aa1563f96288fa19103e7d89c80370a2ea38d4a33f310613a9ba723a061553751622a23bd6abba1b56cf6eb64647363fdfdd1752b7800d9339b4f746058581a55a1060c377a36d2bbd3c50c261dc724d806d29f1fe7ec3bce0252256a9c9008bb8587c08d47b30497d2209ece5cb92288c7a248f20d1d99ad418a436a59d2b19196a138074209e52185878ed3aecd719648709dd5896c52c41ad187c5355345adcd9deb08aa549c64cd6fef05dc0b065e6d335f8907fafc13e098795524d01cce1f5e5307710938a91f9f1fbbcca9eca90d10f4c428cae1f3ddd2f261ee4983667419a22a3c48bc9f3f5256da260f2e239ffcca753ddd387ab01da6aa2abc84cf6b696e2102c56299307def4ad46cf366c60f311490b8001cee48c95961cee2622bfb422580ad219dc8ca2ebb4c00270b43d4abf3f7989d6e903a7269ee02148b375f2d7f84ff1662d187a4fbc5a019fcf463ae1ce8e1fd99a7e57d131626bc75ec5c1ca77ac6d517d26b7a72cde1e296cef25fe68847c2daae7ab1a0b53948c73fe0c21d96fc7464363580aad5416414cdbae780ff38d2ff06c3dc8f7b32f2ba9041fc5e547aa113f4e8b8f4bef049885addce24db79b7d44802c6595f745b352dd7d9b2cdb710512c0e2143d703015d234e52864ae8b97f8c8f546e8619fa91db89aaf70237440c57c7857ac5be6d431eaa38ca7eebe9fb5130c929ce532ed506db6693b2d6cd774a5a5ba487bf247c138028e26e485c36447b4b0e3a6bd359a567ba50103950b3c2740eb546bd93d06963ef45a2bf7b76a28fb2a8e359eadf0bd79b5ea63b5b82ee55a821b174b1405fab06eb969004f5a0f8de1b5ea1ecf0b24afbcf611df47818759cb78f463db17fa7762a79e685951693cf81679c8e96c0ad909420ccf91d9ddf781b2a1c5a17baebe1dada3922b8dbf0950e246266db72f89a40b95320a71179a7cbbfab6dc09bcf080fc53044ff924a997776b6c651abd91dc6a80275d6830eeb8b9abf5d739221f59d454692fcd5ed65534da39481e7ffb7df45bc1bae2f0548e940b81ac8abc732f838b998ddf19147e3aa4d4f2985996fb32eee24692744c901c3a52ed40b83ff87e9239477a0bb59f0b5153a772a8baac9df35d5cd44e2b3b464e6d1d4959e9a878e44a88c719ea803c77eea824aa5e57fcd1d67e983fec36f8178f7d0d2119037deb27804579d564e4b7eb71f3673d2b658e0b8229e75edcc4ecb5c95ff72e3b0dc3f0ad4744a6007c87db87bdbd6b9f44127497d85d7c5d112406aa8d78bd5eae0f78272a19cc5e61228212f4f684ceb35d8ee4410884f5d0e2be40c59b15a3ee34019c558795c88707a7a1d10e90a06e2d1fbe0d7c311a75f05814b616087cfa1750e877ac5eb1eeee45682d30f169b5e15613e0af3a2e7fe06a09404df830064906e363e343b9a6d6dcf38d6ae99fd27bf61d07ea4e7af02539e3cab7e9db258de43f877113c358ed1fcc1056d459b540c8dca6aa1c4eaeb7f3a8fe42e4b38cc232af9a9c483a9b8b750ec3113351370e5468a5557372591ab68b514e549b9b46231a02dbf7693a6146c55f621d3bea43178aca9b64a4f33087b1a50073dda35281f767d5e73a623df3814d82ed85c3f14129003e01689518a9e824d9a756d66e36ed1633a9a617d1c3718c987061f8b2100219abee88380e0084cb6c19818252be0101c2763c5191751230543a91177b9689e6e26dc808d5b27435cd1664f7ad33371a419d8ae8ce19c80ea8043b1df86c0505085b5d7b803f447dc2d8fe08493c14e5e1dcf116710f7bcacc6844b51ae462842bd5853edd56fa355d7743e25c90ec54383bee3cc55b00e3eb91e909f08d2c79d0157861c2efe81c16b8428bc8127eaf5c1c6d602bd8b8b2e00710b75e1e65af20e6056102e447086d9490955bfdfe17f9558a0f3a23f684982ac2f5960651b1299cc70a10aec84f1c38308cb1fceed965eecff959b68414d7b6b37cab3bf5a1ec9c09e20f76469c74aede1a82b312de20243b2282937544047989782a2c34898da3fbff9c4b6fd7ba386b48c600ee50a02b327952e1812cd0903fd149e55731fcce13738b23336ba82b02fc49e79f559c012b8edb4a806c3598be2957e9b152025336225275ca21a31afa1d8460f3ecd590f2c5324622ff96b339e7aaf12c92a8007ded0d3e0e6aa83ed117732a6c47bab225d81910d4ab7dbb2ae4876f5009634f3ac0bc8bead7d8e25264b7ad0ca712b12a7addb29a8142bcca7e62c9805efbeccb05035b085d219350a29c8aa83bb40fc0298ec294844f0e930dac911b2a4ce85345081112b51fe2ca37f5f16adc5f20a172fadfbb05e0feebe46079a1c017b9ab37b52d7509e21429f5b1a6c748d6fd4fa8742bf3a9297e6543b09e507cf3956d2599a50653859168920963bb29831d3b3e5a06d61fb9743eddc3677bb3b6102d8cc6aa0c23842dc8bca47a651968dd1ac27a59323a99fcf7c7e3d2f07e08de441351af2cc88d786543dd9b42c7dbf03aff611517e20ef1be1912bf375039b4701d1b4ca9f165e96e755e9a8725874b38b3173d4e887749d6d46f6e296fe8006a51329ba173ff3e4030358da7b79cf84567b2154d15e588c8a328aa12713bedce7e73ad9aafdf904c073212eac299dbc4186c358fa29b2d87061c69e81707fb7afb1c58cacab207c001765d02594fb66cc150e9128f481e056b00e3de2ff67bb6bc539708f26ed361569ffb07904105477cf9ff34932cfd65557aa9348cb4963bc0c76dd51bd359ed354f7d9cc81b9c78bedbf824891a34dd3818618ac85674299fafc03e1398e2f78a649d5759a0054dd094f825b6e0bed1136056082a938a92ae2b629d349958c69a745ae03dcd65043e9340823fa4bb5439cad2910ba06861d0798a723f1a654bc91ea05b33cf486d1cb1f9ed5a7f8e93937e748d92e2813749a33cdd8260f4d27fe91e465a1794730cd103c8a8b0ff1c773e76516e026d15dc48d33987b78140a1061bd5bdaa4a64e9bce086e18e125a619eccfc1974ceb70016c4fbda3dd69d6914fe6e6b84e964e224353d69f18fc75ccb03539a0f34847620249a05a08f85c507c0127e0d308b946dad854748c3fdcf75a6a5bdcd8fbbc3cd06b18cd4c977b36595c653926882625cb6ba666e76c4713d20eada9da8e8686d2de84e266aa8f4c615c0ccbe15578f0cbecff27f1d8d1be2cb5ce3c0ff314b416f1b0c7deea7056d7b7c4a6119021a1a6e5cdbd6967c52538581f7bea896bd03de75ef4c34e642fa04986d9c4958492b669e6b4afac5f6361405d8f6f5ed09abb08833f1e8aa6a4842b92f33d8af21ce539af2c30cb1d31909b9878bfe1380ff691fe3ce9b9ac7dd246ada1a111c299b341b74ef75f3937c346d26ec6847d7265be726ebddf7ff9bd673923b883afcfd17b8af3447905ec20346b74f11b860214f14b8365b7f018f90334429ca1f1915c32fec602eaff2ffab26e0735f649093dbf014dfefbe0543dcabe466492dd5199afe03d8d11a2ce2c316d2f9c06a15e579b6b3e3255fd39448dbeb2aa7668279000b851ac343011266674bc19b3b3e306db3b164997515147dc4f30dec2ae597dec7f9af1aa4023d0599893a16d01ec33af0129910bc2428c75c7ff7b09f4b57f156dd6a1b761020c70ca58f77efc463733cb38cedf7d1ffb894952e3e06bf3883789dde8ac8af77fe38d8029d35531c5b0fb82b8bddaec61d3a7568c97351b405b3bb85e79e8c7de304eeec13f3b3c7573536d08cd0f9caf35049fb8c634e7fb935cec6aae193a3688cf5fd33a160d5ec44d831096600a0ff8c9447bcce6e0c7649676d294949745a046ba41bccb0773ef041adf706425810cbec1b9bd2bd94a918fa7bbc67fda1d9f5e44b8d78b3d226bfaf82c84b7c6ad477dfbc3367e646b518d7a7efab319fb6a0bcb601b2e1d398876216412bf57a6b4f6936bfdfd30a7372cca27499a56d06259a857bdafe7c2bdf251b1ae4c5d5aa15ddafae13fe244a8080bb5072d0e927cb086a5aab44bc76bededcc64df8d74ba217dc48eca9a8449dac15b1a7b9f9299f226b942d4453d6d3d3b599ff2d432bab9f241f1aafbd27c2fb222d2b5c2910c6bef28af70a3341ab408752b283fca09e129942ac48ad8bfba2a35d7d62a6dae4664c30c6a9a5ee1c2bb6073ab6f57206b61c6d85097262738b4e85b98cdd04a96b856d34ef0870257720f4995cdaa8e6ee58598c20706395ca8ff63a1627b7059f85a0f0fc39c3a857cd4db6ceac9b693446a3e09d439751175cd83b721c55bb86e2afcf8f43f23ac30acaa81c848546b57910225394b63b930b95baf13ab12bb74b86edde3c4c1a2d6175c179cdc54fed699204b0958f7139040a0f233d12a98b3cd8af9eda0b92c9cc12135ea5d52675125856d08df046f95cb2d306c057c34786dfb8900ae80c2553c38ade9183783ab44e1559de3d883475e4e397c7ac145f4a528c598814cf086b0cdafdaa23df07744cf353ae297947ed79132b6104b03187a0acc9b97d9a32363480e098b4ed57ec28a494daeb3b60783cc79537c7c95d5fe1279d892cd40b58203f2e7b25ee19fd831555888beaa8d9c2ea77b4715e7572df82b76a30e48138992a3c0cd89180c288febf44ba96efc5b53df84c3d5ffe95478fe2c17df5ea7f2eab97f91b286298d2b33dd59a8d2dc095e9cad196b1c59f78c83c18d88015694d707dfbad530696b2d263fe95b3cef1c1eb69c759878745794fe2722a3543ce1bd9c61090f1dada04ba1b4ea51d41099a51fa20d7a57b447569f46c970da77ae0322db99f317007e072a949d2d3a77a87c41f5978e6d86d0f248f1f4bb14de750485477cf0ad0f816ea18f798de381418714b8d19abbbe0ace752f6cdc7dd87b0a1bca0f45265ee3c9e17b179a35dd6e1f8533a3eb7de2596d9e34931471b7655c1bfdbf35652c7a70e76c3030624469a52009421b945f64221d8dd8650776142e94a4603840e6cf1715f5d99006c9fd1068ed3ee9d358a0821e06acf6d505e9ea65d498c5d8871a25fbd8f90efb2dc0e208c90fa2bf665a722b76d855691d0ba1b03fb71f4865ee719471d0b8ea6c6bf61c4502628dd55ddaa83e6b8eedf8f31b6d3f6c6726d353b13845606b1178ec7f0483143c8bfbfff4344d7f77d0c6ab8f4946cf2e34e97bb71ef81298b74ae14c8d8c9e34bc2acd3256ed8fc41317cc451890c02ab9ab994ec97b455d4e0f92e9765acf9699f46a4c7a85af45d751506169e2480cdbcd659e13c3893357c92817c8b9d897d7ad53c2e8cbba3b120bba9f22032e7eed463e91fba54e24ba20c0165ea5d0bb25cbaee9fdb7a018767b9f1b4e5fe81d5b63705c7590615e9a6f7275b892c3b1acc539d06077d70f1664306782e5613dbb27b4ed4723e74c37a176ba75b08d051e67f3f289b529ac6434bd84e9aa4983ba1b514d5df630e6b6ce6558818df75580e727966b76aac3bc561fb1d0085b50a79b4c9a5c0dc67a85a51474cc3ff88e89f73a830f4d2b871e65508dda70d3ae49ad52dbe07a7f3a2a0328412c4df77157aeeb07166ddb076a3cf8e4212b3fd188c875ac59c35269e0e1074b2e6ad39d9ec65a6b0e15b59ea296e43624623cfc5b0a78798260fe752b1e821fc071294fda40b9c6d88b742b0b638c8939ae32cc8c1d71f8d0cf6202908ffeb0a84a1e5591a3554d8d98c5b2399b19279c996dad63d1b6bfdbfb4776085a62ccb53c2f2df071c87fa670a3900da5f8c0b2e453cf0dd05bfef0c1f375dd2ceff89a63def6b2334e9ea3f93b0a3c656cf6c73fb0bf3c10c8360ba93d1124f7d15e10ef7dc19158aa90325bc018d09ebb5e1a270bece7e0c83c7588e3bfef23a7ff0f93b1c16041785670cf1fc4b014902567ada85cda4a763f725a9c018c8d321f819ee065de33b85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
