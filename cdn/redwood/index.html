<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae49fa9a80df7392f12ea5a46034b108408d4a115e8e10054764ba2097ad516b61e95fac0990775c9c9cc4cf333c53df387d7ac7ab98ce31275df42610772aa86142374b28bfe992cdf1bd1c47893dc89d631c6f1f3eb1d19cf3bcd989fbb939a2916ec84425af8a9046b46e5662268eb7ad1d0aee4c87cb1b64e1dd0b26ab8e89e2085152f7e8c371cb3af7654ae6c6cce563fcdbd9eca3f1789cf3a69795a774e1f98e765da78127d4e76892ed677b0739c249f609881c46055dd2335fed567d24eabeea138ce7d292e06cfaca5ea5e9e9cd87c19401ec4171d39f83da868c5cc8de664837082599995be93f9aaecc7c4e37c72300de38cb2c31cb1781f4291bb753a0477eed68aec0ed75313b8fb2b388e2bbf971e5ede7b9932a9e1cff8e6dff66090fa052da787ea02a9152472a53334a1aeec39cfd058d69ee5eb6e099ac71a26885b58a47bd0271c9079b4867fad75b4b46aa9a9dd23274b156bd6c4612e57f364cfe654560a30e07a8981dd349365f3bbbe4fde2e5e097aa724c4154fa8f7ccd382dae3c3540fd241debcb8406a48f65a65c02aa7838b406c6a749c96441e2908464c5291f31c06d2069e2170b70e65862db55b796dd7f80f571d9532729993ff697b4e65f892e192cbd1cf4ae35bd7331647b77acbd0fd1d7d47b777dad047f05a9e5ef736d93d340ef4fe0837c2da40fb28dcd96248dd44df325283b156f03cd0b3659187e5aad7723e1075fdfb3b6dd9316813f728cd863be68690fed4e8d27834e68fa98e12aff96ccc0352f2cc9336fa929cabba57e2f6a8ef55b5fb67aa9785d4e254a3ecac1cb66ff5d02de29e17452bfbe4ad9973505ed1c0002f6b398be3b248936e59b76fbfef6bc5ab4a74de6514888be56497368f21b99322ceb18b993f5b9284e2cf39879d3e39c84582b063643d94ec03bf37dd636db2ac8921e2754a13ae8df69ecb9198c8ec92eb1de8b4e0acdc17871bed54c1e513188e7eee97fcfa09641918e1b085a8c396b2c9a7a64dbcecfa9b176f8902b0e3355a8b51ae471a5123233b9b1f14ab77b306698a048bee95a1deb03263a74e9f8715b663acc40a208dc2a71afd04a8856979d94bd2043e75a1816fbf1578e32bc05e39c1cf01b310501639fef5554edfc6e93de2b107bb9b4c0050a04c797d95296844d15587c8f447b7eea3a7008c284aba38afb6875bdce4a72a55b9cc81dc8981d4df78d12c1410f701882d01b6955d2ef2fbbd798e610fff5d3332736fcb81ef640ebc4ace2710ae8c0a44732adaf4948214eb0c29581979eaabe0a42349264365694784d6a45c4f3e8350ff9399f241422bd886c99d449eedf54798a32d970ebbdd2e9e182ed6829f275a543ff219734afa09151b77f213d330b09469aab101e29d28faaf56a396d422829da35574a333e068fbefb71b02e84d7bcf655f61eabfe97ff344b039d9ee2b53439b3c1427aa8ad76f243a922cfc239363f80873de9de69e6f0890b1cefc460d7d34683eb46b375a4b5f596f05bcd46c29c331f3f68add1c0dc8f3e99368a0047e26055a5abd79b9c940a18d6010cf7d88cfba515a8566d746bd83fe9dfb7d10bef4fe7f3cdc0c50d889cb3f9aa9114639221778f0fcb19f6f10e2bb4d51a208e7f9db179ddd59cf0b6005e2381c89c1ec709802c6af30d59964a0d8e71a6ca214b72cf56371b39aa0e6d5caa2c28d08214cf1cf6058cae465fb50af923dac5f7ce4e11450b701210e34b9afca605347a6e82ce6888a3a4a3c87f1ce3a2057a3117909fe44ddec64c587a84b8131793d44ca7ebe077aa7715b4ccc2dc2aaffcae4ba4d376441c387426defc76d9bf54aa133ecb48eac71c1de64ca9ab078166ccc684d7ebde28f12357016f55594d26761da481a469644fd315d2b48a1d625df19ff5bf75e9e8786e1d5d0cb94882f173c5a3bece1b0e1205f1b8abbe987ec953bbd16f7450f4a309f1f3c5725f1bf06a5323dcf0d40df74d7746601256c1870b12e13fe0ee6240d0871c6fa46210da4a39acc2c70583489326b63dc29247647fa4a3fa7c801ece2ff90a7347b9618b1f64f947348a692ff6d2e8fcfc6627b0816b3fe74b8a8ccd32bfd1ee9bc757331181d654d535d770870c9f68c10c5ef99ba0384915230ac3d18d0aacc802bfc4993436fa127346c9badbeb8bedb7b12f158699254b9dc71444d5945a274874788c0a75fd0dec92b9f24c7559ef2e499b994fa408fdd83939a62f7606c6679686fe66e84f035f7e7c60cdb0a982a44fc240ec94701500356ad2ffbbba6dd92e95faabe1f2c1d35a4be347c3be420edac0eb50e562ba032544a533729cc36c14301ae27c0e54bb8d6bdb94610d0d82d6ab9706eb0bccf5e8b068d551cfb71f813ff9040ec8bd5b16aca0ccbc666d93b9a742013cf67b4e643cf2d181f0865abd8372328cc63c5b276fc500570d738774ede5ee7b56c4b9d7f573d1f648f7c11bb25ce54047f9a01515d0ca7c7d4ce76a2b599cdc3ae179a08a4856eae3d72d7e628dfe6a84d24747b04e5ea86d090e5fdad82171dc344530b09f37e06f85824bf3ec889c215329a907880544e961318364808cf360ba1be3c07f86dd72c1c8dc936cad8bfb06afd3d4da7f70cde725c8298dd314ebd5048f97c3cb7167f8f8e88cd38ca647fb9321c8a36d612f4c1b41333c5e16a91882fd6eb8a31f27b1edb670b3039f46cb0d481562439e3a1df0e966aecc1e54f6d80240d919911540f004268a44295cf6fa2cee59169c70c610d0f3cb97fb4fbb313960b4b478032ec50fa48b007c33dbb1203ec91c65ad7f3c4b8130c512319e721a4173ba3a40dcbc8547f4ae3b44d27e2ea3a892e18447bc35134186e6b5f7c8f53b4f4697e176390a8201251d8bd05628de72611251d2fe9c2faef7d7dbfa9ec55cb86c4459cd6ae84ae7856d125d692e6be361929a37ff16c656ebd49b8c07974ba95a6f372f71d0a71b0571f887b4a36af1a936e19717dccfbffe9f8b028573ab4b49906e88aa9808c576a42cace507fcbdd7694d727fb37859be7bda865d03cb515e48547751e1e4a16c0c71df3ac034c73215e6e99a3add3c22096dfb17fdadaa222ab1a0ae9ffb6cf736e95e0749098a705e7ceb6f9a6b77753f46516477a3d0a02a77f990a7f4e3970de7a3e78e587f033841d1baba37666840e32550df733f2e351487c9257764bc69a4ddbfb0eb7f8bcf8abbb67d3c190acb49d787552757d52d85d5843ff1c226ce30b3af21885f2a7694622ed7ec3b407c42d34d50be80609a732baf363a82c2b1c76cb90c683628fddc523abddcb32f2a0301c4d8d07f4b4052cadb8c32d5b2feb38960dab3c576ef761b712b9b835bb43641280bd8586aa4b90977804b079734c6258c543586a7183de8de66ace5d85da61300f639da25572f2392026c9fd6478a834b5b32dad47f2a2e514d5bc0e30c56fbe6883c62a8054b618819231c0c1083f68c111091242e9f37c26ff786054dc5f84c5d931120c09df55bf364a799d851c22f920dae6542a1473cc94be065bd96078dcebad8491ee8575cce5b8cd1bd2454cc3efe31130470fb395096ff0fe4fa9971dd6d3b94b820224f4f1da3527fd4a6decd34c53478f40eb74937fa6f3b972cdc2f1e4cbaad72e51273da5c6035ae58149633c965aa20dc58aaf5a6348b84cea51a5ee67bc9e98501743f71784b14bed7b25505d364682d6ed6aa313442d90f2baf6f70f687484f8282edc91acd30a541d072d2042158e7e4c1eba5d8b4d212381f8f511e95647f7ac3e52a485615aed19aedf768d51873ba23dcf5e2db60e216de185af0a23abba55c24a39afc0ee244b7958887b5620edc7ae16c2905d122e1b514e70e1211db2e0e3b8e5c2bb570c88496b9a537593fa4b89326c61d11270261172b044ce7ea00a82429fae19b37f90f348e89df120f4a3a8823f202c7d337c7930fdcabbb7b269abdfa94d9ff961664dfba6d150f6055bf70f8f31c501aec42c8847b06e999a20d07decdecd5a3c17681037499d597ac83b67ba47a0684935ae0ae9af15cbaf7fa88a4023fa69705c69d7edc108f90f078e90c23caab0f83e9123076173a4797fa64bc32791fac9ad75fdd45a6c472bb98944c9762521a93438af9d93ede55f2717004742c16a2dc65d12a083b4bdb58151c900ca298549ee89d5cb77fdc03341535ab309659c054afa657dbe77c40928d30918a638e49980a8750955d0db4d1fe371b3ad3c47536822a7695e72d5fd1092cdf7785f5a92a70a574d65155830b24258f89b2dbfe4c780e534a540fb9eea2d392d6fbd9c8a357c98a8cfe85eedf786bcb6e786fb60847e03560b011a2b4c94cb5d34a1c1deff4ad92830bf2fd2e59a5a7133b498d2434fc42ee53c1d23ba5c96954172936013af794d38b964c7f5b497e8a35e2c65e64b34ed39780cf87c390e2b95fad2ccc480eb29567c5fee36bee0a08f82267579dc140ada16dcdb23c092e16d593760f14bffa2cb5f093d5aa9002d47346dad4154c6e65afff910a0eb2bb853c83f7ca9694b3ef899e708f89174cdd7915b47b6ce6b82d1749a67400851f5a5f8e840f1e5225378f0dfc9e87f56d46a856eb3a4a46096af213900f8e57cfc559ce64ec2d32f2f02b6f9b2579d82fe4c5d0c1977d8d17a8815ea86dda29a057282774ebe906ed019cca5095a709edea3d7e690f426103f51cfbfdb44de21f7da4ca2dda51cbd37ba7d70c3f885ad6e20cf00a61dd5a11899b2bcf3ed653e86d3d46ba3e157b7f6c044d525cb418d9c01ac1318a0024a14b4f8486cc0efd92d288c91859c4c5fda8afe09171fd05ede273bba0702be1c18ed026244e226c9c1f0fd718f0bdcb9760c204a5132bcd58ec9e86576f765b7fad1865f78831764c07562b001e3874ec5164b4526564a304723bd3b57dca4dd2c427b179a9f7e64c417123fea69f2e51091fd3ba3f02b0e517f3abc4f3ac17f7854bdfabbc78853ec3318a4fc7790985796eec6495d05d34165887e424d1c2b0f37a272370b85fac35660d88b4e71bf20f8d1d130b0b7cadf132550bb37322328b79ee873ad542bd0cebcd7ad704bc98be1be41f2f145c2efcdf7d685070442196097bd4a89875bd9555ccfb9606bd5f9b9d6feb00c993b85b57b223b28bc0a635b670cbdb536fb548fac5b245a6aa656be5b4601afca9a450b3b97f637e0e39bef3f4b3e3ffcefe012b2cb39d890afa876fbeb3b3a5d21e062e139c006b272f16e367c198a270632cc0e698c0605a7da738fc279a7aeb344d565b95bc7cfea6f6cc3c3c0c8e37e0405479e2758f5aae64e942726b736b0e3ec35ce89fd46b4fd3a17ad387d3862b77b0b95f2b628be605874d9c7a0dce449b648571d3a95aa8ea771e48c2852bebe65e5d9967646d6e84f3cfa0021ba37236168ec000a5f842f0693fb1c6bd9a7a0df015e5434ca97ced3e0d020abd0fcdaa58d5acdc1238b9f5a619e947b6f39791b6e3b52a2ba8af8f6af602daa6971b3668a320082c2329862ee3ac33791b4ef70ffa8f85e8d819664055ddbcf03464d7c08b914cdb1df59164a9f0a269db256ef1d644d0a18cf133c5ccde459fa3d2eb3ecd2e22da035699e0ba8b754d506464209a447f74a0626795977fc3e88c7678a2d0d010f067c7019d681360e90aea315f9453cc09ee1e40a11fce46fbbe96d650fadf38c89292af2fe24608ac2d3fb312c48d794a00a83c9659ecd6e095f626986b7ad9cfad4f175d845ef7eb17451f8734a77ea6f84012c0f02714f738c049602cf969dd23eda3f1744fc641fff304386d47b361ec059d9ff007643b38e670c03102f800fadb8effd6ef78023ac70aa75b235b8da0818c2f970eeff250c2736da3a374087df73eb828a2109a5d73925ee3c8c89d806481245620e905f4bb4879a0b66b85e0b4baa518558e028359158f4f5b36b76056d47cf0dd89ee5deaf969aa0041ce88c963d21a92ba43940e4bcc31fc182cb60cde6582fb318b778eb397b52b332db73ccc488408fff8a861921edbd427d548f8f80f89e2a375f41506f8d2d7603f957c1e40aed08846a0c2e012d3011b7d0e71f7531bb5986e6121968013a193e9735a7193d5d528e782a3d04af65b5b0c031c53b0f03c4ce5f326f29117d75b41180494b3efc384827a5453cc1c507c524cfb40dbbf4bc77bbb9c92b0eea7ee52bcb4134d9fe71522377c60f9575a4ff78d7e55db3dcca132d875d39f0b4a3f4cdcf7e703960a91792ca4759b797e60bc416341ab60a3d56a9c42f2cf76c330b2b3f9d661acdc057d7abf297399acccc9466f9818d17a31c15d42e0d0643aa43aa47183ade674d8784656808118946ea0befdf83ef9eaa5094f6811c32dc71fdbeaa196d738374a24788ea3a5830e130541ef3e826ec2e75e8f1eebce65a2485b165d5be229f7ef80879793ddd75ebcef3ca466d373447215988d63348c3c05a47dd42a94c17adee398b35d1fe6a568442937cca2964de29436f1ec9202328d0d70b15b6b08f5781bde625b34d3265ead2761f73b2d7c3ab3eaf708593876bd4911b59aebc55db96840c0814688943d88b7ad2af61f8a4d08c9214f660be6feea8d0f48933dfb201c8f167f40a5d9126322b97548e15610a50b3292d6ceefdaf5d33d2ab9ad9e691fe6516a5b581c4a13e4322f43f1a142c984f9dc7433b9dfa9bfdbaa7dfde12c2d01f4d4033d608a45146fe90ba7b5e25769af8698fe86be55b8f7cc5df5a2fc5ee47028514e0b113b28989470dfbf2155304b5ce1c9e529918ffcb90b8392e262bd82fa76502ed84d399b2cb32c670a52811d9ceea95a8dfdb279085bd86ea17ac33141f776860dd552098365a8f916ecb369f60f9a18ed758ba270197f2976535c132d305808a5b98114f6826023903e7823d0f6abba2251858c68b28e8def61af6f061a1952d992f686034757408cba721f11dc6d17176b686137c0012a9b3057941227da776d5cad6fe759b13dbab843b2d027b418fdcc5df84c7abccc7d637587bd26ee03085ee01a72101a9d43caea73ec69690a20e7f58f1723ea8317a37dd2dd36cb107b9bf2d8990c03b26d114163a90de89d8fbc9cd0810879e19471d2e3da2a954720cea2c174cc4f4e82af24c040743fe314c39d7c927507a0a48cef222ed3d63ff80d06b96b175f5265559fec81d7f94fd077f047ef984916a4b17fe54f544b30d8be8ecdabbcbed2a2730ca8c4b28fd457c9bffcda1d4a2d114613233bce9d18ff00018e86939a1fd0eaf9971a0dfba4a01f604e3cc0a08201330e0fb4c4f12bf9b0e44e70d91420cfa5c1d5c4dabac6aad93a2e172b00c1496566ee76b00493d6c485ad677d1567ca18658cdfa1383d25edf3da3e9690d646e34ee882334837286f93e6c8cdae82f2578ba17ad2996c7810091dac78b9b769608359a6b8e936fb2d0d4de39c61a74254c0ef76716384999fea14707faad1f78259c2dc8316b73665148cf290d1d8a089a6a9965d50b8de1ac7eae4aaa055f81ba933f580d8e5bc6c66775936ed6aa2ee3abcb06a41e2cc1ad8ea16605192bd8a4b1554b6d6c5c8a587c8f9755c30130ab0b55f85921e435bb5439ddf9f1c71a17efb4f0470a83bd5c5b02a0dddbd7a746ff0586806314ed903a21476dc52396414d75d814cc68fdc3f806d042cde1a2a452993be7bbe2ffeb3e64d08de500b8643860b9fbd15cc2cd32c1d8e27779565c5305cea13ee4de058eb40eecc18e76e3f082565d8b88c96b0a8a549ab750f4457b9b833fe1b2fad98fdd1062778febbc57e9ba2e9828601527cf925d0afe5fcdc6c3fcf455d63e4c5d78625880d4589520f111be06dde504d41d9b705e399563f69e1d15686336b502c88edbefbf88327e12d871c7dd0c5480e170b0df578487beb9746b4bbabe61e252c69b465d68facdd0d1946aad135bf81271f33af04f9321779ad0c0acd1bc6219452e71ee7e89e25881f374d016ac3d58fbeb4aaae3e3e9322740188830693d1b2545e4a26ad659f1170faed97994de77b30b73d8e9f73be39663466ab5eb2750c4f9b424c856a2eaf022338a1dda9d300648015949c4f6ff2f5d20969f893ccdb2da8c6df6f8948d8175420bbdc0c95b78da8ae4b769c1fa1346f53cede65b60c89e3b533160590acc306dc7f1194ac3d732cc3e573609d7383e5839faff18ecb25b6b48762331a563ff94b873f6744bd4c69f58e4ade0ca61d9a90d67cfdcb9f62f48e06dfedd11ae658b54acd9f5e67f99e2143f557db3a6445facc8ef938ff05d397b570ca977cf2ec3b110dc5f58959664a3e7983dd0f03e2e0a7d3701ee778e23f83d2e060d67d4bdace73270fc2d5c248c666d28ed5f4d99d1a662a7fa7238b4e8b079805874702d6d6330fbf43b9f113b722f8e93e40cccc6d7ef72e6e82e2f61e2afdf5c103cf52300faefcd9dec758844ab1ee22192e6b0aba77419b62fc0680adcf4e2d880f18ea603a23342144bec015c112d1663ffe024f6acff59b97fa43d5e897d46905392a3f6199af898735080f2c973047f551f0ee43b376bc0e228eabfc32d337f1d96d62d3e829d1644bc5c95fb295e1e0d32437152785bb426bbb23499cb5e111eef8f96dc24e49b2fa7cea8600dbb6b6beb111813cc5db5ebf1935735cc2116aaa64c5b59de2da8ce6b60e8d7237943833c7f9abe036579a31241ae67a5b2b6e617f1c985b125df71c40b4efdf214999bb30dd929f9e912b5b11bbc9486c483cf8408f8d3753b10f46bb2702a6622baa365cf0fca706c7c793d632a9a82433a072b18da5ca85d752ae18fb6a333fc4033704f49348ca542c99c41c6a4424994989a6eccb7e2519d844ed605111ee4fb90d69cf8f9eef2e9249eb217136b4adbb1bb02a29f7d3bb3af4ec2d36dd452e5345a288133e231de48d84d4ba97e2602390244c116effe97d0abb3d063bad1cd3a473f76ad274817c2aeac1a99ccffa6385f04c047c99cf3b60d99980892c14e01b2dbb47e0dee18dd3a5405bb8a644e7c593d1f3c2445d555d4dbca23df9feabf981f59ab7e6c8440e30917c14c590934de7a5ed6f019dd52e110089cbf9d3354996e2f887c5cf75bb72720ee5937bf5801c285d158f029bbbcdf81a7e10b27615214f381641b2752921187f34285b185d1e600880a38cf29fe1700772b5b38efbf6d96513c0ad52e50e935a754352863435fd4e6f912f7041a7f76c1ed6d6fc037381c978843739f0feef575b09307880d6430aeab179914094b92f904330293acef6951209912c001608362466d3199524adfbbb50b7df331017c761f23bfb3e67247cfd57e753ab399be5d60baafd93f274e169b7e1dd64f5805d1e6b731fd06dcf49786c990fbf37775ec88bccdac2b911b8fc1d2fb5433300eff49f3de2c1e704d55805745ecc5869bfe0190f18ffe53322e675c16382261d13004889aacd54c15116d0936a3511095ef7704437f3c8e9032cb1c411fca11bd3412d9a022e20506a7cb25f7024d9cc4f2649a53289722b0afedff01da30910a72af5dc8e4ef48229976685f5a6be44cbe85860b209660fe8e946d03ca4b0c84d834e82bc91a5fb17d3c40a9f6247f1c604fb855b0d8e4ed0207a5c19077fc93ddf45b4227780e8b9eb5d7349b5eecd93536e55f35ad960fa5be6a8513908beeda840cff06b7a6ccdea3262675f9cc46c89ebbadfc6c9a7e58fe9241bc37472d11b26f06efaa5466959e2b011c83c9d94a92b42fc21fa8863ddc071d765310f60122eea91a5a1dfaf7a2dca2227f7a31a0464d08c31c9b8af9d34956295c4f0099df2c0920023647aa44d70089bf79f6e51f4d79a71c3f759af83cfe10df9cc69bdfc671f030b0a6b753416007751dfa80650955b46b27ecd924fdd9df5ff4e8a9ef9e03afee0980cd1e025a09639ba51c31e9b828dabf7e09eb47b7eb8ebff26bf3947a4092737e5a4dc6c5577886dd2dcdc3272948eb38df8f482342a0c9b099b38924c7000cbef6e90395c423028144d950edbea17513f4701bd8f37675dfc7bf998d41cdade1db5bc6c033e05fb0bf019fca8ed9f3ea541c4193e1759eb72d87ce2badf174660d41ee9e48d016a008af7cc30ebeb9bf3883fe5dd025c7c34625cafa794cb3f7eb9026395f8ca4a3a59a831ea42abd30012b838cfe17b3d01237463b769bb0ae559fcb2a87925d811cab3c9d06e57beca203c2ca07cc1fa17a48b864e4cdaa1336a98cf1b8ac20c85b2391b824fbd2a8ed72f002f3438147637344a7c533ff8208b949619aec558a582b249d9b74bb329a096720da057738dba540ce34e409f98bb79e9f04be2974babf32566635dab9c028a02c1ab1facf7a7485be742da6b9bc1245005ddc0fded908b1c34029a4db0fceaeb4d34b6287763ed6e5f88ef4a7452be9b94015d1fb68bf091e93e76b751dc352b7ba5b8a5d17adfc11b825091e97929981fe618e36697174bd6e9f2adbafb3edb2aef1416d9a2047a67ee464d7b6b7940541169ae155ae3d2e013654504e618d8fe534131c756254a4c2095604cf9a4f8ce0e81060880c26bec01d1163d9a68177ff0a02ae82647fc0dcbcd78e3413ac1112f4707f0252dc24fffe59657c2442d46d828689e08a91fb60dfa10b211dcad617da2a5c7edcc928d2c354622656067022d3c72cdd9f58e09baec32675d52adbc2e0bc1263651333d3d82f64c6b695530580e33df66dc948b652f574178c6ba56941843c0999aa9c4164264e0b575fd5f7c0d7fe3aa3a1166a9daeb3d1f06a5468efcc3a57197526bc9269679140ff21fec208dbe5d10130f01b83f13f5d3d5bfa7f7d041f55e2ce24db42e392e0cfa1e0aa8073b0932136332acb8d25a469361d9c5dda145adaaf7870127baf94d6d22364b16ffbbc48864d07393eef417e196b778fc93cba7da0d12c5a14acc1a46300d550f7b4d1de5e9acd8a617f27b80e10f66bc18482c0c5a23954098ab4d79e28af85dd54bf24c4d35cfc59ae9913eb1fa9ed845f3f9405cea197d5f62d44d00212c690d50b209dfce817c15189639c75eb660691fd0fe51d009f0e34848a7ea5deabd2ae9da769f46c6e04dc71f67c84b4f2d501c996a6945b73e0573e604fa9137094f5c4d7c92c6a1821654a94087c1fbac2adfba041f3f7ee3faee1ae623693095387c0cb692d71c204abf738f3fe8b74dc67e1d258f4f160dd853a9c658b1c7492a32e37259b3185563fb00a009526e79b77eaf2e116f3b9a4bb62eb3ab54b76a0dd879c137fa4dd650d48f876f9cfe43d5fb38fbfddc5108ba85e1d27f21322edf09d3450dc4f57da0b7a023b8484355cd9ea013d653fd8033bb17ec7c2293d880cf5fe54dbb79b970cedde8be15d5b6df1a41dcfd366625b9dcc48dae62e2e9569662dd0587d440109a04a6e81b9cc60a1703bcf68994f1433ee6cc7cc95bbec897f1b1b297b937d173bf8ba269553b1b835ed1457ead945eedde3306ffc91cbfce230b0c2eee9d224942d50bf00c9a419e7c72a62e5d0d723e932d860e2aa387c3f94441a28f52f8584337ebb05e49953c0b67e33226b6ac7656a84e4d25eab104067d965d0d5863b1935d23a28451f6767d9b40d57ae18a99caa4a6b2a404dba3239f2f26d7170f97b84109780a03941a512ecaeab3c43e13339065ce19398029a8667a9b9738d17c3430095e4d9985ad7dca014e17c24083e60ec640ffaa7dd1e1c0a783fc15200e4b7dca8c52f05a2b69949de8257e959534e1d7e63534d4c365aa36f4db74308f13a7c630f45b7f244b159c38d18d859d268b1d75724ebf040ae79172296d41441bb0c435e3d9fe41a5c53d3f9e3e2454e64171b414d8ebed0fea754befb117dad84fdd0c9a7e6ad53f072e96bd95c3d6371bef5182707706852667addc9b07ef7292b16da69d0e811c887c447790fb7966904a2b0f820b6b5e356c83c64907e5f8b385af2f0c0d2443da1a7e6cd02772b19e89843eeecd3ff6eb849f2d4c73ff5c784fd971adaddcd9fb190bf60750772e3ef5aac3f94862084e2211a07835daecfa0233711350df532941005e334f68c2e860304cbc59fae252c3014b06572c4ab03cc1b846b6d0e4ff31acdbfc0e0f06e7cc798f9392574da71feffba2714e74f1b9021e18f93ece8770958a221c717debf15a1d99389e0ce5f163650bf9884f168c22064aa08ba8a7f73a047722817a7f562692ea31277d62021f6312f397bd6566f6b03745590a5c2f321f12723ab20cd04150e558d079ed9efbe2fff7eacd0936fea57d5ea33d43413e1985dadcc260e42cc8a495171a5df4d6c2bb7d001a0de0097740ad5a988ae84784472bcc37b06a4d1432ce0ba8db3f222c2daa1b2569205bc4d0247ececb2524cf8494e8550dcd858d6527e470464d95e81d94309a11e86283f345f6f60b59ba97a72fd63ff7b3dc294ba3d06169b294e635083edb376cda12d08ae5474cd8e5cae72118e307ad02c9f4615693ac19e3add96f85780cf4c81e64740bcfa5d05a49cc3fd25f1532dbb4b6664c326a0ca9044929c41416d092b8466e395550efcd315d1fe4edc741bc9a4e2991209bf86fa5e51f8b6a425605856b82c92bdf73292ae6ea391e662689de52015abf509b5e0dce7d2ca80170b8f00e97b52cc8c8ed20e767555eaadeabc6f709de40edd715c994fe2d62ce3dc63e7358e5db002d19d23ec3a194fba05c3710daf9a44452f44549da9162339c82c170d546fe82e0afb7dd867084881ca9833d5d408b1b85803b1181ebeb30069e709c7dc6e970a3c9b6bcf50761f454088dc73fcfbf8d0fb8dca61214d7109f7199f8d06a3a02b2cbcd4556f9c2e28c9d4d5e8ba7acc0bd41927b642e7067920a5659bf668947c3267743d95f50150cd5f5cddd15266c01cae29731bf2c68fadbe0bb171700206f3a1efda0bdfc25012b2ee7e0700c467174400972d8a8ee9ba9756c4586361dabf4f78206e7ac8395a3a5dc30b4f459dff1842e0081c93a0f7e576a964aae83f394428ceba4d56d5b25f47011b6026a46d2b1cbf8a7a6b29fb1871e5dc69d008229e5dfb71965a32a61306555d60695f1ea456a341e6568f333aa0edba4e7c18edd6760571be9bac61264a54d8e9badbbf08eb80c69c69bfa967f62181af165d927f293ae321f5ded2e94f67c669f3e72f72325ae16fd5adb4e5019828dc564c7691ab4c2e17992d52e629f9c0f214157c63629a035a17b9ae0d9cd2a7179406d66142f74b5933ce21339106b30915d61aec10b316ec593f035ae3e3cd5b8e45a6b525c95ab541f606de2f1ee79b565166373ca602ffe59cfdba72261fd73b3ceb8a11264aafece68fc892146a80e9407cdfdae18a3995f30b49a0805e7e056d815eeab14f5fb069bed93f61765c05f0ad072eb3261485f4db22a4f14e0a59a3652d797d3cd9d410e33065c82a8995590e284a11df8c69193bd7cde6935b1dc4d5f40801a170edf88c2db05b86d460b283139ddbe3690f6e96af7e69d521a69220b41e7ea2df63b4ae760afe0ffc3a0005b5bec7d52da300acae6de90cbcad3e654271ba238ddc8ce600384e6f31f56b970f95093504a06774f818aa64c5ad5607d047fce1ad209dbca22e073cc11ee503d874cad9ab8634a03086bc6684978c5a279374df39cee82b4cc4f3b55f06847f6de0f4d90ba5e27f14a959b3062c38558bbc75cb10955a24074ee1710ca9ba73d4eae8a5497a52c83e3cbdbaa9cb00d691e4802b7c62c296a630cd6315055e438656534ac441f66617a69f5f40935a40163753093aa7aad7f1512b19bffbe4c0efafee7b61dda9b54d26382ee7d7ee702a354a93c6dcabf32de3ac787aa2c95b83106327fdbf897c7183232862feeed12ef63b29e7b94cf238979d20ff6366ae3da9493b8d8c3468a3e6c0cc0108327b700e4be61d4e9069767baa2b61463bd44ff3a9f24f118dd0a6a52a84dfad86737e2a7ddef299e41a3015303908c63e305aacf86b58f405577e93be7b71233fcb7a0742779f60aec6c83c749aa489d0de72aea6691aee18223f8d3a07a3a37f022e51e7b3620801b927a4cc1230e48caee0c8defc367b73316b3527e1a41da93b62fb97dc3b5b77f34bce700d9cc66e4ad41141ab90b32072d4944a18841e46ed4af8477ed4ea10fe7988b4e6b70c4e6d3b2e3e9fc4ae9a078a8a6f23478321a1e90d38a180f1117771824aa54efa303e6127203cc69723db24cfd9d7d2821683f4f7ac5a0cf34e8e2f70fe3e61b8e8ba6317e2c16f81bf41b439901d8bd69057bbc32df8975dcca28bfd43c94578645c43543a8b6d71c7e1d49f0d05cd966566ce68abb8b93b6f3124b4a9971e0ded31f9be0ffc9db3c22c63b4d1eade1654e0847bedb9d1b9bf37f80a4d16cb12d045ec84fc68ecc36339fa939db79dbe23e994e06e7505a579477fee0b6e78281e7ba38c51e802c7d958ed470bcd487b36ca4723b920b8310fe79262b4989a2c6b474bf30da6963e849089a1ac263f46b7e1943a1f177c77515a621f1d1a541fae881432405d036503c98a10025331cb07507d61e219cca56d91153a58acfc0ed628c5ab05ba5eb551bb69f8569bd9905fc3f6f70218a389fa56d71a571d1c8d1d9021893d0b4002398a7a59aaafbcf93cf93aed5091ca7b49007afc5c01c6f142e445a54bac13cfaa3b9885e5a56064a2e3727c30d3857091def444cc120e46ef9f5db89b512c4a6f8fe2465e4a23b29d0c1e164c0b998eb926f6e750f83ff6915932b01d6a2ee7b7d98fe693bd807552faef4008fedb7616b500608e4607e8b5c491e80a6f9a1ba5b48621b07948f4f4205596d0ccfcc4e817d64906cd69551bac17d8295ff261124e74366e9ccb1db8773e25443f7a4343cd4e5ca57d53370537b7f6c3d600140c8875229fc3e7cd855ce08211724b9e41a043cb2f110367a364f0d8b35cf8ad25d0e8751656847df184d855f8eff37dfed04883e3d03e3102f1b5319d261d86cca752dd126b268e12c89bf4a1b06691f6c709ea3d9da0921ea3f9f0b119f23dc4e62fd6f9e561d2c838342b4fb729cf82709c003a37ed471ddbd529381a7c435bf819cc54d9493aaa8f549a95a62cbfd9f52c64333c9d1a48bbed896d10f69940fbba5154de9d1a037fc6c031cc0b1f22214354aee21536c9579a3112030523c571e778ae97cdd4481c145fb01e3a278921e42d0eae3b675924f0ebde4c7dd6779cf14b65df9012b75540c384fd079d8a5e173b0dad00beb1d53dd55442c8c466358db7e5a43a33ecbabce2d58130162d35aea8775517de9458c97452ee034c0c3fdf8300f123f8975f5047004e490db326ceaeca873425db6ec8bce921b452f9b3665772f1f8a79fcbcdfc06e369237c6cbdd0584d864ddd6ea52de97fbd8df4827c2663c00c5c80c4c71df96735df68def571dcd8994af819db76ab72d22b6119eabeaae1d6b0e767dc4c5fe67ee8c86b34577eabbbc8ce042d72f9f8232ea2e9ce15b2e9aab9ae690147bf977cc72b964df1a6178c32f3f71f08c42ff1d9c445a6b855a71530f869623c81f82995811767ee83460d9fcaabffda419fdabb70557758ccdf782c4e7b1e3457c5f104fc3b5889f6666b90850e539dd650ebc9982ea261e7d9818bfea42dbc372f23fd556e9a7b59a42cd1b78b978eb24163412454b1fefd12af6dc9875390e10f11f699fb708d86d9a266ce430511c352677835d2ce1698d273c7e70675b519eb25745295caa741aa06d6f8d308d519cd83c1429c917c03008e71cebf22eb3882da289dc40939a86af2f1b7496eeae91435b7df16765ff05f62f668eee130420ac7f60e97e21cfab766acb29fd33edc12361b9275a7cd20dc7931d723176dcdef131eba8e37c492078ac9b0c52043507ac4f78cf5c69f18f025be5e478099ef7f8c90e64981956397b0cec849c5d9c93bd1947ce528eacea33af0164402e4240e5383998c5bdd30ebcc5cdab8b8b63a358c6863f26992b659c991039c96a1d20d4b8f131c0f0d8d2a77497614f28565d155a4ce9c1966b8145ad5ee6209925985d0ffc751109e6031fd36a96ae66e2b68cb35563f5e77167aaa11414d638789c34997f6167fefbec1ca96ad8570c8ff5d48d92183eee724adcb931b3350b3198f8851bdd13fca65459cd1fd3d88a6d2be7584e225244174f2b80302250f4f127ef67b83fb31592af16609c0432fe4f539b77033ba099278439f892a4635b7c05273c98c4d00f1dbcf2673fefd3ed97085a3d67c5d295f470b69a6846c92594add63accba3932dda24bad1950389cdc906c680a3a5b85f5f45eee0a5ffd881d8e401577a25dc8c9c961938043419452851a3f43eaf78721afd7cdd9f57e5f312d8a77c6d7fa7325e618019a3a1a32e41864fa618632974a758ae3e66788dccd45fd763b3654fc4cb05b040933f5a367e979910f85e7763b3a6ff73cdd3c8ec2ffb8b76c7af16f8ee12ee0ede53fc8011213f044f1db4b347bcb6cde9f69be691758f88230558fc81319efdbbab78ddd7f27ac9f24e92e668124bc2e3acd32cdc5df5dd38fee480889b2d794e125efaffce99574f02f3e67f61f4f567ee6caa32f6fa75446ab065dbcbaefe2f6d0eb5cb2e2ba3ad63b49407acb9acc19606bb952b25c11c7eb03c049659dc12cdbc3d5e054aa31d7be32a41d623260cf5cf91f1ae5165ab07ea6de6031d3e58723575a67b03154bb2195405db669136c3fbc4eccd3687ebe0216fae693beec77b3e6e56e373bda9afebf32f988bdfc508c36226f6cdd83dc0c11072047b2e3eeff966f83b7b77dedce96a867a2220ffe60c61745e8fdb84ee2db89e80061cea5bc3b8c4873e56f36152bdc98a2ecd950150b8f0047b7ab180901bcfe91a88f4d0987f5540e78e4ec3e896c01b2677d35e6aaee705a01ecb52e2d28684c9a2594ad7e4c55307200c443f731fb4c6d33fec614fe7bdff190c71352179a3e92b0894835b83bca180503e3090c63ae19346303adbf59980ec72fd4eae7b7509129a094edc2364d3c86d136fccf2fee2712d166c965f914f1b589c3fa4a023c3b397e27548f669b3b50fc79720a9f3c16604970c183ed9e4093d33535dcbc85e98cb218d7c4199ed41df70f66bc7809977bc3eb17505d70bd05d66e19578980c08838e79bf3bbf76230b87300dc9d9aa736a60f6b7f3d73a30253435a8a986c0efeb54b1361c1619f25924847be72018a538ee2a7a91c45bac76dfb22554b589e7af1ace2d6e37de70effb32e7fa555544e0fc02fffa57cecc3f93eed1a0226cef54632ccedc3f7933a77f5a20ab653b61b88ffde1868d00dc5256b10dbb91f316bae7d2637ad009a943c000cef87b435cb59923a28163e097489d36782ba86d5122b7122ada3d29d30363ba970ce4e835cd7414b60a29c777105ca65e564800d92517b0524b7edfa4abe84c5c7f915db19dd131efb9bdd8212e8dc0006b2470e2128aac4c948feab6651f0209bc214b85b1e0eb8f10d8fdf607389b6e87500292566cd09ae2419412395520ee3dccb617e9c8d548f7928b4622844f71b1c39c33cb636f881b25258fe9eaac755d72a68ef25e6cdef4cd4559139371ee5a2bb6fc13ce01f279f32a84178a26d473c5d2a97f744ca1b34d953b12fdd38e958dee42de2cda5b6e5005c12c67f70db1f6c102bde6fafac4200f703e61d618c272b2e286d1c12ad47b0b6a4a179d2ee088e39b2230a0ea5a99404bc176acd6f373ce872da2d929744182b6cb96a79390eacbc690aba61dac176ea2370b9f96381f08672d2d4035260f36da963d6e2437fd4ca3cb2c631d91a9c2dd9c048002adb10bdfb5635272fbb11c30ba0b97714a1c02359d271a1800eec29b60a914fe66c62ddd6cef048ec818a9b19d38fd5c09e8f42d6370637c4c8e3e048e3c312f3493c34bf6dc2a198d0e9cd4adcba77842f603811f71e4ead1f05d862138021203c939a659d44f400b25d7fcb30e0c83e4ec603f8306cf54a7c9af171ea7b5c381ba12b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
