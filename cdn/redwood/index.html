<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"076901381199130bf47e2a8f3a52159243ec3e7aa97f2125a78a6cc69f089762402332d02d392f47276ddaea053f808ae19c28d48587afb2803df5a413c3becb35580d6918ddfeb449850f38ddafe865cbc3233a664192c6a9b02fee6ae7659bb506d791379b08de69bfb0afcd49113da43e24c241ad506c046a4c0b8f7896928d870d55a502a53aa5d3ff70df00895b6c2197228423d590111067379deb04e6da26bd20b533bbfb109dcb68eb294bdc6a79e5e49fdf9951eda39511430a74e3076e1649a172c4c938ee1fda611e25e96c8d9e7a30f6dee462d6413846a86b4ad91e51a80eaa3d09230033c6c17712f14216c7243ccd0ec693c3c04c6a26a8a046a28d8a4f7b02aacdff04ad383c734641b67993146d1cf948fa256ae357759bcb2a6939f73ded9bae6026d74575360af39ce7630110612ee977e5ffe503f4e28973dcc3ce1fef2231dc68f39bf6aef84b8e7f5d58d89b7dd385d3893503210ea364b211d1aa6bbbc3b6949c421420133fefcbc87334f37559d3c15a7620bb1c1cf6475fe50352dbb2cc3a44759e4c1159b9c986f5060b2a8d2f086ffc1a7c5537d30b21846fc8e87f326e85de35fe35cae14eeecacb81a9c458485444c4bc75ac93fc3001d124a829bd100bbac69e0436834a75feeefc072dfefd163e649297deb646ef8a248f052b08d62a8c5adab92c558855c362385d9519c5a462af04afa8018e4886fe7c5384931b0bb1075d6e08af9941ed4c46204f76392849cf906c74cad78afc365d0574f533dc6464fe7f5f7f2642976cc33a3a7367ca50fcd91c3783b14060073d5099da3cf6fad783e66901cdab84b8d617c17d8e24888e6b79a1aa9780c312fd1103f6a45be2ef7703ad0b7016886c62bb7ffbe1b97913c7093da36c213ee5e5040aa50689c7a97f131d754cbef091c86dbd3b3c04c007789d91cd79e15e831c6bb3d13b41105b55a5f947c4278b597670e1699b90a4d2ae2fb4dcec67e26dca5a344123c9825d73275e0ded73f9be9f576f34125c3fc535b32e1121e4337faaeaf36e8d92ba7598b1982ee6478c7d9461f342d692776a75d99801fea23df75df17fd4926ebbf750e2febd1b27c457ae13ff7580714f1c96f0cba7c276e9c6e227774d6c8ca43da29409e21c2937cda9913fd89192ae704848243e250988275f343d752cd7cf6c569b08cc0db67f9b01e78d35216f32e3d40e7145975fd9b4c677150f3d02bb2669e2f9bbf6b3b3502b488d9f6086ed3507cca570a446cb6c5877976e3ddc678d1579f1cea7bd4da1f9ba4f507e8d2eb373632eaa95723dba66abe3a0302d35909ea6fcd9561a7c7300fe1887015c8abb0ddee0cb7cdbfbf210f781ed01ea215439291d75a47ca1267d1d6064ea092a8e3f6b6fd2e2b38e6a5b33986a7d462cffccbe962f1f2773f26df15ae198636b1a1c9abeec26c7cc18b3b03524ef8f471eff5fbd53e71918d62f5ad9f66726ab694ff63dfa1b72bd2278ea1a302a8a93ac9b4b753b0f765c10a24cd126b485082b6e6d78fcce2a340e38134ee99a2f212a5b04d3786a8dc27390d87aa60e70e8b440c47d07b49e09a5bbcea726662ae19a14871440fb680ef27591ccc67ce3e58910e736e43a97073d8f32c190615c6eaf29da2b30983fd0ac8cc851c99dcc824c4dce9832adb02eeffc2595d4f51b0724414e93bd0d87493c31cb800929ddb5fc7413f864112a4af4ea419f148ef121238ed91a89d0a7ac106dcae0b262436af3db08fb39a6bce4b2cee0022a28c97603d99c91e2571e2664e03b4d5fdbd9403efcb577e9e05ad798e487d604c4166c1b4a3539dc49bda4f2474d6f5e768bec4c09a4d8a272c55fa534050c37891673474657b51d32644534b2f6d6a3f1bcea3d21e0e79362117232e7698211e966d7334ee8bb0dfc5274d4c7862ca986d35c6ef96f9b0b0c892d0c2881c84c548547099bee317f57a19d646820d58a74d7ce7aaeeaa2cd20331f0997b3101854933aa7df617cc29b1b40d6fdcfe08e1d392cd3962167b20e4d8c359d9e215f1826dbc7ca8919587b12993fcc614d3afea606cb8e7a4d412fab649a898706c7a9071f20a3be96a736b7e0b8382cdefece4797c3ba341fb0e72ce90a69dec5fd8fdeaaf890ab2003c4dc5741485336f4f4d6a367e9774b6a082f464837e4e92f149a97bd27303fa3b42528b0f7c4b6536b9ae32b1c86e837748c3ddc679d7c8955536bbfeba0b3aa07bfeeaddab2e853a731aecf23335cdeddab5d93715dc21cc504bc68f74cad0ec460df6b4d236ae9f7ec7a03669dd35de9aee906ecf1dab7102726472a55dbbde24242b5b0e64ee6bc464dfbd05e29a5e0a551690456518ff4a435ac301a7fc214bc32348981b7767b390fc0542de35beb75720330eee5914e4a39b3989bc177b43c0da30b3674765f41c2e3fb6640e6ba4257fe77590aa27f90f7b6d5cc35daa1fa3ddc4cafe572d99ce8c3145b6f2b993170bacb767029973d45d0164530e86fa13b3964bd0ad492194f0f9d6184490c902c49ee80d6b2a620fedc75479068e5e976da4dea61959f2adcbda39fd2349cb40f72c80795c9ff981c00398cd02a82bba4d7d899f0d6e6b22c9d20029d2d9fa42464b6e5a074ef335b8995ef23d47ca373661b844433b70a30ef5335d801bf1605e4631bca3e2e13e494396709d9328dbb03954fa18015beed8e941d7e8bc524e48d5a82784a8ba2f87e190e2598d32a697b63886d5e68349d97c94cd2de385674125ed3b839277d0e5273fee69064c7e507d8f2f46b89001f97baa2bc2db9f30c2cc860d2feb5473c7e98a27e4cc1cee13cd620bf83acdca7cafe3aedc31b409ae1bd08b96a67db0597473a2f4653097a6f7b3f6202a5d4fef46b8dbee0c059da3a711beeb64a28d172143a99716a8c51ab1f8838c877782a9af397eb058a85e9b9d17630ca25adaaa1c1294cf3b92a81c57784592ae74cf0c37540496a6edbca88d46b6e62bb86b4fd05ba3861422f5a462f8fb8b37efe0883616be5984a219838333e2bcc2830e0c64e8bba0c8b5ce24b14fba41fb412dd3bcf096e3052bd5a4d28c326e15dbc178ab5181ed5205cd3b53915bf2524019637200b40a435674fd6f71cfe20cd37793f2ad635fac5cd7b6fd775eb2f737eb3af3f046899ec780796bb82e1f1bccd768f1011df59b874473a98f4ee1a6c3ac94347d33056e750f5e2f60edc79a5805be7c638dda51963980e53fb4a7959448fcb615942de0ef080c1fb5f6941b695a7b36d41bb96b5e9c20b77cced54359fc3f2536648552fd42a53a4f13541427e9f43915ef336a5f63fc7ad53750d57de5fac4ae1143cbf8f19810bdeef8e5ff991b49bd06a18be2b7420b9d25a14fa1be46d606c3524a0bd49dc2389c185e2a668c6287e9a54f1ae29ecb11858d837038fd4830ac6bff1a725ceb909c5f15741eb7cd6129dd73f78c68d15f47c0bfc10030523e01242c7e2a6e37a3133c6d7649f990af9c6a7c9449b1b05349a12b98a09dd8dd2a58d00918b795af8d7e9352a4637d86a18d2b5f8e75f81af823f56d9ecd7bfc07300eaafe504a2416e1f98fc4a0f18cd42269a81717cf53eb07428a418c738877edaf35b915517ab0cd34b304600cc5fad1b3f958737e2a0322babbf92830215cc6a91d19800ce066e3d30fc7aa00c4a3cf743ae352221bff1701ac92eeef810fc2ddd2acc45760b15bf212fb57d64aba2e24935180a6ff19b6a850da0f0ea136e95abcf4d160eb30828d526e8d5e2cba74289c242943e0037e893749c4d00201566aeb3c0e05e9353139432207785061342bf07cd163e35a999d91940a89dbada7efc5c654a8e6096c691040cd35853052273c04ed8fb1727b53e1e1e83dafb10284e7f3afe4ca1af97718ed6431128d30a908990e42247bf2363a9d6af8a49e29fe7f3e573c77da5575a1bb7729e3a23feb79b1f1818013ac5713e3e557fee4fd464450d6d96c949ca870232e2befab9a91e515e8d12b2c7196879068adb006ecca7dd95607ce826509eb050fadcfd213be7bdc3cfe2d79fed9f5589f1675d440b2ec72d0a7560c13f47b07af56a75b983e39a38e63b978c9c8f91aaf08d0f4bf9b407f2111dab810b5057f599df8dc8f372cbae387cc086224d60f3bcfd8ae0b1b44b7e69fbbf1fa3a95d8266c2bf64fb7219d59fead97945293095e303877c580589c85055912734bbc3fa9f6610a3d832314c4c4d1d36906bf4747747ba5174dfc8437dd01467ab5846bac24cd8679336d199593bca5e5fcc72f58c80f3127e6cd5180ddbc5d0a3bef94fa1d64efd48ab76072b3a6ca667804a0eb74b382c25beb6db6ae33693196f938dbce4bb74254be05d7f4470c940c853bde66596f0ae3908ecbe8c562a031e374f5fff91b9c7d9468975a5521dfff34a489f08bd9bd27704e4ea4e9b541ed25a0aac5976e57e21b3b78ad94d301cb8d4fa30e52f6713de033be6a4135e4d1da3156d0e964841631d01d3400087fe9d87e7debefe7008b6c4375509c2e8f7694046b5eafdceed06fd0d2d90d51f74bfae5b188529799e569dd30855400e44364f28428c013b3d71083c2fb4ca861c360708c18e06f386333fc7240748f9a35cb34464f17d75582d32a66f9b91facf9c384241d9669ac398bf39afca7f1ac2d1e434e5b51d563e25ecfd31744b577b9992e92cb9bc169f53d71a402e591aff5d31096210a9ebad0f6a3a857cdb8bc1754800cdc595c669a8cbf5b558aca47945c5cc19a54014ce067cc1483dae7d60ca5f6bfdb2ab93e6752a557842a197effcf0d5567553035376d29aa2678bb95fec74e9e022e2dc0b17331b6c82b68ef7dfc78f0091b9eb247d724cbbf88ad7db517d42d6954a8e488f9d99a2ae83997a1cb0133c481f296625e6d38bc9e69dd7d654a50b42635dc29a68cc1a3398a010e19c04f8b59d438e64790d5a69383b806585eb92a6bc4dad8267c071eaf59f79f2089a0504c7c5a5cfd6a9296a41b09310d6df3e087a797fb3fed5f735685e7175fb184b5c91e7db5b46512c98864a42cc0f5e07d28eb4873c33fd4d19f92dc38d985243dad83c6b178d036a566ed8cafc86c38eb11907c2cf0f1757a43804fe0bc2b1a6288adf3689ee6571270b3195a03bdd41524a0089884ca91f62c28b821d3216382a2593400f8352773f4d00fe7af37dc8baf7de5ea36c23666317bd6f06e387c43c66f0cf1a9609b7a47069a79f5014be1bbf3e2a53d76f825b8bc325d838115c3425b2c24561460b130def2bdcb594263a1ac8073d8fcbf46ab1f39e14238006553ee9d2b573f79596f563eb756c9a96b7410a06bc9522e511bfb7a0fe85ac5580251ed9eee336785539caca22ba626064d303737f86b5920133985cc843c8e080762e023f538f2debce920fbdd3ec16e944410caaf9ca677d1fceb02afe8fa0af0f7097e942c7e3b391b735f34775ab98fb09ffb922e2ec11b887b6945e8d7a62d71129c937d5047b9d49a434ae42ff1c2ef6415b852390a5fab790868c8165c36737fbced7c564161f02735fd8eafbfa02889083de023dca9b58418629943edebb90fd3f765ffc5f11b2da01d30d63e1e3baa4fa1002bc69ff342b632400eb06cdaaa6987cd73e3fe00a4e5c33013b59e4b44ab9eef890d1f49ef85924110834a9afd932096914ea8fe11d57e64e4d01d1028b37c671cc0b5206d20a88fb529e9da5a374518e6bb7b596365a3a1e7f8a0d096f85bc9bda68e9dd1c7284a8620f87fc2fca3ba443f34f140235b7ee1f21bf6c0b11ff332a542cb42e2bb77ae995b6ff46f9054184c6d0afde284378591cfb6045bdba163023b6d75b4dc9710d74f829263123fd69dc589cc0cc3451e8051d41dc939f2b52b600c68b13736fbbdc42b33d018adbcaee8c078e1e3d471de5b5cc5e728a8602fb021dd2c2d3e89cca7a599c14c0a40ef99c8509e79659719176003d2da6de2ba39ebf858bfeb6e306f1a67cfb73fe3c5a74b697e0126633ebddf2e568253edd185bad0e9114cda1eaade8eefebae57509a89cf88bba8679c0e1e852b30a2771865d9d37740117a69826c510e0a4b6c3db8bb2bcd895e8e55534ea90e1d914c2c23ac69d069880fab14b5b2527801bed9b66c9bb85c2022878e308bb8f319cfac57cb293f71f041f45be0a5040d2fc7e087e5badc6d8b612e04cdb6caec7f645d9acd557a3e00a12d1652cb7029357402cd378381b646fcfb4c7bac2c29965fc8e04423cd413659efa3b345ef353df8c3396ab6c037a4d34e390934275e9eb872d4cd3bc408b0fd47c150c96dd2b009ac6370bc53b2a26f9e8cd903081357f808cc08fb6282690ebd57af2d4c2b4be551cecc45084af72b0540eb7fa6992d49a370bd9cd7e5c2e3759b20d652ff96bad2aa53e9d8e1831c8dd36cc1d12f8acb56c991fee2c89691f7c5f8ddc00c88594c5ecd98c9566448c03c48244ccafb42858721953115c103bc32f2621ac2797e167c7ba87b572b42efa3fd4a42266d14cc070ca408d86e041beca682851914a1933bc49ad449c49003bad6db31d6e323af56486887ece1494c41e1d6e125d1fbdd10f4cff57984aa3766111cd5ddc5d228bfbc8368453308bcec03a45c2df65c21af29b4a9fdd7ac96b8c70c447e9fa29b69d3d3d15bc1dacbd9883351490dbbbc057fd7c6f2b58933c3e4cc432c70e79848ae9ac210ee19f017fd8ed4442dc2489bdd29019af9fb86abdefbef9844c6e73a05a8c4cf2c66f9627db4018c4204763bd46629cb82f15854dc8e5f4e4e7cf03e61b30f34f3272006aa4916ffc87b375b28b1ae7c23451ac415f91fd1f0e087e8342e4f9bbc7fc41448a87d39290c34c8875529df11d9a487e005ef08d1b9a3e5611907aaa0b68eb5c5d2983dc054ddc547758721d434e19db517c9ec88cff66e24787f464744f7eeed35f42aefc68c9f5f2785cc1911f9b0cdb6a254daae3495f2123a146b8e7143f71ee0f1b106660c67d783814f41af4ad98b416350ebbd383fda53eef157544c790345e7d915e7099228a9560e848608100cae4f32b16b77f2df73bcedcb8ffb2d2a9b15daf564a8cf9753edc8e11ee12eeadf3133ed8f44c5f1a414e1e7403c827d0479c0b574cd7b1dfdcdfa2e2c537f7b493d069cab68ca702a0ebee7ca36f0b4fc2dd436824a38ede1ca461a5f608d17f43faf837d03bbf39573481068bc7a06600a3c95f8a2f399e83f0509c67216bb4f180117e01d3d3a059654d1647e5b9617c5c63c72bba4412e3c1b5b175f8aa8761ce41a69efe475250a347d03d4a2baaaf8f26bcb3b0060b1bc7b120ee6cb2b2f32ddc010690dfb4523e890b405851bd11df52c4dbfdd5d18ba66404fd95293bdad63091c92fcd741717cb2517f10b7092a570d2ca6f7a39ae30a12d6651517122170db9871b2ed9b04f551e14f74729e3fe8bcf2e655740e54e63f2848b9babc104ffcdc972530f03f05ac637f5fc286be840dbff8e51b0769aa0aec299a65b430f0a8b6d52ccb9af5a77e69a30aeec95ad43a0cd39e64e6861e66a51735fe1b816583beb97544feffe37feb2be12b036956efa914737a251993971f5e781c68a73da1d0b6f1c38e9219b635b6aa0cbb0bc115e16df539ab97ba1e83c28d2ac5ff35369f7821e3dfd1eed4c03863638ddc61df32fc89928a3c35b721a55f67a372508e09d2f9298d1cdeceaab160257c245f22ff39cf667ed589e23792a4268e7fb6af003bcc19ccdca48f3444bd824b1554fc164a4f2e8d3de917cb9c4b13ea6adce42291d9338cb95f58bae03b2791a54e0be76e837609b107343c971cd644cbfa0203d16c0cf8861aa0244a8372049f994c46f04a42c2c7ce258ce3c002385afcf054649872485c5c4e7251686c15dc761893bdcd63d8db0b54da2b07b670491636a88b8ab2c2d00e22f699aa3fb5a8e473f1670d98661b237a28999e8afdc204c95021a174c4b969165e37f009eca38d90b6bd56474cdf0c76afda8cae4734e1cf2bc517325ec67d06aafe1b7032be9cc9252cec499be76605a9eb9ecb58df217fcb5469232b73da53919260a899476193f73d8e54517c0f3efc2d29976ac934d0ba8614b6d9de278cc74064cad43ed50acb7294698a853ffc9345b4f7482e01b04530e239c62dbfc3749117d4997312ccf7bb4c4ef3f54bbb02e22ed58625db895bcae7a309b74e12a6a9c3f6bffbdfe02ab4a1ee3e6d34a2c00a10a64c6d0ea40710e7f2c2b3c3b1317e23023ce8117502f11dbfc5729a49db9cd5c414198ff92fbc15b4f570c9944c8a4a6d1c949edde5856c75fbcbc185d9165e6d8420dc268b7e411957ba12c1fa3c68a678c785c9bc08daba77bd0b2ab2b419336f96e72b978cceeb62189797ffa36e74c17e33ad2fd188ec0603363885f8e637cb2560daeb9d90c51f3702854e16ce844ae8e14b3119b331c74079b72eeb3b9b08bb2072f9530c52e2e7bdb53957603f590530d99ea0642419040954f41920e2bc435b36399842f1be2122c61b228ba417a1bb37fd800166e191510cf9879346a7fbf3ac51cd920cdb2056b803bc674a5a4d6b4e74d09552f93f153f0c02201d175d15ae4b7fd210d0c2cef841844f3724e50365b780509f324b335ad6e4ac0f97ffd42e3d03c54ca58c2eb0ee8fe67b50e36b98a6934a919e5e0eacf468b54f0b30da02d7e5a02c76d1b6702b94919693d5e6232610316c57c4145f74ae50f8a05c803be4adceff6bb6d76711043657d2a7488da30b2bfd25ab221682cd9658a73407f021f32fcfb341a07cd653f473576e7a2eb25e287938f38f09a2e5f2a384d7d6e07c878236e3dddf83f58fa3e25c5ff4db5b1099e147855dd8609e1ab56ebe4157c429da88f0f6ab96780426ca52d7ffdd47ca01781de57b1a1ce43fbcd5b96a4fc096676d128a64d4e29152d7f1a49afa419a9196d3ced95a581e93ec277d5b5d4a51768258459a8651fd6bff1ca8cdf1aa4d3e2fa02d153255898aae825b22789902c9227efcd6f7a647ac53c57fd9e813b3331f912091b49f7821fb87e941fccc704842581d64a1e9bd92818e81fae05313db5c21c900ae29a5b9d118afdcad7c6d071b5029cfea55533fb7a77177013753f00812c67b2824b3c94a676b75ac3b6e3db78163a90b371ee84fe409b679fb0cc80b827642433dd6a2e0ae20c395dd1f1db9c4517cf10649aaab3571bc6edd7bc9d5a49bd0f24b5c444a5796327635513b3c1a726605d61a655d84dbace6c309bbe1e9ad32b85359aeefb48755468a1c7f74b8447cf773ad736dd9e1dcb02e1ed002b4733344f939e34ded2f9889f988b503879f9d0a4fa7fc7b629b52bab292c80bd1d15f0c582a02d37f413450a185ef5466ba9b3cc3ca10019793587b49eec276051145c9c265f26c996d44bc9c186e2fd9ae9492f1ac50c87f4742e6f3465e7722beb87db975d682919028fd851fac1e513fb8c6ea057c89ae352d1c0fe22d4ac525c1f0a9435c5d3696cca5ecd6133e02cdb86afe6df58321043e5f7703192a4999bc6cd1072b8a3f7474d7f7dac221de645c9a68d59e9d30aca364ea192f5e24936ccb88a9d8f6bc4e8eb7f5704b42f66b40aa79e66fea547863a37ad3def549aaf1d276f3b2b97e54831fcedbf42fdbf24f0b820b11ef3ca75b4608dae15b338dff00ebd0bcc0a9ed6d640fba4cafe820e84b396a4f1a0441343c991ee93362c549970dd2565718f360b827bc346aa2d57b659de359d95fe130cc2b4f0eba805fd516174ddc73d18719e4d64f24257bed17e015ad090246cd7b807d22b36724238ac40f835bc4f0c6b424e37ef97765c73666d984f06d351260d343076cc2b1f3b1df94761112c557383bd16bfa1335cece08dd540d884c488de527b5bb28bc18323a5236e6b34eb1da052e734af998c6f52afefcd414225d9433e7cf07561392ae24ba1fe04f86512b89a308d559c2188f35f3a8f5c78ec952086883ed61886ec444bec5ca482cac77a2ffe3b4c675bb76af91f231d768f74e56e119aad8ef8689192cacae9eee3bf4c397478c5079dc95055001181b1f6496599b3ddcb64e3632491464460cc6d07bba4c1c932d4c76572137dcda8c23a9868b6a3c3f55e5870afa275f61dda13b5febe12522d1acc07c46ba7ffc872c94ca22a078e755f2516da8a30d9b6fda916a16927a26a981a11dd53c7a8f09a20c584cbf0c8e220deadd9a25c072144c2bdb13b9fd7718bc64265fccc38a244e3edd9f110ff231865ebeb9655ad270ce95f1d37ffce4cb35c3a1553f3ffa11758c644d121e936c1811b0ae1dcbde0c8c2eb7910ce47384e8651697cc0d8a61aeffcd82de0cfee77f369860f04de9691cb79f5aa4fcf318109ade18265b747bff56d42f511398315291692ce08bf1331a5460e951d6a7dfefa60578de3431293ebcc0818f64b05ed2d374e671dd014e610e40e4837f6b47cbf97b484fe96ddf1cedfcaca3da54a7a62650d2781149a966eabe219d93771f64b35675e4e6ada2f03070ad818d481930110cd24b4210c0145979cec9b5eedcc14daeeb55ac9f154fb421a2c8d67a76d51b745295208d93403491f410b352beb95fadf43878329486394c001032c2013c53c74449fe24056d5d51198ed4a02cb6e5660ee4a4cde3c3b729caaab0fabab671f49f8fc28ed9c7daa1aaab5d444cc729aa3ac8886f71d2ccf98dde5a6ee231eda2dd30923238214a4f0e9a2500a5943d3bb3164cc9aa58a262406615b879c564ae2d7dc3e5588f3d47b4f3fb0fc9fe9adc9d7d6b79e39ce3443df6190c1a193ef92feeb228994ef511ae0bf7083c2846423054deae0e1eaabe82123baac4b558c6feaa58f01ab87413246c714af9d4aade6d2149c7dbd3b27467836f3b893176932b4ce16100af4f424bf353b4fb487de8e8def50efe4f322e3306f84b663e927875f1df90d272d1c00567a8785ced5b56e2b1f1798cd856c7b5165fc94c4f9485b6525e99d82a8c75b41b63eebaf7950b7a90e564a7cd09c68cb9581ac88a6b37ae80040e9c08ade9c1014830a322818aed049322ed174c5633b33fff14892eb1e7e821ca49fa8a7b4b2bb772c67e1086b9f6e1e4af3569b4996e9d40567b43d09bb7d9d6e37468445554920a2e4145ae50b94875a13565705388624180c098674c1155f0b6400baee9ec5856d0f428fccede373c63d311d67c7e73fce6ecb80027d12b968c51baf3ef4ad9976693226f4985da973a472ee1289f839eba86ac4feff780c607fe423adc64ce3b96d265c4c42c1fa15d1bedd9888262b088969414a801b312486589329a50b229f5217d6a81ebd035f48e065d77b81b9f0c8536be7663397c582d07419ce25118472131d1d18beffef058e34644088f0450df3f27909f63250c0e3e179ab51057e89eb56790d10400125ba475756c98d00a1149724e7494df4f1aa9cbce7cd26a59f65c27f2c08fe8981e994e802402be82c77a37c750ec2d78966f57f6249fcdb7888ce9c64ff1434034521ad7f6f719828a878b71ec4994fd3727cc4bfa9ce1a5605a0df4565fe8f53958a64ef0ea355c0c58a9850c699041cb4aea45fcafd5109a89da4808086198ff9ed3de3904e4ef224540dbf629bb207b7b535ff05f8e4ac3e52e1bc0e3e66ba0403b8060952b29ccb7f9e3074de5bfdee6238520d620222adfdac5348bdcb6c684bbfb569a51f4307a59c175f30b7e08a06d7f59ab284b20d95e1863bed11ef603cc36fd63dcb428871087cea858befde526a935a006a7f7cbad3aae8441c839a95240ee222daae9db6ed6b855fdeac6c9baf558ed3ac182cfb493e3a562ff747f7bf4463def94d2a9c1169655f7ab8c7e5c1247d306b94de160a56bf00e7e56ff27e9226ae3670718354028af11eb3129f651fc953150d0fdeb56a1204977f3abd22284174af0d9ab92f50ee1fc6b86d96e017098b0b614ccef5e73a757902a6f347c710dd1dd01966e87d7caafde2f17d201ac952c0da6a17db2bfa441bef189e84170c2179ffa4692ac39db8e621bf9be61ce86d6a69622d7d7ba42775e3959ad65ab7970fa6e3b44e029f7a329368510578eeff4f07807670de1e951fbec39858e927ad9f4d55b14bfda5cb623cd72f42f64567116a774ff53e01b1f2216de9ef9472814b3e53c79126c54686528707eefcf0ecdeb44e4b20efb0256883ff8986df48187f39c025f8b4ccac5248f749b7dc8169fc60d0b7989cf40298c1cb9e54fc6776f7d8dd1b5d1e8845cd7b4c29969a9c855b3258ac8bc0e98bb5b0fb1fd998e94331ab46a3dd5cd5df96c7695f424855afb35a012c42481e430da89583f8dc177e5bba08265461bae911343b3cf1668578935c9a446358330a33dfc90fbbe5623fcf9610278117a9bbc7532ebadc2a53954288e1ebe795e7bfbda6a36c35cef292b7a6f3f7acaac7052740b926bc7087c8235c87537f695432c0d6f9fdedb98a54a72d38a3865c0d0b2ef1463f119f8602086559080dbbf0614414b9659572e91e6a6af882cfabb5e9c3cf01fd5a4bdb2225e7c16275e1c519dbb303e25bfbbbbb55ebc5b24f989e90a3d4132bfd17cc7c2b84c6f53fe477fd3d433994c53c7c50fb91ccda26f5729bba1967492a63f9048b5180b0befa2ca6646f1ee208cd75ad7dea3c64225456459595d47e1181a59ebd4213790b147fb75d989d2aaac84048114e728153542336e35647ab245177b73e3d956cb71c6dafb1581690852114bd1f6e6a0c5b4ec3885094181d1f9c4d18060389ee2fe6e5df8c03d19a980235c69a9112bebc3bffc57242279002c3bc4f4f259b33867dd35f8b62b3b923a10d83c0047e5f991cf84445b767fd80527b4233e2b3dbfec48eeb269a59f8473866b68ce4ad28e04fc8b1b33201210c2a89032cefd36fe0abe73a1bbccbd109a7bdf09b558fcf5357d3727514d31a2699c14d5a182db5a2bb387dbd88f0fccae177d2dfbb067aafec35d96656cf37248f6c21e4bdc09e108c46432793f72ed5617d1784cc0a3bdae448e2bba73392c6b630bd75978831b1cdd7bc71023b3431c2c50fea21ebb8cdc676a16d452c3e14ff4a44b1b7c98d4faf22003799bccf68409de38f701de24b337187ab1d4ee8d74cca2d6740613a9ffb3fc0f699d20e5d3b27778ee5f07666b2ce0903bafb57a7719ad69b3889fa14994356dd6a0a719d53d9c54680de19cd672c47128807232de3136c2914b6299c4702aa78ea83394305648f0392951b7e5fbce386e47756ba34e85b10b6bcea07561f07d2b82e8e6da341442f33ea5c9dde98551312b807a80d6777033bd854cb8dc92ccaa1300b6493945dcd361b22d8fd6255a452c3b4c97d48d0dce9f1a50069bda57e6783a11d66a4db9272f14cea38cb9057e5cd32f6b45aa0f16e761b688d6c9ae5877b9df511e18a0135f6bacb94896e390fb7f98c12d70b287bb002a7b21db53d6d09d404a236cf38743b85576454bc7e33902a13267b28c3bb69c9b26851ca683cc47f5f05a190b620d2f6e0103158356c47c81844f601b605186c511b94c1814c454e179d107bdcf8e1c83e7d4806fd03ea6e0fcab648b7985fe406f65cbb7734a4b127312629a50cdfefcf4cb22f637aa81e13e7aecc2f7a3cf5b7cdd99c87baf33330455fce14299e7a15a09d320447f40ae87a1ebd040045a2d98d01361a8605028077c4d040a0c9d734770ff01d7a7db54127a0c3149cedb91bebd4723a721108265ef27f55a2006640b4c1cec4627b6593e5f926ef92e86a1ca60ce2de533e746a87a1413677924e135494b39c894356467f104e2590d8070a8b0905c51bad024cf2922446966d6321c1c6f95130a623fcc785123159fe276e7c623c9d7763333d834fa275835cd8dda189655f92588f9e5cfdfe1fd91a9a17190bd8247d3b4ec7adbc8665bd1f1c7841bfcd571125aaa5ca7643632b444086a58488d8c4d180b7cc9a2c2230a0a9096798f401462fb88a31a236bf2ab68a620121c668b9aa14babd6389057d7c5c0c5c84dedea0129d8d46e8f18b5dd97ad0bbe46aafe1320b7fec43fc5551fac882a1d620e9ffbd46ef675102e31250e04ddc9a1b74ed648567d868b6514fae96e5b449353dd0e0d83fd79bb3c5da103a0b835f87d59bc2f8c6bdc3b8ce4e75978c129184046550ca012322ff1df65d28ab4d59c1a4e79f917dc34316ff8e232c32784f939f957decea005d561304997b73d49718deee21db82ad51fdf3d25d7b857649262e3dd20bb99a4542134390627724d0d2356fb438ed0df5f042184e9d44b1f3d1ed4cab39ddba342d643fd6af22ee784e5998a522178b573727b273b1c191930e49469fa947df227092ad3327ca219f5ee4d835f6d7d25b29f6d5bd89fd2219708a7095fac5b6363dd098f11d3b4c35faa243eb81f93a916289d7a2c9334d91a86149108ddd7712e617855ca3eac4fff1369168940843fac1d3f726ac5f670882c53cb056638b5d544e442640835960fab7f2b112c415aa35759b9a9a34c68728e36fcb717882096cc03a5f602f7bc2bc2196dc59bca74e21627d130a497a57f298679548303a272b250c041cfc57269ab20e50429c3a0e07eed61e67831ac72125e4a41ee5431145521a509ae343e1580000b5266a11ee418a95986490627ac408c91629d6b704289a47da69cefcf878195d140e71fac892405101c126a074bbf1d649b86cac1e33f574ce2efa180fac0534deead08e6522bf57680b3e7ea7fad31de033077ecb5c0de3eb83a08cdd72e05e250e7eacc3e4896514fc652708639e80357ba8d7592969098697ce23a4c9183b61cb3f8ed88127c2846acc88363414ce872eb003fb412ce7a324a940d8492252eac83e61719e7aece3a81111fda6afff4c202bdd2eecac9f34034cf3ea554e8cde63de7653c97ebc8dbf042527831efc5aaa64180cbd3feae15db559cd9712ddf5e33ad4148f378c4c84a786fc52348119f697733770302445a49af8bceb4ad2ecbf22e33a5a7bbaa09314774a1de39b1a2c476f6e1d91dc7fb4e8e7b679eec5f73cf5de75195e34afa45811dbe4a4fa24383c07b6e8e02e9b98e7e1d3410d8c2f3fb74311c66b6067609b1f730c0d98a5f7ac987c11c76692ec3683bcc8476e87ce7f53b2a016590b8dcf6adc1b2ff78c61bed46a20988035a11f3b612a76aa1ad203f1c1ba30a1816aead6fd06a04be3333ce96100a174da379792d5bbf04a943045760efa545ec2924da391d6e83dfce5a9a776ff5345b1afb455481c4c0e8af5696dd9ab0cc57b965e5a59ec634fb5a53c40182202af0a91a4a557308fc591194b8a7511b10c0d0737a900ae22002609cfe1d5e9958b6463c9fc199f97a6863ff7f23b32b98c23e79327364641b0490c35ddc4fa93e1850be6f4f744e39e82c124bb3c9e15ae793a08e1a2baaccab9d3bbfca56cddafd3e9ef7d3b8c199827d9ea128c13017a2401e9949e2fd8f6a0ff87b10bc9862cdb5b68a7ac70fefa24941e4d8a1024249a7874fac25c7075ddf550fb579b42563c6ed0c0319f39ab28ea1e692aba90c1264748eb6f5887bfd6aed58ace36928d29e694a87824b7be1d6e961dcd821b1ecf6f198a139677cd7d8462e5bfda608d99d543738484c1c79d9778cced65dcf74041ceac66099bc6776f24e5817cd8cab14dfa68f13f477adfa54fd3a9a31422ada61edfd699963afb1ddd2cb5328c28a85a7c1954013ed81dba63c9ff5119e65fcc95bf0e06f5a36031baddcc27ce10d96ceca34aeb66f099dc111a36f06c5df009508ec7b2288e2840da6e0f25dba67bfe34b671787519fd9d39da3d6bd5049222518bcda55f3e4dc5a8abe1d407a70144d7bbfe2a3eddfcd9dd2c3c4e12cd6f80d044268767a763d4287e6c652c1b63794245b0a7d2b2cd22f9ec1a7f19b9ff04a486e061a7b4b165e67959b4920824d11a9a6467cb317d03ad052cfd3786b0f5297bb4d1b7e5859ba7d71833131af4e129d07fc06866c81c167cf87b8d22bfe76b8ddc91aabc969c5b95547cbbb36f7bb44bea570b63d3b9ba7d3b47b32ea7b43a414450a4246057c747f504815265cfa51662a870a10a652188f888f9d72ce6cb94a0d05afb7e00d601a4b7eda0a272bf9beb5a960fd449521bb15f9aeac37e276482ed42693fdf0fbe1fa1443d87b256fdc208f04203d55e24b9d8d0322f2441f2a5886d87e18feea0e1d8717cf862d3e163b14aad4b66a2fa7464fba4775900f75a6755d44cd08d77c53d41fd016dc9ce159657f97122c19d4afc7c8366d700820e7b46b996e68cef44cec312e6b74ae6d3ffd7308b4ad0b84c6d201d8a4706969c777465442faab60ca0ac2cb4245159329f59cdca9bfe25280d670531596c3df0b9a145514804b448d48ced79c0ce821ea790de12bdcbd2b73ee99e4e9adbab2002e0ef8d14bddec826a8046131f0119cecc4ef69b40a0ed8ce243a52f5ef376d3a6175f69b562e26ad04248b1ce9c1875a0d5ed78e54a3d7cd23f66aa1ff999dc78ff6980e97475595c751615a540a2920eaee13fec1495b3f7052c9a00c8aa02231e1ea8ef738bfc0ee94e38acb83a7046264c28e9cb4dbf46656a0bc299c286207f26a71e1a3a66f0ca67c2c67d364cad1e6b54d9885371838fde94c83d282cafe9c1cfc0ec23b3f7c7969e204f041fa5c6023840d7084da7a9f67430b4f1b9f2cfce22b7bdeed8dbab66f53bfee297a6ee112af791a60d305ba9919d1bba3022776f9c83263d4e7f5e9625fc99e337797841a3d1ea7a4bff892eb0bde711e97d2d38b5600aeaf044022aa9c4c7f9e677c761dc27aecba24465ebe020a7d52c293919e61f6ed0e4937a803d6e9633d140f8bccf884a49b72c38fcf335fda98426ca901c68f1b21c3c0c7253fd4ba511eb32c96e0a9dcbf1c08e68b9f10ab3cc65bfcbbd410d8b420c144afe2ca4507616d5367125dedcaaa0a6d21542773383472b770ceed22b7bb5ac2d82725b1bcab55fc46cf6c131ccb35bc41371e7030bf096c3de59a44614db88bb83679c2dd22914c816afae2404a8ea14ff4d6c67910457bd3127ef3a9842e108ad987d6ac5788f1241c31945302e7275fc91e52cf1c59bbe11c0b1f4eaba36da664c4b2f395f2b9cc4a2e3d1fd0ec562b3927513c851eacc4ad324c0334595316e2e873716bf7a2644548151f6764ac46596381f4daa27f970bfd1c0287765c45f3073bf8730e9b59f5729b86e7dda43feb8067604554728f00e66dd543640c804f88fc2b1c42b478da6fb4f4c9e1b519c622f134cd43e1681a826388b7b46f08b563c2acfc60bac1308ead0d46b27d62301d1368f3f90fb76d5320de6939f55ff2bbcffd1736193eed6f4ca11364f02b6baccdb79d57475183a3cd8989fb533c210f3433fe71c2ac7b0087cd083321769b30b32f16a5dd57deed254855c32105c5c53780b4609de20a39f07050d2c5c85f398d9b3e839d4ef537425c89857d3c81e78fabdf2dfbd175e70f1480a97ca038d8bdd04e0cd379eb6f70d8068b76d146c4a0dc67701819518b7afd71af6e1ab485c57b3fdaeb9af077978c850586976e0cf7fc86ce550682a8e15397629e3000cfbc4b50276e81b46e1ee3fa463cef1349a103b1f1b93660802e7aee8219debdb3a7361032e558026d7497e58cd7734327712eb9ffc97e1e4329c75a945ad680056573a745d99722412222f89ab0c4a9561701d06cd89b3ce139845fa7ceb99608bf03876f5841faaa1f0f54e8787b94ef8b704f40ce28f7f8c66a6008b198666b22781f713a5323ad6022c329524ad1643b1261585b8883ff9cace0df38729542778aab4383361937f693a0596d9d1d1fd5e1f3d0df6a23cb8af059da935b5b2ad835052d2b6ab327acc305b0a7a583985bee997a3e0a3d50d7727ebf260062bca5a8274057b6a007d21ab62130bc50e6bbb963492cc1f64a34f328b021650c55cdfbd811a5fafe60a55ebb1e4f78b8376016a7fa684da47a8eeee0009476e5347d8f1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
