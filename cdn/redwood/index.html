<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e74fd9d8e4aeccf7bcb91c093278e33fa425e58604fb3433e98b95cbd3fb9d615e800a3708b8f13332e2f84da467fcd444a9e94e765f5584c08d63c470f4bb18f846edf799f86b456f29d514885288eaba9e242f3e68f30ad55821f23087ecfc8235165ebefb2e3f29be7cb4224feb99fd5e095119243b375f39c1cc1fad0f70a9fc84acfac65773f324b793bdcb3ee09a1f29aa64f798e91ff7370ed590c40aa2b6364f71af66103f3b170128a3bb6c5be164352e2814fc0ec3a7239c345e67da5a5ded510d75639d433a0b109046847342a1339978a7e50621df871ce28e7464f6159c613dbc1eb5fecfbeb8663fdcc4662a4a87fe9baad2a777339aad9ddf10ec6bfabbd4819be53a5ef523946d14d97760779b4d28376c3b527a51e435b0f03690de0fbf767a5755fc3e8311fb3bfae1d1da51196d41600ff71cf1d7d7788b5f94c98bee99628f50bce1436c4ecf32df17f32294221a26b538848aa47828d318dca9e56058a2d98d2369cdeb75305031defc81d1e332dee57cab7761e9057ec05d97330917a340b8f970c5d890accfd2044399c7b70d163cb57df7b7708011901b6c81f0d89346414be9b3e5b647d85e77eafa45ba0baa81d0376627b3574f3b3bc8bc1405ce9b8753ff5a24df955e7f9c4c15f2c448b66ab01e68b452ce3084d6f6b795dbecc1c7bb20c9317e393827250b5a0bc52b16839e9b3ee382984e22f8d4c496358083e6fbb6a6f9fc1181fc13f48554a8b2d671dcc4c6b2976d9aa1c991cdd710181555eed57b3ee6322427300158f6782df42380e8ac58d98a0dfaeb960796d12b1e56c501d58cd14a7ae6479d416c1bdd236f3deb0cdfb3ff1499d6e7ca2f662d855cdf7833b7390dedd94791d3b489667beb1d85be6f0744085a8574e7c04199b4eab87aa25d16bbfb496d2ee9586553d267dcbb1ac1002b1501efdb1462664979b05024bca259cab621d12734316c415d6b26028daf4dfab2b35d737ecee4cca29d7a76387db513d59c6c059e319da4b166778d35d701d3e079f149bf70ca58cdbe60ee4fca4640c4ba7dbc0c07dba4fbb587b216a53b900a11c1a2d63e6149859a286b131fc22d5c92173e57e7d9b1e3bb355724b3d42f9d274171a4a4f3119fe4e08e812c040a67e24b04927100b467f74af3402bacbdb4e73a43b1e4328a4a14f392f3e4af0e731f3a339058f6541de0769b9dc50d9e765a7bc41362a6809453c616ddecad7002088b4676230a6faa24e9494d89613aa4ff35f7562cf77ced9190c71e55e3182a9692829230f3bc5595dd9f98178766000c68dba1f52f1f4f64ff9f8e84526917d7f8c33637af9fe79b8d29bcd1a537f204e942647ca8ea8672fa247201e6ea8418a44f76ec924ce6f06d8ca02487fe364e6e3f486c540cfa6d91f0b82b33d8d271da5ff07e02f6c12c035b34386d5c4a0fc1fc056f03fe0eaa6fcdee8bde5c2f267474c5f0687b7ceda7ff98571ec842ec47d6726147982ef348e4057461ccff86140dc1c549d96f985e0ac17ea52071f27765a0577f32594431cbf176e8db24e8dd53fb4b59fc95c9f68dd4300b9cbd77a3633aac1e69c8dbb5e439473fa75c4ebbcdb2ae6bcf23732e1d970223a6b3035f79997b3ba688ba50d997059c711f51fe8fce7430407fee9540733443587241e2fddd9b5412650f8dfd5a53f703e7a7d323230bbc0621ceecf8df19c7a25cdf2d675e80f4d55cef6e93447313fd307bf79c8867b0750c7fd9bc03924e0d5fa4dc4fb27a5cdd89cb5df7d79b922611cbc4c350e136d5f0a85269b32e6febc283ca5532bea2ed19700215bd879e8f64b8294cddfe3a3bc0311c02c2ea787a113913817443045b0469ed0ecad47a46f7c508f23b352dd7ecb1f3ee253720675ddded90fb5cbfb5211be7d19cc9ba9b1f3b013337cd5ecb8adf282d258e10855eedccf9a5e7e4c0b9eb9bfaf815a1bd5f38963a4c9abca165dbb685e19b5420b26abb1c31253448df2ed97fb003deb6a975eb10d6e4dfd025f0ebf8a29944e788368665897424fc47998dd901acc88c224c9d774bf082c760935416ebe29c13d1c1aa3cfa8efa1690eccf2fc6c738099bef8951cd29a0592f237db71a45dd13fb9766d24f626e8eff819e79029ef8f479ea24ed06df7a9a472c706889bc3fc29c723ba44b2d7c981ce1b9c7bc02f667ea98054db762607139c5194aa05071c654e4461432c38ede20b90b15513f5ffc8f2cfc089a39d295d0a6fe9ed6e1db29da42ab3a9ec9a2ebd603172f4bf36549f70a4fd6fd57f5a0c7fa7cb8de1e6389309628a9f44e8a623eb4e7f67a16722ccb36fe46a55b210b557aa43866350ca0b5a8ec076a62832666d324db1b4f784b034e98d7022d3b800e75621ef864f10a75e592ff28d25e74804d11c0bbbcb1b148106ed5e33a71023b9d6e5fcf099a6a71a4df9bb61a2832a254114f46dfdc69a2d0b278966be02795655f4906f4314cd74b44842d4d34da54bb8323851df782cba350651d8feeee251e7d3a8714e21b2b74855d1efd7cffb3dded88bb19d2757400858c5a9f10e71f582410a16d327865555409b5be51c9a25802af2af7f5562388d87746799c2a75534751cf79f4961f1009daa1eb430af610dce1e75341d92025664a088e7ac7339ee9811519ee207202e3c7ad77d18d0990570ef0a3cbf9e10cb246a63db8e57f630486717ec62617eb5ce6faf76419c13d6ae277ea236a66fc080e25639ecdf6a4a88dc990c1c383c720c176eb550785aa28943ba0b174f6c9d2152c2f26b30e51524c842010c47a20f1a731898d681ba3b3ec8a5de1ac3f5a6953977e4a41efa01ce33e4e9eba39999b6f27e8784a592f2ba82802ae3914217138bf5dd74c1114595518e179ba6f162c916b9a9684d632e02ddde3f9ab176fe70430fe56aebd3959b48a1ba3283866023e987b894d789c237ba76d5052f43ae6a6d233276d5808b7a883de38e78f575ce0549c4741fd643ac2fdcccaec879ba7db94b7ae6d01e887c7eeb2b7c8dba232d6d6328f3cf0291b94e14fbb36b8239a278c78d51bf5d4bc0c33a899c0415e3e49959a1ce342f96bd8dabb836c662f5bba83b0bc18106e0fd97724726afbd8f59562f684cf80ba07fad192264ba817eb81287eeef62f4503ae5d3c6a73472eb648b348ee19c2411b98eeeb23dff6de0c69491bc9de70ba604e752d41effbe5eb0e9937ae8ae28b60f703d5d6c452e1d517a1c69dba092f1634deffcc82be3440ae09f426f4cd4edad27a9c64419bc318f8492c52bf561fa0f9fa629521c8d7ff5bdc50bf02112ce5f8be4fe32a3d9e96eb6585a5bf237e7211e3587fe53d902ea69760e0d9b8d3fc1b078aebf3ee5079877dc8f29901ee484628f7de6272bd8694c5c8a326c5fc7a309051aa47b69fc3a5ecad6d875aeb83f0c79a0cc7c1fe1cd8ae5c4f396da0aa2abcb47e26ca7e3ff4cd0a682f6f7e6f8368cfebe2d96c05164b722e66611924d12acce474a938e616c49f1f4eb265559b6f29686e0077235f42a8da80f56e61242946560deb7b0f2b2f2a35299e8440274467003e1aa59c82167e373387244915e2f00399b75c670ef6d8d753afa89cc0f10cee2b53044ff6e2377a1cd3fa3885f5dd81abe9e93ebe37c6be1cd6ca4489b4ddd16ded6cf94d8d7d557187dd35e1fc465bf23508421656a36bb57756ed01e2ce5ab6a86ae71e75f4bfa7a6a2d270b3d2c7fc2548510afa579a35423c09412fda7ff8b54821c28fe7bce3795cadb5c6ab36af7a398bbb70d53dcfe274867dc64ed9a9c69339549800b0540c260e6b8cd5a74778c56e15ef970f11c32b5707d2aa93f0f274610e804d8f5b218abb213a161b7400bc96ca52c627e7fcd81cffafcfe68e82425d9aae7d1715f6763a37536fe87110a328d10463f6f503af9e199c612fd33641e1f707065dc18b98e023b9bb7846ddeda16a10ec31c0f1d62430f1751936865c09889fa4e2dc7714d9057df40cbbb6a1415dc9b146ca381a8f2b9f0c599723f24729c238562390345b94ba4a202cb79cc8610d60846c5d846a9721e47363813e685f340774df41cd3a1c2af03ce648dd817dc567a2ed306f80a37ed1407c56188d7007664e84e27359014a79711790c58f7b5998900a83a344201c822919e25cc363766a95f51b872f8db37308dafb72f05e7dd5ae1888e6edaf7fab6f137cea0a36f46a54b3b810f517e286ce285ab4d9a8d7155fafe7283da8bafa6b3bbfb74cf1b92af6024c10386334603ae763a95c7e33072cd3ef7140106ac9f083c6658581760343e4cadc02b18588153bde54ea70cc85dc1034efed16c5d7e6c263780b4abd36f2ef1762b9803155c69d0d173e82ddc10593e90b9739fbf1855e1358bd4d1eea60768d90e7d44deaa356e060ebdb47f406907583c2800e68a26c7012ff65fabafb23c2407443bf2c5310785c15783c24ce3f0f296f831b12f6d6d644f447ffe1e332b3048645c814291545418b1a012939508e5f6da51451e7f175ecb52166e6945001796fe1a3f120d3b6a62a4d37cb3a07e6ec79119c133e456f34192991c1c3f8a48935d169359ddc1ca6aca813d0b40182553838877673d32bff2796f08692ac3eca3d2de789d7ddb66a0565281d90db648dcec2f44fe29115002e5ea70674d9fb4ff859f395efa8fa643a0b202e825c77cbaa532c32e3d855c520c4ca98ff2b71937fcd2a354e5ba8894572c9c5b05e39776edbcc7ecfd83602c98b3dbbf9d6cf67b2e828cc43c6fa8966008bf5fc9d0334ae1e0b7cc225ea81055c4fd000e495901fd0830c1cf4b46d89dbfc671949fb5be255d86768e9164654420ee201767d4578e418c3850c6c145205805100d117c7bf0a6c3fac6ad22cccd0434dbebdf60c5006b205c8db230aebebed082cee69d90885f35b1ba174ed2168b31128e10ca97abd87c17545d835bc60fe15ac4c9ef7ec4e8934652f79be658e4bd3581da3f90eeb648d24d9b230103e8736366d62319608e9531d05582768b699d3c2d300102de19e709cf1a8cc8eb352a0c5cc9aa84a20d15091440d987f2eb4a8a4529b0fba08a7a9aa4cb34616fd1f72a3519bb182b44953c356a430e7230f31803fba382ac29400f0f94b322d52e6c45b28ae2ca9f73c48edcbe58ecadeaf38b72d893feec5406559d7e8d80bc58f781e9b6afceecf101be3cfa7e2e52b9823371d4d2f4216d8929c8488ee1edfa18a693ddb998786d734fbad8f22ddeeaccb0880de1b85f6f6be5e08be44f6b7240ee58ab3d78504e9379a957eb165b48d0c4e99ded69d873749f5525de6f2eadb88cb46f4d10179e1cc3b0efef8799bd18ec1e4e8078dadcf3d61a013d578fcdc4a7d420b8ddce237e58586bb777103e0b4615271a6ed7f905dca83aa38167285957c530268560427b43b409fb76c8b8545f3aefd53ba50b444d328189c07117a0fac85446356d5d31ce565156ce1122cda0b0508bb10b4377db884efc04deb84f683773d31bde3e3a8bf8902e3f6dcea586d17e6b49a02dedee09883f6cf3561ce86794706c7e26484f6647ca93bb78e7cbbde77d460e5ca217c1669a52fb4dc8de5f0896625179d9b1d70e3ff5f76a5fc57d1cfea64405cb90f3be2e886d862cfd6876bb56b96cd2e20b70aeb30c8b6d01299082fccaaaa46228c8bab5a192d6365aa448a7f402088b2687489e46074b51fa7287f711f68d875e8be512236d24c5a28aedf14fc21e7357483df99eea9d0054bb4352173aea62416d2145442d21a5b37ee6b0d05dc41632e7226ee51e4522c0c95f4663a8f21c716f29b0ec48a1140ebb48b48c44dbff310fd996e2f4fdcb3bf4122302270c9779ead6623c1dd8ad4ce0124f04b5c2097a6e622c487d72f73e03eb80e4fcfeaf8eb0b9c2a75322023717df5393f4168e893ed85b7a0411c41ecd928ff812c012555dd80716fc7deef64a2bd552181692e8ee3de2f43f3d379f9caa067a2d41d00805245679818dc5b651bdae3ed5f9867180cb749947af8b41fc1d7747f697cad7cac044a4a64e71ed5621bfba167bd1714445d181ffe13581515bf19fea87d737cf95096d63df80966dda0c7e8e55f63de0e602a86feadfbfbf276120eb317418d767669d83015d34bf133a94158e50dddaab1a0eb241f722577287d95f34ed0c722e76154966bb651cde1681503e5be2f83f7f85b191cd9eb9374dae06d6ff17f38767495208814b26bc6554727779afb729aafe2667caae76f57079ededacd3efc2abdf6c4f4adb13a332dfecf157379bafd5dbb9a7c355e0871915e12372a7cb8f299dd461d1564e39dd6c06db8fc0ac6a684b1b014e28689f171876e8fe1758a5547fa42cc7fd4e9a1a08ff4a71d02f4f8663b599d7dc1ae16c19158fc7d90f10371cc342381213dd65ba9bbb3ba910910c1f90f64d8d87b8c7ce5049447b2e57dea693202f11ecf5fa506e84e44b4e7a919994fa2cc95e782acacda28cdd62b5e7c83c2e17622a98a8aa27696cac66a8e756c0cecb499b07dfcde1c3bccb6c35e9c326687b29cbb881a3996f8c7bac4bf4425904c0c2f1e4374b33480ea4284bd9780c67b849d0df776027b49a9f7c02e990a78838b09ea959fe5f725b9c3cbb780cdc647a9c907830799b840beb584e0a1beafa2380be713709b540a5681b5ca7fcd8c2a6489bdcc029e87e0eab7e0660f81a29705503708d32661a5a2957f904bc42c4a56a112f808f365fdfd41688c73527a0903debac87d647acf62090592afb83cbc117e752f0b682cae6b0207aa6d0e8d31b8b6083d0f7bfb044a646dec2785c4cf51de427ebd02b6c1a19afee749473338df4d3854b945e82bfff615b325204d22224a2558eeec91469e0ad786415e3176aa3c290d45746bbbc587fe105b6a40d873a1fe7a50641678b03c0f569822cfc79fc552430679b8cc81af512740cee85ace9bd4e938f2b55e1f30fb8434bcdeec6105d3cfb4950075edd6518a1a576f30a270c8cf5a674ed9dda9c0017c6dde19dcf87d8ab221df980ae0ec9fca9ae6d258ab8a42bf5b81ae156342b15183d0565ccb0fa62f94ee043f3924acb60c6c24ccaaf32321dd3e3544a1ec8f3fe5e9a6a84c6b567350ea916ade73debb2fd10c34fbf22fd5ed9f24c972cff3439ec3f0ba1268bb504b81e4f39f1c72c7861611041f71bfd214f87df4b9a21f4c627e0e116d05ea4ee7479d6915ed4eeb052f469ba5ca94bf52f015d2a27adb99de20fb7c94bfe208b2729f424d7e181f407e6741d7cc3eae97174f4efd6640573eeea725c5f36bb25aa362ee6b82d9d6cb2b10ba799d35da4045d51c106eaf0bdd936d749d6611a1c50e5b3600652215bb412bdf408edad202cd8c45daeaa64f82bdafdacfad88f9369b3a4d01e68ec16c4f9cee6291c1af0d9f906e4c474877b4cdceab790ae3a347156095496b69c04c93c1f52970a8d51952e1a405ab05d775b21ef7a3b25fa6545fb756516098dfc0b061cd6bf042c7d1a2eaa391f507fa6c046a70d76f259544f4f213a5552db45fff8560f1b14a3accba8d42815c5b5720c970a9776f0b70e44447197ff28373d760ceca14a8de272dc2b34fd34f1b89ac22f84a2e16e09da77ad54559cdd18b83fb2e0c59400ed22615cc1a2f0d5473e02eb5c6853726f679c901077d155ac82fa572288c03fcdad6026644c73261587fcda9d1429f6f890df1291ff17dcec662a2b23ca2efdfcb26d9c14bf2bb7c482c23557373eb09a0b3f7eaab9329eb5e0a0930adc92b41cb42f7972878ce0ca005de0aa292fae9e3425f82bec9c338044d0f7497c8a20b8ee1a0bb0790d18fb4dd65b0d3ea2a83a19bacb03b1d2fa270d9169bf82a891b36f6405538c2d23fa3777fba4d282cbdc047420f9590cf05ec477d7ec915ec16883d4e20c9eb5254c59532b65bbf0710d96831d270fd1d776d372f4e47947fb71d464257218e7384606f1b31f47ca356f148a9dfb037e80ec0416d0c75c27ba2b02f9870572bf9927ab72eae480ca5d964d284afc3c6b76bc016921d4744fcb431c6aaf7f438ddb891279323065e495e1c60e7570a1a934d3b13b926349a7e8064dfba5ef54e8432ffcdf321fa33c9db34b9dec702d744e51b98d8ddbc40685a7c8301df0c5018d7d0517e9ff934c1a85dbd02acf35721e512d0ff264e2a0df662811612948afa8504ef2e8ebfbc099d16bfc6fb5c1aa677d5706c37781d3759ae02769ba12818ba87766abc1fba6a6da40f4e7dc383567bbcdce523be4ee554d7dc3d8c2a7fd1d3ac0469dfed542de1fe49eccc0e8ac545dce2ad6ff12b062b5aa1214b24391bdbdf2ccbd576ef0db79af062b93ddfb0b586da018e0889ae161817cb84953c130f01b31531006587705d8ee99a8a588e1183fd4e6c515d2fca5537974cef3f3b1af90002b3dd184eea70a27e3baac38336be4d1c55a04fc3947bcfef71702330fbd6f0c403807308cd5a75959c66329eb13ad2946016c6f4fe89e23142581764b9b1470ec5a0247c081ff06882fa1802c88d69a0aa9fb2579d0c20c4275bb9d7e1816911c6e10b9b9dd6d5ae49265c2388e9644322f7869659db9785602b5a36729d77510f1f6640e441d171d586c27cdb433f9d570046ba3cef94e9bb8dcd6af1f5a723338f261f51e04c691c25c69d1cd792df754b60c7213e591687d1840169b69481b3dfd832a709ba50efabbcb27ced0aceac848198a05da94f6946c4ac6130e863ac5c5c061b4ab2046ecfdd50736721744f3baef87c5d8ff1c709b69168c0d8511e637e210adeba49466e159ab51fa49d4dccf2d08d112e45df3166df5e15cb99b39a39b0bea884d265db643c13bb4ebff2e71e5919b77d568dae8d1c576f5e43963523795fbac9ffee19abec684ed7dff0b56f0c9ca865df37e93f05e0c4421e4472c0c5669e79ad82004ab39e8f6d76ee174b770ac7f499cdacf5577e148e378d58338384e15ec3c1154b467ced7aeadc2889d68f06aa374be28f11ae51ab1155ce3f617f2370e73afac755d5e9b48435766c80b410b68097258443c758b6184bda869f1837767593bcefa284a72584a32c737834542a126d9f8fed0da7f57e394aadf0df84f1b7c3b28985dedce8e2668afffe69416f351077e75acb685febcd53615f471df6567435f18ad098d7927f17781f48f064a5c835cb5b8912da15823c281d71dd692b72519051e8bde3503ae0276b4f4e749ee51ea1b040e691dc9dab24e867d00aa33f38d1a8a4bf55ed7c178412b86ea830f47677d73ae9bfe6a80b2a5e7c3acb01d3971b5e0fdeb4b7695d892e0079cbdeee37a4262373e9ecdd6685b6d6f97929e0f05a2ed6884446018e20ee6a237f85107541e37b558ec69f5aa1afe09fc5836ff8abe853d887847e7412b77e57b372fc28f36e9dd01da437ea94859d13aa68e59b07b6c8e2318385dc489a28a9de0006eef800982671070f1b13384de07e04ae7714f7a8acf5e213266e7756f7c2bab03e4a5b288af1442b876e2534ff5a76ab3e97068b279d75b2ce35e13e05aeb60f5e9aec17c53966ff58fe668298c1e970f596da4c76a43db927016e36fe24710bfc29d4f9dd83b9a1c6e306a2a5e889c5c3723987a574b9390652358f8a799f01e395d9220fd56022b0843bdf3a716f1ec661af4b8d6d003a753676a688cb05174e8da3cde5b9e57f310250b2c8cefd292381e0e399c24205d2ddc92f9279c1e96a5361c464c919841895f8d845a67d3a449464295900bedf7adafb204b43ff9d3a3e543d37c464cf2da5d5f31abfa033e3997e4860dbcde4ae4e8857dbfb90c1cc68f3cc58c1905b1c6b99f3bb30575890e9fb37a46f0c95104398f27e78b025b5628381652ce5463068ec25c5f1c1c1cb022b3d97c87785a12f439a46484ef9de5d0ef501f169687392bc1bfc5da0f96753d2da58fb06f18214bede1610381c0ce9cbc10526af28ac13f53e289da7dff4edd3c1aa298653bd1fa19183db631c8b3d2cd887875bae2da895fd3e02a86dff938fee30a49b8cd82f9aca73ded10b4ffe893d8a9f985eaf6a0203169598961224892d31a17b6546ea5c5171b7a3945f5fb0fe9c93b39159ed9285cce4bd84296e535db77ea7b659477a29bfee975b7f0eafa7fd14e3e1969ea4e1efa0dd54b171e0e573357d8080df0721a6a7ed8077af665830eb30ca81b9fc7c18cba9b404d4e1e8c6881e2cf2e4f1d4f135f1e4de7701e907300d6f737a9204f457a8e113a444b67212fa63cf2ecc13b36c2535145e537a50ee16c7db3f1094e9b26f0f39d681b44618762b485a2717219fa142e0802582ac161d0bef58395e6355ce2e724e6973d3bca2b5a67f167f745cdeb3fac6408b93c9dcc38e7766964e4ac5d0c7107243f1c9d0572dfea8225e85b63b0c40573cb1f15a3e91d946bb98f5be51609ba810414baad80c15055c6875488e676647fe8153f78b20d70b7431266d6e656a9ce5da8f03dbcdfa6179f06f7756b81e53529499196b9decae96581133e522767a57d4e59058e6cdab4afd5212505decfb2387afdb63d02781f2e340b6b8a435ce547b8ae12f1e5528d7f4480b0336749b1c277962776085c8147a418c22825dbd0adb04729b0171e0772eaa68855357c823fc16afba948748c7a5a3f976da1181154418932d8741b1e7df1b6ebc864f5fbea1c55786d97966b94579ad6aa03bf47b22bd863c22ee93de63a1fcc82e89b5a9d992b5e9b9ca3c76c0eeb5f01755af8d829bbbe3f4466e0404ccd279eb0df69bb3d2afb5c27718f15a68a24f2597ac534c48f27845df9d0f3f46bd1d12a278237d9e154bc46bf0501e66210a79772ce2bb33974f79795dec34151d9a48a21474b6b0b50b7dc12a9c664e3003e644cb6ae79e17b4f11e528b665169e90692dda8185b6a27af3d512e9066251991b897ba495e81fb22d1f905711b6c08f4fee44e5fc9436285603304f967901db893a9d0580a40307c555d6ecc6d25e8bd40612b12488512cbfa0d0045f0f7ccc4c210659219e5fb0980d99e3a9fdf8f3f09c6fca815e522b989656c4c62e5ee5dfddf8cf52e49b8f5eea7e9f07351c8f447da2832f11aec58faf8337e1ea5e483a14e02f6cdcbac3fea19bee2318df091ada5c6ad6cfdfc519b7df75991fd8032ecc0f7a8bf88586ed182e6eab8af3bfb2b16ff4298061cf671fd1d5b93b906f8193da5343badbd50252c4b626fe5a8e2c0e74edf1089f2a362cb00fc01aa7345e9f65ca37ee6cde7d89af1864fefd520177164a68c67385e9b8a0af88d73a76427a458539dcdc1fb5a56ae9d3de398e06b950c726688c00dadb93915699408cde1fdf67423d2086ce4ff6e0af93e97e38cf483a13945a04704f39bc6e930bdb41633044be7431e18fa73f53f73bc8ba51dd8db5d64213d001bec20f6b131ccb7c79b7ea801ea31201371eb8f507c02bdbf1e0820b78307c4111ba2b7cc8b5f3cace6da4bae5edf8ad1dc064fe1d27294bb16a8d118d803624a18cad088d356c941635bdd1536ece5e80ef41f0edbcdc8430e86b6ef9ff5f91838c98c4b218a081d00901eda2eb0e833899c98bae8a3200236246a52d091aaf58b19351b189826a0eadee30d5d2de12e2c791c856f5d3d2af5a06ce0f74dea7a5dd8bd4c4bf30bd67b86b4eafc1058b85253865f45c9e6ad861ba07a123eb7feb0f8343e00dd5732b7106721d8aaa1042c741e6dea9848c7ef4b7ad93ddfce7fa12e8c252b55248ce390a9717beeabfe9b349335814f356adff3d15b1c518b200e39f4ca14b8e608a23cad3046d4e4f388847a49aee8ade94d54b69aa4e532335329be8da09e5741e65ca030f535e5cfa48693b27dcbc16f3f758bb4d5ca5ad4e1d0349533c04d76c8f5da5e456fc91d1c663c4ed58047b188e82d2741df8b9f7eaeb1f592b9670a8bd9e87761ce69d7cba8c3547863134e1adb8b4f20765fb59f0987799a5c00db7638faced9fb160ecd87dd84342e599cff6aa0d4061521ba919ddcdeffa4cd705b6ce6a90245c76a6cf83566beb5b51b95c1f246a2b09a48aeca0a33f0c263beccfc25a1fb34fba1bbf101828fe5dc55de9fd20859cc9928c7f4f787fbc9585f2d613aef6a00686545fa0d95cbec53dd42bfee126797b7ff933a75f268a493911d6ce0c20cd06b38063b4d1741cc7eef694876f66b7fd272451074388f276953c5c20be8a0cee7eacfa71a673bcd0ebfb6322d7172acd0f093c64e8d9e7cadd667d8267bb8f689c2cf20b3c4588a2a0a1348befaa5aa74c9e10520392ab01464245f8bfcf96ebb590b3ecda689c952f92b5292f43e96a035c59e90dd1f6782c0dd73445717c94c10a6bfaf329e9203754987a84eaab7144479cc247804d5e31aa4ec979992ced02f2c27a96542ee6c7860449ad5942c24b5623ae39d2edecbb9657dc9df6c25593163a1b5e6f6330bd4b65d767ebc8c62f5a3f6d33d5c8c7aab0e431da8c14da55e60e8946d499e5f0342e162cc90e53f6e918a338b9b392bcb5977bc8e840511de6b25be0037ea76aa11a37e2ed1fd8364cde48667cc737e731c6251a9cf6db827e741fdc12f6770602d2a6c50c815f65a5d06eec65825eb19d6f8328877a44194346542ab414844e921409c54c5f35111b7f9b1b882fd3d70351dcb8eda0199f4f6eb2ec5610e89ebe60482409577369b767ba113f4a43e7611fa423168bf7aab45cee5bb721dbf5e21d7a2a88d5d556b5dc8afac5c96c2cbba471b303a3d276819f308428c4318bcac79f7ee2e2a93150017fc22bef4a2576a21d59a5466d2a8005e8ea4c6e9b393413da181ea16baff64c622af273a1fac4c641c94a1f5a9aa047b030feca99f0686ac57463ee2a48be7e6bf23de7a8c6bbb9e10d6d27c97d708789cca7473cb857627c9545412d049c78a4211665d45371ce1653ddde552bddda1f3a4c66299f6b1982f848a5bb825509f56fa49b7b1b7ed32f120c71d2d12e4c861e217d08fa4e853ff44eda953413dbdf2d2771ef780a3636d87fa33c8beff308e4201d3638c2868cade31402d860a6375e7883e96d112ac779fde0ee02a1e56b1082fdc98ad62edeed01ba1f5943c3768a7ccbd25e152459c59d6b39c90b78fcea5f5037be48cc13546d2149ab857f2ec8ebb18d471e1f4e7c70b92da68cae9d7b306df07b6191ef6a830565b3f938aefb28bc003ab82f5977b67cc766127699749d37dbb3ba1b14a118abb25ec74dca76ae2b9bdf802fe187786059882f68727d86b5fdea6924079d5cf692eaa763a3e483fa20e4a3c863e20defd1ecb4f9bef8e0aac68abfb4e62e9304b1ecdb205e1d7ba435e435f8e254cb50ad12ad171537e7b0430fc86e1293e58b917ff076ef4855de737bd290161315d687f0df7cbc77c7d5c937973fc549f5a50aa633cf1474fb0cbbc22d2094232be9f2bbf325fdd9d60a3717efb7d0d9801a882487f9f284e04fd8eef9f09eeb904dcad2ba726034a91f1c13775a38f90ae592e6ff14b943e9484a4cfc5b1b89267d66d5d12d813777fa81546feb36025ff0a3fc5c29520dad26ead9412e2bfd8000d8c614f7bec767f248f072f93569d6ec8f14830ea077d920909002dd71d8af26472b42ad982d1939dad7aedd6d13444c492b82d0bdf49245e834e56dce5a62514a7d8f10ee5ab3d71c75318dbd50661398a004f91b4484ec9390305a7294dc34c3d677261043f6eedcbcbf9c9496b6e39f435581c2dbd4b3b0ccc596b49992cb40096d63cc962b87b8847ceffb92f9d06c9f523d8f5a08e16302462c9f3a3a150eb1d0d156122993b3f9afb3bbf0d4f4a74202bab670fef73e375047c01b6ee952fdaa324a1fada7b6e93770f546281f979f855518d6644dadde08460b47d758891c2e2c2b02d55c01d843e013e194549333d093f5a9d2b1fc3f794de4b043c2e0922f758bb2cd27384676851c986d27b9bc146fd6d266dc87b7428a295d7d5d5902f812db78930ac5fed2499cba85dadd81a9656dfa4affe79807415136d750a3519bef50162bea56d55027aaf1634204bef7e4bb3ee87f23b7898bcb6fe26df171ed0a736ed989ad6965fcd46602b54e079eadebf68325c2718dd531f68093549500731f85525b473835a35bd81ad2299766c7cf81985271f54f012a7711c4edb20cbb291e47c364bc1cb51392fba18e8d1d2331f3da529a5284a0882c85a872aa4875f389e8561ab90158ad5b41675b6159f88513608e41ac2f8a418ee138d9c96ede23d10b129009a283d81c7f2525232faf6f9a0fe786465f4c8ac1a7da0b7a18c84830d78bec17f58bcfb4ba7a859445e269266723cd4d7dd42c1aaad07f6480cf46fdfa9077f9a85a2a6d10b98399ef1eb0fa7df6907b4b05b4281a1a3734deed7c2248368c1f23c6bdae2b9408b96505a711384146996f06303e8fc7f8c5035cc7b71dae4c2d947adc92180c0f259ab7372560b6c63b7728e5a919b4c5bc3ccc63ac5f7964547d611cf750ef185daa523a9eccb8fe21432f47a6a7014500f9dd6687428dce8128603060a5ec63a6af74d13539f1684f3d12b17d004491e8d25e850dedee68b4dc3cbd428a34664c5f4d889833c2bdcb06a1c5be2cb29a70ef3c3a7c93112a5e7223296e65f43b77795f755813712dd680812f26a801b5df1b399e0797c69c5bda93c36f58c218a44851a0c7ef1a1b00d9f80d415dd6d647f85bcfa49ecbb1f713cceb514d2c5d0d678ad7d63649523802e16dbe2288e57192b72d46a6c8bc417fb6a2a2f965900622d85ef3bd9baa22214b69bc50e81f566972d05c8b7508b07b2b4f181295f07ddd737ca2c928ad516e95259f0d7fa58ca0859af8b7b52fe37edef8f7d1f372a282491f4359d11b0f460696bffd1f5af5cd0a6c2820674fad6b125c677275da3d2bbd8612563efbd364bd254a51472a9e24dba82873ca6f66377162aa298117c5dbefe646680638df56300e529dce6531ef23557095efaa3c2b19f20f56d0331a1fd26ab9aff2b804d932b07808ff3d985d241bcc7be938244d9f9d927bf3ebe5c2849477566a0003a97df6254b2b7bb3563c235b08a71afa0f98d3473e6ea118ecdcbf8df54ddc5f5af6d5015aec6b8b8b6ac5b92c55bbffa5463fb7dea1f8d7c9ca0c016672e2c650785281e31bae955d5751b54e156c9d6e904db5c4e24daeb2383e61b58329a7b99f1915cb56fc0f4ad6c6f7b6a1e0eb7de0d5962de75b1843b4f1a0bff61cc12050dc3082d84054bb0b27d7564defd31ca9ff2cb9b9267846482901655b3ab4b1c10632313b9b389fd89cd9a52737c542883276200cca29da56467d3f957d07fd28f6d9732a11a016a11245dc55dd1fe8438749a21fc2e2a82698010498ab7c3b3a62262e05b7cadf674de92827206a244621a984c838c95cc4cd208dddf043cec12cfe665545cdf6bdc4e99d4cca123f98d0e09f455ee5fd061b44e1837a2663ebe3dcc4b5a0fd4b5a7da85715f4e1291ef1d3d263ffa1f1938e65db3c1dde0b97f31f7e3af7edbd8f13be6c2f7ecc2f82d30770e43d93273402a1595a58083ae5ee16f3f20b396c01243a4a10be71f97ccf61926fe073f0a316b8ff22ee1efe7aaf06b27c7fadb3f2764e31a66251bbe21b8660ff3748ea1f360f830a439a106e22543762359b0f327fa5e15f1df72709c65356998dcf9afd6ec5cc9b10e908d7201c3ec728e7027da668a07d5a7de8e155f0c040636704d177be70310f51c1581b8125b8e31bbdcee3e4f44628e0999b5376af0333f9a10b165e911dfbee76ccdc383a323e040c0c0d83db062c6cb312c787d2b3b4c95e0fdeba30e1722039285c5d24f0548eaa76b1f3530dbe62fdf233a492c429b2a44990af666b67233dd5c5ca5420c5b7dd275235dc36bd340b69754e97eb8d1735536e5494fcaa27725535d4ee90b17d195f109f2720e17875e379c315328a7c5bcdf6cbf7b45adfc210db92d716cd5519bc1a73f92d98e05d9acbddc0569afb8601b438d8588119fec9032a47fd27aeb566782c36760d65641abd4bed645814c22c6dc8e06a69155ca58d6943636f5a60db646c22016f675e1130398ee0c4a37b133a269034dac24b74d8d91dc67c0c5bfe89cae49634be4a2021194c92ff48132307a3dc60648f3635a5ef3ee21473df3e9f2be4eb125cab2ba4e27ff28b58fb5a92fd3b43b8dec58363c99b630aa9db711cfd6788a476ee6bce61dafd8981c37f15d1c24b68f5b82a46d9e22554578603d3a28684c5a4b946764e4ee59042e624cb22f7ffdf05021551e6f9759ee8660634d93a585e3a757caf324d05a9939f4b3f12ccdecd75e269a0492333d66619fa805d7f1141d9f911ee36ee635cca4ec4c639d3d72269b1aeb2f81dcfed9e722c7df364dd92690ce24b7779b02943f041cc998f6c8fe5298c0841059444ba9047280768724633a51782990987df8b8f690d1f26dc1240a351fc375c2a2339a5a48e50d56641991c2b4985ee72248616e37d6e192f8666c0ea046427d847b0d7376c3b9af6899805b13900746d9875e45b11d4e03199a0709a5e52dd3e37267fdbff2722f1aed6642661cc35bbfb6a5eb90df7d17ae4eefbe768ff543998a67aa306ef7cceeea6de79d177fa7c8e951414718ba8950bdf992337164a31447f874697458b082ba215e622936de9464d42fb0d0bb551fc343cd4e9b7ad5e93d7b52fdf623926a103fe53094c7b8168304519121ce7d36600c270bbc513a6c518e0793f9695fbffd1a0f118c7410bbc4db5af0a6e02b2135ea2f095912bd8f0b7c2093117377895978dd35654261b5230d700636eb4b13d1ec03990a6183fe9864c995b87f750d19007e39b04928f8db7a84c7afb526add85f939626afeee5b2d633da6b940217a1f8c4485a2c5b79fb77e89f38f6f425b40641bda68e85eda154309cc311e3085b558209f4c0782c1fb931caf70324d28f7eeb27f24e8926160888788c3651837babd8d884e8f10f4f18d89f46a6e64025c86bfd62b77ecb710656107c71f8cfc86bea1b47b21c5e4574cf57134b73c1896785d202836336ba174dacf2f7a5ec51a79cd58671a5d2a619e0851db998a8b635700271e88ad89e2e23dddef6c0a989d5148a60fdb158f9452851b0b6207af1cd07093404bdf8ccd1ed199961f1c0fbcbd13ad8e4ea1ef9b9c56d565c47ab05f894174e541807d1a546b10ba02acf12f1ed377504ec2ed8e72603749160db45f2bd5672290ecb55be3173a4a781ce70da03a3542f21e6f99aa1456ab1f767bc1bb0baf5f2781a9bb429e8b8b4f316104212000b93fb0bf846f0df52ffee32b955aabc382d169da66ab44f36baa608d19d52a039277b8c9f76b5ae225c16147fa616e1c7e68c897b0732287487b15519b5c801658ef42051f201ac7e99c963106ef70ab1f853cc6db965ab21cce20bfdefad98f9d041694d9622f34514e2ed77814d00c98061f33b360c3500c28661fad08e98ce30b61d8996f8dadd398c62fe78df7259538ddff56a62dbb68bc6d72ef654dc720bd1009908944da8da7f13c8edc6344e3e2a621609640ed25cd9a287ead8f7d4ba0aa64758744a3cefa5f8c1cba00c8344fdc3f31d07dac33762995f78b36e846f7fc2fb8fe19feccb09ecb6c662318dde0799c0e17b571ac662f2d0e03770f8c167be8c881a169a096fb0d89704652c8fd579b52436d8985e0a8d727e178b318fc9216574d19a70e4aab79a0c4858756fe9eccf86b947305c93c0cc0828c7bb157d47798101e17cd486daf914654dade5644579deef67566e1fe6a226b75cae5ccc302a690f98e102e22b68abb46f20ad2abf12c964e7b098a5700ae1acadc66f324b9c6ddac216d1644235248d556e7a101359eba1ce27c5d32de177f27d07748099136e263e7c5b2e9e6e55e6759dccf30293905c71752446053be5b1a9d6f776a72952fe1b49479eecfd0a75205eebea16cde04a14f13107840b473ba6cf6321fdd0ff4ff23c8e1dc0922fc246931be5c9c412e8262d3fe73091ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
