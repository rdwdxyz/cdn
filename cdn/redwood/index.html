<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1afe5a384b2fbd30ed86f7532c084c7376473323302a8b1e098d721df9b41fa463139d426937bd13382d2ac274737b3bcf419a6691bf56eea6d1d4a6d43497ef14914fef35667ed78563fb5014923112a2e688c6b6a7904bbed6a68b737881a8702d8d61c4e14a10477c01739d6150093a68fea83579ce896621f1ec1af68330aae8116c9f653faa911b5c548646d97ddcef0e85620a1f36f2b1feaaa6ab496f2afae22b7d7ec4781e9fc4a17cae9dfc08e2392f2f247b124b2f68b9ba97b7696f29343f5cf380afe2c7aa19c82ed40741c6a33d1efcb0b74968bc70e8863b0fd65823cbf952e205a19154977ecf35d4f48f479feddf743796b69a6af89993e52ceb9d3ce2c172a8281030be3ae02830882ab41ff51cf48cd6bbe9c8be2990235b726f88ecfe2d9ec1d4d22ba38e1fbd166416fb4985e1fc6f421fe4259d828a59fd0e12fc7f73aa709c8c7b4de30ecd157b62055c336e81490f12f04897a22bd8cd0fc61ed0c26dd54038d2fb485cd6b75a93cc823e8b8601ed3fd037af7464c3169ef27a46a931a10911ad8e5e59a0400d40a861e574cd45ae9aa078925f9f8a0fd69e45d32659d12d0da03e2aad657fc9ff647be86169b4ffd493e5d8accfa64f94eff274627fe280f88dc031de7a6863c3df0ca98f4f3ba5b22e8bd56161c51c0772f7a6f0a4dbaf9f3bce963dfa5cc8670d341bd5e1dc5dca8586ab9a8ae3bb04d5c35421f48f651080919ee47df1dc4f306504f46a61d28a37f036d1f5790c8624f653fbccf5f72854a6004edb2abb9160f9cc67aa1e91ac3f6c2f71d41b423d79dc7f0a98e6b6ebb8ffe47970ebe1b41afa01e4ab7c6450b12e7feb0f678571c0e37d92ef045897dd7588af761570fb42499cc74757e836f5ea354ea188789c9dbc6cb700e2b8bac861083ff4cddd86e13c74d888842168e5ff9c501951771fece95e058c32d5264fad23a1dd994c12b27baf7e07d73d70f00a5e06c4437fe93e81006ab0e9586ca6e750c274df10a76595a0aa6d92d3716fc8d80309aa2808e7cbdce4ce40a5aa91723eab3eefc6b140015b45fac8e38c02b94a2a333af1d1eecf9675c97f7f76be437c0fb2bf5d89a3cd1f66d52db881549a6fdbbc4350b9e7f8054d5ba14f9c220371d13927edf972f50d7986ff2b14f6cd86bf2e3941694935ee3a293f75b113f02fed3c621978e1e6faaee28cbfce07bc4769254178873fa019518eb04ffb7772fb4f0e57500df900272e1bfad6dcf4ce1cb8a6337f133a961e92c5079767d8a050539dcfd7d2bf03fb433d90bd5c4ba8ffd89d1978dd4e36b6b947c0b2ecc28c24ecbf38d3fe05d0c682f84b61934c78aa15ef4bfc96bce15d0063b23386f7367d004cff01e00fe6e125facd9aa4d3b22d062ebcb4774e45ed07f4b4e11f090d5095128d8bc5ca02cac58b55d7ee30a81981346ed08e34626386564d2ded9fdcf4218443c3298bad22504fde4af0be99e9bb3c4bf1b65bdd877f1ff696a2173d7154459f953ebafce4f522ca8c5f43d80b62e916380d2e2a8ada772b37753a249d4d0bbcdc1430d612abb4b0df02a6188658591ef5ddfd9d286c758cbf21077db17301c376f6a192c102196d13df19e72670ce679a71d45eb1aaaa0c41e836eafde0e4c60cbeb90d61496d7af4e09986476fa53ec7d849673c4c5b6021ca5e597e238be0f80ac063d355af37868d1adf56ba41b6521ba892d57b3989100567a7523ee32d43f94a353a546c5d19f0abf069cb90f5ecf8b6b51050d9b308b9410506540c2f67b36bdb05b93c9606f796b4161fc0ac6216e22e9e84218d06ac0d2f1f1a46f516a95b16ebaac8a4c1fe2c21f5eafd5d3c7201005cb9dd35905642598f6eed262495737faea5daf631b8d1851c35d587642ce400ea9074ff8b9d5eb351e9a3a97dc70ec134a60903b127b6579808f1f298cb78170c91d2bc090880f623e799c6036c4749a94be17eb4406048ae435403eb3641ecfb6e5e0004171377164382b45eee11a53697bb43c894231c9c3761c08601d1c04a3742cd4df5c8691416154dc103a90ef647173f5f091de6d893f2d9fb88f74f61e53ee1e73bde8a987e82889fc0eb214bf4c1544474efb208c6842e50e985f5e5aa8e12b75d6c2d2017d483001bea29c5aed2d11e01473207603b613637c6cc4a6698122a0123b56ee440cbc7ded48b5116084311fa2123f560a76aac369e51362dfeefc6fe9fe4c3109c027e93dddd1879bd4fbfd13697f4093875eb8e8e54d57d117d0d2359dda273a95137457e90705dd03c092059456a79c569f0e6a67483bdc8dfb54351a448efa337cc3d7c685d69c01a12816873f31ef22f26541b3a398597c707c7908a627eaadc42987f9855581cc773cb7b5929f6602ec71d47381290f3ae319be0fc89fa604aabbfa0f67a899db3887e69113b41f3df4486bb5f23ea127ed687ed7a65059851f4533952fd0c3807153ebdbc896c6c691ad11f96f6144388ae8552851a88877afc83c76c9eab9512e43f0b24aa3b5da08a760a6e54975035d44b66fd3f0d9279579b824a2fba5c43fde75809bb400137e617792d11f8a30cb728c09582f9b277ee2fb6a7ec2e85df08c2d87df99c4a7c9e18ff13895a1ce1b910868ee08244fdef879bb192ff09546bf5c205c599fe18efeb4dc6c5fa374ece1457fa385d67b7212e2db3301cffb133a290e7b21ad5c5f6a57434338f796a0503af915930efa9a345e7fcd2a93c582658d6bcf74b763cc69e6a4e40f426622c74c5b96ec0d29abf003f2b5bc39d2af0da1cb6cafb9e787e9fc0bd22824df3d32de2de6e32a40299c69438611d8d3aee53d799812efc1c3a0b495e357980c9295df6ba80bd613713a7521df801c8badcc01d3079580a4166685cfab962288560ec1ca0146396a457fbbbeaf068029dbdb9387e9671104b5595c03945a9aeef00a7dd82483b88213bd127a23bfa4eeba8281601d6e1595277470134de5486eb99e17b843bf3bb0e700dfdcf350d61805797c49343000388391df375601c52cad413c0e08a188cbb1f4a94b42007ea46895f48cc4982e62c2e5e30be0c894dc2e512b326996290d5e7d4f34c2b853fa83ba260f25090ace51675e2d26b5db82165f05de8c6821f7ac9e42846f9d9a1ca77c0c22b1c668be54e3a7e6f5382b373b246a5b8534d57bb2b902dd32fabec6a58f48bdb7c2510b94fabe9aa34c07fd16c9094577448c38db195f47a0eef3d560ae1927863240d07158cb9d326c3f7a47a89565546c74861068544eee2a6ece6640a6c176110f9931343751364cd0f67a8485df958f6bdcdda851aad283a0dc2ba3b1410396e34fa567487f8bafb02226fbb1db9f2d2e30f0f5637a514e251572e82b3e2fa29baf3d577477a15705fda58f5a5b24cc4481d7d4ae8c7297fcbd9d27c57149891fbdb6be790902de79f9a66b76c314982cdad38b1a8d5b9cfab270878d5bcbe111a2f31159e52f2202b432ac62f1f8fb68cbc4ee7d2575caa5fdb9834fb794583a4b8fc536741e46a1877c365d42dc586a2e5342cc9df0609dc34c8baa76f71cda6d4957d5a4eb189ef366ec8fbf443266c256e92d45fa9c03498de805b2b368d0d9f035202ca925b7573564507f358fcf1d4279ea121588863f870fa587d8a5d8a319a41c219380248c2144b6eb3bc808dd3fd030c6d83479a901797f3e901db93b9cdf8cf50ccac02e6658a1e8438d8c2692cf51921756fc28387bd8e23f4775cd0e731910f3745d1c7e585005549833e4af324ab6ba2cdae5e498d87ff2be5b40aee8acd15b2e79dc6dad0160295534dda758b87067cd96e90a9e4c62ca7330a6a6fb354cfffee29c680511109ebb771e9d15759c8de9e6c51a7a5edf880aa960c356006ef3eb2503e62588ab2129ea6eef63b4660aadd9aebad9678b29b71342035d6e84ef485cb1db472f17d305a3e1e774b9aa99cf4630aa8c33ab6edf7cb5d4dffbd377b7e10169a309e60e16dc0b87d6eb8aec74b9c622ad4257c8d654c3ed7aedbd204ca04465e5542e8c8ea9f95d03571ee1fe4b5624cc9238c67ef636e3296477fd2528cfec655ca0cb452f9a72ea834c95970da4f0d3f64e4ceb85adc2fb3b0c667c619358be37f4131109509231ce4aaca94065e2d1e3c7ec6bc75c1b6494559d7c3d1693ae708521c0bcb3a51840ac9952464f9c3ac856e91d3a8175788ac2a50b301a55ddb018ee83c8f41bb62492341b7d0be509f371c02d149087568287dc0f55f1fcc7cdb1adb146d1cefbca4a71a2400d267919e20a3a9006f09324193d69a5c1e5b1eb8acffa3da16ed6230c06f9034f01037589733cd811c8b43d32d83f493f19a87e408301ed12b67f9a1838fd04a44e09542a68cd500dc035b5298565f8f4a6601f43418be412d72b12f3a5b50e09a2f9f3c07de6e2af69b914fe76c9f13ad125b00797a95d6fd973119a7c7ad62f8424563742b896ca7112597875e48b37d538a456c6f6fa423926265afa9d836ebd03c509e77f8227b462011317c5c5b77b4144afc991819278e036af1bc8ed2a1f259444e66208ee3ab404cbb92481015352dbb821a6fb9400a3bd792731ee7ec803c47656b1fef77e9543be172d698abdc667596c4249ea549bd318f0a1e06d2f2e2ba8b198debd09e73d288e793ec9c3db58ee0c64d960926cecbd527282d7ac60449ba6d33f95e4d09a30b74f076ae441aa2451c29bf6830e9798af8afc168b068e3cc5d952fa4f25824d8518beca70f5ba0716bf2dc2bb5da0be93946c3675681b5ef5dfcea1797e019bc147f691a8ea88edb8f04554ab9568354a012536443799aa7d09ee9434351f55c4d248dde94b97be30c550d356dd9e155dd245f709587263af9ca7e216bd794f887f5350e2c3884d7a6d87ce2041d7902690b7945ac49430904c7b5f54614dc8185a936ac0f40e97970757cace38d3000a0ab808cb51d3f137b32b00e5137d33634e7fd25bdc3e45b0805d9d9e60b531d7dabee0a5b811569c973a2bc24c9392dc3bf808c40c11df069bf708de8a80060f6df6cdc0c9ba3fab7e2f25309aa19ad48059dea57b6a24809fd35f486e25c7b717af50121fed959fc0ab04ee0cd6aa0b724a7d97805df82df676c1d97b65b8014c00cce907cc5fb8316ee3519a14ab25dbf588427696e1ee12aa4ab4c4f1fb001bc09f4a1df85f1951c6b36a80d3bec0967bfb2cbf284eac66c24847859dc90245a1a51b7ce2b094b7cae2762a1345d61b0daa49fc27d46921511ecc7723525d6e5f1283cf9dc4cca291e6382b7287cd508c09619bb7b50df2ed8c5044fb261bab5bdccfdfd10d30dc1fedb7ee3db7f2901032ea66638ff66269d1c5a02c8b39ec70a4bd8c6145a0e65d9f814db19dc8a7ef8b271e1365fcbfa0fa4c6071f2d34e7767930f43f377c4e119bef1a70c70c9134929a68a68188ac5dd153fba70ce5932fb0fe81d272497f34e8345848c7280bc70dc2eab8187490fb86420f416ccf040ec65f4b32a4e3ca590c0f5ad6a0b9c7dfca98d61a59236f428450cfd63ae4d8502b58894309c02185109590b1414c78e5c9fc53a6344bfdde04b7a4a2d70a7003ca393ef2ba73b6ed86bf964f67c86721ee4d364f89f48746450780c8f69009f0c4ffb5077069fbcc1b074d3564dc9b467a54411de9b7215400fb9a384772ab34b3604669833d03225fc75da72656cb4c6e6e9d52668839a464d6a2900cd35a12ac67c8ad6a760d23ab67f19e04267a377d8dbaad863b63b1b52d4ec61cf5b13146ebb5b67420cfcdbb6124dd5eb30105a6072b0ad5c2c88ecb9c80aaaaedfeb5fda464b8ed713a53a3f82e7b730490ef9b2c48732279e845de9222af0b1b8d6a8788dd4a1e67da50af4117bbadbe9e9b0ea7b2a20994e3ad072ab030d9fb22f130abc51063a5976cbff9037890e1c3e52064c6ccbfaf00dc65ec7c67e7d09579ce2e790c8c196288cb88283d3239bca5a449a183a0e968dcd9561776fe7e034ece4185125e112a827a275a9c77a92c51209e6d197b7683f9fa3913df859e2d456637a3910652114f09cd3c08e22d1b3e20f656af54f1bc7f416e0b7108a289234886d85fc0bb5d8dcdcde76457a02214f19ac9d22d6ad54165f94fa6af9bd2231e26df01064252f5a88402d515b193e782018a7723da20bea38c758e5dd25f408b36201b0d1a044bb4d28c0303c15b7edfe7e5f1d2e248d99cded7882bb03aece21f6797b365d961c98b37dd4f28ad9f91fe3954de3530ffed52185670a25ed320e577038cc8e0ef24ca3ea51379e85b3accff4f337109f57389992741d7ea9c0544a78bf80aac725c8d6e6e7187b07a35d2dcba6e34e144b0a9ced0f6a5398f33edfed1775c91b00a3fe26847112566c8afcc121ab17df975438b16cd28a02da79969068b6319bfe6e8ecbaf5f97d28a5d94ad6e2ce2cc36a0f6f1e6eb23935f70284b608d53b8c82d60d87b99f743f7ef092881b525a7e4f93fe8c8e1a6413a7dcbcd72437f3dc0bef3547e93ca3960db886d7cf76f2459ce3c26385d3e57a0eb101cabce12e11bb6949cd75ca3ade5dac0db11b557ce2fc20f93fa6418f980e91d0472740c5dabd11e8a16512fb32d6e7a27c4c2c58916276a5822c8c521c135cc07cb7cd12fca08c35f3248b90f5767a6a46374370be1ef79c41afcde25893218a51c7e280916b90399ede65b8e362a7fcc4b8f8339d772c467fd70fe15c811616545963da94944bbcf93961394c568294b4086679b8865b5571a35bb4a4f012cc0c5a55977497b10141e29443b6202529743503cac497f7cf9f37921d767c90d0ba6c0f4276fe84829481dea52b1191a878c38b906092f999650c2c549ead2938f8d2737010fdb40223806d31c474aca32c0f808bee1c81544868f7749be577d86399954c9769579ccbdf8185dd3ba39f947dc7e7b5bd9bd55e46aa1af374c7e306aea7a42ebdc4bc1ea1779e06708893beada379688d22495bffb968d2c84ebc4e5031a64102b32453c9770cbdfe455980db6f675dbe45c2e91ec306905a487218ac1e24c0f54ba7f2d1f446bfbf9e7940779e102fcb106d8b01e220703d9b43ceedbbdb1b90f0ff4c5b9a0fcd95a499a48d3136b66db9e298c9d187778dbea174cdd981b60a9870f0fcaefb16c426427754314fd3d99bf077dc43c0f937e3c4ea21bcb3ea4d02df2d0373379c06b37613604c72e262934bc7103c5556916498d5b2f97149b0e6da2dfe93850e0c91b544beaf331d3fe2aa698830669abf11cbaa8d5148f7a715af0ad8ca540369c8efda74fc7ea14f391b401f461c42a71553c4af5a035a107b4a93f2cb2078ae683b0f7f5a318826d4188644479e6f53a8233d56623559ca32ccfab71584db7e99784b6fcbe7c92cd48dd3ba5acdf49f1c328158aeae38d064df77a4628352fff57b9fb59021706439098d9830af2ec77bf3b4b2cb8dd18b4e95680e9f80dba5ad436cd6d96a1996de4754398197af9bbc1d691d958ba4cb96d43a41e8032fb1de091325b7c88d2082e0462217e7e0562dd3da378d8d02782ea4613aae99829399d10522d2316e552865542e35b49834815dabb5a5abec3708ebc85f0fee14926420d392436d1ec84a812c666d8d0ead8473082acbc06921c64e5c10dd68023eb6534874ac4697868035c62d36adeaf608e15786dbb88b606cd6f794aca02314f8c936011554969883ff26826fa0f6567012a1f5f5e0d888928b777ed69d97a463c3e52ecf9cb5cedceebcfc81038d6412b5a33a266bf236862e4c65955a3e447300ab4c63180e0dd7685e4e1fcc3cac3517b7166e9b39973ab3183e296f4554d5cec6d209cf34f7a62b139037fec37590b78a58f354c85a71f0178c98047b1a66c1db49d95f6be33c1ae64932067c41978b81c86d4570b83f6d87e095da86001df6a80d8ed4d1a46d6c8a84c7942d0b1e657383bffc3a2ce858250ac68b501b086b28d2795842406abffbad4047e7f91555296907577bbf32d92527002834cb5a0c4618b36b39067aa4d8216f7e4f1f7e28c31ccd5b32cf5ed6807cf447ce2190d07102ee49fadd39fa0e096da2284afb7f794faa110aae3b3931d31cf9ad78fe2ed0a1be9f3c3cc3150e3e28657ae19a24950c30aa48aebd0f56125b0e919c25d0dc72c4fe3d51f3c4f21de55ed959ea5c5501788486772faa2169bec8ce5398423eebfb1611878d438f3fe8a4df6a5d69a362577eb6054cd95fe036f231df0402300e1efb6aa161ca2fc439289575da2889bf98d724ea5b23ab3516448faa2c90637c28510f253c62174e756a38083c12f53134f12ff51a28d01519f775ca7cb9d885e579d65d2736d2076dacfe46901a943c6543904ea01b931196edd9a916c7b75b57c146c9de8ec1fc58fe572b84fb51d8d645ddc97543470310f5e10d6f2168e6f8f86bc01bf4ffbd1074baa16d8469eb74de89136bfc0f13a7d13b6afc150a03617bb80ca06d0cb0130eadff64da22e240943fb0ef051a07857d8ff7195d383079ec30df76d832c7298691375a39705372ec7b19e26484a31139e8b640c4f26b9dd9857b488208c6f57757b07e8bcf01664190f2b2434db64eba56e2aedf4cbf573b6a29b02c08f27b957b383793516c52164c5a098b24e3c307bccf5d17633a56148bba00f3c361255acbcbd24d6659d5305974d36616c64d8a2727c9b44125b7cd5e3aadd27f08e5ade34d36b6792399e75cdb8d4cdbfce211abddf10a59c7db2439580f50fb3b644efd5b6cfa9fd14b5eb20bdcb4881b0a43392f7fd7b99915dcd4c25bc86cbbdfdfab7554f375ee6403c97ce6b78d2d2355dc6c9068b49028def41b3ab59c4be3b480eee170a6b7f9e17612374b18162e0d08e57d9a81fdd362edf77306edad5a2fb2d5cf65841dd4607b7fc33d3118fc17088185dc7107704c78430fdd6197f4bd08b791141f9a14d992dd9380bf153a8dbb3fb9b95af18c49c000768945cb049fbf2113599f2f69ab0bfa43fa432a99a45b5c0a6c5479a89031d0091f2e40c61c4007ff4f1dae07feaefbba0f674b1837224e4cc99aef418ffd126ba701c787b59aececea71f9575e1483eb9e9f606f78ce659d653c8cc37b3b53d05c111c876464f44c05e9b14b084d6915a559da1a5858fa5c2af152999953f142545de1d7243512d0d915383cd2955ddc103d899740eb5c80f24392c3e354de3bca66ddcfb42b8deb73462e535025ae34dff4ba67617058da116224819535ba33489b5162d2716cbf0c7a77a1726c5a7ce0c2260463e4a9c98e2cdced6474c46d4af68b5bc72f8ec21cd73675e6fbf8a342560f087abdbb1dfec8f74e02f1405503f9baf05dc94c9c60c1c058a39399b716775cb87727eb78e30a0450def492204657666fe04bc4fbf83dc5051862eedc41a75402f8c9a9283c64472acddace7c90aab9125ed15d02d0886038798ad7c45e58ae6691110f656e36a2e26f2d662b183e67af69e676c119653230e3129c05587d51a2654af83ff9277c724955e555ccfc391c8d8e5e6b121b01c864a1dfdb64ba2fbd11ffc5f4d49b2af3709da976013bf12d6229cd4aaec382340ed166f370f85a918d1792779d717f3ae55dd5f426fc660dce931a84f51a4afab8fc8e59efe4bc49e3e8ca0dc0053f257bb39c2989004b59e817de14fb9608107bceef6a5ab8576e5c0d28b8cb28740d7efc706a806f6cbf2634059583039f1e2608d8664eb2f52844e388dea81595d27ac9950f95b9fbc003c0bc732efe66a1b0b5539d6b410df0600b8530211c3587064b08d063d355adeb2c2cd9e6ab9dbaba616cfd4599e374830080554e2abb130ef359289dffead77a07faa0aad07415e51443cfbe413eb71137a0dccf8df31f1065baabfb4e03af29b2b0cc424bd5c5ae384b75cacd94c684f5f6ccc57faa22ed3d6e37a2fc140feb2119e17ff9b4ea62a6fe1158f0a97c618df155a5e14fd848df290044beabfe88393e8f384bcc1a991102932eb589eebec618adf1318d36f22a2ff397b45d2cfe412870415fefba6d0c513c61b6c179264ea65649e0eff99ff9bfd0956aa67acc1e5e9d76b47c7830833c55df8012fd79dea50e416569ec6ed417e58cc0da8965097508493e579c0ec1172fd809c7b170c119182555c6a98cd0c5b7eaeba0d285e29e677b21d4d9821919c560ac361a44e986c4fab76fd225694104d778bdd17fc9e18dfca8aafc53ad1390d85338b33773a6e57575970443d44bc780bc91dacd75e4b4b63431b504da8074b84060aa184f26ed3ad2669bd29ae0ee91db7b8b97f57b94e3af1374362b2c59407ed0fbf464db32ba7bc8766f6c3ff8f7df571d202a1fd9e26220e833ff5399d9575159a2c209b0e952113ce19214d20dae03e2c50a0b39e38a4bf90cac9b41a2996ae867f5a16a4d60a927e54600441d9ced44a9d2015b1dae791d6a35c7d5e0105f3f46e4bd6c4185e64aeee7834872f80218f2d0aafdfb4966aa22f4113c25e9dfdf3caa19e993f8a2f98f8dc92f37296ec685984499e384323ccb658b6bcc7d8679748fa8ce6ef7627da4889031e35c1101df6267f7f47753b7ec5cfe0c9576603928d659dbe068e958fa1ddfdfabdd9390d416e94ea1c7596e0b11c2e80492e4e4882e5aa8af20953a5cac71bfa7eeb2a6c5300ed12fe7c972317534bfb1c37a118b9261e7e253e5dbb21ca788cae37a867e072050d0a101dbb49e5c13bf64eaa85bcc51fc9b30c8858d512c541140bf8dc9f316ae84bcf6f31c25adebad00359c4979008f510b958d80ebabf7860358c2ee76d7d52d336755abf14a2dbc88543adc1baf9e08928c2e136e2e763e3e12a82e1c513d39575c00b4222a3eb3050591c48f8f60ac72f30b8ab3bf95be957ee81ab6352e755dd011cbcb99b746bc27c92be1b973ac2b6e21761d87a2d8cf13ef04a8426594079b17abd522b4a003ebfae42b7f0779e665f3cb9123f18152477aee451a3e7500b6096e3a216265a361039ecb352bd6d24152d2cf1e2af957e78e852696916aae605879927f66ae991f7c842129d4547b3fdd001a18d8bf5a58be627bdf6c721454edf23150514919d5003f107e34dbb9813f5d4b7aebe1c0b7cb181142c6e938907ef8d77c4c732643983e8b41f268a5d23b4f526de21026bb6355c29853d3039140ca9a64a5e1c6bc59475e684ab73cde9d143a21ce62d0972422cbc7322be73757614a6d9957f4c54c0f9d47f87e064c313bd601e622fc9d5645aef08ef44543db1b8760b79d04b567e9e4a97b1cb55c5cbbacdd596b01585ba140eee7a2e989cef9e6474da5b68b93162c3be1ae8ba07a5a62d0d1762baea3f2ac7519858a03f668a79a54db1adb409cbe0f225231f9380d1990d831d8044428aa1231e306c235acf5bc835d1a8a0a2ee689faee0c32efb235abcc478c2c390b0d0134e282aaf2ce9677b34e9e5feed0cb579e2217ab36c1a33996888636dcc337770ced7d540c3b6addcca107f1cb9a531544725fab59cf261b0bb80a7f2d525b7fd099ebae86514a4081a4af553197071ae8ebc7f8f0e6d908ae40aa2dc3dd6906299c182491bb3b9977324edc404e5f500746aef3a4d94dc8c9fb1ddaeb70acbd25cb4149623401129e823520aee1b05dd8a3f08de1633039a4e95bc17344bb910f5deb13064e1b386d17d63e8a06569514c41c1796f8551639c5d4268fe5bf65669dd64ca099323bbef14f4d49b10af3b8bd11a3b90c65219d671fd1ab10e3416d31801e4be0d375f3f515fdd742ba8babfc52cffce308e4a54e9494ab0eba98841a5eecfa6094e693c33377090c2b5240f58a4d324590d0a2a7923f40ce5f61bda4d2dcc63b3e1f0edb5551d9dafe852ecf89ea64d816b0584e96ff9f1497eeac7f0c592c154b8d157954e9b032927d42f5543c279ae3623e0f110abed6a406ea0e4445cb679562a2c759b103172ff83071ed1c10ac6a8b2f410278c096fd75dd4f53a75410de47326381d1b4a8d3281fa156102b0e2aa1e3fe54c2118be66135e2ff321749464927dd0b4225709afb5a9d66c9396fa7f3709cf139e1a7569c389f61ce64929771cb390d60c85d5193b6f1a2409c7975ce451fb931ba01164c86c34574c129211ad1d921dfa6c356ef9b927de4ceb39aee851039e9e46c975889cfe95c7b477f2fd34267593428e7b258b88e4726859510e19351abba623bf8569cbcc898318ee86c7ccbf8b45dbd2116c53bebb0a756417511e9829602ce64dede72a4aad77379044c375ef35b2dc8938a91c4a0bd570a6f6de144788260523ff590be65b3db52bf8f63401004dfd9fc80317152a075d4e1347fd7b75e98b8c81b5ed89d1d5235e962b6b113f69ab270d73e47699741b672e948b729a4507026f0a38f5e6c3cc50283eb4e49a09a2fa9b395ab0fad3381a3e7e02707f58e18b48e8a0a4ffb6b4fa244a69ab34f7174cdbb545b56a2129c112010f3448cd4e6075c50433a55508e258c83a8a96bd63b8623c41680fcbd3e4d41a0b545a72fc7d6556c5c6c035724641ca6d3465936a76d6ae1ad8d142cdd6c7a49b83791074c4a3bc7da5c33578db90ea0250ed4e1dbd3a663fd14f091e8d395f942ca8f90d9879bb34e7522972a158c47646c2286a827de357eb03df1dbafdc97ac3c6d75438340212d433bc19b8b2c5513e0b4a78691642de5e15510e2e1e1ca34a8b7a0f3054dfa5e3a2944bd39bedcdf5027938783006e114a9b11eb24ad60926986fd97b04eb9d9c7eae01a5767d157e59c89bccbc10c1a4b7f77eab3f012dc529281bea7253f52686ef122aa7566316cfc1bfcb39a35a76428a60a90123bb89678785bd33f01ea3635829da61a92ae9d3770557479169ff3effe210fbe2a4b40a10d94d5e80a321a30d8c101563b40798a0707a3a756e71765fdfa8dae325803e4cba3e8a9c89e9f429ca03d1d021e26a10fe09af4070eb09d1246d87efbe3542dabeaa843a64a2bfcfbf61214871474bbb31a638f2b3ef40263ba0d737ced9eaf1c5482b5922e124eda77f0467472c8e29984540af476c18aa7d261fb3f79647b1107c1a5fe077cb0315040cde6b40fc650056a7cb96f425737d92acaa73953125029700123b276474ed4e37707dc0822810378c4fdd771441de16c9d027f74fd7b320039bbd7ac4aaf11ec87a30b0dadb5637565722846264027852f33d9f67e5403e94ebd7d85a34df4aa6ed98af184150c82b7f6e5a8dc669277515f05b175fe56ff39fabff679efd791ec9bbde50172e88405d1c8a42bb57f39bf43682b141d50f92fb803ab6862a7dfb5f7da70c261fc9f0fce489dce34e2ec604fcc2740fa95e86aa516c0c5ed843733e9ad77fe3134d2e3866183bca99ba70ab57f5573426c14fef55a48b651eef1ba701b5040ad8e7d0959254f1064839666c0229bb7085cd22dff6da4d1e0fd699b754491fd676a5b19a39b6ebf25afe2e3be684042f87906a81722b337d9603184ae3cdb14c8269fed00f513c3564e88d632536b271c5768dda17b2b4fc8002fc0a941ff36e33a53f0529566568b43b425daf1935ae640390696bccf5f3fdfdc7673d71612f47091808531b3f6ca735671609c652abfd0f72bd8e0934986b59624182bae77313070a42089216f52e0b812ab43c6079155af81b9e2d08fc09570a5ed0dd33636f5b3f87f0a8d8317397362b10747d1a7a7eb77a11d8b7ddd138a1476011d89fa9312d8f11b54235b298ef294eeeee3a3fe313bf9106520e3d49b5d67a8988bb63ef6d91909babffb3827e98067ccc378afc66a4b5dae6d80f02c04256ebc856115431465ce3318cf24fc8b10edafbe6271ecd89770aeae74a2490e09c90bdb54ab8e53c2879caf9798204d94873142f61a4386c2bd125707ae46658bc3e280d49a70cf98148cf63e6bd00847cb68ca172c7c3dee3e03875a5ff2f8b0511a1939556194c3d96e688a3706567b5099d21331e2a9f900ca29988b7498a189e392825bde3b07e951815a2819d6948e7b7cf252e2e10bedce742d9a5118b8adce4f615c7da59e24c2f84597b711ebd9b4bba13f1d7e26e5b5b2b93c60cced55cfeebe29df307e635fd1a32a8c0ce44a798391dadc8d95697fc23659431a2af710376bf3743b19092014bf790e34132d4b1125628643eca93cb8d95aa51d8152e1cdba39b21bfc645080c0384342abd8250e25fca1a92fa25611f15b2db1f1221dd81a103b81c838e99db5f00d7a047f4ffb3925517e138147d260f85c73b4b3c71af54059ca4681c1a7b80738bce07037c528df1ea1ba9be8eaf655ed11d3670135d63d9fdf20b070847c765a29702df0180c1d8ba735380285f51f637dc324faf301a0f6079abbe228c6c500cc56b9b72d4030bb8547a3a40b5cb258363b19f2c52a2bf4f8ecbf4de7c99fbbcfedc3fdab9f8388e2db03a31ad113838dd3057d640fc694142a0732c6e66eec07c024e7b74dc5e91f42d18c0cd3b7df29fef03e413282796158333adec2fa2234745ad6a784b7707f0423c514e25091d5d85efbfd09fa65b5c9a7cd59f9ba568aeec1966aed9589d4aefd202ce88cd726e2e1575121b7c64f767c4f9eefc0dd2870be1fa9829d81396d233df8a4524d5839511632cf43a0ef706a4ced5eb56d406c516b2bd00f60a80132c744e1d72534a616b4424ccbd703d72907c962d959dc2f0e8251d60f0a388c348eeca2b43112eaea16c30338aa98e7fbdf248b6d3437bf273c2eb07083e19f7091c7ba86fd1aff1d97007e6f4264274d1d75ef1a0a6db3596ff7f60f7104b90669a2312991c25b78b5f20d08a6f8a1c80156f996480a0b42d7989fb5a979ff88c19cee04ea58e8a898fda174890aaef5ece1ec5a41f58d1886cd6350960b4671a253bdc3264fcc33ae02b4a87ff2fb29ded992b45a7f32cd684e4e0ce0496e6a3e4b94495c9150afc5e41030367e7fb84144862c2c564072bd38ad906f6e55ca023024f26dac4d1c6f43542f359c3aacf438c53c6bcef93d5361b240f47ae45ada274f861431046414e59b4237ce18c3d55a8a977b36e8b2a0cf40e1b21f855c8cb205805bc83beab5d2b1114b93c37a5a8881dfd0392a9273f53b24375cc91261346f08f80b0dee4086813878d047234324f01a18eabf6a8300bf94449cb7cb096745e21ce48e7157b20ebcd4ddcacf403dec65789f560df13afa8e99311424757059264311e8358d752e45b0712f5dbdc2550823aabf0853aa8cb3e6ca0e896ae38137ba0ea5a73f066066f0002f803b9ce7d88b0adbd2d330fd271121b10fff8979fb02f64d3d9d3ecdfd1e8e0d215d6e5083708dbf6e19c0778e938d086c9074a1676e4f27b1cea34c43c8372876cbe48cd191c2221cb9c4dd7ed605c27b8ed7d8c2f7c35610ac4a67cb80ad0a6a7b700c7c68865b1d211ea9ad92298e97d10c4b0002e52d3b36a0d7a51d3be6df0e40e9564199b5d2491c1e3150c2d0a1c7a29a6cddad6285d1516beb7f012dea8645799c9db77fda75994f5d064c1972c7fe9c38855d00e29e57cd3c607ae0bcf3047ec0d4798f3abe137c03b29674c7cd1103be80bc8a2776c487e2698a4ca9985f7de7d0d98d3f62881e701d9473be6923aa21ff95e47fc466feed5d3b41c828a6247cd61d83bf903d9e875539850c1558c8b1effd159d367375cc223ff3d6405d6b120e8719430c4562e88341c25ea2afa33a17afee1c2ed529ca9f24ce4bf5e9349d997ec925662e50373dbfcd52412c9a8de9b9e3476e3654e95b1b570bca4d1fc4fefc9cd88ea25368bb1a20f26d39b34e025d881c161051b561376f241aba0d9d3539dd6789b1669f7fd5bf13d8d846f12bfe350d78e20a0b0993ff91bfb686bda3e96b177707d22777bd89ecab627f578428770a4a6eb65988de1600dc076c4963fbe428e7847eeb089d5db627fd7a33420e0385ce264ed561c653c4c4dd2aacacdc521b427a8267e45f9ce54b874c7ddd29462900eee075fc010c40b1faad3f3f34c708b0d504d074386e5f752a05fb1fbf196f772ce2ef9ca157e061fce95811274f0020173fa15b5a5cd6c566b6374585053cc5fcd38cc2ef32854288a306f96555037cddc324b7b2c3d252d7fbbc7e75a3792e883c0b01d213566084e6878b71b4e146a719002b15e7f2ae0c51ccae217100c04996b4ca2465b431b76dd277c64b9ab1944ba904a03cc6fa7fe188bb29ceaa56c83eb246338bda3dbbc88a131fac22e2a6b906632b7b4db7f9664652b18798260d02b66eb624a20d5f9af399ec24ed688bc9294b8ccf137d102bd24e09e17d5d9925906ec39011833055bebe8acd4f63e4b486535d44fc66ab823c0a3ef24bb35e741a3e1c7f5224b42ea8f6cc58e626cf44af17bdf8cc312fb8f2831785195f962aab719a0e46c0c1c2658e1cb75b7dcd8db55256d0f16b0c1a78169281cd682abecc8d1bc549edb86c7d37166ed03c36adc88b2bbed2800a1514ad2e1eee357dae352cdb32403c9deaebcbde2282945d02ed1988f102a7efb2aa7e7415f532d84b76e52390818080bf718302edabd315096f35c1ff541fb1695f2a0282287d170d00608d914485c452ce9e813461a66c769586b053b4b8d7bdfc281b6cc1a7a5cf2c692e9ed70e79cff2670a8bfa6d6b19c188521e880e6a94f4dbbf77c2dc2b1e7268349757adb8d0d8fc20b8e41d8f7ed1a54d28ede9d8d615ae894e7ccc4f908db6ec0fa5de537e74617a0786d176370219828b7f09c5ba7a12e29ebd1ec342bc06cc34ef1ccf6e6257fd418e25d69099012ce70c9ca942d1c883b3b61e79c439eda9b11e69d9f07baa24aab37ce8334a6c7d42da0ca81f14936eb165adce5d6242531edfba1d0ed08248792d9b727eb4390b62665cf4430b66079fc5da92f4a54550ec18f9e0e2f8d4b688b0d95bc1daeaf00d55211ef60cb9416334b7fa13c1b70f4c8c9ba1d9df0258331c1658f7e3390ba098c8650fca77c085d60804f5f017f7b5a899ceb7c4097af40814406151abb9493e21accb9b83c4557e5a8f4397f46126539873d586b985447821aa11c0c95fd66de0d90578a69bb5008fdb16c427480d51548123dbc1dcf27f96e140be0e76b50b47913b921941e5b337f9a5bb785d19cd271a2d740eaa7e25e45a3f8032ca369be6cadc91020d3e357ff948b06d0d9182db9bf507f4bed6468e830fba5b5b4a7edb75c0ee019fb8cb32a842b625090e2c86d7158f4aeac581ff0178740420f04af6ea4637a0aba92f2b772091508060ed07bd1f010b1ed03f8138f202cc8aba6bcc5bb0ecc379f18673ef06ab302d73e4118970b18f0c0f4a24f0c415a584d66ce7bc2184484a61f0f7d11dd24d607465ccae15d137abc73e89090ecd9d3e9b6f85304232b7470d46cfcf1b065730f88b585405426520e868a51c65dc163ae526fb688dc40170cf5c441fd779f3faa1742b9c9d08a443634f5cb8473fa39ec5e9c42f57ca395ea58f970a90035d086bf1ca14e3fb853e64ef067f215f7073935255b298c72403b02201f46d04b15e1198ed6e65aa0e456e0f5029b329eb1354aedc0adce61cfb55613bd5308024fdfb1dcf246ae39b8d53651a287db05784d16f142b0123521f6b2e82a97a4cac2deef2417e19155e20942576916b2f1ddbfef0b34a1308a8ca6d50a1feedc1aa7f822ce824211c282bce6ddd4ccae17fc927adda9a5e746cbc2c528d06f908fb9876e315dfc4ac08485b081198980283e683a17e41473687380a1549364e6a07f479ad3fb301b9e5e5d93d631269a97a20d1714e32abe8298c369ed164584014933eec7ca2e5e64c6657837157fdc7a5858d10ba84fa2c4818e58006cce1b02ea7ebad1bf8b1068003158c31a5c54347cb9aea51ee6349fee3d51a024400922cd377bb35a3603c65a5358d76225b97b24ca9477643f0f0b158d49384f470c53c874bcd21b693a077ac64cadbbe2fa4a133e40c621ad6f100e1ed74ed09c70e34baed651acdccd03c75ecc60d92fd1d33c9f050e6a0c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
