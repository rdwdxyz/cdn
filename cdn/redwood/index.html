<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2a135be817c2db0e20a19889daaad743a583fab9006f711841a1af9ad40c8f560107cf336668b26ae5828e01da035ceb4bfb9161266e36af9e0ec8c5f51a017e2ad46d04edd4032bd7597dec472c13ebecdad8379604b7b45b2e558e2fbd8784333c4318390fb0639ed1d5ec5eb4524e6d743cba8de9a72eb5a0343649dce4874dac064213b9fa7795a108f7fef555536bb2aeec70059e4a802c84419a93b22244a6288dd5e00c3bfd6d17793913a387dfb899a3a74eded9ef827f114143a2d8e4ea69d9cf0727af1c240bde86c16ce7cc9d34d5674dd5aaa7054a36fdde8db428b74701632b325664e3beabba7beddf93874f934ff730e6d1def7800f8ab0f86388c1a3e8d6885643297c08a4b342835baeb9657668adde9b0aebae2aa1275ca98d47ca3165bd485ee1c5f7222d244cbd413ff21513f6afc3c3dd0a97b322b5b2246d4e523566b951be7feb2b77e13233c413964314e389055bebd903476c24dff22f66035785d7ca09505660e5efe3be0d93b8ab68b885ccd1e82f4c8860a2fa9ba6ef48ea97924dd17daa03397b93c5db4fa3a905e9219ec3f31f6f663baf0671e836431af0939b6a043a159db04019dd4afb65c710615a4f407f5bd530a160e5f260d785192c33126a7978875c628ec5aeb6ec5bb1de978471788ef9cdce322882bbe6dafeb7082fe65840fafebba454ae25455fdbc3cd10e910f95ea00a16a12dd5a99651b21787fba05204ab93a768338d596e511f67800c311fd4b4232713c03ec8b3de17cb370a63814b59ec68d474f08d4a4acc79a975ded90fc88a1508d5d23b146b66cd2929a4ed44a1109167db6f2e224292969b01f9fb2cbf81ddc87beda31c41ec3dbf74acb784ae46fc2b3bc8854f2997c629d6097f4902e33c2ec48ce135e5181cdc8d93bd7fc2a42daef96e96ad7de762cfa2dfde097e54dccf9f53dc0cb47bb4e938d01473eb4b3813c25d97027a04bb82c70fb1d5add128205bf1a69d45b6360be33410632ad30e6855f24dff904b330950f2286a64d1662186dd1f1e47b9de49bec0723a2166e21753ac138de81dead0f35ad8becee3b69835330b598f9980a8704982c595835a536208a915415d14979bdbfa46e517a67324579f039a2b1120ad0a864b6c61798b14840a243d35325b58948d5625dd883688bce339610560739fdf805305028d96963b1d0e28e6bbbc2bf103280a70010b31ecbf6aac41c31c171294166c93772353a263e2c7ebf36b6dd7e9adbf5c3f565f21d7200ceb6f389464419f376af553de748fcc71715faf27650dd659497dff55a0124c12e1fc8250fe88b4fc980664f6c964a866883e9c6882183a80826388a85fc4137f1f740e4b5477c7e9535ec2f3f5812d9f9551269f8c007e72a85e9187c675efe2ad6d08a66ab4a47395d77a2a01dfd433aa00832f5f0387280b2dc288a52d829696407f7a059c282696687e10c5540bba0b888fc0d9f4617129210e322988f67dc41c5d31c1439d8191a867ae19e9a2e01d97d7a038d8bc54190b5f1211f8ea2da1c5b11f2854b5f3ed02958768390e3c930afea064364557d3367281e792a1db33bccdad6857bf796d32cfd5f51dc855805b1d0b5b28ab0cf42e98cf070b0f231e5cba48305901d60bc4796f1e56b8d585ef63102146f9fd3916222d16d7ac1873d5be7fce1e2b69f16fd1e5a0cb42274399d3ed4d55b7753d2778ce0831caa801637116b5e49ec367186328e3c7a30e1f1050e5bdd548df397fc357bcc61bcb70595b7021aaf306f222521885b1ca86721ea07f9e12c5f512af4dd4bdd049c5459271efb8d6570ba8c9f32e7a4895ff2687f4246172db23cf75997d0383257089dd3e431ebc74a6f6b77c239a93466bd65c6ad0a73ef85e0510e4a2a368669ea7ae35dcf3a636e0adcd77816d76727c3b8f92fa6773c41a6e496daefd6f31f95bab5e6a33d532715e083aebaa26629b9d37702d1d36b229e5f180de56b63bbeaf3f0b65653eb85748a30413716b4a6b1be8efe71ca5a4058a5946a033d6467af6325057945d5b04c9ee82045cd85b443a126a0f4e04acc08471e748e21f20bac77658b20ad6b042ce423595266764b43d749a3dc8aa21fbb9abf64cc56fd68e958b06fdb82907e044cc9c13b073af6794b245f694c22dbb64b715b2339032efcda3e3993449a8dc606a8a028ae519338d0c8ad1bf8a0bd96335e9e941caf1e3e26ace113105ae65a7cfe9b67dd767900f27db928a11043c4d35e2bdcb8f5f76b918eed11f4cb8bcf46c66411def0a27b79b618ce2dd90f279f1401943a8f66eea99445eeaed7716b6e26c43708bfc257f71ad70a3669d574b1cb26129ee3c20655431dba33eb98e4256e5245850746946532e73f683744783433c1a9db64f7dddfaa774f950faf423a7d0304a1dc21b0be8c34d389fdb51b5c2aa65f81ddd17daed8f5bd26b3a3d1823da62b10c9bd98ed78ee728dcee476b490496c0c079a0036d67da248084861f8a698bbcf09f472aa6c2211f628b1e454199da67c7ce659d627d04957e4307f7f9e1b4b2725ef1631eff7adf045a9b803d3c71fa5f565ed079e258e56c6713fe8ac8fe2e738dc654b587a655fffda44704acbd76a48fa7e678763b9a15c2848148ee755263d008d76264e1876f2d168d924a68248ab789aafda2a511ff037c74e2b52e225895ac558122be6bf2ec2154d772feb9708ea0d996d6a31dc883a7b44acd2628e42b0dceff95f49ca07442be4db992005b319c710be814be831e397f6bdc00dd73991ec0f3a21f5b09b211347400c1591b0d498288ba84e7eff06c25d641749be30133c9e4c179098e5f68cad4dd6b494c8b965237dfb239f44f3f9855733c7ffd2c0b211df45884433d1b0791b839ada5e997759376587404ff9d78d33dfe0230e9c86e3d00d01b54458bd18bcdc7e5c1d6ee1bfa01bae0c8ea1803044ffa9300b7b6046e7312955489228f0a423f24c127aadbae0575cfc9eb25ad1c742c414f3d8b37b7de07db1c542caba6d901dccd12922c6e469b730c983cbb4143c5267874bc32fc667da8446d8ca99ab8d9dc2567de463417a0e35388c987722d07096d81961b92c52185f607ccfb73edcfd15c6f4ad13842697083db4512e7b95d658350934e018068bc3945f538ed049a12f0cf0ff43dc875bb9d9af49155bbcee430f216e9077d1982b61a621aaa17c2d51c058689e9d4715e6b2bdf0b7287f7a4c28e86c220537f2efb34a1fffa933bc55dc8e47a7ab9cddba0cc5aa2d23e9dbb29d23749a78f8fa82152706f83fc75d06c22d139ca1dd4a7fa4c2e637e427ce86b0a1969db5a9fd8fee8ea8a4fbbacaac95200ae2fccbf3e5a76d9756ce2eae55b7dedecc53055f1294bf5d3dc5bd207a589f7173b5120df5a6d676640ed60483f581caf18b642735a31657f267d8b910b451268a3843aeb251d9348262c6db8640f4adbef9ec6cc44475c66d31b086204a1289aa7e38480856ab91fbfe2493956b723aa735208f4c260731c1e65a4c23acf6570cebfc72c5677819d50d941381166ab9ac9aa88627a91562551802eb23892f3d7a267fda2aacbabbacb2cd577e9513e9a457b942d055aaab8bcbf63fe4fb4aff770bc8f1397a34b451e027ece6d3f50beb6ea71320b045166973476380ae8eeaf42e0a8c84b4c3d5208c849c68d68f941efce94b41ba947bf12d97d262478eb8b550dade3bfd2b34608820bc57fcc51f7bb1549c65422759f5f42b9d66cbf13561074e427bd143327890b7999e34215c95657ca5a08e7a1b5fb81b7bc78330f26a487bc183dc35cdcc2fb2540604824c69441c2e2db6bdffb6b489781f4e7975df8e9c7caf10e9c9151717d52e0602ca0dcb55dfd5e14af336103893aa2a7ffc1ae7732b3b9564d1a936ac0f3c3887604576ea966404ba25860e1ffc411822a7e5b513e4117047de2fb6d659c5b5fd71c5eebe9c2eba8060c3ee5835ab223dd0a2d95f2825808ebfe2356fe5bdb527d764b0bfaf20fb4e837f4e76c961633b754f5661960651c695b6ee704afad7636accdfc55f92bd0d00c84781e71d011da25f39b6c30f8a5fbc84a55a3d5ea814d3b6e78e232bad31510cfefb0985a5bd58b084318d7361f8c92eb1e3004893530602c0b31517c2ff0eec0fc773d87c83af32fbf2167f4c0d3bcc093ed50a555ac6260657fada182ca64b8a6c6d76def22fcb64d4f35cba16ed9676b3ac52ca749f5f6d8648092e1547c73a0c4d482c77ce812bbc7e9212f6546582d3746b9f6b56bc4fbcfa4f95fa7212f0e2395c98276103032798d6a0a510de23fb35dfb4724e1e57575e227cc04ac680e0b3ad2de6ea1badc9b0db79459840d80a46698f88c0e72768a45b7221825b425b2b28fc8cdde93d1eca7e40139cf0e4cefb80b263b5f1c97f2b653d057122933120f327ca0f87c9eebc933e58a7b385c207a4d70ec73327ab47f5c88c3afd6ff1c96fd97044de9b08a5ddc88e49186c479d5140142721b3e83c37202bdfc50cad442f865495bb3bc1256ecdb34e1aa387d88fcff93f6090e19b942026448e50913696ca587946a73fd4e72073ced3fbe852d789125820e51c18edce55d0bc91fc491812faa24b2e7585f7297487821c1536f107956c47bdd3aa2ced569a649c79c1efe430865ebb154ea0d3e44f2a22db26cb31dc86f77d679e0eeea155d10277fc847e559e24bf10d18cfe70b231d9d0096b344b4deb92f8e463049132773f7e37d74a2e47aa92c896792a9adda9b69ec8ac0a83022750597b0869ee87717eb849c4cd84220a710269cb9cf52faccf2d523478de5c9eedaadf43cb1af7ef4015c906cf0faac309c898f3a7656521794c3f9106fbe7f126d5a22f5b07ddb92b67e2c98611b85cddadfa3aa9301fc51ee4e677c644bac3907aa29819b85ea2823f9f7a41da3780996f4403084089a66574dfe3e3072d4f413a5a33fdc18ed92f9e865dffd769edde8b6d87eff755773742f5e5aa21cc6c5947462d6e896fc6ea5d01295fe80497a34cc7d2145c3cc62883ffa5ab8bb2ef53b1b452e245c913d70ef097bc0b30e2d894790afb8c5cea271539f3fcff2eb0e83998071cff4ce838a7d30023b04619696bbc46e46799b2f8458e60c8948080dc08c53432c7c89bd9d39fea14719cd1e3a114cdbf3c14a2b5effdba52ddf06d6c5082a44ec504c418d6c73952f2fa3cad39a5cce5c4a43fb73981ac1d9fc8d5fdab1d5a45c0b0e0a11692c02167609d5c4b14ddc174e3187522894dc8875e22bdcabc5175ce60065e973ac54bde2eada01f43af88a2224c6a97d4b6f26efbab52993fcdd4e67125b2c00a27ca538c077591518062cb58580f1324614fe2e151953af967c82f05ea254592126ad7a6a65feb85dd0ac04143e4ed779c72a733c7319e273feb16bd6941a494dcc1e9f29cb0ea3cf0403dff8e76322664c8ecd3f1b1b96f95669c92b0857d82fb84ae0ba5c337c7a6c4faaa87a9b581acc7463d3166482c495a643e28b345bbcc0522bee3bc9e0991b5d6e1010e369b33dfd6ae121503a936d458b9a0690a31b122b58f71d71dcaf718f7a9d27830bdc3bbe9145f0bd35d9b3f1ee9242fdeb53e809619879b2c97355a4e8e276e2824e2d85a502305321744eb09b50fae17284b48d175b808f4eb3fa1e828fc7dba6457a5b2c1f4600dfb37ce66493385913d570e52e8b52f73f2143aa6144ea82fa55b50012317c7e56f70d3d9f80f3083fdd40616c0f48239b613e36c03170d9d4ce437853c7db436c1f382405f7afb977cb88e59c1092bcd15e51cd2aa234d214ffa2f05f26374a86694fdfd0461fd84537afc517b1560efcd6162b5392a1240cd2d9d1d71f37afd47c19d1a3e8beb5e34c4ff2ff5b5717c420c9188ae7d5ed4b5959cbd7ce1d88a4c7f572fd1d3a74739794a67b1cea6f8b0a74e14a586a24aa8e5f571dbed058631f015061e4f1c37fab9fb1884ae7085b1a5178ad97172ea5e8b9d658f364c8f09d0e28436938bf7ce61fa3ea793e502027418241dfdace1bfa2b8f5961420f62059c2efef9f8182f0397806a508f8fd84a3d65120d690c32e0f21c75786050bf83cce44a688ea6a83d29f65255581519ecccebcca9534f9d93e912d2fe0637724fc4ed9512c55cab3339a4596c1e1c15178bb59b1d3c22c333ade74c9241193df374115db2be593de2b2ebb166dbf8930ae21eb4caea2032f39f2986cc0a21b3b640b810594151fa2a3283ce3682937fc4da5b026a985214e00806bc3cc0b0b82ca2130a9f0550d1033c1da52b5eee89c3101979e51a7bd10011d6f1faa2b0f2fa0af91749300f2b922b5937c6585300596b0e8b41eda462447af76d701490423ab2b803f9a5d1481c52e5dd2d531c497ddca3c39c80b08bc2c2ff997a59d43f95e7818f644ea9adea70fb455c44faab742c8b993c4ffd667f078b22b5e61f2ebd2e32f079b75f1bd4fa14c3cad088c9f4586c808743ebc5f68caee2a33ea34cbc150c209a88a58d541582cd7a430652d8acba5d54e7b8ddd2d6762d6f97736a03cae45a2a951f7147c08a3aaa52806ae056418cfccc1bf72a0fb5e2abc7f8f9377af565566150eb42abc17a71470c99c5a2cef56f2a209965d52856b70e546ebbe65262ca81b760b5cab71534cfa30753d5da48ffe47fe044e28ff82b117449174eec21ca295eb2aaec933754dd99fc254996b09707cd7b4e2ef906ad59a8d95021f6a888780d2f1f89d47cdc641f54852be5abce0c130abf020dbe4986a89a22d81ef88d5bb997ff392882c9660c092ee1c37ad2826c621fafafba49f5fc6b0e517382d75b5e6d03be454bf00ce6bceed2f3af576ddc94dc67c772fb22759a8b84b7b15ebbb0badc952e7d0e15d70d8ed989c6541901b295720e53057667d8b988c1f1588a57c08a19a622238b6a8b26d8a6c46e2c1ddc6b42f14db752ec6c1951e0ee6f1bfab1f4ccff335eafecb85765c417dfda7fccf013d29dd0d7892b2395f852dd167e436bf957b2ec8df3595114d5e54f4efd328718d880dd86a2713dcc941ecb3cdd70751dd92c70769c02b66b39eadfd6ba511cf2feefdeb633de58276f28fe3c74f9b138a8599e8e4e30829cdb58f333e9c0d286a55245e4ee5aad317421b9d1753dfc2da36b6d28f55dbdc5cd3410afa226249484d4c8e90321f9a7c5658e5060cf7f6dee07cdc0494274fd1f5872d72357438ebf639a1736b1b68df671db71c7b3780e9b4b8089d2dbcb8d1a920695386cf042c34f91577d8e9537a65e9f378ac35cd0449967877b6d9444f8787501525c78e4135267136dae0e02f75f1a55917385a48834b867290f1fc187e689ad2d1c67cc4ee92e0636b79c9bc7f5ff38b04403f21ede3114cb765c1d4100174c258db2b5b62078e3c3be6dbe13ddd7ac46fd19b1770ece108699da010b481b18156cc465e91c1af05887916d57bea7bebb45a4d86179a2012ad06949e4fa2536e3aede0628da4499da8581b8c46c8ada63acae0bf9de7f4f421792adec8e46e63be21db7708d32d1d76c7586a002c194db7984041f3e86f7d094aac00b1a4f33e5c1bbf18643f4014ec3e4b6a3b7c8d32833d8aab24c3bc16697817492b983a1247ebb304a4204320dfca525ee24b61be24300722d4621976c6aa69bd0860bbd79b5540202372120e84e084266eb0f931684342ac3d6a897752d572d2842dbea5a06661bd6fb7cc081f0d5623ac8bc29270b4315cbb29b8c95c0639a52932a77cd35c63b15387115568cdbaa2611ac61869a78a599ebb059c2d7c4efcdf636bdcbfe5b79a622b3bf88176f4dd3e0ad661dc4eb2449da0b85cf9d43d5edf084c8bc9d7eef03ae6cb21ac6623fec96141b51a4f75527b39c455431ee31f6771009e577654a2896dcad06bc2f0e7b12ea15aedaca9c10a76b9f5118a0d641d8f8765413c3a4b696ceb6afffcc5162065bb149aefbc279427af3dcd11526f104e7f76f50d99802c97e7971bac0cd4b3d198754fa5996cececb25dd243f0ab64f548268b30a0214a2734feb3f5d16b367dd4af0420c68ff5d473601a66c817589e9d378bbc54bfe5cef4e46c16c887169b76438e2f28504e655d4a1b1a344bc9d858b3eeeb55dfad833a432b55ca1054f401c4d8de047e2c61c39232d0cd9b8e61f2bc703a746b4d275b46f238a8b072a93bd58e7ec85b922ef4f665c7d20711e96fdb2b2a8908d642162553ac3a4aba1f1401de10a5cb68e4c6ccf5e9fd5cff95ee5a03ad340c939f4c43984e1f2c925930272d744d3a4854a0f0b23075c69c3cab893434be72d1226c59f201919d4ec5da900900ced57738365a2838007fb34766d74c68b3d3af7ed312f4c458a6b414a595bdb369a190ae9f23db049cf1e3bb7c6e44cf26ad3ba07a51f7ad572e47bc412a290fe88a931269244050c41fa3b31e76670519732dfef20f0de7c49120fe58d95e96fcb927af6d51698146ff3d60cd9c6303e5c460117b0d47bb5a12d04118e600982fd8317a1b1f78e920991017bf0fb25779b4889dfd4cd21d17fcfc0795a989b3e19c9f70b486520a305e037924881afb292ffa68505aabe239d6a33b058484df1a2a9dae1b17fcedcc9c17737a08cab5d4af794e6b396df9f02fb6569353c6fc375023815d24abf766943593b74b90abcd8fa0c1df7a96dfc9838f99c8fb61fc4d55d78cc3cc3251f43a852093d07394229e73cd7d9dd3d06a476650b92c1aaab0a1e13711c730196346cc6117381e6da12adeab74137c1447466657abbfe49462d4deefa845082a83e83f251cc5c09ba2450f80d495cb4ba3edd40b6886eee9eca7a6c805ba2d59aa066b5a0939bb21c0c553a35168116e42f2829edd266e3857f48fd537fa61c9305189835fd1f8d68974afb14c687802994103bf3e0bd202e61db242dc244c150c063680519a8d7f5355bb0451cc42b664a9f119f9a260f6272779e4ee944d7a48c8608b30daeb70ff443388f42d006ca11ea8bb77697c4ba77bc22d13426a15db10180f7396612a4137700e5576fa9eb4ae82b242528a7e5eb42a7f51316607c07328d713eab28ac29135f827b5a0c272267c4b5fe6859eab1f8ba5cee35e8997952a5c964a51367442230f372f7ab9b94286c9ee229593ca538ceb3733b7fe90806bf77858b37785a969b7c341936ffa2bc6396c8aa0d6146f50e595d26d352577cb97c7937cf8060afc34281bbb4a97a16bc3eb6d51f1bbb9525d27cd6cd5cfb713ed63a3b230649f38c110ab878f41a494cd1b1e54f7141f8e8531f6559243e7f72501d2288c67cee9d0aa1098ecb96feeb0291887f51e299e50d255f70c2de475d4de14ed833ebae5c5f9af00dc928f7f6cd31735a782b68c450e5c85dbf459d1ec2a96c2cbc95c8aad7fd91658cae5ce74952b7b97255d53e87162623f2d1dee2467f224a1bdce53c45f3e1b8dc51bdc0fa626324e2cb2db7ec1098dd1ac8994828a3f8196ce65311198461094c4c91d309ad0260e0c2a646a6220d50a3643f70052c59377216e3a2650cd63466db2c2a724eb7fbc9ffcc3a79433ac992a4d5c43db7e4a65165b569c376120a4d8a85315cde466491f824bde6b6a498f8e81b8a5a80743e534ececc16284a64b36c02447aeea4b2a2a9da75837419061a6ec0ad0a066d23e8949c7fb7d56e1ba2fd5bdc3cf034df5101ed0f2befcdd50b93772c971f0c31ae6e42c7873b4890f9df7d4ddde1be10100e48351f5f7a3b399342dc70c561a659b865bebee1cf00845a11d97f9f28fb99ef95dce8d047131290f0bdd23254a5f806c180390f75d67811f5f0f95550368dd2c70067f70d2a5500fd30c13431f8418773729ab12e68e7c1d20cad524a5aeae37ebc1010dddff154ff1e18be4b769d2f2eb677f40ba4f067bbf47adf3a2cab9854c3a6947cda4a64875fe1a64c523b11428950cb68dc9865b729a7dfd9aba67aa3ffcd23179d39e8cf40bdf16722c3e07d20490eafd362e5def0a98ce343d9c0038d5b12c68bfba31ea9aa7e20a2ee8ca9aa46c0af9b8ff2974bb5746232e97832df3f3166b3330fe2cbde60802abab54b17f1be8cc873f7dc02f866627b58806898d19629fa59df6d32cd57ab72467253b1830517df086f95fc6a8c938dcb5cdc07b334f47f010add4ae0b58e70aab84844c000ea24af296c47d870cb8b995288d1946a7b26d48e986142c56bf637093e6295666e9a3dc0f603564ea0c917800ade9ce8813611996a66cedb96055b59bef5c5ee09545f7a97c75a20aec7ddba1ad881c61d32f5dc814db48cff6faf307e882732f243812b07452b98bb97500f9440c732dbe9702e09e93977a4a4faa7c0c0289b45f147e933dcdd323be92932d756d2244d68a256ca21a04c583e8a77aa31d4d1e637a3af78b935cf149a934970f1ccc918a49a0af1f4552a5be31c29efd48c60c53cbfdf6301b89e9da26cee4289c6ed53c5d4a5d46948eb4195197af69b56d807e796b135bd92ca57c6f7ca22c84894f198700dae93eeba7ea0dd3cd66d637c23025dcffbb98ef59adaf4d5983a0599e88f2d465403ac35ffbf782381872b4ef890c5d3470114607b70fc78b1d8b952e122fe6ed060e3d51b2aef30e1f0db0b83e5d233a73274db619799846ebbf3b821b645d244708257ed0a5b3732463e7afd3ab4bd982a933190753939dd0cbd9e065c1c226145bd654771e3b018876674fb2d1f5ef179483de0f28da7000fed7ec345ab704460c3b98f96bc925a08785754539f872c83a031b50af46e1a5f964b79b40cab533c316ae74ffe87ed47f479476c35ebb2f70a50a02084ef7f98485b8a3d6efc3cd1898d3068c8b1ab7a4279c16cf817a24394b20c48fcdaba37ae8715673a9a2bae0e91cc8b5fc197638c20b7e9cd5f5a62cce7c0a1b80491a53a79409cc400795eafa870e6c1c2ee719db0c50669d0948268cf5afede4d9d3a52f4e632a6deeb42d62bf71879669142fff8f9bf4e81e4739c0df7f17583aad2eb11b6546a202ffe5c8263e660d1673989517b0a8a4f5b76ecc39a8a6d78dae6ec28c79679eff225240ebe4491d3c0ab98b61b01430fee76f0ec8766e261b154a16bbcc840c985817eafab58448f273d4e9b1b46fa79ed0d2ba0b215e6b482278dd25638d5ea5aa9e3dc13ffcffcba87cff7033e862e92f438764eb7b44b06c504527292d42414850eea42fd5929378d1efab23b4d2ff3853d3746d8566f369d5c10a5dd77632b67a8b9553137e40f97f8b1e47f8cc11f04f7932ef542061df2441b8f6b117c762d11f040503af08eeae5ddded02bfa31d1bf8b27b2bef0269f2aa8e98e494abf731d3be36ff60495d8aa2c9a2356d4d9ff3a30ccdd08a10c1b27b147080fad4cd6e8553e7915f8bdfa2347876e604c1d27daf5f36d6ea44f822d8d65b0c6f3d2bff809ffdf049eff07abe9dbc7233ea2106a6c2a9d0c0d2e6b7cf014e81832e2936582d03f446902c363b43c1f55d194370d13985aed25f79a72d4325807d5647b614eb5862134259b38fd543c2a00b73cf29b0c2a390fd8e53499c891fdaa288e2f22b95e619adca227b0864904fafb3f7905a25a00b07a61ba74eddb94d683b070aaf45f0e7d47c035952941bb0b7737f0c6ae09ec3a23240d4cba3477f89d23f5c8987a7b19e3319f523d1d7fc8cb30e64989ea4dcdbc79e9d4b5e97f3b71ee0d68ef83ad92085ff0d72bb9d5b11b384463b675bf884e112c30627c245164b2cb865dc7229b0bce343c1f6d9534c0a0ba545715bca076d9c1c7ac992cdefe64ba71b53c8f56d564f3fcd2754abc0596a3a832ffef2f327e7830cf2753c6d1c1a1a0a31e7d82b506d0cc99274d29626b3ffae717fc2e354945a6ef59bb3a014a0214ba08e41135b25df47145dfd1adf7bcef5765c83df07f73096ba6f38ea71347f13e1a69d3e4d3f07472d43cbd7e1a1902360a9c46c95d9c74852e4afbd2d69f7347ee238fac8c49c529ac88957ec42aea84cc89bfd2ea6540f9da530499e77bf001c72dfd9b42122b9c670267395682fc1bfbec3931fd61951708c0b0f3c9cf8d9961ac3276b49e7bc42992e64449adf8253dc1164e619e488a0fd24bf902df197a9cc3f5258c1db6517a142f4777d9b40ed99176f01e80ce517a1933c7daee496bf19c39aeb1df5a2586a14e6d2ea08978da2d132eca5442498cdc55910be6acb187005edee5692cfcbbc9e0cd32aeb6082ab668b99ed75e1e79fcc6829a1c3ca12d419a764ee0fe91aca067cdc3e26196b18b0803d2c5b12ce91427be5cae33c848ddb90d69dd4c025c2acb602f66c30e0ebf5d94d315ce33304a5197c5f81f043c3a22f6fb4305e646df33d34e47d1dfa815f3e823b79f61ba2e399ada1134b9b65474f07dad5b54738e4c33260955dd8eca1427b40ca940af156f7b221d5b4289a6d33f154aa882b2dbf4cd29e23f51944288b4626b614d1b3a121633d4d8d1352e048d2800433c62f5964cc2dfc113dcaaff3c0a2ae6b4ad020f74ea69a6ee6c33d5e28aafc08d0363927ab87bfd5276b3d666321890f35720242818b9ed87cbf9c605e50aba671f6ef76464a98bd2fd3087533c1847d38bd2659d8aa85a5f282d70d81c74f5c92211ed2c0599613e5a93f8fa8e011e2709463cb877453b995fc38b6a890cba834b5085f5ebd1313c1054cf18b2fc2d70176a4620bf97b40501a5b9c8ab57a6a71c14ba2934f56acb7b9e17c3fafc0687773903049cff7a2996211021dbdd41c20eacc4f541a5b39b1e47d4666d3f23471508ab73fdd2cefcde179d820630924b93b2a2b45ed0337b2941375b9442b7479d45c197ae65e6d7d6c54a16c39c8b5fa888d6b0b5c382271319add9bc94d27aee04ae57ecee69cfb96e29f5920e365ffc90caf7b1942c285818c632597d043811d27023e7b34e7942fc85e2a5d313dfa0486d1136ec22d4f772b7890f5aaaac9c7cd75eeb2081c53d11c2851b84c2e3b0234e3a0b3a3ae9ef328288e76230b4525f5c32e9184e6f5f014b4f9462e155d357c7136fd4bdd824b2abee99342fea1fcf5094ef6d7613ff518126cd9719268b5a5dceeec25cdb292ac5c4e119b9cab411ef62c5f8dacd19dba73604f336cac675e97b06c49e7ccdf54d1d1d015aed720b79bf36a178773031ecd77757f53fc6c535ca71f6bc0fa48772ac9b7ebc910cd58b2d00edc158809b79ac927f6224cc1c2bc6d0a0329254c487fac9e170f760cb24a9e93ea86832f3f87379ea96e438df748607e75d67103fb902cebbeac4920f7fda1480069c0fc3a8e4d56fe5bd74651cd79ccd089a44e522fa3e6a9ac029e093a38435f9128adaa774c6571228eff4057804649bf6a46dfa99879e6a1214804e162a79a9f7652696356fa5417a0bfac63f41e0a4655922c135b29b84f3a3409a85247f07f96e8e342ce29ee000180fa92c12c48a9409048f6ee130681f62b74e8e828e73cd471c3e872ee3a9958e030752f83bbf7cdb8933461146feb6a2abddb5bc81fe71da9a27024ba8ff6e9126399e05911799c9299ad3ff99bb58bd2f48fca7b75ee7427f20283b14a5004d8e6e444e760b963fc2b6e44cf97e3cc2fb5e241d9d42e97bb98977e94de4ea5b0733de97ff5c98495046ab7e6317d45710dcb320c0610e20d220b1f3655c853b6107149947b8334b03e66913c1fe1873387f3da8f866000c5d2c54026353b19e61fc3d213c50b41afd69450243a54428f59f7dc2aa32a43f2febeab1547dfb35439a4407e5cb6f660ee9bc5613f14a8953e5415cf983542ecd144c0e822805a9ca7f7568bd06eecf800db98513c1a81420eb9802484d470938c492657c39600c2f53b02dcb828021d9572a98228fcb28af707068eca181f338be00b27fcb2986a981c80f74586f6b01bf96b040c8885a568723586eb62a9dc24771740d229d8030f2e4c9d393da1eae4fd78dadc6b8b18e59bc20711b7d2bf0c07ac6be2816dc8f1d971a63794c1b657e698597cc04e105aba04abdd1fd45117f39bb66b032591729bd68a710c3d7ee3108478b946741d9ece927421072823b3b63bfb7fe1099ff26ddf7149beed60641ef0e251ba022b4b94b2947c18145725083a6ef873fc6d207220ef0cad96e74ebc05a9ffefc635a1785bdc56fabe6cba7b7f05d0b88b5dce9cf4cf103c8f043707b2f44d9c2cd8795c10e5f1fd322e7f94ce2bd8e278b96b4443e5e6d4998fec2b071048de4e59a819f55fbeeedfb670c2cd557cdcf30ee09fb45f3037de5ffcd64d08b48fad633da9a3b4a9ed980c0057c2957d975aed5b02832f6d78262abf519c3e3e7f39cbdff5d9f57958d8fba7fe4a4c400404301009aca58181b7967ea6c25081f4574baf2aeb8dea216fe92c3a4d2424e12dc5966583a7f9b03a1afeb6ba9a49da685e3a6ea72faee95bc8f249d691c8ac926444c14732421aa6aa9cfdcbf71188c30c0e462a09933e576da5b6a70cbf2c61e5c578ad4cfa7c1739bc273b885685faa733c67d4727e6b4b6b6a039bd443ee9d542e88f95d8479d4daba4d75ae4ee9b89b9524ceb0454fb6df047c7bb7ee4f5f38ce8f47641881c3276d68e8e0878631931d9ffd5175614c995e43fe8e531429f854960e554b1405655aa81316574e0eeb2b0b0952a4d2df621993298c461f69f1d9687f69ed14be38da462c26bfbd8ee2f3c4bb98dc1775e1596f093d3b8c8283d12ca20dcaf765fec2d6f45533e63b5197781ceb1b7f04e155e3149372420c5ea2e4fd1865b3fd6e55ad85310585fc49f53c8b7fbeaa51448270358fdf37955f30315b36255632bb43e42b3bdc9a35d2958e459403058d9d294591d0104aebf8fbb3e80882fdf6cf940bad2d2a004135f2631539c19ef9fa28dd5e180203de85809722f3cf6c0679a70ed570e614601f762f644d163c9a516ce3887e10d9e4f35740c819d600713104e5e461968b07078e4e3a8d3e5d47ff0229d1250de7772f11b81213c7e2bc2f039774efcfb2124897c24a17eaa51fabb0d26efdc57c09ab2e7f0456a2923f1fd2c96268de981dff97fe5781001e7fc23001d833c91dfdb391188b6fc18391d46ca8eb04d22e88ecada248efe37c327e7fe7aaa4f47adf636efad722a810be11bb0b287b7fd4f2768821cc7f1b7cb3a5ca69fed5b141f51df2aae7b4514f95bcf01db5e11f818adf88a1e7ac09bff5f5e4438f0265113c3327bc08f4ae25dd9b530830b806bc880cc399c77a4ace747f461907f9879661f62fa330faedbce20657ca70dd8b62d1a098f296d1fb08a64b24a059a76a21dbea27f57de6cff9f653ef3bb840f436175585232df593e7a989474a56236438be9df25e7d3cd514d9d17e6ae7771d45c766bfc092cac3f44cb53f9e8870a875976113c78b10f6887431b3f1eecc171370a5b88be63ea8762d3148bfd05f54345500df9504d0649cdca5b266d6811886c7e0c41a3b107da10b88bda31d256bc3c1a3f6f962a636980522e86007ef79d3a26e254cd401c915a2cd2fa8a03a9619357fdb8809c43a0a1df5feaa04255de0826b79017b0956fe65fae40e59eca5e3ab8145878541760a9d12d3c0fdbe9ae0a0eaecbb49d13d1690ae74272346ab0a5780b5332961011c4cb1e4d8831ad9e74c4d4165d1879c455a0f7ba3364b4cd7c82ba9c1a6aed6d32dd5bb04513ae494412765bdeb5ceb3368321117232f7bd519a77e2b394cb870be5afd3634c871d5c930755c2e093500023e38e39460b4d4e06ad15863f39a5232511fc16c9e948d145dbcaacf0eedd0250652f3b7b3214b91412837067202d1409aef52d0633162c200033ea357dedb4465cc62dd435cb99a023a2347122c52fedf894d0c6b0000b5dd6c5a9bfa26bbd4ea9806f7ec27074b9098e147982c60564e49a6626f9c461135a9d09e74df0026ff64c5b95a169ae1f50260aea6740dddf3c500977dda2ed8e540f47de263a94f02730a84b5b4ff8a593a3459580b3ae3cb2ed94aa3d5449baab6192e5bf40b2a3f24476b17b4a1ea8e5d551c82642810ee6f79c066f87c743e72e9c136a581f36b9e369991c3ef76ae837c490b5456ebe8e935fb45a0ce1d870f79c31bc563cfaf237ca13b3e3a90c013e8e7e57dd3e870db294281cf5e55f4ca50a8f1213a72d227b928758c5e3d91acceccce09e717fde07c8693656faaf24ff0232123afb2e0c1b4d9f422992208973db53384bae22d58df931b309063ebd40bc0885eea5e23b86136d0bb75fcd4347855310d2bc12eafcebf3abab47f4f4e315e118e484757052c010eeda64d748e18511dee15ade512a8f3b76d5b5bb97cc089d4256e2ae201747f08ae80e0fe0b27880ebfd206e0bb403d632df8d3498490562b7dd59dd999f0c7ff0b0f8025f77443f53295ce2659cd4d9a6db37bb72629c9e1b8351dc93de3a87def0e5762f7e88cb09e002a74570f7f027e9c0c1f8fe4c33a4b0545b50cc8090662f1cf5c7a738b1984c0d7ce53e5b0961fb35a48ecfcb041248c47149ac617d1de46e279bd2304423a8aa05a3229e5c9e15fa7f8ece9359a023ad60d322009ce5444fef67b254c5308d992f3126e90e5e635cd72b987c83db9e8f8f5b33e2bac559fbcab644fd9546335d2c0e111df493ba7c34e7679921fe5264d4f3c17f5f6038c9317ff2e8f1256c568b3af9c77f5372a9dc7568f42f4b079a13bac940ae90e0c6ea9e1c25f084ce3a160c2ef8a58755ed91d2071841dfc77757ceda60b671e953fc839c386fc2880078660f9c8a95fe08cf3aa7f81839b54c3f54b059373bb1d92516c242ec6d4fc44093730e079017fca776e9f9bef1eae097a63139ac06c5cdefa5d75480c5e13febcae4330bf5e033b899b539bf5c3ae6d76767b5f148151b52c932bf760bbcefbf4eca23a610cbde04121036bc748feb509aae1fdff21818ebe5190861351b0577b212661cd01c00dc196d904087db3ed0d6cc523ac29b72420d4fe6d318c1e43e96752934011033cc5a24faf7f521eef00c45d7b75ee010c45894f095e337fb0c1276f9ffe971a05ea3658b3e2278403cd14ba889f037bf933ded97ee5594085226e7d2f86a3ff4cda9c5270a3fbbf952ea743155daf3f145a4dfb19dea68c20cc1e0641816414599c85565d5cf439b495f855aeb2aa1ab1e0d07fa28240ed378c32365956ab02f4370223fc995ff69bac8fae72bad8ba6cad8ef70a8b4a74c1d49803c705c8702e8feb73461d0f541a204d56fdee4ff57dc382bd097ace8e32c7d9b64e498af1d530973660f5a54e4ca63fd1a2a7137a3e81d971bb5852a3792363cfd6839488d5656e6405ce2e57a45e91a6985a670acd430ba63a0c178e41dd0fc0449d8083c0b4ae875889fe8306d4301ff4372b1790dbdeecfe52aa6d4b7e6dc539a6dd8ab6d8771e635d92196b9f00259db0ca7c4d997154b4845273aa9f65826cfe66a11a19c2a7ffe1c3958e76967e50c414451362fcfee7745fd61dbe61646f540e4b119a41687101d5ed30a091af224d8525c4745644c8154d5fc27b7836dc93638f32bfed451a067e6c7a5083b8ffda957a2a779101b27ee98bdbc73b04ff96c7f8c340cfb20cf938b034625e975819ef843f35b919f4e599f53a280d74195733ba4527c6db2c83eed1d5282b57608f2b9e042ed517a0904393f1f1dbc1f1bb858c3936a2049fb5fa66193d9b7a8d203c0a537139ccbd83be532e5be6b5beb63118d48ef56511c45722961a8a44f70c2613dca218cdae91f23c7471f4b87b42e0b1a43dfa6096593c6437f19b27710cef6dc49ac899accded23d2bc200dd0e101ee38257167dac8ed495bef2e77480786636d18582aef66184739a1397bee6a4d1aa31e01fc25c9db38641d629211409478ac7db35172fa4f69158623aa25040c6d59366dce088049fdfd0ca7d13ea03099828f27379ae6982e232b1f7c061b523363b998ff1ffd5ad6d59fbc8ea503acbae76ab4aca3f28d14afc2885717099c58432e87e9f99a6c431b0aee4470a694e80312acca601","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
