<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4be07fe74224e324f30b07bd7014f339b09aad02a6f2632da017e365b5979e88ed77aa01baac7bdab4ee28c72eb03a36c1912b4662ac9ca5f915aa958da66bcd2979d673032395f766f794f4bbb37396604c7e91379532641cf6b9978034d4be00453bc8d1296d6783f5980595979732ae5506177e4bcd139a25e821dff71a7f7e749f7bcc544ea06b7cb72e5fd0095d60a8107be77a8909b106c59e38c0acd5cc6d3e291b0d5bf37cab5ad1495b08d2a3832e72acee9e23e7501afebaeafff6d0d1b78df4e6e947a97a57d4dea365d2a0bd36653d2197653e69229a46647d874d2dcbd81a5a5e4bcb21d4d2d1f410db52f2148b13fd17a259b66e166f49a3ea6128d307fc872be6734d247ec727160d114b7c164f94a46440a2ad217f9d6cf69530865acf0584a09e891f2fe0c312648309df82b88aa2d1647d032be1d0e030f70c37784491470dca8334a563eb55dcd9dc573d258a5d6b9a24ad61f775884c6f9bd2432f6dfc1a21d0e348ea955711c6a61619712e25f147213c0c5208ac21758765ac6cefb2dc933075d0c03a696587009556908a2ef06ce05db431b993d9386be9cad3fb9abd923d936af6773eab11c8567b46c75b06b38df07da67af4d07b96a5a9212576b3cfc88f026c65265e706e3d72509615d1c240037a915bf4dab1537e6c79ae249130fe3f3ea21b47416171263b85b9cdf08ef607f2188efc1f7e17d39f415124d1a31ef1e2bb2403da6afd249c9c0e79ff558b11de4c488839661ea1152637623eee143ba5c2afc45a741bf2fcd3a06e18653703f1c174773b6fadddb14ebf7612fc3e1a71a4abfa5adeb21202d83df63380ac7cf69ed5e5066f4b2eb48b8f77708dd24ef8fd4d485f845a79fcd10eb6ca1be8cf01fed3b8017b0e6e52cc9261588253c93dac4d6811196dfe35d4b1723d62b7781178ed39d0fa2bc0550783a4c5419d0639de08f85772eeb1af3c8bc8ec792fc2cda3db7c34b5b32d9de15dcd46ad3e97abdbbc0581f29d50d4b3dd42098ad9683af0c802b5b07d274ec5ac29253a1d10093d9a9de420814fe5594b7fa00025e26a169624a261188dcf6ea9f18ae15cfd80f83e4c944c0195b6a64787d0c28b714fd9da70a8b59a436a169e124543c1858b70e93b1e5aeec0686c0fc4496575c421d6845ae1191b62a04e6cddbd7668c8a2651137010187c8855e7e394c723635a5d3fa878d6918b4e178135893fa4e1edc6e4bb98cca95c27a393200c7a090055536d9f4ad3ab9d4748c1610ca37babeee4639c5ed55f2b8d435d746aae8424f3f141a3c0a9a0b4bae954c8966c4a4244634ef3c19a413d82cc3c312d8b32a83346dc13a6329d25724d97b5b15861e7410b5bb69a1d3881cc7a82e8a0447dc78710574b60bee1ac6aa48989904c85c093abb61d70c3445a692c5db478769194fdcc3545b205e56f8a417f1f448eaaac5de0a909d77448a743fde29135453cc7fbf968aab207bc1aaf0c0979daabdf2d93a278b4d19f541d9a6f1419e92ee3dec327b410a1b60cedc7f9cb5a1a13f0e56e2b5649822f3e10a220d9d2f7147b80a685526ce13de425ace153795401ec1b90f4538351372d0b60912c1254d0d32d1edd6e070a2efb7206e9b1826cd12c8872611c5eaff6b33f9927605dffae67e3708fb68a6b9019e2abc1a4711fcb1258e06f6c69ad4935c854fed55da3b2cd9bd56f9b8b3c71fdfbe2020aeeac388c63d99f73fa5447b8aba21ea5181e868046b1c809eebe2acd8dbed70be610a72d70d625117336b6ab5f11fe02ee5d719b61b1fca9f22179cc2e964e669d3d7b82a72ce0c32c158ac84dc073bef08ccd9b6398048730f89b6da7f3644482d4590f94e7df47f670122bd195bdb204742ecfd7bf3a58ba2c06948539568c93e3c13ef3192e3248a55ecb20bd02c7f2049386640568db7eb49601c0ba9311b7cbc12b492361dc9f483d2d32861b4fca86bcfdf8444f032836f4494de26d8ef7adf34491debb3c6a6af1f9002cfdd6ae394c69fb27a011ba23f7c339a0f8f1080e87ca1bc3494d840cc9aad07cc0a30dec65da8b4dbd3f1d1983a97a3a09c5eec25e3eb7d169b78a0f94cb0b9a947a0adf6072cdd78ddf0965676d6e8425a328c5dfb4a2d6c294fd471ab1dc22a12ea05554a26aa7b4be7f37cfa14757b645bfe7f0ab78dde09849bd4f98b322926dbdf8f6b39f4dc0db25bf699623005f931204e4cd4c2a62de99aab2706e1031bc6f8ddd3b27b0a0de2f30d7512fe95c2050f6a42a10db70655eed8bace48cf2d9a3e94c40a28155f35b8ec4d95ed95c0c4c23130920356ed29febfbac1f4da86f73d18a9a40c0df3187dd7f9d451acf51237cb4a4a85758dc39736e74125a5d3e6978bea4298066e90e37dd96815d191b85501c76412a568fb1afeb4101534e02080943c02b419d24af69f460ef1a805400440ddb0d6ecced0581cb47d71c44b386956e7dd895b4c753a0063ecf5af53e6980d5ef207d57ae80570c431ff1f1df7ea3381276afb92bb76bfc6f0036e7c5747f6697e7bad6ba7d23dc77597bc27019e8c5b32d9a67ff8692e754cd722bb6fabe3f11ed77963db24ece17681011e431f1c08148946ebceb6657cd9816b0bb5032a1d7559b6d8fc75dcdafbdea425f81e5ca98ccac76a6c05068020a3d6430f9e6d739839172859085146f5c57d3ad0b32090968a21c9798b112cce0296d097c62eb3993652d913a5a70ae41104a5fe6e55b9fa0d516032a8f249b6789784e79b3cac80f228402b0f947b0efacc4021468aa60c973b3e5169ac0616256179a8259765fb6eda538aa0f1052e0dc2c7bca0672b26fb6cf20c946b1bda256cf8fe351e03c068785b8ead76837abbadc0ff8b0c05d40fe86af94ed8cd00242e68a990e69669ca6f650c21987868194080dd19b4f0f1410e7f320e3f098aa8a70aa4be6f236170159628bb9e5eed13ed77e0093a9f5d0145972edb0ca6af8fb88302ae5150c7e1263cba92aff5d76a8d8cca4e7a7b759de792d6c7efc8202a65a5dc0998f902c4b2ae35f89261a12f871b8f697d28a3f614fde0dc7d1b478b10eea59702a2375fe1ac99e46144a24f3f473d75c68d7b227530eaf926e123504615c714e3084f9892ca3ca764b96f59aa1cd27fef88cdc81d4aebdc424729d8203accd3e866ecdc3ff6d70886f93be7aa24f561cd101be488446a475382412ab6fcac657015797d31b915b57f46f6a592232207b7a6d822ab9f248d71da0d1c0f0b4eedc535da6493d50169cf34582296072fc674c4742b508509acb21e201c037d5ecbf713a79ca9686bf161a4e47abd1928fdaf07b497b7c2cde449f7263a8563252a13e80a8e825fb3b2d170e71f81764d4cb5e7ae183d1b31f156929438f1038bc40851dd7e36d8c5d36d391e54f0ae097a76e0a49ef3b021d1cb8c44b2b62a7fec0aad6488b37196dca003ec6020802f6af734b1a79c45ed20c21de5c6fd2761d38aaf82c16db49d555a8e2add59f1b03b74743b55039fd47f5aac7e9eeabb2b3263c2579795defaddd8dc370d26e2cba6295c1b61c4e81b2100af7a0443048a63afd600d1881e53ba7121ebdc62131c5f8854430a20f445ec47b227ce5147822dec1b88df8439e681485ae7ac77978737a9d73cacfe660d6ded7ecec58137a7a940eaee9b5b38a7fdd3652f7246f9832e8d6b9a2699c11d9138636aa2f2396b7dcdda22cee281316ccbab588f492db654987deacb65e0d3ebd0f0d9f1afbb8d2bcb98e3c1b97f06012085934ad42d6e947696336c67d39fa47674a83429136915a0bd2fec333e626ccd121900f83ef71a95b428e592937a784a82fc2458cd095dfefb6997b057ae833ef110fcd13376d3e63517f50d317a53120fe8b9b655c9167913babdceaed69c3923ee6fe236531c88222e519a6dab35729192852deda12b8159f1d4be8a56c27af4df54d86619e6e37abed3d155cd0abd03d821f8c80ada2c41bb1ad7182aaf824f73e5fe2a341bc07409a75c35e18135eba9a830237b3dfe15b01a78ff661c7f8a58213ff7586f3d61319ec350f7baecfd2f172538f541aab95575768b68b8f109d615e41d704ebafdcc5fedf25db8254bdd6bdcc1d0e05d37f4eb30caa6dc170906f465411a1560db7093098a1d475fff6bc21482f5fa04511057bf2596e939646b9787422552dc2ae9456f98d37ae06ffabd2f3be5314aec8bc1798b7bf8e85fa920f8dbce7ed5d0a986180eee462215f3439ca8953214c576819371e764347909e29525ba98249906fa9a00e442326778f0467f97af001f229cd699ed179b12c2ade783c9d7a395bb18ee7c56a3ae1ab9d7f4aa980a80516b10bc764a11eb606dfb2ddb1a7b0ddb512ce11929d52ea1853b9bdfaca0f228a4584ad846b3e472407ec17d5a96798245982e9464cdfc89bbd10cd53541b56d6813935ef68f681f775c534fe6c1712b764e18e40d03b090005fdbc078e9af5917195fe11c026a8533922f3fd9f9cba44133f3b09fc2f8c0b0f445646d9a9da6f80bbf6281040dd5db5a37119037ddbef80be2c1b78db46dcf59fbbb027440cfba397d6c0c477228cb896dd6edbf1a62d1e11009d54625ebaf1546d81a7ebc88fc9d9bcdb6045d9cabe6c72d6512e4b00d51e7cb03959485a6eacdb7a3e8fe96223dce639ff39a8dc7a64185e091006b64d574e6df832de6e41a44161af09a79beb80acc445e47192e6403b2847254626a729beee9ccf4f4761e0dad9177d1520b71317c52734432adde384ad67649e242968f21aae47ab567f271bc5086249361cc81e8b488b23d5f2175abdd55a8942cf8f5feb83d777559936f2720c3c359d4419cfe2f04d2723bcdc445369be69337461bcee7ac02df460461108c312a1507fb5749a10b8233aa6c0a910fda65fd446ed64db72a52325de2ac6a9b950c0ca5c8c5a4d4e953a260f446928d4d6ce97fd56fda956a0d8d62e249ccd374c5e74b3ec438a9206dd59a8196dc9f9206afe7a0718399860816cce15adba37b1e7742834a7dbedfcb6136e0a878224138ca6ec3b073f6af17eae7aef9066cb7286625ff75359be9e1f4b7d11e81e20dbc655ff2cb58afd9365ac885485680306008911e839601b35826d31ce4a391ed64e9d902734d098c6022ee01465055b04c697a572d75b0d257cf7d016adb270abd296e2b41736f0b6f1c920d0a43c611da9c9af200f42e6aa89725aabc37d6fdc68b13b0f7602cca26868ec26c945c0c67337f22156ab4ae790214140ac8214b00e4f7814c31c1abe3ec0341a9bb8baf1f98e95dd79edb4bb17d201d1c2f27894142d302b0dccbcf9405ef93f5893652bb5c4773e30bdd31b0f16f7aa2fae2148123e94f009a6694134d5722dcb261e5247497ea623c98a9a829a3d72389cd50ceb00c6eb4b272eebb92aa7e673974e4a1f1588fd999f8d6ede23fdb9c06a367fccbb508a5fcd9eb7def83069c79c3ed5c394c29ae661876f708e17421be3b748868f2cf3828b8958bc606c8950522530ac09d14a798aa8cde389482e2d3c42c053951405f12d2cb08915586e7830d5b3e149db46e9f93c6d47fab539ca6874ad7372f382b0014c2d72e68b0633492e7defa75dfe5fc72a48e6d0def1b651eef0fad41b83fec381cca3de07f4c9170f80b3b36bda1be88ac0912ab0c068a3df755bf2d3aa4ebb0bafd4d15b552095a9497799bafee08c2d0d44e991687067be39f253e1e28c4ae876fb174b220f2af13d14cde6a116aa39249bbf2d25e1ed13e51b04e90d0c66a08606aee0f92dd5fc921453a2c42054587602fa2f9f80d39d1dbf5aae45afae2e7f2841ce867ddb1695f4d1172c8baaf3125c061ea47a664c1ad081dcd17bf651d49506af5422de883ee6b584452fddff37d204144ae0c1da19ce56cf716c22fd4f9460f12c9faa6a004d4113c4ccdddb84aa44c9287a2051346f4ccf79be8f590368c9f3c140056b2dc3c35fb603ef8dbb80c17c56c79e42e44b7bb439e3e1e451bd3308372e12af1dbf5cd17b45871cba7848f6652d6759400c6f5ae16d492c9c45c08e23e9611ac1e5e13f6507e997ab4953a8af18064ea96bc91a11f976815c66f94deaed2d2ec7767ee7ea6d23cd61d6d485d29948ad9934720e2770d23b387d0734628903f0ecd223553b082c37c39ae76b3b22bd9e4c56037c36fa2ba3659f8a53b4e92f12658027178a0b523368316231589748efbf07aada6590c36c8215fadca2028c5e61d1566d6358e334c925126be960de5d647c9a061a4aed7b235d921b45e823d0c59f8bb7fae36909ea918f765a6ff299320ae325eba2c5cd5a12e1106bfefd39878edacb95a26f25a78b2dd0465faa8e3a332feda3d750cd025074726afb4909e83fd01e9d9f16ec8d8ac4498478d154ab1302a7b419bd460fde837bc587b378c4202190b5049b9bc8f791839595f4896a14fabef635052654ace4a903c5ec620b87b1e47365713534cbbf33617ccb5170669bc33063e3b7bfaaea9f8a87ad95fd29a8e71bf5fc026caaec9749cc141e67e2f1000667729109aec46e081d4a2331930c3f1297fa45df063dc30c1da7c14646f6fdabbbdbfaa8c0a5f84df77fc02ed795e86f10e7ded652b90fe56afac61dabbd5221c1e38a79319d05f08438543d88a532599a288b2a3bcaecd38c92f27b0dbdf6cfdaefcd76d92e5dc32cb47bbe8c9c00f8f713b091f70a8b9bfc2b057c309a90e0be4dcc491c0a4481283e2bd3694d997261971f4fbf1c4ff8c878c2d58ccf36d93bc6f7e47e91fb0334382340134c2074c5dc015b8454c0a00dde4ca6b5545de8dc1b2cc37dd89501ce5c8024bdd20a2a8317c868177f2e0cdb1ae88a24649976b85ea83aeaaa62b43b9a8ccf9ba04b34989d65086e662f08746de53a1bef375d63f5938bfe1934f15428e5fcadffdf3592255d65ede0b7b7ea70825bd3e1e3599e14edc76f05c42bff4be54531dc75aec7a75d46d0b5afe7d8bed306cd9deff8f4f0ecd527d019d564684a82e0e72a52039d3b8b6ddad6dd9f6ac755618c46b55b4eccebb057712b2774b950b982cc7ccf813802ab01bc08ba0f052954e9fd4ac7adfc67a1fa34c474477893d925adef121d68c179416bb13b22dc8afaef994c331dca95536ef1a15ae9730adc08f649279abfe88aa74b0771b60f325c015148643abdc7e66a04757154c6abc313c889ad26473516afce18da36f34cdf71e8c616e8144c3f63957edb8e61a03e73282e4b5618006732c7e576c181af3b2c101f0a3d9875790bc286860e6ea0f667f9b88004c9844b6283edbee090e408d23a721f58f86c1ba8a6681e82e927e9b35efa06de88f724220e82f28965a2c4f659e919dd8386c026427c6f57c3ab4f1bad94c22e1ee5f3be77cd3bd99e410d69d95ffe95dbe3e11e249fd9bec827495c79ab1dea2a0971f8220036a21e46896d29eefbbc2dfd8bd886aafb6440a6d3f375ed43c4cbe92b8b7059fefa5323ffb9d84e383f358416c30af540aac0409c4584ecc54df3f30ece3063fe51d45547e1a2fdc0c4a41d04136ae53a7eca6607530e34bb6c6cd3d79dd9789fe8510a0d3dbd0d2552a93dbdfc082924240ef45e8177ad0b04899bbb65bb36681772f86d3a3e25183c47d0c0a1f8e97eb4ed2a4b51a841ab72bb565a2886fd8916aa3981b444abdf20018616b19f56909a08e331cef38ffaf33102932672390ca57f231ff61c05d3c651e7df149984f8626df97797bef96452118db0d831805f16a0adea41c075a47fb9d3c5b8db9b173db678cc2b2d4706cfcf45dda0ca993fa9745f72c3dc17909b25029b338e027d143ed8247e9e199a2a0dc2a8514ace52d535ddab1c316c2927c954f7e75f86dca7c266013b043d94805dffd303384d2af2266e53a3005ecdd0dd6871d18adede390f8bb3d408c8f3c43905213a2bf0a4c1d8205a6ccfa9d2076486631d64eb9bd0359a1b5759a986ef14c3626d453095c09651b31e37c7d8e91fcfb3eafa8f149543c3927df195bd047a6379f0326026b5b228e7fdb28ac6c096ee3c09f2100863f3ef35a962d8645c3ce4c7b080f321fa43088f263e56f00789acaa069490b612ff63952fa54a3a1d0289cf9abcae73e6ae2af2f16dc8910b82ed9ea231a25a0fe4c6416ad61fb17339c2797c515957d654f65dff0923d97c086d6002b13a760dfde2e7367c39215edc62d87e8956c807eefd12061b6e6987dd129aa58533bc449befdfe5c9a6c492a456ae18b55cf9ff886bd853a446d2779394a3ab817f5bd5823c837841a56f81815ee07f270e2489e90460d5d27630531db7727295cfb244069ccebbc878974001ba5a1440d2a8b68693d00e6f73367812990536cea8dffea2b71f20627ba7b4f0c7b2b791c12ef0c0ea58bfca88f11795bd3b3083e0da1f6522f994bf3d7cd34fd51ad907ead5b140ea426465614679f5a8d6ade456514679ec5056a492b866e30eb95b0f26d37a9ea435618ddf49174c5950de1e12935f7d15d21d8c94c6b2b6e6d3e0858c9082c5c54a6fc86a637e663eb21c98ae75bf5367ff098ba4eb1c66774fd27a88b687f5bc9cf07cbf6c8561a5fe158e2b6f9a8a96770a894b0e9444c43d3b629de35d61e4858dce1d1be58b4c2cc4818634adda909470116fb53aabee80bffa3b3dbba5c0f4ac03fb15fc60634f7f9472e790db17c83c0ab72bef32d85d21d6f429272600e1c685e3a9ca6b7273a5425a0604ff4bbe2d13fe08c5b45d1fecc91fe3b6ae812da2ea5bf194dd24840f2672bde937fc65a8b51a8664067c38c867bd6d6348463d0982b7069252e81c90f67b1530c4fa47808dd23eade8909210b3501a8e72233f9992cf4ff4ef674888190dfed9921631fc52e0007085400df34afeca43d934bb0b596ad6326bc4b5abbb99c2a2e0b506c6204826f191f0ad179da1ea568e0009a828c6f6b7ed4247ea91078ff9cad54550c117ca340030aaed7950fa10c79178131186745b337be6f18ce666a00089d93078c4bdcdbac787ee5a3983c35f023c0f9556d9ce394b1c9901d5f2cd653a3b2978ce1826f23347f59dd90136470bcbab353a8ca8a43daf9aaa72a9f590645d2c81bb7f31972bc510adffda93d48d612fc23f903534ab6f2791005c98c9e00e4d6e688412e395ffb8699f16cc87de00394f0d98d98900e3b94113f0a5661f04ae89218e8874df122464ab32d56d567b709b3675645e7ed7c5530180aa85b52409f69d3bbb8960c574288221d80708385b05153bbd800d428b62735a21965c99950bc839bf064c10fef34de91af94a1b7db21c9cc43a821fb5db1a3de0e06abe34e8cd888a6380c79b9dc5ab2e62f45fcf11cecb6b2f53f81184a41f0bc7634d1001f1d1121893a645018af35656a12a06c54179f18cd3745b5ae92abb1cd6a7347bd4bd4eec2918e6776470d1d7e4e5ad8a9a0c0f03de706a94d137b384fa5f9c4ae050f067ecec715eb67d84ffaebd79f3f15ee5d99f0e4d15859f500633024225f551d0f30e4a57630f9909fdaffe2ed286053f86795641293e6f976eb470831a7d385c06940466e9675291db25f2cc72f20a8aca84e925e3feb83a7aecb9a69d865c42b580b3f9b0723c5812d06263bb7687a568d742d3e3b8266a3c9423169e39f809e92ce3255ba4f38737d6730e92d7a24a6c89556f6a2ff5ccf0e085b8afbeda292a45d9f59d7f2de0cca9e9d2eab8afcd4d07f25f276df152d055fe57d9f3edda47820f65cd350311692a9e5fc457d88d97c1212b40a368efa7c1a8a68dddb5eb58877c290474b1cb46eb55ff4fa54b9ba353323983cda3ac0d28d118be43d0078589732f33e61594dfeff0df8c7e64e3f34d56f6b0c624d9ecfcdb57e1ecebeb04b5df6c0f7e66c54004580a4e620a25ac9b6eaa670bb8590c3487a06355a0cc6b502bef352ee2be2a752a86491498e3355ad9fc02483b85441e7b756c8e121f1a29a3609bcd9db122953cdeeb9df8c92bf080754e0bcdfd4554cc2ebd31fdc85c52e1ec0dc4698968a0730525264a3b4779b3ef0541b4c74fa78bc9e10cc5b0d7d4d6f72d4f4b7f6197bcbf5a227a91e2fde5e70d3d4569a3192fce221cb8c1149871d0dde1f03ac134d789943487fa400d098b087cedb1a54165e533070e0d58a074f0c35b72115c24d854367af6584aba9d5a5362e9043d16adcaa14801b1baea2bcb9bdec61fba57efc0f15f6e1276851cba235f5f49aaae8a24cc47826e9e2fa86108f04b7fdee90a5773c4af47594fbf39772d86603b5815cb512d1f5f5109da2a40c5df45ccb81275710ce221ff660c1f8fb276d11ef638a6d024bd74f9fd26cba08685f083d2c24238fbc64f0386c6fef3cc93e424c1ca02734c194477594ea6c7ea709864fce9d5c45bb134b365d35bea21cc2e2c450fcf00be38d20973a0e4ea9390ee53b9cfcbff9f476182cb2e3000b3a28c0a6a82c3e8913f976af5c5a31f15fcdd7a0e159653c697bbdf68baaf26e220b88568d704045714fe269044fbf775b5c7e7db61f6708a22bdde96433f9685f9a204409ab6443de5522a1db65570faa848866b9f83384282df3599a9c32bbee6fa5fbd3a2b06f2d91b02e3bd09824b64d48cc762d3fa9013c8edb2c1d1be4e2facd2f9c96b3f3f08fedbac4a3086e8679efbabf1e9cdfa54a03edae36610e1833d3344c0d82edfc35daa846ce87182bc2cb3b3c64f627db462bea6db162ab3e5a63d16e7570bfaf91ca605f0c0d71140b8da1b76fc22983be6c3d08afee9c77f17975b055e5101276550ca6e834385a5dc99d81c2535210c05d12fa9e12cad2a1ac203682aed5e5407a3b7986d86e36ef9a0402a850a72fb51d7bc1394a7ed68d294ea78395946bbf5128118240bcff60729229fa905c6c0a53a32358b9bcb83c19e7b1b6cc06f02f0dcaa8ece5788057172e001a751cab983b7733950cc4150cd766c9bc558a9be5812dbb615a003eb2da667b9798d4e1d712249eacb77b064e7398b36db7ca2beb9498ea44d7359a37cbe40f534a4dc80919a44dbe23f76106c83b06e8d9bafe7d5e2ad9ba6a44354f6336f7f94257dcc947f462c0868a1732ddf557f08584184ab57b71f57ef8cceda5f1b13c61d63c7083e7c735e5532e690846360fa054134d228ed65acf198b331e93fdfe805be291978248048f694f22ef723d3874a6c8c5104f77b60950854e24c25812ab9011166266e863988fb5f54889524ca4118a8e68a7a700346dca1cb46cc6d7a75db7a0e95c193eb74bab99b54b18c96b6964b770bebb8731026894e2c104bb321458fe7c204d798de930d2276b3ab2de53d3129dee82877317ea6e0a9101a38ede5d795011ef77edb6fd8a63e99b164435ccf5108561db739a0e4d945ddbf32cdd724edebc2aa9d467361dd4ad5ef149e96557137a3d91fe13e8abbc53679ec77399c5a296dbfe6b43231f3482e4762da23503e23c50645c1e75b47ab90e990620d34c4387deaa44effbc1fdbecaf5f27c4dbc0f8e9de01dac3d846f1df306245e54ef19773ae413e85b7512e6e13aff0b6f730bfe427d36aea8d168531fca55b6007746636d861905c76fd574148372bf00fc57eab482f0515341b19dc0ff3896fb2fd8be5c9dacafa98cdddfbaa9fb581216bba921a62ac0b1a14aa2b52dce2a4a1d20fff0f94dc0fb36bf199e3ec145d89e46524a43cc88c15b32121df856e635c34dc23049c63b881cc11a75e4a05f4bf4e08dbbbf7731d57954d6b1d5252059c3d8f6b997e2040198f860d34fa3d83d9b88f0a37d2046b64a52f696c4be9596f702926216bdb1d4497635a408128322ff0bccff8286c155636f586ec5379607b13adaec1c92ed0645cebfd65ed74fef9eea005fa9c0f0af37c85e7c7c3cc33abdb47e3187515fa43c9623ab339ce247a880b768dad8043ce4bdf686d0b71247165e53b827d85ae7af6479c9a8429cc117e201c516866285931690fb0b1d8b7e1d273f41152d2825e3500eda4edc7d09e2dd14a1dbc80596e981fd6a1fdb14b5a63807bd52ad22b30e908d30ab222a537999d424da587b3dd879ec2185e4eea7f541735e10195cb043ead2554e38c47972f0bfdcdc47068185de80d4859e96079374e1cd172bef59caa050e17b5f847031ddf9e3abca2d5d5b55303890d702af95f6d3d06a47840031ae9f78d93ffaca6b72253c736c89121dabc25ab9217fbbd91f55a38dfc4b1f7c05a0e4f20e15364cdbe72deffd233befc4f2a60cd335622d64c42366dd15cf0da7bf128e73896f51fc82583fea9f27a99750bba70679c6c1787b5d19a018d512a499f64069735f672835fd0c44da23ffbf241d27cd682b17f5418076776ac955c83d2ece86fd34ec9d2defa77abd83d8e931ee86412391a996b564c9f06cf92ea483360892c2a7a8475cdb82ab203ee8081136a8d015d5c53569743112e8ff0c379a0b437803b72b9568c3894975f7c8871971d453ecabdc785a9f312e50f623bd7d9f323c3f717306988aaf3cd29a93c0b0bda6cc5d6807991d0534031b2c6c21ccdec76dc0f1d6f53632435b1e02255ef004a192bb900ed78629ec60a7dac9dc217b0781241da92c3fd196e766dbb83d05297b3f4b8e2d5441b20185d581aec485f07140bf7a74fb2f234ab280956d48acd9b58892ffacd1f6e4413278e2cd474f26c264b1703bd4d8f8e4efb074fcb1fb97b17e5d883e7310021d3025fff2a549f897f7ff80ea5abb3bc6840a01738ff8a97f2669253d61cd5474037838075e8859fa00270d80613e96d1935ab94bd2629675fc9c1984d6346fbacbed3ab1c3c0a3826aa2f55f7809f535ace811e9d07ee2008131141786e992dd6656771fd845287566edd9eb5c167f7e5da23da7f724415b2033cfb18364a6b70884b0df40600b18e96fc30823c4325d571b4e8431d381ff606c5b237bd4b3c4417712981171ae9b6ae427338af978ffc3ae1b40d7de838874ca451bacd34796c82806c7464a156cd65ccf7eeb20622c7fe54ab56791bfd70da5e6c22063858c854444cd74a6d9fffb8d48e03ee03a7b0c205e8c96745ace3e07d9d0dbef8330361ea02d8163c5d150a4313f32dbde2c991472dc80ea211f7f0c8053e0cd7013867ac0c17be20ac3d70deb19f69aed99caae29331bf576ef84c7be2b693533510a9bd28ad1dfbe81055f8a34a2ced5f0e89aee0324a887fb0dde8f61995b60e0896327967b76082ffe43a31b002710355bd2d988458ce9a71c4d46b3f0a45c5c7185fb2bc7eec5aee46f1e6318c8c3079e0d218b12f63b87f96cfa2f40c934f6d8108356c5c1f2620852cb453b430f1dd99cddfe8dd1ec5e71f8bb8edb6be018760243123da96c7f6c914f50957069af85308deeb21c70c49b6d291cb67a1d1e2ed1a1f1d117077af7ea40de20e4a71d43c02592d9d144f94c86d5c8d89a6e04bca8b004d5498e8100a089d19399978a44f379497fd736c9e6af04aa7cfe0fe32b4f2974bef10b724353ce60a925048058d50bebe11047280a4c77417cb13403be256adb41e19240c9d950e861236372174ce0a09f2c8583dfebd77f3850455361fe1021d311429ad20d94ee597609c09f64ade79b11d613b5229d2b250337d585d4664f8260e5438799c34e9702f9d7ed73d2a9c6bee63d9d0858b6be0cd91b61ca35928d50b4e5c9a76e245c58305ac788e9ccf414f51e3153f4280fd103b8e2e99e152feeaa8d604a7eb00b4982f06d6fa9367285ce5ffc3b4ae585ea6471b33d2df5935b4da503c02b89c0074ab3217d0ca277afde2eadccd1168a8c479029978c299729d00d1c18ce0e91f2cd57bd75c2377f186581af7bb92c4755ce4d2062988064ca043c07100423cb4a3727585ea62a56fd0adc66e82707ea2bb8cf2dec420e78e1682baa516548ddcb808670d6735f81921e3640a68ff73348d6cec88f47b7c0881e4187f099a9447aae43c23eee753bade5c79e82937d7d49c9c4330f755c9b26da85c36d6ceb00864cbf9b6d2ad0623068960a7412ff689a9122de5d6cb5df0591d546bae95268928041b9e2e3d199c517bec0d4edb3e21f3e27943f0a29a56bee7103536f404f71346b2f61a36f82eb80d513e7aa780c1fe3cf58cb1accf7ac5eb0ec0d3b5cb0afcbc665a0304a6b9c567b432050402f2bbc19f2b6baffb0468aaccff2770d83a2dd874a3728b9ff3d4153a56c5518144195c70e21a05a83d9e94a1e9bd9fc32d43655106a7e972d55d480ac55f75bb55e1601c0361fc2b9df27538658bbaf6d1929cfe096d93f86e9af6dee9e08cf9b67d5f38ce7b8f0878a4debabc19fbc01f1fa74bc5ef7428c2883d42858e9ef0d320e311df7a57df5e17b6a43b97659413d7fda00f31ea46170e3b6b28d963e02252fc1553d36dcb6c3faab8dae881509a31ad87e5cda9d10fc99dab18025ee481288ea521032288bd6cfd1deb89aa7e4dfa82ddedc82ac121c4c9695f01c2704b894a6ad9667845e91cae108515c495356b12178119d534a82d0afa3c31f1444481ea45fb2e057fe2d951bf43926f2095c06bfa678fcc4f04dddd8468d781b2006c2bcd69eed62655fc4759a250cb5fe6b3dd32b6fcba5fe1ad7abf5aac54e7a10a4f7d0819b570964fb23e2e18fd1c38a44e0648e9abc9883184461ef6de75fd047f3e83b42a9fb1262c498509e36273d8c005f5301571ff86d6149b6f75e46aa977e78e00b0165b4c938d90b9aaa482678230c36115a56a0001c1b06d8b65b958f6bf7d5d75f9303117e5f16c4d1940b0a4e72c947f986d9cdfc5ffa15221fcde251776839ef8d02016c2a380c5a76249eef40ea36bc0161791e2315fa759dc4b9fd9fe5eaf016a5f4ac7d301b8a7895a79681bca8442843dbef701c3ca8923ad122151f5a2eb307b69ba11d64a3cccbfdec72ef483795dba2c37632d09530142e6251556095217ec5e342bb2329bdf8ad524966b645795299610b4b79c33e34a8e06b98c6d9849ce124a906a117e076c21f9aa2fb56b3c591a269806f9e7b24d079b82796c29fec4dde22c9b94e5f7f010e29d8c66e5fa87e9b536a20a68599b682114cf52ff84afd22a65762bb1450e3ad67930462e10b58a6a952215c271a6a68422b2612c0241c61fd0d7a16b2941be36644ef4718c514c8f47b4aa694ca6400d8181f877e719010c1113eec88274a65c44a3db3e74b67e4877eab10a3580dd41c3dff93930cddcb9c6b0f8eb273584bf6c183576247e57c8440f9f41c088add65bc4e030c072ffc4717a440100c3068740bc5da5314e3410e2e46122b210711074384e4a32479d399499e2dde75c489e11e3e6971cfd799460e27584e861d53aa6c2fa551d2420112076f41fe573571aa3ac4333099e6cb1568e51fef8e6df3e23d555887060096157bc3e24f54f4964a9a02573cbfec3f5665aca48b0eca9e600efd973abe8547aea5eecaec83aab73a600189c1ca7606fde915cde2352a4cda66338804af0653c36079bc4ac5279c3cffcaeefe740bdf2e8ef96f54d95dbcc3732d51dd5858f9941be78402d969b65b29c83c8ee8cb3dfa97018384666a3d3677740f0b5ceff92d429784d33ceb55e7444d140fba6fc95b397cb264b8417f2e258e2013d430e01564b7d108f5a4c720a9ade5ee05eb63319459e5ce898e096899c058073eaeaf119e07e037ceaaad2369b7d2048415c569b26c0295e1b1eab0b5a8daa4590799e92f4e3935a0df64bfb40c618acd135a51a78164d9d2b819281578c3e5646aa0a15ef4b43b27fd3145fad2574b32b65eac06112048fdacb6c2c9fc898ba6a5d1d5d4814de7a96b125ce7cdfb2409a6887f4608d0f95d69e60b2489f611a682eb658099d7900be5f97c4ebeebe4a7bd9b700e7a01e2ee1ee2b1d635ab5320a14cdfd1b0f9a4ba9744084ed1612dde8a8560279c2a07a7b62eecf4e4f335e86f98ac66b7930ef119be12e88fd34f90928ce3437639791e41393020c91ced33997ac3649231af694c015a3dbff9036bf58972b3e8c672ff8a43c19b92650970c13bcbce18e04941d1d853683dcf4c358eb70de39d1455ebf8caaed601742b1880944295d3867c6c4c0f94e15bf98347737cb18ba471e4afc16dfccace44548d469ebc329e6248120f6cc4514b535a99c13e4604714c163333a5a111a8fe23f58a1c9dae8f35d52991e95a97befa9652f9f4abd222f5e941f1a42806f2d5f2b65d9074fbb69023a5e0574c940982eb25f8dc63eecfe97db6cd66458f7a60fdff6ed75e39e12bc146b37b13a9b6d823a62e01142537ccc2d9ee1e215f0f2fdb8cadf55c841f2e205118de9c42ee10b4466053b642bdfc8cc95cab4228fccc359844b409809ffe8ab3317a65fecba92172347f2841bbe5ee1b58918469c5679dc67b7aac349b5e7584c75315b6f09ce34b0c0bb619e47a67b029fd46e30c7412a471125db7b8178c85e79b82ac3599ddedaec8676b9abe98c95b5ed2e7994ce8bc09137382b007b73c2b39ab40a42ba892aa6356f0cbe4723b9ffbfaa91be5ba9af4d6b615d32848866ba47cb9bbd3fb692eaf909b0236f819814030d6fdd1cc255659b7ff54032b289704bc2228e8d1368bc02437293a333db8753e1ff2679ff4347a49a038939c00a4b7d1c7f607b08ac62eca123d8628512a873284ba0f144b5a3d7f5bd51ecf459b304d1e1904ae0a2ceae1aed89510f824e2c759a2d79f30250c2ba631beee4b9acc19e4a125be77563a986c725511e8c9e788d0cc0eae338efb2465c6b8e09dd629033b59a4e71a39e9b45b8a1dab9785bd60dd905ae9101dbd120e2f7453af52938f4783818796c23a2e59c6fcfffe2ca78656f73339f3cadd4b09d515721791076b654308ee8e19b6189fdf41c9198a257ea3297dc02d682d1f8af8416a1bec99b8eee1a896b119321c3dbc931d1c593530bd97004afae6604fa526be5d1cbdee055d7012e1f2ef70b8578e351d1a0a427a3fddfadde26f3a6ac53aee2c3b7c21007f07de814023772749ce9f2f61374edc64e564c1fd0967acf776fa411329c3016d5b19e91b5799eaeb5638322a322025ef6d09ba6f7cef3746e01c3b502991bb376d09434a4333f930a0cc6b59bbf476a2c1f59163de60beaf666bd55ebd5873ca840215f184667ee06a4ff5951be3011d75734dd90292555eadbdba385eca16eb19bc86dc3d5ef849c8415a0ef183f85f533c697cbc6d1a20ca53a46fd3125eaae540c79640b6e74b351ab18c5955f1110eb3699c2bb6fe0a4883105bcf9a9c8f96d9db3e4f890d4d83e3aff0e57ccd7c42c5a68429ba9aa95e037db475fb1c0cb73d2485b79c8b741a135ed2c09b271c6446ca9e7ad352e246fa7b9eb755c90cb1df269fb16707e966d0ec25015e49188e86e882c0d6ea237e042dd925b656645c5af07f786fa5eab4d1c6cae92e4ad865367f2220b7405eb42424061fd279d5e2c24e9e54544e4dc9a1c0217edc0456b16a0b297a1bab6cdccb817147de7c6da8d1f366ad970737bd8c6624905cf69582f0cc49979731b05de7123e27affd56662fd90b818fabd4a9e62890b328c9d3b61f9f73ddec0bf7c09164f15ae55b9ec4263d2852d58d9cf8cbcc550fce3d4dac1826fc4ee69581d7fb43771b23ef49fa9b48789a6a669eeb5ab083f17c2d350e7cd33a0affc0d033f9a28da8b97a8523205cda14a3357e76cbb61b0c5b9c54ca5a494c84b1f8144458e505105658392f47b62e16119e6369afb4441bb0864a8b7665328da9968121f2eb5f63a1bf14e6458859978c28f8683a9db4c5356181eb085503cf12ea76639e861f0b8e5ce61d673240915d51f319cac186f38a70ed6eda6ed43788e7adcf98ef65bf12bbaa1f9b9965e165734b3889ea7b8e695afad9a12148a0ad06a139d49964a0b76f51ba11e54dcb035e961fea56bb4e902708d1ca11415d7d3e21d49b66725fee5dbc98c165d7c07541216aecbaa8230de39035d15401a1b9a84a9286426dbf3c3bb5868d6c324bfd1137809446f366","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
