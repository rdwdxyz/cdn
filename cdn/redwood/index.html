<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b553e2005733a51c0df94ed74b57a68475d10cafd527a89f36b4576f6bf17074cc3f36eb978fba2c428e4acb2066dae3122b4821e6223302177e7bfee95613cf7eb9dee81106313100eefc6929d795a273cc9af83ff7dd966127554ca95dc21cf4715eac8d9095dafc01bdcc57611677f7777725dadb42b42e7962900bad81996b94c1eb7136885212b929f1d2e0422b17c041b9fecb74c0cf5da0160ad2f41959bb34066f9547dc2d648396a2798dd7841f2aa56663bab3571c203c4013518e9d4aa9af7a8e32630c57cdbaf6454ca6c4b0e313072da456bbfd914348271665e2efaef993a3db59f6fcaffe019f93107a2e34b0502a56b2c89c514ef70326e3f39c607983cebe1a12206b42ff129216e715114849343df1ebc5951e730c7ffdd6a72a45950546f79c54c0e49d11bab96ed564b7f6fa84c09af95365d033158f2f966decbc900fbee8c42a2a3c0e7698dc76170b71c830035bbb77663d8b2c0430696ec6e3a5de270b522625fbd88aed4082bfa6d32f034c846f2d76e0ecf99d26db2be1e7d630777048de9180c6ef78eb9579d04cf467e93c6cc962ce07e0099a1a957e02c43cb71d4b819979cf86708b15ea59a4027a45733f1d068aeeb0d438eb1c885bd5f5ae207b886f23215a79c33757ade13c5f96a511a38d941a831882148a73cbaa5d569ef4ae1e13d0f79264f68456ef27c1c77ce122b27a085adeb030f501f7603e7590f5cf4f4e03ba1eadaff7f70d7cd1d8d101744bb9840f6f7f78bcb8b53b74f125942f5d7615f16bf1bb15e63db56d4ea539d09cfc198169eae614dbc3945c889a210419c5f22e2f6f292d476f538e01412de08f9205bbd80abe46a84a0cbc9ef39a0c563a61c1bba47923f64d2599b4c35073f64dd56ca6ca560013b167c583bb107ba9e292f5503516d6b91a1d7e7fe4ddc919d88cbff52229396f187290db7511cb24bfb2ff73e3e3f99768a49c34661576470f0cd50d96584548f110f1ad476316626ccc94c43e45415b7c65a1c7fe047412fc2583d28d9eb2465c2f21c316e4d06b213cd0efefe193c6fc870f949f3892f3681a135e8aed61d95c27d284f186163850fb41131c6d26a6181301d3968d4a25707b23a43086c4490ae333d36c694e68e38d436e66ca6a941a1979bc33dc91dc6f202aa3431f93678b72643c473e3d98d0e88dd78b3e3a9e97dc821eb924c7e91767cadf2261b5ca6550e407e955d0dad129a1610115b6a6daa324c0f9592abdb57aaae9cd35e81c38864a930036d158f74ada8497f85cc3c35167f3a12ecb5ef3eb440befd44f86434f3a263f37e0f47f4635305e24549993c7db6abbb0a01660c0492816bc299b9a13e3e343afcb217bc4e8d087464c78bdf5a2e79328b8a32c47d13006048338967c64ca464543e862e5cf54c55f02d0055a3c93c2a06d719dc373bacb4bf7ef1dbbfe9b1b582f6dad82b86818dcbc73dd443578227cc3b1de48469bf914c07333433dc167d1d5088c627364d302a891f156f2cb17f5bfa3edc77cacb3e222e91dd7c1360fafc1cbe1cb7adec2d2f7caa1c52e87f26c7204f1d7792977ab97bab8cf2bb6b5d188c97d1919d64ea48e296b83a0b05880aaf83237c36deecb2e6ef4254109191e5ef30fab2926982fd0576002d00f23a011efe7249836bedc3eebbe475ce853466a949c5b8819b587f85db4dba13fd7ace204af65a0ead2f0215dd5b6237ba3c0c3f5e78cb0602ce8c08d66319ac2f1de488ceaa885716d30417f9c77fee58bf4e5bb82985d651e00869b4e2c979098a448e3d74edb81a5f17b847e2a4b2073f2c9780c9e9ba5c3ada5afd1f7564b2c5de55018a72d798c9fcbb8cba1df0b117dea8963832108fa4aaebe0f30953d2be7646ae2f821666e6b143f6beb8618000b4e1813f9c920bbd7ff666ac83d1f9ec715e1ae9a6919785bc0c08fb6e37b5170a7f9c356d5fde9d6a732aac1ee5ac590c34fbfbc5663c58f3ab5d18cc80f9c24572f6a84804af0b29d9fb4b6b51a48e07bf18d5ba390e6bda402cda947bc16bc30c6ba226dd7dbb5411e24992f92518a982541b9d0f59852221bab997d2c95c8a3844bcc494dc22300aef43b8732acb1be38ae28f805bb3153e52de555a0a2edd481b0f4b6b10096a410c9d97da0065cd33335fe00773554b807e9d6d4633b6d12e58628790588683ce5b446109b7dbea1bc7cd6d8e63d7f0667c19134aee95a621a65a14667d2a6e58bb7047459fd9a9e46c64c45d14795d24135e4f0bdd0c94b7aa44917fffd53a4c251d729e4549e21ddb82c3bbd3b7ab2d6bc5cedbbac79c3b304dd780145f88d4a03137e43a1a71aee58b376b9dc9be4277524122ad9683bf637df289d91364bbc90c37c2fdb2aa07782e783d724a11f9d10203457acf63b6ad25f9aafab873e43971e1bf3152898c7d2f355781b863251c1caf93e7937cd80e95bc33622a51bfa213447bf08c4d33073996c5d35b3e0a27c774f766a40d7070692372d77c3af85835e4d0243c1ba9995f1dc75ed1cff586c9d246b963a59b0e3fe0a91a6f7c09ae140f37cadf7d905c17de887a9aa3c119235c95953f5a2838128cb466957386108b4724ab7ee997e7be51530c24643a474c559cc5f997012f0159d38f30a11e9e8aa5a8faf1849a0e2403f7db1e79c000b1645a5c80c3dc1548eaffab0f9cb3f6890cb7649848915c0c910ea9d87b199e11dbe59d3f06ec648201968dc0de117e38c34968d5a6605fd74e1dee325ebf03ffcc664fe647e1736907ae5dc69e79995230b9a4d8e73a79b681ae43fa049fa27a8ac3f473c4dddb6c534470b4de102e370b6f7163e3d05fa96b5fbd56e810dd959f965d6ad9ee9f53a66ef0061d5a011f33c61f44dd5890a9c41488e800f70b8f470cb9c309ed1130f547e12bf55a05dab717209aae8fd89062a9b24eabf315425447184a7dfbc9f1f8a32c828f86019481478f986e1de9f477d2801beac036cc5a300042201fe668ba8a668bc2c032633f0aab08b976d81365b6874054700635945583dc19de561ad9bc9bb13fa96930e6d83ce572501194311b46ad532012059276d367d9e3182a8f1cd1e5aed17b65a60b3a3717f58451470c6f7ba90627377bb3ae55f4cadb99d81e5a9b4224323f826306036069d84366731bff6ccb46b36f0b6ea3f47aa9efc8a4e69371963732a0d38525f8e5e5d0a4d8c444aba20ee6c6021d010f02cf5b80ee81ed6ae1f1e30dd606cd63a303ecd0a456b68f80c5bca54f3c066fb2a7ed0973c10c93e708c7354f74ff271c233a0a695fdd9886e35025666dad50739b8631a055aa6f1bd354c039cd4827c52635df998d76efe6adc5371278ab8e1532cd27dbe0ae015733647d914beddd61cb0aad0a8409cbe1f77dd75150488a9f93daacdaf03f6fcba9caa1c8f9a456cfeb0eb3d73bf8da2fe7c156ac2a4255ac22b41ee1835f2d0ba3c5c2f72325094b17f54278d7e616e0090d29df7188d2966fa4ba329f80d85e58ff837637c5f78aee4bc44a1486632ef33de41fac260f3fb4e5ac1e918bc8a73fd4016147d62ded01606a032178b26f7bdaa6d57f2477d7394e42af7afe1b087dcd5bcabb3bb0f8e11d8a7fb341e7aceea9cf79368b3463bf4e68e4e48143664e8fa24336bd86970dd8327ab44b3b0f3a2172a3c65ec8deb365568ad1e25456787afa90fe0cf8af47c2760cea7e865bdc6b6a3454b8e4a717ec9d52cc123228361169f3ffdfcd738bec4ec39d384ca4dd3df8833a6e3a04a7def706aac83af736892513b9b86e0ce47a85758c302810d00f536704fa90dadaf29a01b12e83b361cd349bc0a87683ee11602f1b0d2d76b22eab48306dc6805f474cc120bf21b7e4e5111d6e994b9d4628c866eddaf7df3a05e078559d49c232d8bc0d5ce7b4a089c318a7715dbef28efdd7445bfa5e8fb2d2ef0668696f934efa1b428033ea8d1c78cce1270a799bb87a213a920dc63eca0925e9f18fa25ff1c820646bdb41a4b7fa5586f13931951a5a2917eb7eda4c2535c6ba4166cd8a446bf82fa5428f25870aebce6e397eda75fcfbb700679fd89b12e6f047890dfeed85c0b1d7d406c7a577dcd13de32ad92ee563662731fdbc24b64658042719dcdb6e83a13d65ff46f94cfa426b3c791bfb402c24f37254bf3485cbcfb9562cda402e81d11fdc1ecfdc16c37ab445fc44ca99c5d084ba7cdf2d811a2edf79982ffaca954b1c8c46dccf9b5556874b1562a93a7283e1fa328d471aae13ca934bbbeb595856666f810b7534cfdf89ad38fabf1c8fdd6cefc4329ce9a4e61771ec7c31530f51a33801fce918c95dc86291450ed8895466bd357c2316a4cddbfaf57ae8d40575ca60f5d3709c3586aff4a1bda3131b40bdf1dbee3541b628c91b96902bb2ee436350ec49785e82e9f647f077f848357751624b574c1f27bdc03f802ca927efca88397dd395b304e6a87162b7a7ff429471e506da7b5b70ca5bf310abba530182e990380b37ebad25d83890a8759d5c58904ea5e42a40a88acd94704341d4434ada93d9006b25f131f1d2a302d0eebdbbd306d061d5741b7cac9923ea0b1ff0fb58d95e71c07cde79f32809baf2b7c7ca86de28779c1aad074bc8646ba251838f8b72f08f259222f1f6939be5cc97a9e2bd566f421b1e3b260a332e4f926040c3e67b0e60b737fbe2c2811b4f4d3ca6e9c136058ab87fd6f1128d7cf10e9efc05c1f4a2fa4bfab404f75ba5c92f2b64a86082c93ca4e798e965895b8e365e96732859bc58b7c09e8601061c470c3250c3a739c1d26cf944feb191dc882f2845145f3746525d48a051bc2f35d86307e948dd99d94d5a9500d85a3c5b2abc142778eb349d0af8330e1b02f50ee5987f9b912f2079b730d8df1a3b3b089eecb0db9d0f09e7eda3c16e62e626a244c9046709932a25fc75bfafb6c29df0443900bd4f3fc7f808681fac3f6102898d447e414bf55cb7788009516cdb28e195ff394e39f0b6706a8a0a34deb1ac9ed48f796e8ac4dc7b9dc4276abe1e1170664ba5fb8a333cf48817083874c393314ea5f4b3f882335ab7525773322788f97d3c6e2f9cbc5f7c5e86276ffb627d956ba7e9ece9c7dcc68dcdc0ec157c7d94925f620feafa9c32de549396016f7481446bafadd2fb5e3833d90e4c7563356cca3e37763787f895c9311c599efa54453c5240934c9be9cee709229cde440ac91e6fbbe624dfcf06d289183563faf419a9acc4a6182d9529b474d584b5cdd352c5e597d9096a903c44e9955000315d950f3b5efa6b857f2af7d8c08fbfb6c9c9747626494094133c5729122264894da6c8e32b639b3eccf485c5d876f9bd467af1bc636cd0de3f17a6e31a72c14971e23b7fcf6ac70d7c2dd799f2a8a1523ab2077d49c74c2be8e7e55a4174ae19545a459759e8e01493fc70bcba09d2b77e3b2ef005a494d58c5143f1d444e847a31bfc559b8268614cd853a6e0022eae9ee7474ea49c22ad6ab18b2297fe409f23b4529158d4ef2a2621fde1efacc8057c61aaee111267053503c9b397b4da9425ce997b315f825936464d07237a04d674e824814f632ca94d1854edf0265a189631c214267edb0c013a84db4082b96738b18d50fcaabafee3d2a2038c2da6b1a42aae8d4b5e69ebeaf5932f9afcb9a1100d05c39b18a5438bed445815968c573086dff7ccc1b4dbc41e887b6a492083d6149d0203d7f082fb9f637fc17064baccafcbfb9366f7e95c61eb2935cb447e38eb736e64505c368ff14e047fbba8fb9f233b234c256d9d5063d8564a1bba58e7e409e45d2ef01138cd1250d52955a0651bfcc54ad6382092986030791dd9edf6feb116441c2ccbd08f6d696a7c7563e82719d5062c0b6c903288c023b63ba659b3d5081209dbaa53f6fc25603b55bec7564d5337bba56b14aad839d50a4bc974c391e5b01b2c81aafa2f5993d463a9248259f47ff2a05c890bccde096258f5fe12cf11cc1e6a3eb1115fd73f24ea3d0edf162f597548bdece9ad3d60b21e13f5401085cb78f12a576af304947c8f77591f69d7904d1dea94804d71d0b7360e1655070f7d09b7a00d867baf9ab22a0b2bb3186d981fa27f17cfa528ddf7d3ead3d5d189b9481d642fcc2045e53047d9d55d47ef90a4c7c2c71424491b4b7988d33c5edcfc344f0f7dae602e1065a82dbbb097d2e0570461d3ca662ccde3ead0f01babe895a1ddf7e60baf89ac0040acd368817d86dd3471ad4e03ca0f8b49dde470fd76dc06b8dcdffc840ee9af20bcf2a8d5d86a9daad96bfc192d99e1e8a5cff0044ddba523769c87155b3599412888991fad4d60d891cacd980d23f80536968aa0144aeaf6c4681bfd74f869b26468bfdbc23418d91b840299450278f2b0c357aa12dcf827220486ee298b62b820678618d0483985c4db531102ac2e0f6c0a41b5a47a666ad7bd3a5fb2f0ca477b23765d150d615df3358a796479cba99076235577bd437126cceb15a743c5413511e7557532419f16cebe3689bad27379b581d41b1b212dd8d5199e69d60cfce8cfa29e25d8f387326d530531151e7a2c87da9428ad38df54ab4cdb5ae43ca551cac513b78085bc728a18aeca390fdef3c7e35db90145186dcab4116b8a6ddf60cae787d28e09cd13261ff09ed6e42726d8d3995af8636941a1da9a487560eef7047a005ee1cbdb6e59b0c6345d71a8daf193fee43a8dc09bbf11420a697a00c1aa9886bc5d31ffb0da6b4d153d2e69ab9a8823edcdcc6ee3572c9c790e1cbc5251363957ee7ec7abeecbf58e3f201148e20a3a164be230612d1a26eb3ca657233c9148d4ec4a13f3b124a76b6a5730a4acaf23e8c525c0b705e09baf211056b0bb31e880f5f221bbc137c2e29cd977c1a3b1ef50444e5c371b11e7617af7c38b1f136115902bf75dbd03f7bd529ecad2526280703e0b38b4422e782fb380a15ca6043d3ba3d87f5556f526068de79d81bf828d1b6b237422e4c6727d4d497cccb19a2b649c362a5657e008dab6d603593dd1508e4c292b00038443e9f9dfecc76a35173c5b04ad5cea00bb1e0cab22f928ec438061ab1f2f983b7400b75b6581639bf6f65762fb885c0872eb9a481a76642e250f0f34e29b72d0b2b15ba63778b979a7ad5140ef3776404bec41485f12916c9eed75dd76c8dbb0ec5a7cea279a80ab73d96cc93d2a2b5673b2fb43779d37dcc3b33b49824549f2a98a67d198a4e7134b79129c6d081948be836ba52f9689ae8210ad89912aeaaa4b55f840d7c3fac675f20d3d55ac67c8d2397e5ff021fde3893652a44ee974324871c10f1b36d47827b272088d39b8d3e9fd3c8c5c5bfd7136cc0a058287117bd416f47fa94d988e7b1e31fd24e0422b72c8cfd2f59559de5f552fbcba691dec2fca4e8b7d5a4fd6eb82eef581fdcdb6a4959a06a255db924047bed9702ac921ae4ca3e9b5acc1cde015e13814637aa3b94d5a0a921adace48c2d5f2592411c2783c15cc486e1b581d56707bb26bb5886a1917d5c6633a939b8d1c9fa2449f26fa81df8f7dd63fbb6b6d8b8c9b4d0283b24d071013b74aa360ba527187ebfecf1c1e716e3947f963db5b65474508f49c920fc92e0393be0518480bfd66c612f83eb81861a99e2118d0348e881f729e0731b56f74e539fa339e7323fe962de98756e6192f5f2347214c00c9627195a1266b3ed8c331aa2df4186f417d81427083d4aa2a571109b2d86ff9b55cfd566f0225e2f3c398bb148ef05bd74b8b511c45a2f8a4c66abe62232a278159b2993131bce3df35be76cabb78ca6463e2f6497c10a413d9c08bb5dce746babf076b7c0b61008fcf3ca77e82ff21c595d41e19e652f57d094f040151095c768cb8c3a19f2eb9bd43d9903ac17ba4e9a0733806f967e2b986f72886212cd7a2f217fe05de928a5e3a3db192824871024737795698cc692f3fd5abc78d9f993751a8717a7d893e7e70d5bd9e67bc97256ba865844b111bace7a4f7bf83db7f8d5e29dca9c8bf183896b2838c22e71bb9bfd2caffdf276c4d119db769265a7a4e906309b2649327725bca31217eaa5f170768fa0793e0055aac82cb23e214236cf75173dceefe5eafddee28eef1fc06447278c58dcbf2f0be8a679fe5081124296c50468048d345b3118b262f6eed3df57159b4fc29e35771684113010d195b754e34ee686fdbf1910e914ff6009ed71a72ae27160bd5590ec6ab9ea1c4acf623afee5251615fdf3957db33d016fe5840b93a7872d0b4ed6ad80193e7865b3ccdec41fbe6b42528270c22dfa90992ce84f2c21362560d279e5a5ef9d4ac9c7f18cdfe36eede4f3f8ab17eaf1a1cea461695ebf9cda2202a05b7bcda84ccfbe4089e2b47b359f95590beeb5f16d57ba10182c8bb9df5b0768d9f177a2fae65e682df2e6ba70b67df3285e85a8b4b9321977a131287a1cbac097331a905eb98e7c3562c523b5318d9d17fb4622a6e4340b3d5ed8080a9af1e29dd62bbd7d8ee7e6645b97bcda8b7513156cf6702b00b51ea4e5b2628cc91ed14212a1d023a60a495d1171e75dc9324240cec8d0de1f2e73192727c1cb1f9a9aaf1f9e25c31b3bd4c4e5ed3c81231afb124c4bb2bc33cd50c905a61ca489cd402b5e4932b0a928bcd33ef2d837cac479f2af2fd9cae36b3b6116d94e08125af1188a9d85459d49834b62debfc8159aedb106a479de6b6be922b91c7f6484e119e87e3b8a75b3dde2a327334bb88d42d86a5a1b26da1a1878f443a51574a6eb64136350da8d28c49ae00ec93ad9fdcc3afbbc73d0912e2d2ed452c0a33531eaaefde84d9631d477ef862a203b9480b66efa0718acc58054e2b286f20ef1e9670e880ac344bb98d07529dc65452ca4cbf14a0e7e4bcc66ded320020dfffa8f8d4c6eefe74243c8db220f2f4bc0e836353f44a71358c9707fd714b9f8cf837b21a8fafdef583d39a6439281aff00ec320400fcfbb08579c37a0e4da76e518243e97aeb2619e64d6c276082f42fa2ed66f5ac06060fe7ef15463c67bbe0363f77e09a75d2cac408332d4997ab5e7db1b9e9d5f81591e03eb52e46a4c5dbe25353381bf2a65e63f233f1ffdb8cd3dd63a0eb20b1a464b5b23febf84b205d2cd8e526a44a621b1175008898c7aecb6140b533565b28e8205cec950c1108b718e6c6acf2bf9e8aef312a9bcba3a6cae1c3d0eb4cfa833f37e23c1000df000013b86ffd96f5913efbea9690cbaa8eed32d52acaf85266185e16b5b21d34f5345ca2b7edd307e83cfbe3a4c4bb9cec28c4910611034b2837218a8407e68edb8500387756374582dd225037716783dc6702ff79b398f010da8bcce105eba6efd9258e0e66308fb408bc6d79683f3ff5455aa6907989ecd819e2a9f6d1d7551500fa1ceb36097379539e9e39849908e7cfd7ca6316d4a48c350094e1a9c997588d1285f845e047f0ee8b704bedfca259b6908b9b16f1f5a85f188a118eae4683dd55f11426d2fd3c566352f16bb2b9a7eee579f10359a28baa5751f283cdc4e3da875b153f0f85a22b9511520933164553f3e3374c990050f91e8d0ca8cd25e4c7d31958b4e0d05b619e8958bd7b6c473e2a3a6a7770fa9149058f25cb0ec59e2b6bb51643962016fe07e450b43c67ffd0932c177fd8bbecb2292031c5bbf3eeefe97108e3913c2864954c78f5ad9c095683e23f6602bd55048c4765e146ffc03329cdc9cc759ecfe5fd6d5ee001176b72c496ed13589556e2322dd1fda7086e185f10a4dc5d559e8ee0e6277dd7a83d0aa6326c62e1169b59754397c29126f1fecd980d0286075a357b4c6cdb02cd8d1d5c1d3f1dd5e5e1cd7cadcab8495698ac53e65229157bde8eacacd9ed535eb6cec347169a4aec87db48eea2a4011b2b16e22ecdc1461c73f3a5c32330cee34687181616405d40eb79ae5cf6f05ee36969c6c62fdc5ed817bb9c9729792ee1dce51bc16b35b6c7a954c2d91c7dbc34e3b507f6c440fba1a310c17e773a085088f5cae87e49eb4aef171649360d8f5fb4b1a6c82c1c629f87c4e869603f7681529548c0c76b1159204197fe182b27ef606839039c49f3df7f797e7737ba43ba5135a059a04b2fb8baa40e4e5e6758c28c07222c4d7e2c15059ea89070f5eec6531c4e38bd02b0305b44a8eaae89b7a7e0ff71994875e2e06093175927e484c1b518173b422a0e9c13713bc492c7359f1a8fe397c61ca8282f2bdffedc79b3d6e1d16a2e5ca8d15583625b8bc662b8a3ca955c7fe6c28cd64e2a4eae5acf155704da48ce3075d2bb8fa0f5bbda062b19c8fe8bc8de5c7d1de2cf4e66e548d68d0d66c17bfe7010f8ebe87c6ddcfd2c92f8fbf1e23ff0f8b81efcc51c1d1929a0430da545b4b0e336b19ecb158843685dcea40b0d2e4044dc717c05e623e6ac5597f1b96950921987618269b5a218659ee302496aae4411f557e5c8d745383209dd154029221a7a23debeeb28b35a8c3730a07011de57433ed14b3d0bf3353995e52cb74d949c4862fd03c579600584eb336417ec105f8a5130601951fab73d02f7ebfa7e2233b87e18681a13930206e722f8ec9db5a0b6d4af65cd4e221b682044070ae3476210b5dc441bc647c5815926f1bd5569c246a8a4612f86f85e1805d2a17f474da798988749260d0ad48f3ccbb499b32284d49ee3cb4dc7c069cb8a66649d08c3d7eb064f997b45b193a6123f34bf54da26f99e49b078345bf170b462600da3a1f2c90e9ccee647b1670b1955b7041ba60a98ffc86f2d6991d9972bf9d0f2cd1a8db8922022d8c7f5207dbd435ab84ce13da5cdaee81596a2abc92510befbc2520536f67f4847fc3ccb67788ee1c1b7590a02f1577d938984e0a10020b243ed2f19f5d5ccc128c7ac73d3e91dd5cd963f8b2d44f4b15810a16d5a7e9161996ff3a5376a61228730f2c8399e4762ef13fa94d14d247a51295f9dafbd4a40250d3abd4139bfdff47d380372023a9254cf6e8c1c5da1b5283ae32a3bd9ae00bef4c930446f2eeec5ef1db68645442a0780daf22b27733f1ab971de49aec384ee420b2b2a5062f360270603f28e04d859b1a5dbc6bb8380392285d220e3a35b36c548ea0b3323beec5e11a520fc1163a26ebf28d47083569b5df03e9818612a9d78f983bfda5c00e8e122b43ee7bc95f4b196b7ea74c731b2211533b4f1255f73f5888057c9c0398880996b74401b09abdefaf2e56d41f7afb3d619fd3f5c9e2ef2d6e2f61f2be17e040ebd52bfba3a4d1de4dc648cbd210dedb981ac7d9f8993f188166bcd82687a216d01a7bf0c13aa4c8562815829f9a56d5d9de66c2c78167537b29c7b099a48c816c53f8f51e87bfe491857d6d5ca9bf40ef58423da30248188658e2d20de4358bd22a4a52677fa6a5ad00f1caf3bbea5ffda7dad6fb0b181e14abb8315694cfe52fe00e592e2931056891616f472366bb32f2c3e61e58747ae7e0cc0ffb5d31e4200740ee770898f2ab164a3fe437d719254b08f1f07abe847fca6d41d8a0ef3b5cc33490261b068162c71fb7d93b6d37c03c873839fe6017628b9117a1b2794cae4f2124ee9e2b614926bf3cfe884d4cf08be3520e0764ae3766172c938be233d0592b77ad0f9947ba8a6c3c829eaf7131d57dbb9d2226159a75a784483fc2e77fb1cb4c1e73c0dadaa4177f6cb2bc051204530d9f972abf9c2f4646ff6f35060ea43d4ea51e7200c38d19e921d6176bc17bdc62255c64ca92fd2b6fdde6e31e22ca91222dd89c776603a04a59074485b9f4331e94d006a08cf110316472763aef45470971453116d1069f91e1433dc3496acea6e490360e16edb5eb0cbaaf07f63c3b145c1ba4ef293e1de31dbfea44b608e15e8e45a639e40580c128f30735ec880eccb1d26d95004448a57f25388b74e216a301a3f0864a2b8facc1d2cbe22e49bc7a1acf2fb225ecd73e58477b3cfc5cbbf55478650689c12a20c4f51da3b5904968c6bf4ec269cd616372b040029b431123e6f3676764d7490ad04fb0f279fca3c4f093919c644dad8002b986946ccda129272151a024cbd66a1569da7f282377e44dab1580e07e6b5dc002eb65fbe5f7b46d524f39becc3e13d130969c9e5e0168bf57d3a3ce17172ffcef3c7893316dcef6d848dafb3dbe8ddeaa4e6e3056c44ca4ab4421523d03912fa93b44e55614be02ea8edaa020c4fd86fb6127e79a7ab0a8a582af8a059f0b0e91cf13becab7ffa9d900624083c184158cfe2dded811e1987dc5c7c1ac8c6761bf9543f4e31e86c9abfc82fec3b2e17d1e941913faf9d16c735ed38e0bd55028d2c8a57caa2e7c000fbc7459a95dead325abaf64f91d7c098bd80a2d8b06fa567d65304e7a9cb1892be9b824c7b9e5f6e4627963e0a4cece50580a7c02cc70f780117f299ca32f79bff14d8db9e5a6378b6dddd4b5e77b5476389c0eb7444d5c0dea97c5df1bf292e18dd19b71366c3b46c49300d976fb1cad2b5bdca1747fea18d0abd5d8577188a45f1d1452e86b3677640dfbc0f21323c2b6c2c17a9e119a8d829736a7a33c28d95de27cc804ea560aec960eccde4dc616c9f4a24b88cf7fdeb5d801b2937246d22244c02fd1e758c38517d7e1d96299c584d049191fde10f66e39d96fd5677b14e168ae63cc7738e858c03e50ab23f4ee34a8f9788d5f0a76fb63b53ede1ae8fa4ec5f1436336687329320f9e75b7991530f8cb45f59fa48c1c9911908e082a867a0d1c01ee73345ca3a05b8870df215a79080342770d4da59d123505f44fef608b9b7c6eb7f631d1b0db32545af68193cddc14bb4883301c09a3ab142f2fc5b659aedcf9753202039d764a724c437f6908b88471665d400aa0271e48110c8c887655454b916180f54c084c8f0e92d4d79d783716756f323428c71234f65ae908dda58faadfc448b700e4642dbb80e58857380b86196be25cbc3962730d979cd7443e8d798a606b4bdb24b72e4c8321d052c3fb0780f2bf74f221f55914221acae64ec13b2a348255d95f298ad1ae2ea86e37f4518564109034682acb31f80edf533bf533d7f16994f1e531f387c6ccf652bb41f44312173f063632ceb81c4e09e9213d91d1df02a3f4fc9d80ed0ceafdd741fc233abc8c76508db85f0b1b214c6d9e2b3c366a706de36e861be413a18e6677cde6ca4836d5d6fdfc8760bae44dc36e5c3b08acbe49d06276cd514b2d3fb72d900eae188420d9b58e5903df2d7b2716a64c115ddd7715c1ef833471eedaef35b1bc0b65b2f185c55a81140c1a4e261b78b5bcf0865261b3190039ba8fbf3d99d3b518078c172603e50ee9bb1b65ce64fab309bc85a57bbd17a7b42b9d66f35a4b3c7a3fcbf226c857d29f1815427db7def4e89f0352a15e1d458461e302d6687b11ce290e980ebcb3ca7b6859e1a764dea9a25a0d51f21f5b06d5c47e341ca396c2e6893a6167bd9875dfb7afae6c28704e8e9ec315e55e04a7605ea7d464628078db1d2269ca069ab36f167dae34942a900514b0f6c31df2fbd6aee3d6bc7c5bb594f5590a2efd46e21f8edd0ed563b25c321b2630746b4550db364675a2641069fb1218bd119dbfc21fd8228cf872259d0aee8be6f7a492a9602b3f6b91153bc21b47a95d972ced0df4c75e1951506e3fb27912b17e83d8c5e466f26a2eb752cc2fa39295cd97fe08e67306a85d87a37eb5efb4201a8f4ef2c0f4faf9fc17582379c97506d4fe260153fad7c1f22a8a7860542fb358a4ae089b0752c23ab18e09bbd19e03a210a86347377a7529829072949cdb49257b843a0b02858636b6ec922a141b74c60aa672bd5e79799abc72e624d8013af80626409592c3fce0ec3500cb248883968965ee66603d116fb3d2d7f410c8dc33b1d81c0ff03632b5ccc1ffdd1a86f8490a2afa4fd975ca1216ccb2fe1b099c08c702df938164ab8b29bfe0f6abf1b02eab45ceb93bf9c11ffe91ed5e46984d9d8b4a951db60dbf9fe88302fccb6cdbd59dcd56d91089d582db8884fc76f1ad726aba7a57e95035cf76a69344dfc3c09fe58d2af01c45cecab7dd775b71feaedfdd2933851976cf60bdec37dab06116d7139f0f5c0703c7b842b89bfc66fb0128d8123d551024e64abf7ac332f2f32332f81f5fe3b2ecf975f3dac36ba2f45d5ad0c48364f2ac2e3b0f6d7886080f8e61c9d407b47dfb7da533f6d21d5c557fb6d29b4a5f7eda819beb28b90657e1daaf1bb6503c405ea096077dd7ec8a3a9eaa19935db3657b2b75ab177ee039f92279805cc80a6471294249f4b639172ff78fe2ab3cde820ef2d7ca5368842fbf2bac87b69c1d4eb22a7d647e0f7297c2a08482a6fcbd787864debc34d2c05651c6c67a39911ed3ef40c3d30db118d33d8b8b7c331b3d10a7f85ddc56661de5d9a7b0bc1e40573b80a4e4faf9e246fa233a7878513217c0ffbf5205ba56ab338320f23b794f851c8659cf80a43b361ddff4713f25ad94991e5b59269382d210660a360fa8644e3d41e4e6c1f0725f8b65ba876c77240aed0da9fa0a38f7fc3b9978e849220afe8e599330390085edeebecbc159f03cc91b56452210f11e08917910883a668a714eff2f7d857a34b09c831c1b0de62b16c312934075756b09690b1ea4ea0d9368e6aaf4692efded8bb518d4d99755f65fd1443773c4357574a0b7f93496f15ab240fecbec978f15b38dd6c46a092c6f29758a3df39a00f174390b5a8c50456c3be7770688dd03372cd237ea5dc5aae6b6daadfcabc2c9c7b0820289d8200607cbd9e40dc3fa089b297e41b87442bedc681a6a83bd63408897463ccb27fd33abf4cc1f3571cfc4edae6ee0b1c5cbffa010be56b258f5903172e3a911306fc9f5fb358c288171ea42d48f454db77f760cd4fe52d4bdd43d81ff062e8ab48302b3c8c1dc79d8ce51ccee73cd795c848307164691a7bdacfda0e309e25e72c04ef8b236b1862d0437ea492c8f468d08216b82ddbd7166d0e6f7383d66fb800c2396cf0e0b0e5ddba728b72ac4fe9bba2c0c40948e02ac9cfc48d266324d767156890abe56190128e9c7495704214f6233fcf2ceac52e837a5b513f98f53acf8414aab011177c56a640e216ac7ce2b125a433395d645ed8c12eb983cae503eba769a1cd5352de5270ab58359bc02e78ca1a35ffc43989ee597f476e31594777b520b81e088bfa0aed46723dbe4dabe69fb005e5505b95c656f54214e282ddbb79d862dbcfda69b5d484b16bc83a40ed8727f97bfcbb926fb579cd4634a3c35e37b4f78cb9c36eb8903fc2c7df78e0ac7eb83518bdb0d122d54fb463113e100358df236e1b52c53a9bfa72dbd532339d8806f5402f5235b15e15a511ed17089ddc5d7e4aa9e7b7ecc0af6e64330c4dc4436d9cd4826a0ff59f0bb78428ef0d8d2905ef35632868022bbf713b6044cdd9a2366f733d92eadd940c4ccdf0d44904e66edf5a836ba83215fcd69c5f2f9a58b9fb8d77b0c6dad108e19e75564c95c8efdb34f6d1f60c279d2caf16b3de2da77f84dc4c795e14f7161c63a4ecbad9408b1360925f05d07e6a593874ae5e88f2aec5f30324625d3add29e2b6d148eced498d99e90039cdbbf43bbc50cdccad7ec99b3714ccab2d4ff133ea4285a48419bb2b6cca185cf363f3ef9751723d6b11eef97fde17fea911162501be6e5a4f3adb89a25516da8646f90d16254f6adf896a6622a66cc6788598bc5629f6cea508bb059f9a8ecc0450566134b7dee2b984f8480c5fe858fb1fbcef1b7eea8705a472c4a4f5d638bca49e7c057f094434ca147528ae084c12af975223e8466b5f8758f113157750cf8597aaa25bcefed38d4ccf6f5d871db8050542096776c510d07876d2da8676943aec64559488e8a428ff3b570ca174630adfe9b93c34cd728766e5531dd2e6972154142bd3188c25e867ddc837be3756f0161378893514b6cd589daf3c7f36b3d3a448e1f4d66332aeaa3280e3c7dfc3e51a984b6645a81ce834197fb9b010efab06c385a111a761daa088b703f7457387b822cf89953e3a20c9a0792253220fd2b1ad163e4354bd738fb53d0241579eb98082fbe49dbe3bc4a58ef286c4243a9338cbddba9a9c81bd5e1bd057c92d807030f3e8297c76be1dedd6f5c1629fea185e78a91e6b29c1497594d96b253d8db84d8189225acd843274729433814226d1ec4248b805f8bee122c335847a98fa5019853cf2438ace5582b836f525541d52f63c53d1bb5d0f58e95a5bb50900a5e77e2857957205f714085952de92ad997d5069aab64b60f0df85d64f5cb0006126545fdeeb204efc693ba7413270cc819966854ea19ee5f127d0b435967ee26f0ee2f43abd8a97813ed5e8e0f89de7ea2b1e6bb261778a3b742eaf432fa57640ddeffdba661813f167b8689bf75e0618ce969779e68e5e652a957cd7b7aec78d6f91aa29259a9f942ba4998a79451c28bbcd53ee4b1318b0096e0ce667f47222f1a22040d2c0121b5513120a9aa4583292d602a0f2c5c8bde599c6de7135e00cf8ebf92330cfcfa89521e1165a3e7af77e253fe6e98fa1e9bacda21351ef55be648bf468495522c9261c554e11bf123561dab9587a119d5ac2ee53fc8065ef3be1f2980091f65c991e84e8b3ebfc66919559fc1eb6aaa3f666053626af6a413ed645f301dac102aecda30c4bd411840477f6150c2b4c99d292d63eee13e922980197a6d869afa473c66a329a0487254ba1e4698215a092e79cd448d0bc29312a8c6c0d0af7c04bfeb63197518d3ccd5a0fa5c08742cc25e73738798b21e9004a9b8558e1ae5572483a9f07bd213524d2e32dee8ee3dc7a93f6256253e4c6de818072661335d1048685d71fa2386f4c76671753f8432750d522359a7729c8111c27b74a2fc2a38b22c74f3c6d742ade8907370b05e0d8b008b9810f63ab98d873c159e8854030566c2f418f86da1348eb2be401f589c82d66f79e399e269c0aae1fffb7334209912afd5c358e636c3e6c683aa04d100e669eb855236bbae95277ff6b3f0626e37c5e1ced18893f33b93762ebeced15f75e5d0d33da87650cdbbbd6eb8eac7bab66427022e550f6a5319c11c45e85a302690bbed70675a614029caa93b6a94c86a5a2bbbdaa0b0cca5dca67598c9e893c40abf348aa58f7d53103147b41864db55f0acb26a4155acd79c09107d198e8fd67882c20b8fcec7a5da853359a7dc479446a88033704a3c8de5a3d302eb9400fbf6e585f312be00f19bb3b9012f6dce09f63dd92fdc8f5ea3859ddd7e8f955dc0a9eaa929aefad88e45d0b9c33087bda0d32293058a5495818811c97998d995d5c01378e4ba5cc530e7b77a41d47177b6049a8a21926fd55740fa7201e2ec8a55d46c632ba05dbeba5fba4f077ca2c5061fde51aeb04f77e3fdc3fdf78eb7fa725a6e04507e89dfc233478e68e25dab02c1ea104761b66f3de6c6d994fdd3e1379821a6c48ba6c236d664500ba6202996e988f205ebde734a6bdad9ac86af4083e0b30ab5e1f4f0c4a39adf5a2319d76c60b5e344d74c88e1d86928d589d1d2db0f586184c9f11d655fcd0962facd93c5ad7680c7a245bc7773b4a647f1fa8d5c796aa02c839b452d55de670237894b95b816198f3f58dcf061babcc9c32f9a86f2d243d8bf6d48d30223273de48f2c97f8fbb5b8e66f604a0227cc9c5e9615b63334210cd8a2c0ef5cb86ea8a7f66d47444d510768202f6ee843b93143b93ecfe86d835aecf3ffdeb89e8893714c4a6bd5dffd5550b01f29bde3465566148148492f89f35b95359f400919fd758affc04f6d2f1fdd57d9aafa412c0f460e2910dfbfb8f8899c3500aefc12eb260450e4417139ac9759c53452bc795f83b7abbb1e1f6befb1d81d0a109845746336d8269f7af008c5e870fe96b98aa020b00b7fefdfa20f87605fae90e50db161f1ef5a234954fdf46d557f739a8f8e5662cd88fe947a999d0ddba08c319e8aef49c1b1af1f2f56f057f95843420c46a6892a5729d77d19f4320e2cccdd249e54c6756b403b2a531530e59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
