<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f2ee024fcb02a4e3a951a5ce02072984029118c805a86959a3465be28111eb7667efdb39e34de195e47d9b6ac90d95992912fbc99bd4603470ed22d62809f680710bf3c75f1bca3ddab67be49ac9298326016ed60fb9d991a0143162243bc3f4999e6a473d6809d81f68d9851c98c0d3c327019acb14eba03f3add52166f3b2cd10d1bd9b37f000346cccf76c247f7e0f6cf537759493dbd3b5d61ad34562d61307114d70fc613797523d75484aad0e78fb7706647c924fad2dc1d37b939e0ba1f935cca0c073927cdbed48d4418b9b338f2c460cd2085d1451000485920f76fbacd9f86fc521a183738591c6fe39169db5a6a70d779184d993e4a78784c68607ca216c2bc817b613c076d53c03c69395dfd5e85f6b8b67d68671bfdfa8cd431f1ec3bc3b5ff139db1060e9d60047881d21134add1129ba33fb52d6baaab97ba586275b65d5440a6d3c77267b996e9a0f3eba1a2264924504168538dc212b5367866c253271cd7da3465e5d1fb8fb3138c72024aa8ee061b4ccc10940ee5a2647c58bb0fdb515b35f22ea4d080261b930acc14ece1581348bf396048b6e32e563e6ba3c6ed4ae94576a43a63c7e418f5637408c934d42be262c3ead8ed625db2eeeca4c0ceb65c4f04468abc38298657d9d852c42eea15268dc43e2b52d78c90314b0d7f32b77c519a11cc70efeaef3213bd1a5cb41b7bbb2813fc3387609ae2ad7ff6c6a8850e8e0a872ff391b4c2a08883e746a5c86dd4b7ba4cf8d2ca25a88e75ee7ed70cfc7bc9da11d5b39f7bd2474ab74e401d923828eda5cb2aa4fa50982060807d956924cd5183a95bb4ae459d56d264cd4b9ad26952a8e337d8d1e5b390f5fa016bbe90a234b1ce9577db571be8917dd8c8486dc1b47acb391d64e82adf34bc0d0765f63be980e3dcb4b84ba5c09717682b2c0e74d70566a802fc2a8ac9382383ef9b1a20fc5fbc4dc7fd63ae5699c4d2d8ccd0f08fbd48c0d24fbc808c3739990a4e8b943d9902416cf0af654db51676169cfe75a2a90929a31d460f3e66ae24cb3ff0fd5ce23c184c23b7fedc2a7c144cffa58f12b3c70003351fac7edb0577434c82e34bc8162acd635f5c19dd6fda9a239b7a5cd640b6af400dddd544559ffa9a10bd738c4c0c6173588ca87508cde8b03aee223198d0f7944980645da17a4aff2250543ba78184807fa681d4dee203fcd780a9dbf13cdabcf4b07abf2ef44cedc49ecf7888ba53551953a876a4a559a155283f18ad7542f57cd3fa4430f8affbc4bcccdb975d13667980624ed0a5d195dfd78888e59e978beff6960c4c4bcfa3e918ecaa3d7e5a019741c9a84ed1b644199dc62646673cedfa3b47caaf81aa06342a64ed14eea6c935624e2ee5983b723d4de6596053a1820ca3c4b63bae202e387d4b707f4f33a85234095b60b3976841a24e7449052e80f14351208edf264fea2fcf22c283be26e9fffc3cb19c46cfba154fd5eaed8205466d32ff7a256ae238dc4118f834f2c2bf6ec248e1773b91f00ed8302f4cbb34550cc8d473d6dbe74108699c5fe7497b895d91b86edf9d014e7413f2cc7640a1fd43c8768bc6a268a4b9fb37291f5a1e842b89aee0985cd2aa510b495bf517f32ebc0282d2fdafb71aaa0f0a33bd0e2c1dd06c2b0a36c57924edca5869354b6c562974e1613dcff81a71ad4d93ca8096782cb8a1ec5e2d8e1d92ffcd1e75efa6805a3555c8790a7f0ac846d618b93c2a416debd56f584a4061c6a9ed7c2e6ab306f99ecd7f23c50de4456ea2bcff819580ca81cec8250ed6517ea9538ed8337dc4bf743e7e33f6624ac6aeaefcdbeb49d72867a0b73b466efd445d6545edfcc4d0ec952c592714f4fc02656254c771e8a67df8a3d86b6ecb85ef15fc11842004222f642f18039b4e341c613764415cd68116ec0bd32066fe47b17970099a447f1967cf18c156c5c6b8fe055fe1a56e96028dce30513386f4f836edec141975f91ca313fb378f912a4a7ad22f3ddedc79c87dad7a28676164cb5f5d357584a427f37cca72f1b6d60c35a8b1c7df095768b40820a02ac3d9a0c9c0a5e1b8f8f690dd6eed91d90e0c4b36d5b72642bdcd8cc331dac9fe194c376dd6a7442b5678e2391eb655eb3f86b5842c6d37a6447884a7b36207f63ab741c0a2778493688516f768d8631a50a7d8b248ac1d18844d42cffeccc24a22019966cbaea76edf1ffa66f474749db69cee48a3a058e155b365473adf1fd4f6e3c989480e254f03ba467ae039a28f8ea0e85137158b39d3488c6d6d85fe498442530db3ec0e59a6478b6d3e8d38fa27def8451f7375ba439c6fc4f722fde3089a93cdd049c32785fdc35a4cdbc6393c3c768a269ee70fe9cd255b7be8dbb2918bab149c4d7afed1102818791d6a4af07ba5cc7567a6b8815f92abd022e976d8959e3c50cf353c413a520ca6118cd711572eccaa70652376be6321a56f64a365a4e0d536c742034d7af66389b8cb021e9dc4703ae85aa5941eb0fe8b266046803b4e6984e6eaad5d326152168c5a17fb7616a73d5f70ed3711ea2e31f8c6088e3b98a15b5fc951eb13905c9c1cad42f2be2dd7d3f6b90ebc9c6dfdc9d2b9bada93d1f443fd1efcf8fa7fb4de07c9d68af58b5ae642358904ffe34ce43d54b478512b5d20dc15eb5c3a1945fb5e92d3e5da80d6eb71b83b3e9f50c85f75b32c29d494e889dee7f85f5d803323a5f31ef187496557cffc62897d9b08a1fb433f4eab2fe010e26c80d84d6c564c8c6e9257a734a8f65b44bd71e4e96e54cb3c1b1067faf93f9f69deff04771a56a80d6e46a03a98768a708bd1884a02c3a6b015aca256176c6631719962fd65b9afb48d57fd54d409efbb9a25684a5acb0c8807332df589fb6a22da4c47fad6f7d5192b180ab53fa77978f48f73157851d1e5162d705577267c37d82367cd2b28330ae804cbafa7770c4b9ed0ed54508f43365c64eb9adc3a355862e82d374c14b9c842dafc7dc54a941d1a686e62ed8afafda45f99797efaabc9bb12fe7bf42dfdb09a2d1961972853fa697aeb427e204a0e55d8ea7bdc6c7457f09cadb96210239a0fe88aa777b6313ba539de2a1f35072a992aadf5520610588d7f159ade49b3192affb3830c17b8b0a4f1731e5b619a0261c8837f5e113a5dcdb43f7ad50392ce91c6558a8985b5d482f8674c8784d64da87f5cc5a9c46658cc3612bb91448614dc1ac897f3555d26cc817c5016524e5162fcccc46f5472ca5e2de2ada9c717919f6c3c4d6d759ab389ed66a359275d83cf6bc16a2d7aeb4fe429f432f335fa7ed34ac639a79dd24ba2df3b10ae556eb94981d161b55b0f36f257fedd8ddecbfa3caacf0e8d0f5224db0c1e9f259820f65f0574b29535c543aa0df7c8f5d295451e9126ccad2fa2434ed124a9a7b5744eca60338374fe3854e3f67ed083f2df31afd3f6209c86833252e8e4d36142349eb5e20e5bfbe5bb6118c03235b70e5d25c36ce585d8f7dbf3776d95d20996ab2930accbf6009b52f8b2f6d650ae551dd1b3d4d824788bc1bd10379dc7b3baaae0121cdf6a7a16aff7d6071fba269642bca6bfb24938d24e1612b9b987ffc6824d815a63f042e488a1af90cbddf69e0557bd4548d0fcbb7d057d2c2eadc34ca34b08e108f0e13614133ea213d9291fff0e5e6da6c62b4b390cbe2373e69aa081eabd6c9940a3f1147fe82b15f11522f9a5474910f65825d3a5af1cf14fbb72f7ad76b58b77cd42de7096d999ee092d148519f435a5b97ef4479517d1f95779c5b04f5cd478b0261430a628e237ae606988bef8e71a6b1eb2ed4be28f7dbd9b53060cacbeb091108c132ffdaf87f97b87786bced8017855850af5b639a42786f16caa959dc81009ebb7f67c10e1cdac836239bcb38098ca002e17afc40ea15ae9cc378744166656d30ef29143c02134ccb1dea68327d7963dc92a529206b8949df2339ece4942f88b7c2f8723995cdad75ce8f557920cc33327a39b9e78f1024404975fddcba44371bc583c5b6d6233e3a35b048c924cd09fb228fbf2cf073e560241be5621ecdce445bbe7a4d95ed3f64b7c78165d2b84be4a3c607c8239d712c0e054b6745be13586a9a59c882499fe33242e3ceb1c72d39cfb2fabbc6a2769411ae208ee477d1e4b946e6c6c6b6fc352a5f7efc75fad4a04350ec67056d7347906252a742f29c1eae6e2cc31b9356bc361631d53d5590479f379c6b18953dcf543ecd99e14677adea448969bcb6088a312f2e9612fb585e1d33d25a9af4fc24c12cec02663f606d2a1c31ce0f0c7f85422fa68dd2411567faffe144b45f07d6abd765fc6e39f1cd313b7ced256350066d52971fcf25fbc56f6573c7f535d866040565e02f8884732b38f8119e99815ed8dd564fe1be5f6c4e8b771678d385dc379c0d2460623c142d0bb89d01ab6c9058243efe3635b20708250dd19e5f38760eae874cce2c186d030b95fdb338a15876bbb30cac3ab5172f0fce2c62fc63dc5585fd4722339a3664d03996168fa624f44c6cc63710c5aad739a0f4e9c4b38c6a25c0d3170fe576952e6ba43464c4d372db6d3ad8a1fb341b23cae7a4780d440a699109e1ab2cd65b110cf3ef91f2000d7e94cc75286d44dce0cd36ff48200dcf975d4139df5e8f14ce7117b18ce58b44385b191529e997a3667ed6be10a8d89a3ed978f2b48c791866d91ff5e6fa7f556d50cc1e8e0acf26e4090885f652d52e839c17f4006c4ab58114b6a1c90b3002136e3cc581fa17a91d88bb0c6d89cb727b7055922332f88c7104cf735c23457be9d4685e6faa3e672353ceee615de9e490791bd68c8523c34e052860d2aa4165196420c4f81f21e2235703a5c7984288a6d368e76175d8b43710ceb50347124674491ef14323318664506b3649661729c0d7d4fd9dfe473b242df32ab3adb29407fc0ceada806cca313da8e7767462c7f9eee245bf653ab29b43ccce28255e482023186b508f421ce05182ecce3d63b8a82ff2d6a904bf442adcc89214dda17364b4049ba5d53d4a218eb3e4ed0aba98735d7226e61121df36f5ed952a816d131bbc5a43581be6427f6407396d1fd0b48710f4f0e4eb86f650da679b0ae401a126ea79389ffbb0fa42cc12f357fc5b9a157861bc1ecf4a8b2a56d783753d3780a1f970f25b44b75dc3b5827af3e1c8a8dec779832381eef7bfe217acad08815953ec90b5e85515af6b9a28dcb7ecef473e72b64af24cf1e706cfa2c504266d8952da4ca802ff176e0497987a66c02fd610ce5243944991593022151e33da717c5d4af6bbd5fb97e94e276c14b226ffe2022d25a90583d4f834ae39af60538221a1a9dbdfa1cb1c9f7039d0424e3e6e67734a98209322db6dc9fffe90ecebf66272cd238894caa58dc7c03998efd1f3e6f6a9e4c53fb0e15695a20914d3171c63d1cdc580b91957e4da29f17029ce16d2fd854361a520cb82951fe06be4da16b82f06124011c1018fe77f31e96454c6f9476c751f438ba9e501f17a06a157c4e47def8b4794af2954e0a763a2d9c3099a1790926735c0d821eecc474b0eb6cf2aa2c8274556b4463f2d639be31d3921eae01c9215952cd766efa1bdee629ad4ca36d09f9ade4ee9782374acb9ee36fb5e48e61285f01b4b5ffd9d4e246c2718bb0e48ebbbffe4dd929acfde30535dcd5518b82a72139a049dd4ad7a1e62386a1cecd5e47be0bdae1607dc16d15c8978d017d201f1fe2111294b7b73fc991e781b9883b4df145fae5b6d4916d02f8905437875c5d3fc5fb18c7fcba21c9bdf124748ca92d2c475f83ab1412d20febb1a562fa1b48a73318bf69a8a5f4512d6486106808fc11d062c5a14c59c736aff0f7e0f748cc1d4b2ac2aa4a82c441c664b553ba4bdf4dc89e81d4e9999b07cdadc43c4476d1c78e3eb11c2f1684f10d4ba481eaeb293d31ab0debb1fd5ae70e39557e764faf1f9661f4a79abf3608fad4be8bf8815a07225021429e85256919d05b1a4e19e3b54601c27c89929ac800245727a339ee182cedcc48c7ac97859ba90b4fb5e9e2374fe49528676b79e51d9651c6935c255f294c216f44617aba8493488b96c05ca2eaf146d597f5cb3f5f442ec77c4e2594f4a15a033cc7567677e3204811698068dd4d5d86ff7ad2db34d26a1502decc406ed0d3ad8722f0486a2dbaccfc4a3ba434890e846a5f092d17701babfe3e7d93491ba5240be9f5a75dea63ed1192bc22ca12abefb5120152e2146c7f8c3a4c2884af215de9c8151c8962483eb3f67d1b010e6148a42075d843d286710f5ae504d6643e3fda008756190f4f268e182655b1f48999ed3d8ee358f42f198453c41b360adca9cde0f2b659a571de92082b2d945844073acd4a9797dc2526f1eeda374f38d930107c4e4ca08125e6a2e44f994155cec6ee98119e553591431b4a45862c8a0e0e14ebbbfe13ce19874728647108cf0f133ccbb1e7692b2aa10141613fd0860463a35d2c4923978eea780929ace536bfe97d0e594d8780bb992f8e2d03562c0246b1a32b15e85ebe31c2635f5640963d7eba8eef2e7f8dd7b60c29d22b3ef7724b473479023ef5a1fe58eb80af589c57bb68bc0ffe1df725b70e308fa9472967bb92c161db77b43e6f75cdcac032d9de13eec251ead953658a2028d13736943fe2ef52341c1e8c287986842209788906a4319d113b255425af3dc491b20c556a7625695bb66b31d7e0e74a1dced6e13342d50ce7c166b94289cc651d9a9e3eaf3527621c3ef1ded3f633d420902f54af68a94124e40e88624bcc7e121481a653eb99f5b440cd21882a97ce1858b7e1dd149caf369dc580b81fce306bbd15b99eb779f3ec185797795887751efc1da3968922797a163404f3c860d65eac7abb34c7d35e1b0d58c3accb05cf6a50319228cd15585e4a4f91acbe07a0aedb4722ae50799a59f4bb8abcaece7762ae31b8c7b2c028023718d5706755e41a32a0b7596228304f299aa1090439b8613687777ea64a8c9ea93fb128d7e4ab6f172beefc5f4ab8a275d194ee9cd5680be834f762ee6657ad7f216077cead5db757f123726982b289362cac549bb71205f229daac9be14c82098a923afd3c182fc7b34d66dffe8caf9f079930fdd2d9d57e636bcd2a443fb56492cbd85e706f59d1765340f9d06f19c842d41e3ec53c06a640a462a1caeff3d91a609205b1f5d76ddc063dd7ccffa31aca63ab554bfffa078cb9a4c3868b0b4d3aa73b4baf17047170c80097d1a6ffe224e9e01575ac478dd656032aba52be637b77c3d050857f1c2afa8d685b2e62da48c1642b9f2717ff1258206a53b6c944b3f9e00ca1343db20bf3b4fe48cd0e1092ed2f495cb3775312dced8b8842ec9ea1344f3acf891dda9ba14608a3c80e09964942d605982e479c7dc3a0e0c243f3e9aeb26dc9e2408226ee51455a216b3f0b944a1576a99502e505f691485e9d8f2d67b37f689232068ed22ccaa32409e0c2ba768d71e1fea33f60123f5a6a0950e59add67026e726a72f3aa8d0fc21c580d7ec281a22b6837fa3831aa191821e5cbce48ae95b7b639815ba6912297f09b64f3d20f273049c82dfe40de6287e6e4d20505700c84c7d92711ebaf2d50de13c3a41b1d2623df0f9d28cfd6b660ca26b5f62b8e1997d2d263aecd1c8a1ec59b1063dc5bbae52d2bce8bfc19a3c25fcbf80d87765e5d7d4428f01a36df589f9c5fb2ee0fb3026c99661c5971f827288cb754c9d0b5073e423ecc4228a6b9eac28828bbeed118e431e5177bcc1ef6268b68c5f9b1e9a317e48d774f5d082c8704507621d4e7ef043948e6f7adf24a3e339550fc80337abc938f506167047bb6c75ecb7fd35c9bed0bdde5bb4fb743a2595621bbff20e3c875a7628aa5ad2368c70af33919041ab21a0196741710a7d718cc65153ea140b6ffc35d1fed1c7a5aa2e016a15822a19ed93efca9b677740a27f6a6cb462a7459c28fc674c9e493c52278fa30ed12b36058386633640ad966962f2cb76f2ed1a83afbeefbf0aa25dcdaf67ca9d5f68989af430f4d018e9590c60627bb136872834ee5eda6034c9acafd09605700d4d43632e352dc668abe007a62d87440be686e980955bd59bf69a1e2815e1a00b39e1f424107379b588b9c0d7ee39123ade51417e51683e2116769cba6589c1ff42ea5c223f6a2951e64fbaccc98bf28a896c24082bdff838c59c27dde23189377f1f640bb576c8577a619d1560398fd758e2c449c2f3058397fee4c35b1119a43bb4b719fdc966c6e5a26dcac1eeec93df51ac6bcdcaa583f61dfeee6e1127b93e76dcf3ed47285f369f5ef778df873653f6134aaf6452f740304742150df30a467c57a42275f72f29fd379abb315ee1a148f6507507bcae13a98144d03bc4c837bb2ab0829d69cf8fb0cedf2d7f1eafebf847a0f05e275e81296dd71af868f5d843db9d7f312428ac7a1824fe3db066cbb6ecdef8749f08ff84198e5bc1250a64d73955af8c8582348e5dc30cff597efb4b616845432df37d7d6622edd1ffa74576e17a3da76192f5736b108971ab3e49a008953ca5921343ee4a94b5558ce803eedb5cbf0ccf890b0e261d130c45880e172dece94bfd9b3fb747d198c38042c5ce50099287165940294d0136323c0af4ddd720a03e451ea3547e396355aecd42f3addea0e94dceda59a60e3977b7b5a1e1f0912a24b170eaf94214596bcf7013094862a06a3301e1fc3f69c5abfd6cc1fdf2c1148d9b616a9ddd01e17401de80bf100b8f7bfdfe50a80c7dcc1db75ad21fffd36880ddd6765fda15b11bc90a076d8bb6d051967d0e9f2a1b94f6dc2ef0e95bd5c9cc0febb382ceaf6acde7e8b70cfd52560e1b0ef23cf5ce5eb7fe85d4cd27e67e8db0623138d9aad7cad8540bef8570eb36d93e87954ca67aa956f4720c7a30844cc201d08efaef943e500f8fc15db60406572953a624322f67e8e3058c1e442d2a41339f2747bec3d536fce405cfed3f65d9a516a54fe305dbb0b5ab54a1649aec1c2432a6cd7bbac519ca9d675a1c9071a307685e1e8f6d6d6a793b8ade24e5e281ea198feb3a37f02f58fc5b776530b5194c172e5b62e14490746f9528ca73a1876bdb4484b83852dba99d748554b8fb5b72f65e869447caab0da45272c18c666882fd945ade513b020311afc280e4810ca6f32e5adc10075d590a7306bc734bf1665bf2cd3507ede263f6dc167f977ca9b9c0b280a350a2b7976313df30603c0ec21fa8a33de3e3d2cfa09f0f331c030aa44e1068e31af18647b86f5a210ee4d431c3aa7138d23d829e4c34b47a331cd6b8f7378b933c19a900277d07ad1afe93befed4d5e7e7b624611038d8b3668e9ef5b4f464bd25807ffe500bf9d6d895fc493d6e3750f57deecf2478e039683fdaefc05293536ad2273a728322972ddb7cf2b93570272bdb61aa56f9ef9a1f528d651130c01e1342b6534ca3c53a4a99f09c147f392e24a347b0c619d19a89118e6ec45eb6ea4a2386abde403b5f1218d62982012424dd55afdb5fef8bd7fb944a1578adc9ea35b56d98b900c7436afa2e403afa5ad2b73efef135cc083c06aa28103731211df42129552a47a1d8653e675cc4e751f786a5596648cf9f9aec319355dfcf873273d8720d563d2ca4f9f4c6c08e8d016306913b1098562328959184463e1272b4ac9c947e41750786bf5d9cd0e1d69bf9c5a538e10ff26669fe0217293d2691c3173c674888125bfb44e95305431c418044e1754ee31c29e60d8554150ac66cb6e627fbd3ef1a2872bbf6e42f6b755295b1173f84ffc09c380bb3eacdea5fd507ed3247bb1168619b4bb0c0722501ff04ff153a4223f101e30269456b521f92bdf434c45ead8c70456e4ad000e1ead7475c60a8284b2f784a88cb55e9d8baca58dd4f8a7c9f22d906f82bf7426944588a3c69540349d88d5081038e680ca091a086bf3b363566fce9786ba2444285ed4c30c160c6391ef23c23cc26d099377738e86def7f0ebbfdf78a919ae4006b371edfbca22bcdfa262b7bed92aa16d2e8953052f062658d51a812d0e0bc202d51af44795a5d919eb5687d24b70d3ecd182d6e52fe3a917040611e2bed7305734df2c689437ef6cf44f9aa4e6de288ef732c8655413b9a7e5c265bb127e7cdde90aa02affa6634b6ad088b44e8da10bc2f87a6039b014b260ccf7a83ae53931f3e33723d611ce22d8b3e1b18947a80b46664a6eab7d3e3b421d7ea6076c50bc97cd1f7a3aa9aaf3683560b90c3ee30a5bac93029bc0a638eb36c0dceb5ce409408a3ca7d987686425a609d8963a3016be3f4b03c9f6018d7f30727a01b02268e3937b17cab3c05a1c75a3174f08339605fc34100c2894d5e536fb936bfe3ece83be0d97e87cc8d63ff00783a97648463e773d9a39a8c67cfb27701b5039f1dedd28c8b2f119f62394abb49fcef0cf11ce0680bb36e66fc3697a102bbf513828012a4a6df030c7459e8d6b8947c911a4a8dc40afaecfa377f9b33095383f6ebe2a6bfb406ab3c95761d001170f160b023d4b841f44cc242e4a771909b43e470dd353b7fb77b6ddad494fc7abfb214115f1bfb0b9f14ec463d4116916fa1b60451a33f592db5e5f99e4ba7898ef64ac52d48978a5ddf296089e5e1d8d4c9ce9f064152c57fb43d9d1ed715976d39e006aa0467f7340ad0f1b55e5618f8750d830ce65ceee1dbe83b88a33a3206aa319d888ee6c9bebb98d0d19c2faca13928846b088a52d71c502798e3c0966a128b0df345b6c057d925b9041723bd9d470b596d2df17fef0e0eda412ea7b558056bb5cf60fe279b7e30f8ecad8398dac32bd0c8552bfe1053527e9ec293f1d30c9c1921a5dcdda430bb3d5c1254edf047051d497a5943e8ed3cedf674ba821592d43ff71943fb6d192e63db3c17a27185ea7177b6e33017554a38a8121698d9931f50809e2d149bc033c0b66bcbee176b0a125def1a543b3a42cedf18bbcec0343efb4d4f28b2866085404b656db19b91bdfb21c58608dc3faf77155f431e290cdaf03d344e9a1ecaa8457bb1cfc46defe6f993aa9ce58f5844cebf0526b8518743928e44858ebecdfeabb10812e22ee4e614980cf17a838bc388e7c602daf8c7f68b3a99f653bc558ae9449ad17293ce1471cd3fb5a24fa9571fa28e34d3a30e1317bccd386d50125e8b919662d4fadfd34d457559000e81d81aabb3e645c893d5daeb299b9b772aa2b3084768ba416a49be2b4d0ed254a16bd88a721aa18e915f6cbb6dd1d9b69aeae17b202056469b16e2bab14edc3825e3c6991dc1e0dae1a3596a38ff2016ba8bf7080956397fbcf9318af157ad7e44f2e7f3b05867a0f9c5c58785e0eea33dfb286a5b76d7a9d0b5997bbb03fa2f784797b8e5b3d8fae347dc670604607eef0995515df7ef289bb57a4baeadb9ecdf84be5982d20ecbc4ff1476235474308fd2130b6822e3f832c74020fc426f95770711839e594bd166bad8dbe58e794b62d988d4d7c0e8aeb5554d70b8e0a1b88e1fc54648770416f35b10b01a5698bdd97356d2c634dc88d9f89bae960883a392805dc9d56f9a1a120d51cf0f37c46801eca64f9e45718c64b4c2c526eff46b8b911074cb9e3b5f1f1938fc3f0a5bdce3e8f1155eef0324d7eadadd2128b550c89c3cb56caf8519817156690c9a7921361a094ddb3fd792d351e9d8970228e0455552c6e1231252f971f070ba85996634e137fab31762f963e5cbe8d8026d116dc0e51e6960852c284a287651a97fec58840b3cb27a55c7909615ed753a3a6be72c05b3d27d9c2ccda737201c6449da95328956210953306d9199654f8f3dc35107460d6779ea390cf66e749bae47d2034c03b56524eda5148daf2654082563e54f68d665ed880abfafa6863de09d3a8324c70e08bd73ed909e33ae700e0372ed2eb84c3c7c050e4167e9cfee2eb8a0784e88735f20ddf2f64fbf331f50e74ff9445cfe056d4b864c8d12c64b3097cfd0594b9a638f8512203e08cc38df534a1ec82bed0daa317ae1ddfa942ecbbc144341e761b232e59d9682b4ea32f38c74b2bccc0aabe2f36a4e7e591a98908d5624e07d23b376174311d44f6d9db790f76f1d6930a6d65fa2e8e8230e1151f2b0ca17664b8a8cd62950c97828f38979996c5c5d435d8717cf14e6fb812cbc8040998303e4ff4e0ca33e66d91a6d2b18331789b7455c80056d5d4fd82fa5cacc6b5e20524502c1d76e7b18d1a67dfee677eedd4f03262127180c9f99eb120963af4c2ff6e59edbcda443a14fb318ea0eec9cc3273db86380609ed8ce4c631d514596b115708689263807bc5b614b6d8205936bf0070e762edb1ba84e5f1c7518bf7c7166effb609dfe5b6f02e0015dd62d8d2591681bc72a283210997018e30ddf41837fbfa7c99f672eed3cb370c8c6526e16cef3773684ab71e2d5f333d301053b24d38d64733e40978f813b2d802f070242581475364e15d6c41d1c2eabf0460be7e286d9c63c0cb2ee3eddfdc7d609ee41fcf096a71f4b5ce19359310a4e66c6beae417da7efde8f0747566c3b5a492478c385e298c3111b28f485cff264926121eb798a7038ee08cb2c1cdf3583f84118888da6d8dc0795ab6332e8735b0c0c0ae88642e4339f28ab7908974aac01a2436db1f2c672079b8a74d03579d4be30a5697b3b199956126a31d8d9c0625459d3ae6a2018727915e1f7f82a7d7a43b990d784194f84544084188877ef910475daf9366bdd0f4946dc8d4c829cc963d8fbb33935ac59d64c83fc95817a95672acca874f6d0dd9fe86bac4a6deeaf79dc9227bea36e14ae25e5f5153dadbff376974c9e4430da99d0db1bf236828b96f1e47359ae5951c36961d32b9e9cf19230330bd33071da19a799f89d63db6cd89fedb2b17782c90d03212ec6f42e967136794d5463ac78929c1e942e68afb090d0671dbcbc4d6b155db39caf6ebabc07f4784dbbde5c73b771eee7b2b28fb49e2803896d2ed779fbd9a54abfacd75b0da4501c3fd2624637fd77c46cc797c83634f221c84dbb1a7344e8d8b1c9fc7860e84793758bf409b50d543ae5d1a9c81283867c98a4e8b4d2d28a10cd0290e88fbeb35adedbc505b2315a58455d74b8c36d078923341b54f23a190ea0a0315d3b71e32562852e33e02c6c0614108d3adcfdcbc4e8f61439a7bf2b163b388a41003f92a8f16d5cc7af524c43139794fce92658d67f3f2caeead3afabad74f65eace4bf9dbbf6957ad69b179328a4ba3e5e8e3e7afca27b911a4962c82a07a5fd441cb3e4c5339750ec9bb127984a4b64487350b024f64779a54d30c933b5babdec276fd8cb246c9ab22480160adf86f538e51b1f52f0021c8937b2e8727f82d2ada6f3b390890f5b3fca69cdb432a145b3460c2aa5861ee7d364723f8fe6b04dedbb05d6e5f3f9799d56f418d1374e7bced1f90d31c9d4798689926840d49bcbdf9ecbfa32a484fd87a75ccd482bd9b103e35def2bc42c30a2536f122ef27595cd15b4a5d3f8b1068c7fb92663273bcff401c20ae93c0e22337d41a15c0a7fcc95bd5f4964f598a6ffb0264b171aca2231e4078baee27eebc1b4d7eea77500983aa57a0d65cb2de15491bf7a18df7d0d178dd117da95ab348e308c1288a674a25d3e6088894bebd85f35bfc71698df1013cf39e828bfee7092c82cdab251570788b7d5ec1ab457f857bc9657c7905bc0558a1c9d836fac0c04ef584536dfc5482355b8d1f7d5708a77fb584a28aa5b3536371e2af6f891a94cfb98cfe3ddbcb7cea87fb320e5a0c60d48eb41688e4ad479100c2406c0a039e03534938bde3ddb5a879d6be7c41cd701670acb1191096612dc5ce16a98628085af578b1f1ca7f2fda3dcfa7abe1e771fb02455fd10c7efe1add61a8000b72e1fa5ea007b6c637cc557e4d62c2094b381133952ac73c34104e9871bffc1e9e3d290ba13e08e4f0dc2c8367fc05e6e6719ea834fe0dd8db314dbdb2f24aa9a55a88a8cbe47d31d26afd5989f70d76af5ff2e38cd0e24a64b00dd348fe15b2e87677003f969673c43cf69997793b55d2fa069a03f74b8fa58ee6df6e081c24124de38c718ae810d914deff70ffb0cdb58189e1976c92453722a499e4ae0ab3d988e4702a9814c87fcdced495b35202968de4f5e889f3e42079e6c82d54f010da4e927a131243071729f2a67cca4210ee11c276072d286b287e3ecf7d55c06b232c64794a3858af0e2900eaa9ce0a1dece22cc7e71274d93896ef30dc68633ec8c204fc19a4ccfb449ec060dc39ed4c42b210f69189af59f0238451f6e0c0f0e0b754207a85b1668b0fc48168feabcfdc8e5b7dd31398350cdee70e9120e24d2b89c2ef8465aa6f6eee1645639b8af53b40fc111aa13cc023342a619b011a680d0cdc88a04867975c50185bb2aa8afff4a60848ae40caea1b2154a058993f9dccf6ab6ab108e1bd2ede23518bcb645db22cc26474e0b5082eddc5dee19eace745d5f84f3c69ab7d9a149a53ebce8caa682af5db7b9d33f9cbeae66006e1ae7f9ce7114fcf1a47c23e2e604e4d7f7a1b01ac793b8d89cb12416f6f4874709a7be6ef0c7473b52e769a80bad892a422273a28ad4c3d1e4fa389757faabc86958ddfb35ed5bd30cdff5f12e1e61ca38ab2421385f8ac6c7669d4e1ee41b2d50279d0c0986c586a7cb3d51d1ae5d0669b68071a1b94323f466e12573887fa5bd3f3cf07de665672cf97833425dea633e02354fb30ee3a7d062585fbd277ce91567b0eb6390973b28bc5b080599c6aa1daf99e7e6f28224742a7559b9da16580ab6c961f019986d119fee8785efeeb079f62f1157f60587284db8df1b0a69035046687d30010c896fbaa88fe27fa30be76c68795f8ab8e744b24aa8f86a2392f65b0c08a3243ea27358b5da91cba9a33ee23bfd6af4383c6a95a42280561156970aab59f369d195bb49c257c23e45c22f07a2a990db92fa63f9c2710d4b0eff37bf36dddf1066ae53333c245562753172bf4b0dc76beac5aad14dff20f72002ba65136b0e31a7d57db064f8f78285f1b09c4be761d3f089ef9d9ed5fff8e8dfe838910b3ede806203e4e6686eb765ecd38722cc7650b404ae1cfd69496c9fdbefdded12efd22a85328339d48a162538f1b6b8eddfef28bb12430409f152aa6b392a00f15671f5c61f0b586b27a3dd808b63ed01733a27826fa4e6b2214ba78c00fbf3679e75963c67611c5f5021e079a06d04c424673c3f596e45f5aee6200e3ba39e7fae9928a9753a924c051611834bef9a6fd4f743f601e2f603d86862fd59b8adbd6183c83a6bd07ec7d513afe3a13628edddc643f45126c0ec745a2b82ea7b94c12cf0ce6b26ecace05f41b063613c4396b2458cdb655b0216c8d2ddd8d90ec15890ab9cce60f6b2bc8a46698c9bfa4ad110b41ff78a93f8a36172d3389ec8f21730f1587359f15b0758ccb163a374eaef57b599a21c012c4b789b3f03d792a83e404d0a11fd51273849b2f54673525fc58a6d06c26acc7975f50736610ecc5c1ff7c7a3e1cf3d269b8eb2d5f222e4fe4f037e5be461ef2be71d6b389573df8993aac98c6a915333a026849c5d6f92b95acdaec95e30da2740f74cd1f373b97ab30931da05bb5926b9d790f3e2484af063899195d32e94ddce5626108dae42cd73011ed3a06e0b1f2748569e26c4728d1e0a941b40be3b986c07346f59c7ea3401841250d8352cf149e40af50da3e7f6fe5359c53492e489827b7a2caabb37d7b65274b453d20925cbfc4b741d4cedeb9f86e669a0cd7ae54831627b0de8433c2bef63752b338a004ac56c7272a924e52fc43d49e3cc44e651306e733911e06584c2392009a0533bfe2f354f7e11908c698953c38be4a4580e1c8c92db1aa1c5232bd397e743d2311f5fced48d6691f9d52effc0437fe6dcbf2077579a9d5b11f8fe64f40625a569c641b3ddf6e0fdb061340829d86f5835023200b502e8ee351b1e362c80eba458129b6e3770a0757362004721a34c495835c29e4689f1e027bab86fca43b64cb1bf937ade6be30e36a223f43cd0bdd0443cf817dcb8444a7f556ad334fdc426d3c4de4448bd7b5d722b9e59a3b2f39df697610ecf96eddd3a1685e7055fbed0f632dd8aa7e79a5bc763a1cfb6347dd7e2c9b288543ae757c528660bf2500795da19e7ea98666618817139cefefdb8f385aa0b36c9fa932dc25db3617f7544373fa5a13ee868e6d74360a2f9815526fd2623588ae85a159d17b7f5283b347daef03bc0c17ace7424a926005db8513fd8601efa3c198a039d15eb0dd8a4cc58084e05f19be85373db497e5801de18e7847a58944699603ad81f2be0a9d444941d9506dd2920353ad3f6fd3a282804c9bba730b2b3e389aa87e199c0c17e85300bbea32f6f353546e6426c869d9a6e90e4f5cbeab83891eee9b0665bf0c9a1b6927ada41f6c966da8d6bf06aa52da153ec6b575545fc1abb21da2ff5561092543d5a916cadaeddda2c685eb6102fe07db334ba5a75c39b7c15317d5bf833f95bc4a87c5fca530535265a6e3d6825210fc17c79b7ad544823b2e244569d639a7af56d9c1053cd17e215a57af17629c9f330fa697ab065ad2efbc98e0b383d363cb15a26d087c8eb6e9f6344050deaf3ab0a18b25336f81df92fdef2e51af8de516f29689071cff3545e61eda570f033a7560bad5944042828c8968e416535b9dd601db062bf8380710211eeb7e4f258189c1ac0d44662e94f8f127e6dab2dc3f619c71c653f1f8923846fdcdc6f5fdd17ac90bd8cf588d565a7c2b78eb70ebe750192d4070d2353cf0c4225356ec78ceda33b6d61a66d88c434aa08e65969d2f419706c376704c61cfd5e38710a7c8027f48466ff2f8c1181aaca75bfcdf52213a4efbb28c520c2703eed8ef21ceddc428ea5a9dc8e63880ca81b65c2ddcb76db95cebe4c3e9c06e72ac4e47012bf4aa22595e9240c9071a463894fc8ac2613b58b1b2294550b34346b7986e16adcaadf6c50d50f09ccd89c9db6fd6565b35c253d561a8db28b690bcd9d31cd63934c38e7751dc768c34d8d913ba6b9cf81fa8b64025dd13a42d963c8d0e2979a8d3d7d5dc75442cd64e834109d99262fac56ce5d56892d55b3edcdd4b3e4fcd4c7714f2003f4dac367c3fb4d406bf795934d6d58799eb6a75053b889c7da74137a78e64276ee566d3e7e9221ec9361ef241a1ca49cf9512de9b530eaea69f9b0ed070b9f0e021cd02f714a55d84e82b52512889e5259d1ce0a36b73a45c0cbf6cd1b646a00a7b53ce9f655bb415d0c4ad4c8f896af83aa52262722150aef47ba767a4dc6896bd380e010270d9d72daaf81e5af097791105a488af559f1ab35b727e5623718e81264e6df2962386d173b736c807d423f50efda2a65f27226ed4930644938d862f67bae0b8f9b4e2b96ef647f6946c3a64d593439603daad4c1b03a971c235c9c3ec85b19c00925970d9265e59bca51a598272c821f8ca46e67999790fe7bbde5bf96ff072e64795a747dbe6bce95e9c1d9c74ca04dbc27607294263eb41b5a0b2cd1c6f884455e627e20890f26ecca4de6ff3a2a71483b3a921ccad8189fe443e07b5f39b7515d29d43c0795f28c6568d403a20abb0f970a183de424eb2d47a6f40d0d55cf7ad214cadc487ea6189dc4050b3da1831ea2e482cfcd6018a3f77783f3e20f0efc76fdcf2b0d25514f641ba118af6224ae17a077919ba907bba177ae1935ef18b576f03f95a802bc3f901570505273e695119161da0723dc8893606b2ed2d74b68566cbc07c17db98e635f7d96bc73414a3e05b75a9995379bb00f145abf16caf34977db375b7320a80701e4c845a0982c2a35de263992fdb23b9dfcfb28e4833e63c6aa6cdb395fda9225328bf42844dda271ba4befb39817ed8edb7d981925919c6b945172511e4f3e6981efd0eff461745cb83fc21f38273418b91f26f0699a66916d198a19b9ebffdcf9c9805e358aa3ddeaebf932e851","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
