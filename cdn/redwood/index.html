<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ee3efb9d7db88152e84a5b0786ff75449b7225a5a960a8be3a6fb7e157d0c12b7674b2155460405130d041f1cc61776d248053b5eda25db077c389386ac7354195faa819fb028b43b3e60a76ccc87764f6359e4bd202fc7df83176eef17621cf2dd324acf555db5263b0008e20bcefa1024f7861eba2d8608f2696905d2f34e2678f9cee1163e1805b8938a2d8134dfcfce7502fd41f97611f2b0060face5112285949cbb0227b5615c289a42315433bdf1f1b43a4dc5c519731a5bcebb943099bbd22bcc29364ec75d993b0dc5d0c9d7f67c034aecf7445ad8f29bc348aa8a0d6af73fe67200700870439fb28a5d04c8e22385117509e2343743eacef392d74a9fea93f1a2a9a2547977ea42469aaa82b65cf881db1c2b24895f14649e0975eab7a3bc675f7cb87f2c77c80483bd7e482c76a51176fdd9b4ab17292a2e34d868602d8495706668397aa5bf5f1f4a2541720229e9a624c3521ee49522095b7a56842630fa4deb9d4b45f235f20fa7ecc04b1f98d9f72a4011a18b0052fb9c70940848a7e3abfb1d9b4f5eeb7cbf71b069d64b186697e1519c7f9d10072388ed78f17d6d054c7672cb603ed9d64cbb024ea247001f1722f249aa244257f79fb90996fd359fe1168506243687aae8e854e71afe1bada38ad0e466152f716dbdf2d5a225dec821d94b48e831d08f77cf20d5a7ee4655fd957970ebc6ae71cf2b721e12fc4699b02938fbe10bb63653f45f548be3a33330f665b8253250d15dabdd4af39193493e12c9d5f29b15d6d7e014837079ea82a910a088c813b37831e1eb046bf47297bd106645ffbbc334a3a3ed59858902908bdf3056af3aadaa2fe00f5a0a29461f15020361f3cbafa3f779b158521eebcdc7f910ab0cbd1b1a8cf33e8724ea604ac8bf54ebcd3ab9b6eecdecd0dbe925870aca2911cc4dfab6a72aa14336f7abc6bf705fd3b682831153f15104dd654d156838fe1d4b42ce17120c826eb6ccd1982d4eb2532dd8d18977411263c92a086c585c2bf40dee789784cb075ab0c49b225015ef07f4b67c6b84c91e3946cadefae31067b4731a845f51e5a8418ec20a4d7798fb6b58243401e20cdb7efaa08c3774198a7ef100cb18beb4e0e2f5413d8eb2d8e15209800f40da0a3582ea2eba23b356f6a2889431935020b2e0da0b379c1e9ffcb90d25fe433972a1de29ec0ee28e8fda6f82409d9c77caadcd11ede15668c59451d59e2680fa466b0d8625843274a588f6320ea803b45b67c0a096bee042ff0cede58d90287f5cafa0d118253b3c0d40fec3f9574f728e7ff24261e255f3cc25ff22317ddd95f6e653096df7cf21f4648d7992b1f3ecfb91f0bc30aa7f88f055f4e1a5cf17a572f073edf62fdbf5ba6c026449055eda78cf8666051f61127858c2e4474569d5a4ff14412eab7f99fc6a4f1c01597d871bd088837811887fb7aecaeaccc3d99fa46c84f1136cc5d7d670102bf85fad41d48a87fba60cb27fa2313013a3f68001f0f9c4a90bac4b83765843fb4bfea805ba9a87487566d27c476935511be30542edffd274abad7a5806df946653d9db370df6012884ca5b559365134e9617ae6cfb4cd0b913ce6dc671fa61a0a8cfeae5aa9c96259396208ef3803757c1b0ec7aadca29f67638e6769fb1ab3363b466ca9b94b7fab95301706769cefe28222e03cfd713a52666d51a57e6f3a5bd77916db7df186952c5cb1cc0822b0c3ac20087ebb2a41b3e6e16d0d90b1ac5d6e38227d4b89fdfbfdffd75d5ed488a5d91ed6a6fd5c61b159128ff09dbf4586d91fb2c1e54a4b7b4442378eb2d237dfa995dd505d8e154040d026bb36f504a51625e40d0149b98c78fe06a6ce179d858e2d0bbfd51a8c7f23055130cec9e61fec0de87614d93e29fc406c0232e6dcce77da0d089c6967bcdfa70f6077259d68e2da9fbc33065c0bfae53760e55566b6ccb0ad71c17fb948917b49ab4eaabe7b02ac04ceafde587eda76184101ff8b9c68d415996d9e3ee0b40a57fc0894ef25779a1322d9749c73a32f8c42b8eeaccfdbdadade91d5a3ddb9eaf6d3428f613b54d8549b2dce89bd4018a9f5fbfdbf8f53e7bb5a17ad1dcefe6ac09bb3a3aea688e238af43ea5b2f80f136220c551d13b345f8592fdb73d598445731014e8dfda4ed7f390b746545b81bcec02acbf1eef6daabf24ffad75c2f95e1099069f60af3944a134383148342e27dc3656dd0b88974c92f1cd104d7be9fad6c2a73315684f90354e7d4fddc0cae72732583e202ed13d5c56666e4b4f2044202e6dbb985963aae83c1c5a852a6b170f2f0d9576ffef772593b25037ff180d14b8da11c446d55fdd29274657d559003e29fe601cf15319ca0a3793061ee09f5bcf853a0aa9292ca45a307af374c82241289963252a2afecca8535f686d6e4e7b36fc0b9ff63256fcdbce134634d1611113ec7c0f0e3cebd0b40611f662c8daddede83fe697b31de848cd519acc0e44371b1fa0e821d2e2f62c8a8702cfd4a9a5b02f8195c5226e5dbf6f7f112002941e4f1174d780a0a8e2f3f68d2c62996951e444d30b41cbbce3c3d6e2fde37548c2344da76d7a3c4cf6637d6f0253e47519993b4aca4f0fbb0558e76b73c5de7c9e16dcd390c82ce07e9e639d3b5d383d892cf7a5c9a72135100e6edb8a4561181edd6ba0a423d32fb2c7be59a37d7f80fb5ec051a04bdcdc1864c5e0795b0f3993f84f98d1d739bae45c5b6580f29bf0c2be5e7a0e165647611e13190f25e6f2ad10f08c579d245bb023829d4080bb59b5a31a0d96710e526f73b16647215ee48b2463d46a81076c12c0a369e3634f31ccf1dbbc0e35d5c60f6612f727537a872e1ec672e590a7c241766a43da8d6ff737b4a8f59ec01d0c751d87abd2dd564cfc9b8b929d37f89a9b18138e39b579734c79e55f9c1656c605388a9c26c3efe4ab710ef18fbc1a059219fb413492b36aa6050ee3a66db1444562258f6106f7631f9002c14a7e487d8f47056906d2a9070be04a875f69c48b910fc5620b9a5e588025c41f771e6ddea653937edba746f41a1f218c231dae61f5d96242a0882890e6e8d04bf0ba6989873b2c843da6c69f5192381efb03bf35e41f83ea547bcf49c11f315229026e32630fbc7016a3b6a3b5158f9a844c5a7872a9f28a43cafe6b6e6d3eca8b8ac795fd7a927962bdc61472a8c6a73cb07367dd1da4e5ff41312b50d72a2adf1f9081d748e1ae26f162b814bcb3c8e7bd0acfc1829637a872e9fffab2a6e242c91d6264cb4050c7d3539563a05f92a5bbc12cbf7bf2f624249f9d924d75b1aff9ed6df5a9f09226982f87053f58ad426b3cf558005f00ffd37697e17ebff1c48e4ae512de26da683ecb3bdffc6e44835e84eabfa26de89f97f62f7fda3007dd9ad433f41a9923905ff178171feeb31ba5deb2abac91d10faf2ec0038f727e7ec6ef20541b81b9157d601bb600d2b417d5d5128f7dd982cfe3934088560b3c07aa297556d4c89e73c5e40bfadf13cc0af2c1a2edf0b1ce0c6114509e75fbcc68b854424b280471acd20f9f17fcb33e22bc9a89c8ae63dd531148ccfc5698d329d4a86927a07890fce3a764e7581c8af2da10c32e93d6e108ae329144deaa1bbca17ecc45c84f242207aa913e25df46e18fa218db8dc4e5106018ccb6c8076556b273c043a99d3715d8941ffb8911f75688df8065e29df08142be7a59560d6a1f14b48f0ef09fb2e1745fe42be0fa5a7a1f3717556e7e80441405ff4a8ac7512f81b5c0ca819f57dd0a241cc52d69db417522491bff38db9e51ac54368fbb32593e9264168b79ac3b22a1fad75bd545f3ec06126bec905435a04b09dd1011bdd3a6b5de96ea34816e54c67478beb77a863f0f78133f4df5bd4a9dece2ef340d0d2a39a740de92fc2ebfa11c976980e76666df0110f3e8e51e8afede16a07f4a37f3d697bc2ea9b6d10db460378eee0fd6c590818ba584a578515050194c3f0597e2349046ff6511fddbd65e3d0c758a211def638f1216648170cb4c04ade266c6e16c3ab2bfe513838e5822d396a6aff8e81dd9953c46b80be522093fdf0c3c47c66655a7131a62a7729aee3b7f74a2fef36bfae5a6739139e1bb397826f45a4e7753955ae18a9100d2f2e0ea5d098b602c13545796720babf4a5a988bcbe4a746a96a9aa95ced56937ab70d4ff702a9bb0471fc7255e93864a6fcae86b3e33941fd6d4273cc19d6ee83554b44b56ae5e0417fe9f3989f5850db3940579af6b2bd71a27e99da2e0677ba736e6046edab14b21ac6b97790d67a63ab17904718e61e5039af1fd59f313ce0b9beec48f5debb70efa5407626b567b17e4fa2189dcb0edd2bc6794c443df209d727f40f497671764040dbfb7b11292b46d885063122ced7e54e1f03c76c85a3ef0a822275db2ca780566905d49c87a81fe43de1d648eaca287ef56a2f41ad1d51f8750a207a984357e7ac0891adb2da0e85f777b37bafa586db0e9d67dd8ad08e551176b5ca52e6665e4e333913204b8d5d02ac169f6d38d2d0bc87a09c848742288c95947f6359f9516e0a921384ec3692e4e8861640cfb61bd07ff21a9b4fe5eb678de8c1c44c255e930e8061c0737190d90f8d12dc9317caa5b97b17f74b9523f72a0e30f41747b2e6957e8abe36801a47f1b0264a52d7e62cd1799ed02f4a44fd69bdfee6a4cb60a9fab597cb39e51e2fe639bcf5699f846e4f5a73146cf1691122a6bff788567453924576354f42fad5498d170593c3397ae0fdd4a4abfef5eb88bbd747b92344eddd7d9233b96de96bfa3dfc6edc8b5dade76a46a4316ef5400b6c376764d0b619d069a2fc71fca94db745d6da58c2b19a7c450059175041ddcba638557a56737ecacb5e87b744dbd1f0a30183fd117d5c9843e1bac542aabf1a13296e2498bf538c6017e866fb322bc2bd19d6a9a1e0db60390f71372cee5d3aeda5a37c0cfb34a3f4418506a084e275c7002f63bcac5c38ec1078cec5ce694f2b51130e56de1970a83dcaf5f497725fb7cc73cc046962e98afc7a675bbc8f23e472eec3883649ed908d0b53bc69cdb5a9fb24da3c6fe685c085fa3d5278a246c905197698e1c36da7566f992127d025aa08914cabe6bb06aa372057509978b7f5eb38582e48ac4c45dcf4c416d9fcbb8d794232e293280c23b5e1c519d15f4c8e6d6c4b815b58201b4c41b948003d6e297bed24c08cd750c45359b06e57d4b0b70c396cd18f4768fbe825c85cc2af71c0123429bb5c8aaea89076b1238dfc58b430774bf39d436742fecd4b0c9027542a317767316195e807bdb313c25f2df4367c91a8e02317b77423fa33ddc7c07fc2409e847555b6dca9b670f0bf3775695ed5ef38e4e03c1e665c62671cc9dba7b9e27d68c80ffa26c3f19d6eba481d2f14bd7edcaedd925e2633d8e428003f8d4d7481f738e67935b3bb23f0e934efb8230efb4fc858c2fc165d2ab1d6331585a7eabf492e33678846fe6b3d408277d8adad81bfdf87e264a3f6b107137f50f4bc311b39d199848db974b31622552e618fad68d621ec4a4ae9cb1776a0bf2dadd4f26db7c8946998addd353c0fbb54a8b55cc74169020ed099937353e81d71bee5886a0e760c3d9b9a9c369f27db39e5a4760dcac252aaf089cb0c6481c92872cc7502ca5f6691a230ae374e511d98abac5755e81bf14d60e3453d04d2f6daa0232c9ab61c437d01cad25391a5dfa98d056c323bdb47c7cadc8da22a49e1ca5b487755bc75ba58d992dadc698f12687764baf95e07f90e81255e4b59c61cfed20ab84eb3e4d7320f7107c735a2c8cef7649e1c4a49f6c64dedac4c86adf4cd389d8ce0d2c064e6567ce630acc1ece66c3d075f44500df47207540f9e616eae6c0f407a55a262092ce66a8840eed569955edab58aff7fa54482fde838a2aa0e2706598eebc72d539584bfd32b60f846ab51ad91ee5c53a41a3edde65b940a42dc6e8d50731e35e80e2e258b7058a1baeb281cf43a7d9496a890692e0c0fc149e6241c808d8cee36ea9a772613aa4893b9b57ada4b7048a02017957a406c4fccb45a79d2341dc34a10510edf5e224d5916f911d2d6c94c7451bef09e417a4fd6b33be91b8b4fa0fec9ec6522040bbba71847ed258770343ccc7eb786531e070eafefeef1ffc0bc698d48a0122f9eab094ee93bfe5f985a8ab242d54e69644e498e30394be1efab9ec82540363ae15f87eacd0d75d81f79325949f4acef8b0d9aab82f50d8f5176faa53ade44538eba93bf8a3dc6a85d606e91158638e40a0091c52f780a3d8fad46724873bb571dc32307d4a5d07b808ded059116e5019ea03b60c6feba1e1c1a880ebbff184ef05b8431dd17f8a07e40f982a7d376c1223af5263fd4a8ce6d1755fde8cab01793d57217b333b78b88fb7419497a2272361c06c6a96c2014255c978ff6341fbba3b73d8ac67ba6538fa1d52f90d1ff246aca74b0fd121ff52a0170f89896b1eb4bd972ea446d4f2a150c3de0b234346705f7825427a35b1174d8e691bd4b13f8b4988b2f7677d920e5badfae35dd8fd2646791cf0e5832d7fc75406f4cca68688c88eaca14166e10497953b239e5bbeadebde2c2d0fddba7284778e18ed4c884c6b26ff059871678ecef8df8d7ef102ae91e4f27236069725c5cd814ca061c7d7c910b7909e258d0b6b46ed682f72b9d26cd8e8fe46111637a123a37e11b50f47bdacf814e139d1c521678dfc403b05cf0c811f8e3044da8ec4cbb21383c4522570cab8bbc4edbdde003f46c0bc37a9ec947e9bbca842ffe3a06bc9268e630fda3d51b478424e4a9853bc3482c30c8e3a83703ca968ca4fb3493224b82fdbea9c2f9f4b629c28242a72c50cd4f9350d824793591388bc094ff6cbe7b5adc3d3ab03d4332dedb705af69e6808cff63f3a6449b3207e718d47c7b0867634b9ffc0769b7157ae44f4904e21c5d9779b3a2e23aa4a45e0898b4a9e85ce1ec7d82a22cef6358739780f8669564a9458e1fc5c4ad9cf7ef01a6fec6019d4a6c8da186bf6ba886c7cb1d456e16f790241187864aaff306355736e5eef60347e11f66c2708d769b5922787428d31b08fd58a8b7bd20103144cf63fa7ef83e1f8c849cb77bc5ee2676f442185e61ba1bb5584c12d779bada630c1dd9c0e0f9f52817d174d51febd8e8a3dad82ce560fd5b46b79283e905be70f4148f30ef618c40cdd420a9d97afc0a40d588ab1af4a5570da9734e8254f71a8f40d96ea4173b0f033f8841b189524b88da310d89c07fa03ed8977f5ca0c026da1207c08b2e3b479274ad52a95b36d6c9b05d7969bd69715026272979fa315c4e193ef0aae67d029ed36ab253760645e24ba7b4ac5584a6dca002b820578f1c3dea0b4571447e0ec5303519b66f13d28de32fdbdf5c70bd9a97d14b77f71cbf557ba65e2f87723791f3034712e5941e58bccda5c494edf44e3bf010d85a76198ec24cc31680b10926430032ad1141f513c867decba1393abe5b65752f82458a71ec8574425bb0aabc21c295f42887df4011c78e66866a9a7901981a797cf931f35c20e887347734313538bd9e31577951868ab502eab3a38d0d1037b4cc3fda063da12c0ab1f2c61622b87ce45881f770d95e7b433d31a467d7e45acaecb93b92d7a18bf2ea8e21fe93926c4f115ab37ff82903f6d191b62e1addc765789cbf37d241ec11d112305fcc72bc4d29020e2e8bb8e8fcf0c839dc67b005c88079fa99b2f6a920e2b00570e7f19307b437cebd8fa60a551d4a25b77f7d0cfeeb865f0c13e6789be5439c1dea12efadcf40c56db89e0c5d84619cf89c3cad849f4c7e36e0a8bf2eabe91d73c6453b20280320f1f7b2f128ef8b033fbad6c7791d96e270988fce875c6a73654e0f7b15e0412477ff7659fce38c920f4e17d17b22340f2b33aebc838b00eefd92d5307e4da3ac35a2df76a959d047893f6e9812fbc4db9dead6853f0c597fd7df42a43a6bc25f930c18a247f6f00f782e5d90c372dfd1b528cf4cb09cdc788524672ba312c92e923e81c0d388253f877ccf003d793854a5855125667091f933448a4f3dd2d79ab74ac4d405d268ea87b287fc03e0ade225c88e0de5155fdf45da7dd76df32ba5e73fd2ea25db71e1f855758777e95b00f6243cc5df1576ee40297b9e507f982d31b082ece0d77656300777196a7f1d32c75e24ff7e5f85278d5db5a117e99ef3078bacf5d0a5c75b541f69d1a98450cdd82994fbb875075b108bfc116ce419338ad6c7d98f2f000e80e9d362b1186291bc80383c56ce736d6d74df9875bf613751c360c409a3f9196542b8a2a74578865408fe229bb502f51f50266ac39254e1e17373e3e763b4b1d88668d38392ca4ba9f868747ef39c753a1b59ebc90935f8200abfefa0ff714157cb5b30d7b2a8a2abb275ccd1cfe860583d0522caf504eb7acf4cb2ef447ee243623cff6ff0407f9019da3b2158dd7fb76a461d817c23dc9d11038578af3928ad4b6042a5db33515c5dcbfda4708b64b857d7282d1381061147044284da2206fbf8de11bfcfb51f5d4d16e048b73b857ffd7c0a2ae0383050cf17a48731ecaebcb045be0e235a2e16a46a4ae77b75f791cdcb510c9e10207c1b047634413cd0e1f5b8b355305bf7200553f0419418d012dfbb0b14b7a3429f5703d4ed235b4b02ce3cdcbd13f6780eb59c013877c54e2161be5b226d6234ea46479c89da3ace020aa49c45c9da102e8829e69e04f0e732151bea643e3d28e7ca9a9d15b863164bd533a60a604c79aebe3402e58f43707a4c5fa8f23f9a513a4229b92305809de4c15a4a13363b73bf8a93a4edbeff69cc2d8950dd0d1fa54b0a58249f86a40e0e03fa36eda1b073d4217540bd493110df4d9a4fc0992af4dcce284615ded14880454d601b2dded090bdd6e04673c7e5f5c52be75a69c80e5d0a86cf49b736dfa522dbb202bd7f842e7823f381064e4dc0738c2847bb61a7cf32033001638be4c8127c14d7a08bb3ef67ad63450f134ce6114438a20dc2ef4a4dbf69ffe5829feef713e5ff49e4b89b3c1089561b38963779916eab073990ab33ad6cfb000c011653e0554f43716f7678aba79240a63e578a8bea6d140c4e180c84ff0af000722246630840b5df43609c98562248d3756b65f67f597afe9ae74c1c88a49b4cb01923aac74ccda40ae27913e0542f175f5ed258d9ffeaa45cb3bac0f1023686745b7e42cbf35ec14992858d0e839e9d774f9ca30436bdac93b528036894b4362d48cbe067b37cf0c261d191579995f2ff225d18ba7c23eb0bef56e32461f2afe20dfb1fb8ded05be6a029bcdecca5b456809d9dd4a97746f48d5ef410886e4786c6f49e2ed77d0e2d27c538ada5eb86601c29141bb2c7f0ad64116113f80e067f8d005ed125d601baaff61c2524475c976f01c9e200e40c7bba9ddc0c0b65208413e90e2dd5ee49d28b8953f944cbc4a66a19e8b4ed133d8809da6bbec07d1e1eed74924cc7b3be672f30b65163b8d20350bd61fcd1c1888201dea7d34afdbaf6c29cb5a29c0fecae9ad1e6c0455b6c55be42ba3a8dcf060e3f32acc2e628cf6bd5e42d25b5a717c8e7d505da9f9b112444ca68803bead4b0cbe25ddbd98451ebd22ecda00108ce8873fd91e94cf51a09a7b42c34df23d5f96ff9ab0bba89c928a36f24ea7135a3afe962b8d8a6cc2729da0fb8e02900736be48379c40fa657f1dd9ec52554e3017acc5e95fecd5510840c5177b51e160f304fc6b9d3dc1a668ba09c16485981242170af26c3454d6589e3564c89cd746bed7c4baa98c6312bec338141b418e0d11f488cf2eb1d1c01e16448f12628ddec261450089dc848030a0f59e92ff60a716b80172e0c072d3c32d4b8bedbe8a0bdf2dfc27db858a8fb819de2afdcd9a35386d38b4b40b1a2a36a741905b4ae84c319d06dd211e8e09b07b58b370bd8b8c3519927f7494551ba52f5e754ebde0ce70e8a15cc41321d162f382d792cb2eae3a67cd4dd2207337117ff7916ec9ec8525c09f1f67b0a4364e6a7d115abec5f435b3d2ed06ee9ab895af72c5d36cfac6d82a9820d2307f3339f51cc7b2344ea2b3a34d2f1ace39ddecd1231940429d9127d90682cff4197d09af4f9d5a72b848be7b646c64a6148a02862007ae007fc6d69537c2878acbc1cc7b7f56c2396fced4abc7bb2d9ab2b817d65f5a17ab7698649ec9ca0e8df2ddb16c21943e779cd7fd0b7be2d244370559c961ba80d69b11ca24063abe8db6d69ee86db08c2c918c3630fec3110a384e4f18b8e4c9a6f876e225c79c5fa0a1fb4ef711ced55adba12869419110d35609ab1bce0fb0b25c81bbcdb10662f7a08b00029a97845ece0e4f898745fe921ecc58e032689d3c5ee9a479e85499d0cf98664558cf89d3a7e551b63823b5635afa208114475b3f408bb1380ddce2fcf92993ff90ced517757d47c163b5a631d256fc0860dcde35b256d4dc5a3e8960be23b292584af5fbab38de0175d4932f8f362cce5b1612f2aad94112dbcb9b6dffe900f741494372875d6da93e4b40411dc1a1fe7a1042ff35cd7a6bde7483e9ac2cdc0fa17d3baeaf7006fe99e7a6cee967bc54c0328e1d04213da363a6ece5a194aacd22541a7d5d34c4f8d880e9da80ab56d681fb795e3cbc7b9996229173b92500860b5695435593e7a63addd2110c89d364fe1a0e466b310af388f65e7142874fc2373dfd67f7c719be796baf409aaf6a804d4e67d11566fdd7e90f17aff0beef056e49b6d32a6a259e5371e13eea1f320ac640cac88804ef1ae7b1a209b5b9f752aa464d7ddffcdb8fa7ad6ba70f27dad0c489dba793f0955f054e1c78e3e509392bdfdf224274ddd0583d3489c0539dea5fcf476ef92d900f61b7076b77998197ff4838efa5894d2f44c1c63ae477a0960ea1593ebaadc903d42cc0426c7299bd4843a8b34be7ed9a2dd525e4a114b5dbfe20fe2fff160bd31539122d1161b9b4853333002714a93e330b516ed99ccd0de069434522afaa1ee638c9ad1b7fbf760a7cb8ef77b720278280c682a54fd3a319668cfdee885f03bf5c0914fa430b6619d82ae7f08df0cfa330233f1e89f187eedcc2714d3c16053b8efe5e89fae1cb590965b54b5df44b7a8452ad0e4c2214a290fc4ffed84a9e24bdce5da52ad5a3cc46440a613810ee06876b41b528488b307aa26dfb9738480012e794d70780a695fbe2fc5f39c345fe9e7730677a5b0c19a83262aff5127402da59b6ee3745ab3c22a6e1da9763ea5f653f79080a9179371fe9f97613bba877889e50e7c76ba917c89be4932cf4e9b9c454e1828a7b85676c98883928533ca14b9c33d1ecad07fff55e4ff4622df2e20c6fdf5e103055ba00beeeebb221e82d1c17a531e0f31daca28ded62b14fdc318d41bd2dd923dd6dd479523b5df1ad438b9de36e69959053617108fcad092c3c1b490a5c415fafddb25c3659ff378c013cb5d210107daf07553015ddf8b916da6d96d2339ebcdde250212ac82956db998d1055a66ab4fa392f3f6386cf96f42a392b2e108e1b3da6b3d1c4d8683f118a7a1f538c4390313090254789e84a5c8cd32e7762075a46d2b4dbd9456af68b1b00b37ebdddbf656ef8c3b6095401bdeb4c0f790ba7bd65f2f2f1a1f604b909340fcaeec210e57533d81742ea19cc426f7b7442587e3116785eba79f7b687c2c96ee1c0815903dc85d9a1b902e617318b1cfdfa1a4a76393da66dbd0428050180cb6563e05ce6174f9236b5b559442a5855081ea70d3a3f9a0d14c27926aece1c02cb58211a9dc8aeddd7f7590bdc31a34269e39b5e1522eb32c1863a896412fce58e97c34ee38454122a593864b30a0cfa730d8eecf1e5106dcb973d40945f8f6c830b718129e61a44a6efbb46a08033e0caf5f1803f791e6a7360de555bc2c276d9f4d7b87a3137b110c53f17a0df02c4bb140bc05139d8bfa10317b80cf35cc4c999daa9ceb17b42233b0739a7f4a78f9615a2c68f82868adc88ce8e898042e448cb0c5762f970f10cc2c61f687bba4502e63ed35899eec9e811c113d98a21d9a34eb737d74fa39de0c85beeee95364900000ed656615fe1f067575d7c3be6fdbe41d39b01916b86b190eebcb900c63f68734c480e010d7f023cd88f3bce854c74eadc25f10de18aedf00a776ad55e2ce6680970ed82ad4852fa2b70986844e06e15772ddf18c0b691107f4e0ba878048d51b6dd083c6a161aaa82cc0b718b3f631e6d23fca0a0fefa53e394a29dd19cbe224ea8cb0dee5ca47182144db574a9f62ca606dde57c47fb0f27f8361707fc0b9bd2a667b4d91832341b67260a4a0e1f53352a544ea3ec262ec10485481b6064544ca740ff6916f290868ba92244131996b7190d48a72e1dcd42e3a747b1527a50ac1c5bb9f9ccbafa38ca49ee7c3489f5f5900932ac6a316215acb3344ac3841395b082eb4147faf6c0293e8a38da66bc6ece8bfc0018a10e370459f221f0b0e04209e9cffa959b075b9b17d24143ba8c6e4c6417cbf849324e5471c96d40a3b452d2b71574581745a98a2e4a53c8866461374de1fc7e8cd0ce2502626d579ba2fd1fcf7b46a690bb5011f8b5683c251db708a88e5e3234482372686c1a416f7b5a891cb307574484df23d8ac95947db59244a86ec22f887b5a838ff6e11225fd572e9227d3ac5b1ff44f4db02e5137ff142d18b7028ada2292920021db1a801e9e538fd92a155c85a4439b628d938537f4f372c2281871df65c8cd2fa64b2f427449e7db3fa6fde6d530e317274b718faafaa98e1797b907173aca420e69738b99b3e2aaa0ffa59ae8a345608b6bbd3e4a04ef90b94c093b5b037ebbf844405248f7528a724709132587aeba6b7c1044f91d235756406749a64458db4262296e9683c0cdb9ad5bb422495b976f4f2903982380b3cc40b76fe88f84d5bc01671a6acc26e07e6ff83a8bc94eb3d6184eea02fc0d69568f09626b7e3b4e587ff3bf4fed663d88225ea148ff42c220ef765bfa4efc040e89ee19a1817b02ce4592b6c077c28667502e4ccb6f4c5b91e4daff98e2e6f05102da3c03c956ccc86e174a405aa9bf024b2db16b856ee946a42fbe240d36447244d1282ea4195109edc31bf302885be73c0cefb3e4e2b719b69cf2d1637c984aec52d2b93ec382002db2495300a9cbb6b835151e7f9f9b20e435fb31f1fa04d7688d8061ce561c307cd899c00a90d59bcb53b799475d276c2faaa56fb7cb9fd0e241058beb8b1817d889601c5e8e556bd426df0e9617335278216833988fc5ec04d45808f595ab0cfec220a6a2279b6d68d2d4fe1e01f1995c71e4c2172d596a257dbc023c9c88097f9fe8b33e85e63f29bd5dd5075421859447cccdd0d2d03b2af1d1bd80e12795cea61144c30426be0812f299031b32bee188a07dfccf1673f253f5502f2d043b66f571171d26ba2daf9b6ee63bb2ba2ab51cdb16e1ee8beca92926f4ccf41e68e574777b739b3c9d8499e1caa37e4a82eebb48e80f7eed8782e5e2d4a8afe253fbf153177cc93efeca05848c33a7847ae60888fc35cf574b3e3249a195a5f426ab41a82be980fdbe893c4af039d88be326ff26b89d41eb6f81ef239918377ea8799da60b20c6b4fa4fabda65bcf95073fa3f11bda857cbecab91ebeb9f04d97d3101e9b7bf4c8934142c02ed643a76db3ef9d9a6c91a3544978a64c3775f7060b35260ec591ca9029fb452eb03291853e5d301c8937d1bee09cc4120079862bdc85cedfc3fa589e5d2422eb7997c37bfeae038f9801436b284f0bbae59dbe48bb0b87d7c3d87136d2a5b7408c39c6f86c1969468e4425a2ce4983cf889bbe2a40cbd460a49a7572f8727243d61172d4fefe80c412f310c70f0787a3bbd5052b20e48f0787939a357b3fb4aff8127b6161b1ade6b92ec8b0824891acc238b3b3942c872a619b6f3c19dfa86a4b857dfab1f0529b762b63fc1926dae568cdd12647c04ea7e541eddaf0c732c20e389f1c2ef6195aa184d2a28a2c64bff4488d1462dbc20f20acb5ec1565bef18c97cd104ba911c67c8dbd9989d640ce4b85a1c83d70f305eb0d53cf3a269cdc9499c350df89376544b47d1cda7f42fecb7e39dea3fa9def9311e18270fdf70dc8fce543f43e93bbae5c24d026fdcf7767d0bdb89ddb37bf5a510607222fd7abc3d66f0f15e95a131c1d84f5c9148721a5cc10d1c5f0400522baffd0ecb07dfa58cdb4fbea65515e261884cb1dc66b5f8e08b79ead4b8b3999357eb1a6b18545b167f46072c3ffe6782079f54f220f13bbb207ef25966e2290b555dbac05b38d9f388ca4fcfbfe2fe9a4bcfb5e5cb2030ca336fb1ed0481e4def0a28bdde0d17c8e39a7579e01a263c211048995d1b864c8c158c438f8eb9f115219b97aaae2a6975de9ab5e9b67a2018e0892b12d7591db26641862dad0c83d65bbbf7a809638b2a397c589c61ad9e760361dbe4db26f999d2b25a4b33cfc0f3607cdb0444b219934336b1958f33bfd0b64b981e7de13444e9e3d279024f73e7b6e0ac5c1a23795f5815a306ff99f1778402a8c68641027ea8e092e93987e82dc02f98b6de19fa6352258bdcafca2fd5ca1d687c640934376ac8daa8689d0a5cc713d1cb12168af3fec16178bb7a4237e2b4b8e3aa5b1f03ac2a65bd7adf0f42ebced5ef450e33d1ecb7ae1425c70ed86eb2e1c4678d22df48f05c4e186bfa17967c3d9dcfc3a3e3419a68e105f3def3fbd1faaa8a3cc3440747641a5ace416689e0cd6182f06c587cc833f7ba1a54945e67f8678eec4bf49ed5b7ebd767f666264cb573e265444fd087f80afe8a5300ff4718e8d33a953bee508bd3322aa66defc0fc4a29763059fb32c6ade0e6d3d2f4a6618fbfbf6f677edd4e6a9f581099f008178935fc10d7411c56383ed76024094e604fc160d868f07cace889ea2c6e690ea5a8c827181fbed1e37e8ecad57b87b6be4f2fcaec20726268a029cb3f8371f54abaa9753d20a0e75329d5d8b1bda1d2a8404e8ede63eabfc58bcd41df19cdadf5ac6eeb6536f2fce740bfc2d1e602426d2ac809dc2874f2271e58713b1d6f3e5a3f3c568017fb0743a652baf21c7e8ff2680c2cf5cd95e54b4cf91cb6199ea4345beee50d65de8720438e80f0840131af1b626bb7318443477c5016fcaf9b3ea8172bfd92921bb9d15fcc2b626a61a2b6fda0bc36ea9030390a6314f63440a3c1a5241e3f982ecebafb4c90ffaddf40b8343ca4548ced1d7a0688baa8b93f4209655bc491a86b7f0d51615d9320c772c399bfde206514145b439fe837b16a13e86cbbf35dda2ca1563c0ba7265d0ca9db3940c03640b05a01b17d6c19990332f89f370bfba77aba4cca63207eb4a66ec72be712ab3764856ba45d5805fe4a6f923d80b91daf8d8bcd2d9ecb85f559f701ed21a6c4b5f1d80c3ab8fde53501174e33b4be5c7c126d7d0d749e8731be68e241a9e4ef90787441c3bfdef6df0b3192c18c9674a99cc1e57cc1af17d2ada9b88edd88e0d1b0d9f84f1b6cbcd5315ed8db3aaaf4019d60dcb54a44ab74e48f7b375c0d2972beba293447665e9ae5752cd344df30d1bd35d968c7ccb1abd508744138804a0011a12c7da06d4caef210a25bebad71f9f5815e2d6537170f0a7097f6aa904a5c6c42d5d3aac5d194ac8692682befa0e8dfffa8df9218334131105a7ee2c88704bad6470dee7e2324f4fcc50995d14bac1fdbd532ea4c5e08a03444f9eaebfdbc7e08760dab4de8151f4e1248e705192afdb043163d65d473d16a23a230ad1146c3be41c27a59264d737f0f5788206c6264f4428254e09ebb7cbdc5008c655e065c4a7770f97b21cfaa9343479ba3c3751491fac350ae430047798b3874e44eab329de921bd69c4a0dd2fc38caff15d26a7ec53f1a068ddcb6a4ec152976943b6d74a498dea92f057628058c85d99d2395f168acdbb4cf09926b991841d83edbbfc8d9944d188e941437fcf4568b550cfef54570943a5ab2e8fd6dc3d9c992c7c4d1b75d3e3c1514da283c42dc507f37546a4b30db845d22d70cd7b488196a42f68881ea64210f5fad2a378999243c96c5efc1e01e578bd75fbe2cb3b146138f4add48709d45ce7cc3b38910c3e85ec6cbcef3f28761d3858c3a9540b99536b71adc53588b6914739c943ea676b0cb7b08ef4d9faaa29c8d06de5b99c7ad06760a23d5e7db1e8c3dceeb37b2ca5b64ec228ee690e230ab058af6000e06a3c1b2b248d6f4a045c7065163206b08abb216701d58ad5e720650846553c2161ee6930fd1a38df5f8d045fefee1e60e9b6abd39e95a375b2caac0d963a86e7daaa391d7d1bbd17bc195fc488abbd286fc53139e8e5dae1ab37a72c32084306e9834af185be466ddf20b21a6e6ef1f5e4d22e3467c3ffe4c8cbe40617756cf99c72f03e5b71a51ac3ecac07b8962651a43dd9d697ed44d6aa3869f090610fa045a036f384dfd8f0219496ba9ed612b47797c0b61042e7db124f029e40c4db0ef179c6b31a43e1678b9a7007c3b8e5f57f7701cd9e47ad28f993c2a47571b82bb6a5b50dc28d74db10baa93ac73f5b6449f4ae176ac2bfbfa58f14379b581ef2d063fe9c78dfc92ae1bde1bd77eb3b0e104c97eb9c60f40ceb1d535ee7279cb6a2990f938c0844186d2df67d414fef1043d045a08ea3c19ca478a1a3c15fee4d576e4ff2f5206dc8364b923a75f4e824cd2fe3ae95ab082dd32f31b2c813100f2d2e3c00a9832e241c2ade4aea09d15dd32f9373d43da14e69bc4968f9367ab71196d03773d485894f9654ca4832be89fc7813299adac8bbf295721c63dba56545300cf358e7414e120410d304dd1b7c0a0c4390dbbf285cc6fb4e9166ef486d1e55d5adf7446307a3017cf253a91c311167e2eeaf687b34500bc60d92efc400ea8c3c6fa73989d99951d6a7e89d9df95919febae2a9dfdd458d95ff5633457a36b05c57ca8f48c1b06efe0c6f9f4fe29d9e5b5a0d5033606b5165ec2ae1a92197caa605a7bc35880732f93f556f1fef3466c14ad5ed221979226b2906201cff39a1e9ccb8da166dba0ac076b06d59d0387f071e18d64eadb65cecef1968dff7887da46c55eb9f337cc037194bf438f2031961f14b4f7402e04f1c6bc672515d8d4ff13371844e8ab80c2ecde4e398ed9d9ee441d4e8694ab732623f7054c693397fb65181f9fdaec190b9dda28894b334a18cdc3c0d94c75564eb9a1259e1a804faa1e508a08e1be20719ecaeaa10992ec89e569166f1d7f2323a9f69fe54aca32f21b8870d1aa9e47411f30dd866bddc6fda5d7f6773ebd6482a1690ed3c8c1f563088b421b2fc61b669306d2a4d2a30da7a730c9514e41a97405da159be53569f29f3818fd8da3c8f3b236943bfeedac21cce4c4ddf30faa5c5132366fd5e9208ccac961b8b62b004fbb5d1e3162661c57d3978fce174aff2b17246ca70dc13d01082b9350004e243eb2b759365d5608dd06eb92f455c8fefca0f83805dca83bd12fd3585f26fa8e11cb4985c5923bb3962b1103c1e97352d00a79283739e84f93ed2aedeeead5060701990fcb32864cf1f7b13d1ad71da5f0d4cfcb77868447449726c894ec454193474fe23696393f325c0c486215bbcd0a4e58175685dd915ae68a7d1b655269fd5d41dab8d578cea10a784e4cc97e5ed5d5f614c63dda0ecb20ee2cd80bfa844eebb296c11ee36ce15bee54dd5fb59dc665033c900094f12fb384247b8d41e3d7338c6227dd5707258edd491e5dbd112f8efefd32dc01cb7b60d88bfcec3959ee78bc52a9e8702250e63d3c4232f36c5b2fad7debbcd119811136351273d2c06addcedda879e660d848bf6a4d0f95345d0c54bb0a58eadd37f30bac87bce433328a35b5c21eadc0bc75c2310f8b56cf6aa97cde5ace08c0e25a3845c71fe22d5d4b165674344318c8b929ac73b87b89eba93061b89484a2d530916282f9195c1f35e6e8d0bbd86d75ab787b69698cbff670fe0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
