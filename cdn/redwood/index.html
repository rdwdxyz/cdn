<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad7fcda6a960aca77a45d634a99aee247440d1df8b5cf185b08df291b62ddecf72e2a316007171f0d3b049e3981da66d594a5115168a2da18fdf0d97bc44b6551f2d642bb28a3a7663fac14f1bffb1ab6bd800057dd6944772b21c0c6128c0e0ed04fc26ad1d69f0ac4f750c03c5499671c1d7a1b801be02e86a16bd9fb358563bff79916c7dff1c97678d8f42c7fa22e1de492a11fe01acdaa3bb13d61e77cb122d2b475398fcf95b8a2db05ebe82e921eecb1b8665a24f0e8d0f8a8294701606f5b1fef91914c4dbf508aa35e7917bea28a904d1a8922bec1c2a3079dcb916e6ee8c80829251760fc51ef169777c72dbee4f5aa644f89065a01a907791fa4fa23b5c1c376ae37af31af71f47647078d9656548afe4732ecdbd37c6e23ebf469a48f4861082726dc8a348350aeea61e8ca11e891f80e570d8e7a23a2759089e729746fc382a6aa1710fa5bea531910caa613951fcb60fc82fc4050845aa306a97bf380c1fb3a2ce4421a4cbabf8792d8e5a992ba4b6573357707bcfea56b3a314daf56581cb6239d8f9b69871e27de7b9c03c02887e85aadee5b75aaac901120877c778b4e4ffeb75d7f7e8cf1cbc1909435d8a597f7f095b31cfc2d914ef869aa063aeaa75964cd302f315bf07aac43598feb00b568be7d5612e59896a04707ac7317c4309f1ca54789f115a776c69ec4486c5e4841cbcbbc0ed6212b7759630f195c7ecba1e637a3b31884e00e63aa5d96def57eb82ec8f86a4ac679ed0a04b8adc36e93fc0c874ebf9005e257f0b070f58ce96acb474408409236fb8d6637c63917068f47ebe9b087d45f514cc0c125b9f1b67ab399e96e20bdc38f88f508aeb0c664c25f57f27a50011a2f226e8c51b96d6d22ce25d60f82c42e3994c3b7a5832354d01646368ce45650ed81f9ae254604dda99aa8bd4cef0ff12c64d919cd82e6f5a1551a357bdfe1e4604ddfee710c87973b888b23a393c8da68aa764b8b6b57eaa74258af2d0493cbb341931e1160b0fd5af872214c5ace43817011e485832d6a3ee3530b49496b1c0cb2557271fd7c1e35caeacf7371a2ebaa009098bb8655b9c6ca780444914a3b349f46a1acfa013bb4e1edd908afed24e1ba09164a47c470104f3eeed03774996ca42e631448cc28237b8044bc3f9ce1313778d416ce5a2cf01300bb2214a41d9d11ffc0a5c01a4554b15a97d146986e50c0c00353d6c91d905a001b56a179a936724355d1b32f26d77ccdc29ca58e7020275174734fccf4e07f450faa19d0797c16ab3de9afff9b58c470176d77866801a68b8f2fb55dd6940f42905c12634383e9859e695f72e877b19f7eaa205d134179e428eadea9103e491ed272f41cf561b7c2c93e969f29ebda23eb245161341b0033839af41bec7fa7fe2c0890ebdadd2c81ea8c549d4b81fe804f9787ab129cc9f9b4356c8f0614d5ead6a01a6b7d4b817a6239ffa88f0514918586b631019bd21a01ded75f5d5efc4c846101416b8674d74627d82e3740398a7b3d028618886fdd6035383e8b5a67d1456e411deb4c7533ab7d936b3ee22a641532c21b0d697484bab4edf4bdff4c14599a3de58227e1ab937a54f828ee558d54c7b130ae5cdf57203f4e716594e6cc7a699ec30796a4009e36ed696038569f1cf598b907f508475e998c4d71900ca85d04c3b0431381a6e67dfddd21453c84252c333379b8308311e940305e48e55bdadd920add019a3a31ecb497df305671efb44323f4de8986581a5cf0bc8848a611265a3088a1673551d3e3b279fb64ab9c1e44cab78e8b99e7227997f86bb4cb52a65f5c6b0b6c8258fa8790e06821c3dba5ccb04a5ed43f7357d088212d1fcdb44d075d68d670bb4333436a576c7f9e013ddd719c97a611bfd84df394a327ce245e9fd30d21dc509dfcb6c05277cd8980b6299746f79c01812c31f0b1f3f019754b114107a04dbbebc192229b6ccef7954c878386e630162c9913f48903800a945f6983e74fdf468f3e288040549353816cfd0d433560863ed9b1dd481923bae13c51659693d292df9b0ef802c2b82a782f71a611b516330186e0b8e83142d31c1f7c64b1bfdc1b4b126dbe053612725d975f47f02524f0feaf7915cbf074deb043a3b086c2db575206a74257f59ab3b91f83254fc6596d3aeeb1e42e18214465be37d12d66e37a4636a6b4090de2b620d7f549c64deb786b9c407fb494ee3272f85e13223045676327bfda0f23501fc48071983f3d0426568316c8ef10cd88590338e34548daa402ea7224aa7783ac1ac51757bdf03835cf760e1548383f5a062f7d75834e041962e83a4f298b80791704742adae32282f47d93b0b01da8c2b9b8be680877418576f128e5d523ba7faad5b275ecb2c68a653fc313d245f82b7e5cebec03c6e96982bb240ddf6a3e7139f39e18fc6f0aca9ffef6c039a314c3f67081ef54d0a9cbce3487b3368bc38f9559b46bf30a979693396386d887083b7328969b7634827de77ca3e70db73b4a3633de0f54ef5b6fa42ef6a1365fb5f2d1636ac4d40d612fb853918e70ffefc25710317c80a496e4adfce4cfd3c7a42443beda58085b11d8da1f3bd7045dbf4f213aaf06b7988c96c961dbce8800c1237a75ee11aaf8ca6060016722a0df3ea0ec2cde74a98d74d0597fe73ba7f33f8a89cc538d9193ddb729bf0cec042ffd9475438ae20cf5312989b8bd45d24941f3ccf8d905ac3fb10c0d0395898db9419bd34778846564b1c5e96067a5e2b5e15d6c85499af7a45cd2d683beeba025f85030890877d7022f3b3c72d6551b65d3aa55bb0ce4d1d45dd33642b6f1a28880690c0501680d317fb722461c66c1231dc070981f2f97c191b8a64aee9464b3691f2f3bdb5d9166e1a8e5764b2d9735042599ffd35f88450dbe47922aa1c6f08885f4fa83d8747c380e0dd1b03840ad10038f14c819f90d2b5494feea49d869e427d13e52c0bc7dbd8d718e24fb69fc1e39d80ab4fec23cf7d2297fe261a79e672beb600ff1165e1ece6dc6b86ddea61d15832369c7e746ef6f6e32be4ab6745cb79c9b4c630ea30f40053c7a78d0cbe10931c580bb4d8fcd0987817ff33d4b269bf0915240ffd93c41c2c4cba33181780e4130f52616a3e64cca94f5336c8aa9b4b2a0e862b7c53953f59e69e37a0bbc77e6c573c3966728cc7b02b03c8413ec7c2f3ea62de6751c77ac4c98c3e64e3b6cdb69bce926acd2626c902f278778d8cde3a1522b20d0edf9cda3c5955e939ffcf2b013ff7355ccab6c4e562654a4ee11158da6398fb00a4965276cbb65da165518e1456b4ae701037122e4de316c927273f9403a43b42d05d9a12abb583317de8816ee7eda56bc94e8c57ebdf17dfd457125d86b1acfaf3c1723e34c67db7dcdfe50410ae2c801bd04276cc758fdde0cd943740238a6fafe750cb52745e9ae65b61f578dfddce2a3f82ea60d0cf7e3a4ba432f6616cd2be03a0e172c380f62049166b9f8c6453ec978cec3afe4f84b09604d4be2ac5b18082196526bd5d10419d9e0e3fb4d9898b09176c68b56c6d255bce906f66a8c356eee8e1105f3b492f3e2c508afd86afe3a6020f2c8985ec7db484e19cb78680fb11e1701302bfe84d35fb2382f358fed4a6331d50d6f82e65f98db563e48ee110b8e3c51c44e3aa4177bdfcfc09d31af35556de0423a7df1a82a69a4eea0ea1ae08d35af0c746bb0a77d1ed9307279e2496c72fd8016475ff8ba672e2eef495e609c86bda11ba03e4fbacc88929132c8e2a07bd1600c5985ed15c8230d6030d3f1d6f91ddbf2c167be5dd6bc340f263263351828fc41d58529aedac3121c4e362cb062e68e5d1f72716603976e5ecef527f165bc71d3e2c0595523f6bbb1cdd14de47f99c4e7900ae3de273c330e7521d47d62de5091fb70f024de54a3b2e125fab09f8b37335c56d0d4cfd6928e1102da5c8d343987e73fdf02e45bc6d8774445d31a33cba04262d21deb2edd213e19cf9ead8bc3559b608daf10a7b6801c174839d564df481d1f0dd00219b048ee0fc741d96432021e03c6139b1de009ef1ac4ad4b52478ec1c5d67d655c987e22f0e944cfcdfde5fb5f79b6f14a5151ae5e37fed917c39764e76f9640e933b19ab9b91d494f0f3d2815dbc2bca1d36e64b7990ac48eef720bac799306f8b8fede2dfda27f5ca995f5cb66eedac3334b6899e6eb166de8722f8aa12157d5f77526a6e21ff61fd42592199efd484acb08e398d6b4e233c6b9da04fe3e76be21a4c2f729472a2ef7e64a098a17735531a4cbab0459b521013d8a01a857d2acaf2d8181236b443814a5d099180b333851e822c41ef5dda05601bbd54cb604169a551bfdf9d7d0283f329d24fb48d82857c66df0a59a6d7933642bba90ab4662f2b58b1ea40f6b59c156a120b5618c9d6d7c63e21ba7e2697a2aa71093278e2ff8e34774aa2279fd104e9e63d8958309221d9b0023401bfc81038a40f332246576df4625409a533227fd0c9dc05a67d9894f463a428df15720bdefdd059b719aeb6c8f770828103657756435b32366b1e50810bc2cbf2c0b679d424394795df0355d7bc114692e9d855ab3867cb1da52b3b85fe1ea10729d8e685b33292db0f1b08fc9ff7ef9785a1dfd26087108263a9f8469c073ec9f96365307f746a92f9de7c18568b229ef82e079cdbbe9a103f95080b820620388c125f0ca685b909b11a3e6f5a8277b2b8cdda5dca6d79ace0fa85253aaedeb6b17461c62272bff026cb88ddeee71d28a2127fb7692419ff1f73eca66e683d3e7b83ca8f45b886482e317486d038aa13c7217c33a3d2a49c51d6fe1c6620461778324fa61c18916dc798ea94959913679528367e0c274de8d0c9bb099b9e863c41808b70ca71804bbdaf2efdbecd5e3a8d30f3e13cd1e0631a01acd2921135a07f7e7634f2bf5835d16f0534da7fea7e0c5d86dd33c8c9fc960a508f98afe522398a4989971fe6bcbe383b12ad91127af66177a870a46e023c698a3b99c3b2116da83e0f2ce1bfe27e73386b0b883504688fee812b6d090ee423d0cfc80f07ea2fba3caae13fde0d3881053f4866bbadb6ee34ea8288cda668ffcdb22a66b93fb30ab348648c573d9b60dc23b616d119744dc45dfd7ee778d510d8d93a3094f4421550c124112ff2bcccb7e427f96ffdfa785633368a8cf2ca45c2008eeae6f8344fd29720b07d28c6655178417aa4db2a471f87a4ef771938cea9d6b216e25e6aa7c7f1279ca533194188a7228a8ca533b8ef3333e392be6dd1e069c955496198e7d71532ec8d37c98d2af86215c3df872faa4a36a1a9565ea5a955630e30f98ff11065b2659ff93613035740dd2f5fdb431dd96bbd7dcb8cab0246568d5b3df975f5cb68fee4170c1e6f288ee70f99fb994d83448f429a89e438d3c446f73a6e92b500558dda7fccec1d0af9f0043eb981ccf88b7271de9099784414d1cfd1637754c0b48f36e32786cfd615a5a3efc96133c56ad75cc61bd0009f677e9ce041abb11d9dc9f376a7a8758652b7b6ddda7524cdab245a1ec587ba84a4397302f5bac2567d223ac9effbe20c7c8c1fe99a2cfadc03bb19991d44a049b857eb28ba23aaae6b0b8bf1139a2940fa26c93e1027805760928bab68259ce867d09783d0e1e4a4bb5bb85ffd1419f916b6c75fe1387a519d30c390f4402f0974cddc3eff32e1207563d7f87d71f4619c56b7102ba80b639069836288f38ee8ddf6da8552817fa11e859afb8c83101ccf675e52efffba280bd168e54515cc869ddefb9c5c8b81fcebd6bcd5ad738b9f0b6653e0f5f8bc6e456db3651fe20b7cc47c5587d35beeb48acacfac7664a7ce40eaa13d540d66e7185d5a880cb4230e4e5210aab6d91b487bb5c66577fa299da92a62211ae5f16069778275aeb6b6d4920475f46541f5bdd45736acc221329ed4efd61ef7b04a344ca3de5ec7f0d874d147c945617a22a5a8e4e1d439d780af7ab99d10e02f130bb7e46d61472855260120a0a9d620b40e9e2f1b8abaeb77c2315c2d0b7edd0751711497308f2de5fe82051c1ac6d532a20fce6a80497ebf0f10fe18c07bfc29722205e75f3be2d08226b2853c98542b50dd776269b6a454b5971cc377006df2cbaf77746b1e8ab22bf825801b6ee0a5dcccb1606ddd19fbcd9a8bf0d918c54ad3c219a681dfbf95ba2bc927cc5acb8594cc90718c0803cd0bf2a0732f82c7cd4b98dfd9edbfd12920b50912f94de1212cdf4db33f67f918dcb1bcb1edf0b1193af74e2f056a502144fe7973aa4a5eff9908e6530adbb12cdeb08a404fac70e01407ba3a5bc674ac3366ee82b8d4c6763db6f307c44611c09e911dc5fc2fba77f9b99884074d8f25eb9568e83d07764fc294a44f595cc5ec979c3ecaaef9745a156124bdbdb4fabec3300066726bba68227bb2bb17d0f033611f603b6305debfb2347c9e8fdc044fadb5f449312a90efe744fa991caadd3e7a32545d67d1f802f2804e7f098805389fcae114fa6937790e73e7a8cacd22a8f301944dea2983b4ea75995143fa372e1ae4474f2a44f96199cc58999f2597093a6aa5c1f9e136f6e438ade0e808932963a027ef3fb1c74787a3915699fb5f46857934ceb795d887078868c183d430372a9fa3b5fa1415e2c94fdeb6bd400e5ad92ed2c95617b3f1f10e496b28b08f3a6c472aa4c6a441401aae49e890e9374c64b5f618693168ece094e3db3dfd4c9f8c37337dc827195f3726f308a204279c6a86369ddac2502395723db79edb8e027f60077b65306242d1bdff955563dcc072bbe4861ded81343c452ef793bee6842e147e05050788a483ba8e3cbe5e048ef24c2beb913065bf7355717b4fe69d95b6f9e8753e1ee7d161abef840af3ebcd5b1299450774e91c53d32e35b2a298c8663cf45797c322299151ded9d8d53dba082e1cc4246437e217df6de3e7650f130e191142ac26c07567da980e7d848a2011a6c2462e7a1e29498cf3fc93e26df5c5afc11500db45f55cd5585e7efacdeeabe794b210b9be9ddacb34d7f1569252b84a9edcc8cbbd2b94111b0ce899a3389cbaf671a61466789ef94c430a4c32b60cc6b58207b58cc7159c4a01f1a2f9f1e311988602aaa28a9a4e0b4f2e840e935b30e61185548c961f917a4e6e0e7ca6a19a890c216dc81764a855ccc484b8b76b37b3b6ce071d0a93a8e6b25cd9c35423aae97ff585fff6c629cb3c4dd8dc35593e5c15ae192cd14bf9a14b1358b8303a050a2815ae61853656943be33ab09de4519d8d697f5a02bf804209ea28130ac18ecd0c8756fb78f0b0e60d5fe17cf77cde358205f56abce677e327dbeccd0363f01be99b3a24077ae67919b8c62cd593fedb373779897fb16f2b3bf04cac5d663873b24a90f2d5df8fca9ecaecd67c61e3d3450df7d03005aeed0994e111a9d4c46923df870f704eab1739c1609c6f02f4b8a0239c0d2800908625d6eedcccd4320f620443ad5b578df92c1fb5b687fea23c294dc832a9242a8e97b708ffddb4ef2326f82dae78cf7e226db52e24697d6890fe7c0afea04f6671c397b638c4d8c807d4c0089da637ed08c63cb02d637b64c2f6e36cb5b92e13d777ce48e49a8d6b5ee6edd684b0081b7188eb4fd2905b0f4d06e2bcd4c6f41ecb0207af21ec97e44539f1d1379b62ea9e37c761372cc99c030542b4f0251a9a6ccb4c16cf4cc6dc116805b1836175da533b7ec251aa02e573816979e8c93b21f94b9a16ba5290337f01f814e574c14d5b01875d1bd329cf2061e192d36f6fca9502c672e2c6d1469d9c636c41858e6713aee7e643bb11990dd9af8736ee87ccddf240c94869befb6ceeb9d6edeab3fd2f9b796b3afb1cefa05cadf8eff8072f82c64561badd13f3d0727f45da2d9c9b31ebd08bfa42099743c7515004978b22c61761f69634f09b02e4b611ab4159a310b1c11994734eaf4434ff168964a3cdc67fa5bb64635336c21d75ec477eed2a23bf4383f781a75f693e1af7f4439a7faebaeea2a5bf2bbf8dc1ee5d0099e283015876a8907e3051c6d7c80a6fab119c5defa4dd69714add0aae6ab2bd5e40a979e7dd1300f9af3fdc89d539d312ee4fcf4a4aa44fb2fe341d90d1e09dd3c17bac294c178fe44bcef1f4e18537532d08f10913c959f44ca5993f9e2ed899ac98d5c4523c3af22a9a5ada9663daefcdd53b018d7b8d0e83703305eb0154dbcc8617f996248a40345a009537c74391132eee3fbff61d25f284c10c02b9740c266078d577ebef482196dd47e8349baba5922452667518b6d253e0b5d842b417ee7975bb383868451b3a3b6bdebff8ed47d0a2c17469fadc4af4afcec9c84ea1bed97a9cb3a00a6af2f881991cbd6866410e5d3a35040e0010910ce07082f722fa8e51e6b95419fcceff40ac119829d35496781d902804a50132365062f10eadac459d12b9d73226360ece6ab199394218a1d60505867fbeca3d9bee322a9aedcece8e40f7dd4f7ab5bb88c21f415a62bdadfba3152f8e2b36f8172586bbdd7990dcb963a805175044a1cab2c80f00df3d9a871ae4b226217aad6b3e4886dc2ebb24e27935e3633368eb40974fc09fae31762a646a81f90695cdd5a6719c70671c1a9c88a38760003c9e035ed921759688ce48248d99544fa3a62c64dec80d4ddfc7c8fe1227c74049ce8293e4ca7ad6b696fe41754d8578f8f68656576023a550d42c8ad95f510a2b63e55dd5c22f6caab6fa0fa607f38dd0f7bffac053992531d91acc4fe6a3ea3b7df8f92733c3836e4af5c7bf4afdf3d8de6ae55944cacc648fde8d32bcf070330bab9beaa8c1af42a4ad48c84fea7e51302462ec5454f77586b626c986ae525b9f85af9062574062ea4fe9cdf993be5c5c54648348779faf1b25108af466a57405f48a5f20c06bcf5ce14f9f5c5a90a4a178b51d82afda793d03c720ff247818d8c15a6a5fde1f8681a3b0358496cf7a192f856799d145acb9a2100d3731bee91999bb49d3c94521a1159c2ea82c82f1a7cbf718403d8c1ada108f2abf7bbadd72d31c7800d0be2263e3a4b733638e723bac942707b85956608abcf6c6d19f272be7dd101391b5c12f342789d2575d2f91882493df1f9e296e024b0ec879e959e9321f9db99912ad3104c64bf52f5f5f26a9f6a64a3f456a50a2a1ee8c0c062d33c8908280e372f96582e840e6435cd018de8e8823aec8a7eeb08ef07905f77f69ee243ddee2237378315a5e2985b87e14dd56f63f45bf9ce26c02f19b04ac4e3bae60185d2e387b73c35ac4eb3c1e257c558b080a5134e4092e36a10c65e945c39b1a4f8eeb3f340b053a30e3573895a9cca10e9fc29982572e2e0c1ad2f8b07e4a36b4350d06fa726cf0963b255c6ecfbea40352a7e49203b2f15af4e6964633ad89cb0267852b2f71c03aaa3cffb9857523103931247c7d416c1d006aed655278408c5c4e5547673b230dbc61bcd7d8c369a487373a629fd4b740915d6b91fe4f4c089d329499635a170ff0cbdf1284de6a6312468df2ba4d3bab20be00a446dc8ce877b62d653044aff5b8d1c68556f221089122e0370cf4eea5d03cb30e91a9832884347a59af0aea1c852fae1ed137172fa113f52167f9ff0c0dc7475bcad99f083759f9782d7d8f60d43d6592afa0343331c86c231ec5ab4f1823d65cfb74c461344c8af6bd20f00c95507f39f3f6dbb1f64e608620a59741b85f3bde81c0d5965b1ff8152d986ba202645622d6845ba852870d397d90ce7f6d8fd1a90553f9fc7513f08a3bbb21f3bb7085a6b1802db28245876579ced331adee2e1ed0c4622bc05b05893593b007176a3ee2f92c3c472f6a0b4331834cbd9821355d9f3b4b5a57dbd72ad999432ce330384a71819495a0e424f5b2d0ea41f048cb0cf02e196924ef7d828177affc4d0eff7381aa477b2f6919adf8d55d7a7f596bee7f2994933d115487e4fe7a51770e1663d85a0a7e1c8b071ccfee6b868d211b1e53c297dc2127f2becefc05e0927715d4b4081d8a43d68e80350fe63b5a1e9519e94f4f2546c860b488d6c4719bb647b4f036b606a5cb817322d1fc461bca5981a8b2c3000588021f72a794e4f8ff13b3af7733649749a7ab08e0324edeecc5806869d7a877b8394dc9d80d920217a77f40a44f65349672ae70f1f8b7ed365bdce3352ef4d57512952b31bb3b6a589420c96bfbdddf08acdfbc74b57f8d4b49d8ba1d0597e09f6a785926f59bffe77d9091c58366190afaf7f6051548688e0f7314a22f3ecf15e3a5055192d29bdeced039795db760fd9b39521381ec7804b264e9c90e7ad15db1d883c0651f0f9ebfeb1e3d5fdd433d37644b4dd44dfd68e2d08d82cab1343aa9d183e589f7a7432782f06873bf27b3cca250616cdb9d2b92b5f61b508c1338b3fafd38415250dfa8dd94a00c0f9881a8a7c83fbee08bd6b0837f76e99bad2e80113abcdc3b3d9157a12cffbe0040b8c1479b44f78c09b8bd6caad19562b84440ab3588725029ffa206b6f761d7232fd4cae9273a3400f7bf38a0e42014e62cd0eac4a8a6d63800a6d106c27f37f15cf62089e025b4acd621e4f78c0f6f84ff43e724074bf7545929ed0be93ecf25383981dbf9954c81ba4224786ec695dc69170de2e1583a06d0f264edca6063fa4bc02e2042ebf094381e9b27532c70e582515318c82a36f111ff90a0ab97d88638621f26e1d0d4b8e820e5baff06247fe7aafb05fb72b14db2ed03771b9b922631ca870cab07d7a335810c9fb55baf129229bef688272a350e0eab582948d4c3e55d8f3344ab509ca53d9fc55ee31eccc76127e22a61f05a2d51da1cd63bcc4b649f62b78cf048fb847ccb3705eec7c4c3e48ae0ec75a4b6fcb6380a3296466f2e03661672941b2abe7acebfb6ac8e886b9f6fe8896457454ab2d1b43359ee0675efe2e98bf7c77539b9200da788ceba457ed6d58e59f1ecf603f7b52e95c323fd5f30688909854aefbf61e72a3034fca9d57760c9309a32c4da246db406b70f920a72e59a4dd41e43fd2e797092fcead66b5d408f5c81906f691cdc472301d6b4fd94128916abda7a6e5da62d9b3fb1bc2fc46716d7d74f35837bd055572e4908ae1e0f90bd874e4fedb946308420979649ad482c25985732705663965c32b51535b765688007de6f7c55650414f79d79cfc2a6a6544ab100407799e81b121320741d6ec74936b454555928621ff411171c595464a83117a8a4e7197ebeaed37cdffc572416cae0a43dc52433180f4e583c2131233c344ae739f84ea4d15325f9b2717ff0de132b3894ddbf586fe84f3c67d7122da678d94cd8dcc8ed89cce093ee0835b3ee9a24bc4f2555eedc1f14285a25edc4defd97b52170cb26b6907c70facab58dd4cdfd9a22370405a4af010fb75acc1794cb516df8669c1b926039407fb5c01c47f5dc625f8441e3abac7984a689511fcbdec45b89dc48934e7a433bca5fd54d0c1c17716237fc3ceb5871a4bd917ad477255ae351af0f7598585eddb92e2794458f8bcccd0a4f39b495bf030022aa64710bd19e4bed205f70bbb76c4ef01aa3a5a75a305bc09ebf42d74d5d91bd1add02f82ad77a9abc462974da8b1cef5354092ceacbb9b7537567f7ab188c38354fd4a67aff9c3db4b8788c00840c50ece019bff5eb14b9e4ec088a32193d57ca9bf035ef186f7ec585df24e6fc50dc268ce496a5f65dbf489d0fefc9491fa4fb3b10ade1ca3d7201db416e12306fd5baad5f063cc0782da052ff4e0a4108251e713b3651f0956492e97f5e04e3da45208bcc576a3aa9ebb7da01a447d1ffbd1cdd428496d1b82596f4a3a89a11910c816f5a94514548aed95daa07337bc0bf92af57ecc036493bf0f010a4cf64782366beb1f9fccbebae4156fded30eb8bf425329dbdaf77d21c329ee2db24a7a60b194ae570f071f1960b391134d2ba6c7440a7f99ad0177888f46d2089ba2fb1ebcd88fc293ab110131923c1ffb12be0171322fe7d95f37743402d592a87ceff2d8256b133a4628fad807ecf902144909f4cd63456be19f7b34ee8ebe76c9cab976bba2a16aced345dd70f7f3377aed7f6b46b9ab0a6d19e6d0b826c44e24fe75478f36887d1cd51a7278ef4765350ae41dfd78523d157b09e9d552f247b05fb08a6baf0ed10fb3b037974c94e0db47901dbb8e4091105b4d053ee823263230c8f484f2a2b82f8527ce4f6aee69bdc750abb8cb80861d4ce70483d9dec76df404f25ec1f719e85e073bd1562baa16b3c5748c91a41869a9d8e9e74df03b818b8a78b3fb8d4e7f36af400e35d84233566e64b30a433df6d6680c27e4605af78efca0be61016d96be80a1dbc1a48007de3b7557b17930e024b35fbe11126db2ac14e8050344ae93715516af4f2cdc43da5876861c56d47d654f3e6fc19ab052580c89fa473b3683c85fa803d681fbd10f6abf01fc9a112818626b3f8d0a2ec15c2717e65fbc46b1de33fd8c09a77b7952c19873c2fb6021d28664d5a71423b9ba978ffd9cb905bf3f30e5f3f39149076bb9f354ae878a139dc44f996c6c17ae90959ef181fef81acdede853b3265297bd12d4cc7cee3dc85a328a3f36fe4b082ebe0ecfb86ab643722d97171f28070d57478f478742d8b238084cc258a81d50a90a2eb03b4f6bcea73316e007ca07923604345e532a5af37d591a17e8feaccc66d5c385af251db497ff46ae2b4c0dae519a94841bcb22320610c7fd9f909ebbb1e0527df38ce3220adae3f1eccc227b442b188fbceb5def001560d126ddcb80d598d50dfa598721c7310ec5dd3a4928827e6cc30be0339ebf6e05a8ef99116917aabb08ef818e0c0c7ed0eb8e28effd59386b82015c62541fe22a8e4e1e03878695b7e059bf1ba5132a4cc8edf9969acb7bdeb4165b5872c15c814e691fb8fcd738a24f1a611b46669d996410a225657bd2003850580830085c05925345a7b199fee875462a32360f7b44b19a586ef80db3f118b657069a2a990af9d0d2828caa6f8bd7d188f9415b2ec148199ed4b6d499535a297c6d931b0e2e2f5d8337fe167de521f64fcae2c9132cee608b195caf92abbefd9f0886c01aa409fdeb1772a221b59fcd1baae0f688618668c4ca8b5927e4e39c2f08a43fca72a663f68e85c9475fdd9150303a44ad355ddcc5b54655a926ead002a9d43b9dbb3b8979d03f6f2796abb593aa69a9fbabf631554c50586d324ed6ce4c3ef4a24f38a043c7f5e7c5c5c0d944e55e94fa2ccf2d6caff9a2cceb0d1b8f7e446961544a7d5b24a508df724bad55fead785f10499ea5d78804503cc157b55767f89de90401f07b663216c3c4f7299ae26b809b6f13590f67a406e273f49248b44a72189aa1b0d18f537aa21ffaddecf5c4c0316819b8523ff009efd834a9061f88461532c0f72ee53ade1803c98481abd23f5c525c78bb5bca934181bc75b3f5639e5f3fcf25de51b19221c17030a0cc5d4e45d97efa7b8a345a07e86e51aee2920bf5e75d3298105778077ff6b781c636ef13fbddb20644e4570a7af171481fd2a4b9c1d26797e4e0dd237f094965c2e4efc3d0c511e1033d61cc04f1aeba023bd982b08a95077e0e3875b27b6dc733e05726d3bf1c5a87f19c81944acca99a3a33bf1985b51690d75c03da471b266977e06bd14e9627a663c5bda894fb64c045d885ae5abad5179c00c2c4a45a5e6c1f4cdf7f47b6c1890e95a5c182fe9f3bcfce84fc59a77bb2367a3501ef246bc1e4276b6c44cf638aa029b46e661492f6d4edbf333dbd5e517d74638377084945440916a937812ff0b63ad15ce6706b63a4a1f9194324ad6b401d38a08c0f97ec5276d2a759e4f5a551621a1f9c23f885d25ba51a3182308826971beccde3cb71961fb98c28ec09eeda473d85f0e5d762adbf2f870ed5de42fe231ead420406c1592c2f34c30bca90b789873025cad380f71eb9e58b5aaaf56150dd999238b4afb1acd0e0a34740936502215b910da0985339936f24d7ae81845b1210205716be7b55c6cd62061462b3a700e95c17e097891ef1a2f548f8827f44674e11ff2bd36029ccc1ff8613558c819f9782b36e0fd3e231e54a5bec6ce825e858e866e81a3b511c47c1c484243e1aadea3c4ae7efd2d6d04d28802457794be542707011f3aae8f5718e1c432b4fdf17418ab6b3f93135d36f787aa298d053e09e2442b9a298550a62b17ea3270516f42004846cd85456cd79cf4b90be286de752ca87945500c005b71c5bdd13571254ba251c5b34a1d415594eae2780acfaf181394c097adfff97a42dc06e2a94836037207a427acc14572cc5947159df5b3f87b97976a51145fed5618631750ac1b451284dab2f4b1821671e63924d8800545f5bd31a8e1b9f78ed3122778be6c6ca93d9f781bfd63fd5bce31506d7eb3e037d69c89fd016a0ff51dc7f815d11a4e93c8c8d1e301a807f4ab77f6880ce99397da4947981fc58d58db4e98a2ff660c617971398248ed72f85fe99d54af6f9f2a6045f767c8fcf5966540ebc3e08aa0c34c8ca39101a3bd14316869bba7a4399a7209aeb69899462fcbe284e8fb5df63a9bb9b3a35346550e70d0d1281436c4a810ad04416b241ccf77a519d96505c8d8b6b8e22f1642248f044afdd7b4eb7c9a076b699bfe0c322fcbf4f5a1c680bbd21552a1d1c91b7597fb7a1eac6185aecd0161f4512c332841d35908cb5cc9ccd5de0f7ca434c245e5e835a9bb3a23d077e3aececfa24ccff1700eeffad54fe9a4b12bee5b2df4bf71150c6a936a3f6fa97f00a13d7b41935f505829c9753fec4b7a87333817e3c297025fc08b9fd11924a5e69be2d1e68b2f99146a7446e60a5b0628792a41ab66079b57a18e2a31ffc06a76bdf23ea2c817690b43ab22a962983477d5d0b42d63610f82a2209087783de6da9c52bfb2f6e8491a4717ba544dc0f0cd959b0fd1e0254c521559ce3a1e4ce4b7e93c84ff944d45f9abca3e77cf49c586d909311a5b366b7b2762d89b214597f7fe0d24c6dd629bfbebf72ae70173a9130cf159ad31cc616ceaeab97449c826fd557a82aa6f1951a66a8627a74f1ddce31d6ef3b23143b1996b686a93ce561525656547e55ac4108f18faf9390e3e6446a02a263c842e25428fcb57a37166b227a46b4be9220b89b5f2c8face62b5637e8d8a1aab1363f606107d5593dedea2f299e2e60199a08f180f5dab704b63ec3049ee2e6a8929f53e36782b009f87a76e6ac18736be1d9f08706bb3955d2e69fb4a0e98f7eb49993b123aa87a77bf1ad7a677cf2d7e3210970007975f3be392342fd6f23d0c52547e8d77d4347657c6c6ff44b13d64e6e6587c7903af437c6111d3dd752607c07b885a206413b2abc5f550124e90ef61d0fa08ce752a3a050c71781d0455da96cb640641b9a7de6f6ce646090aac2ba21d1f1a9b4c6770918d84ea7a519c31b38d879b64ab8fce0f1cdccafd479322135b1a2c8ff8bff8c828383878d6da7d95d26abaecf50dffe5312cd653861d56b4d2fe280a91c623cabbe82c68acdb689c493c5cb4bba7e60cbe73c87a6c511c04070f7524af9b1f288af22f20a90482db53a0882f0c88dad3a958c78cad8a27d6ff5b9613cc7ab24bad3c2ce353dac028e6bd41b4a0670285e0d7a9f303f6a19db05788d8062367156c9c9afb58db522af62ce0359353493f2ce66ad0c538f4ad41861e940d3ccb206ec067236241606824e32ab1360272e5eaec8ff7520ac6a523ead37c257d2f3ac2f2286506fbcde22ab3a56adbedcc89b5b06bc2404faeea3082bc3520dd7198b2ffa96ddddafdc749880889b103da2e95e165a61f8b422339e3d63a107a4526c57a0a9580bef6d29147df28904f0b1b193438f1e92e1b0a3da5c8d18adbaf92c2f7d684fa397f6f2d360d97976c576ea34bc24fa1e7308aa59343dfa475993dbe6ccbf8a559a37e15afeffa8f28e49b2eeb126ae41c1c5bec10e67fefdf377708a8f2664dc4b4907713d16a1254738b5541eecc477f3a5972f4bf385e127562a3e974116b0d67e33984c20ea86c0b66a39dbe476b911f0b59db89135ddd2497f7d11461c7307ebedd2d42277b0bc05d538c1e7336307b8baebcbab53f19fff34fd8e82b55f20af4ec546b526b404b39daf666d74a56c15fd5bb57ed314f6a766bd2a3d3e710336f1e28bf88e4a05fc73223e09035cfca5c53da567dd33bdc4982ccc457dbaedc9e71c6aeb4989a5b364e8be2c349820931f953afa623eb12449b4aa4290e1917c01f2a3f8042bd3c101f31e6c4d8ba4fe36358f4cc38f37ba5488bbb418058323576903c883bad292e1ab386e10d03a89a7be2c38b8f17e0a5786bdd4cefe15f11fde4df427223368814e09b85c3a0863eea54d6e561fca7085b58ab89a83d86ff5743673e0c559f6501f302c52b3195074eae29fe0dcce67105d7762558fe895b150dbb6b1194787eec10e5c5cc9b295e40200f003094a01d4144e1e8f873f2e1a11961dc20c67db4f6fd692aae9f12cad635ea4580b1b0aeea88dee73409af100beb66121146b638bf30036fc4c2d67757fe20f074c4ad4f38d7ffbed95fa00bac8607530bf923011a1fa58fe8fc358e24dd46ee0e5aca11fc6450fb475dee44ddc84fccd0441b50ab57a47815b1ef2048f3ac5125a78505efd9d26a1c1128f8b5a82dc355430c4f304bd8f35a796a2ffb98d39a7c3535f14b612fd0e423c725a75e6e20d130ee2028c8f6d467fbf51574e66c27fd68e19d642e2a6408bfeb83d82e17ab1071843b0f22bc2f2d602f879f9c14905af0f65e7f3e7712bd358e5a7dc4e21fa0665885aabb222eabb4b7a83d33f6a5f0de4f7c5b95c9bc592964416c07c41d02224c30ee87ecf2c2217c77b18cbab56b9d1c16ea27c524a845c0aafa1a00ec0e50af405ecd9e303b1418b3b16a0f6086959975dfa6e663521b8f468ed3db9a2d84abfe9348537e2a1910e97632065e925989bd7ad5ebc05a2fee50c50095be6b5525ac9e2566e7a317ecf9abcc705f7c66cdb3ba2f68485446abb53914eb5d81ab1b1a768788d2340d8f130e3a76b8fb7f16647bc32d3932e7fabc43737313cf09e917cadcffe3b8a068719568cb1daebe1dbefb8852b834125a0c76abfd302d47cd75ae44a4b783233691d6fbe9afa2631d577eb2ddebea503002907613d08d4ebee1b00201100530e8b635939ac2d7c754a2020a15e6909d6a530b30fe0f8a10ad15893e5ea6e45908b6196664e0461deac0f830b368240703e227617e8330583a6137d6a90c363875972c036bb9188231cd309a2e9eaa5febcaef49025c8be670dfb1b179cc75601eec775a36acf0bfe8e8b5c937b495c1e740790b13459433bce4e3a80ba7cc73c3469d776aa6a7e216bc58229dac266bab30c70503c5d4adb567c148d6298f3b03089cadee04f76c8fc384c856ee8152b0cac9cb59fc7e1e6aa3caadda23f49345c0ea70fc29a297c05e1453d504d5b5457b1964935f13776307696d8e7b0e3803a66c6b8c4adc644983b37995619a63b63e81b490b2d07acb52e5b7886d8b1ec3ff0426becb87243e5174057e065fe703742e90650f3be7f7d3baa5c6a474feaf6428deeecb492fb71d77e9f1500d2d2b714b483fee98858fc73a2fb004a1c26116cbbae33fd70568fdc38a4e279fb5bfa50747b1db0abfc70be11ace83fc4ec1bc8f0e6db5bc3885d304fa77eb4b5bf2c65b3a9abeb5986d02836648cde891d5e6f60c6ecc7eb7013ac72e0ab6fc3bf3571dad4bd243bbfc8fb246b08355a0587459dd148934578e83a356b35c79acf090867197d94c5f5775df03e83544cba3a13126f79d6a17437df4411bb6c016321ceda0f5218cfde761cb2d5f8c6ac0b2a2f997e5415e1b897852c06f577bb4d6f86ff84fdb3b748084885af4fee4481687afcbf057a1aa787f34c3a9bb8c9cf38aee46704b577a12dd430c1bf33b1387925bc36de8346f5a89ca7c821a0e70975effa04829961da212eec7d515dc7374f669b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
