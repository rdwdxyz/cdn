<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1e4ffdadd667288c32fd27aa07ddcbaf0a8176824d959f3bfe0d6fec1187e43e95cfd4720643e6489719b2a1cf68d27457d1513e22287b5bd4af279c45ca2525438ea1b728a93d07b665eff923eeb5cd603fcc297c3df98a1dc9faadfe9121ecb4233fad421a4b0a6b71f4b7142f18937969a27ea5f70b64543abc16c93d098fedc83c87618d7e8ecc265dd8dd393685c99dc8ce73e47f7699dd026d78929cfd536855eb6ffedd2dc21d9bcb1cc9b6f207143420ddf2f764413eb2e1c2d2898bb2ec3519a9ecd6674777f2e70f105227ac341ae31abc57aa369e516fbb72f4122b9e4fe79f90de848851c2b7685d922f2e2da356263205910416273e64a19042ea0346612fc34e3d819cb9f97cc38a7b99602463ce53d82b87c48211b0f62e8f0cc99a41c6e8625d7607e59c02381fde530879782642b80e26ad4d49a2a36994c1c34a552cc9fab9651e285a15524ef494b0b4b4e39bc5755056d0897ed9eb39c6fa414b8347b7a463ea9f35755567028a673f6c9b1e98a6b6f8531e1656b2d9def22bf4bb44ce95d6bc735c106ae57d490d6cb1e9860c2eb470a4805cf55922091a8ad0997ab1f7e395c638368cac6dae74b3050787bd691aa259c997ba88021c2f7ef323effbe1f30bf49e5992ab6a63711fe967eb14a2683f77f4dc6ebf8ebba32bca374a3ac47824a1a4584d912cbd318091f185aea609c328bfb53c1d18149a230c35dd86aa0a23bb5db76ac0adca6ba4bbbe8b5955eb502d943bdd139c8e11ab7e68c9a7dff7468409c3633e7e7a07593824cf6707e92cbb3354fe0ee69e3f69de2395af2933c522359cd7daa8582afed7c2c547b7045a64bd45e7d5b56cc146652f7d431ee88fd9a652611c5ffa4f3ad8d00f6c1161d2aa358a2d85ce23751f9fae9c41a679fb7e5948c8f420c3ff15688884015748d52821ff5929840f1bae85f9a67eec82d390bc5c4cf3e6e29f8bc4b854b96af6a439fa93ba43e6dc36e363dc721fd7d0d01325fca00887bd602bfdb73b943673db05337f9382140784bf1dc76512da3df820cadcba18ef74de51e929cca416474965c004e7a2d3fd4b9b62b32decaa4037b16ebcb6a2263334a82ab4eb500a471fb477973a207fbf3c6fb846ee271b35a8e4c847b74a8f7914246d353302bf096f43877698ae1cb3a5a44cfcad5ac412953686d4523d9a2bfca0742e4c81c151e98f20d079d9592de61b41bd0aac8e56a0b8bf845ebb5a81fe14754d85f1d61403369e3ebbc3dea7fabefc8d242d258768a6ac49f3c8108461df188e841823ea1108c7c92b81e11846584a2346935d22f0742132d3e9202b52c424f74bb883f83b77cea462adea2de5704bd865aa9d8adb524e797b1ea0e621b7ffd96b2e966cf09a5f24b5a9d6349a85eb499492649b72989c76b1d67213230c42c51b12bab4cc798e5be79de72644382726d06b007918b60c4b877be5e1188c980a24c8db94f6ecbf6a76073dbb10a541f5a08602cc363d8761be0104f197b1aca18d25db152b50d58d713df6b5f81b8e2369d4ad992223592b0e42f7ab664f93462a61bf988ad9d938f7025ffe77fe42a068dda184e876434cd63250e0e9a234a795582a9440ce85fa27df72f736869ab9d3a00c64e81fca6b163788c60976bb61001c552c83bfcbc2cac98ec16f4c4c3b5dbcce2fbbe74714d5440395cc706a70f7f85d43ad62790ae97b374c415bd9f85a076e3945f9d15d072ad1624ff15ddeadbc80b55a70055bd4ad35d739c6c7a5824988228773dc04977b04641cba0b3c7fe81ff3ed7a821239842874811a1eb1e39bfa1196be32f12ecd2e2a2444640c1ae755e83fb464b2788af87b5a42da5eafbe3102e7196f1f6ece8a6bca3d7525f05fb7624894f6117faf02c4e1bbd8aec16d16a0a712ccd880983e510dc32823c331b9a2d86428d29bb4667933fadcd54d3f63c714969aeda629b0cf690a0db2d9e57af9a5b30fc79d6e8f2c6726e73a461a47408d96e52bb210dc57b2bfca6ee33f0f47d5ac7daa62e4dd6b1cf4cfd379b099d98878bf891c7932eaa7cbcc40bcf3e3c1a283b586d1c811f3bffddc19e65fef090acf7168cc038e1e0b2bc8835b9ea3c23a005c831d55c91fd8003b19bf7c9a8f55c567c245d2ec1495130b20b2903a4e326f5151c16a969cfadf51cff01043b7bf7b4030965f80e511c5eb8917f95ebd2ceff40587297c647fc24738ed0780a669039eb72a9dbb12efc730830acecf9a2d1e9148a633d0e567bdba02c1aff4fc274c185b2fcff3a09b1cd1b37a396c612b6e37458f015fc582c2f6b9cb1c7b16f098e3973c660ba69936cab1684bad8bd9d72b23c415a80936a25bf53ee07dfa4c8872e4b6f72c1a76210fc809a960a7c18be254329755133cfb4ed1f4f4a5274980e0ef84b9537066e7aa1e97e400324cd9a2bab0eafeaab22bec74f23733b280526c1aaebec77dfa02f0a750ef0b9e9f10ae3ae0c029e8db8bed572317acd56430b71fa5bf4e6551c9d9cd82f1336d5e3df1a13c26363dbe1e69724f1f01e0a0eb5d017f9475840afbf6aeaa8a1e0234e887b2fd281ac0984bbd486cb87a93e565780ec1878791337002414f5e54a959a4152e037aede5c72ea15b19ad23379a328b8e6ade8170eddc598774d128df3690eaec92317cf625502352798e3e83a3d66f815d683a57383669fca377550c73fb632dfd31e411d3c790ab31c00f9798267dd15279c971d44e904d4f18131dbdb646c88bc67e4855efe7a5d5623ec0526cb9c316814777f53ea26549bfd1dd943be416a1e5bc3d140f493d51057607512569323693f194c2b2614b64d9ba4ada39110d5e66ae035f27c2ed2baff97d4f6f1510f078b30d2ba5f9fe50b7a146496dff0f6295d3f16276da609599cb68a039b3c2c6ce37a80a4920e7003bbd9b4144c7a864116659d34fb9c857cb4a148de19f476e3521c2726c7c3ab6e97cf7efd0edbd9aa9593ce231d5704c8e11e6c0ab6e6313c8a63f22701a44232abe4cbb662a7703b7752963d12fe69758e530fe1460b72e68d6399b9e7417e996e1ff63a33712cedb2c402134e3e83529ad2dfc7b2ba5ee8fa2af4200bbf579752536356f30af4abd70ccb435a39e3782db97fda8c58cb83e65b27e33df903eb28b80f58ef4ff998c02bd68a54c572b03c9d88aee1870098cc6ede978084dc38fec6be5b902763d78725e1aa20a3db40a4b7dd485a8dded3877abed0b19398ce9ebdee98539f882e407705fdeda762b03fc12abc5a8b2454dcfe674953ec8eaab9fa696afd758fbd8274062b85ee2c1b49c05a599f4721324175315cc1520421b85e640b912efb1204962a161832e6ad4a2ef3e9cacee9194263b794dd8289d29f1e6cffe5d8531803dd112fde842b31b7d6ece3ce65f9174582bcfa25519183466a9b7576212c140ff18233a84604eb2ac5626d0eb26a99d0a87eda14d0bb9f696da016b31fde1e6fa6f422f77b5937674047a069f325c8f0c83c6fac31b94612d197092996893fde3775d4b52dff5448d8ea43d9726750cd4d470cabe1edc24ebeafb99bb0ff63220029d739a82c66732e8639a05cc8c4c8ebcb3525e412226f5087e2cc3fa9dc403cda7172e0b11cd3cd88fbe5b8267fcd3925f76aab8101e590e19abd37820be1a2593fe8556fc153355a11a37bca3cf63248a6f510a56b32a6d543596285c2bd33523dd9040bdb36c32c8c635a54d6557098be4d1f8cb4c43697c7738bda0ffddc3015e94ebdb805d8687ddc661614cb8aa6148837c0fe3de12a4d634ebe9f97f2eae756ae113be7743870ef001cf01482a092e0825e83bc3aa310cfcadf3e1676a6e17f96aac973ccd994bfa2e91acf3ff86dbce0ba622454f1bf794d6d63d931099f6def824a08f468e1b212b8c5d62bfc1e2f36df6804dd63d522067ff30f83d9848a13a29b4224107c44789b95eb8dc3e02d34f0464aad1de1da1ba911466c59e992d5233e7bd132214f3b02239e4127384d87a213fde10b6d62b761a15438ffb6e22251a1af8148a31b89c42c26c33bd476a574bd19a828cb5480d0bcad657067201f30e4e64bb9d7745d6a34ee4364e67e15d15363f1509ea58395e24c8d87d495d4291a017326677658848a5f8175f17f5d31a57ec7303520172975dd46c33cbfa80518737e39f0f1e8da31776c7db93cc54b23f20e083db04c701ca6a577ff6a7fb73c4cfe149d8979db5582006097489f298c6e57e99669cc110fa3af2c00bfd10973b6ddefebdef300e2948f38ec252109e737e3ae3dd3535c89b171d5b8d64acb38d056abd07ced6ffb5bba7d08e231974ad38d2c589f03e862784351d6180e8158d938de2194ba3e6c7b0b494a3fbd6f14d25dedf0ad151c50065cc8dac15140c69a5e9172f7f62592c22940d9dfcae85ed9b81dd6362e97e038ab0e8cfa007df13c7c150aad8a9b7c487566ec375c026d38347e49e3591f6ec040cd55342fd1b4ce2117c543dad7fb57682e3f68e9692ba1985af0a7a726de66ce2f68d1733a04e9bf80b860b4c4aed28e860b84194b87c865e274ebb7cb8fd1db570315e487f9df52a4ef10ff4863b1c4cfdad81e86ccfb7795898498dd2db1e3a91d05c080aaf97c1bf862c53aebd8dfd529c9bdcfb359581c03b468ff8846a366ba39ece7d0f70bedc9e92c51a758bf30fb244a2eac9ea0ea7e451884888812905e68a8eb6a8708bf074fae89e6b439f7f1c504efddd22ba299b7257b96fbef77c33350e5fef7ab2fbf0a7be0df6e414bd4f1c019c6efaa12fc93b5460b35e07988235e24338a5544727480e3fc19a4829768d721af6a817e8c88e457639d2a400e7ae90aebb503ef7388f85f36a5010873bc196c5c9f75f65d6c977c027a488d2b514b9b38c7069f058f78555d368481eb2abdcb41508625c259517affe2e9177114a62a25bb5bbc372846dbdc06f3d9cd2d58779ab3c0157508bcf0971fad826818fd8e0882bbd90056e503f784e6866d7d0bf91348581e672e85c34ddf87b6b95eca4c25083a057d13c4481401bcc2928322264dbb474cb3c0477f177583201d788346e4532061b9d7dbf50295d529539fce1b5047d9dc3d6d889d999992016b30e8b1e1d51fcaec5cd2bc966bb048c46e8cef357ce3413137acdd3a7d5d9517b3b7ea071799dec7e3593b196dd6edebdb6e8fb5e012f4e3fd61ce4b83bb39d45c3cce742a1125812c827b9b59e32b1e533e2b03049a5b4a47dc11028f9eaa11f798653589c2ed8f4b6d2e62b22c66e1c22a320b9930b0446c87ed6a8a63e2e0b43051c798c54319284c1bef8c12bda3964fdecfb1dfccacff5ea703dd63396bab63af44d100a0c7042631228484df73a4dff6d8a3525fa2fcb4bd55bc3c6daa182b897578d0fed4b9ee3c5b4c96b36de69674e779c6777fb798c94f7996c7f29885f6310e6bb680896e7363f6604c50224493d0aba1bf39926af78dc7a738770fcc0fbdb3ff2d14151f0861f34e501107ec58afa870c4f07aa0871c1a1877c570a057128cbf9e8ead3df22ddf0de75178ef8cf1f62ee2ed1f7a671af6947b80fc48e3efa05186ff44b07b6ea12d273f9578b8229c62f2154cb395e8162282300dd6d1524080b67547db1833957ea7dfc124e548eaac90300826370e95123241d5443c37cfb6f44148f9230381b33165a4be81e04aa0534eb1fac019324855aeaada02ac27490daa919da1008333b75e1a844d003e16bb9c82be2df864f244a80bfcf98ddb78e8d0d9f869160b6e6df07355933335975e2fc0555e72e7bf8b9869c1f6622bf92db2c622041ccf6e41efe38ef0aeba662a850bb9b86a6cfb9c9e0fabde339f0c88d084ddfe75433b0ce1baaaf25e7e25f45c02a519e184a6432bbcc8d64a08afb8236d595ffb72c1e3a09ffc4704f4c41827d87400a69c48c74c5b80c7bd77aace367a1fac54ab13b03834e75509372f14c73757cb8600abface9cc100a193574a260a1aa86144fb5a6d2627b6d7d73fdfaedaf39ebc3327029123ac001b8a9a56ee9493ae78940a73793e47b65c632ce868545aa189c5885e04c785b0689dac0e7d50166fbf64090358c6b34cbebfe43f1ecfe561054b077988c6e277fa7b8a1b60289b42e6d31bb9c6fd6a941261e9a4def59459fa3c8ff5e745ad15ed349ff7e812497f357b9eb63c6562b6039a588db2c25d19cc4da47ebdb7d01472f6416cc55b5e0229bb3d9e3f1164855a31cc2fa48e04c829af58556309f939805d79de2b7adafc71ed5186a02cb13cd728a686fbb7217b5da036f0818eb4d8e6cbe8ba67a2b1ab1fe28f06dc156eb56c1d2b1049553d218cc13efac198db4aaf77458b919599cbbbff9228c91eaced699200a679103c9594cee24af4cb866f35fc519880ebd75d7dda653557f9b4cf25ae59e7ca81c2a27947ded9be2873b0f87d70ea522f4abeea65aadd6443850c3b7d7c3e3214209c40d695bcd4820b2f907729781f3ca96090f7d926c110770faab7eb66f30b4f793dff399e952b2cb1ee0179204856366ae7fdbba5e72860736dceb92a271c90ddd6e0fd307a38ba0e7443ae3768e6d5d6536bac564efb02d1dbd7a1c846c841eaa559633c5af674d8804446767d3bf305945ca1c0a6bbb718a4932dcd5965b525b2dff00a9d1735aecdc70694fb80633b80904992923ebbfddd77325c5254e59801309cfe60b58c356a7536505ee16ec4c27d0fd54e0a51c5511e2613bfd567258cdc5ac40fabd7df9a1b753bf5f94fae02059fc16d89db87c9dfdd08236730502a749adfdb321d060b87ff49618726d8682844d63b645603a9a5732482373d3e5b24180c184ae34d733221d3c7d406071e1cae53722928dcbf11cdf823920867986be5bd002bcecc2046639e31de0ac6cab36137a4e352d4fd7445de690e52f8f55542577ce7d449239976f810e5a75bef3585bb9e6e9dbedd0e182e065cd9328f554036b9ad811438320e847474bfafabfc1e5dc84fefccd80a62cea3b05c489a7e4381f448b71f0645813922745a492da63c5bd3b21ff05bc779155be03cf120b8467dde31da70afc6d9d5633588528ab69f0f924d5a410cdcc1484daa4df0c51b40f3ba2fe5048dd478b22413f1172bc002fa612e1c9eec55371b2ad20231b7240b6b2defd180f9dc7df98738f3fcbe1a933392c52098ed067fa8f0261a16ee4621b70f84ab9546f2fbc3b9ee5434c29ca1f344189662b216bca21fd590b5cb58b0517932ef906e2d30f14b0b9aaa3f349726919b14f245b4ec870e3a4030c572556f65a4eea9cf733215bb8dc7ab1db612f8e42aa7efbec6f1291d0101e9eb92b89372848fdb55f023c00d59aa9fa8997232edd37f8991c1647a4c5e2c543e6b39540e84518bae26f97ec97ccc8bb94abb5830cddc0f1a4976c2e83c8b58c2e3bfea25a9acc0a1763c1adc3c3d4c1440dafbcd08845f3c0918a9ee735018d4acd463c79c34c3bdabee6b30b9bbdf306a154765ace47c86bb5e32088f01c335b1ea1472eb8733c1c652e9f0610d6b3d4d1ddd2e88cb8bd4ffc1110f3f4639a21d269168d7ce05eae2f2fec03d4d04abae015101295966e3d9679977210d51554e1e9d0312f5f17db4ccea0aa26520b0645e95fcbe933c757f0703aeaa1294da5c9fc43513ac492ee1ec00e7724b304410c9800692030fd7c6b11150bbf71cb4d1f6bb96b1aea2be526526b8aee4aa60e370758310fe2b308dfccf4e2bb027c92b1f4fa22040a32c1b48f2cf4298be27b8b7b390d52223fbf1b93b0259b438f7e3537902c49a208284045742da9fb2218f16a19ac3effbe00c8583be8b01782de15de99bd892a8b5b5a13a3aabdf72c8ff270027665e88ed24021db6afdb7f1b8d8cefda1a16e8f8dfaad5521f2aa947f16e9a9e74ef0e6b251e90df91fe779a2e2f5a9465162cb78edd260e878d83d52992e7d8b7d5c74779fcf8d97a0f1c122b1968eea2cb4a28dae6949b32dcf09c324c6ba1c7e131d92e92200178555b7e541bf244fcf67fa265f0d29b155f689b7aeee526e0e528cfc213d4e4dee4f9a7ec61c8c435238b61298f68e47371c78e87e4b3bbdca1b931d841cd9f106bbd4f94d3add5532bac3cb2279e7cead36f32f6b63dfac0e2a7fd969fe7e8d8629a38789ea870af682d5ce5473e486cb0a70a160a14ecce774431cdd18cfb6969a8c6434ed2c58f39c9cfa5dddeabee4b789d26950757ba83be79b1515fef04c03db59094421540f3813a4abd9204fa11b4b5bf415f201fe33b0a94e941e65538a0255fbec719d40ee0f63b8e088616187f0232f2f499a0a1911d385ab12647b2b0d4a748c3fefc877270328ba931fc5ae1c0b605888089d06e403a2665bb6efb5b04eda5c982fac7193cb0dd2fed5f410a69c3cb43f374cfc2cede60d2ef988abdfd7d3d3c52d9111568536a8b93d66f4ad04ab7b1c7f62926446cbd4811238678eefc896513200583bd58184618d02cf4ae9851a0c6c6a527378c0f9f1d4f8964a405a0158650d7f17ceba711920adb1c92a164c0c7e11cd0436f107fce5a013a6745544ce1b6d6f0747e61a8b9199be26d607e2ea6692ef4e94823f43a852144f2ff53ad9b3f1ca658780c559db815e368e2322f25a865245142db542e04108a8b5f92d3e7ede5891abb5ee9b1a7bdaf589bb545e9fb98407faf2517d13f73b5520b0f19adf0d3b63f265543b1cf927c1b5f1cce2dbb76697bf7fc8adcad20097472d077822e793caa39c72ddd5507552acb8b52a04446545042dbb9c7631d1985c32dc00da88f866057c3568c842507f5d1f95ba6f048318c2f4115e935223a8ff4b503969b5e5c50efc17300d06a78c5da18d59773ba575f276008876d1b305cf4df512ae969a58a7c504763236550867acced23fcb4e901c1df2c98aab9bbd3efe7ed32a1fff34bfb86702a5cb7532571bedd31e4a1c67f87bfd8f76d56abbf999f2bbc029e4f5978adeb5923693c1d04231753c091687ee8035d334b554690c73c1dd8796d29dcb209bc8f40ef72b193b64f35d1c3baea2c4114c930b6efa0572e261647bd92dca5005450133e33c23fdb255ef91d15220a30dd7149edb1bf111ab6baa9bf0bc1ef65eb01b06daee368740ac02d2d9d5b8ab0782d92298f41961ab8128aed405cc11a90fc51a2cd1bcf82f3a36624e9338e28441e2a907c0dcb7e234da24b48c1d9ed47aaf23362f59a7bf87f6ea3af7ffc89351b21fe2d6774a9d253627adceb49177c70f015ed3ec2317f4bb5fe1b7780b45afa06383d8e4ef86591848ae0dd7a77f1e6128eb510493d64f33797dc5cc9588d48138a5fd75fcfee35fd75111c13b20e1f0c2e9b8c1a829ec16a8cfe70c4aa347b29b54f520ecf6238a4182ba492c3edc34f6b0c93b08c1456b8566a6a6a3f32b4410458f83692860fb4a262f931ddc1f986401fa3f2aad89ad0f7ea51cdac008efe9ce1c01cb3999551903795465f5ccd8dd4ff5c547a0c98d8e63575b43e4eeaab06ab0d8bf90c7c5127c3dfb71869d642d3d10bddee52d4d102184bd1d85b71cd6aae145da6282ed8e25af6d2273e9de3a18392d23e82faad23945030b785bfdf0bb65b8151c01cccfc5e8f7e4393848fb366eff8767c40aeea3b5718882cb326a382772bfd683c0d2c81a40aa635e697a03cb07a1796b3b6cf8c7fe49139f85f69ed014a699a892c132e8b9173b29bee867a15d405e9b0d6b04103454cbbb2d086c831d7c6a69e50b91a76555afdd8d31218e42210fd5673b60a9d6517ee5ab771ec812d2ffeb6d104bede5b475fdb0627f6425ded3992a5b2e9b8b70e18591fcf9f74d5cf9d93f4a0ed142fab2bde60750bd7bbb401dd70ee379a4c32c03c27b78877a0e751d69e8029ad669053b5118511f2b78f22bbbb3f8254e9c3691867828edd1eeffdc30083ac7f98925527e2a23367f49bbcfba16641ec13a1064f6e38553f26fc82af964d5322b8fb816ac22eeb0bc71b88ba41324842368451fb233ff47685ac52dadabd1baea49262d1dfc0ce1eb7c5b4eee3e8954298a5d8766a76ea5f63dffa2c22c19817d60ef5dccc59665904a8614b44c51c6d8ef89ce82a513d1ddffd9f45f19d7221ec0535054384dbfadf13e1013866337cc579cf5a7eb059154cbd2062d6c946dbdc08c55e55635a37fce03bc74f404eab583ec1e9aaa729665807afc165e63e93ca270da82a1d68415fc84daf2bed2cfa2b548ac318025c2e9b829c5c4aa1cc979e9a989f133c2850bf0bf61447626fb5fa220f964cda9f8fd73f46dff5df8b4056628eca2275c1528f9bb808d12863993b5ac3b956fe7a29dd48560118f073fc12aacc51e6d2286202e2cb893b6f2c6a7045e6df5905c08c436e2a40e1c066e272acc55946129b5638757e00a5f89485e552d963669ccc0232655dd8e7bf52a5368a1e92e99e83b2152065b8bd2a602129ace7dbbd9b49a322eb3c9d3bf4e02a11cfb6fb9751b918b0a07e10cba0a1fdfb549b975538af956f346af51dd77814366ba0805f624de83d7be63cf320b49d5b48356e54ddad649535db4ad6016a18cf02a1c1eb50385316c67f1c679f9f164ab71917bf5af8f908a4b268baf224a443f163c1f1e10b92c29a3ca5331532d1c3c1abf39818ccc1d45757c0fab59585a5659dfc75aea117af1c57ea1b7dbb44164d0687dc115e62adfebb01272b38e7644440ca6850ac11c6b07303f69b9076b51b7a0f4df62a94fd04a87eb729b3d0e428a0a29297a6ee585d1044c25191a4ff8efbc894055b22f2a4be090e772bc304dcc01fb9b07437a880f58eb88545939da918bdb590bfaad8255a7a1a103f3617caece00f42bb8f0408fe5527570534d2a62793f73c14e258f5ca8ff96a77438c34106ed081364be5a309954b74ac5d33a4dc2cb249dd2754097f2bb4a3be50e17d0f37318e0053e92f12274426456173ffb816bbf6361e2ecfd2879c93569c0f0f36b06afa76a9ab65328608e93fe849a14e9611d0fb9d227aa2984c7affb753bae74055f9556e20136f79e31a7989e01bbc32adaf1ecd3f6e0e00c507bd422d9553203ebfc0c04a7e45802b9422e4974d505fad9f6d1f833ea57d8c6c149be2db05da3a679ec5d3f7eeb44bc9d4a7d8406bfa5e2c5cb788d3675bd8b5d1bd3b11304706197b2aaf3fbcfb50d979e03e423ec3845228fd64de00bbfa16acb801b9177ad2cbb66eccb6aa3a784b7540a4760d943f3f922206181ddd5d5328f63616492b5be011054d43fd69ada7ae77f5ec2f046e4ae842bddba2a4abfb2435af40a2790e049697423f34dc14410f82c10e2d5afde54a3abc8ef5e74df8541f06456907e66aff6f1e0a2e187e3d3493fdcf74b64f4ab0fd5cc6838139ce63fe5e4a0c9cce2e0660dde7e61039937c21e2346781bb0195621a445018a287a53ec6353a2b78bb46765046135f52e53f7a56ed0993309d72bb28c9260af0b6ca4ef6deeb1ee23b3c9b611df6f9b03a7f767f96a1fd8708ce28ab34a3f0c86d064188934e6bf841c8abe5d2b5bc5f8a01c970cb108f20e161df615ab258f79914d76f17e74324c2bd5e0d337e08949d9c20bda0850d0baef3e95756a7752afd218de310c0cf3b20d01609cd64043dbcb4f055ee848586d0f621d0f68f5a6b8702681acc3d49677c65ab257e02387e8abaadf07f9598e653f9d43cfa4c6614c255759014ff468b8a35e6370e37a9b00a76f1f186984f403f37e254d82d640687d20031865d464a1d85f5ee994e043d88d0a8bd6bd9d141e20436c4422f1d19bb8d600c14dc2a69754e407224b37bb390532cffdcd72400191a0f2cf8c3cd9265f4a014e150fdf86d70beb4979e16d14f16a335017865cd7371447ef044a76ea1ed306665176ebb39b05eb4ea8036144fb41b71b1fd1f9123d572b12591db9a7333aae1613dfe1954199da45df22d144c13c38fab28223a0f694b6211edcb6e0e97eb06eb73960cc1ddb6a56a7d315231e069e4f772e42efb371e8ca0719744d53565170526c6d43dcc2c3504987c4c01690c50c260576669e8e90b4dc353126a986382394a5dda841624e5004a58f16719f5e07754ff443a87e6673845febd097fe92493151d85d29fc6245d5e8156c3e5b4ae6f1970a79edac724139d6af5e3f391136b7669e4d3f3fa77b3238b687ed2514dc6cea9f770c17334db54f32f98133eb3dc7d20ff8888a2b2793a3d4a8207d34a8b9e2791264270e275da280b4386da9750eb03bc25770ddf053882a70d993b4fa1778f2b2fafecfe4f8020867dbee1b40d1ca6d3c1e1f268f623815269c3e3f9afb920714862822a161813802a4e158f2fa21d65fe85c7814e0dee47678ced73eb79e57bbceb025f3a77dc4a87cc4edfbc4cc02f6f2e545e2722fd1656bc039f0246c1c15f0186929608ac5bcb4c2adce73a17bfac6bb97d710d5f6a1a6a4bc6387b09fcfff68223cfe89709f4cc9ec5914faa34661774a6154bfc6465168a81519e7f306dc189739670cfed2ae8d4d1a6470d858798d155441cca5327afa3d322df41291be86b9552ca873e9b2e51a205317c175747b809a8c1bb18cd9d0e27eeb1e24b879802301938e6d7e3fa18049d135384c24c05d975918b23af37b84d1c7ae9e0069bdcde0f43e85e11d51d5a6a925484a8f3d9b921f362eff414beb1ed17e92a37a78687b99fd732d6e936ecb940bbe4c40ab53a3ef62d2e42e4689b8e38b79a399da8ae91599e0326bba314daeaa33d6ddc91489c68f6a769fdcecebece0a6eed57f08404b0b3eae340e25c1db7df9dc047de54f870647ed2b3c083f2c9e8dde94337293ddeb9410c898b77b482839d130be7e1563df780de3c57d98b7cc7213118bed116ec41a8644585ccf7429dda99796bb5f735517943913a9d5556f5d4c21d2ff1d6579b25163d130941fc10d364cde6e7c2fc9b9b5c441e6fff2f34dd1158e46d1d83e112df9ddf2a61069982905335be11e3911b0a9e139528cd991a8c7a3aa08b404169d076b13d34d0c230bff3178ea5d51dc4661881e131ed4c6c7120772b88e01c704bf8cd8536fd3a8ee22b248f52370a128505602bb6cab5cd20653ef1ad15aeaff3b5b492b8753fb91a403933925d5b90e3b26aa43cf35bd9175f36c9c7f26bcc87b9d23831ea6d3a6f7f3783e243069e58cb6bd7ecdb51751aad6f310e6031b6cac53863b5711c57efa1854b7ba4369a6e1a0500e6c4e7e52d2a8f727fdde06524ca3b9feaf1654fd1b430f4d5fe302a10195f8077055674a6696bcbade245ae55bf875806dab424988ec109d2160945c8ab259e3763396a9d16d8b413627899e76045abd6aa5057610b99ee43e63b9c262b5c0a98a1c794e5636d692658de4c23f1ef69eead64f26180b53f756355168bb64e196eeab740a6af370b1f89c140853cb6599fb586722248ddd30b07b3f8c961bd8632692490ecd7bced89f8377499a1e644cfe770ce3d33694ec42af584c25b205408c545977be133330f9f8f0777875aeff87b2d47cb844e3bff62cfc74b64527b7aaba193221a84e9e120162d29c255086f79d435eb6a4121251f67e1294060ebad6c7988889365678de2a995d5125dcdf0a3280f5979facb3ac8c53198e99825631a20b903b8ff0012bd8a53badc5c2da07d9fa7689c77cd012b2f72e7c4bb016083d2b03690062880ca5e96ef0e710bbe77e97974947e2834d0f9a8f8335261fb8937559a8cadc8ed640ae69dcb37a28a3f476fae9dbff2cbda592bd9d1a85fd1410a7a042b5aed2f48c6ec60f15a4151701d2c60f2ce75adf02ad7edc369f97a60a8ac6a2ba685d790815eadc64405c69da8cc5494e2d8eadd3488a2af5c4064d4e0977bbd94875e80e67b4a495107f24b1daf4319b945fc1ecbadb69a8f6b397aa31ef2ae8d8bfdb6411a3e262b738d562ee70264226b0fbd8e65b2e79af01fbdbfe7cf929d7b9fccbd014e70cf054e2545fcff5ec4af898583c93096b92d1dc8d104bdf927e6f6a2d71af7741ed235b31e8fdb81e0365ee92ea0533e4e3131690a1f71d9de0722e05d1eb13fe4901144ea165f7fc1facb5d14d21e0cd3a07b1843eb7a94cbc9003ceb765fb4f0d24d978aaf4919388fb0ffe44f287c12c1870fc14045627445779b9a53c3fa0f019fd1a54226df6e154a53589e216db87cb9be6828e8555515f211056ab8f695e3ac3d5e549ec1e18319676f9d1b443cc42f4237231a2d939766fd4715ce46a3bea6af4c6c4ecab2933d25beaac35ddd71b9c74789cbdbf06394aaae6bd0d7ffe3c871940796bfc1dec33d3cda0b8ca7a85cab0e61077b00e05ed7d68a85c5953d9c7772cedfb854ecf31eddc3d65000e0eeadfa4aeeb34290e390e23d785cba9e10bea57bf64e05bd88fa54074be54e6dc34dae38520200bfae1240503f99397f9549537cb1661634ee04d94be9f25bf9a510efed124f54b3b99ad990b425e6e1ae35dcdaaeae623ca6847aa93444277b3f809db26b3814d74382d50e0e6c445b2798efc1fd5786735b4e383c19e5850492bba0ddd9bc6d3199e5478e59d740ce709d0e6a0bcf0e18a46f7c8fc30fdeaac00560e00b21905e3f72989abcbf9601f3b989d35a1867ad51d72dc26ad56e2ca64ce8c5349d0d1189602693fee8b1e230c315db91710c7cad1fc5ba9ae468842fe24111eaf26b5b117f9b858a118e68c9366eedf61476e45bb48700c14987407591285509c2f1d608b8821dea22f9340a3088f3131fc11ca14136a538dc98c84a314a0c1c20affa4e8be990f422985cdfcfe661405e778e8bedb73cd5b40dba397b84edf61d80d0bfa1eb21f5824ef1efbbc482a32526536326a2ce8419556eeaaa6a50db78e045b405db299b1fda3f06ce05fd37e56584e968ae9dc3495d9e64dc3853c100d0aa6c7fbe9563110f01e05416f14209d71ae894c1325acd966d908c2f31c953552b2b41d2637366ce4342caae066cb18dac228591a9e322f435e4dd8c3bfe6c2bada785d8580ee6077555437c4a15a83ae40f05159c639a3cd27733342f798ec92ac68146d5575f1329c4189745b770d52c349ca9340f04db19ac602af00833dfebd0e0ec360deae96495069d15ad848495e9f14288171ab27b7b7a7e8aef5ca433b570eaae9dd0d675b6a88d4a30ab76f46636bdd1d7da84a3a7d7a3825f811e2f175bd95d58cc551d12f22864ef39dfa133a8ec23b3a9d0194d3b05117e809d82fa37d250e9e308918e4e0c02ec8077e7df00234dc40e6f25ea91cbb05bab3745b6c7e730a0d029ca06a6a066075dee4c149ce143772b2a4d1dbd433eb62c0c8256072cce696ee925b11314a112d6575731590445ac1fa42414b88626b2470c31960895933766488092c8f17bdb12f8c31aa0e17d9f1c81a669f9370aefeefe74136351daa0f258d1aa1ddb4471090bc0be37d46f91bf490ed10e453abb6a27b162a6758885414b656969990e584fd86a1221d657156c177875a7bf930a5023fbda3af29ae8c1dc18f567cec86521f634833f4a34e83f985999b4e3936acc841fa8d63aeb85cc06c99a3a632f9bccc32b2d35983f4898d13d6f95fd69c50a01a4b879a6796c7eb4d4502a67869ee93d9c829db953de1503b9035011b99d8d18b071f6e1deff3b1f73852390403ca19d0c79171f5d6fc3c662074a99e7e637415a6fa6dd23ec5c26faa4d103e4271de14f91011af1d9c45bfa1dfae905fc9d721800abb50d9664255899f84d224b3c64593ed9a9bd0fc3de8fd24562d7c00937cc936f657ebb90cd3bae13e77ea53b26d12f6baad6a11c0ba11f6e1bbdcfe0ad88ce06e629012fab02929a5c4af866ad2b2c50663f528d7dbb0190c810fd736792992506f78209f17ca9269cc79eb6f25f06ffd7e8a321939ffe184b160e6380d0eaa3f62c030e2c1dac2ac44ce4010ac391a9472166b68a468193cd6abf258aae76de5867639e3daea89ab8ea3d3be5c86d2d42ce0211b7a66dbf36428d4771173220d95dfc913a250bff50fb06e0d4891ea5f421d73e780ac677f9b553892a35b6e565b75d58198c32058983934593c9c30088e5d49db33323cc2ec7a53103bddb9cd53e714f0d7b7aeffcf231f7a426aefca91accc63c5e60755c4b310e847fedeef6ba54aadae5b9e9dcbf4205283847ed3a2beb210816071300d2b30eaa9175855d067c93c0ad57eb4043bd06cd1fb90360bfa7423065bd40e00c7084b8d675afc849754ba4a26719cb509faf5fa33d854e74481b2b7534f7df30fcff157e9e855ac0c92f45cd3a45f1ed81480fa0913ad221202bd05c8cacafa4b57d200474785e8660a9449a86bf38df98f955c6662aff46793d48dfd9bc26abdc0fc7a7408f967bbd9f5b485252f1d536c1dd48aeeb4a18c94e20c2f6608e7fc27002598b1018d9a308ca4d4225f57570136b9fe93a396e22e3f3ed4985eb0301b35e469231956bc1e461d7323ad24d1ffaad8e0f2a13fdc358a8d4c151c1b117e861f38e056ac1a2a6787fc148375c9bd62b210e8ab2a8a863a180330fd73771552e69bd56614cf92c84cf43e09a945f5132f55663d6bd284179ea6a4079bcab6aedf6afa10b4aed5e69d79123416c1cc14340b5d83e2fba5b413bb3a9c3833c74e03629c92147683acd193e8f1daedcaf22030d3399200bbbb61a895b79044b1535fe7847425a1052b8deb9d5657c0cc95bcb60f816cf09308244501e279e4abfe05d9980864368a2dd240a8b13c5185bb80fd1b583cf4353aa35ad4445aa77ed9eb383ce27203bc85cdf2b7b64ac34f1d9922ac3fbe6a37ffc39ea211c7656f8c51e1402fb4583de96b4d05feffa5d9b5572965b1aa7f6c70d15c08ad9186ff699cc7493181238fdbe207f26c833378005b5e083752e9bdc8d89d2d654e117afef52acfe28898e5f4b4d8298365222f32c97a34824055f52155c784bce67e81f9e8c674597aba769878b09c42e4b97c11c88ee963b46e7a1b5baf80da50baade2ae49fed9531ad13bac219d657902d1d0defe19897266b2865cc87a92912ed1bc5e2489fa762097018104ddc9ee225515677b1acddadda90b4281d3ba13c52fedf76a78bc94eeb9e3b40804ae11e08ad4924fceae3f64db9fc61104b5612a0f21a2e3ac2cbb304e563e03b591816c426327c5c49b9ee5fe081c48ac5a48164ee9d6468dbc4df5ce311c33efd74dbe9142f7a55f0fabf43fa50dfaa2eb5972b5fea76bd16c501bb01438194df534c4a30492886fb6c9e2ba60566140479d880b1030a8c7a70f4024d11d628a5ec66bdf4503c1d037e25a7635b5dc309819ac7d8d36b5f0d3b25b629ffec50233c99915267c4ed30f9b4b93e6510d09ecc3d389c0c33cb6fba58630aa69344ed3640f8b0b61cfe0252b4b3bf44add42110a560b9e09e74d973b9b7a9a1e54599b12d4ebeab67597159cac9fb068742c8ec81f4b94a5d8c0dbc11c9cad0afcb7f24e6883e9a497c374387be57a3e4c3f0d76ec51afa46a0affadaff110c3d17075937983a650a2a9eb4c649fe06c34144a38b07601e27e2ba7043bfbdc54e03459d59ce77ef79f0447300edea7147a5bb3c9fd6cead178c3e8fdff9305ef3244cf1301829830137a293de221f668bcfb62f556ca9e2785bfab12a69dae6930230491bb205221440825984e74f0e171083783f7fe80aab77b8a32ef2942f7861f1cf52ea48f6c33ba9f468e6878f5694972a1d3f13c03502f91384976ba90d8e5db125bd5e7f136762c3d76ec535b89c2249afa344db9accdcd0795ca367bb6d7c69af52c42e3df7081138e5d80639088e57b096b503e918c1b4ff6be4a82161378bfc7bab483d6330a092523b4e61187b7f5f072da9eb29b7d1f9b1a0c7e79851192787001178648971c2485260849623bcafa00e82e7e0b4519dd02c25c0622f64995320b994de3c9c5b5182f96ee69811f25d346d16830639e313181d0f31e19445415741ae2712cf1871a2fa076fa06df5f9712e39d571b8116c3ca285865757b24b2c5c7d28daf472ea6d5ff4d5dd3585eb35f95d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
