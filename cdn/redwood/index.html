<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a2bb552184045ffafcd38e0cec674b047f3d6c5a5072eea17d64c5684e71e98fd5eed02fd06f4469c6a6e77d8931d041a2aec8162dc6abf8fcb456a740688d6aeccc0f427ce10a508215d3c846bc1e74f1bf830ca7e7fc0bcfe8f98dfaa7d7f5c43d53d0a3f2f0462fd4e7b04a2c5790aa23dc98ba332cb655401464b8f435b8704f5930f3731de8a8cbda84673ec6f76dac18392a11969fe67168cfa29671a1281605659016d1c3f2ea4469affa4237fce864c3abe3646de4e5b5ea1d9c2a4957b76c0b9c00dcb03b49d0509b6120b8424ba4a7365323d89ddbfda63a53f62d8c41859096820594a26a3db5cc730be6541f3f3d844e77ff9c8d9f9052714166cc3a95e4fc93cb36d6a3d9618a514e8d6fefeb0c1783aa42f64aa52ceaec2264b95ffec3fdfa9433827b6905864465478aad4f0982e8700a949264344f7a22832ed22d391a33af543c7df2ad28429f885f90f317cd8ea9010b2a7128b14b267d418482c8b829c829fb385c7c4c6c0fb85a18d419afc6f110c864613682c26a5fee4022f72bcd6cb3c13e8f05423c0d8e76138df97e4a6fe3ab3b00283896ab5780d74a83a62bed507c6113d4443de4b0941404da91f9cd1a6e7754c52a491758c581d0dd6f0965ace2cf4c9e5ca564ead6dc4c648b48127e42533894ddf21e56ce2ef694019a60440da19ec685c98aa010817187630e1e61af9a4f21ba0b293db3d598b61f24093ec778132518597d99874ea361ee149b923714ee7ff4df713ef41c0ed546e9706e043dd828746f79b7bfbd8bf522347bf2dcb2d4191053a071b5b3e5dc38d5e23e5c9431ca8e8ba8aa45ec2f6f0cb7269d29620fdc221cb84dd9857a2e72d447a9b82d718c67c46e7e8c2e16a710aab9024a407ed8e52a5207539b83dd364cd6d7175eff22826dfee24f541b2952c46e286208988d386fb44c39868ca236b9f0799dfc35f47919fd6c74d68c9ccb33da75b825f3d341252aba41a9820a4f6356de91b57471f4bb0b47cbfd5d42337af8d0cbff784839abd59a5147ec196e7179ee5ee79f4215a552b326bc6742bf09ec8ceacaec7b82ad5c7eaf3dea41abb8e4000460318a3c786d91ee848623720c94053d46e6c30a13abf9292feccfc7b64244f198a4e5b6602e617db85317a58613549feb376718f01e48bd2b2cbb7400fcba55496f8ef1a7bc75cb3f7659128f5f683ff0d819b6db6d3e4e7977d04d707f905ec844c37cfc1072073fc6c08f162eb9810283aa5f1bfac0dcc037da0dc6cd15d4b8e9d7ea7157843533682efdcae2d7a4c45b341a4f879d3c6317ea6ae40657e3b8f475b04cebf1788f2fd3d4bf30e738d96f35f2d7e703615153f5310da7f9c66567633c86f738423facc605f8021c3b76f69b6465e304a3136b169654a1fb52d78218306fc6d40402d6104be085eb90e23de79806d7b61058cf16e5b9f5dd4d71ab856931e2036397e3df600519e0592e6e3e1fcc687b96d469ec8da29831fcd4ef1460e30a64e25805f05cea731a2c98b583e84bafd27ca5be1135b1b6ba6047cc123d48c8041e753ccad020acce47b8dc0cf99a03271d110eed99900ec07bca9ac200209f35439ce909409bb157febf062b1b18430bbe7d70e227256e4a76e0ff1f447338108c56866f831d06670ee1a750b8a4cda18d0169ba316f03a1e3fedbf34cf76ac03730cb873485020fff99ab3ce2c57942de31cde38d25e11a3a9577d7e1e9778effada16aecf6390b19b73fae7580b2b52f5a468d45f3f1636304c4137d21217d5c3d8d67c9910dc58e61af0a8bddd521db4e990cba8f9388c9a0f47f1ddf2373660eec98f3fe481113a95fe169bf0f5115a7dbc80f449d5bea710cc78e9e1dc61cfad520e2b63c3e341d7b5087ceb5fa8bfb0389619c3d6c4d50532a4d05e544575fcfee2e7528b89e19e42047ac9b65ed673cec7763e851be7166c3fd90981c580b62335b6fe6121528fb7c8cf109cb2044f3378a3aefbe1dff730d5c27113fca17087dc856d0b8f4925dc7c0e0cbb1379c43782c85fa33ba997a2a8289b453b3d06f72df4b64fc2fab976d43133252af072761efde23b90b7ddfcfd4314929f31d17553b0520d7ffc2624e72939c59720dee5f01ce18833f59db569739f3c0d2e2c790f2de4ed15fe92799830da5607f73b38a9e478b2066293bc64d9d93e89e12821882f85c73f51f18b5748119a760c6f2b40cce6eab45d71cae16146e6b6ba680569da251b81d50b0c7c043f96f75ced95646794243f1da29c1f61c264f0cbf64100438af51fc2f5b6b325bd09ecfc8ee243cbde7af07ce63cfd8fbe33692dc23ab93aabfdcd6e3beb909929ddc6bd92a1befd5751a9b874c0c06a7fead7bb9dff6642446e9a87a77bde4b164e4aee61bd19e98c4454c92fe53b22219dc37c4e4bf064d29d2a165486babe4d8b8f9231f0de63e3b7f0f6899807b619fc1c23e37277b6e7e7140e7243572db4baf316212c41568ca31060e9f01da2bdd70c66ba8175753edba311fabadbdec2557398083810e5e340e4039407f77b1550c8f48f4daf76635289c29b9223c0c5f6bd04c387d4ae4f1fc73e615e5c85db9482828f7b3b0ffe6c632e9629e101245f8ca510376de29c5cc82db07acf16d160e46c94526ffdc5046fd7ad20b5b52ae048daa290dc181e8f1a9c5b2d404aab65dca3315a9d0cc5ecb5bc15f5d541a42cbee9a5e2e0b5a3e9e17536ca6e199c57176868b3ca7281886a074741c84c9a79bbafc03f7fd72289a8f7ece46c768b5bca87bed5321f0b47c3780fa4aab5db418a1b96f8a8adb66c3819b1d0ab8c28c6c62a15464b698ba244cc751e6b89efc202f309f718e450835fede19ad4d33f1d16168dd1390d3d8a148fce43a4dc50aa80c114ef48ab00421e94ff18e98246069ce3b277225111de9bcbf038322898148c328db178076098d6124d93cfa79831369af6dfa562c0d4da614926786c059a648c98a62ad0808e28d1fcb631e54332a5ca98e3851aa02e74b0629ca960742a478434e58e6459dd2bade801e0ed2370389862d646003e0d292ed5a9feca6486d9dbd7d514add23a0685ee3e96b5bd89e050c7ce49dc5347731435cf2d723ecdeca070a52be74590e2ae4c1b1b945f5ca6037b17c47a884daa2d93113a921a20a3a2f4235e9a35a867c86945282b99a0bd914da52255d9a3f139ec9b2d1fe1f6577aa892cb8fee00421ff2cf06836446f65e9b94a3393286c72e89fbee1be9913a28e53ac5fa7067fc321d3dba3084c0654ef9bc30ce1644a922f7a7d025805ba50ad79afda0f4e5ac3dcf9a47fbc2120983f4f24f71db747e94d95ffeff4521b0d63bab280a285edde02c7bdf7133d99c19d39a90420b7f17107e4544916267d4ca3ffca2c4f0afbb7e229f18baa680030150185940a1cbc797351bf90f927ca5075e23961907c50431aae40f013089c58cb4760bc87a281ee5fd8930b79aee6b7bd571cf41d07ed48379bf5871f16514ea42f7fefdb186092c446bfa25db1506d6842d429a980a1bf1fc1c3c7376ee5afcbac58b6ce87d4d63282e32e49f0a0d499d8dccc65a145dbcf58ed586b61bf4df61c7c5b53a72af98f24b7462c1ff321f7d82d85d6f9ab7a299459ac5023e5d10c490741c19f2759a763aa650675f850ab05adb8153a8de7ab32fb491d61bb5f56d661b9fec3093de3898977861ca0358e9c0c4d6a31fdb01e1c04e8f747c5fb4bbc36c82ae23bf40c9c570d646e8b6dad28e7c9d76f2f6129f6e4fa25c81523afb03b46d3bc5efd15f4d332bd2d9699001210c2e4caa5e99e174bf69e323b8626782aa7785285df54ad5b85d354f4966f5da8d7efe37781b2ca7f2d1d5229a07ab02851534cde39a0eafe68b15527ecde27162842a6201f7de382f2793b8a1d3fdaec40bb03d319be7cb658e59c79efa92b94c987d1fb20259b8c613d32a81fd84194abc9545960a742c346945faec860b5dae4980c3b0cbe4f9c4b9dedb514c089d18d0bbee400d54c37060be8cf87f32770d7caea2b6840138acdb8ce176ee832a9f708c450ffa03d7b14d865729ebe0078cb7ce2257d1c412430bf6cff9e516e4cb379ef0df659036767ba84890a03b62be7de056e192fecbc0d8b1da516a5decee31c0a0d52ae34cece849d35c7c998507e5658a487fd455fb8504446d51b48f8f44a42dfa0da02849357d67fa3b2c63c79c79a8f6e6d345a5ed1f0c08e217b98402e9e7fb79327d81f0af9db2ee8dfe89ec1fab4625b07991b62bdc8f25d961715b4d298af2c53129169404117703a422be81955af58eeebd80bb00197828fdd4389fffc36a5726c37a831e23ffd3fa23e0aa2d1c7227f685f7324fe8824a3ffa100e71abb6fba840f76461444f2a01398da2179f9612f1e28e39afc29328418a54cb98d7209ffc08951730fc316181288dc8337a4033d31ee667886fd106648dddfdf261d731785d12a834b88474560617d5fdc086da59e4dd13b225995378dc4a350875861838428bb4f36e3de5d1ef4ffa6ffad90c0410876401c3e02180727084e37b44752b0857e14783b951bc67b43008cff2026ec55e643fbc2b424dad1f1d0cc3ed23d0a997d9a104ff83c44066890eb0bee22ed08c7289fb952f6576c4e10e543ecce80b63bd47872df2057e52500a7a6afddd46d59e921bd56a8b3569042e4a8ef43cc9e15d1e2e481e8dba031c4f43b18921d3f10906c1ace57fbcfdb2cd99d3f2878ff2e2c937c6876644f1b7729feadf8bfc11391b2a32945bd4951ff60e46f6a6c9c588deb833dc2389284c39c59cd3ff232f08ac606348d96a747598f41479e38ba1e83d8f720961416ba72cd1de24d0771c71ba66a2d3dc77c2ddb90a69c490b6ed7cc3577bb2406113fa068169b046116ba9a126aa9a0d1b9497e6ceaeefcfc67b0a58edb432b010628f806c40cc2b6c5f87a4eb3ebf0b528631a66ae433354708ad4970dfcbe02eb2fe22e3941af52786f29156d910a68d8d82356532cef910896bdaad67407ef4cb15e6900ac8ee7339d8f5803807878f171b52cc26e54ab25431e25724bddf39e19662ef0aa18f500e7e79f61141181e14987c0ab6b40318ea2aea73f2b007e93e06f664fd70af73683eb04b358d072fd5242b708d82d111ccc2a47c17e96890103bb4ccdaa4a9e169c329cd25dab56f3897e24601cd949d14bb6cc2c8ede5b22822fb83ea0c9af437a98752d5613593863dd2fc0496a652089ce102b20f23c04a2e9af023848c7ffc8af97a41e6c2cc5d3539d5a2a061181f42ec10ba85d1e37c10ef51011505808ea93caa2bed84d7f7f211ff0d1884c2a62b470ea13414a90e92ab416106acb34e43755d288efcbe3acb595447d3630f573b3f3383a7c12e025f4013c3791c3667ae6339e8786741ec8e40537f7df6679bc24c09c19d71796ebc4f3cf3b9232ccea686d05d7765663238d6ce2c248758c6e2d19a4148d3bccf18eb3407e0cd630e93181967d4cd2803a66654279e5d4f8d016b5e14aaae2cac2f557d1c6b5dcf46776ec565176cf1bf4c4202b30341cce0e7f4d4fb7b7376b0fd47c18cea4d252a3346d0e1db259b761dd66adb769846377e58b77a0015626d4de76d68ac712c225a4671e22dff4eea6f58a58fa51561ddc53e1b47796d8cb56414b15ec358bc8ca9cc89aadb1a304015cc667a720fff7f4a658bc0848373e66bd52ac5bef13f314ae0d13938ed84dd2de81426c16050bd4e26e877c41a2a86694398b1d4d75e9d2ad673f235684ec31a1ee70055289f498b9e25353b2a969b0e32c39b25f8c306a3ffc91fdd511aeeb944f3c5be0ce1e1ab0525475979e323b56f72927eb5ce9cf5fd80b046b85479c67934984ddc5e315dbbc63777390565e836dc3cb88206fdf6c543271c3e76cd33434c8e600b1fefd6e2d251be5a73b431561d3ffb17ad2e6406833abc68c863b9b6bc310f7dbd1aa8c8ccc3d7d1ca0fa13bb2a9929d9700bf04adc05beffab3dc11c4b45ce86084b88a269f81a4e1ab3101a9571926cc5218e774a88e08c1352132cfea2db12328edcae73f12eb2f22941194b0f7ede351351b5139ce8757b97930fd4f962f0a1aa99a9a8473992d8d0c1a0748e9f4769b049c5b9d7317af846a0a736284b76dc3ad78e697c9a975d67e0305a4736cf25342f3557be1778f90ba219d4a469ed061065acca7b42c0567f51b516be7b80a9fbb4af6d691b4037101004c4852e17a5e39d6429fb01f55f6dc3eaea9111ff5383a5ada1e37596c546c15436a2768a7857d18b46a6b0e00e91ce142d19255395c5259cffe3776a2dcd1d19665ba9147120ac9d08d76cd8cedeb2182e9ecdd720e9f2b47599e8c6fa09e232d2a3537f4a3371332eed6f0f86512517b4216f0e97de514e2e2a77770b84c8cbb138098dc0281442be04ddffc7b333dff9b62cdf073009134a2c846e018ccf14f971304e971d88bca8594012fc60837beaa5c04125d6c10dc3a6274aaa987c253124c9e98b245f03a5608e38999441128c6e7328745ce93a25b1d9fa03310a8fda5d2c70edadac9e8363e4ffbf7a960bf130566cc7a76c971e8f8367178a9004c3377f51dca0f7dbdc02153c942459d8f2002b6c46223dbc52083d2c72c2f089c37b6b307952c2a1e821a04676ff740fe1dd3e78e597d047ab46118c299f80180aef01fa5a567338250ee718e91ce6da2ce8a62c7fc79fc874824c13c7b32e40250733840b314c3b058f693da248f047738e4c0dd472e94b065c6793809a52c126f3e6f790252361ab2bf073f2bc6269ecaa48f0f1c8f28785786dc4d2342061deec8294e30527c9330e4fff5bba1b48c3ca13e1324fcfa75dcaad248c7c8ca4c569d88be5b335efd6efaf9ca21cc9989e3faa6e072e0f43af959e63a2946e6c3cd9579c599cf78fb25b03ca6527909f57a0530458dd14986ec6404dd84ea8b5ac043653299e3314e87012d304a2dfbc34119b339d2aa9c77b882269739615dc57b9f72219c4a729fdac5107943d8427fee56ae1d9f1f9924114de3b1e8345c2a40276637e36e7edf7fea5de984eca51a0125f305a9509c7bee370b399ae212f0d6a81149e13516546217e3a1fde019823108c87702ae791922a3330e5030cb192abcea2438bd26ad353fe38a7b7757e761b2c94d0c7d0e068406d96de6a784ac8bf9342e877f550852c1d5e3af6d44d83cb3368af28827c45ea8902d2c3149be21e1d3b24abcc0e498545a2b0a84d3955e0e329fa7275f0e9eefb62c524c3adbf7ce4662b419a4ee6fae57dba8f79baf4f1a3d3b0661a3f01e4a4f8dc724b80411b5f4c1f4f1455bb98ee35d6218412463af43571b8a2eee1ec271fff1893c7e3b1d46f7179fc5e481f1481bea4df4e0d69b5f5d413ccd8f8adac419f83f17109c551ace5b1f1c9d1c57ff1320250cfb0144dfc5f3d8e86621f240b2721bd49f308ab3d653c99d84c6d452d3a0e5ae86109e769e71f6cecb3887bf59aa5054d51326fa7f89a2f517556863d4b332fb19727a2f6d228272aebe83e44a4989c90ea86506a895405a09e52d6d7a27a616afcc79840ed80c3bf11f1229c9ab9a39326398e7b2099d9fe3646f6212142ce60b90179a5d7e75380989fcbb3874d55094176afc945fa95894082ecb88b0f764150ef0b7b00a19d3c6a118a756c91d7172d02f520c14171bfb23b5bfa78596889d60e5f4b3f5eb0b5512928e479735a09422496e99ef81c2ac3b52d4416c68a7c10ab77fa90de620f6fc4a659fc9a26d06e6df005781c03d969c859dc25f876565809046dd89c92ec731d884a906a7336177c9184f4117e327c007949a381ea0464625621b5c636cc0462c7233e5505e750819dc855f3cc9bb752fb0cacc4d64737272940e27490e51e564dac4f61e7b7058fc5a0a9fc541259db88b8306966032b1bac3601c2b79a97f5218e3ab920f4aedf854cfd6eba1e83f529ad1aca2290ca933efa3bdbed1ebb0743ce715859bbe33f431d5e4687ee02962ce64b0cca6311bbc11f965281e948185c3274e48aea04ecb792fbc64c9c96870ca3c5e0a655c214f6838372449a461417a65a502ce3026c47fa6b0eeb025600673ac6c25ce5d885dcf6f86b0c7c75ffe186ae80128a072f94cd7221e0b24e460ed0c0ce4068ef4318efc3329cda3febae9ab191a2c2fc26141825cf5626c3e210bb6e3f146fc89efce35d43f932255f12cda75c792c99955c1185e38d44cb1712dbf6ca16f71f06ca660a96c9553bc216983732f85d68ab6db780240ce7616da1d4398fdb36a671ddabdcaf209f4439b7bf9db838ac6b74b8e0779cd53dccdc91eb20a1d071706c7540439e4850032cf2379d7ca9ce5c357868fe78256afb7af33cf3b5065272f9e4bb959435136e6cddea4e8af7b8c2bd044f0deb449323c1866b0ce1278e0db4e497bcee15e2ffb75f45cfeb0f0bf0c57a6442f836032a29cfd29bdd74d725e7bac2a0fae6c9569bf16efaf5cee94c91701941526c18112380598407548c1ee64e808f5dd17cb40aaede980584eb70d3204913aca7296046e6c440586f5a55c59220520478ff7fe8a68a205cdca628f91efea2eac42ecff73c4345bdf58d7e877271b76ac30382ad4befe3a020d0ce9d6b6c1e730925e5d55699818e30c728061d61ad1b9c3d57122962179116a397c3765cafe5ddc5615e7cf8948996957c8eeffb95050c8236f779ad66a213388f84184c56ba00eb239aa4250e30a8ffbe9e972af66f39b97addd1359b970bae8c81fee36338d4ca5ee589164eb45c34f5baa7a4f9c3dcbb9d62f3dedc1d089c1158899b674f1465d4782e86e06b028340e2bf1fbb3c93478b66f51037f3b14f26f2cbebd7ae692ae153d7a1f0ebe0c68f062faeb741230f95b7c972fc6272f019f3adc8a45abf2f21d527d107b812587ccfe445feaf512d9446a624efdbe0402a07c44a4077c2cbf4e08869a9cfe14349533bf258e3345d98c2415c7caea5ff809738eed59fdd7edf22b24c89ba0786e7487aee50f3aca89d9bd68e11fb50b7271170eebf5630586c7a682c46c209452a1625a4c25e62381d6cc8fd1f85e35936e24f7a6ddf7014dfd4d83861ab788c0301b4f02b01209ae3d7a027159cb37dcdf7b4656ca8d40a2a2f180ea930a0d1259add7dd58c5b136b6bc4acd91a174e21bf458bc851801c97acac9ec0a80441a7302641ab45c36fed2cf4243c798b1e2ccf8f8fb25fb9a560779ed8d96ee0a1e6e6b92872ec2e97478f07862165205c00768a81d76f172f9876d5e376b9bb73c178111ea250821a2e033c2e077788791c51add919e7db051015e9b265c5797dc95a68732d4e1ac2d35c3d59847e96721ae9882090e72fa8468d2fccb6d9ffc8dce71ee314f645924077f6420a1d3dab2e23df1c36eb204d762a15b654348c493c7f78820abe95469d99eb8e3c7fcb1f92ac8db67e54682ac9b7ca0ec3580f2ddb2f427bfe671d62e1f4605e92107a7dbf961caec6a1c0fa23bdee5b2064e02b532870818fcbc560154de62731d289632712e80190f5980f49a63633ea6d4e49bfa0487c0cc176b39141b8d9d42904c16e4ff35ed34a881708c97be43a4881c1d11f5a2791b87ffde9edbf404e7f743274810230006365eca8f688f999f6532bad02f6a71c991e6285f5162cee592dd784bdb05948bb3db22291566fe35d6e52cb962e7a520105fb442cc0363c785329df7569635043aa3d6f697b209eb6f9ed8b7b7de639a2da356e575d98a7da7bfc87282260a01d7a9e6eb83bf86f612584e86600e211d989a8981f668f9043f6bff18cce96c1f5107600f379d43a372eeede6eda38e5594f4b34fea10f4b85a9ac1766c03ba0f46fed80d301ec5169ec807e24fc511b9783a18a151c39c8a71ec29a0729b9354cb0fba025a99eeefd9855bb6691615712710d72beb9dd05ba5e5ddd34e6690ce412d64d26448a282ef03c5737ea7efe6b6f8a2a3dec0c30150e972c610be1c99486b6085505148acb4ff8efccfed3ad3e1649b71f6796026f72b09041aa965b9accc43e8f4162aca470fcfaf492c75040846844022258042f0590571372545472036d5eac29cb902ccc0962cb0f26866a75e5b9d21b8fda5174803b1ca5e58290dfb5454dfe61cfcfc8feb052691ffce189680197dc5ac781506f292b71d472a0fcc12cb98636f28a78e198933a7bcb5b24ce75f3d3d2c8b16032cc3c506dca78844f68951d948588169aabe4e076489975f48fe0918c7dbd03b490f2b1c77c910df03018c6508d269b10de553d905fc261aef353cfd32c3b0301a9995306d6f7546bf0cf0c158294f3353fb2bdf3fd242974603cae660cc3b123aed4cd9fab8f4a37f368298d157c3c3004134df01202588fc6c75016b45f8249a358c7f54bef4987cef3ba29beb26c05c0f5acf61e41f540cef9a08a771c2c5040013b24a0a15791bd3e304ad808879d24ca96b4e4191fc8fd1a303c7a943fb0447f68d3385cadaf73f7dc87d17de7fd1ad20017ea140249370db90ab15852683ed2c092dfc9ea7c1b06f5102f5719b7f09492c86e470ea526ef390472117e3e8d1f0aa66a6734257d1684d4d5059eea398e6d586e58f07ee06a02ecafe258f477b1202623b2564fb5df7bec9742becd1fd55555eae488892a0304f8ca961756d1f2122ee3f4872808307150822df32c43e1e842cb134bb8848790cb840892165a958adf7f55e7c937b3da5aaaf84dc986b13977dc2e932e0ff21c88067e73084b13e14f6ecccdab9f6d209f4e14e8a59d82d2d59bc79e18ed170ee1e4c641f394ad5dd459331d7e8b925b8c162adb634c7fe83b836b6a39bf23bf6408e899f4d3f90eca174b7a37fdfc2a625d5919e5aa794c4fcbb94095af5530959a859a88533e2ae13832ae7e903fa5b09f2b1d58747bac081981109e13e1fa1e85a5cbbc8fcb5649aa2aba2f009568afa48e76e4d524334b1e09812f7cf2033b2822b324b15b3173eb4183748b87ced87681bc57ffc88fa4b4cd7f345a18579d7753d03201d7dfbfb9dae11aefc7d8d36ce2b3aedde935562bddb4bc4a636804a314d901c2bb5ff4b6d69b250181c7db2bf26f88ec37376dbc9d6a8db1a13822421b342e376a2b64d50a30a0926b2845461b5075140672c004760bfb34c37955eae58d757c660cf10b2eb12867a0b39cd9ce03b163706bfae8c8d26c673e66d9fba9046fde8afd862daecf0f17aa82bde2d9ea39f0527536b9eb43caf14669df6fdc649ff2d1bdc79b751473206960ff7834268013cc3d21c73ee00479d0bb0f4e5eecd3acbdd1d9fa6f011094e03d9b977b2050899154391fb6db61a3b21dd6f92b543875929f6629570093a6e6d26db3c0d665fb3af37302d6c155542a2c7c908a724721161c47f8f743ce0ff2336c6ad2cc410b647be0d0a8dfefadfdd52d5fad9094824fcfea91d7c3b3af94b989f372974a97b94c74b75d5d0605dc082bcd79fb3e0137370470994578bdb549cb48e46d7fed973fe3eb767d25f2d433ef25a33635304f0d6c95a6f026e97fd332a4ef911076741b6f82c45e8be8d3f49387f4fc10184739a004522de43534c79be0f21f43102fd5ca435c7536fb910fba6577281151e9da0bcb592e1b35e952907a4bd4e24c89e354438b62c3317d001007875a7f03936bac57d42f0822a44f2770d426b3ab0b91a7416048a1a8dd099b4f164407b2c966319c48368faba3972cd2f1490d7bbfc4ce75c7d0162e02068c7b4430e051d55e1f1dcb115bc810ef48ff248d6bd6aae05cb16671cc099248baff74fe595361b93798ffad3313371da639e12d32664ddaba82a5a02f8b9cfd4e96a283ec258871c87107fe2729abf15369d22492457970f2930ea52e80b86ed3cd8b239ea546db2384c2af0ae23eb510b8fa3b62f564d0ec2d8693bf71d0294f7483359aff83f70480d21ed22e746211511e2a002b884c422e1817dd570d221037454c5b292cc88dc6f77d4c277f7bdf7ff9570254b7df120915ccbfd36a630bda7f5ee1e556a480bded064832006f57441dada86d740047b81f758ef4a17769f5ec8fd5eaa0a5f5fddaf4a55221fbbdfa3d543b8d3ce128b9964adb71c2b866f6d19d7b95e4817df9f2ec210df08438fcf6cc3cd6c2c6030d130cfa45b1c0b3b7d74431ae0eca9cc8a62111412ac1b40b6013ae191ee614d04a8a44c8ce4564ff02d735c59a396870ec034b058646d2308da065433354041dd73e2686253eb5e6ac4fb56a25d3ae78ec63a88304e185d28b8a092d35c612b3528eff774b87fd9a057eb68793e08f95b44de03273e48f64a0101b78bccb3cda3c8dd589d69ee2a82ac0028072de3a7641f888e4b2abd7769114d5924477e19fd6a1f4d81b1b58578c12e558dddb448018900a05cdeac8800ed9a627451c23d46bd70f2a86ccb67516c8573fc95104f16773fc5395fc4bba07e74366e9c6feaa5511c847fe98715d9f48d6ac839425e6314dc90fa660242a523a70ec27a7154040f7853b05bae8756ca9b69cf833d7203e9c7a560b94044fa72adfbe9fff586fd0030bbeff74cd0d754b8f933ad3e11b2db44da1313fef19365b637a3308b51f451195b2498b8ba5662e38d94e6dc713706c1e5f02df85519f360ed9c18108cb1608fed28ccdc899e19fc0fc500b06ed11f5490304d4061654dcccb6b10378cb61e2fcede8db762573858af845af565d107f590705479c9db8e81a532cb744691ae2daff6593ce1b8ad8193a5570a4a5fa52071b5fe6c94030a7ea0fcfd75c5e4ce4a22170911c4ec7e2f4dd53ae32616c261c870a75a4721d8c2e08b58cdb1aa229d532a22a2133544e3d23266acc00988d469c9dfd5c2f61f3df1a3bfc70ec9f80460f507a4ccc84b9de5a3e6f42821adadb2e0290c1d46d8517acb885615e3a18ce8b6390050bbb36af71ace55cc89cc3aed631a1521fc8113d76cbdd1b1e2e36eca67ca82f013dbd67e48263a820b49d3fd1d734520893fd05089498488f746c637294752851d88711a9b3a643c9b6b5fcdcb0274cf7789bdf5df4a43fd0560e35968426f093afff2850e892fc008dff8ab9cf1ac6d527e1614f31e2e18f8b9b4cd059df666cc59767a05f7ec0d636dfb3a9aedb032b626685bd6995b18c1c698a94a005874bcecc2bda4936a24f57106b52d6ef0d8226ee7b33f067e99e6206671ab3ce396334db0b94363a33cf93386330cfba7efd51eaf2883d98b91d39bd53795d1e4256ec49ddad770d0f60facd4aa30eea0f809857c7e6253ea8d4ed34bc9ab29663625d1c7556d19fa512dc1f3b9357e527607b24c744259a8efac0e0a5bb61cdf7fbabba348a7327a6c357895257e79e734d5a9f8858fc684dfdb22be72860678926cb2b4da2a14d04aca2237787bd8411e75057a30b3fe9bafe568cd91749f0e9c7be52a580996bbdd6964ea7b469f43d4812320e45691743d06e7ceb4889dd73fa13fb30b7a312a1201cfde1ed7d63942c67ec76ebd286bb31454b8835f7414abcba56d30f8d675fe97ce1c454030c00fc4c190529643e122391542022f5bfcd7bcd7666ad0265e86185e47280fe74512bbcddf131f63d15b53dfbfb87b5fa3952e9b311146c3fda23d5003ba3f5feef2d4a698cba27f9b7ef888499e74a6a74bedaf7e3359d074a707ed3538b349a0ea580e7476e7815f3cd7fc8b8f111c28e950406954f83d1dbb2cc0deb1537a68509dfc6b12668ba0644bd21083d9da4aa47355652a32585db4dd644759cdee6413b507e81e3a0ec8bdba3575b2bed490f7285e222315c3212968b0131eb8c98842a3e51f314bcd6b94a13004ce11e1375920663b2d7b7a924034c2446fb690d480523e948919899a4229e61f38837aab4d47379cf34b14b563e2b1c4a19a4575dd23bf398a2132726ab15cfc811c1a04c8708e1a9818033944b353355fdd3a38683913e2c88c848cef1f4d1c5add6b5de02ed6eb53e13e159e0822efa49e00a85c93cf43ae17287ecfa2a0ce979f76bef499259349ce04f5a7b68a7e155e54b5addaafb42fef6370b501bb666578518cc46b90f4e87c0e93d90b4bc0bbd2ef7d4f9585140323606fc41e0c1b709a1ace54a71ad43563df05928529b2b4a280c9b3aa2f661f04678beb5c6ceb662469691801108c1b38119ded34f1248ce1605f09bbe587d8f38f841b115db0fa35cd2db1ebfd8c3835c7c153f5d97b5d1ea923293cad85a0e1441cb3b007072e2b953850274f21b9b960fab212bc0cedc8e16a9e12e7ac20da158e3cd116f5e2bef9d1a4a14948a4525cb13a37f59cbb5b6e2aa4faa9723692b4910a5948e56ea51697df6971a25c3affed60ffa5a026f68174aff1f856f7144e03721ca13eaafc3292e2f6a0f43865fa73b97d361d246808d6135d35d22d3436c802026f4b76fcd62edc33e68dea8cb75257a76c0b4136f5f237f9572b50af3e7f392d2e67853b926e4851305b121d85519b5bd237a30b09b618c98e22cad06da230c833cef12e2dac1e1c748d14dcd748d28628d8a0f714aee5861b17b9bd1116ba5e06551d25b6c1537f1823f07b2763c2d6c56fe28fbf645c030795c6468bff7c6df11bd21472d16459b7514e379d7747fb02b3a6c5afbb3d35c1b96076323a96e1e64415092c27b25607a5ade7d0d15c602a2694de517ab2c36c6f4042a86df1ba7ffb29a4a3f78839f2cd3bcb13d04e06cece620ee37022e1ee45aa18982ba3af7b946060acd4a138f9224b69e8cb689b5aea9622e8877493299911823a229bcfe7f964b4ab70bc7717c36546a1fd91101a946a15d15590adc2da0f9ab6b344d48dbe8568198a824353b0f46de1b67ce311b41d874bce7c0e4ae79f8f838f05ffebf36e26e8ee81626cf2eea5d32a01fe356a15c1b04db003a723e57134c3730944b8c58756a02e875c68bed5388510b4b26a8872cb2d9a83738855bf5d8fbb2b7fa3d22826b4cbb55da4d7e7299613499400208b59bb15b0ead2d247e73b52935d67d8ccffdfbb2f2eb931f0496a419cf22b2197c365143ff52da7962b3d5bba6e563b44b24c38e8db5b8d56c50c248c297bbc38cee28bafa4ddf7164a8fa1cd984ad1d2b5ff9d98fe514248463eb4f57cc0df82082dcbcc12a2cf07cd17a79252596c4fc10d2bab615fd81a1bfecd496b06ea7b7f4bbfdda1be8b58830c292517cea8c465d6dd5fbae5ee490f17071ccfcc6c2eb5beca28549276602e95a27e5ad273423671d84608bca9303c246f9ca4a4c272f13d5e5572e5725fa9f7385f0162238629c54bc429237f9e24a3277d35470b6040632a528181e4dc130a77a2efa879cfb931ef8bb930e5df06aae0db6f0693c27ea65ac9fd206bf91fd8a71e38c36392558e2b0fe9d8381dbdb35db91e2d4af8010ccf0fdbc69609b06aee412a187f227ebcd1d1cc963c310dcbf2f87a905eb8e22848715482c1e1fb1e798b34962caeb1dbba76c51d9cc5cf7b7037498f5b6f7ef81631e0b5debe88f07840b44cfff59f6af57c19191f8d84507d4000ec54089011b3836209fcbcf047ddbc772b48dd0d2ce672d118a950800caf995e5bebfd0481354727d441431acaf25c03fe3676105042eef965cc6bcb43a24195bd8c17ab82a2d8f530452bae36bca8b53e9db25a666042175644c45e13c3df73db459b8af23ba9e9f21d99f376fe7049181fb726d069c25f3323f3c0369746e23adc6647bea43135896ff09c3782ab32cba070353b14eaa4f6b4bf55c3e5df3353a5a4b6ce6a800e55fe978d57c9b8d20c57af54d36e2d842cee6d93a94dc109e9df4832f353061bec1be14a84e248cff7a3cc31adad056fc11a08a6898dfb7b5ef9466b7a3c0810f54cc5876977f8bd7a5712a1eb0d9e9f70d4a6b1aa2ec954c0343e6a0fd7896bcef1e6d6b8ad02143fcc9b0c54f79894336777a9f618aea8407f28847e1a0924a589979f0daa1ed37e538203355b12e5e73cb2ab49ceb341b36a52d51067e0de9286b8bc58066e1d37260fc17c8d90e0d01ea38eef9febbc9c3c0ba822be5ab30835b552da5be1d8329219ee4c430d7f04a38c926bd3ab5b593a132cab8614a1d92c4171094fdcb9f69fb4a126408acf708c71f94bebd6d7f7f4e4c41a332b9d3cd6d38ec8ef7b58c69967046fa37972e5a180ca9959464e749bb7c63e97f22bd947938ccaa0aafb31daf9bde45f458dc0115f6767da68f5d835a71973ddd480564e3cf58d8bbd77e4e5e40e5bf639cc5eafd9c9828f8f8afa632556955f0fde3877bafc8d67294000ab8ac18ce5ee565eedeccc6b754ee97854c7dc48a280cd48a93110ab49798cafd5909f20d3fbad2c63e3b4f75ebd6fb8129513fdd29a6732c385901612b24d8f072f9f3f160bfc378ec2c8f24e5a8a9caf9ab76a5934053b22caeab49435f039cdc57e61349db1eba29747b32eec38d9d8d6eabf0eb5678c719e29c7df064928a120463eb1b710e9d2434c7405e58e06917a9931a9667d4224a746377edc9403683bcf7d5ed4f4544806da38b0b18d84f15c5c825a55b7d546546ca7137433599efa8e20935331f0ecc1d97cf57e408d8780ab2e7be58e75835080688bfa7d5a8d9495bdb1c4afb7b50e42fb55bf47c3815475cfe4fffb9a985fc1f3d0f2e1c4f8812f7123db7b2cbe6a0463066e32a331010a67d223b01a3090a5d4499ec91b497659b56dc0d286497c9e6a319d87c181ee1f4f8d520b7bd3987eae0ab04bc0947858f7f42de8da9847d0e0e452a98332c46b9c74a565e3404c0f6bb67d87c78f49e9c5f9866f48e1adb38c87be568d2ecf93aab037704a009c812bcb84c91b90706956e419560415ba70b16b3119436fd27985d91121e3b6db0a02570da628ef9853a70eb1d1af470e45fb3943e2f183356db04fcf38093d3020c75f602eed8fd036e06ba08c550bc5588a86dec5c7eaf058d45e54a856cd11b8cbbe6e15d046171a7a2afccd7b5f17e8e18f18cf9ade77d8b804c888b3066872fac496d3d419aadfa281f2beebecd07eedfc38d95e7ffb10b0395e64cca76fa36372d916b3079ca5f7649e94ed3ac1ea4fd968cf387bc70dec48bd5177c13eb9a7b0f58127a0cfb97b2fa079c3984dc9d2f07c8ce08edfe7037db616bf78e3709031c9265ee299b813148f9ba163784471df3366bf6091a43db69189c63877cdbf1b2300f653033732fdae17d195ae5203bc8c99326df7f688f09c7e0b4722a6dba503a590cac63bf841abecd616ed1792a9e121c18e0b0810b8c832e6c251ae939a42245065520091bfa6544d99860c8b14825902a3a6413afda136372bfe357a57eb64124ebd74e911dc5b31f0fde68143bad902df9bdfb48ba944816fa2ec9355e711090ffe4ed18745be88d4160c85d0365509f0fb08ed16f43f9d31c0f1de65aed04577a37ca3eeb0736c494889c784638fb2af01209ade8c09b6d1d681e645ad0f82a19c91b77e0c18cd88eeb2c295a3ded46e643a11f2b92a8c808293aa8265f6c7eb5eb6525ea55e0f1ce554d3e5b4aacce9b76ce8def789578b1050e6db9ab493e18bcfd2ffcc58a0c698556014b05b0290270a73207449eec18a525d4bb9ceb12c97d60f614d7a7a638c61cee0f297950cdfa428233096fa8b76b416e41126c5c2f1f30725bc5ac66289c571134b32cb19d2a5fd9a13cf90337b7f033ffe31fbd0dd906ce64a0c55732db0f2bb5be366a4c8fbca385a2767eb1d3c80dd868f627858c3bc7ee576892631f3b68d361c14394e3afe12becc855e9a17c16b7858a96c39210b4412e221b618f3a4f3f54e3c47b678690dfb629195f5d0add74733b38fe49ffb808e7506ad0f4a9bb39267f04f7401596bc3f14fd6d66417f3feb8d978f6d8daf6bd5c62551fe8aa7810b2c3c553b98e3ae610d20d1d1a9ab0b800e0959d6ac4fb207e82e1d0666bc3677bffd5746da53a17bed43c8db159bfb5b4cc15cd344eeb761f027bfb4edcdbef91304301a7d66f1a3fde194a0c44b08e0c7446e71997aa2ccfe4ed10c76e768c11fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
