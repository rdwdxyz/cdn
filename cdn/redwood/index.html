<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af3a35ed4cfcc9437437b9a809c4199c3e751bb33c3cddc685f176d7908a7ffdf4ed1f88477f34268eb11f54915cfc02db627e1b86b7678afac7529c4b1555702e0eaa72097094365e077afe59421a47e47c8254a590c44fafc4e1f88d54523bdcdffe53289e63648a10b4fdb8d0899db5e1c5d93b58bb11232dc5d92725eaafb3fb696f05bf9387843c999e01880c99901ce6bcba72d82027babe542c60fae27cd8c61e7a4546d4912f53307cdd63ef6684e1d868b8f1f8c457c8968755aa1649662adba1123d4ce8e89aefc87575ddc4941427d8ad997a777bbd002a51d3be0fda1a6e602cedcd5275e0a3958e24b43472b3e5c078dbd95d049e064d37c57ee7f67be0591b45a20ebaf0e9c4e67ff5621e353928a8b01822d47ab5d8b56355228473010b35ab301f1db09ec393d090e11a280ea303c21eadb22a7e24b7cec037237068037e5d7e8f74d5b80c06707ecc2d3786fc7d28a01a054653a67ff17b87273d80975c3c642d8a8aeb6eda3c58c627743fb0dbf4f0d2ad7d9ec103f07db7042418b09a6a551031d9b7c03a70a4457cb2a3b07797ebadd4ba33c5e43d35334c70752634a2c63884520b7ea12007b79dd6e6295cd4441355b157f1d515510fc7dc4c5c801c6f52c947ad10281f794616a062e36874aff8465d679e0e0127f6ad5bf50490ec41187bd853cd2b70b22ccbb560d2733a506fe4dd515b83e9ff23f8b113e0a06cedf9be44411907c4b1288fa1834608ea64b067894838dda652f613069ef29213301a362b62103b9239c04b76d41c5e99096c25ba957aa175c3476e899df84a671de756ab96d119fc027b3ccc3e1bdd3d9230f9ddf7aa50cefe1750781738868f1db93d6f3d226cb0641469a63e35fd5b50dc20c40b2efdec49f05e50e5e4cd2713f8d65970866764f293bd9fe547061d935b40afa981643a437441a00f36776bde023f517603e05199b345729e74c2b985ea09f6c7c70f24dce211968e06600e0a429a1fb4a2970600f8e46211ab8ed9e89651dd3a0084acea360d601766a01f1ce698d188ec45ee1ecd36d5ceee4ee993dae1ea470ef27dcbaa8c6f6fa2bc49f335c1db2fe587c9a3591bd211a3fc9697693351d98081dbef7a6dd3e8a3105b8e0319f9ef8f38fb192263c7259ec8082fd014be1357a29892418a43abd9a002afaded0ee73a98f85ee6e9bb330bf667c071e169143042108452e7a4149394b68523c082c3abb110cdd39b6c533b8657fa32aed382ba3fa2041cfb6f2824e32a276eca0550ae548ec506d45d6f1a393461e7cd9c5d0dd8cd1797474df110aa9c86867853db292bf663e627dc07ab782e13c2a78ba11c9e490881a202e298fdbaba4b4bb9f33cbd8c1853910a14ba37c9514b5c736d0c18986a44a0eec87d640e82e75e81c10a87691718b73d0bb4775909de00cf882e0e22b9c1a576f76265f710153caed478c6e45a61e9f4f20e88d0af31dade71cd25b261ce519666e795bcfda3b892d01aabea3103e60b5a0c606a12c751cfd7c86128bc338000646533b793c4ed6433706385ee7a13ee54b583a0664801f85bec62f7c4a4dc988b1066874137c5933f4b17530e55463c9c790df79f57a08574fa88029936770bf0972c0b62e55144ce61467af5e858a120b5bf41d63743c47b56f0eac2fdc8e9b4a47721de26cf2b42781a1a04c2fd9847b8ef063e01f0520e57a5a8592b10d871ff39a3deddc1b46a8b2725c28017387357358e2892009514561b6395de4a66f9551f2f19deb6dce069609bd1ff99365ed74db8b350e13c1332e784f1e60ee27a0023ea1151b596e763ee852c9b935a58c3b7dda3b7a777764ddf1b43ab7d40675e8560979f0a54042b8b25548314704174e979bcaae554f26cadd6d25f4440cea35e1e871e7a6557b7721bb8d06675e571d06285887c4fbf8cf70a76c989be7f254ed78260d779f7d87edd7cf71d90754be945694c812537de9e9f282e2e1f1922d91041e9bc8559f13a5420d94472c70037bc11b2b31ccd8e0ab83af6d9ff60b589bc2381b059f613660989998ddaee236c83eb9903c8dbe84d5f0e689a1b8ec96988506c0956db23fc3ca65e1b12fc6798d05539b20bcd2e44231f388fc9a57a37464e99d50ea664158cf0d8b1d2b6f1fd4ed4e8497d42cfef8817dbd335e168e705cef0189b8e8c74c155b41401caa0d8ecaff796766cdebe4d455e3930a7b9536e99e0bd3343783b60f8efd73367a43d0566a3a0f814a496cf9b3f4abf183f00ffec42b9c2e11bd2cee8d94209c89d81270d2ddeec05063143d9307a4b396d60d6ba39ed266dcca5f9593f73e0d886fa004146872414db73e5ee5a3084b3ed2c333c00086dd346ee54709362c59971e8f9645d043576ffee4c70b44d4f1b39c9cecfa6f0f166c3e81b14682ba1c3af394f2724e7bdecf47e3400a9a1581e0ae871c72ac9aeb76bff07c44889292b31e1efb2673afa1b4b304b48bc99c7979ef3da6937660b284597451e2243675d3a9503721be8f8e02434a28b15bb858a94f959c374617330559fe1ca699ca44b9f4463608403b7327e3af00a64ee8c6aa1cda5971ca043e13f6c0e7da5d9b74ac822d80c923d5def5afbab2a8979681eb6f4823d97cd49897f9d8434f34a071fd034bb00f981907a5d20e38511700a13b07732273ca336b530a6ab05eb5e58130b0b21d942084530fd5fb0c62c7308738843f0cb0b3adbd6fcb28e191b7166e8314792bc786e2016042161b2b18f5d0ba26c8b10568bf7040407fc6e6902553c5e0dac3840d65bdd78176787f5e404322ef4c831db4443627e85d67180b2400e9e439d093a19664a36b1807b7ae3013c3fc7f8ea9d6c7946432df2b51ee1bd28a364292010e13cc16b34e245994d509dcfeb600fdf9e516f5458c6e2781b4657529e5d767823e6b9a94cc5a8292c6f5c4f676ac162f54473e540f2dc0ea9cdf0535371529ebcacee056a0e53ba0bbbdb26227f947aa8d572ff2f45b70dfaac4bbface20c38324d3dec93ed5df7c3d8927444fa8c41fb5dcf0ce0ad4c5d7a4713e77b97a4d73a3e435e8a48e8ba40affce9277e5928fae026dfeb4a0e7414c8d98c502964a40493b7fcd22935d8ef059450b5e615b5fba0e1c83f1fabff580e1594f180d3f0e5f923971da1b6838efab6221154a1a2155c5c8ba60a50fdbfc9dc526db279212be3b3ba19fe9f67b72c033a2db4f3f830507baf19ad2de1636c048282b831146975ba40bd4a02d384d29f15afad6baa010ef8493cf70a5086f2937c8b0d67c97b26b15b2e0753889513ed1efeb22a180062570726a293b86f3352d81ff0d86f0e58c87fe210860ef11952a5c90dd014bf42780138b92454621275716a22e5b96aedad8b596fcc64848b67a79d96630b5a2db3bb2cfc985762062e97bbc29ea07072a83f127683c29ccc706d20e13eeb29e91764bec1ccebd48f30b0a9968b1ba179ffc0c387cf188f58998a2145c7f56c92505fa4931f146bb5b225823576887ad7143e91f58e4164684424d82e913a1b0176d9f543acf5d857a4a486b5423630115dfafc9708d3fafae842df2ce7e6840870fc2c8b0b836ae9ca89a472c5a426d0a2b9201b82f3d43ce100887fa39ad8ff03da7a12b41444a01c92f36dbe99e836fb4e4e2b7314321e57340bc7563fa919ec1cfed6fca152cc06ea75f19dc6da37063c72d3ca8e48c94c4e45f2431b4bd77f4e6d650da36ebe0b1f45b288b74551e29db1a228880ded5d6eb343cb20cadf2cce95f35aa6d4b88560049e9e54f4b3519deadcb76de264b44f2091671d31480abec39a822fa8c749574d8cfac589dc0bb411c767673df5aab3c8a5d8cced2913e3be950e806aacc914a7363444528844ca1984d614aa60823b64631880b74ba5194b4a5ebe4cb90ab43046fca655e2bda855b00ddc8c351aee435a32bf8190b04fcd9a4523263845c51092d29c039ef8225ed82d62c0228d029fb35408878a754f841345f2cd0d3faa50de57cbcf10e4bf8a05fd298d211c7595f17f50d606b120cb24f4edee09474b6b5bf138234505cb548f26070574d9163c76dbaceeaf03878e39ffe4297b973632b6d864dccbcd7df12930a6a3a5caca5e40151ccc38693f9ac63c4680abee33235bea54bd059ee1c2049115028406f68393c3cd31588c376e3de97f5506d91261295304139bd9fa1bcd45d31be617a5906072ef62380ce5ffb60da897caf3e9f3f2bdf0f0a100947b581ec23c98e264a65e6f61e97a0d8684fb0f954323e98d76c2b38be68872e44822071213bc30dd70d0cb1812d04fdbaa76fbc0fea47f20f5aada2eb8dedfe8123129a54dd459d499ca325a2c5aa878ed7f8119cd05b2d660c8e4b67920d630e9bb6156487dc0565c26940908e6573007eb6558526fc03e22bacc2e8e457957c4d27caa897e3c3154cabc7e0a85cf7014c0d0668fe4d4201ec253abdcb5a1fc8f0e71ff0d236012b2867fc644ce95f510a1602b3c8c64f30800c58a569215e8e14901a2d052811e38ba6a2ef521de7ae68c33a030a0ebbbb19e4e7af23f93c44a9af24317ee6c5a37dceb105cb47acecfd39739c7200c514655bfa5bb450f07c350e74a85eb72feedff2273d7e41a0c2e26b4500384148252e9da4668f47dc8113cb8acf6560d19014a0e5e855d09b1f4df64f515eaf77b99912ccd8d6640a78711c7f4918a576325ab9dd1008614a579c3f1a27eb82a0f722ccfc7fd4f158f8042c3ca22175b4059767e4062d7509a61828d12fe6e5ebdec4fdfc2e1dee17fc5015053ffc93b9ade37e5feacfb0fceaaa673bdbe061802b409088837a1aec305a75305626eea2167d596bc8d43dde55cb93e3e9b8b14ede70cc14f2b60e9ea2eba43a9d7d3d1745c511752a69e4bb31ffbf70eeb53384a846153b4975d1ea0f3d187022254ea21ab619c33ee9bd3060adbfd78878302576000d6c23e7fffd854664f4de9864562395792c8f543c919afddedabc946167993c73de680258718a206107ab29c8b747b2ba6b3cac2a35f706686e83bda9ce90983557fdfb963c35c7af62564db10e5d990aa168c1e4d72a51498757cda18852a12818c0360fcc13cf699a486eb28ba15628c1602d05375467828f5693b3a5b64c9e8d96b964edc86ba668b1710fac63800c8348c1d1e19ba4a0590e9f6c31fcf3289c940ab4cab61858ffae6d4a93181317754834c5c912f4ef0b0a29d81dc2232471f50707f3bf28529a2a464c5adf9b55ad8e52d51281274c8de760046e912df6852d6bd16e25c433aeb646c6bde1fcd5acf3648ddd047cb0392c0165aad19512197b2368476c0182a7538afb76b910751074929374a964cce5c084ce97ce16dd24cc7769036623c57cc965841c8b098b0b9613a80e3ec863039617469729f3914a2d543490cb7ca82ac24cd3b1142199c059e7faa1df6a5bf894bb559bb9750323e66213d3faabc38fcea317f1d73f958e43f11b479fb15c59e56efa983e71c680fa498175ea21e98fd093c4b9402e44396b0735e0b53397335185ffcfdac5088a4f08b302ab9b016845c19d9e94b73b5617355575e36155f75236ba70a1c9ae8683ce3ec9a657310f82a1f9e5431165c4017c45ba0e3f6b988108810ee8327e1abab92d9104c73791ad416053bbb934c1920aeeb0fcd5f789f965d67750e82965d3123419faf5321448102f276d7fe0952262a8f227fe7ab008f8f7c2f8eb11cd2fdad5e860c522d9e565c50a3195e951cc994ce96f9e3f6f384a8195e9b4d8c3c6cbec0d4df5e01b57fcb785a78de4950a705b83f033c8f0cbe2133ac81aeed70799f68fc760d81c4f2155f4ef25cfbc6f4c7d92adecf836ff93f347353c1aaf5e4687db292f66b9904f4a6979c162c02694f32a5cdf2b6cd8a8cb4822e73b1f1babb78c7214d708361562d028403bedab020388d0867eaec809ecc116fa9b394637515c66ac4fe13ffc7650dd3ab9c16cc46380233fcb38908a10e1c731803342a6a3a0f419a496ec530b89fea242b187f3cd9c42cff008430b9c9955ce53a6b6e0a8c29f52f44c21e634f5579f8cf29ba412baeb4551e3b424a6acadb955ed6c5803bb6151678977358b4f920a80f332ae4474e1a874229be6ac94fbb3ddc05c18a4432b0d837bb293737bce1aa2c2c3f8b735dbc88b41a2126eb975e0337a72e9ed1b5906f32e12eeec628c8690893279e43193b5f3185bfb8f05043e614557c77fe0869e3a680bd6323f22524d3ebb65da269beeee1d95637dafb50830d3d7f248066b08880e2b29df5b31603b082d3ab219eac242954911bb8b34614022e1bcbe2944870bfbabf81b40470f97671355202f0afccbf1bc6aeca5e99e9641e767e3847de8d814fa274328f1a80c58b0517275a3388ccd4091219f89d1a0652512c8b7e870ec37d899c697e1c0b6e2462f73f6aadcb6f3782434f53dcb7cbaeb8044662ca27cbda1bed2dc001731531dfe41104e81216cf38dbfce46bc3257bb606b4f57b30b612fd1ceb4a94f5d4dab422a9ea005b416be2783f73349a9e5798696e9b9ddce73b575d04e54f1181153a5d86c763d390599c5eabc61397501bd684dd4833729ba0ef1ab8fbdd48175a2b8d302543a4077a1a5871ba5a9fda66d75ce76b2d359effca8c8fdd1adf4862027c8e562019e473fff83c6701a4deec0174868c8f2324655a0b057d820b2d1a8cf82ebec9f58c4fbe121ef0a1e31dfbdc2c490ae5c11ff070aff326a044997bac7fccb1f74e4a7a15661d039754031281bdf383bb6edf7277498659ac49439829f854ae06f6dace736ee9429ccde0c8c53ed4f16249495daa5ef313e69dd13d909b3ae5da60489d522931c0991329ec3a6a7e6a9184ecc6685bbc54aa33a11b365f5f4ad2a6334305a168d98320d3787c7ae080b2cb1d23328bc5c872003dab0044d51627df104d51432c6b7fd6553c013c5126b43d239f6931f4e4ac6d50e883bdaba7d97ddb630d8e7e22a4a16cbd159846d4b62ff037ec49cb2d26a8fef22baa57dbbc8f1c5b13242af1131ba2deb7239e5684f866a8322ea37ebb4ffd29c74a82fb9724f4e3bb0d8c76646933139bff6a7193ceceb90934f1de0066123963f059c04c847324752bc1eb29892dc5650924b20e83ecc1be1ab113f2bb4b5926f960b0ea14f23c33c7bcb436e4c764d2ddacdbefde12910a3753f86748b274e42869162ab43f1ecf89f40a1e30eb18d479b6848a7b36428d303ec78f29fefd28acf3663a13de254dd6d68d16b4dfa7e65866a5b87a22a24ee074f69946d27fcbd835f5d381ba9e90e2667baf4800088b976a312e62b63d9ce24d5c3c12812a5f7b6e21bb82b06096a2b378a991d4509f5b5db148bed58fa6fe9c1fb5a86282e4cc577a85910c2bdd44ed114214ca39303dca58deac081e0022b9236cecac8815496b553f076f43bacf74c2b8dfb002d99c604804819722beeb739bbba1d0548faffe85b6e1cf15d3b9e381a7a77da38c2306612d2f324bc5a8500f0312446822318b0bd88e70cf7de7ddd2801812c343291c83c918f7299211566bf8a45c8991da4f31abb06570e33b78d9c1306192a906ce19739646ffdec3fa570088bf5b42ecf60fbcbfaaaa1894f5c8ae363c5e0dc9d039c1e85ab160c8e8fa4b19cb5dd50f16b6be73b6534d5809f92cfeca18eae3138d074b2f585f6c62b14346d2258e4d04b22b39fe3a53730fc536555ea2a39a80bd65ceff86b6633f36f83d4f4943b4cfc84ff9c438a1db759e2ffc838c9cf6ed8a9827c29fe08e8ff2ec2fbef25e035addd66991bb80c8031fbd653723483072606255010f4bb4c13c8f0958546c23d2aa1228f771c80176507dac425826656bd5a4c953ddf60d708e4c5689dc49b727feb0279897d0c98abf08e1b594b2cd5fa0a088d519c38ef3a3cf2ee90d3237248c601c6920a8cd31d3fd592af3f937848fc9f8f0e0f383d6732fd70cf4f8dd385e825317a55f29067154057a68f89028a076bca703988858ed5da6caa7943f8b7a898f4463d58e33b22aeabc5c591214bf734858a675262a16aaff2c488308b28f6aa903d288af10548957446f5f97dd544852b962ff7017e2732f636b2eb74736910a0bbcb467a9d786ded3b67586d02254d82582b26f88ea217332ef10088be863f7544eb1d97da7a25d861ef771238cb983bcfa06909d7cbde1ffc0c75dbb1cd2b3d0ec3965d0c6ae6357c98968cf7deacdb75d24237b74c5c559a242e8d9d7f43d9597e1489ced0cfd2c927c9ec5c7a3cd38591326260b0d3ff4d4f430be0f6032b828dc58c124688f4c88e8be36d593aebdeebf1157771df0c3c6958f31841d1f1fc3373a2c946700b3ce36be426e7bc6b7dedfc8b61dbfa991ca55fdc276042437ca52db0a5c7307c7acc3f7ad638c8f3e6bed10b551d0d49441cf8f2f07f0755f325b1da264293d8ef9bafe4ac0d91ce88625909caf4fe77af634ba5f9f003f0dd98b85aac5fb3e1064aec178352ae82163c00137dcb813924e283d7671da9c96f5d95b842bd9bbcbdf9f5de11186047c07a3b002a1792f41ba78f7dbc6a0bc64c6829e19d1ecc665075801e3b596f4ce4a7c454668027b4ed0fc7c5a7e97f378d0f237a4a0618779c14c07fd65d8c9b6b7243bde7223943c5ea92e5c5b6866b9005746f6ac6b105d234c8e193d7e6311c60bc0e0f6004ad68ba4bfc976d57751f2e485c47c15f421c3de7f6e086d5e4d62e7666492fcb69c3beaee739ab88e3c15c1d1a2b4d86d2edd96aec1412bf79742ef8f5723c77e9d5232a6dd135aa8787385370fe98e5e06111ffb2f9f0108ec1202064ba7bdd072f420f8f9fd44ebf387a3775fe10ea96bd643ecadb1913d0c907f71c8e8cd14c1f1c57e84caa476ac9c86d15efb3ab57b2d4a178636c6dec5c4d79e79509163b878ae10803050c3f8fee9977085f4ce9fbb1bcfc9471f8395929fb511809bc30dcebd6e9e1ab6f93852764ccce815f8ccaf6b7e31175e5ef6f97c36b50d91c453bc56bc8a57a87116054823d0b02c48851f4c0c3703d6a232739335f404c523c8ef5a9a29360066ec3a61126f9154e292643a34e47a567e10f48e9b2feb21f689726000eb816b94c8669add3ebec6ccbd73f1f85582926034e0f78e8ef5de3310560d47aaa1b307231023a1b6bf192f0b293c105ed9da4acefab806460cdee5a73ee609421d881371e42bcd5b1471b393bc1c90e2feb8a7326cc469b878a7bbf561d3be5ddcbadc18086f63ca2cd8d927c25ad7fce230ee943ba89dde1e9c59ab434f1cd72f78d7bde10e308c7b31981d7e29f5e132356d9536c3fcd0ecba395bba58a46550044dd25e810adfffc316f8f4b4fd4d2c0536ad13c3ec6fe816cf0edc471c7bf35d9d64ca249657574672ec4cfaa0e12c5815442fa33a7ff1f054681c983e730967157751a49d542b69cd0706256814c5a37f82b829da60c0063af97610c38c5f343eaad0c008ff1d5dd54d8bc0de4e9bbf411ea6ef746712ebca6a0d1db3777bced6e35ed1b4bd1666b70f99f855f18cc4b1322e19157b91dd4bd1d0437ac75b44a90caa4ce7d5d6c0e1a726f5e55fc96a5a83ef6832ec4d242a07a9cb16713be87498e74f486e0c4f1a22bf34c90382552ad82edcbb73e95a6b1dde093421294847625d04f83b0db8363f4720a91cbabc9415cc51c640b789398e1b259dd2802a9bff337a8e7765879313d2af41d29c5a93f22f87950d25402283be5ab4ec9788faa3b7012215a5f86d5b8adf69f7b4fdb4e9b3bc9e39b3c937da5a9759a915f4c8424cf442e90960491f4d786ea36a9d9219521e1124bf135101e975e653c02201a108cb7b34e88ac569af51f4e9b0758279651f93132128a2a4e3c65974b612c35087369f894337ebfa9038af38f6526dec2d52cad8c166a793cbd05d6781effe2a52b84e57f1c5201fe0ebb0ef583d45c707400fc7ededf69e963ca47a967822441f958d9b56756aaf5e49ffdd4222a7ac1741e64b4cf33c3772037201f934e66f404b8c503018420448628ce91332ed995e2f2c1237c3a41a3b2568fc976e95b3b29c775bc500efa5ddaa265d9ff62aa71bce06da477e1e78c12c1f92ac699467568e1191c4c7434dbb9c73fb104e37c18ce9f6a5f9f2627ecfd3d19dffe0b102e136af52440c98bcd1a495fecb4ec06ac21383c0e87be0b3dee586a291aea641a566c6d4b2f3b5d197c8d379c26339052683e5d921063eb10dbdae8dcf39802fa8059f802c5016b212dedc09cd36887d65b177e2e176ce8bac70b6ef89f2ca81c452470736eb73f4ce459d5f853d1cbed285179871e0abf96398d2753e9483984e41f8a9420aa4a3151fce0ab17339f6373eed12b0c773b3ff2849ce1dc0d58cc8fcfb2da102bdeafd899385808fc03af91d8668a3c3fb142706447abbdf1f3437a1d340cb374508ea7af29f53d8ce66c8f2e05591bcc5250b3b8ffdbcbcd431875d311604b975758c4385329aaf3ce710951eafdd855b034266d1d9f11402e40ebe9cf3a9e6e2365697dcbfb8b0a178feea53eab30ed2f62a8a7a1ed21ad73e5c52218b28ec6abcd0e4a355307c7418d5ac5b21c52758f91d7548bf4b4e1147d03bd8e896252443b24dc1544664aaccb36822ed4f17f5e9a9b3038a708c754b7279871aa552598bf1dbbdc3245e5caef5167fe7c26ba2c0975be56035f461ce88628eea2ad2376cbd347bb6bbbffa3ea86291983d40c98e65ef52d00b8ee008553e88b0dd55663fd7827094a27c40391fae6741c7c31e1f87be1e00678e3073af4c7fa6a2ee472acec83d280bd71a06f496e79cc827cbcb8fda2825be3f209db7cb2bdb6b1c573c7701a189ffbbd0cf4ad5433329d46492d2df0a44a6714edf54080fb50ac36866a96adc9c877b52f3ade33b13e2a22b9fe42c7eb899ca50a154f432539e4e476d763fc54bc4b63ff096acbc25d74702fbf16b668cb68f4749307d373c64244fdd9fff74bbd1ae75c480430ed1bf52a0db3c16bb3629bf4530167cef7c81aab2e3718cd3a3b63a5501e86a7c8e07b22f511983783feacb975bcdb94becb62558d5cf25227a5223cd155beefe2655871cb7f36d6066d5200d4d82e7b758788108c0dffd253f32f5e54c8951c88bf906fb48a68bee6cfa4168e688b702b28c8047379e0d5125d55866ba38c95a4d1915c01a88bd7e2e23843dc7835f2049fd3c18cf121863fc69a0cfc95f9ada8b412f1172656bd6525ad59e89b4b23adc604c5dd8eda0edcecacd483e97e7ec6a317a35a212ca2c17ce1e97d116effa6320af908d0c014f2919f8b9da66a01de4390442f832776e84a251f6e3daf71ea35322a5d53267385dc440d20d09877a26286e13c885c3c0691679b9a82ab0ecb7a7f35846cf0dabe29fce0288ee49ab4809a2a7fec445e671ed7ca8f5db35acb915e16a2a5ea2fd4fd1e9f81a791f28132dbd17708a9f3b2c2b11251a1af01a77e23cf6cb83c76366112aa438a1f5b05d719b98099f87f645b66a406c2c6530987927bea6ea376abf52a997f9c9e49bf699bdb56db2757ca48bd17684d33942fc6c13a752dc0f462a2b40af3b1c4eb26f6b9f7bce954ff72d4c1b64ee5fe85eb12448ac1716174172d5b8f690e635c4fb558aa67f0568f5c3096edc389feed54fef2762cb62e9e7809c9fe9016fb8d5d690bd7321f0b878ca090dab868de3df062db279cdfd2b1221c0d85244e2b46aba386285b7cefeb71d354e75b684fb148a40f98e22946636b4ce3c93ad98fd37c99cd9a995d4467c6f0b85b8388549c04ecddab42bf77d58910ceadc006ff36c067f3f13cb892bcde18bd2fc54e060601f416b33e9efeebc3a039febb62f93e939dae8a6b6df252e944a924f6eef7e8107bf60c98db5fa0939ef3f4a566715a31cd659039b75b7b861f7b6d85a6f2f4f4e808fc3dce05d137a35b8bcc942e23af36dc78036dcd4517b1f23760d64ed9723cf460e49a1202b47adf8812e35402afb6e553e7ee31d2b2b70cddf088d70fcc2c614648175649b0dd84838aa131c34128300ea22c4db532cb5c928420bd9925052cf85f7a30029ac883a860487ce8b2cf84d48a5ada7200c33feac7cad9a8015ef2f5c09f352269d43a143be93f73bbf48692b0d1778d0c4657380eb7a4684f2c95e743f5095ce32600a3690e8e3e8bc8e6ab064531147081b001d3ad33116d6b9fddd5d4b655c8036eae71ea87407c9b37506f96e46a65de613e563232ad053081f2c7cb07a3df0318f1c49d9718538a397efc34dd558cd2de5a8bbe593df92e9efa230722f521802e8e8de8ebc697da8db88cb57d3bdd760a711aa027086d8c81bfe2d4db69611d795079a5460f03cae85b483ca8c490f9fbad390d2e0a3c40b564360298c9fcd5a8047dfd0d98943f12116c71b1a9439a937451073fae709ede13c6b40d0d1e8b27a64752f55dc8fd84405dc8985efc24434de495e64436c9bd46d95418bc45ebfb0d22e17e1943fc9e7ca70d61e6951675b18eaa1521e79d8ebc186c0281cd817a0d75800361f199fa99441a12fe191d3923bcf831823ab70652392f8107f0865533740d8bac274015b2c3ffae6a31b7586ba75545220096783602ef3dfb825c6858bd7b5b8f2ae38935c37c96c3f45315ab7841a98a7e1065acfb17755c1b18a0e6f47f7497b5ba3ef42146325afe0780428238fb72d482794843e83f600d25b5edde864076c16f09cb8e9d080975079a54b22f7a78647d5f11e9c088f9becfcf91e66148f65248d5ef0eb5013f307b60ed7b60a758198a379baef7a836a0f07ea1d7805d3e7aca18b1b05f1dac3a375b8ae214f141eee2f09f7a5aa7fd749603dcc654c32d9263ae8b07f1f78c743aabe72e826cb326aced11c6a383054f2c7be2a6780dc14945e7de4f3201d484b76976ac4c916128202a620720d04c6e0153077cdd0870ef965186a2339698d07ece3165c9b522e05e9230a0fd758555e85fe9b153aac74556d3d50a6c35adb582a04496a1a5f68038d77855096e272304c63bb7819a563664d4bb477b085c7e86f375cf3525a8a6abd93792631b504d333f2782dbefbacdbb1d23375e48522003582bfe59d9aefece18b47f32b0144a165d5c36b8ad0d97d707460218d46ab364f7f6e485a1237b84a5b31bafeaef910606efc26c3b7abbb5d74026e0c21a8bbad2052b8a5da7e8fdcc0c9500a602e6da7578e9a9c75363dae7e5a1b79fe3414e040879c13d9588373bd2298d087f26a330cc994ad2ded8ffa4288bc9d8e1856b0e85a6c350ec59a333c6d1b2b38d5de169619784319436d6989ddc0235af7be0733de06e6c7668bfa237ed4ad99327e629611ad6e1204278f74a961264aa8baa0cd79d5f4968208e694fe117b8091f53eb231f192d0eade8cab30347a9bd7ce5182b3159cc4138c39fb78094a6e86949132eb99242338ae4d6bd9c40211fb91478d8198258d8c92de89ef72173a2d95388666701a79be2bf8ad2989e66035e8d6f6ab247ef352c48801ede8025f58de1f78d869dd5b16dbc73d6c242ecd1da86cfdbb6913fb7b497dbc860e2284ce0d7fada9231cdabb0618e1a0c042bda34ff067fcd7b26e7deb2b4a8f8cbf207ccce2f2aadb3a7dfddd9717821f2affdd37f2910e7287825995ff7fdd2c6f07acfde1cb88eb30ad19fd2387df83e26435ad5fbb1535824f2563b9dcced9a902b929bcc1bd52b09c438207881cb2c1cab9971c622fac7fba89cdc13d1c5851c18d30e9fddfbc013d080030fdb4dc459b12b30f5ba665fa04195865424d2f3f4c5862db5fde801f21570e430e6f49b13893e453c8d1ff3d65fca83ce70483bef7e0a3fa43f6cc65f26ea0742fba2649a2e7cb4a792091296442f528d0b4f0b20fe19aec693a793318ae1b384ef8608ecdd0104db4a930c302244c4d3acf8c7b8941de623b2f0983ac1979bf6ec1256ef44b37fd249bb0e51871950dcf60a9f2cd6aa4a19d35285b887c7315ebcd8aca244632e0a801aec13d0af2e42b7e8b6a6ce90482385cfc85d33d221898abb2592998cb240a45b6d890af60eabafb9ccefbfb822316c54973cb5d382dadec6c39ba992a156744f739afe473e3f07060514ee775818fbecd833f018b6379daf6407a5deb8f153365d286dcce7dc8904011778be5bd1af1a1e60e5ce3269e3edb6885e8f2f0fa64a7d77a2364637361a680c69e8bd47afb0cb234b0a021ef3bd0e05a6143168cfc232fdbeec59b5d8723c2a336d644a0bfb19a4cf84f10d94902477054c315f4fd56a92617001b31e443a080d50b74c5c26ad7dbfe23ec6462ace80983bd62fa8bb525dae1dbc180b00313c22337dffc7246f34196929e916292200bca3d540c9518d6115c02ae7a7db64bab3ca78eb1ac7a060baab1b98129fc59cd1a17282d8e9935405c078f29be5890349574278ee35a3df9c77b05a32bdd2396f220fd6e70267892c770a08a4541f82a86bafd7829fb593bd61c696d611031ff6705a69f86e1b7c828c09eef5f20e44ef234b1159358bc0b67eebc6faadc7370e5d8cb3dfb694aaa17cd242f6106bf13feb2b4688cd8a68bad59e449d889735730daf8702a70adb7b5668a65ba5f97c195b724e6ef03f2b978331909222dd41e90a544f8d00cfdef908d18a363e436a686ad1195b29d6df6a42669366cfe734b95d72d0612dd4449a426b289721cfb9f40ea8ad2c6f60f5eeb8f7a0f6054ba3b62f3714aeb20e56e4c45c3b2f3a8066675cba6a0812d998d042b17151775df9e101fe20ec266756c9a289c7a808bbe0726cdeb5e26250911bb4945c0a330b3ef3da3c176ce84856ebcaae9533b79ea1af5ad239c4d0e916a7606207d8b77e00ad5b68ee556cbb86211ddba58d26b3e61285a5f9294e6a8ad3d5bde93c015a112bf5fd2afd15d09272405c319b729c3fcab483653b2f377943fe1642879ae28f2f71e5adf35d04f92c5b0a503b12ed29a46e5e7314fc15ac740836ea6f70133cdedbc3a8e974a55ad207292c4f7bc6d7422835a43592791193168f25e4e03fb3753dd34ac079df15d490faecf98a6ffce881ebad8efd8ae20bee5870b5378b220c47801f48518","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
