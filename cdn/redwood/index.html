<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ed3c79164aaa800c6358b7042d6562bf98f4f7be438d62039a6dd9fda42ae801a41430d96dd80bdecff9920d9ea75901c61599433a9c032acb13e14a9ee14b00a9ba022fe9be28146dfd9f74448b7a1c0aa438634467b60cab049a76451532f473dc8012173c71f5e17bb4e77342c616b2454999c0faadfc41a29e8942e6927496f9880c91862b2c2c9ea6b3fa0cc189ea1075ce8d2a5708bce693061328c5b5193f2ee168b964f5937d31d81f4e16ad5ecab54693535502d9daabd07316ee42a36fff4ff813dc85ea0a1a3dd2ddf0d52e054dc82227ac5257ca5bd69ce4c804c2d833c102cabe66ebe96fa3b840167e04d6cc8d0c98878b77daae1a50666cbf0aa3f5d570a3659824f328eaca9cc63f7fba89c3beb4d468e1cc98fccdd1f073a9b50ad35deefb90014a64e6c1f3f3da9fb20586a564ddb396e6bfa0ccc61a2582a569e7e3824c816078d21fdbb975cd8746e526ba8a16afaeda6577309d1a52fa79d61543de823abe07384d60a5cfcbf47448d885588ad7a01298c5d918675f39af922bedfb6991bd3d732e806c0b81dc3378645b7d721f56fd051d80d4c53b5f750fb5cebd40e6e5798cd58a3240011668d94f0face09fea63b9adbfbc36addee610e932683e868fe9f9eae4c4d987101b57b3475d83cdd2e5e2e529a72a0265203006ccaea201f34f9b614521b7797e27eca686c75076a6f00ee48d4d6abe64d1c38c5a223847b553271795e5d59e4c0f58411daf29cffbbba9d456e8aaba5366c4da30298947a81255976ba921a15c4139b96c92a02784b199e64f35a78b7a85055d2c3ecca9e059a40873ab0116a2eddd5c939c1eb62dc03530d7aa6bcccce6f0e684a260bcf6bb2106609310983b1ab93c5624f9d5d7fc4be3b2b9dc58b0f910f3c6978d3f7e835f19bdac1c08fdda48dc418bb980575fcb700b24ca2c01b99e55235dd8f95f4eeb9586583bab1182f0918d637e066e3620b493d02ea9f1bff8bd0ad87ae29e5823c38994f77cfa74ef2e7942aa63dd3f433b6d871608f8ae8625d80ea15cf4f4cdbe3bb397c083e42846fd72abcbe8af1f42bf042d6493d5c81171e383fa465b6af5b5fc89dad34da8a719c186c2a480e7f6570bc1c1aa466d8b00bde35dbb0ea107598f83b8b930a2ce5bff52a3bbfb9279ef44b96ec0b7def790b7ec3b8037b0a00eefb3d4c37109f641a1b11fb76c1e8a7f8f841f4bbc601643ae7a308fa26060159bfcc3abf67939ddbf80f7cf4748ad04673f1426f47d57ef5a1e538ee5f3df3b4fb2521cf3bb019064e96f8cfa1657939aacf89beae823a02f4bb00ebe829725cea09e04c1589386f5771a301486e249eaa0b732bba00374804179bd1c0e9cecced7c2e43b3fdc2559ed89f25ef581207196126f1e3a334f376b39b61a5d4d2d0372738d6ce8a1625b4965dbe8e8723f5f24a037cd337f53a277fe1ef86c6b8ad096804ad926ed2203f01291e174aab0b9371e42229f5da3225a3340cab6ada895ecfca98b849d40195b9305e029ea9c37b22b2a7f188df0cbcc42e7e69118a893f43fccc3ec6f5091eb24b068e0791adb7b940591d1752a9ae50efb7fa725fe4edad9c3ecc89a337d668fd86479eaad17128e379f84704735c1a79b81c06a98e0c2b50cbfe4df6c627d68a83af93636a88ea3cfcfbe04f285116ae3843cd18a3b103340e603bf57f84d9c788de4389f44e96da1ffc811ac1c0a5f107e17716da0dcaf442a8901e2b99b394f8f92325b7ba3a1273d4b7ab71fefccad95e4eeb01ad5ea95032d3fffbeab6c02f58ce83e8357654158e8f80e64746f1c4aaa02c08e36ae892e95659713b78af5a36cd6b58a02b08cb41d1fc4ed9676d491c85f732d3494dcf9c7b20115d675f09ae12416ab61de5cc2a8e3fb29a65b5487f132001fee23c6239448678888785668740edbd796fcc3d4e83761aa3d1fe51d48e345542a1f82741fb8644ce217d46f4fab86722c42e6de2204d20aae90c3a7bcef718e4e24e709ccc69f36a1746f7b207a6a215cdc6fd6e0d9ca758df01b8f7ec6a80344c5399d636bdffc7bc8950755fe86853967fdca117d9ed033026523d240b8af08fdb4c4a75102f92f1aaeac9281f14b7e69c224132de9ece276c877f6816f4138edb0bea33950646b7fa5ba5f707136e11337fea53cae9c9db77ecd4f30a8df14c43391b32687726d104e7a03289e88b24298e0b2efb8fad07bb44299baba188e100cd875091e012fd664260493ab623955978c85cab7d54b94df3b11c66048ca00a9ddeb324ca16cc10e777f195f5c3d32779c452d9e2a94351ebd58d3988444b4c3e8179b53838a1e1fcc4c38c095f79c7725c83b8184b55505338ad75e5149e03fa2d7aa4fcff00e6b0514d07090321a0b80526127435b5f87a9fc4228f9ccebbab51c2ce30e64a14c852f6912f562c2fe013db6f35ebec31a921e2403e5d5470596c8a5b60171bd525cc77bee369a4a5d6c246a8404e8238270c83f7576dc012105d1550a9ebbac7dc5d9c2eac9c28ef00e1627a97773841cba34540b638a2afbcbea8ace892cc2c208b4d8bf57491b71c17cc6e3d74079686691967f7c9d7d5723210b314dc24faaef069e6bebedab64f5f38d2e3a98d68d3a97b6de881aa48bffab98dbc7032dd45e9c1d285c34fa981741119e7560541b1c66191d2d977db29f4d826a3cfe1db6ad43744b1984a8ce427ba354e4491221c3c787d2934c90311a37fecf0af9b90a39b746bdf2c03cfcb19540d622dd0bd7620aca9fbb627488b832b2139e6e6d6dc40c07eaa987ca3e7bc52ca623f62805afe9f14a0dd51cb12ab5c6955a7375d5e6e5d058c673a469c58258ea1ec4293d97d6240fbc55d41cadfb948a0dd554fc18738e1eb31a80afa4bde774e0d4f7a24913e3f336bb954f98701a4c7d25573217b18f16041c099f821b771522351e7c503f9e4f256a48866339f6287683dd06bf3032e2f7e1c8ebd4ec49637f993c356d701973b9b8ff261a5705eacf274efd0addb3ab993fff0323cf4a653076b16c859961cb40df0f1c064932683174ec5c2aa811406f4db50da8fcd7f0c2364220149d93b437dd3117c4fa5179e64e372ceb4f940464cfec481160c718709292c25bf1c5110b87eb3a59f2d9459013c720acc83abf2f4e4d10f289456f712c83a2b011b1796e4ce31b7d5b4c53bb1975bac2066bff261ad6a573a8e1d14377b7ee7bee09f1b58e4a2f2a284cb0a3cab4685d2cab6eaca49eaf40db1c26ff389b20d2fa658eec65a746c858d3cd94f9d316b6f5db7c05387cea41bf6baa5ebbba63280912a39d4c739993a5f9676fbf9fddc287d0f2764fd7e0c9134da2dfde6f778d80a2e8cc60be12488413c89e6102456d23881002f6d15a8c0d83b311fa1f6a9d9d3f3eaa683415295dd2db7464a41d0a6826b345919e1228fd1918bb28a9d49154f0f11206bb223b0970c3ec788a4cc1055b21f458295b0cafa3d8c232ddb67361dccaf2f05a6e4c66f1eb02868bda0aeee6b17e5b5e963dce39dc45437e5c8329a770c40dca1fa7e374a146423b9794faf72672c60a1a18bffd26d5ee22bd096dd6a979f919eef43f52ba6f9811ab9736dabdf1ff0ab15b861b783bff920f54d97f19ea8b959de565b5e344c54f1f93aff5fc8382fe4e13a94feb8ab90e5e274f10e0862b5fd7198a12caf547d03829625c965d773737559f1584031320e2d2b8cb9d7f4d4d19c8a8d3706a74461a2e748eb0518f1debf46c71e93c086fb6a978672b60223c07062185a55106b7f774a6314e55afceecc177767e246b43123bfa02827ad004d21c2b59864497dc4095666d276bba9fa7f7118d164a502783e3714cc7c60c4b2bd2de76f8feee6aa5dc22b012c7a2c3f7ad2a0c63cabbf72e11b6aba73b99d9f63b957d4fc581ee1a131ed4b4a377e0a607def6802509f097d47614d5ed933f29143bd52c0207975b8c2975cb51e641697a41195536d02559af293af0f66f6ef86da5201493a9733125ff7391192546c425869244c99895129185798a5c430ab076dbb60bd51f587ebf284a503001f8dfd6932a5d9c624f79835dc1ddf10dbb7197234ba2859533c126788bac8b1238705e2128b4aef17958bdc01b5742c0abdf70831eaf8d57c398d0150c87cd178eb0e359fcb563e2ce1d851a6c258a8a80b7d771d491d29c55a36a047df7ec905911ee315cdc2e8f37fc512cbeba1ef3995bf02fc2e33ce3951f5dca02dd73a3450945aa9fa36eb328f379f5e15785083ede4f6976fd498a5db0b1eb71ce223bdbd08dee6ff036a4ed5fa94e6a99f718deceee16a7675d8efcaffd54dfd65b4d199d811d19ea5fb7ae819409dbadcbb7cb009e62be42f4d6ea2d466800b0e621ac8ac4fa24c79352d916aaeed3e91a877fdd54e30c11d835356d75cd05f5fd72aec5f7ba5dbd779cfc23e148f61914be34ccd2d7a5fd74fc2b506cf89c245a706acf593d31bf07dde8ad0d331fd291d576cd17062f79565285c29c4da2880d56f13478500e86a76a4fddfb6ddce9ff3345e7212a99c52fecba020763cf4ecb0f4e2a38854134e7349105fc6fb584477430b2222fbdcedf4b5f4cd86d24d10837e6231b3a5ebc9ffabb9e902a233f4c9c6b20c4b06258bfa2154f22ea3d506632e28e0bb26a1d6933b043425c949a0935d1bf90f3c9609014e9750945ccaaf7171066250c96ff1b250d8f9e9dcaf3c9c0bed7fd481cb34b65b43ae1e3d5e1578b38a95cf8511bef974760f73db96a422f7ff4a558d4adb8fae48dea21eb64384a1960521f466913c3fa7dcd82f3650105a496f1d01c841a5b59c32338c71961d585d909541e027ddbc8cd3f0b615f5fb5420abddedf29a17b56991015dcddcd9419f0d81840bafc0597aac274be2138f1cc6de929932c4d154000663d0c3dd03c2abb2b9f1867925629f72c69b5fb6c75a370ce2f73f1642fd79e40e7beb3afeb42b43e61d8698d45229d637f3f0b7ec85deabedf69d77e6a1c238db91f00ef55c17709b9dc5ed03ed7106667e78c498e152a2f1d76f96fac455b7ac8ba6d9a008b65aaf2eab99bf09f251bd55eb3f9a0e81c089cb9ac9def017e381e584980d5e02c419b7707ec12118f6f828edae3b5ca8f79dd52b21771139c833f684953832d831138ab8bdf226bcc6054c734d0dca54e7a0ea8e4ce9ff82427e693dadab7f7605df177c5e22b4f78065b41c1a4123c58ac13c1a4869047c8b83e0cd4b07c4149a79334a32a222545b6fdf364684f000f454ff14985c5999638eee338a8a608fe888f76390929d85523ca3f7364ac610e74ec4f6c4d91aaa0c07e7cf0f9680c6f2d4c928301f785cad0e60ff9b955c8d0a623213b51e3a2478e4f57bb74ed458ca5305299a518b33475343e13bf6aad7b8c53c7334ac02ae0a7744e1881d7aab0c12de41ab8cbbbed9362d23c15b1fa15ee702fadb614b71c4d77746088609780459c667cdc5a72ce64bb03fcb6d0446959a38e7eb6514a02a4ecf21af67118460ba47d147c724f6e60c5108a1cf4ca7d96c52faf74b969efd5a340dc3890946e4e8ab938a92a51a25461afbcb695c2ca3448d29d3286f78e82517be262e3c77ed96749cb5aaeb4e132923ff1ac8eaf4e3fe4347439f3941dd479ee6f15a47edbc04a511a1a8a3d44f73b43df85e4446538c6f5722092bbf71a8e1fdccb15a146607dd9b063af4b123df6489218493650223c94fe0dbc7c6ea27df12e42223acedf573efbb0be997ea9b540d3c6ed8c0d8f4c08b429c0ef1349ca538ec4aab5112387a7216d9c1ed9a8cb05616797719b2abead2e8a341a8fd96c400acba900f3fb7dcbcfe57ff5fae5958ac801a7505fc5d4274d98a40bac286e9f7b5ccfb616ce29cb3b584f8a81f215813fc233c0c10a596e999341d5ff302edb100a980ffff38d77d374370c699934d5dd5239f33743909372b44f11ee06e1dbae045ea29c4277d350c015edd7abf268f332d56aa1b20b57eb47daa6d00ac48e65177b7adc5124519e3b85e826eec31ea623b133136c3ad5f3e66b5a99fe061284c5cf68bb62f7e4f695d01fd89f0bb19277cb57f9dc9dfcb0fbd1fe54f5897bb26c260a6ab9b3a52883fa6cbb9ee9d2595d59fd47072eb6d5b6ac75415784ec3ccfee2984b1d533848f831be1a2be9111e5f30714e6fbcab2ce15910a3c2f0bbd7eaddfb413d3d23467cbe0c71021c84bb72a5281bb5d4180dfc5ccc9728bd6b8dc480fcecb4aa5b6440dc4eef42a6363095f225c4ddb681376e42f457aee33e308894a1071afae7304a8dfca9b036aafb46f193ea31c1d796a18c2e1c01b465e8789a175b94d2ea92b6d5e6e8f8612ff240094eefe02c1da10a38840e3a1afaede04503cdeb5a5615a8b660a2df9bc60ce3df94c1c442951ac40c2280f5916d6ab2520e30fb56fdca20ab57044c4d101b5fbb280c1f82e90d306c256a94747ec9c4fb494e9a7d3d9f09a0f87fb1735df64551c2c1bfa7cc957062a9ac7dd86c33816cf0fe22c4236495cc9803eb5b041e1f25db043fafd8da4a3dc470d55f22f36075dae948a78f2272fbdeb02758fbc1cd8db6274930971a040e738f444416b9d012fff6fa0eedb379eaa6f68534137a32e209385b7854d574319b1cda7054262213a15a049d9b8152dc6c496be0b12dbc7d3f78e1574742560396f84d3cf42b950d77b00fadd8e12ae954bb7ed6754f8c171936dd35a23d0d7795ffe0d9fc5bb7e4f2b0aa3973183fed0787f2e9e7ed3332935c4714e5acc8c6bc4b902fd9c3dfb0264ad68004505b452e33681784628be8d262a6be26e644640000902af473f0486dcc3627606f140e90bd61ba4117f961ab335cde4788be95678347818aa9948ccb9209fd4f01d4a0a9143f89ecbc3371c9734e75ec7f63a1370c5a5ab4474fe6eeed975e7f64877b3373f43b6f298d114a7d6a34699009734b49ec7deae46ded85b9e78298a4281d6c3f9bff1217fa583d15572f5dc91e6691513c25b5a50cfabdd3e5badd07515dc21793e2fe690ea85a83ce45e72e81b52d8289f380dace1d38c7fee6a9eaab415ae939af68a89771cd2b64af81af388a9f1ce5afad61b337456672bc0d341c04d272244711ad80721383172feb79ddcf888becdd8de539f4e33e471d97ced4d90add308e1274ceb3df5d36f67896440823f2c28c800a96a149242367cc49169d664f7d38a47856946bf8c866734fdea02cadfddea00ad1d0c85409feee396aba92c566b448ade386f23619485a745f4af315e029d06e0125ad133bdfb8e561b1652efddd0b5c191ca7f525a55411cadcbdb3aff9bb4cc6598886d26f6e1741788ce95599a09aef109b86b345f6a7f684a025a66d9ecc425beca52388805008b9e9064735ef33b98cf4679ef44383953b1ec63a648ea136370b7f95fbd6468184b6b8a368be04e4881b7f30fceef38274a62b2ba5a1cc1c5df7bbe2b780280fd864ac9de87b2e6f4ff238e28b4b57f12441fbf00600235028e4e0ce075a5b457b94f8358ac076e800cd416d19b9ff426de196a86a60a54b34a3510c9c288478673d2a49dde23c8a4803c5aef689bdec29e5390594112cbc98d90cb6c6b471b23adf6a33434bb39ad2cae5b3a12955fc0c0a28e529fc0e1a537b2108ca355e9c641da557010a08405994c8711a6c137b66173d5976eff20d31c60ebacc0b0379f23d0b083e24a9279d61bff4373fc202db43e53666a86c44fd4056b36d9ca3d8fa5d4205199aef9631b07f6d0b5eada3552ab9d5ff9123d0f1a25ce9d9c146f5a92586d0c1f928f5ddb3921b5e89f38d93d83640db4f7e8dfe217b0f3f742353999f72faff6f1b5e8dff88e4c3f73188caa4f25030b8997081063a7f4a4f4b19cd135a15832b96dc2d2fd2c991cec4a071393cd523807dd474c5428c08a16ebfacc7dbdfeb40892522ce2bf3a0af0e025c223269beeb9233baf13770f7719339a1ea228b383facf0303d4ebe5d5d7fe5cab34431a3ec8b9d9605a0c610eb32bc6f8ce85730e3a79b81c0a17c9006b32d98fbd80f1be4af0ddf3f85a1391b3705674254664ad131ea611addbb3d470e50a824d6e72b80433fcdd930dbf08cb9ec2a7ea683cfdd5b76f24873b336dc78a7af3f9207f1b9db2c73c4aeb7854313167631f23d2bf095e8c33d8da0fcab3fc59a86367228ac2e19af30f32a259212dcb1320cc2714fa6306af348138987dc7228e22b716738b28e283600775782a33932efa08662f680c3b3e8469a916cfeed7131a76c28cbd07a8106b6503fe222934e70f062c49569ee69866dd5df1a9dd359f0e71ae5b062199a91b34878acbdc908ed2103abdd8bf2c4d73baa4734b14a45da84d20c1a106329367844c850d3f4f30c24f16de24897d412997416cd4a5f4ff5d40b53f7bc9bafef4b82a0d786957129a1a4c94c972ebab17a4b4e1f9877d99b5f1d9b70011f85f496694d6efca17561637c7a87ba88c22a6d255d93eb028deb276b0e1b4d9dcf955f3164207ad13697e22a37c494d6c5fbdc0269d94d4145d5060d4b82067765fb389314570aa6388247ab2f11e62a5635d80a581f4a19eef547eef771ba740cd37543c1f95dcd421c5e283e87773fabdd31378dc648f0fb4938d54febcf2f665908a02b24030f8d6a4c33277815320e8f7cac0de19fb2ba5e3b8e32f58166ffd1157b9642f656c1c90934ac90e23b4978da3b596c1dc3ca9c857deb2323a6115d099c6f265e4bb2ac4bdd45e99e31c63715b0369dffc418a83cbdfa144a6e1bfe7c97bef7054a1f705c307dc24a80331df3ac63287d629e7d5f6517c27a890efb581365105a32e1fa39d7b423420dedaee7348f7e3b6e782b75c639e2ab8ea7941d9be7d2ce05f0ff1d81b8adc6a565fb44aad3a984dd44759b3621cb1018e26347cbdf2ca9398da4722c5e4ccede83c47905749caecd1787b2478dd700ffacdaa3b0adc9903c543a0badbfa607b1dd8ee835eef5cb1dedfd0535ac9c139d660ae4bf4dbf291fe03c71a785545997b728f9906dc4ea4229796f0e2106659b6c2aa50f7c11db5190fc41046bd876ac53e7c5e2e34b4dc4f57532535a43661afaf26f0d6bb0b7f801581814f1c94457bc62fc8abc1f5dc69d8b1e42536838def6631b7f697aeb3d214144e7d4a37ab8fd45b5d2c17e94ffeeb09f944774b1dbe99aadd2aa4f716a26cb292025b328ff88d4d1f8147c31ac01bd1118eb18236a31c8adfdede693bc8697909b00b20a3eb584348fee3ae764c4345c40f7786377e6f1c9431be18c57b6addf1e2ef109ed169f70eaf06bc650e2f5d291dab416d5b4d5965aba7d52010bd4842f86196ce6ed472dd69238054e6b1261de74aad10f6a3f9b5d4ea6c4c50baae1d2c3f3bf7bc695d2c26404762a39636614eecb4beedbaba309ca7f060218ee7c2a58fc052e8fdc1b64a6823e376d3b544abc50e42fb0b93d926ee08521a82a4c0c7f5a65a086ccf3b250dd54814650e5af14b1f23a2e5aa05c5dcb637af7410271a15afc0e277a42a4efce476f02ece30fc8325886d9fa56046ae7b54eead61e7d30320941a5838a6729014a169bad13338e6f174e64d7ba195e1557876c41744fe0800cb74f668e573574a8ee7aea34a80cf54bb9ef2d4bb42b4484c467035197ed2d5a256b0b818e0ce65c31093453b4008053e6c5d5671088fd390e6a76f693a152bd30c5b5d8312513fb953ab3329bab049d0d8dcc88bf949370f5f7fda422361152703f46e19f3f4b1317e91a0427c10546470bc2ed7212345dcb1e1be7b88034a0b7408c0f2915799ab5d0f1d857abcabf13bb13d95327a272475f0dc8e78312213c71d21525f54681fd53697e129a4c92cae2395632b1bb379dc1718b1605a74784163741f17acfb96aa90ad0e651648870c37b106d4b5112851e812350f7dcd172318200111684efcfa721f930052c4ef1409c25264347dfca0c6ef7435e70f9535552219619433237c13bdd5bb5910cb60c616e7fdcb37efb0db2f825a0a5a2c9eb4f8d001ae2a2344176235429b2bde80bc2bea939ce742543de65b93ee79b0e9a1cace4258c2553cfc222a1678223beadf27c75c436e6dd046d2b2a58463bb0b2f3508a1f4d8a0c0b6cb150ae02708fad78b644ec63eecaaac58963e5d92fb9dcf7cb80b82209c9dedd3daef2e5b24df20e17085df01b8863664ce730b5693a87e7615005facff4e44c2d7056bd06e3fb33546b2a8ff472ad3e417d8ae2d9781b5e8e58b21e708f06592482914d94c5ef48530469b80f8688556478280dd19ee19a3b3effd5fd5246c4cd7e855d8d2cc2988af0f7cdf43f33b44777f28aee4f36a732df89ffc3787cbac06ecc9308fef14df7893206c90f16c0a1afcc348f8b40e93105e7d3a74f52ae42f31ccc6fa3bb83e0f8eaacfdc292f3792d8881737e960f271216741f17231d19589877b9a9cc6b061edafb4de52a078692e70ffd90562f419885ebc6906cc7798a0d4c9d880ee0c043430ffa871505f92bbeb7d40a6072a61c08c9c60dacf4561760fa7e420674fa175edc95b9832bb0d2ee3f86989c8c00e4ad7d6793f8182204983f50fa8de47b912a8531d7b7d708cc87d03ebb51c355314335911e92a0265868d42ae93cf73486d0380c6224e55f133e219dc2ceb9c391ba3a3bb4b3de2f6ad1671f02789e2a1f171836c7dd79798e78e92ef0e1f6762f06be2ca554fa55018dafe4a0e48828196786dfbfc19991867e66f3be49cb941727452aa017daa8f1616ac58c9a9b60c7eb7d93871bbcf4db7190db99f83f1fff426de6e20fdddf62ccdcd82eee78f772d365a5e4e7a19dbdc6e2cfcee22ac23384700bcf01086a1457147f9a2abc0c5460e615433fad380cd95d12654e9e60d94aa7d8cdb3ac6ddf14fd0c4393259046782deb79a30f2fc58ec2b60d77558d0f97562e83c76bb6791e1fb845ea87c1a0491fc72b65c2ed176b8eb3826ba88672f532a510a16c6d8d298f2c59a1a6f42e05db5049f4640c2da6ac89ef5dc6bae173990f20bd2de5a50afe1c243798b01a0bd08fa03bd17a72842c673e493ee78710e53f705abc66d143f4bfe5b804acf50264adf8ca2af6d18ab7ba7b6a2621af67f2282607339895939aefe5429693fa6ec2c98902c139f7a1cc828074aa20e4ebbf16946c0d8fcb214aeade7cc4c0515a634ffe5144a85cec42d00f0325969a6bf960195a8f664d8bc18e5b44c29d9772c4f202132b471391862093ce9b34395406021f1361c5151cfdf7ebb24d962fe4d1952d35914ab98bba7c53e1aa80ed1b76bc2484c65bebe5a8f96ddf62b398e33bf50311fec753c312734121d8084955986fe97f456d053c71cbce65d38f53508da8c794fdd87a6292591a7baf373917a0e155502db3d0e9cfc4d063a46da71def25812158f9b2ce9eb049b2f1858676b5a5f6d6ad9c501ca205566cdc2be51a69d8f5ed59d03f02429e0c532f45d7dc161a9a52e6915a3043f43d77baa9976716e38f53b9cd18261376b36080df4f57dda8f5e8b2164c73e0e25896fc6f873befa6a4094c15f296feb19a77890dd24c67a1b2b278f5c1a5bbba35dc20eff5b92d1650d4e026cceee1938b6cb360b0db73aaf746204a88109290366ffbea045727d1b3d1281a6b1948d96e1f0b9131188db90c19a1a8bdae6bdd78de63017503a2d1472cf13de1b5050bad94de21cde7c9aa45f99483cfaa8437b63dfcce408595ff3bc86797a5e692383f8ee818af7143e9b2d70e45d018e98a998cb6561bf2ce459cfc0362906ce8c1561cc6f7f7c9df6b223156ed36adf16324f7fe40bdaeac9e5292e6cc458194bf35c3279876efe5e4d0b7d4269579e88e802d981bc5317cb2dad4ca3b843e9f53b4a56a65166980fc8e00f70ab2adb3cbe2eb45a19948cbab93ea9a4f0f29b7448986b93dadd1dd25f779598b0cb361f41bd78a7910ab3c677a15fc129db41d032c47a151747a54612ec6ff53aac242989951881b31d5894e8161f38396d31a5cade8fa589bf1459736505b93b983268c18dbf27a6f1f556ea660090e7cad035a19124a0e446d5f96c1ff9b441fa9f3dcf22ae790bc017ed135ca21c525218752bd04a3458e45880dc26630f013c9128f08b3c30dada2470a1e17904f0ed0ce01d663764825a9487c890840bc9a01ed8eb550e2bc3bafaa3e6b115fc3430d5e28145585915a412dbb202f3a78c20c23f1230307fa5b1bad2e882f8472dcbfeae09dc4b5caeffcbcd740d3440984671a4acd680512e362081db5dd5e18b52685f0d8017391ae086f4e6fcfe4470b619296e858519736547b4d0bbfbabc295191a4d9d5c5c751211f5efb76b0f79a4430f3586b22ef0d0fb67479d63d531595fbd4f43643291b280d8d1316ff0e0a390fdaf2d0ff8ccf7cc5eec24ba554698039d16aec9fe7ed82432acafff33f4108088cf0e1fcaeae333800565191155ca2b918820c11aed2ebb5930c42374722e68c4e86c717caaab16ec903f437a6318084051ef62a44a564c38d353b3a3a89e986437e8ed23dc385cfb835a2307101f7d61e249a6f1c590645e9a83ffbbfd71654fd6b8cf333a9cde4214d0f6fa96bfce2691e3852fd133aec1199f7836c45dda6236f42677feec4ab3014dd42bf2564fd322f9cd285a8c62b962aed75efefc9432d3053465511fd8ef56a1ee63fe2d8adbc006bcd1cc6a1d8a2a9b8567fb5fae98e2d209fda792501108e52269a43a228b471a0e708746b0ce4cdcfc2c02a643f30d5465c064bd0bc4ae45a95a89cd9c9ef3038b1100b4bcfdf01217b3f53c1fd30a599d634c48ecf8c3f729f7c0e9b54d875a0b73c60fef8f7162693b458775c9e313e57a026ac4e282de0597781e1119c3a5587dfbf1fd5716d8c35a2520e749e1ae24bd6a33d4167f5e9c359d642655981bd0c959cf4842437e443b5bb7f1b2e9d5c600579014e6cd85300ff6faf69165108318db395fc2a81b97e0e418af4a1df29c9408fa72555c5d028803753bac9527cf70582bbdc18d5e2d174221b79628951d604c36374990e135463260e6f7f9c113b0d5c7825a51d2ffabddccdf3ccae0f3b95521e3ddbad786393b2a002712908b5a1c510de3d7ddf7e02daedf94b74241c7cace6bb8dc69ead2e5e29b0916a59fa099374068a7f13a8678bc43ae3de65980656ac65f9a1ba8b786c8250bf1a95757e2d6d5e0fb8a738a71b3777890beee50320d16205433aa7cb4be4b0f6afc368831940c7a1e0c2687e1626ab4637cb77dd8a725b5b9bc232968e6982945725f3b95ab07c2f37a679deab68af130dfadc9dec0c28d3187c2fc4a44391623b736701ef02faab1af44aa08aa3f7f916b316f844631b0a503a0c9082f98388dba6fb155dfaea9a4cbb99b438073f17aff4a593fb7d4deb626fb0264a3ae9955b007d33e24173df06522489a0f74287e8df51f47e17ac9759d8c32b8244ff09122e6e7e86f5fe2ff3f6504ad543fca195cfc0c8699065f1dae42c02c5df07535286d3282c1db8624aa0a79304d487683ba244d97bab0029e99bec2315eb74a5d3f3e5a4506a74afe8c48904b572d710f85826259c28993c86d08b36cd5f26fefdb27ba0235ef912474926da0756bf0f6a070712494512a73b6d59dc6f738a685577a7a52add83b8827896312752c59b2e19c1ffe25883a17b0cdfdf47debed880b097233a04fbdd6a22e52e4e55e0e213f44b44bc3c3a6d2a11ab27b0f37615a9e8be66da10d80f76dfdfffaf547d1ad697a756f83f499e07f268e5f6ccd51b481d3e082a2cd673b4b8c7621247ce15a5bc389a73bcca4476510c141ba557bc40f24fec967fef3dd0a34da2a4e95f5a060a5afa87c3835d8e82c958c2102bf66e2c7038ade0550d30c739ec0bb0b58605bc90e4c4b5348069e1e5becedb3003c209707662f1d8bad1a485741c828046c2967caf59dac0274cafa7cccb9b502d070a193671c80f0f2e736bf1f3e814a9c1a93260ca582c7b42be511da011834431be2faacbbed0d5ed977438f2a4051fb229422cac476838ecc11e39490936c37aa218a34ffca3436053a5821f7b442d17b85da8c587a2d614b45cd3b3528c9109b10e0992d01b0ca158ab819a096212e016eea331891017ece94b800f11744bd4665762361e10a7452e4a1783823585c03253d80cbeb04c50bb8896a99f9f29855976c1d080d5b90a28c0604b959b4d2d54b617653c7f874ff72bf0f3220252e6ec981971cf4eb12a519a2a442d72647dacc32b724eeaffc7b1bd3a2b716a3cc75dc357b1f51265f2eb1358577181ce3ae47ce194b608297d5fe967eeb46eb45918a4de356fbb676ebf9ffc8a1e4d7bd3d5f9a849360c9d5b6d0787d1e991bc759b93ce0ad86270654594334036eb1a7f3abaafdb6dd68521d20a86d9a46fa721f538f75a964e8c34c9c3b53778ad06eb764400277e06b0d4626a55639adf80ef8c550ea2b6c6509b8fca0d371ea33fbcc2238ce4c06d2025cd3372181eea2c5d65d8981c9cfb3cd44e7659320f8058b5cc8069e7fe19c3d4b670a654869cf1d924899b9c4af039adca4113305f5e70aeb9b8c6a7eb28655073c6ae606d626b0d63219054a24e550e4bec13ddd37e4f4c6e7b5fb608e142e4ad9f367f22137868e17a80c8e5e68e3a33fb57527c392c8c24a39c67e6bb6ff5eeff8d0b96ba69fa18654e8ebd3ccbba3653b2b09b2450e2cf8db868a8696e28a107601c7884429aa00796df5a4274cb7ac3d00b99ed1aeb29daf285d7f2914a14578ea5edd829dc9625f1d729f800fb59493118d0c8d313e989692912bdb9854e70ed5d7b24a1e8ca2c2730be59c2cc92264bced709f4de0a9eb174c09c4ac3584569a0e7c7efdf8c126ed1a2fa1e2d4f679d39a6d3614e24c5800ead9348f1a0f90c22f9e1866f4fba350afd07a3d1310f3c814b85a4c1b48fc941b69881f93b3cdafe8f9102657b39ebf3ff7a9f1983b08efa0a8cf08372032663b60c278e8575fa5edda2d4c34053154a41cf767e0efa29329bc67e067dcc20375f347edb947024b722477cc264d737b255617f41fac23ee0dd759fee364da3961cb93a8153dbdd700d7fcbb8b48fd0e8695d6b89723f68174cf5fe0faceda5f70c36da1652e703336fde81a9e467275505b63ce435dbec7a0f0f91e8489a275cb785159daf23c2478152ad0debe428bb24ec99a50cc43e64f43ad116f85576bfc279516d44b99ccfd9e5c2778ad6a8050f97f886a333cc291850e8fbe6ed2a99e07bf3675e4119a7a52f998f9b4da33beb6709d07d0d49e73aaa02312a7b7180110827411c482879304a8dc14436d8d23e1d542b7759229dee42c83ae542ee1c4e9611ec97b861a3b74a3d5fec7eced8850eb7b52ba4b6281751402dea95875202687d37c2518f2fe5f0953592fb08df8ee7640b0b81c4527a8b39980bf861fd18b46cd4884561c12ce3c5a9a26a9a96724fad854326c9e7fff68b52315cf5f88a805760a889179eb18b8599d24d10d8b492c6952eaace57ea092d37e164173e2ddae9e0d01da7edc59c577d2b6dea7ed523811b147c1c5ee3c1da4c772fb66e38a0878d57fd0d1b564b086cf7caf0ba3c6f075810b7d161df24d0c2fae8a811854e0827fd3d282de9315655d25fe1ee6385a65660289847bc43316de57cf971e6d3cc376ec4eef3aafdc719df7794fe76a2e3b3fc3f39ab8a087552c1fde6e01d7ba644af4a292a374a63a53fdd2be621a78263f036fb69452815ee149cf0a00a055de84dcc8bb079840a9e2ed90379b3c980adaeb9e4ce8dc72c0354e44be1fe312371134b8b1124e9b9698f2290155272f0dd68fa7c7fbea202efb7971eb734c0409a9e2252902ae318a71629ad7e89bfa16ad25e7052168a308c4bdc7e1fe5405dcebbbe0c00a7f09db4acc5eab43548fc96cb124fd521fdae39c9704d6775bfb0c301335a029e790de8566f95882d881b465f74d4f7ed0a5e15974be5933554de8a455a07f6353c45a0c7da248c90aff59588d4d55042608f4cbeaf5cbac66145a868cf601c87af7858a7f6a515a04170a826c3860ac35353cc836e1d74221de2355f3d2f21cfab8dcf3a960ca8f0168c2f02943bb7c51ab5f854649515913803e9a5b12a47fc6bafc83f15986786aa07420d620b34fe2574a04c9117f1d298f6b3fc2e04167940e6fc0db433ed8f8407ec08400b94ccd60f89f1ecc28cf2d653f348fd4fc57fbd9b5746c6cdecbfa193ecbcf25039f3814bd6b7cd51bb2ab31fa70c24f024fd55fa12e9204e5ed39c9976a02d9ae0ac6456d90b46f9acc4ad800f9d7aff73160c01cefc0a646ca758948ba09f64a6984e4c8c4127ffc7a85eab8213fee52086de53f88d036a9cdb05534fd13bbf270a82660e2e89a65abc36f8afb98d3d64ce2cb5c6645d48b5fcaced072d4ce2a174c062a344940f624349a15bf7bf473dc5f29a110bc18653864c1041496b549df707dbab3d47092b1f0cd1ee6f3af2633070b4d459bfefaddd8a484651bb32485f309b7bab394e77c8331e5459928371d8add4c2ef937fbb9cd00667168e67f1cde39c8009f6bfaad8a5781f795af3fe92fa42b0ee6ffe827fa8d7a87d9be254d1bcb4e82aa5c3285b589bec1ab4c9b537ff3ae4c00601b24c4c32f1d3b711118a5fe9d6a9d40841e5a9fbbbe760892ccce30dd5eb877529cb164c49b6729e673114d307c8437452dab997c6d05497919ba74ba34836199f13ff8348c573f3ed88a7836ef0c6f83eaa6b978bb36c9f077c82f643338127be0ec37ed584f961e38cae20d93df59db7fb492c3497ecba641cfe13292d940dff072523f0a8ee651fa34cff7a8cc19469693cc0ef9d7bbcfc44ce14d871a9ec0f35e8cb1b4b61553118b82b915a917d086ccc6990adf8f299e3aebdf9303a16b999673d0d7bb14123a9e9ee4d85c833ea61835f70b766418785478124109d2f17a92dbe38db482b80b6628709391e7c0144a3f58bdbc96cb132cb9a221a31285d78ce57d47c60d26c860fc29e7fdc2edb4791e88e1c5a5260ae8d796b2f480cc7d0adcbf737f762a5d93e41cda7c4db8d8edad980d8274097e505359d41e808470bca85f2d9b5f5f1933da421fd030d6b9a4bb27d0dde43a81aae17502eff43adeb08c58bca86ed1b0387d16d4aa74701ea384a907745bde9dd6e1868e0cc440b005a1b1424ff0caaa89c0548d52188e8eb7af6b8a563aace13b2b17168800f0167270efc1a2b2cc0c7e205750b992056ebdc7e9c3b94dbf482349d5fff8af0d58be223f5df4df56e44d0f9f97979d733deed0972e9d4c9e8f41c7d379b881ef7490fa2c5ef7bc2acd88264b181252e4434a569b743dd27f1226385c84d50b99390aaeb3a5793a0d666cdefe44c21261789f780d6b248cfbf0bfe726542c496c6a747b5daabf720a108c2bdc01655e392bb53ac84aa786a9af20ad5a825880b9adf2675cdfdd20d1b64a3d73659531ce72f92c04bcdacd74395fb15d1b2b136aa5d629f579bc89ae93ce585cc3be294db23462da1c18a8057319d7cfdd705de85bfafbe8a841c74f191e2d16a58bcac3af400314f0eba6c2780ab7d87344c7189b90f76b08e63839c25b4336a14bacdb72f879c661dd332f51b5df2a71001eaa6aa3e8caadf436e04b8a94e82cb3df899184abfa0c6a0de5bb0c017f4fb77eab5a53b76e619a1acdfc586a5d43de2d7f4fbb0b4f4ee66298a86817a55bf63f827a9883749e92aba8635cab4c50b1d1e4512a023da06b2efef10be1c0d0e95113a3c963a41b0b3a0dfae200195f42e15d0d4f0b8a5484d961740eb127c3a25abae503271ac752b2d7e28a65016da1736cac1d6ee623faddf3341dd7026b274168b4406b55f2f8282a0207a1791da787097038630ee8b443be3cda8b52139216efb1263786a8cb820b272a0b933c9f47f79da072d635f0cb6bd1711ffb6f3d7e2c8b3bbe286dc431d67d16369a2caac7e49bab587a5f516e5158c78e9b454405ae692c2efbb372e2c0e63274e8a3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
