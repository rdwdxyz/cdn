<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e176df0d8d289640b4d116f0e0981b411eee43f022119dec39388eda5adc81ca71ca84084b10de00bd575b929672724e5a9d89efca26204155fa7241aafc8ecffa2bbb603f6e176be459e44fe019492577b5b2834d5bd88c6875da9f1444bfb4cac3f201a36d4faf0062ddd1f9d4e1f8f0cccc33a70add8bed149462e76be35c227bff6f8ae8b01372957cd3e43fd64598371a2b63cd364a965ba04b4f0e4a66819042c406de0091a55773c21690cf42044b15568947df647a817c54a7d28fb887644c24440cd7137872e8e8ea541e4d5038bab08e4d8dd91ca7149a31cc94a5d99f744073a46bfe718eb495703baad086229ddd76043566335449f4372fd130166bfca1e3dc94ae52e2eb37486c54155106525b8f404c846e5afa3b3394b263db588c09f7b8e14fc1a6770cbea584500efab8ad041c55468fac2fcb1fc65e216b06177d93d735201bc241a4af9d24c796cedfb5ba5ab4afcb6eaf4a55b71a652ff3fe938dba827d7dc402c8276677d6fd8481a6eb51e6312fab00b3f465ee95e2db63a3cca728fbffb31d7ec8fe5c4709eabe6119d06e9a1b03d34743a5170d19ec20175935ca2ec9ea8c5274a87f1fe9834c4ee660a6a3a62c0b7d063b80dfea86f6288ef489a9b0ace8a49e1b0405cb30843b11bc985e29b55f058d5344fb81b62606e965849db3f3e721377caa27263d729d6bf2a02f49fb09f7889368a9a2baac424af480ee78553a1dadc8a56d49e6ae2be842f611b95d6379dd38c8687557646ede3a0398dcd94cffd88e0636e062391033538858b22900be04a6d9a6772362e6776497e070fd725291b8c0502f7e07342de257bd8510806901c277841ef0c129e63e22e9794391773a0e7252e2dd2808ee3f0f2251887340ae855d58b4f8d2d6b66fa3316c01fabc8af8af17118c98f3969e56c028944c64bf10865d9219e9b25839eff75cbb53703d7174e9c9b228648bce1007478a75dc330679043ffe1a33a9e5793016509105814f210bf7b0fae706479138607ef77835c5ec630deb34d653113e4d0c75a6fe7f96e0f6ba8aea594ef3eb48a7488e4283a082cdb1f467fb1c909f4c299183227bd2eaa22fd523e049679b05cf3e412c73602c7d5b21efb203e77c9b24b9bfa8b63844bbdb4dbcad8c023b5738b2a00af4e1277f85de51d8e935b841573f74bac85bec841a8b0c16e69941e329a1bfc3aace6d8c4cfaa200529622cf5cd5d3e7f0a66523c8b3167226ae1e71dfad56350fee2d83c6d2357c27bbbdda35974fdf56f30054811f6da1bf529e70d9492255a3bb8aa7dcc6b701c0fffd73be3adc41c06a3a5873eae533161490fcf065db90b8d38e2f4919258c4c6debe26ee101c25b68c97e44ee4ebd5618f65e4e5a1c0ac251573edb87f301a7797794558e87d19ec6cda0ef6a0788f0026c74c685a40fab07d2835e35f2a714a86257ddf3224d9b7cc715055e3c412c7c8fbcf8412d20fc0667aea9fdbe349aec5b3dc6e5ae9d1947d358d1d3477f9ec53d14c4763397b10df20104cf1fea05cd4a60eb038379f21203564b3d081112015038a42f942304feb764094f26c2db07437dcd796c634118708433411915e85602026ed36fe92e901f22c18baeca313dc3082dffb23f5976c052dc672c85880f081db3fcda366f1b9368ed7d71b9745ba3f6e9831ece0cc0ed937b743be942483a90b08d102c3b477324061c3005efccd5c95901813eaa162d854b2dad43d5470758f0e62ae3c67f940ffe10ec628d2fbc1ff0e3b0f5f11366d7ab799b87fbf278c6248ec450c2b4c443800626f23a2a1d8f12b8d2909e67f7e80a4953fbe240c5aeff1332ed0ce0f695aa316a4b30bd2b3f46b75ce8a8ce69e4334be017ad53b53b202d24d55cccc5f7404e968f13dd7b04e61d5370a1a4395e620cbc385b8dba2fa5797e03fbfd6415c2b1726e995e14124ab1cea9e7aa1434593863e21dddc85683d64dcd463dced46fa426434f50f1b24ac065287318edbc2b901d4e15c4fd9aa23f62455b3a44389cc78f855b5884c3c9dc548b22e2d13d0e32c07301d1a1eaab738fd3b98cdabcbb51b17ff2109775ed3839800945f0e279c518a63fb1ed4bc43fbd3b65672d13aa01497a6539db873ddb7f2cd23cd775f8eba0248c5fae39866d56a225211b7fa3ca58539c39ebf19fea4a3e44d10d98fdc2a407d648b4c197998ed0a1d70e4d479dbe9b03d2406c9d6c34738b6f7bd37e6a5d3d13fce3ba7147b99afc01a520a60b48659f9581c6cc4413db11cfcb75c99c1d4bec4f33406538400390ca7ae1572ef3c324c0cbbe9e4dff30b76b48b1d41739b6b2a8c39e97522504bd3721750b2d43068fbbfdffe8e74e62ccc909d9dc15acc7be9b84987edaa0bf54fafab54d8a866d5659757c478036484a2626a8654dbcb6064378836265eca8c007799d58f47408d6bf8f07d587d17162d6c947d81f03ce17d0b717163f559a804f2694fa54f3c0a660724d257e83d637a49b110364fe41756d878a5a8e32311de6d086ae1d68379a75c641b9ee601d6543f31347d3959f7407bccdf9a4ffe1a7d1724f20e10f48108e4714891a2f11069837bdb6315ef125bf70ad25d277095827a195a3cfb7c2cbeeaea187a23f5c15058a2c463716369f012a98b9866fa538169c50f8d23219154a530c59ea1875f6f81d1e0fb1e6f6d1d68366e0f871e4c36e67a1c4ab6c0a0923e12c9b08746349e63ce74548f56a64cb0e9bb674850f606f4f961751b6efb29b9de04438274efc885ca2b91c196d5bbacc0f55af42d512c8a3762fa43ab15f175e6ddd1f5d71c96a43771f610842a2a208694c55bd17e5ca9033b8572300a81372238dcab7109b7f46d2a07304fd4dad04f84af37808a3e0a0aadd66e358f1b6402855ecb890e5341c930ebd824b74b67383c5317ab5904c40c9c66332305c9269d1afb240502911ff2bef0771ef7363be0e4f922504f08ffa27458b4b6b8e37f82351c3934c81b51643b0d35d6cb328839d16f6392c99115d2b908cd22b04f1013144176ebda2539ab3c4934c4de79f1fc76c102480d3a3b308f9caef61e53c7d7240e992ae19dd70a6b2ea36f59b6e682a224219fa0bc92eae87a7fc7fdcc31d0b0cad774a021fc6b24e68858a4fbc45030d3713a6f37cc09f1055d68c8ce7819e91a2da383d5d2b4de076ae76d967569a10e84eb8d3952550da2b71c91b1d1999640b06196bc51cdc28e2e34c3f1972acfc96f7b96d13d57e5b3f932304b61839a6c8b49b052ffd181be10ead29122d2a6de1067fbd9af0417c7ad62dff60ccd02025266f07621bb62b0b507b4f9ef84139e6efe9894fb34df0517c27bfbba36b577a74f9ac587517d2e86b3dd3506b64eed7d3d180671c4b177241c15ef3de51e84ac31bf7eaf9b67adbb0972874043d3ad9cf426a60f4355cf65f313cd26a600c14126770904d5c76ace9d18dde5cde70a8d8f8ee620863d980aab86ed193cbfe57130e59b3ee95b1fe976bf4d05611d94e6d2b947fba58bc9f7d0e864f63c965b91630a4ecd5cc7fb8eeef5cea99335c5fc6db0ff260ff89cda81668382ac232ca0d34ef74eb979d39b959f3090e8096abea8b3fe9c1ba6aa1104c3bb4c576e08fe3882889a6e60de2abb7a7eaa3628b126d7a2cb51c67f2d2acb56607dda191d80f7ba6885e36124175b64651f624c61a4073e3d0cce4f98130800854e8f80b9e971ee96ce9d4ebe04c4f1eb297a81f405d3a5d4b7ac837c1279f6e52b1df9979b99691415dc85c19105e555aa67dea39761d9896c3a822d49114c218f2f4d1982b91a9f1303e6b8c24141ff6e6f9af2415b281def0eff9e2e3d1fcf11851770d845ca4ad647e415ddac0e98f6b5c331d1fa365f86196c4b4348a6952e03a6bb747b96342c26ac6004cc8d69cad3e3c9680ab4c15c092d999ede9a8c789c61c76f4415eb119797dc668beab94791a3f21182921741125e8fbeb899409c72138c478c145bc1f34470d118e31db8c31a9c33cf8646e906e08e46980e77fba9526657ce5f385899a7099e1c33b32f9a7db898897935f7dc0271990403223a8cdc52e3511b871d2f9674f6bb5842041ea641711a5196b157cb674c4634c9738a0af678c492deb383d15dfda1ad2c09f0be45ba2aa384dbaa771719f70737adf7c22a2029241676732db0f76a401faa55066e78352227bb672b508d194390a2a2ee237ac6b7de97965c6102b64ede699397a9ab4c5f0438f76331a01ed13caaa62f2cbba4a49fee1f5a28ec7c5034b7127227fd498ffc195b5710617256ff6dd5b6e489278a24e348e8293370b77990147b42dcb39868e327dd6e9383529ffb23063d2735a139cf33fa51020190971705fa62c951961d9deda3163500ada99c2d024a1c364f9aff1c3385735f83cc7d442a9fc484c73ca9a9c91b9a949fc89601691294f4f720d8309fdea8a43f6d3321178d3ba02a98ae7e9847622dee953619862e586f8eeaada5667fdcdd7be176052423ded1e80638b72b3ca9abb350530e40cf48b62e62283d9fa8c0a32f79318ab648cb29e9c16d27fb6533054e64b7a1abd93b252cde441fc9e9f73c24acd38e98ccdf5c01831bef94cf81fa967dc5b633342c6a8e8d6b5d0cab0820c3d639f17d19211741a6712c8184e343f45d7a8adf39dd69fb0140e7df4726a60e52357aa3d62cdbd387ad4ee289dc8f48e665cef6f52973c78668ab5e39843ee1654bac2ae820157ff8ec4ddec89589bcbfb54e711095f2882f746478c9e475d2b811363c90d95d0ff3ce77646902029627f937b8876f67592d824ee487bab0a805a1112f0ebb96204f062f241d3e5158418b026e92acd37205e626205d4344681577aabeaf8de8ba6aa081e6711bdc67750e6f386d801d7c1c273a6c46c1bdac390a4ca7bcbda78e8f5c96423ddc76b3e9017138d40cbe93d28bfdf331cb1a8d1f5851a61aa357af89f0e4b689d656912d77fdf587434325c61f27d6c70c8d6b977f1052784a76cbaad5f5fe7161c0b2cff4426590a3ba87c24005837352aa74984ab4d6e54a981f3abba466abeda1be8153db16a7da354387caebc7e28501dd861dc3db2ec139bbc4776d5af817f8bb0744b243cfe23a2a5907f855de88b00905b0f05754bf69db3930c3a542d1171aa67b8d128fbb59123da9842c77a654d860fe25faf3e729e1570c2504542f474d7fc3fd0edfa6c9e6f2ebfab7966677e8ffc667a6c20bec208ce984619b04001b53ea2061eeba91bd7fba37765758770079d4b71889e137d5440cda53aa972b26d022a76e15d0ccfa74ea2fa5a070473a8493af5a1e34fe60d14b0d4b2a402671f5c215b15f21d9e2024378490968df3e3931a64fbe4e158190dee655bc013270637a2c598fba802322a65f5d949402d808fb0bc7ff3b945e7ff4d5d9de846b903214c68cf35e52d049543cfa5dae946a86f941b0e5064ed2ecc930f24b23fbae54ff2755895058154e81c4a3d9772d23d34411dbebe0f4593cfca4ed5499a36c4948c955318ac9322e058c0569d5667d1c84326b4554aad74e96d200192c398effad38ae1f833b8e4d722122c226167c093e0b18eb6acfaacf6b3926448ebd2f52ae9526bcd83e7ce23adbc43addf2d3b6ce99bf36de082eb69bc9f00a2bcd3676946b6b9d5a4ede72c9b345eafaef06eaad194c3df41ca4333767bea12f24b7b55ee3b9acdd17ae36bdb1f8cff61c3716eae50cafeb51c633fc59a7becf2466bab3d7f6cc9573b892f07f1eb069e7539637689df639ec72ee1cbb8bbf88e096481b4b978bbdbd79aa17ae00a44c755bd04e4a9c9ee9e5e77a5809d2f60712e6bd4b7fe13c7ef952751bacdb1b9711e507ce76daec5ae2458d7557bcd825cb657c49a8c5ee77f4971ebe4ea6dce48e2021f3434adb07d9bfd041122ffe8aadfb318f79fa9a938936acc4194d5556c8387c007343e5fe22a5a10553cf0ee4cbfd13a322e29fa518e9b5d1bf748e93b2cf72a0c1471fb04335d75bf4a57d0c357330c01746aa23d523bf094ea8d4206a9456a9aeac828776129df448fe725c884a0b7dc29d0ce8beb1cbf4dfb5050696b6912bfa5a176895b1102492aaa94fe63eb1975b9d2522c59439d94b36447e51d0e9c5152f92356060ad513a511c0393ff60020de84dfaa250650ec1a7231c16e7a11ef460382e8eb456dd84ae2fbb8b0835707ec99f1de102c530bd01f558b2612467ec90f8070f91698b3e4828d3b5d86b3a4f9a8ab753f1715d49c9ee748bc285bb02c101a03627e7d8019fa9e4c4a75cd3130ed89a386ef68ef25f5e62017177db81413e67fb21b0269487d88aba6d4c4ccd5c38e4f147b28dfaf4c13a6bc03d816c05b2ab9fee41f7ae94df822d67e1ebb1010cb1e525e646f4c4594ca3b2a92cbf654cc387c40201d29fd3b167cb8323dd765ebefc77b8c8cafddc54984262d380c42fc13c2cfea9856b01859e54889e70cbb74f62952f1fb9547461f68e059f4279944282e856c91d5eca6e20ecfbb9ba840f29f07be1fd3b5aa0cd4eae8b10f62a09945b43f364c4e0a1bc6be4cf6a6be4e2f3666ab0a03d5ae264d3dd8642e604c30598a093b672a325b030ca26c2586e51446304c310552f18841a7cdd884245b7f487b421e27bd32c4e7cc68de88cce2e0207eec2122c6a6be880bea63f3f2eb6d069a6b1b6f07d2e084d526c6b03dcf35ab6a2a861267ecd2d81ecae51266ef8440f99f90c4ed2e953c318d6b026e465281ba38dc58d7cad5c33492c73deeeb33f499e385f49be19f92871e2ebb9accbb7a3e6c67783cb7685ed89a53fe1ad36129a035f0ca799182eb2402af69cd287bdb10722fac63137db42bb54bf1cc229529da42582da0c2cd13e7ee1da3d022f5441700a3e7eeaaa93edf3c4b11638692ebfb6a82df3a65a1ba0ee75d526b709c216f54cbc1bec96122a45f4967b90691eeef10fe12544aeba2ae46ed8f738f7a99e3faada84c5ac98eef5387567152e1453fe8849bc5a402fd1f6f39f1f28e95ad40c3b21d16eade4a97b288aaa94f45b21274e31220e5eac790bc0910c28387484e74210657e484d30d5b63857666ff90103ab0f0162b7a44b28705b74564423a89cd884b062aefe340e7aa359f9339eca422124f5f1654cf03ba9a5e46536a102b1f63b8146258b8d3b73e00a1df0f75db2ecfe32bb9e0b51a67d32022672b86d5753ed8bb6ce4a616f1c90024312f9aac7a3250008f62ffdcdb343b282282043cb10065f238633f954a33268fff61c3302e60b9a74b16183b3c5a3adb1103090eecc9468e34b6ef8a8acbd54225420d81079aa1c0efa41712ee13a2ef3223ff81b7729bc30bfa8a05c0be75602839116b4adf2faf781d65a6443ad52e2385b93241fc8d0d780e431bf5579660808514de0cef1df2d24c3ea99cf8362273534a68835cbae853bd1fb803aaa42c59f58baf7ccf62ebf7c7332123315f9be37170eacb1d5df323db5ef107da7aef5e04e0623d299378bd12fe7c9fc4647a5ac3a9572bc2fe80adf7a66966343ef0b7e8f467cbcb3f968e606a254b1ac183b273fdb84a433ba6e230236af20ed416d647fe39713752ed7860ba43b966cb3116fb41c7eba595204350a01d83252e1322c0314bf6187c7884b928d3e7b8a4c663a21295296cf93cecef24812604e08bbaf1f453456a9f9eb50c2e48fd57ee0e0d4604e4008a2f0206dc54daaf3369da7a3fae4dd7cf47991fa94e9c6a7553b56eb64e8bec1472c3b576098424dbd7894dd217cedcc45fabb264ca1c7e080504b3b37bf193f6b53d579ed124616a77c3cc6df7a79c8d8288024a6b75b2167466714f23433dcbd01b2cdd5585f20844ff0fbdd6d1d2161c3a5abb0e38d55d596201a6a935fd6eceafac58536a5a1a1a3693fdd8d6f7e68946d15bc47878b415a88c63545ce726f6f110a96375c7f4427da60ebd3d0a51269b68a780403b80757a46dc3a3da3759a6f73620244e6dd70e9f4aad87a0fdc72a076c81c35b95c813b33d1e955079fd7bc4e5d9456571f78447099d4916c59bc02ef02b20c5c2fe7f12ad30601e87f05e8b9ed1e5ce5d555bf146177ed86dd624bd798344ba45a11123a6a0e08ffbd4d18e911de0d88884c0d72266afebf5a549ac63f79569de08eb65db7b94be745273bedf424d76ea03c5795e15835efe95e0a01b8b0da669f1dfa82af51d3cecd335b54fe670bc967fc3abdba9e9ed165f51af251c39c0f61fca76fbf319cbb4b29f266222b65dfe26d42001f43000822fe878b370af30086a93693b59ec2b8c52645e26ec5a2324c88e9ee3d560f9879e75e765cf105f0cf24f66580c16c091b1b8660876cc85748712914592ba8e114de09d69cd8f093f4e369929331b4138d8a9fd7ba1e76671568e3085fd2c2ea8476f53c5209f6e27a6d00c8bb13c45eda2345b28cfab58d76f6461fe90ec9ed563cda06c45889ed9bc426dae49aabc5e4fec5b8d1d18cc951b42eee735be17562619e44acbb983486f56626b0a766913fe78925a046d8778dc339e69419fde2ef8883193f956ac53a16aec90dbf379595d63f8e7a3449aec941dff08aa7dd970d6fb454af19c6d403458204ff96f684ab406c97ec8e83c4bcbe35f5c4c866f2c0c447b2df770f2de4f7588adf6cc298e198a103461ec8699e065e10ffd357b2e36e3a649dd037a6b41807cb58024977bdbfc7b8511d6c6a7d7e73521a6e65b521d850dfd3ec90e92d5776f64afefdcbc396a291528c9f22ff6d3c27a221cd1ec70efa3678f92c4c2f0e757c76973fdbf28b17cb645903c9785b640eb9c82a069d86ba26b3d4344461c355e4aa4d611d5e7776e6b577b6c5fefd156a02abbd6f465df8e8ee353e706dbbd51f7b8d46c97a000b72e571a18dbe35a37d8a79755c985274cff4c58d4c2dab5a9693649e87fd0bb5d6bf3432935066196454679d4c076a5d6d86c28a21e7dcf86f3546fa3c300791f528a5c245d2aa7cfd5ea2a62bc230b682dce3861a3161237391b6f2dbd8c64122802375d8fcf2eda4505df00e13ab7becb998fa3186fa696a9c84be7db004eac6cd0bbcd9e61ef9534cbd7e07d13e7220c41307a0079cf233a1f5cdf3f5164aabfa27dff09288b3fbcfe68c750d7616ea0aab39f793561062d69231ef2356b78f4f65cabaf1aa4b83f0e0a10ee0ba4b1d4ebefe5b80d68ba26f52a23e6fc6d698b772ab9c0d29e3fbba256cc14bcbfad180d911693be6f9f580e5539d73a35278233d9c8c1149ba582c36e750e11609c96417f3011a3d5c613d1a979a7626614ac45bfe52d96e821cf8e54c8e6794ad4c4d4b1f4d8fe10cdad493578263e290f3373411eb0d909024557d694ed776621e17cfe9960545a0114700b3915f9ed74cd583fe4a1795deaf7073ee52a8b5763840bc3fcbdfb893e44c12d12b0ffbe7baa6014aefa1c849c872f20a5968124f78c54dea2d0c6f2eb1c2bf0488ac720d5ec1c24790f31aab360ef0559c5ee75226d8d5a4118803ad7bacc63a2479d6b18eba775b28b0757057f75f59794aa9b22d5b275565ddb358d6041ce442527d8461f3181ab678efe11b8800e3a9dbb5b56e9b268d86770216cf2d733709b7364ba988c33c67f0611d2eb2b3df4ef12f6fd596deca3e29b797adf5f3d763d47e704b34d68355c489f077ff76b8811d6efe652c51639ffc926bcc8459ecc0d5bb77cd4d8e616e4ac7113d1439ba903e24d39f6eaaa6aef13cac36d7a57aa933db9ffc1a197e248454b2b176e199a9a99ea4c266a73274183215f17afd8e69f0a898b30d0992a4cdcbbddb6befc1672f7a08db1771e64c9bf379aa5eb4986dd65b2b66a0db0ba3e2d46bf1519106f95ae004fd5206f7c2621f66a979055350855d1c999d10f4c93667eebba75e67361bb2f084ef090f93593708a7348951e24c5c69556734968eda5e99040399d6a5c72e4a6790822499133375d60d70c4090588527de408cc01fd61868c2656320802dd9ed73ffeca5edbb17eec87d261cc3c700b403e45ebb710c53313cb3bcffa040bc3c86ace16a8399f3b23610fb30cabcc757be840103ffe4468d84bf116449e86b2f716c9315d27b063e563a50f61544647c9d983d7c2a8ecbbe6ab9efc3e2c4090ff02f8ee5dc011072a332631b62e558335357103bb31e80e7c9d91ac95050b7bb2dae07ba82e3fc70944b329e6ffba35242c162b37f2b8f1c03df291831bd4aa729acdc386a6548cf352a7fc57872ab804016a4bff32813fdcfe7db8a66c98f63ad195d1d239e1e22241bcab35d98460b07d4204b6d281a9e92c1e66e7ac0eee602c69d4c28c92ee6f3a5a18b125ab9deb906f834fc0ad662a1f087f68e48d14009b75672a18e3dda22a6090433ca56743e1f8d25016818ee3d4d9e7d920d05a254eb72691ee97f0d77911c1b3e157fd58ab2b3fbeda6a18792c10416046cbe44280069885df4ea6b97a3161b8596f388ac0b499699ff0940ea9d53b77c22260eef2f46c6fd7d9126a43521aab91676eaf84172a077afec0022a73e24bc3c92de2029d6266cee6dbbe674d0dd70f3c8f732e53ed6d44e7dd7f2eeca36e51b05fe1df2e4d5bf67c3e59d39661c190bf61bb2a92cd0ebf395e7ce2f103a441a93945ea25fcdd81c176959292cdaeb269ace79562b2fd3e363b32689ba962a1a6a1f5a5482441da6f1b898a12507336b392438addf9f1ed239608a4eb37d92f7b3c9e8fbb8c959ab1757f36bc4c17af7cd96941f77a6f8375f18885b2f8487c8ebf2af601e7537452ea117925f5f8d2c2a5fe3057203db1b243e2c5fe708ea33f47794381bdb038dbaab9dbb6d6c231fa502aa0adfbde0d736f153c4351a40a2a6cb4262ef32c97cd01de549ae93726fd0b8e4cabd0ccac49521e6cb1f40d2c64b9af1e2e8090e5c6a85d578a236aea12ab302b3724d7f5e3dcb1448f48698419808c9ebd34ba0ea61662e108d0fbb37d1b7ed0f2f40f5e021ace30140f2b2133e4aa0d9b316234a89cade40bd1204fa4bc2788ffc03fbf62fc8be99a28a2f893f57b174b914f63e8008281e8a520bbc7f7b6dc9d24147430a8cfc919e9cba633fa6a7deb46ef4aa3894cdecb35d0bbe157855d0a2b224ac79b04e3eb5b2db99857c3a78fba3002dad35c5edc6812f3bea0c4dca3b9202ac171f2577e08a3d601d0de8a387cada86e5e94f21b7008b3bb16ce7772f5946cd9981d85d4aa31bbdceea5a98f1f6a8711adb9f37197e25f9cadbcdc0d798e2ed642a8ed24a2b98782db12ad0c3ee0d1d0f3bc84ee56196ad7c3a8d415e3e33bc25c074bc23b335a035d3ba7435a96ea8f8a71d30dd6f1e1137860fa189419f62fabf833b4f32f07b8b514d131de4352ad31837aec40daa7a9376688b0fe39472a6ffb2bb5664d697ccec1e2c0192a2d76d57a09e83dd5433a2d94137a99fec68ab2b81ac00b30d328a7f82877668baa3a05b28163ef73621eaea72db0055ccabecce1e75ca9e8654c4043532164629d345c377c2d16139d81d48259d26c4f291110e70315055a07a92360f1b34dd9eaebdec092f343b206ea3283b613d51b61b052912f8a6acd7d3e230a5bfa9de4975b3f76db797e96c6d2105438cd01366de06277bce8e61e4b1ca5c94eec599645e2b329377aaa0d91838454d31580b53a39d8fb985685f4f55e41757bc336f3721d13c91e89fbd197780a31405c9b2eba0ebcb1c7e5485c75c17a5e75611c9b07d3b56949116fae61ae8a174f2511767aef418e36061615b3a6eac270622e4290681b1ecc674092dcec4e8da1e094495b493246e29eac77e256221fa5de8c401b84afc74ca25e50c2fa895612262af197f8502d7d64f9d419049521cfa384d5519638752d3413712a945945cb9879de15c8252ca6cfeae5b40adb0263e6eeca06cb5655f07d6be9dde0618147ccafbf3ec739be9ab893948a517627d9d07c5b90b71b32fdad5e0d5ea1e04cbdde233cb2392341613efa8ac0d2b39fd4e964553c7165315b9c86961f47b50ac16da0efad6e3453609fea0dbde3ab57d81dbcc4273c9b84bbb80c6c0031d389b16c28e265273afb45bf446e38f4655d3a799827dedbc06891ae78a86210660c972159d9286d17690360984b095a0ba208192aca4f1064f18c8353988f2b7ff65ac001059447a49af19419e1b8d32ac288f445bf64a3d06670446f26d689205802c0ec515b2d70e8211cd35705ee00c5e68ce53e9ecc0eb1485322ded4868ea01e1d0cc7c81af34d17c31c9fd735a03bc5ce9857fb5a49c67995ebefacddf24587875270baf42fd669db92d930a2cb8174928010c8fda9804a549dfd120d31988118fd34619a8b5179803ddf661699221e7da8fe2c06c3d5c4626e68b0cda56361addc7c6f8ad3daac36e6ba81e4e4e03c0cd156635b6f4be215715e04f46123cf8b1f7d89e1d5fd9b5ee44e059b32870f5f70bbec4ada5dd6db256f7d8c6f699f68b5edced62bd48d3e2f262e42c99fc541cd45678eeb32a02d4a1a09cc0b633a64bd7e89e5668efe0b6b0e6c128442f10eb15a1a95346b2ad8f75c297fcfa46faea5845e08ac1f78ed4e9458dd2afb0d0c84a7f1cd2d319a60740fd0b0670906e8e290ebb1f9f2e03f9c80663efc1c25805b15cf682a5465d5bd612dd1459528edb830f7dab8ff127e0c5f5abe8f4b0882444af1b7041b02ff5a4055ac33ecb906ea96a8dd458f6604a15ab37cb0fc522bc0882a490d1868ee6de907b59a28a612a4b23d1d33a78d2bcee6801be0b759c7e24fab09de3f2f890fdbb085047055a71724074675059accf6195f9d4d0f29fba04906a3a0f994284deb41f212923e27c24331099d22b2b51c6501c1af52330c118faf2b5e316f4d131c50e337c2755ba28e1d207402c91b08a289ae91774132ad1dd9571a63814cd77612b387a21023ec7ef3de449630ad805c737c3b230fe3a2a3935b56f93227c712e9e586201b6de5a2155dd69a48de443c6260887259b816f87f1de612b784baa614d3b2c3f1f1da852d0385c06dd1be7098637eaae0db633b7dbd626388f8cdbbc1330127a041d97cab3db2541cd8352df3b1822baff6b810208faad5eb44fb44bebe5bde2abf680636d0dc629ada8ed4f98757423adfde6268ad6f5d2dde16443d44b634401a61b6c43e793a6acf5d521a956d1b25dc5c496eaaf6ffa333aa1359ad2df41ec8ce415370fb729cf1a5c4406db4471b043e2fdef584c64e9af06873fcf09911bdcddb5ba829b1550a602237f62914db6703c5dfcf49fb5e8fe869720a2000bf38a05821a057fac7d43d8ac38294009a07ef6125a6c6bf9351e34935e68bf733e559532431620dfc05777555e781270fea683967b688d6df6f2de34fc8d72e72e445a6d9d949a15dbadfa55cf633ee055ba50344f50bc5f206c1b3ad2444f8567fd1eb30ddd8d5bd2c60cd9fd18a6af71f2bf7a9ba0d793cac4397b0efc5d3524496df15e84b50be29ec923e9e3368ad210e324f2f7f320d24116c6ef5c9e7fb8d04dcbbd0c0e6028832a709b925fd3fc20b0619ceb44f868556669ce71a0a102a5218d955f2367042504b4dfff5a8b9ec2dfeeed0ca61e3cee42e8e66e05caa9ab2ac5af315ed1b5fcbeaa15b6e5ec33d380863cfd5b69ecf6bba6d2c41df68c483bc5fb6775632f1063de771085222a740dc37d98bca1e516ac804085c8c2037222ec4b150072b644a560fb27b045541a6d7d040369d7e7b138a4943542aa46f4fe817d6cd8ce275db888a6345571e62158882bb048c5fbe012bf3ba8ef598102f95c00aa5d69ea5199cacb6b54317deb347c68a7aa66a543f6c10082b637c9448f8a904ba8631a799d80a809498fce7a89bedd6559fb52fd02f1c84eca933788bbffb32d7d3e2e47d4821070525ba2d50295445c0bd04315645b75a30a441543ff2a5a44c821e84863c4c49fe9c6225f9a92f8e7e4c68beee1e7ada27f68a3293d4a70c77d9890a435e2ead0710408f045b171d8dd4a5699bef1bb1debe34ea271ffca8e031b510f11f31a3ced081c37cde853a1d0f9d3dbb08b1488815618023fc7225637ce24bc781dec0bd018f232fb91b782c40451e30bc36fa31c83d9447429f3881c93ec9baeeb22e3bbcc2dbb7a6ae412f4af615661de4f02d5cc7ab1b2557cdbcec0d4e6f1aa3cc0e0de0f63181d60024e71ca68bb4f33e92e9754d144136d2beae83be09bb74d87297a73ea286ec5b45f197dff1484d83dc67f9569152bb0305c078595207145be603bd010fe03aeda76047490c089125af499bb8830bacdac0573538c5fa13223e0278b19ca88c8abc5b16d2c88d65265b7174918972db6f582aa01642bee94df6618532c88bd30f58d48485e750d0dd993f50e9748a0e1f37ac89dbf068a06c75c91ea3899d497f3bb0d9030a81ae7451a4fe65c1703db16554c4b4eda75af95637aec509fc7e0c333039bd5dff79a34d0639e50c7fc58a3f0e08f797ac134f86de360de85745a6cf6489faebc79be59852441f30ed429e8df27d3355302c225ca3978b2ca446a78d60689b6fa2bacd2c1b7142bb5c7f992e1cbd3d1602fd0822b4ddce8d1a65d6e25c464c9aa8d9366a68e2aef51efa26831056cc63256c8504c1245437c88554eebf7ad3d446024088a5096bc8796b67ced403bb0f626ed3e9655b6fa85e454c591e2e63109ade81c4554548d63bc57944bb1b909389e38b3867262a6cc5c2b08e0391b4dff6203503b8d0bb04a6f8e95d49775d7375cf27e9fa5ccf9b6af4ab442e901cc8392137310868ae529ac5e1ef4828dd34b8a9acd2ba9c15257651c93ddea407ee3eb6ef7fb48aaff5c2742cb3c991581a1d783c019ffaea89289a0390d0d78b29bf9fe46bb5b8a8e8ce1641cb028d5b365a7052af0c65047af7f904aa405a86163dc6f1bc1c367035810e14cadcfe3527d2d6f9cb5ae23a9d2d0025e7f7e6e969e702d4b8d22c11c089d9805d8e999a4ef0a4df9438fea6d9cbb57390d3f52f93c32e74abd099d54b2c9e63d549ab4da8a39ece9c17698976ef6e559dd4a07203980dd7ce77ca365dbb963466056e3267200c3121887d60172824b6784bb1a8a244c457f5e62e30162c780c503566e003f7cca876bc28da40d4f42b74842be1e3a54559d4ba63f63ebc5209fb9ea88181c9443ffbe33e64fd151ef89cf2a4acfe7fc84342d7b8e449c33d19a8525774727645a4ce00abc6228b8e9c6bb9cd3a0987ea8a6a0291bf4d2693803c3978a611b75bcf704a7121f8998fb4f5deb0d534d587375c2094f89809215b7cc18a82a6ae348af8d930db27e11e4a2b78d9ca59ddc20807f4e0a30e9cec115da8a46386dc2649a1dcc3566ff626fdf0f4d3de0d44a59f1493a5fa0632a048c5a115c351b0ad9dee68971dbad5825ec626ba2212d3142e85a5cee2c29e49b49e98c2dad3d304d0b1caa3266ce2272d0873c63dc07024965b6e1c7fc239df85da0cc48fded274fbd5aef8c888730e70eb514a50d17ec5faaada4cfe1f4bdb10a9978e147ec48e8eda7bba81d529b186fdde071645c76353f3e2fb7b943d24a6b208657d880d5473d05b373ecdace1d646504e101e12cb89fb14ba04587e201b10b691103a23c1b2c5b5d952d8174a65677e5178228e610b0eb178b8bfe58aa7f575b22363932dc792ef7aa12110cf8b8dcaa0e7bab955c1e018eeb3fc56dc89701906f5c0158f2bbdb679103e87d53d28c1da5d6c17cfb9bbc6afa738c3aed894d4d55b76aa7c0d39b9b1ffea944f87985f51ecd535c80dc162c5b646b676b93ee219f7831d6f3a9eb548d6110753bf4ed2ffab3eb6875ba4f98a84ab40cc1d35ec509f4505ed16911131c8a5aec0bf3c8c5bbca5ae62a219d723e05917b75de38b4567a643368b41ab0e96feb5b4bf2c30b7bfae86e7786e2118be463a40dcbd4f2cee5c5a8730ec1362eeb570c0b8a877851454ab8de794a21d3802f1ed5b6a16b662d3a312486d3b5b19be9c36cc71306872c61dec9a79c5932e4f3974d7d70ca5624c0c5c469cf4600a4e80149a1ea22cc214c67dac6857d5301815817adbfe7b76ea8fbd9c4f3a987aa62008cbd12b0397f5fc2ecc3d29fdf1e4d6acedb5adbcc7965eb96e46fd60b433163d5e064421fb18330f85063ab1019038558f600fcd33114c59af939fa8a0471062237b2e0892b30b10f9c5231ea1e08f477d0e25dcba5214954db14e111b6649961175ae6aac9a1b22944776fba28b556c55506aba2d891776f59537a4d9451ed3ba2a1a5064d01c8c66fbc499a34d12653b34db982c5fe6c487176c7404defc3f35300b271b596fafc3e22660558b87cdbf4d99d8563c44c54f39403cf6b3ed6e433d730ccd03c927bfa314072f05ba9c3b98e3e50b3804c41156196ca75fd3344882f977d7f69a78df63b04ce7ea5263f94d0094eb48b50e9291cbdd02fa6827862446156bd3a8171ec67442114e2699a88cd3e0c04ef18133610d0927e613d9c18714554b14695ed527ac4daab2362f2413adc6cca1ade5917de041879b4abfce5f6a3a75a6061c0512e1a11ac855c07008e2d58318fa5df2c3ad10834392b3d3508e55632bc1928ce09d9146436827028acc0f16d973ac96804226882ab9a65131159542e54bf38c3d3d49f8b62c4875e53571e2573391d39bb9f66eb67c070e328db17848083b4314da1762336b1950b031d76d91e85751b915cd9600ea740f621e8aa958b184201cca54ecd33e2367539d9dc31a1c2dc818350b0213b3d6ef7ef431e574475171d6810ff73e8c9ff2c9c207a24093b74052bfe25141c9e7db9b47fb39a7576a616c6199865ee5db3a68e2c4a2fd1554be7258f9c59c43d189e9922e1c58169601639c391d941ecbae598aa7405c14625f52794fa091a5a7b6c18e784731bf4e521a4a75d72cbdccf382a39cc4a71edf202cd3481226488da5850d17ece5bd487eaab9d5b0ad3a476fbf3820654f523336a32f5eb3bea8a69b142777f7da288070a640d6a3f1f564e1d88d32244164447d8a54c0033bf0c8b5aa0c5a30ebfe2110c2229fc4db60e2d20e16e209b3dc1fa2b97952a5e41e7d2674462aa222e95f0a28823e87720af55a2a7c74a5b1f280f194d1d688c7e785465f5c7c1b345845b4d252475e6b0f644f659946fcb20bf4277fa4edd05089018a54a9372d21c29da3ca6fa8d4a8baaa03e930fdc8440ea011a642e436d9da07731d70881da5a72f4157f9712df3684402670e523fd592ce14f942cb4c861d1d6b51efb370f3a58e4ab2212d008e67503ace59b15183bf49b084afd2263d95ec5209e35e2068dc2a143dded95ad8a65f9cb92f8c96165c6229217cb6ae2619966f6822d7e87aeb206230ba2676c7d0fa11c3fc42d453d1737cbc1c131700d3cf6f551562ceb245307bf4a811823ca4becb2d88dab3b37bf784162d21171ba9334e8d1ae1da7b8c819381890875c6b87b890cfab660caa82460592cb5285c22cc4be9ee97971df94372c2b4bc6685cf59d35ad3bd825d2410b373b45a07b3bb45ae82cf0d43580b9451b3a9a855dd02e5a624aec81845c9768490d38d98fce4e3bb95c7645c2f90f60f2dddff90e64bcd2115b343c83a14df53c02c6aa0514efe2662dc734c39ad66581841e8d98dc273235ddbcae3b7b13992baec23299abdcd0750e7742315bb1be9423dd9dc4fa308d39b04bffef0e2009438292b16a95f07d5a5449456d204444146f262e4ad71d23874cde51a3aeef5a17473bda4bbd88ba6727e0ff99e765409e27510968fe398b8162ce0c9464b61769410e354406e8d0a016e828c844bc7f2e2740595381aa294c384f878112d6da9727ed5199b5e8ce3ed0eb630fd8104210a326fd91fc2b1214b69a40adf89a64225dc975c5e9852e7e92dd42f7949b57d3a7050aeec7f9fd86fb600a4faec1cb1e3b3072f1d7bdc16b6cbe6c6e660f9f6d5f6b16cbed4110f819b3bbb3477bab96bc999ad69f02068b0be5d39503aeca3683cf4bf7f05dcca398e46b30a073af66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
