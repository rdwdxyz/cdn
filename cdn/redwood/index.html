<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"418e825f035ba19de159960bbb771dc4b88bb953edf0e7a5262fa92350a4033fa5ca0fe7afdb6caf38ed6bcc4f872db667fef0767d1ab6089391fb5d7e0d69a1c216e53f8eacbbbe94b2f2f5ae9b7a5e792d530efddaa35931d31c9b0e4468c3edc1984be36fd425e5339639367229e2fb45c91918bb8f8720b395ad3a10fb981e29f7214b5e7c1583bfb19ed9e24619e891925c5da6713f63f15ef4a3c548058fe50586e2aae84ed2368299fbfe9bd55177bc0133b5f37bd0a8c918ba61f2b3e4d233e5a32a6fab9212bed65fa31c146b994a6ba8c808faf7a15cd6221758832a2039420e7b512d97702713955230ac365bc88575b94aa7e9bc38efb419c9cee8ceba74900cda825f43d7a4d68b96a52e309131c3d3605f5ea207203f50055a2b9a48f876d35c1bf205f5ce1f6930ac19ede7313f3f418aec2bd7bfa07f34f9d14f1a22dcf2579046138566a6d285e9818a79bc1f9ce0de4c120c11e67b23299bdc6c91f1e9fd1c40533228c357f102df9325c0695ed556161cd0ce15c917f79bce21416fbb908e2816c74850dd16996c778a0aac301970fdfd0d7cbb3d8d934413bdec90c7d7a3c6ffee617704f218b7fbe7b573f94670c3cb9ec9e7d582c3b0d9088ff882e92362764131e32c601329087faafaeed8dd82af6f8381ceb8bc8de37cf94c9bbda6d686f23d844f76d00575f50c0c4aee3cae5c7bc4195533c559c83304e3ef020022c95bc7719ac16578546450263dd6f12de2803a01bd8ca65aaf4b333bebda7376cc1b82476190d933de5f779a4e4438141a1b09c0a7c3f5026b2aa5de56b7c620886a8030ed218ac080be5d7c9598a833a7e1aa4e2476a6bd6f10feb31bdea5a81f4dff4524201abbbfee70e6e98d8ea735cd9a9f76a331bc87573832ae6a15f99de864bf0243ac740fac3a69ad6304e6688661ee64c056fdc1480f8cfa53fd2daec799e1e4d34e5f50c55933fc2a7482d37a1f695b46a9f830808b8c21b663654cf075b31e718d2dd0ac33e68a6e43ada35ff9a60f384996cca7225d7cdc7708db95055f4f2f5c6adbf13377c30487c03523ecfa7b0b688445a1e10685b7b89def973893d005563940b94bac296d39fe54b601c5df154380fbfca44d77555818c39b79506a5fbc48d54116ab35c3dca9f7353ea1084221fda5e182269a6c7a7ccfb8d862a1236cf6b8072c6e29d77fedaf3bc27876214e96619c28aac81767ab08ce4c1a940d012169da5bfc4baf339397de67536dd0f59aa2f05953c69e2e943c661ec2486b54acd2aa75441b9de7cad2d5bee4110961672528082938e535bc26d3cfdd75977a3bdf531d4116d3bc0196ee46c589a49a11fbac26183179c2dea92fc01537c11ffc7a09043ad814fb754674ef8b956b5f5e61cf785a17de07fcab8778dc46be1bc3e788e38d5c5f2197b0bc0774286a4f4dc6dbeb82975d9cdc0d1af0c9a2a1ef218f9597d3ef828762168168bafe233048ed95f6f0a2abb1f6345ea34e6f38196a4d0600d3c86c72de6d31229b5b6d6792a5e904aa8f4720f3ced0d76b1ca24b0973bd5e8695e1bc70fd585adf2bf933615b95ca61994c1b4b92659800f09202ce332a58c0b9baa456ad4461b30c4e28edbd4f952c6f2be06f0a1e5562e6e5d0fc5b8321dc56a483f8f68d48955b6c85802b1222388c5e2c4c3e574976a80d987c89c3841f7f6cd897f18c7acc65419b351cfc9e9db50f9a744f870dbc3823d9e1ca9b9101e4e85ebe72ca463d478609707918e037a8ffb7b63fcb306e98dda523c7051a1c0a9cc5502c3fbfb4d59e66f9ab4a6684fac7fe362779e5b30832483ba9b597dcb2e2c7a8af9dfb697922273dfb127280df546dd22ec284b3e7b57337d8fe81db9010df7e875201c9ab4ce27267ec9bfcb45f293296f69e578611f6906f5b66dd314ebe2974f3641edea2eca4664e501459102894785dd3554a2f2e77cac6a13bf30c7ef62f5abf66d09abc81c27863ffe1b910ade0f431bdb17aafdf0a7e5acd1cfcbf7f2a14285b70aeadfb3aadb581858f4a264fab70adb94d096748cc338ac676d58ef67d40272dc1eed655dfd8ab9091f246bbc6cfdddfd7a39af549f2bbfbff5a51a2da9f3dc8a4fe7b73c03c381bbeb2835b870a24a9601635b4183992ec8f59c7cd5c598d870a9a32cbc0e5b04cf80f622c78100a43e4a60b012cb3eadcdc52bd4848386171b683b3f4a6c7259f9e9fb4771e5b6f5de498d5fd3dda65c1a9597b7cfc3da26808172a54aafc9e443ef1ecaeb3c1ed7e2a7167593a2618657ef4909faca4e38765c3a6128125d652bf29f56838dab2c4a1f3309b6a1946e67f99afa8f91975dda3dfe414495ea101ac79955e729d1f1b156875942a098f762c8bfbe4eaa555505796d5a819ba43cf1cf91eeb9a4d90a53b42501c64a3b35760935ed71d04c76c0d5788bdfe795b16649171cbc1f3ed46d7b533c887e953e517100bce23e0abc63ba7e946ae858934c86b828db22de421c69e0284c745690c0fe2b94fc242204bf7b4a7d9602e032b5cf036bf7b29276bd15a19663df1012b484898943dc2ea492686088ee53308d2d2d06a9e270d5b41de5acad57d321c8bae07810e852531eb8bc0bb9873dffa3e04c2d13e47cc98c391549963fe91d27750d4749a308f65bfd91859c629f25f30d3e59cf8ebcc84cb7aa9a16414cf34f2b6e3914b64a2fc1d5bdafd7bbe5e5db536b3d84a279c2b9c2215b6c96ba34f594d560822dba70c784674fdcba7397bb07560c070571b89f163ab917a663e471011f7c88747296ca97ccee0b4efcd5fbd72da62845533e91cb0fd62b623c0f7c5317bef468cba18035b4bd0635441d72331814b4716a420291e78eddad82534463945aef8244aa80a46bd68a6711f2eb836ec294c80fbca8a07035f28d346b0e7a1d7690ae79978fdaaa3017eb862ff52380a26910cd6825ef61ed12ad48aba5664591f6828da25a0397e1f7f8b53092f9637f706a797a1bab712c5b55d60e610aaf304c941248d248734e81027476d8ccdf57cdeb2e230d8d96a04c8e7f209ca0847b225813b43eb55b61a94d089ceef67ec958fc7af28c54891ac7fd78167074bdee45e26e995eb1b094c9fd2e21c1e320869f442158b98e9f3a1e48faf5b47068ff8158bee769b2a35285423f86c9a5ae49762b9d5f153387d7f2861ed5cca3e07aedd80dad45ddeaa6a07e6ef53f14fd21ff5ee19ec9c8c18e5b172054015f0b2d3522274d6b19caaf12371a1fe6f8fc1a56e96d02f7b24b32e27d576fe261d580f7035e7c13b654fd042565d89b384006183c8c2d5b9bdafd8b93e1c9481547f9c60bc602acea23cc4d3b517610a90bf23e29811d78d511b9593de5707e3b8e63ce5cc8bc3fbc9fd1cbaf32e8cc829933c10859b5609cf3ca838e7a61133d862494a04a235674ec36f7a9399662ca56dfdb45d5cdf29f5e990350f3f65c892563064eb4cac00bf189a2e861accca10f2fadf05530be48ae6639510ae444679671f0e13e6ee06f85e843a2a7f26ba98719532b18225a60a85423ac9364ab96c03f68cda569e50ae87bd8e7d3fed4b25023ff584875f57be90164134897241baa6baa1120c41e1fd592c788aa86b41dcee613f27a2933be29a7219e3ec439509a24a38d1539a2cb5645fcf05fef184799cc2ce1c9beda2d9b69267a5777f5589a9ed70e72347836179e22f0291e8336ea3330d63073ac8f322cc118d90eb82dbcab2478cfdceaba05e1ba784407ba037d09184fdf48a29363353af1bc4175316b0175961b9711e78abf9952f10774785e733803882424db48bcfd5e3f014763ed18fbea9d76a0da0be8b3cfb4872c5041f19ca4c26cd06507866b3158e4826646714ac9370bd3e7c727340504930668d3860dea6fcac02e161421b72974eac4e42d28895438a309343e73af70c3f02cb4dc2eb122f9f42c32e1f94a917df49b01fca145014a25d0e6e7b87eb9d3c51e508dc2cb6db877b2f196b81be2ff6dbf5d4cc203ff5c1fe375709460ffed8db6960d2c6300f4ac730db8692a9b8fc9e7191a13f98b42443a452dcec2774708f01de1c62220179b87cb6f6359445475e30b751540b88d7f5dee3b251e6e0e05dd7de5416fd7be51926178d9db68091c7597af093d40b75068aaeb3be49fec552717bc074d082e8c433662a627f664510dbb64736a44ca55f1c3fec37d1268165aabe2a7ad98c0187d05b3133ce3b36dd89ed1b1d7695060fd58858559ad11ea4e7de269a15f9f6995691fdfb9542f282ea3ef92948521399d65b71abf1767ce5d55ef43dad269bac626b52120af7b1caf86846b4f656756f026e1c6ba43c98b7dab1722ddcc8204a066c31258bf1f728d14597d9289c38c741aec8a1753a3bf38c516a70364fbab51fa147bf265f030abc90abb957b34a6430b41521eb309613b8885c920032a888a45f959d4b7b2891032ba5e556c49af5b558c8920a174201dcd69d41b5554aa7a54d4cb24b002389da623034e4ea09f05fda5ea30b0c7b6d8106cb59bae55db7d51ed50907c4eaf7d746c7724b2c0c8a85bb340d1528b846ed9eec783e7eab9565e5925b3bd12c81f6efe419a330cd0c171cc61de1575bcb41e2426f0eaf358de4e2a2ca9912ec0ecb0c5a67ec349d266fdbedd13c06779c426407c1b30a05b10222c9b9bef2164a67a253fc1daf790299574dd507e58710bb2711b481060074cd64d283c775401386136632204e58566039fa621e6330a67f5db6e06783e442a1b6e10e8442cb1f445564e54ffbd1f3110d4898ca2a3f2702aaee54b447a4f3b554606fd39800bc6ad8e93eed2ec3e5664125558bb5e83ad39bf603b305f64dfadb79203f04e572022d15baa0a8e574aa74273e502ef8aaf525c70ad2a6faf1947c4e3f234d4064b40ecd00e8a83e850977b12d8de60bf2630e5f42187092b91ba563aba776a5ff5548421a2f14d55a33339c712094edf018f35f845c3a50398d9fd820dbd52f53868adfb541f9966ca64faee930831d7bc2c38c07b761606e4e4e8076362305f46ba55dc2320e009209c00c04f94b3360280a6c0f2cc9b2263365a150d18aff282e4fd54442faf0d15b1ba0751272b4f658997f1c0323406c6c8f83f7e2764c4d13003a44658b280bcb5c69f26480acd5be6b18cb2cc706ca841c9430b0ad747c57aa2c48ec52ba499a05cebc30ca4a9f001a5faee8f43856a050abc1b3f80d9856e574cd6f46da84a2c7f57ae45b339bef8c36cda449ccc0a8b3a220a016ec48b6a241e8b8cbeb48eec15569f2246a455527c2cb6a02872994ba3323c4b64e8673531e417c195cee2092a506d60cded2eedbd22b55dd042671e3bb2157c787e38d7bc0dc67c2bcb181c0448d71c8a8ca959b169143fda07f90c5c7a89ebb8e0751b6b05ffb3e6df9fa8576e8cbfa4c6bc25cb9997ff9dc3b1c76aecdca6a76c206c09d72fa2bb10c5a176f2f4967022d1f3c31ed13f051acffc6f6e489a41cdf004919286c62b81173d02043634869c4f724653f10dd3dd2e1cfab694cd629e0f3616486384ed82e393da5f91e1bc82333a06ca33c5406fd6943403a2c813214f41072a1683f59b2bda921f619296cf5ff43495d5186ed80bea8f8738f487f3cbb90ea4b6d76cf42cd1dcda3ea8952f5b171701ee92bd0c36523968aaa4c9d009a6cd0667a78f73a10a178cfb7a29ca0cf9be0ddb45a14b4df46bc650e52beb714f4f78b3254f503157e4b582d024ce7a272762c35a40da2d26f7e714b655c8abdc952e431577eb62bbe18c342b3e22f44a01d84fa46727d904d9e09d3690662e0dd6d3b3faa1ca6a62334bd79c76d15a925d7a296682f3d9b62141975e420291deeebf13a17533802522ff8a88a6607809db7d16ab7d5728e28c7ef1ce1928e305fc10fad6ef63765dae825546e001f9b24e355ee275b1439858e4bb7ec42ac3a4812609a7c64eca5a900028cdcbf92393dc379053731b128243fddf46043a937c676545c98b9ea07ca5a101684b181c0b064c8e806f44680fd73d441856b683d323e977b2013dbd0845e10aef4147642aa7e4caa43edb3b4737520e0c90f1aa8d0891f99f8b22b0ec44137e968008751dde622527c14f981a5c21e44a5cfe424a830291d5803e688d84f91a7957174db3f373425df7d9ce1f7ebfe75f6111314e5ccb3fa61b1592039c1c25ca5419f3fd5606b641d95396d66d754f281567109ca41035071494f11f1bbb49302bc3097ee251e1e63180d2b84102a1a2ba900fc4d6ca913bd0d041a4d59a3552d19261844c4aa2727602bbd55f7a027f4c169966567e06241bb2b7a370c3a154efbd20193f62f830855d1b2982bcabaafbc4c5787ea6497d0e6c5b8d58f5e67e48a3c120b3261f2f9d6a8e792b4043d50d359223c9e83f108d84b2254f630b65c18c64816b386eb2cca0946d6d2464dd80fc0f17325ecf724e32e0d0f5cc6ed62201606933f6bc67bbdb3f7223ab1db1af673062fd83208143d1d5d29f65d0908b31e9b671212c9ea434d3da3f8a11c88f96c33172455cfde29d5f56d4d067f4e9f739abe233ebb52fb2c1f397c3793cc19b2347ad2580cbbadc5ed789d8e5547a587ba0e754660576425ce89caec8ed4d1bd27a43f7137689ed9caf7ae966d91971379a921836181ee6903375ed84bd52b5139c78dc64ac712e7984cadd87f10810f5a0a5fea3f65823d39b06bbaccb38fb58a8dd7524ed0492c83c1d9c024478f54822eb61a3bcb7beb8bcabe4950ee73187a004081d5eb8a3478ce5c1661b02f7a939ed8e1cbba5ca47d86fc9b6417bce284cb474f066dc16d624e61c681bcfa776cb8c75e209939b4b183491a0b0cf761b5ec6383d3597100e67cce37da6e8e3326cf6d4134afcdc84a77c435510b4bbecc7002423e1416fe78a3fc9d4ab69f01091dc1ce262f117fa2241b572bf7142424893d07fcb24c948bfb6aba786453ac71a68ef0a191922a8884393c1cd52355b06a953f845378ce0613083a39dd2d78e219c5ddd90ac7a2a76d7e4ba0384f2af04879158d4ed05e815bee731715f92ad687ebd1e86cce7894227325c0bf6eb40a2da06adf97e9f38a0ee0491e1e23fbe9ed4a0062cd51a207ae9481c05345d1e233071ef628d0456b86bf94e5ee3a10996b8f42c824ecb3f66ff82c7675756ea116c1ecb19f51bff2903e827f3093e0d2d048830484dfe8e88a0d5f63394783a1d26cf26bb5001b445559a191b2f4db63644de57a7df05c0bdb3bcd27fc42b03f27e3df95af4381eaf73b3054c91cf8e2c4b77457570c0fa6da969e409b3a3f59e656ac85211af2d97870ba5626e11bbca81eb144db9bde69ba07216ce97a741867440bbf83f2656b773b4740238beef9ac5e212a3ee13eeeacc61fad7a74ec33332e85a14a676d25fa0a31973e80caecc1161f029c6163728e6c2da4269ed4e6a024dd3952f010c137a6e14b202f637f5615dec0353d2a9add7467f0059c8141d2f9df932679df8335692c3f663bad5cbfa88e93ae5b05b944f6a23600db0cb27f72029b1560a3abb6903c49a32da5909a7ad816b02202f0c2506b71e7f5cc15b7cd50cfe154a6426bf8a8d75a14687c131626e185ac93edecad03c9711d293cf434f1c6ea5babd44d757cc7b3ab90bf8d42ed1091928e1c8d0c1f7f20e02b1ab34119d8216da43ef16ab57aa78eb053c9e8f3aad2cf09f2a9fcaeca862c048017af126245468916f7df9bb5ffef00eee8fccbbf21d361db32cd38f29538380cd5d268b846aa8c1259074c271c3788da1b5f0220568a3eae197282f674662cdbc8a6ceaf59e8231dcacd55565702df319ad653b48b59a70a5290fdcb32e4d96454e34a04f5dfa52faf612dec200a01291bbfe2f7ff814316f4a48949e6b8bd7700c7c0c9913f359b41be616d60f6b42a53ed331de1fa0c5de6b648c97679a0ba09dfedc8d538ae7ab8d8eaf927af5830716ae5df940c5e15959c7415ed8186eded7a42b03fa0cfeaa58d929cd7244a4eb79483574a0e4e72f6af8785a6171386f5f78316098bbcb3b0acc2bf6395168d477d608369b578b74439edb619531626c869f5c9e99e690c2d6de7cc5d505588df5679c92567c899dc35dec49129542196e4f0c1c450af1ad2cd6952b3dac6215e14a0f13b5e6f05503acdac98bc99e66b76697bcaad64923fed235e9808b2bc4951964ddf83e8af76536b89038b6363b2babd0c169d10c1df1baf44ae50afdf059160e4c5c638be3a314383bdd568a8353622fa55235ec050cc2ab7965f405659048bdd72348255fb04e962f3399695cd1257807e9a07c14096e1ec9e4b12e4d086f091b9226ef2ea2221d876bce1e228137e03ddad9c37cd59415146ae280d49f635adc0c388bdef3043aba968db769f1d84dc6068fea2256ec383f13d50e65460163430433a44c61a09340ab3980b89084ba0a736c69da04be1da1f59092ff60d8e2ef574a23f9c60b91f1b7dc86022832db53ce3a0891455d8bbf621af464b33e95a3de6ba00fe07a02f327b2810822a69be719d6bc7a6b93383e0918130562ed834a1e0f91d1648607eda867764e5c6b23e28d31a2f04f9d121ed177388f1e3954e9c71e7844010660520331784cee047a8a9a54906a4d8c8138a7b1d72754082730fe0bcad30fee1024e2f2aec0f93c119483ecb7d1c8972cc76e99c01f303e6bb3e1d9f14e4d6c3198c11eb910478dcb3d70ab92d2e3df9a6a705c4142995432c405e075589be5b7b0b0c745754d670dc3f88f8b603cb16ea13269809faf98e2708343ac2670680a06df4f6ccd1dc7ba7e6d6ca73fb1e1f13d6b819db49183f2dc0a84943a7af945f2464e234667015ac085825e006d6041cb876192e1ba6e6b62389c19429bdb0411b4927315fc7361f266539e748574b8a8d397bbfbe884b4cef168a3bb159d37ce7a139f6c37b34d8e422cc8d4078f0d54aa87e5bd794f3c7f491110c5e76722769565e197d0a9b6deed3e920e956272aa7653a6b952a3992e6c72040bf1ad093abfd959cae9ab6f346b4ad3c7b94ef8e84cda9ed08868825c64f5c6c27db8223768a0b32e09a7e0abe37678659f92a7d717260d5c365ed2d226d8528ddc7e9fd3ecf626858edd6c1f31b127300634319ccb4b849e6eaf82f09da97c9bda9b0618c275794f6b5ca8172ac81a7993c1c2e110b21fa928398a795e6d18a00267780d012ecf0476cb38db4847aad23cfbc5227ca539f9db425a9ba01824c9f2089d00f3ed28877eaf49b9a62b6e08c64e02c6f46f707e02c8c7c5e5f006611427188b1c5fd64fd092843e0c5ebd6a3a313df2bc6b6942b5f0747c81387635294684b3fece6a0399655e465c1214d5311b9f32ff5dea72890b083196c61033c5806c3497422de3904780181e7cedd00cad4f6c0aac4fa89cbd4249f28dc15bf84fa0d0f75249aabdd3b4b18b21c5bc55a3e71bb135a33644eb50c0d56b07b5faefe77a43321cd316ec6de9f379504e49fe219f1732267e54f1f2414c045abbb89bd437e0f73c72a03f722e127017a9ec9aca7e0f6a1a660954a8e939129cd03e15dce43230f91d146d4e891217eeceebf636950b9a77d2d265def82ba2d4a9a9ec796a470f1e4afcf83cc39f93a3692d6cbf0e20ee56a87e80a5111008035efcfbef7d01db46fd375f5810922bd7a7548aa7637a5b03de61899ea42b9077ffdf5072efed91df4b56b0df9fc9e3118c9030d7e3366fafd3953419553b679c5a5acf8c31fa825dcc60bbb4713659602e5f43a05a0dca3bf81141413d5fb7318cfcdadce5ecda72b736342d82613650b8c82a3e7a57731b0296b1dbfc1814b72881d709a1148bc62bfd526f1429e9a388fc7b4e6035daa026b041f94ca96dcd9ec4e719ac60c3f1a68a3db3b88d12632990d57ae84583ab10c3c3541bc9788f9dddc7be9e33f6dbc2e51a0d71963a620cbd1fc805ea0268fb9a8b0ec4e9f5ddca484934138bcdf38dcfcb2a0786f3bb9e19d3f475eb9b655b9261606c76032b177991ebc53293b63397388b9fb9305ff8b02088f0e5cd099c6be70e6baed448549b48af2f2031f24690a0b78040a9bf48f7bc4c6230f8416609d76ba12d1a90d2cae3e9dd86448d18ebc4597d39d4b5f845a4dc2663b334307e0eb5dcd9eca2234de261072f799eb276e7a5a36ee48d161f9596efa222db2abbb82852af7720ddb1ad6ad2f4452ab3d15442101555762fb7f2bee1bc66e590c782f5dd157cb283f0fe754ca0feb47f7284e7406c3397ce526c4d4caaea51089e4131505bf43e920de831448afa0ef74dfabea055901f2f743c7ce44d61f956498a91ea367f21ccb45e39b7ec71fba8f0463dff4bcb6d29f9b308f7585501bf5c18f469f9267648ff04bd819fd4423816ff4d28781dfb621f64a176630e090b25101e95804c99b684e74ea0b88b54904e52744d015376c54c95843ee68ea12fe48495e7ece00797e434692ba89503053f24784c5488e7ff5d701bbddaaf7ffe4a137630038a726ae85881d70e0467f48b7b23c436a8a10d56c61ba9eaba5d1bcbca7c12d8f8a8cac1adf6f338f79484e8b26074742be1c20ce4468d1c38f0bd2e915ac0dab22b4adcd50906bdb831ad973156bc816c8d61290d36c438205f9a185437da5a041bd007ef688e4f56777b85f44f50c0a4b4da571bdb1396ad79f1652aaa13ee12fe5d15bd53d79acc6a9d30cbe5c501aa14bc3177e2cf20a628e517fa5dc6d8fc6ca854dc1cebfab8f73f275030468e447aec10c9420624c18ae2dc7601d09d0d3652ec44bceba0d66b7119d5bb5a821aeb1de10c8e35fad4e4e7cbd74b98a203af0c895ca573ae589ab8562189265298efb53576b0bfcb8634b7dd451d7670e6b0a6470c6e01209d5bad14ab8a7b4dba3d22e42ec74defca0a87c6ed946d2619a8d30ab093cff25f887103767927033d9d98cd6a5763b4c322502b298864f4ca1599abf943bde132db355b072fa9ccdaddbef5fc2b7460a669f3cd56985acccb45b3a3048df2faf0552027c6fb7d5883ad67b48c78614db3d07da69356f48a139224792b1834617fa5ddf3f6c840262694a41659848e6c89dcfb08a371d6111d2c930a379b6496c6d8118c50d928a174181b5e1978c8ee5e94beb5696dbe214aa24e731589d8f3c4c3e0611442123cb080d486e11998d3a55e4bff6b861c90ecd5aa5e7866356d632ede1f78546b68f0cdee728e3e49093aaa62f5123d7e4741cf8f437872064e61e8756fe35ff2abbc21862e92724911c24ac478fd60bacb33205fb1914971d7695da40d133d9873517de088635be0e8173de46ac714fa61c426fcbd055476b858e1da8c6d7f88f5e567430f3600fa58bdd5618e16ac4851eac99df4d3e8207e73cf88d4d8f21f58558a83a0c449afeb0451cf263a09bee7343fd09cb86b407198d09ffd96aa609b43d4448d235de9782cd1c462a8808e51a75ddf70fbd489f005924fb4a768d0dfe7d414ffed7563c97085a4c27bec01de2b706ef6145a4b7ea780b38468153bcfda9000296f243ed408ab801e424eac4152e9a9480e50e37a84a26ae18ae95d76085aa18206e818ae9db77c661eb2a2a2bef982870f008e7e311d1857e5d58870d2cdf2f1c6025af847f6d92a1d01fb31c69468c86ca556ef0161bb3ea3f851ac035186b31c47181151092f61274e7a59a67348f089859943382d2237ca7636bd0545de388aaad5cafa0a154a63b27e163b116b9abb8ec825f965129b9f90e4f9909c71ee76763d2261acca1e80aabf6edc275f62fa9747664ebae9796f3258d7aeaf016494b72d9d660fa6c12e2ab7d8e18ff7329396bb3240dc9f6c4a8f7948ee3ecf590868e4f6a23f3ef31e10fe0f7b19f3a72fd04b5a54202c0906bcf2c1175c3b25e4d4118d26d80a02c379c11dcffb8bad3e12f137684dae2773e516a6db32cc3872f2f90ae25e75701cf35a00fa335cf60198a2d2b67ecb6130fdc95b147b10b2a3da746cd5aa0e1d3c2489337e6c0922f2b998c6dcc14086276f310068c86667dac5d6d6e51e555125369d3daf14ec899193003e3b983e32481e90e32799a3d95bf17f10a148523675fed525f530d271c65024f0cf9ee8e680834027b28742ace9fe129a44d9465e6b8a2aa25e838605345b3663bf9f597e0b2d870e2edf99f5e3b02aad697761d08df0a95d78ef9616dff0ac55e0194df41190a35d32b98e84f9f9d73cad222cd8d70c72ea33ea6ed554d7dd93dc3c5afd1554e4cfbcefbe4c5d83d0107aec67a0076a93fe2ca2733ca7317ddeb86a60544d780fed6f498d940076df0be64d3fa6fd7cb9740afbb286c4d0fa5e605636e5567c3b66a2401ab867d9811655ef3ac8e5c855dc8d491fc121a5a80f46f7eea2ec84193173c33d84a4f9f25ccea8ac5c90b11c7980163c065ad899879a7767840a19e075ae6800a0c4f629eab7fadcbcde2945e858a6d6651d5eb8d5a101d36308ddfedd55d7c16491b5ce1edc4ad844decebddfa6133dfa3244658c3a670550494cfa724fb48b0d7043a773315de71b0e9528393e940e075b9168b4ea874049ed2c308baf39c245969d2f8ce489fe55b3ab39126e693545db545a2223b74973deaccec1f1dbb29884a5c4537676cdf18001df6aa60bc4fc11e289d9b80cecbe041483b7d70768fb4c1565a8ad17a2aa58ae219bd197fb6a36a66f1bcbc0dd087023bc31ee6ca6acc3edc9fbd926aa8d07aed254002385040c78a14ad5f79ff48a835c4a61aa98eaf509aac0fca36fedd2e06645ef73b0d82e3f7ba52d093fc6519c723e8d97d8bf6f06b0db80b4a2cb7ce417afc27fbb1d7814b5c7893d762433e84941c4ff665f31b57adf629d6d441b2a1f608578562aca0eb80c268c0334e5606b1cc3e4bd85fbbb579019c1c55aed3d3bbff1ad9acc6682d649a0e39483d8e0c1d0c7945718c33c091d9abf881b03aab6d737e0f49a7e1fddf1b98a0068505049f3b6b75a48248c12f73a844c2018f2215ec90bf2900bf024799847a2a85bc7a70e7913273a8ae472a2515b31ce21246805f4ee171f31826058732b7a6d7360ead95e172a02b13ae2d51639500ce1d94e784d65f29a740516958f2b5bba58ad84a0f20f78bdd32dabcb735398a531cbbc64b65abf7f7f97ebc8574adc2da6b84a9de675e6921da19434bed21e6922d2eb6c293308b6a04702918dc065cb8cc4e77c121437f7bc2e3cb346ffe6e559e9efdb6c4fe4c4f229f086052bc826aa205a5ac55a18facfa14787be3f528d31321328010f1313fc19f062f16f359ba7f74f21efdd42035990ce4ddcb43b03f578e1ea19fc171c6ace19b30f32b8fb521c56723f0665cf8c0504a36453f7c54c838c1938122230ea5c59432255820a32b70a5b49fb4702668b8dd1ac0fcf30c429dec7e8320a166de09a04d55c44eb1f4ddc1680f8c81b5c7a46a55bb46326ddebb9ea8c385f83a7f9b0e420f0e5fbb6502c5b82f0e84e25417a43f6cac8de6766eeb980d1b5f7c58b451ba1dacc4409e6a8c29edb3b7c134ebe743b396f5025a597be9d3d08d6c5cb4af5369dea8bfc5efcad8bc57ab8b3d694fc35f6234f14c52a67f4bdd43449e2873415f14ac458cad0452171c34e61fb3548c054e0d742b124704866b2b75da1eb91c4e8185231f0ac18b7c2e9542fb323ca6eb6226579a428f2ae8135c7c470a9904297805a8c2ab94c0f1cf0f7457ac8e3a4577beb75d6597c30f85bdafcc7f489ddcb3376c6ec1b351d75fc5bc7737ed43d0c1f7607132119324a9e46306b1faea4ef6578f4ee825f7af347d05d893bed724068675fa22f411ab51b5bc48f2166150111cec5078c4765322bbf527b8e2712036a80b061149f8c60952e1bda2f03523c7b22f8c020e51fab797a7aa70e67e0a402d78d601a0a40cbeb660260cf8cab73cae46bdc58ced2c17bdf4893db6a74d2b67462cbf16962ac5e4ee2c9a76a7c597cca3f756310d16fe71e75e9fe8c22dc381859fb1544e576de13258007e3358946ee866ccaf32e329300e6f2227920b71680f87c1adc3c499f78062d4fd2f097daab884c09da1cab988fedcead45632e34636518eb1eb0b92805f972e0572339baed57232c76b5783690d86652b1d032081be209997060dc7bb2244f30bb1a1ca620d5942a26bfe3b940df37688ba419e432a5bf50149ad70246728395d5657b4486e52c5d12d958d3a161d8e5272180dc79f6e16e1b9a4318f633d40839cf60a30564f3ff7d4f2a563c7777fe15c5108a8ea7b1a605125894bb568ae4b5a1c58ac6a9908d5ac5de6a6651acd66238157b345703d772398b94e47d84b92f39f0ab28636f8e64eb87894a9f291a7e84b565e0b5a6201d1f9faaa87a65acec7759f551ce2f34ef90d36821b2f648e6fb9758af643fc864bb3bf3b2e0ebaff03c461881258c8e818cd8daa4447e8a1a4f95e7dc7319b55a871238169653dcd257f94c923313e888530cbc330fda2327b514ee280c4c43b5f01ee86d0901988871a0a0c3c7187e9a9a69d7a9f7c1bb0aa2a9c72f300899c2fe4b4c6437fdbf6c85ec5ffa2cba7fcf22215db59cfb9ab776ffc4147b5e6115cfd358a5621b7879620c1e5ad41be6c052a290cdafdf8da7e1a9cded5b2e2a042b30508ab6bd6ed79dce4859c2ff97440c1d7432bcd1180de1d8de30d44cafa7f8c93c8210a50f287bf46f8cbb99dadcda4715d4c9707ababbb443aede93b429bd671330b31715ba3c688d11204e35343c755c50b53b8fbb6e761379fead22a7d9659a62bca6866e9522c4c0ed2b698316b0db6295968b127bcc66f6e8143bb34b7fa8e0b4ac332539ceaa3914a69171bb8d050914013a915c63b6a152ee700f4c3b17f6b73655b62cbdcd498f5d32db19407f9ab5c0e5fcdb1b4c2b1c28615cedc53f2b17f2cd3c6554ba834d771b8a25a88fd814c1ef4e54d6f21b458d3d8867d5ba34763516d5cbeb7f1c48e8d54043a355564fcfb264603df4b4d6724a2d656835f2d5fe9b5481d020271a79f610f06ff207efdd651ffb409e8ba94656e7b637febbbdf92bb4a72384074e48506f98f83cf3eedc243ebce59f0888db495bc562c8ef22fea2eed9140c8c43bda02a47a7e79983751916191cdc6682596c9aeaa7d8cfac25511a10e9c9d99ed126fb656230e2ef35f77efbde09538c04cc7027ed99ddc603d9d45e56ed3b46d6685da4b8a784fe23335ca5ca47a88a2cf6fbb47b00677f9cf3cbf41608d6bdef0de7499d744770f4c246e0c9f1292f5b8e7ca34cd510392ed2c654b05c3a03d4723121fd214a9b6562bc59ec4d3350e55a24e9f400625c5ba27bd37bd4001ef30abdf5c118d0dd46d79bd368934319638c0baf7e5b905d500afe260f7f5716114a09e0b17030607db42b45ad050a80c1558fd4299b6a71ebe6cda79090074bf232b3f25326f522b99cd5cde997b28b00cdb1e7ee7c6ca5a182dce496aef0ee76ddeb0ceb80d6987cc567bcc52894d143663a54d6df4f23f305e2ff0ee52f2bd4584b967417c199466b967f045709c7dfa06edc1b43f6576d92414612f04117d304b26e0da9e26629d670f9486febc62bc032878bf92e922505867b9fb8987e7018cf9505182685bd56c1b3cdf94f776a706fb79fea5c907b048761fda26b59b7a3ce577ace77f73b493522c9a56163d098a20ef59f0e22377c6c1ed13f52aec779609d3545b531dfa21df747f61d6eff95f06a39d4d2dbf96b13c5c161de3bdc88165b0775ea7ba52f060c6d01209c731d827440164215995b4ee48ccd75595cd81ace6399a66ff6cc71f5ad60f45dd12197b7f96a20e4c35a439df10ed0c8176a85aaa01a53d2289cb835d27a3fb15a6bcef51dfd2b611590690e4b133c1aee4c562efff7c5396e9667ffe67a4e1b6b75c4ae24e6fefdd8b98af59fa222a0e1f0e7d4e469fadd8c2c5684ec9fe014afda2021df3d6bc94e35bd3fb7e2e77669f2ca3531f7a71cd3626d1e7b8192214dd39e913b88b54058af29b82f1ce9214c7e41bf8070ae82d1576711ca0ac1e2aa1e01180b1dfbff21bc12cdb0756a0af004d7fb87fa066220625c751379a3f931a59e198acd9d7b0d2633121b93e152b700e1cb52f9731143d3adfe75f7c3b7fcca3a40f9ae0acdcf8457433d4ce6b79cd73794955c1c53fe6009b0aa961679c1265c8529e81771699f86c424b094cf3cb327fea355fd360c6a18f38f3fb29bc06a0c91f1bad9285c759d45dfc9291fe705953ac05643051ff0059cecbb3e05b3359163b532889db79c6fd773264e1916ce6c33f8df3dacef29931666278ae152ecd184d21fa083d60a60a05061453011c140bd264b150d3d96f6d21945a23737dd26560b7d60b62e2a7eff5415dd83de27267973bfa9800183a33623ed03c41ad6aa8951dda2e25e03a7cb62bc54140bef210b2935d9ea751d329c5ace89ceb55339fec481499304a7a144beaef1e34b11e58a7606fb937361527a3c59e84d190b6c1884f223f8f6a3365bb38d50c9bf5f16e876bf27905eed7fec5c94d0250451af2d1ebe0e386e3d88aa9ab46bae9d7614af1cbd130411987586d3f5321ed5f32318a045a385f91ccf2ae4af4c1be2d6b519409b27c12d67b0cc991c1da7ae0e9be0fb04a0a494be83fd9c41beb44133fc33e6337041a7bfc563d251bb716e9d5b8d28bf6f3e7a50b7191173a7372acc7bba5b0dc8f2ffae22d4a8859fc362dbb81ef3dfcb643ab908c9a8a70fc201d9e9daa1346a8d8846a6146a9b61116abe11b8a86ba488919cb0d177b3937d9aa2158f7098bd2a02891281f7a1ffc8c20ad70aeaba646158abb06c484dbe228a4c36091222ff1c413fab2b91bdbca5da4d50b890f782196c59340ca4821fe598de4db0e07b3698aec25d8c7f89e9308e851a476044a84144de03c1c9ae38619a891c1ea567a5a96b830f7255e00788db13c9f8e10c6fcf0bc741969556c1586b185c71e9d62ee1e581f4ffd00837fa4345367eda4d17c79c3131ca5c40a533e11259a3dede561f07e645593fca07c6e01bce1e06b99eb6560bda5f00734ed38c283b688c38598dca341a8effed85f5347c55920903cd2ac1d89b965176f312dd7160a0b342432c2ccd625eddc76b63f8758cd419b2a97aef6cc9aa918f8bc4465c99b1c23ae53caa753a1942cbf84d61bfb6e7b5d43cf49dba30c399230c77bf79218b07716f812e4c88f55e01f6f93ea3099cfe33c8c88ef547b61677591761a2fc55a45b11259d46637561b515df53842d8b3e0b21a1aafdd805d1b0803f9810f35fdc6b34af8419b80793144529711ee06f578bdfb8a76c1c7aa4c8dcc361860ccac31b0cee137e260077fe8f574c3b536d127f8a1ed01286dda1a20bf147b1476b8787a94be86de2df46ceeb90bf21e4157ce6e6fe6972cc91156737c918671530468c65d959c2c4b4d60c129ee89df84d0c7d0da44be801c7c97f4f8e91a28c34d8f9e72671d871135d418a44225f1768e3b93b509424da76c3684c57577d5f41de16cbdf826abece28ad515965f7251075b10e149c0d049239f2853ade048c27810cbe93545843f006fc5e5670f20097d14987c9fae02cc78e03484e03c73e242bf764a419279178eeaec0cf7e8d5e519d542337b6df5feb6760bc035bd229ab4fefe204ba6df2f36b5d8d1d2b4eee9b8d39c1571a4efabbc6987d4c90de7faffa57070249815380a06daaa0141b123daf78907171e93de4e38b248a996640c2aba2ae270f06978a4627fe55b5f6a09be3f117d8775faad4d89bee525f02463117ce0f8dd816abaec484790201076bf59ec55f5af582e3911ad7bb59876cfdd08426f6de95588c8ea4fe4f47e27eefe4d4a1a91c8eb78049993211f2ea873923102caf40870a468eebe5cda27019687b9b9bada47138dc5f0f145b0af5e38632804930b41c07517cd587aea9ed8a83805ea9d7c3f061ee124e37ab0e04674d214fdf2fc6201d3ac43c20f8f2fc3bd834af917fb9bb324b3b99232508ccea5932213de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
