<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f65d3336fbee1b6f7012e88e5b82e2c4b379ce4a0d6e668d7e1b79ab2608bb8b467bce45d8860be8fb0878e8541c90639303d4f76f4acbea07d0c2ac118e65e01ac6ebca25ee79aad66ad7f0a607b5d5161f9d815ed6d9f33340a4db8350fe4d99d6246ab73bb6df8c8280fa686f08767ac905bf86918e597dca7460b602beaad5285058bf42617062bea58cdbe565d53423969209b3524219484a3ce20c7b674e642812005b660f1ffc023f53b8be55e25fdca9fbe41c10913bb1d975ec926cbad5e123a085a1039df42c6edade43be48b0308eb926bd9f624dca4bfa7ef0ee3b4a4d9c86547af2216fecda1e34ba4094c9080560185fe2b3ad8fb66f70ec6ddb048ebd92822ca023f93a006314582e7c65dbfb28eb3d14afad73782119271edbb34f8d1fc8ee50ff41379275d1fc3e812cf53bf9d5ae0ae1495d179ced573a8515f3fe73ff9e49a3b96756013adbcc7ac7ea875535e68d90290bc6271fd378b7d37262110ed765d109ec27aea1ae18defc85b29f6005af709256518e3a8eec2852987753ca9ed9c16fad0996f2ffbfa5f0d4a2888aebd28179ac870abb5338149e45309d58847758e550ee5848df12d6c9a3af45c62e6a89e8688761a266c94b04a675dfff6e58c368c00d2ba661eb39b6d06787f2c024270ff04da8300092026f4db6fe7014d1f7628d4af61e067a76e9b04c7a0ea3f33819985481fab40b5ae9fddaeddb9ca7c36db3a8508f6c1618dbea478c1b9e2154a10f93b8c0f11c070147e59af6198dea4db14d760bd6fe044f704608cbd00cc8da29856452fa4892648a51814c1aeb3df1c8d147bce83593ba01cfa7e8f152e762e17d3703bee67cfb7d0199ed1571229b8550116d55b15ea84dda91bed169c89a37eac08dbf39cec4b3556806043d8d0a6a291d877f3198be760d56b54743085018aa3a43428e12ce9ddd7a99725229dea5d913139362b2b801ebb4b1ba10eae932dab3dab1fb870da43cf1025eb602094c59180379118ce5ff03f007908a69c7a419ad9ea554b222fbccceab383aeaf6aaf37666f2986031737f3cd556f0a48135f752c5109998cc921ca1220e2f704b5f2f85796365a833d013708765ab933f6f6dce74bdd97b83386fb52c548bda09d725fd688f3c7aa9f5a5e9621357dd7a25c247c14701e5bd1c154f33b026d3925e15e8a3ceea2713fdcd3425cf9f06f0ac32a569d6cd37f73075e5638f3f2d07fea9f70055f2d8482c3fd8005fce24ecc63aeed9373ea003fd4cac0d67453a464530a58f9cf51ce4623f5d18fb60be3f11829d57a5e610c8f828490e6556b4eda76d1969ae290765b3cfcd4c152a91e90ab8035d2ea8ec062780e61f3f5675a1f78223ffc77dfeac31a3b0497fc96d14c98eddfe5af8b7ac033b877c6678d775fce6a21a068cd1b3cf1c574449f20958ae06ef62b70842b9c7c83a70389948a25edc7f948fcbc9e9151671fff4c15c7398bd3a194a61b027088db2fa913f5e374c3cd34d6bca2951a7ed4e27cd55a9259ed92f25d4709dc4ca6ec9efb73cb85551b0a9d0a7091b9a0d0355f53e2bbd6f13baf6137a5013f3e340c6fdac5fa910d2c3c56a8fd53eeecb5b0986dfcdedd4a67e788ad1dbb0a1bcacc7bea28680b15926d5cf6e16fc5f32d736bc78856583f9cbe491d9b7736b3fff7be712165f81a9a4eab27cf6e7e837ecc6ef6468558b84d3451dcce1979a08732a6fc9ee5bc0f2273ba0223a3c9dbf9cd14d054f38aca097c3b9619a4117ef23a3e90cd970699fd56b18ca5b474c0d7eba79dfb6096b2c1829ed28b12d2a0bb9af6cc52335d902ca386ebe01da329769bc8368c066a0c4ab651461dafd7e2c002f358be63dab1033c306b073e7d55b5ce1692ca54186f4f63e82dadaf4390b84a72074f91e6383dbaeab8db854f1f6acb9c1ac635e54bc02ccdf89b160f829ebe43c99e62918fd9bf5c4251a27538673adae89712a71313b60e5d3c7433830a401b19ec7071aac299482fe681c3f9ff020b4c57626efc4d21f5c40976076a41d15517f674630a65a7ca7c0b90423acf6b8a7953b94bbd532f3afe9c9f426318f44528775926944bd7501f6bf7e79d935f7e65538b1bcea98ee5472177ec393281e828a48fa30b39224fa1c644f024f1a2205a11d613199b9ccf01799e35d1ac48a8627a3ffe0062bc66a963f60e365123268a77ede0d17676f517c28be6461093b30c83549815ba2e997a83d62c40ff6568a2546098cd0940d82fd3ac4700255f30248d3f7c1f6fd7c13b7666650bfa864f55f9e0be4ae7d4d33a141902b23386feb987ede005caadfdc9fdbf35efaf7e87f88e4127c3ae0d95c803f1b4cd13218076e7a1c3810c6fdb3c2e7cb7f6c2b95180acc513e1c5b1dca40fe98e3fcb7d6cb5af5289d0807e01e87db6525a2274319b33ce0b589a2457d5bd3fd5989ae53bb359ac0636a1ad28f02c2f232f80a10996fc7bb1ac051d107d5201bfa7b43e14b6bb62ef53a79fbd2283b4b203813fcca00edc76616bfbba4876e3720ba88da352e7b60e528736b824fdfa8e2b26c4811ff523ac085bf9b3bbe8cd26adf7f6f05ff9d5145d1b1bcaf6fb1aeba6f97bbc90ca85dce71f18febebdcabe5040e5050d85683d6e3f13679ef04acc478d62e9a17da688352ef4536493fdad51a315ef01261981c5a5a4b2c85816a59187b825b4390b35ff8a1b889d987244016620fc54c6b671e37fbedc4773daec4bb61afd7ef5e58f4cb4cb8abe66b5b13795bbc9bd697d0ab04cc888c306cd3901082fe4be7d31721fae86ac87a9df1125e81d6f410105c443cbd386983524c39f9977e1e57ac026429af40b7568c655c93b358f88370b284828cf38c6ff99440808038bc426e2f96ba1d0a0fbd158d3c5d505573a7c881b8b34aad20ee202c4d0ae9d04b7adf9840b440750b432e0151a1f4965bd46ce42b45b75f6131a46f9610501e909a981e74ae9a197521751c5e6b236283177cd52c2a95e45d2152b1dc3091f9049f5b34406ee2ef29fa30adc1b80c49fd7702d4147d8a06272348facf8b131946ccac2c1701fd0d8a6580a9f8ae10032fe6660e261cb84aeeda8991640041963850a337800a4e6041709d1beeba86b8622af64c5a5c723109e423ecc421a2716bc135a7d4234287d4377e29cd237de82aafbb4edd337a58f68fc2f29a0ab123311a74238b58467d7ca175084e98c3e0de3b94c3794496f6af9c54ec7ab69c2881b0cd1b9e133ff22fb89aa1332ef6ad761c038edd106321a1dbe2912f8d7ae0b7e7470098ad54842af1baf089a3480c24e8d5584f54c1cf3515f010ec267892e30749cd94534f886ea35c4b6ae5fb2a22d67c2855b4b27013868c3743f6075e3227a458af5fd8be53dc6522773efbe2ce5b20042586a800281dfa84f4d21e490ead3b39a2963a1fc1915997886d7b30e900ed2d0539ca1d19eab69a72fab208c07f0c546ca96f7278fad6d5cbe5a9ac4a57d5dbc53e27d3e55fab96547074e177b4b1f4da209c3cc59619ce805ccd49bc62269549fce785e078222ad176f7ab4821470becf1a61fd5cec40e457c222c1d7ee31821040fdb3070fa44183dcf813bbd436383dba42c1873029aa524bfc37983ebbf5efa48eb3791d9801cd707cd30c01b157a0b879a9dc9c6fc821a3ce9b401f894cad4e77d11aa5324993436df2f043b436adb35c2b9d472e7a9da81049e94b7bc73b4f8621e0728700b726cba9da346c9a13ec08ac427aff9c56759cc8eccdaf1a3bd638b7a2e386999a32a7186247ca806bb637c0c67ad48ca960a00958ce98bf54d2f0c16071bf660b65c456e1d90029c5ed703dae55cfe78aae69a4d4ece19edee33a22da2e2b3a151ccd6d38a940dc52e5e84966b5e565ebf4b12f1a28f82cccda79aa6cb5d1dc802cf12deda5d14a91885827900720928369220cb8f22052e1f6422f2d7072607d7a06d4fd20f3e8a797fbffbb6d1ff03215c4d270fe761ff841b1aa75d766dfc43f06d155c7ae43efba176d245e24dad6f40eb68002c0069d2f65697a53e7bc82e2e19634d80c53596f09ff0779038b3d997612b0fe0ccc60bb99dc6cdb2bf21a6824f230cabd9b0a29267b46c3265813cdc5e82685b7ef3c60d50d820c1fced3cdb7eeb3166983a2ae10cc2100158ede30decf1d6e4dffb6eec72f8ccbbbfa7022ad058e7c9ed3b6797a074e30f92f778432d77e768a933a64987ebe540a6a6aeb9b1a09041b06ee07a51b8cb2357d8db1e32595b842462b9fcd85f1a388e8db40995d6646520b4ee447a6da995dcaf0023ffb642996d3e73f686ed008a6633f5bab35cca95a11638eedd03f68c811fc757070e8a8f9570fc6fcbe135e67356da8d8739f5443ea151d4ab45c31ab4c4689f0e3f2401423c5dd4bc69e12c01f9a2cee7e663c553375baf240bfd24f1da1a9f6729956e888aedc2a211819ce76bdd91bf4fc64d5a291f5a02702077c949df7b2929682961e95fb28180e7c1cd5f35cce374ec0789f4d76fa435ea6ba12102bb3f77af7e5cf388c1c29c799101cb2bf799aaf0af6fa0c1677dcfa65073c125dcd1d5cae2afbf08f87cc9abbd6273e341b578cbf25b1ea8a0234bbad03908c9f4bc8b090df377ea786f2d2b404f3c075eeee9c35843d592f237080d30de169851c261c6a67251e132c8672a6f275fe8093201b949dcad1f885ca9c157b738e71e3bd6308368697b671f96f8c1cdfff9515b3599e0e2b5edf90b407ce1c662488f767100b33db5ee6fb5e4af4143970b1611e488fc56b6e4221dc6788864b4cc25faacd04eb63f63ed39eb15db43ec5d5d2b41fe11874ebebf0dd1a4baac794a344f062e3d58cffc5833abf7444749028eec5fda694998e385224f017702c6a9cf30a292dfc191ced26620ea6607574fbc5ae2c0bf01aaef4c249d759c34128f69224cd4302a0c65fbaebf1f8082ffad03970db3d9d463d9b716cf00bd77095fb5ddf602c0a0d4e2cb5493b79529e7573ec73bf9dcc072ecfcfb4def29352f008f6b778ed7d4c7868c675952daf4eaab86c7f0bffc48fba046e499ece1687cdbc67bb016807d62de1414eacce895af0143533c1c7d76ae4e309e374622f93f87d91e125c3b1ed228b531c46f8ff17b93f7fc1f7a6be31b1d9dc94df11963d6dbc087713048bb8d01bb786b10f3a953467a1bbf9609439ba8c191fdd28fb7d6acb64a1820ba3061370e41d72faa41efb5be9240d3242fcb49c8c9e701e7521e01d5eb696c467703eb461f6a1a4ec59ebaebd3a239f866a46a0cbc05c44b2c14f078af207603a7f353ec1751e8c85ccbe12b7df79054946bfb1b516fcdd0715c7dd537f37479b3d8a41be967521f44153e4712c400b22e068659f96b31daa17afa8715930be162a339c64209c22fa639a51a1e5bc30eb1ef19149a3e9baf0455a6a97c47c3cf65754920673bf986fa2004afc8dea0090175f79283c3fcd5289250d9b4ac08164236978f642c70ca678e8744db251980a4581a02ff28b423e82bb0685eab8015d70df91b98025a0a27af65b61d977bff910433a907ee37d4b7378f5eee5c3b39a5a0e0eb4c6222a0cbb9ee3e0a0b107e35da96fe91af2fe68140ff24c2d95eb83e4f5ac6fabb543435a6f6cfad26dd69c9d3c26a2ca1d4b9a154665f98fb9357e4ba9963cc3ab85d3be8d2d16c1fa9fe14645eee8c69a61d51aa7503a3cf72513148f2d3131825f1ecc5e7961f0509491fe29dc127273ab3052474fd0f2c10ab7635da776d5bd3ccac7fdd397d5e88e28587fe5cfe0eda45105ad1cbffd08da42c33a2545ce5c50c1f59741a364c6d3f286db1e5b0a48983af8b454637da1cc8ed2700c038a46556142a2cafcfedb8cdb2584c69552774c53fc9f87860de6ad116ea01527f932b9c1c84b71d7b5fc9211d204fd342c3503ceaf44f88225d3c2b88cd85276756bc4b4281ebb6f7ea12f0487689bc9ac6f2790a38a6b20cb9c2df43e71d23219597bfe6237269fda291376be86d4709e366550938999b0b63475a5f6f35a9965cf00d9f49ea18e024457ec03d3a5b5dc94cfca2a51123eca91436ba96f6bd87236b5273f639343118753aa628d3cc0d3f673aeea934e65cf7fb826ceec556cf28920255919a33c3480cf38b38b8547e1aa1f7279c96ff918dce44bed4a6992d542e366298d61198d1931738a3c0e068ab0847c0cd6599deb814b6efe4e660d799dcbca3a82cc34696eb2caff0404275b7cf170bf2a86d46ce47234058c8673fd82658c8e8a1b8a1b52eae41b22ebe7a2084c074f9b1657f38c807c8bc6bb48b9afec055329018761362d3465a6d02e800e74d7e7a4220f39f410e34d36363e03e3d1835e6b93202d7a938cc01d159a9ea4c89562ace6c0ba08452634021984c11e11ec50936c911cc44ae9df1997a4a665bbf1c803cdd08a783dafda281f9beaa6975ec8f846703d53ad23e8d531db75dfec9e28797abf2c4b6783d6789c9771289a61a42082166c39f6234bb7a9430614f127b19f350c7931ab81594d4e0aac47c861682c0cb862901d069964512428e35c8ce67e36b2bc65b14321f33a0d2c32153b3236f809e31d495cece054920d19e7412d7fc9f69c041086529856bf7ab1afa5576fe6d74eff785f2b6a242a4860bdfb83fc1abfb996e17e6c45d2d339e1531528c30b3366c894122f40e2b94cdc2d9f57484b36929ac369d4ef077c3d7b9c366d9c517dcdb151d46aa168eaac4745b99b5b560a930198b15de98d1f09f9d11f1a5c69eb888146ef43d4582df5653935a0347038f72a6deb5498f51b5a5088d2396b3bf560b981249df7741b6bcf4096bfe462b8cb7ed1cb801295ad2dfd90d2292e95d90148ff9153e83d93021fa4c312e7c1a133f663f20caf0d685dd9b7d3f7059bc996d2d0e8ea819787159d9dc2240ec6e18c9c6fed39f7b9fa05358e14e95e436a7121b5748e5e0f54474ac1ae041c10427c11c5bcb88982e41b42533230022b9b8bae869ff12c2f0e597d452c6d2b9767c6043ebd0fdbdb26beade158d8aa9acfb67f29a2aee850a943898110e4c9a5828da822870bd7f85cc6656104c1d80cf20ab573104e9d2ad15baa296aa189634b28c51e231fc9a20026f334db64c964dd2b35134c861ff81982fb0c3e411fcc91a8b0cf6975c4789efe7cbd223134fb7d6bdf1863293eda74e1535f6885fc62fa50a28e8dbbda10c301d6299c9c0391731506abfaa5a2f0c4bfda0228a4c00dccf8775cccbc8c88aeb1d718005ad9a8d1b90a237c6fb82ce89190e4f0a141e45255ca8cfffa7ecef25570ae8e5e646669e6856e6f2a25351f472c9f9e454129e09da48e52bfeb4ba5a761986cd18c81dc28abb928ecc5ac3e27f355b51a3401dcd83b621adf6b45af4468b15e9419ee9ed742adf659b7dd631fe919ebcc2e6e57a77d0c68ac690e51cf96654bdfeb7fc296ebbf3d3ece2eb87b508d83f6a4425f7f839603ba418958912545d5b06f2a28eea989b07911bc15e105b94a11e254c52842183edfa2ec6599860160f698b3806f101ea91764908f642355387d5a96cb5cab418aac1d5310cbbfe4c7944e8f14a767e10e3c6c3d142824d8e7727def85b199480c0aad8f26e4ad047189a20fd7273375c8c6e9c02842e40fae000aa7cdf1670d04714490380f5347b356f8eead6f123991108c314a1881148908a654ec7f42d726247363012dfb25f711d43efe247f96702b1ad68505ed7848e8804690070b40b0bc8f14a750d952e59fa6e577291dae3a53c30505c99c8953c92865069460e8d644ebdc69f3397a837c99174c604eaa59f9e9d6886380a2510419b76243799baaf4fcabe25e1700ffcb0a998875539ccfdd2f43adb1a2302414402ba766bfddc42cda125b93d14b76e8044b963bb81793b33d98be75c320b6a456cf73d835714765cf7a60e4d184cc9f0a53c95262d71e206ac24c0c3decaad0d6f901a1e4c62ca7ce9f14573ef42695c589dd24633b9aad76708fb29f019ae4d102d70abf34085caf5e2c3f3719937ee13aabfea3f8d7ef05c3a871db1d98b81d9acfb0d8684afe9c212ae917f1278f2bc465f9d8cc205ce3404c8cb447443905ec6f1f6e97fe8b6a42b04ac908ccb3b205a7ca5d2a9a994e1a57b30b402651ef4ce1a58767d41a39a857470a1e9ade39844bceefeada4a40313a1caa501f9d0153c0872ec1b8056cf13d1d6c6a9da4559d61e65f1181e0b741c1f4a4ae9b02770eb76d0da08bb2ff07997a5fcf1914fd9058d01be9dceec4dc11cedab680c7ae5d8581f55943153f29bce2b6cb8c30fdc30ec2a44004154bb7ebf12985483e0a2894735fcabf0a6b756363d8e43abd41080671da1c921ff1e4d853e167fb987f59d09772130d9d6fb3b637e9d84bf382a004fe74588b89671fe8490cdcd79b167e902d2beebbd468b249811a3720dd7b2f4f8d65f8e84382de99546fb62a4f3785ba2b845f2c19102abe189b0e64bdd3797eea897a62a45b3b65d96cb61580bbf16e6f3b02d31e47dfbf615fb24c097010383e1f42e7198da7fc6cc894a273a9099d47fa009e7fa4e79c8d0d216714da5d93c970d5d494a9124e5fe0265950bf7e2c3bf2cbe1c61f5a5697d6e39d1e05de4a2a88b78ab34ea338a88c70d3dcce939a4a8ed1e6244706d31a5f60e1a4db7c716c0c177b8a74ee49966bc8b6b70f45706625bf65875f371bea8fcf2fad6e930f38745757db54fee8ec219195cc651cb91cd852ef17d055504fcc426c266262cfe5b4e48bf89e1236b00124afd525b4cefdce8968813c6089af0c612f38dea9d0de318a1484373279e0c83cc2d340c37e938626f72c6d134ba90e0d59252405d677627faddbb7550eb8de8a0cc690fa1ced49172f908fbf07ade3320b2fdb3ab500357bbf7449bb390b50c7f7aee29917d7ba999e86219bdfdf6c4afb60d47a8503361321f7e26033f9d7e25d7b0e609b2c83e6b9370bc272ba785b962c249c6c8e8a2a29fe46c379df3c3f076e87f9855ce8544cd5b97b2172605dc4f8a9ece5c54b361ab641563dfbda2ceaf184ffd8e186226e88a4b003e30d9da73f01643f58d750a0875480edbd8c0e221f2f3bf0e2cc3b57b2cfa400c5a922bdcbb8ddc07eb194bd2c2cd468f45c55f910f448ef68f8f6b5e50c14103b63b07766fdd0b5da75b55f2053af4e3430d8f8b8c5090d787ce92b052311e0ed028b1dcb66693db862b813ff9e34f7e29550af75df9d8747c0f0c22dd375a5c0dd80b482ec93010742fd5fa7aaaefa68a766db42e0c36d5447a6608fdd7ff804e3df8d891bdaa09c453d697554edb34495311b03059f3eaa4eaccc539b6ff86fe1e34febbb27297c0de759e8180a1d77620af78f8af713f84c6a427934548dfd4d38fb0a923cc4e0bfa028c44e0c00ee0fd90d34b200a4838d2a233b192d78b36da463cc91238b28a195ec92eeda05a5681f648d4e474cd68a387b45f4b210f7b9ffe7885cc0a4c42cec521c2f39c62443bb807cb69526a3d6cf60770ad995afe7741fe26e4b38dc79a521329d2f7aa76191becfc1b82521485bb7bd25666dbe00b31d9ef819066905d48c6f9e4ffca7b1eb809d257ce341bda5d4fdeb7cf772c18a83146aece28785f5574258d1c2ce294641e7302c0994e85898d08f3eb44eec9aa4ad0556fd35fe3b95699b16c43f3e4060f1148bf7ae6358d6704335d80bebf3df6a44344e8866ddab175827cbdfcb5d2d2a5f8c0e2152dab07959e12ddffa0e66282a638a09469b740dd8fcdae596e290014689f80119dd7c9a1e502c724e6bc1c51d87077972dc293377972fe6ab0e7951647438286484e84445b18ebe2da34115c21e2df0a8c04695b176aed03080f174d140952e1586db4a01e28c77947f3e3acb67433a92b9163335150bf77e27a9c74a9dfd3c984cf02d6f762d556f624ee19ccae08d44f341f3d9c3239024252dff52ab9f9baa94b8ef5d545b59aa94954532ba764e2b29aa4505fd7348ef47285f4154d9c313c2423eb8636b3b72951daed0044d262bfde9824e023b6e0b254c9be02b2ac673c2f8a8d641179d34c0f92b5fc636d0929a3c46aee7bfa4b74ae7a2d450c54daf0a70b63f9d7e4154cc5ab8ccc6107e5479a3aca27528ff467ff2ecf2f8e5e4987b988dd10139f6063306eae3798dcd77a78c018b13a522a66618bcaa08b4750d84236916a40cb29ce780a2fbfad103dc216096343e0818b6c979cc9938ea2aa27a74290688c3c82ac54edcf71a8eba65867ebd68498d7df6d7daa0c2ebb3df874edb5169314f0eb5327b311efef3ea6e338862e312be27a7c5b5cd20786ff2658b431652314f192b964ca120dfa38d424be3f5f79432f9698b355fcbc116652e25b4aa4a644b0a55f9ed0ae1c3a670b23659b4a943f9d0b5b7d977b04a1aa922e04bed9ea7a945addab4773adf47f3753c2a6a81f7c6ca16a3933e7188f7d8bde422cdc6b0b95c617e022b20d9eb33abe3c68ce640bac46cd17dcea9a914a1a988e328506cc23f8cabd8484912995bdf608a896a74f1429ad45771c8ffc2f536523e8dbc4e89215ba4977171134a9dcc6fb936c136669a265c9672a6cd1521113c9f4dc1465e673e77dd60658f2ac9cc8c354d4c679aac3a6d69ae8c42bf3f5fde297e8f54f5565a4081ff398416a7e44e45425e173e08c1e488bb99ea8de575c4f1c749694353bb5781e458c53d93149cbd7c609e02320422cfe67bdc5aa3b9d3f86989dbaab7fc34336ed892166a8f517fb8dd02c9c909746c7367e47c764490d1d0d248f376b603df5624d4e2ad0adc43db2ebf1685c8a7f8468cf88cf62cd073c541001627b609ba8dd734a9cf268f166e060a73a35c75f6562dfe24be03cb192e7e426a8a57bd0e34dc726e25211052c1ef4708ef423785b3744daeffa3539e08a607c940eefd850c643d301f78ea7d987de62538ff6ab3a199c704a434ff95175376a64186c6c343117324e5c6014d2941d89ff2b87946f19fd2825d65e01dc75b694252f3934755e135c10f0162ec3825cb671fc04f967942d354cd966dd0ebb101447d2e52636191be9041a121ba7698e306429b6b45c26d1f550ccc968b1c14f2649bbefd44cfc48bf7b09f5deb5ef61b5b23630c69888d44303bd77924a55b9c51ef073da38a0d2175ae74ffd8b27442f47dd74c16b4bd023f3c614745e7dc877b23d6934c27a087d728dab7048456a43afdbd5849d3fbaf850e65951ca614879c67ba0bf245843c2dff96d9b0b215a8e8120437b2733970e471b16790100ec2c7e88260a59311ab54c7a9f1fd3482eebc7ab922e2367a07ac6933d5f70d0688a81c14800c5d883ed75fc87c99b067a251f5207847f66375666579e128e5b47b199eb66b24fc103df178c14ea117d18d6cde21f73a1343c881c6c9bbd665f27af6bc7deeceabeff755e83151ebc107fe5a0ebc5818133a127b7784a7202182afe68088b28e1218b4af7b9795b7aad75f940a94befe98750db56fb235d285a63e78718c042c7ea8a4434b7026a4254e1741b55457a32d7842553126bc044006cd302d5efad9e0a8b5d2d32b6fccf9f30bee2a65d3db9a6925240718fc6a169c0f3f252305b77a9e9bd6d22e68e265b38467f41bdd42d281d2e35a3870eabaf1e537faba73520d09d3c6e19e0c0227689c165a442579d3b07ae2042ef3dc9f4407fe483296dc014b77963b24a36f6660f4ffe760a45c4adde001aa96a6944ca4dd645f155acdfc4a2b0ba4690546b859e8c7c32b467c990a5d3825b38de1e69011546a07d49b24f7a92c10f4176f524ba5468bdd446e1e367f706310788354a09376ca4ad7d7949da3f6bf4a46c1757af34edce89dff7eab0f7456310e71c1cd5cb8d0ba50b036fc5212f12c8edaed6530c1967e2ef1bf3197928c1a4c81bd2b0ddcb8cd02aea680f15fa2a19f5486530f9f90fb9ce1384c1a10ee16d28eededd476b68e86485ab2cd6ced8e16374acfc8c86128e32ce07c97248d1c5af17a44b5fdd680191e39ab26ba877df46045c36dbb0a742d7abfabdcb4f81c681d2e00d97c93dedefd72f5fd8f6f3664f5b99e2a14ee76c828346be38e299121a697557f0192dfecf1c5ab1ac48ee6c66b9c2ea97c8f9f215946a373030224f2316440387945e6395de965cd162828abf1c061ac02d1a0919ff0088defe684b788c5fa9ca25e8de8dae9386b2d7a0c1e9676e2c57943f63e8558be06bb236355c2c37035a4677290a241e3e59dfbd69a0250f2dff7d195596e45e8caef348a8b8a988bc00aeef0074f5de8d0dbcf045a733fa6b03b21555f7ac1ff7db3638a23bd34340de95c23576ee186d47b27e0555711e1c1bb4e89eef7fac5f4cdd0ab32926f07912c1226447bae275d1a568ad46fbf8845c7cb6496900ef62af003d9e46fc6ddda125e3c230c0fd0f23d3738ff0fc931e2552b3dfe0c8575a5550af28adda4c5cc9a360cb787ddbcdc108b3db822399ab06ff81a9caaa37b546bfabee9bd2d6b9f33de884f8575eaece2db94eed1a79ee900af996c617142bdb9390f6a618f969e95ef988ea10348e89591da398cc251829325ae5d7b319e9d1ebd848370831e64b8baec5dd2ba1dcd4d71338d1ef8a0cf3bcf1319f4a50c3e71145a9d6888ece0f81fc202ca00eb45d8763171559f0671038729c83c068eeb18e1baab0f188ca7c20785e10ecf6b3fd6c4ebf815cb004d61154f5fd86b83f73e976d5ede79f902cf7cea87c45a9bd04cf03f597a02ba95a3b6576e0f86131252f7730fbebb253c24e2fc1d0266774f5e60a69d5839bff06b4a6e2f94f2a731c3f60e58de40da757e02b77166aae89560422b55163fcb29fe1415a5f96d6ccb7b5becd96c48a98d034f3feb8c005aa8ba698cf7c5d24249825d5ae23391ed833a06c78ada13d0e3a9ee1ac4e56b8b3b16fe421a1375651b797c502d7d907fa19affd2c9228e21fa66154a78bd6575e05f77c0a9504d0c74215436971570b84291d1f543476912f465713fc662bd7d8b71b2810e64422bda2493720581a15d055b71d0735e678bf382cc26900b20ed62227563a0629a4033bbedfbcfa3d196906c2038416dbafc5c4c97ebdf477d92e7e088aa40cd990490c5267a22b557d6299a25e3caeafa485c16317470c86b1a59b625521dea1923218513a8b57e0d14416afca2a47008066f88663e7c75e0b2eb5a74e33d15aa4738c01332168173cfedecb4057a52c3c9b89b8bc90fe948eafd639fc7c04ebb06cbf99a7fd09c71f411b98c96f4151b6d07c6304f511b61b2643f7ee4c27fa970e40d2a4d2a339b49b2f1407f4df592ce309d5a4aaa9260434ba00a723a67afff5cc4e2fc36b8095fbd41263f5485a9dd66544e4f8b4171078ccfa7b115649b28ef515e7a952224e22ad6edbf645882306c5eb5516a1ae54d9e23b3cb450ed426134c602c96e8934fcb381f625fc4477c9bc713a4feeac28bfa0351db6e3cd11a942404781c676ab819c2820cee686d4fdd4ce311ca7d787f2fa797ab20e1651ef4b197cc9a8ea4acee867f48945563101e5fd6a82d985ac43bb9927d470a803eb3c93333031f3b7bdbcbc306eea737f0424f0c8bbbda17b2985e3fd8a320e155d35f60643928aa017bc04b97b2c4fb7535bb610e18719da78e374ca8da188735a1df4590f25354a55c809df969df8e637cd3067acce9984301ad74e41a2fd765ce03956d8b9a78397e34ea5fa47e37dd67f21c2441f7b25376f6ceba03d26d4d24c6e89abf49fabba110dc02ac0ce7bdc8e97ac6aa4cb5a15287fc55e5828337bcd33ccfccd6d37489236f1029adfbb1113c3e5cb94deac23f8ba60f2b2c3636d16065bb2c48be772e35568b80d2303f4352588cbb4b089c75c098ecd3eeee5e4fb244d9aa62389f210d4a1c537615b198476cde5604f06787ef3cdd0bfb0a98d9450c0ea98a85ef0a707e6c07c4e19c98d999658da33516b4554ddeeea7b52d4e1b8b06be4c4514b14bc46a36f83f43674f57075d708da64a87f078258fd66e0754752dc9b9774a095e3543264251a6727fafcc912509f5469445efd9db1ee8d266f24dfc523d27059be92ebe3969d02cf35bb25e8ab65d96ec230ca1a9760782a68aee1bd4b50c3fa8182ee9551c7c1963dd091c30720df531f1ec87522d31b7efd42e9b9bdf6334e461d6f56c44e8eb629aaab82d7f0a6d8a68f92555e0fb302b6581e5fa5b80159c8160f74e3821fb68ae9b74e3deebdc37f7e041ebfc2d7ed9cf438e1a4553cea031133dbd40ee2260be241b7a30166a9b7373b9fd285107179aa5ada14d0c4b8bebb808f3003162a3e9a1bd8bb22645764236da5f4234126a86ac5a13a78f9045cfe0696bfe2d9a12d2b37c70800bed0a73bf16a0dd82b02c3f77330fc71f50c80f86ee78c86d47ffa1d2618246509c3127769ecd77539f1818527ada130308db008fd96664a8469faf7fe04b3e7b576ca5e49abc8ba47cce27f5f58645ae92daf60149997a7ba2f9dfdb1ce56ef884d0cb614bf0c06b80e65b08e8dbf22dba3cb64a92562c3959bc1a9c7f34ee5b6be7523eef9537d1f953f0951e40d464269b03364d565d44dcd58db2812cba1e80e386063c8bf4fbf4a7413526b3695e14afba73ce6ef5d40d9231c86337618de2be900a356c868f760a2abda976b1bd4af8ca54d4251950a33ce7f4b4f58d1e81ebe838c242f4b6f949e0b335050d530620f35b541cf5679773055fd6c93e57ef072bfcbf4baf37ba91867f62975144ba5b2152e6f4a7a21f95d0ff1d960e0a91f2c2bfd5bf62eaf9bd2e1ec2dda1610ef28922d9f069623be6b15c413c06f60b165ded6735baab8c845a17a5de96a2b3387ed72dbb28739bdf9302377bebc355b84acb5a6f065af1379535abad42089733e0302ce48dd612f1a46e6c7f343827fa45c2c27140d221e58433c96244f63f4ac34f4976ee9c70f8b00a5a78ab84a62438bb949268d5e39f9590f8075f878cfa5f3e68b2df87126e1e1a24ab083e275827743226cd9caf991615615422eaa7d1ad32d5febf2a215fbf794a4a52109e1daa2505e28688491372b038337cb611af8bb5f5e48088be2585a2b3fdad4fada1f57b0adb882049f47851546bf1882271bf17cfcc8b5d61ee5fc24842b13798dc6e3cc2a5631b434ab73169aa2670fe3e0f3d5315410aed66b95d83ceb334822b9ddb438975c81b1c091829d02fdaa4ec24577c39e845c114164ef972f8d8c06c21eb3e6aa437b2d55dd012f6bab4e2a43722a239111e2d47f03615700f9e5168e0b1c0f2901a062ff9ab9dc6a47021e1f0d5efed3ab71bccf9d152d480bb678398385545a0dbfbe31d10fd13e72e86cb0bac409dffa922264a0bb672d44812b0d7592f9460693285e140649024e8b7ee4a9e11a8bca5f9d0df83086c59a0aed79466d8f5dfbce549302478fe4ef5bee59951659669324ba74e4baa4293668b537d16915551595559167a3ee09ded67820f282dad326ca410cd0e02c87401092e021d323254e630bf7693bc037f5edc18cf25e01a2136661aa611f1a7849cf516c542ba9bbe1bfd6ab1ffcb44e80950e0bee648d11db364035b4d2f5f77848d772487a138db5f0614163f13e60b3d68e7df1b37447650fa0e28d13eea1eaa582dfb1b50a778195ce51bb9c1fcb7c3565dbc8b279057edb61add50ccc9fa29773d9e4173da3a94c3a5b1cefa9aa546eede0f41fc3a1b50685894f9c0cbc5d462b2dba386e681587f8f234577cdb57f01129c5681390d5e01d7ca496f83d8e46ca878f611970e6f04f717d6d086f41c6f8487e38d379f372fc5d5d9dbe68a9b0d9a4aca6f8298998b0e16dca1140ec0630ada64371a39626a01a60fe137f6aec2caf11dae7aba365a348fa9537ac7793e47e5bbbac6dd02240f6a5385aac12eafdedd0d754b87c5a77f197480689765d5de4fd71dda94bbcabd14a4de8b844dd489f0cbbef60b5d6cd64c521dea465a387a9dd3f89d4e70bbfff8ba197811fe910ed44f01216c7403c5de5f2de73311c02ba43b0d64a4ebd909a5c7d47bc315dc27b26b2a092bf1af0e019c1aca1cae3656042f15451f2018b4bdb5e68c88db36409673204e49972a99cda853fa540d1ba007abc0726634682ff556b4ff921551ae6c5cf9c664846ee22655e90f2f88a5e32e425628ed2dd2e53d37361e4373ef70f3e65f8d92fc0653f4622d66f1b0d20da8f6a01372e070080cb57d54c2215e6240d2c2bc66617b45de7acc6d3316af36ccafee7b4ab55ddd251f908004ce4e1baa4921c22287678d4ad5c7132a60ea2ce366525cb6482a44967b1549d03558d75543a608d98675c962ad14a84aa5fac53cfa39190d3f273043ffbfc5e940363f01eff19f4b60da68e5c3167a442d6d6f23552c7eb58f36a869208e8d4ffbb835f72e30e05bef617046c77c6babe52a81f7762902219feb5f35087c3c0dcc374e44bd40ac665bae04177fab87b4e0f8e60dd979f06ed17cea3ea7dcc2ce14e8b4096f865bfb941c9cfb37566a979a86a02151059f192e389173c9ac36293de50159980358e0fb1e671de42ba286197a71dd27820c9416df1cd95d62e562748685f269b36d85cceb00c46d1eb71cd154563f88b5d563a640951b5ebbfc1294e3cdc9a689ee28bba8c5a073604c574eb4030cea949efbad3d7c072cf2bed85a6c3fb87626368a48376f8b78ebed716a48f142b9e62df3bd00af2532ca83d03e0ded3e2405ee706698c43ccbe58ade7ebe1cde6ec73eca609d2466d49f7f462f6d1acab9433143f12c174a3a5251b07f780e0e66c1460b40eb5cb8550fec97e38d22eb4a90db82935e1c0a6de1cda5aa75c54a63914deb343dce07ca08d78b8cd7d3cc4c0a80940bf813fea6629ff30a5503ec537400204128634165dde6f446e174f9985dd969fc87581b34b838455b72702e2b3a58d8a011ea7fa889f51a95121c1732d1e78c6fa0f0173fe801033596b8d1c0a4e7d7fb8c5ee4f7b6240797a7a61e967ed36af5cf108d3c5c4b7988136715c49b605544f99f3292eeb3246ed5e2a25b6fe6d462bab55abeb31d9f75f4477036f78340a4c26db780bea6027e5f63c3868cbaf80736dfe16316f59e6169d8074e2121ee8ea96309500297656523a84d77316de17af027b1f6b3b51888d25af1fe9610c87cb3e97b6906e15ed43b03424c33a53d05333a47845a697962af2589427fa9d796406b579a5ac74ab675bf7359e13c75a9473e37c61fb43e8e099de0fd3b6ecfe3549d5b66be9def810a4ba0c665f269b69e1aa37153c33baa7a3c0d6e51660d6edcfb356cae9503d0c361d9765bef759608508e5748a03a32d8a13df7a70984a63fdd6114762e34611dd2520d695ec6a68078205064a3bf2a66d5e4e7cd1a8fc3e8fc8f61b88fecded991525305e4eb25b441214871701bc9465d1c23b0b31096f77b4d02f2bceb1585588576d05d2466fe86895bf5db135173110d249d13201ce489e82f68c3d84f5df23fe0dbb3a2bcb7441a8d1a7ae3796c40f082b229f43fc71a238d54456be66fd9be5586376f03b7e65b79fe7bbdde7e09fa2a92bfd3a8a0d27429a1af397061242fcc892460cdbde1614922752871340a02da0cdb60efb74ab06ea2affd24ad8cd8dbc3e6dad3c13c2c182978ea1a980819cb1c7060013c2b193d81a0e08f617d80df75e90dda2521cdf1c9b3cc4dca499993941f1aad32a61190109ecf96c84c0106646ff6bc2acba15a47d9e90868e6ce4c1cde9092d5dafcb7af177eafc3d7a6cae8d8f7bc17dba2134cb9cada42896cf558c59dd79f30a56454f16a31065b59fb2baf5dab7bbb85d57fa4987460e75b0244986b63b56e1c918cf1f43b963fc5d68b5c62f5e89940a8dbfaf6148f61f0dd59bd24e73d32cd21784c6539cbc3e3521c99128655f7d50785918a49b62b79e1067aa6f22658adb3c815e4100ab84ae4d3235eee7cfd022838c98ddaa2aa56a2d966f12dda4c75ae5caed3eb5872cbd45fc0d45ee69453b1db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
