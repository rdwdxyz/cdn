<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85f159bbd8d3cf1ad7eed862c45452e29e02f2cd5c0f550d27a66689439d2e45754ba3e3717165d6090f57530e4e253347257045c7a14e7f62a11e98b9fcdc46ab959636baac948e48d0bf662599429e59fd0248a3721ed9f1f25ff8e8aa6ecc0fab7939eabe7ec4671ad21066c2a29c3b2e87feaa0e81b1aae6534ee2b995367b8e0741ecf7a1a0f9a191abdaa7592bd19170e1d319e190e9c9c7b5db7b0424f588039f0df30e09c744e51a9c0a83f3aba5f3ecb569c8471152e180726aeb75ef9253ccaf3243e51f120e727dc6c991789a36620c0d98d9547c88ac12c68cfb3e7e336bc5f1ac40c8fd683cc255e83eb04546fc344d83db6e4fbff6e130db69dc27ed413739e1394f04b1eb92069f092ecd6ee86b772d7d3679a8354dc90f16cde735409349e613ef63a3d00893ade34ca83cdf33fae98073d12dc0e6961c10b5fbf2594fa0fcb8407b3bf4762768edaa7a6bf7dfb513fe549c925b13f7f26eeef7a83517da17dadf643f69647c46beba5e5d7d294aeddee9a5efcbe696a985045c628c9277c5ccae39dd63ff90b7073faf644033d4e5938a82dca3f42c5846ef08808eefe53b90439c10ca07c91fb6f2c9464df5da5f31149905a347c31983b57bc1a6ed64021ff5c5a3cef81d7688b83c2495ccee2ce23b65bc7b7b3e468fe0a9172a3114dcbc61d8f3a1b2a2d6053baacf2314182c51f4cf01741ea08e799a9b79b50acc93de8fc10db1a17a9f8a89b0ab8adbc87a3d862bb55be9d21079976a8c674e34ba4cfe3de9a3ebe005b918352e48d697f0dd350087077e000d9a74e8ccaa477a34cf69d804632b42eb10e68d5814d615fa1834ff0e442ca406c86f12396f55e2454a087bcb53382a481f983d4c0ba8a78adc9758d14d7015789bbec5bacde1dbabbd3bb26f2d365d510f67536323557ed133e84a45277846460456e83429d3d70cb21d4fde9c11d4e70e50b7c8e41448fe2705783157f8d9ea811fb5c3168848458fbcbf2614e0af30f87ba8e7021f8d21746fbed344293df90f5e8bcaa2848c9a67bcdd5e10c7522148bead5c4df65c4029ed32ed10d2397784b40b85333e7f4086c08ec35c67c9ad35197ae9d9db99d3a061dc9f6990edec141e4410be1d656506d9d36ca88acd6a8c3c9b961c2d91af0eded3bcd2f5d3bf63831976d7fa31feae1e51e3dc255ac3b3618b1c0c46e89ae50702d842fd06abede726a57e29f5a61b2ff07163dca5e36431f3f2fe7eac76d9acc1bb4d766eae25059a9e04a7996eb210e84bf6ea38810642739d9366a6992dbf1b5739bec22ea1549602d8d01935902877abe15b3404e95eb46f39132565b1392ddce7093602c83c0586e7acb7892b2617a1fc66488dce4d278937370085804d37ea2e658e913f918cad58da2dedf7e785b849ef05b67f294e94607d32ca473036c23d00917e72b7dd266e234849276d7703495c56beb6bebfa6d04b21e5580a6fd58d465c0575e96136ef74310e126b33e6bab63ce09121cb0ed7fb96d220f6e306d2eed8ecce94b0b5b704edeb8302b4b24845eaf54f418f1974d7c05169f4b251dd15838422aa0aee58ba1f53670e1ec18b10a5e4c17e6e26545d282bc7f98ee0941d804a350e4bdf71545c31da31b6a939c8c96f09f387bcfe59e1769e5fd65693849ef55431669aef63db7f8bef1a874b8718e099beeac6539e865f3c42d59bdf3939c384bacc92452c5bc9922d5a5e22c74c8c8115f89d5f540961e7c93185089b5d2736f4bdd2aee70d03bdf85d078782e831de7cbf6fc7fc76e7690f0c0a9002324a6d5d1d9a13f4f4d942f334a768bbddcf4a1df9f35b7126705cf47558444a10b5f27626a66d4f0966e26a70d4a070a4033654e11ce3f16bd4486c033da5bd2ad8c92f17afeadc7d237ddf89cb28684d9810ca90a4c2f1165008d1fba0c3db88e7e7e043b0ef97607a4c0d9dce053d10384251e36d01e2122ab7a1f9aff78d8f8706bf9fb1dbdb26fbac0e13820450b39812f9efb811fdb6130c793ddda61acdb86f8e19a8675a889c762a4bb15b7d188e2b9796452870a2d1c85437fc085c409a98f7902e6d5aac8e91c77da8b628349621c857401400437e9a31de34d38100a30e7963c7d3b50a72c44c1d21554a1019e63c2991c0eb9b803e501f22166a60b03d69dd7c379512913172fd54c84b64e4bfc74c7814632ed9ede1f7117e1ffbdd8eec592b0d4e1368a28287a651516672a3ca90e574eabb8f54eef3b34fc7e4ec91f23208932c3082032f0f988ef082b0e58f17137ce389b01475c5677912edee5a504c897af93399ed33dcde87c862925548e7098365ec996e59e10bcc65a8002ff7b58107c1f602d87c64456a5f632e1f770d35e90f189d7cee86633357f04606c2925c7bdca33bd51cbf66f7ed79d9c400c1f07080937d5708fa6ff9d8d96f54a2ea1a101202c63240f4f64327d808d2c4c463cf47c76ced69a71f54ff43290e0bdb99ae439e70a3b27a60ca710a254bc42319b1d8ea7690f64f5226b301f84b760c8d850d53be1e1b9d7e3f0218fa0f3b70544ed60b9ca68f7e3d48722a599fc3163cabb624e596eddfac2ecc929539b89395df05b44498daa0a8ceb195a43e2f9e0c9eb3137a906579346f90cd0256c71819268875fc3cf45e90426be3a3366c842d82d2e83ca167086f0cf39163bb0f694cce9d56944541e35567528daeb3eff02bcfca21c57f30aa7e312388d298874d30ff1497889054983f47862be86378cfbbefde99e6383dc12f38145afc2c3738108497d4686c9f6ee42f1da7e6d898b47a529559ea7a9c43a08cd01f72f817a77d213ee0d5eef3dfbd2118ba662a05f8ef2c453871a511a482ba9fd68f35254f341f673c89f571b25a3b72185c0cb97f62fc43a068f9e5683fcd3c166370df1d626925b8ffa83923d7b6c1c7e5313ccfd2f71ca6a551018892d840025b51e9b020977b17d9dd084b72f0fce69a389adc45a58d1882593f423c47d2115b7f7ef1672802e6ac0c67a72f40f6c702398fe7cc28c0e09cb7f84f5cc2e945ede6f8cb5552ee8e427ca6d5b3a530afcf1a4057922216d150925b2c169ae9cbac91d2baa12e75d48c09021464133fd7c99ddfcfbf7d56b5b045969e82b85a742d724b7b99ec90066607ff533f6b4d8946f89c7ac3b12343226d98934834b1521b206fca871f41cd96baf72299e100eaad392f084dfb8fbd4b6fd1e1b125d58cb1316bc8fd846b986ddd1897880015f09661cbcc54530946baff6f4166508b7ff125a5e77bf9200bba480e01a0951f855d584aae52079fd3e6dee91bfec1b729e9649a656a88f8214cdb87a04fae75d08665d6eac9efdc332623432e5db0b9ffa232f7e76af0c8d5ccf2fbc20ddc7a38252489512dcb5b02b80931cb444746850616d3ad8515bb6f1968d30297b96008486644d1a1079b1970bb577b12e8533b9384d79460d4bc76b75d192f9268af10a5e62d9a889922ba0261baffe1726026c5b4bf9030a381073fb0ac293569c56f92d5f9ce9a013ebd7300f72ddda6e0594febedbbcaffe355876097887c1b60e2b7f064ff08b28411b3d92d4e1ed9291f0d5391986ef37e81b3f4224a3597ee63803674583f8707b5b542c795ffd5d36ebf78533ba185d05e26ffc37eca5ede6633d2500d8adcf1b872f84c3816c0628820880166c8f4433815c7797fe4b3ffd21ae87a5d7266db43a11165ef1142aa656af9c55bb0b6b9eb89b7b1b5596f672fb38450b067c5d15bd4d253110358f5e32841f553b278782e232a1b095aa5a8491c7f36b762631c1e29a9ad1b93261bc2a4de20721249a8316d299f54cc41df9dacea820673e3fa75a944af03712ae67f769ba9e0121aeeeafeccf6871527d945af75e2694ef5a4d0dc9795389b299dcc35e00c30c54ad68602fb5b1d542e681a4e664948855de81a6ffa18432144648c4f696b96cd9a0a85232c7497f99f5de0ce92c01c8c481766184a17b694c3c0b43c158a5fa31d8270550a8f27f9fb19abbf3a4d422b54f55c8a6db8f84c8a721801a99bfab3e409cd499b42a2e89e46826d866c69e8a75d659da3b4712e5f2cb24cb403da62ace16e966340a826fb1ed07191a468e253e341e1c5b3dc8a348a520cd879eb4681b0d1a60edae97380a64ecbb45941d2501a5fc7e2c2d2d147681398c6e4115b0321c024fc692e2cc6f673e797f3f9ada2a201ac447f5291316d4e6556558cbea0ac9ee8b3e8d9315767f5641dd44e5f1e6907569e6d34c11501739eb8e7140cd274007b4db027f7173f4a8d5dd903cd15f21ba0086c873590b814b0e357834dda7284de9c4163ccfd80b6d27c994ff01cd2da8f31f013754b94de59acba85acbbe96219bf273399a51f3118ea2e40f7a635166e09eaeb83a6272e4c7cee09415de3df1dff6f61e261be2456a44bd06fcb662de80975ab623a3af07b13da2d91cfa22e8ca74e9fcd225a9bbe5988bacb3b01519c5f5335a40d400265c2b32c0ef6c952ad92658d8d01ddb12bf0bc4099280dcf2f14bb7070d43988de8a6352849e627660d12466003e5c3e46914ae6ca4a791e4e0377def02f940e363e4c11a521021b319e8be6c2750569d482846a727998183fce5b87924948d9696db5cf88ec5ea656f40e52f39662830c9159a3bce603692cc754ee454ef6313e655a5bfeecf33154f71bc0a1055a660ede1090ab54d7c069e4c5a88cd19a8910fad5b8dcc50c1eb53bd7ad533f58a93f1ec6cb983b1f8232554d18205c65bc44fa8cc60daa9146c2bfe2322078c156d4e9ae4d5e5f2a98ba1ddffe79654fb0c960670f722ba47404fa02481c7bda26adf8044a21a60529a7d3187241b342354650db1e155e9690f60a304598ceba391f77057a8a9629b719cd3f28e3990e8585dfb7c80e9a98cab2ed993fa10f4c50c886e0a07c1731a386aedcedc10bb65ebbf1c5b70e23a11b05e5aeff02d43d91617648d7d392a4daeb9466bf2f8253132037640953fa30a250b9c781fade85d4388b4629d29e01cf7b96d9c9714e2cf769793467882426f18417318637862e51f123123c9e882b5f3b3430f206d15a8267229fdd670044ea9257c669ca11b33cf3bbf9156e28d7e74bed920c6a76b9af6386df246a2ad9a63d2a98c686ff7902bb24e3704ea0f0d310c716c5015299b48275ea8c37d651532220d9c603e1d96bc58174ccc34bdf61bbc82020a3aecef0b5f0936dc8e82044edf3c070e53a7f814b4d32ebed3f66870d5320c1f1b3f476b1980c91f5806a5da27ed64d0120d1b608dba413b441a6b816b36590dc46dd7927ae0bdee807311cc875718e6143fa8b73c0a8a00098efa0d0be42c8423420a74a5cd947a62514dee3f10187384c972dbbe956da66649c907bdb2c9bd891351a5c5763443aa78b743f7d1166ac9978d2af0681d91e68fd24339c0755f5b3b3cb846bb1576d84eef4e71d03e37e0c964113d97cc5c7003d4a54625be31a51b856d3c06799af1047af859ccb90c9dc69c9be331b606d5d0585a12f028e36c0441e6c87bf9a5ac47cf0dcd70922c50461767e2f6bdc8fda4922c4ee0fa1d6cf712e9be4af9db1ea31149c6fbda5834386e32099e24f78c95698b90cbfbdf128c07fc7b2fe776ad1ee036b0d2b7471641642c032114b593ad7c6bbf2af3d993bfc76b033d24e3aa33eb76cc4237feb2024eb4acfbae872b1db5004166e5fe0e0537e81ccd3616fcf00c0d3f03cdcf28fec8138423a6a6ea08af3d175ad53c0fc8bb45ebf547265fc821f8dbfed0e92d9bfa4dae22fc3c7c5fd9a054fdecfa9144d464f6bd0b64e15a6805cf728eb96c142767da874e62ceb20098d956ebbd9ec456f4bd4011cbb928224d64a1f48462114cc798eadfbd8d629fa29bc3442d0c1dfbf0d12a9f1288a925a1da5456c5ab6008063aaf01ca7420d5467b6b8a2dec5d4454f8da49b855386b01de2aa0667d785e8ac6bbbeb0fd15e4736905c4db7646c096fc2773c1f4c1336a4875b04c5255cd172bcb753088aad9cc7036c77e60fb6ea1552c5c17c202c27846785c1c93bed29b4615f427f0aebc7cc2864a6bcdc66a30a1da57ef48d40a1802cc5cba3e4c356d70248224365df8874de82c67eb1f980df908803e9ed3e1fe92f713351b6a0bb4a01ce56bac231e5c64d88157cd4ef3a762dc1114967718a6d824b6a64924a5e9e7982b8c75a54b584856c81bf2033d3e7f85be0c7903c835744b31dc9704563908fbc12e78a4d27e45caacbdda7d12ba2bd070a34ecff398ac671f9f1344724a01cd1fa3cc82e5a42bc0695ba01fd23dae8b56cd09b603f37b47f1b92504528f20f69e71f65eaa399ec6cb4614cd97ce6fab33ea405cb638a6766ed67e652748894a491b6a70823dfdc995de77a26757238843956eeef5523caded2a43215eb5fcf7707a965018cf76062333d3e87308cf151a278913e3fc833db654e272236909cd31d67dd42d8aff3c39fe00306feeb25048e5d3e12a166fc86f16c8c130e9ae94dcc21ff7bd917645ef37c660f68af4b4c8351ea8b880e31d293ba3d93aba42edb75a3ea10c1b94711ce2e5141ef771745258b0b28ce5c64d00995d3b7c1884b11d22d20d1b75d15f8cd8e1c8a92f179a50b6a84bf836f7d966002c6fcaaeb47f99ebe0f2e15987811c819d7dbc2e294a8f595942edc7658b361d58f20abc7f65e292155c063a862fba7c56e73652701a225a263162f9dff7a898df08dca40c77c809d087b24e943b33c59a2f7f142a356e84604942bd31ebd1b92f8434a3bb5f2bf89334f6903946be21b89f6dbfcd72008cc0f3f4c965bcdbd3189937edc61ec3411c800b312da6cac460fa9ce19012d6057de3eca63333734551a711bca5a3190287b8c21d9980ccc9dbadaffee1d13ff4e79946af932e43544dfd777c337769fffa18f1c925eb1fea9b9ad44fbc5ea13bd3e129c7fde4410b0176a4759f6481d6728875338f9b9e4010544e8181829cad8c4b4e16bebb0081808b2da1f0e9ae776b615a29819bca346a4d6e76bbeb7540a58e9e626ceffef0f6321e149a10b5b71680b5226fcc8d47d26d76f711d05bea1dec82e03d25006602f0055ed973817b384237f8f7691bf88ad5bfcffc12b2b89762be0eb2f34df596b05dd94305caeb95baaf84515c5a5173bbad499821d73dfae9827a0bc44af2f267b8b76d71cbb8de6e3f52ed2d3be42d39f82738826e0f6d92396c51d6b05b4e4e1d02e83660124ea6d7523d3c6a6c8f7ccc2a070ed5e1a539fdb9d99c392756b658f0da6be0213ce54ab2acc0b4c008997b2dfb4e1c8b0a967a158a520c9cd7b58d2a5ad0cc60e391a6a70acdb4f334d6fa8a65cd3533805ccff1cfa7ec034c7f82b5c0761475e8ba4732184f179afdddcf8f5db30e5b23c8fc2ec6b6a8754a02766a1ee3c9c7e4c592ab28e7e43b2cf4a0534d35a05160d6382af6a99c48db15fa2814258da444c24e86bbe9d4dfc1d2982cba1553bfc55a5bbda44063c3f9ab237f29f802ac690294d651f08c0f3479e496b893dbedef787b19347bf23a2ecfe7932c4454a09be99aaff83bd277e687750e5fc596b160283068e28f5cfceb239f9854480366e43cd20006aee030e7389bfa4bbdb831307b303e45f9544b0fe8ac1872d29afb7cd1a56a497ff18635060ea43023eaada26d607c4652d68699998c27fcd3d5ca1d3ce9a56ed53f76bdadec6858a5cabd3962ff24739ae700d6222e5ec3b966d5906471e328a1288e2dcb99be98804e9c3ab64ac3f00e60864fcf1d729c51ad2bfc4c6fc5a0bf4b156620224c3d3920776234729853c7a684b1674b82b98b9a2286fc59f341775216adea60fe3c6f86a5e2ac5f111017a7b321b593a651dd5e86721f29814171af6ed18b209de84eb8507c3e028f5e8d81a01be32a0d5d287a69f4bf599af4de8bf9dd7f0a44507ecb04e18ea63cac16d246986c07ca65018138f2bf492c3868cd7bc695333ce2553f6abcabe3752f89d8cbfb1b44ffb328614eb03b8bfba6bbda98559ec5ea76a7baa1969031e5deea9f3d8ce028fbc79ab1450cd9f87c30ec56e5408ec277e13640b4bd223f354ef50639dbbe91f758ee5fc0d18cd4893c4575d8ca7c173260241bce49f15e6a4d9ffa584d2c204b9c9b683cd33882d4b18ce5413f482733b67b1033b2ee8b53cf94837e84664b05c43907a53e7e4864003e7c5e13e614572122b0484ac76dafd5cbdc3bb0e9bf55540b4be8ff884f1b79942062ccbae92f54e0039c10628c7998892e3ee2f3c5d0abb0438907303579c4da8c1ed1f68711292f7bf8349bebb9cc4473fc4962dd8bfed0a314e6f3f08bbcdbde2a01cf6345773699be70bd71aee3f0481da2cc516d0b28202867a9884870c085915225919c585339db3d34d1ab5fd8c4ba671d53b1de8a9a7de16b9c675b36b1402a84ec5fc35b94280e9522894643a9824eac4ec37bac7d2e307f8f3aebf28d7ec240236e30abcad47a784f3b44708ff93c287e1eb652e1b9ad8608f2eed1ab012c74f2668c43a914cebd28763acb7f09767dcdf233707a20cb67acde22935264b822cab143ef7f628573d15ab79a0ab9cab80f9dfcb71bf044cc1de49837a6cd64e2a20ab3f0b5d5df826de4afbe1910f1992824368edad402eb8a545e7477091efa1bc4f7cc3faa12071b4f34c7a27572c8a7c62263d01245a948025e89e0a9245b7a80c85e17ce5540fe91826a7c3a875176599586e153c6fea06bd815b102ef7094201d7002abb09c052f754a0dca8d63199cf05da3a5a7150fac88c368f26051f4433b8c6d148599ba937834da7d8303217c421edb235adaf46d8c2c838ab938155c8b4b89bad1e8a8ce6d63e20d11da180a1306b6bbdd2aba8affd7a16b45ac1944fa99601e971f2f0d9f6f3d8f9cc6605fb3f1772fffadd702b91ca28b04d9bb8f016117a17668167ceec2a5b1b3655458a9d888c7479f01b7acd28b36be2833c18387a11a3f9174d851058a0cdc2f646f3ae4c4e2f4f84bd0048b38a3e151431de62fb607b3f6a210828b061706421a45897cfe8d21047fbee1302f3a1cb7d5da23c6e7942bfa36a8629df3da9e101d128ae7ab10dc84a1ed551f30d64f566d0efc73e983409844d0cde9501ff2a3350cd0a8ef87bab9e721e9c60ba45c73edef2e26facc2ab3b4310ad6fd3ae78238ddf2433512954bbf260674e6292a323d00ad1bb291fc374c40ad25529d7e8ed8319e778e7ab3e55c80875019cbfcb5823916706fa979f9561b8569b7631efd2a8471b7d3d35a230bc995ab82ac7c6b08e31180210d9737d606a0ac278ba7eb9141f749e8a50c7e02eee418690c34afc886779198a37ec80a9ea475f98de53dc07595467b909524c43066323ccafd076f80b99c4b3d3c7ed160a4edfd89906ebab067cd043a9c6e786ed3c16124424e827bb66e99e739b99b2dcdf9381e006064bd8a29e364e0b85a5924477d0637ccaf1239365427642e1593773354adbc6353b607c3da4c29889306e6638c09f8d59acde41606199adaabe320069cb648cbcf6ec27618df92228e53f10088b470205f40c2385aec767a599a6086c2e5841194f96d49e8ba29c6bef8f2216240ebedf79826f877d421532c080e727a49c8f5a8008c77ce0c7dd7decb6d41fa18645ddcd4fb9f2b2973826c3906fede8027020d91ff2615bb9d2a035fd50ad57095af5a713d3a4f1ffc51ae8f0a95aecaa31f8efda5598efdc44180884223a971bd1cce3904fe8636bf0779ad8e1741bafaf62bedbc55a7903a89be047b024602cc6b2796d2f84a0641f191f26dbf1786612d98e7df28d38526a55a19af234c38d8aa3840101247cb447880ac6031be7e5d30043c3544592ce6ab46592baaf11c734a6142167b3feb5e08586daa462549b33040f13cc1157ff30407c24dc77789071f26b457be099ed78dc298a0263675faee771f8605cd038d9553d813f163b7480cbf23da997c8a94731a0aea17d30674eeee206b92661c8110e904813b218a7810eb9e61b3a31559d3b3e802509daaa2459024d0cbd70722d4791b363f147196ee05234ec69a7db2ad2563b7a0cc023ecfa4a5313ca6d05c826a206499087a639dc463c45f9da410f9d39eb8a14624c286868a73cbc7141870b52d58e86a375d63a4c4e4ff8f1ec164921fd91bcb3b38e2f16026dd27628699e4b15c22a885e516a34c6634113030c73770b4581a840443b922c084aa8e4288c1a34859ad6a214ded6da3e73ad26ef4f1cdc46ff02d337f1d30149f23c80dc9a870b234dee068550f814aa44b107288e299187659cf0427beefeb7bf355c7a8fb6f77f1f4817f3006514c2184cd74dc8725c85c1baf158385a1145e314a617ac4d603c5f0435c0fcb640ca99b81d9fefbc1417a8471521b82bd46ca7532f15c5f309be90c5fde3614ba4b86bbdc4f325aef5219dfc9ff8f444ee24f7b589866bd352107d6a159727c02a2479359ca5769cc6fbbd87e6cd83fceba92b7aa0e51cc524c77244955d7647615dee083f6b1a88769c415698ff4b6ab6c010eb87ed87b14445dbdc8119dfa8ed0aa08b46a27148793a261616f85eadf5ac08b0f40bb4f2c5339f30e6102cb45b90f2c45e4a5d498458564236f0659f5c487482c7fbc73be8add2266f62884e4b4da06b289211fb542e9eb75155f85365732af39b840025dd37a881788a153537d05c8386e7f55bedbb9ecb22aa84c58c9296bae775b3bfb517ca4dec6b504a97b677fc8dd419066ba06ff31ae2e474b1d6cc2e7e833c1e439e437a52d006bfcd677ecce50d055c89eb3cf65ec71d04f8ac5d622e20b421d2f32520bc57982f84eacc06b0c71ddfd5a3ab04eb9978ec4e6655427d84138315573a6f1c8914e801a7bc717d97e91726ad167d9b107cf2b218ff2b92e92ad09486c2dbee63bd27476989ee228622cf4ca4a58b9c81b7f0dc3ecd690fe1e6165cc70b2b0a0483fc6838d5cbdca2c8b650c91a4316c2637618a4eb49c1f84a3b8160a3516783b059b7fde71fa00e5c4eb0c2db7301fabc57622b25ed102ad53a6f9f63134f0fd9d184b47d8c3b315eb2687419f848459ddb9b3867c0bfcd926f395da20f9986c0b17a6327378c644969b8485ec27ea974d6b610da27544c0644788e18279e97821e161ea8c443077793573d4ae359811bc0ae18c1199320cca044afbb4420e821228d4f66c0d887a8aa920f0b219ffe1f73ed9e08f27bc9a43d904bafc98a262152922220872ecd088925a1f36a234cfb769e363b3b0a4d62cd1086216432d514ac2e1ea36dafa58845ad66511f2589ba3b81532d70d36c9e4f7e92afd02ee3f0924035ac051bbb773ea1af86ba2abc8b1573b36e7375d0c6180466b9abc14dfdfe0048478477cc2cffd18451c803ceede6bca111427638b78483326f2c3dc8ef781a1717459742da80c992ee84f6bd66b68bdb34ed60ff1518c5e0a194236df51cf8805c3b3366efdd3ca88c42b43658e86acac1ee7156bd072e29a4c3f3f3c5847745705796835b70bcf2ce0740c966f10472947e97789a0cacc6917c135c85144ece31cf5716062a1b535f1698cf30b850fa5025793eb87128874dca027ffdddcabce693dcd65e3de8d9414c73b882802d76471e2f6b8a556d0a9cd98c15d4f1583c2e8f13ba4fc01dcb621dd473129802f1bb47873afb0eb6a29f8504b918bdae4efc7a6254caca8fc430327f23b7f0a97d33d8f69185dadf1666d1dda613b53f10461608b4c2b5af982d7ffa74a7780aa0f52d5d72a03e0bcddc9378c1c138ea9486f6e6094f136355c846607ef837cccdcaec95619e43955a59bf00ab66489e10b82f91bfa2303a58cacce665b65fc9dd9a4039082fcb07a292ffc7500cef0a61067ae789a2c5c57e17cdd02794b2c428a5578a322b98dff21c0d5bcf84d774ad784cdaf81b150765052cf8be259df5d10c9adaba3846ff0e8ea285962f8e49520400528c23aca6194e87ee4ae33e3ad9a9350fdf4874a498dab2f1e171903559023c03ce5ead9b0398f5e2513ebc7c515dee9f2c74c7a865afda3f287d7a5f9692d2b8a649afcd31ebb8a96832b2ac387541abf7ecd396f30766cc60d559295f8ac7933a100af05fa26f24975e992dd852e66f2c2677a5fe4210b2d90ef3c7200c8e1cf802c9d208b9a622ace0b5e289879d6e403a37a9d1d5ad39afde71ca00b1e30fe44c81ddef250f810529c94241933827ee0c1219263e41990c9d3ca226e9110078390a3b81471e62207dc159a90318fb7e125f24fc097d286749b5f34d859852337078d1a3545e2cf4e57232f441d79652443180793ece9972ffe81033caa5e155cd1edc27ee3066b24976e7be9f7fd2765444f0d50a3fe891e2b35002bf6f848c02de8d78d1973f96d21be3ceccc214018f6a17e7f82e64061d04951a5bfa2edc2bafde95ae9fd6ac7feaa70ad648f7bf97d0dd01e680653647618183bf02ef2c5c079277fdf6fe1dc2b588f704d6c9e3b0d7b13243e3b9fd397cac1dd66da000731a3ced79f334f794e802db81199b133c3423d804837c614292190d91e4e9524566be058431225b8d1d906a8d0dd84f02d6178da674edb8baa75a7c91f2d30c1ca6dfefce98909b293a6819e292cd402b99d9d858452b371d01708d7ceec73e0c9f9c2fbb1c00194b7c2a6b98f60bdaaef226255294936d6f22643964a0f57dbf34ef5a8ad644893cd466300c2073e1670a5f06a7240c094e12dfe7db3d6e464309cc366663def9135f23703438f7cf361a8e4ce203becb40b517fe52b096ee65019ea5feac50e0d009423a9440f0317db1e009a5c5b58ebfade42cbd5dea515a1211b7e18f830257bf5071a5057ceee191b5e86a97b59ccac3a6bef221ca70f3ea7352923c654ae4666539be3c11fec55840c3782a7c0bfab470df64b60af68891e3d9df510dfa5153bd459afe876f07eaca74d7f2854bcdd1888c3ed14e9b118cdfafa4ffa9b3f1676b190ea6aa8f5a0abe3af9f397d0eb70a76dbd901889ebfdfd9cb8fee9bad1f52b3dad193c708e627ff089604c27bd12e3e7f78e8aa5f470d649e312642e7a551c665bd1faf6de82e36bba8f95a5206297ba6f0a0b36da27ad7d1c72accc61757cdb279d204fef480d25d172588624552b8af193d87689de4b95767c86b8ef922930e4d242b2708474cd8480d6e399d5ba0685658e3923ff3e51e8653da6eca5df02e6971488c1862df9833247c6a7c570b3be240d6ff4d67086a78439361a9d1edceff7e481227541776958c94bdf57145ead45c2e9f89db843da51a24e835b793d1485466e97433a9ed2b17ccf2bb8952cc863bbc7152ef7bd9b8f063346623a4a8ca69655c171c495a8791ecfd5fc13e3202751d030706e977cc67796bee9126e64a19fd1743a49ed1b1fa74d3df36cb289c539adc7dbffc3d45a27ae1141ca137172ef1aaed0716a6ac80f9c891f3f757bbe9f1b2c335b71e990e026d82128214c72d4ce3d721d47d49e079ec55200e9e90281c5bce0b00cf497f9442c40e870bec98d1f165262010a9a795c498226e7dc4cdead3a4b10fbcab36abd8291c7bba4ac2b94de13eb4b3813b5e7e046bd7e92a08d3d647931c1e901248dc40723781a18db443046f035be4f259dbb89ed25a0f5dcdb2f6f1e5a5062d6044344ee3d3e1d0b674a6f4e068dc9db0af5209e0cac748a43644121cb4430f342e39d58a3f957b9116fba11753ae5cae7ced75bccd226d0319f5fe654a7d5e74b86529865617332fb1399f602f48b0887874efd79f861ca720d69289f070d668bf0d1c49c7e38642937658fc0d8adf4b4f22dff07149e41ab1586510a490c18252e8b463985fbab5890c188e23cf021c0b7537b7cf08ec3e324ba775cced8d33bb04014eca03c8b2a48c2f62d30aa4fca8d6d58db0b8a7f9f0ba87fdf9de79b4d51905329d6cb8c0dde7ddafb807531094e980b8735d1d5337ec15922bf34ddd4b2eadcb75fc3bbe09f3b6c5455209c2f18c8a47d010eb75712db8fbf042b3d035f7a637658d75f8ca8a5bb63e12a19b9f1d22803b7fb232225cd25e2875821556651d8a9b6223a834fe663f04989f62b0b7d033ae842858fbdef334806123d3b420e60d3ffc14ce32892a5226c5befe65479c2f61f4924234b69f1df016248831b83a14a64d36ef8f9b7213344a2c2df7a9bdd9ca7ff9add47cd7ffb20bcdcc69cd078033309b386e5ca24dd15b853ae50579429608143a685b2f872d0e89676458a089eb1ef713e28f8afa6c970653d2b03aca2b3aeb1bad1dc0b0efa29e9d52c5140510b5b78a265114e5f72839a25a02d56cb86ff0f0a8f6acff9e3532fe4873d675fcb604cba1ee3b09d8911e66453c57ea7b960ba9af0fbdcc7d33fde2e32f60aa02f2ac0bda00f8f8b046b23b26bb8c8fc45e0a6ef4493bcb2bd06157466ff274679298234cb116a07a330e43a98f061347de9789bdcd150689ab30850e68cf8191345aa5a8d493d3fcc0a9704fc8bbb07e189ad985df44ed51fca0c24b184e5a79b7f313d8a86c0280e2a7355359ea1ee5cca2c6b7059edcc41b0464b9499aa1301865e0d730c02e0abf4c3d7aa862e89ac45e1bdd5aba27dced353cebb0363ebe4ddc70a5f1ee3580b9d75282e77fdf471cf5b54dcd72c89d6322879d4a93696297594e02f45b9e20e1ffcf8636b40514ceb9e32b197b5594fbaa92455314da93e532cfce0c0eac72382b07fff2835d5e3b95f0d984bf5b7bb1c92e930876a327a564e3dfe97675688a9484544e9ee908992744a4f9578855ad169df4a0400cec0677b0c36739e5ccfbfa632d69fd6a8ad6332525ad8e7ccab147d440b11e37c7006a13395eb2cb2c82ecf6503e1230e7667232c6bc9dda042cf81c53c94ff1af26189239ac444a4e601b8086047cfb9b8fcfec9425a886f2a688a80a5fd80a9c54e9d7ae655e339427f429cd11bce931a7b7317c8503677ecbdc154bcb6ff1905f4eb77e62e75e50f46a4aad005e3f8c5fe7778e04f4c1473050150dc68ce1f2c52f2c9e874750eebdcd318b9670c99b198c596d351396e592346c361f70363d3d9a66ee4942f77249eb5f87084332463a128ae9fbfd5df5b4b86cbbd392267626330c3163885089b49f8fb3d381a82419da29c59653667956decdef1430aa4ace8cd154ea0b3f131707f5a255ebdc2e16d4d04888774519aaa5973d794b743e4c5ca885269770ef3ab2f9b64ca11b273945287a1b5e2d1d3547ec29fd45f122c7ab3b24655abfb41aa446149beb88d317b69be98ccdedcd8c2f05a0ab53a7c82b8422704859bce37f2bc212671c4ef769ea3fb8139039aba991d029a4023eedd4a5fba23d8f13e854fc2d6edbf227401e250cb014589468a62ec5521b96f760248cf339b7dcdb02277d827386b6dcbcb4bde0c1c7d561380bcc19e26f4399a2a2a3fe9411c007b7fd46736894a8dcd5b7c5934b0aaca3d7ca88bd79bd6c6bc209a33c3c4db34a1d59f6a81f67c303f95302bc5414419c089a321abcf5c3fdacb4a9bd7dd4f8dc9a92f4476178b94bc10100ec53745aa2de8fa095093a8ec60f79419291081771afca53b11618b2940f732fc1a76baba039a9fade6856398a38551e83b70bffac42fc5eb4c3ceb98e432239cbe2ca768c18dd0123f1189b1bacab04afbd347d852668d916fed52c4133014f2703be4204b1fcc61e4bfe8f6b34d964a3e17a71d172bc70f9929d0997fed6218329fdd84dd39485eee9d67ce151385b241eae3b10af5febbc12d312e5d8c6725e5606bbc5adc498b414491052922d0e1d09db4b129348a3408e4b9a72c3ef0c7fb6b689523fde07189a837cb18f68edadd9b408fe3e242a7c73522e2c9043385b1a0bd167ffbe73b0960eece09e87b16a6f4f858038e270d9de1b33f9d28c36d55c6b5b5f021aceb784d762aa5ee173d5595d64f28e68e3d3f4b02f0fa289bf3f0a6a8c1f90248d427116b9e689b8f74240c59c6d5fcc5147e8a516140ae5a32e9240a3251a564078e73b611ef5a8f8c44c9188ca904c8f717b44ca8a85ae93d6c2d289484432160f84fec73a543937674cafbfb770523083b9c79e33aea3b822f9ff244b36cf7e196505444e9f6688b2e8264d39ffd3bb1d369bf063855cdf7afc4b5e54d80db36059418930e96866bd5b1b3c351336e5b5f79396ff0313476aa2d833c1fdc0a9b70ab10be1bb7de9abf508e17c6283972cf282cfea004420171f65feb72fa156063c1603cdd18db8b5e72542643d53e8f2f5e466765e5c252f6104760f983549f70d222c6f14733ca8e56b55f79aa0fcf5798e67b30e4b2bccb51d563b43dbac61be11642cc07dccf84270bd39121a9e512d52da7ac4edaa64c7fb41a838de150607f5029f26e16a534779a3dd1cc90ec98d7ee4f4b2a893352af3fd3ec4a2aebc57e4785ebd2e6a270770226f50b6a6a12a39af28cf2ddee569437c34c270112ab2095bc757398144f2c3879bc38cb7157c20cf1b54e665f6a1c2e689b907fb2c5062141dd908f134e05ccc1285790eb086ad3b58d8ca11ae0b8fb4c9d4c5c0bec313dc7c0c50bdbcc24b45d24ea8c744c4e7aaf0dafa6cb1f8dc41e318830ce7a23c9b79ad2c5c63d39166a1b6ea8875e9ef6b5748e5b957436eeb37668de6440a86d991e783d6bdcb403f4e61482d75e837acc7e3d95199fb56684d8e2314562b70e46e1392d3dc88919104abbc6adc70885e4f21a8775bdae2b2b39815f8649b650e02a76fc74b5619f85373c14c5308e60ad24b1e8b43a2780a25b7bf280654cb1a23bf8856fd0dac6cf2f311bc4e62ae49c272ec6390f66a2ebb46a3f789d2a1ccbc8152c9ba5a66b1ac2ed662b17d33e96baa6f823719ef37a5ea0822dce0d2ab19f016f2229b8d42f13f9de9bac1ec78291dbe4a4b68357d754f4261ab45c88812b9ed4d4bc075d98af37c291ff0a5a9636047a48b2c7df702bba07c6ef889cab1cf4eb0f014025b495f419f6d9c40ee4ac64df5230abcb60a63aeaad02daaa2dbcc0eb4eb81ed3d0da11a0b7d4f917b90bec861d8f715399001c6ed56d428a319d40dfd25ec464bf868a458dc4a476b8092b8f0a0adc6b0ef3500fd8d26cfbb33200335fd23be79541dd87440e696504a7128c7504b1b0d3b65350b0b9346a7fb2459e77bdcac2b0f1eacb4ade42592f1b915e7c18424c744eb452c1dcf34bd35c60e14609e4babf9ab0efae82289a370e4abf3ffe36531acc843d4a7be576fb2c9fda50ba1370833956d54e423b640a88388e1ef4936f7c919862bfecc73f34e73d6d4eb2e3d8192ff2bd20b8420704876389f1a52d926b6a9723da414f74cab8bfb15a641eee816467030a967bcadb0bd6a39c14c50b028f2be52b4e8503da75d87e5d36cfa5e8c1ae21c0ba90597015280f3a13efd0533eff869d87776a8fe68cadf3a73c3d7aac9789be019c8952b6409e0b84201eace271177b0ec515c8d863a409d1ae34ce6cb0493208564e9fe7f23eb34eba62d2bef7da98f62b4a2eb796900e19ad5622b9674f70b892466e1e346426db6f90aa50c835591031dd751a684ee61e2f68194ad9a9627c468c8bcf0f064b703b9501314622661442a9dca84cbaefaae83d5b8a9754cb4808d4a62aa10dcb58a5316c6629d7c965404c16fee6dbb32a085e0642e2ad6d6bafce845074d51b9e146547f76201b4602dbc79dc8d9f2432a9ec91dfb57767e6f069be511a574c98be3d2e0c482b21d757d3da738aceded4d4d1684667324c662c263a6e0965fc70cc5639b1b536ad194f2560d2005000ef993acadb958a01882c3b11ea916c32a78c4f44af969561807016449c7558b27f9b048ef59763c0b7af8a9ae3a4e6eeb27dda303b61e674b7b7676a8b18cafa8b1c36648b564974167269f4298f226e55104c97bc5da73444e1ddba656a6bf2baf3b936c53701c7ada2963bb23369bdc6766cfb5e2ce1b2a012ace60bd4d457eb560d1240caf75fd7166806c563fb26ac531347002b0e687ed38d283a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
