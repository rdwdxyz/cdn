<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"afc86b5cbe926db9232cd1c535731679a09f36e46ea581c71dffb4f7e86c5fb52f32321c0d76624c5682d8be8c1f7b7ad5fcb49f11e3c81c655dec0680ef195e49170c369c49df17420b5a644958dcbacbdea61b98651e989e9d3db561595c8ce8d16057760869af07f07a5256636ae961d01d38b98c58b1124c8fc984a55ef7506e4f9978eb7a32d7c7b84a0e293366a07c636ac7c613ca790dd7efc99e46231c1034e54ea5656322b5ecb0176dd42ada49c38b2ba17d0b5096e92c96e825f264f7bab1879aeffafa8de1a8da996cede7bbfcc7b72809575213c45217223dfecb651bc72997089287cbb6343323a2718f4da951cface3516edcc3a5e75a0594053340c585104f70d148047e8a6955936f51d3731637e79af70a3ecbdc6b1065d6c6704f23741089e69e4d9969923e44ebb77fb2150333a2a1a300de4f8b6d3ab5be32b8851e803208f99d52bc1e2aa57b17517e0cbb2602b1df729bc12e0476a7fec5dc299c9e35aa41e84b7024a9ea97b2bb4b1fc28efca73e62d482f275c58f9b56db84b0a83c9f0a92561af54a41378695d959c8dfcbb4cffe911f3299be5cbd8bff4dcd1d5d87faaa3495fb714381570ce10e8d37ec3b2f59e7e9e146e5bdec3944af682de9cb895a7244038b0de240025b2c0d4963f90454edbe56bdf58d655c73a81d74bd407daad1ca1a3f5ce079a0d9779993eab0a7b5dddb002c6331718526111e6ed3ac42c6946ccd9539f942cf5466a359818fdf99f6e3f483ccb37e9c94e674868c9ab385e4bceaed9f7bae2d8ec17880cd2ae516c7cde9cab416bd56ac27cbe9a0fd28f5f965eb31987cd70ef65ce1cdc90a9d4380f97ad7e494e282bfe156dc0b76431129456391adc07184e8bdd438b53df2c3557dd1d2abe4f4258bf75ae3e6060c7cceaa0ad7d689aa0e24433100c86652dd84dc7e8cf7891ae5860eb6496cdd18e3893bde47c5483f7428ca474edc3fb1385693c4ed965503bd80bf51f95ae312d259c02836423d3f07ccda81fbd48b533a7a24a372c6aa770dbba1b9b381a65dc67076319d00819d80a5202cd6adc20aa1c021a974471aee9c9fb155d131afe4b080b7a0e1ab01d89daf977f7a733dfcaa54bf7508a72981893a363e98c20df4eec25e8ad88c74d921653a5161b33ef14dafe772fb23d14fce716c224bac6ae32d3bed8f1a5d99e40c4639022d1ab65c809c7256bad67972700740dc145671e02ff25e4f80ac770adaa9b70bd193520f84c11004be200ec212e54c3a4b5b95b2bdd2376919f725d22aede5d7360a2200c0fb923d3907aafd879052ef3ecc7be4d55f05f6de38362c463e4b150ea4cafcace8e3eaf2a875dc8d57366e6a64ff002b41ccdf437151718396c38c802c8e98ce2fd239d2bfdd23aa45723825d8501dc2fb134a07b7d66fe4b64e5807c9691dcf1b6e1329c8b4bfb314bf4d07ef09bd974a2755a5ef111178eb886d6351d98287911379768c9bec73cd8e31bdb5ef93fa2221b23edae832ba0bec52b94dff85d562f15f8e662864b3e0136cdb256f93eea23c4de2326fb851f1cd88089f3350b7a82bbfd169483f3a247613a038fec6b58e0f9868eb714264657c136a0942428735f234950bccc52da8fa4e47b8bb34485d3dac545dea6506cec03eb86d92b8810faa0406136cad39e3182b365e6e9d99ed93e0d453838055dfd56aeeb2526e2f41e1b95e2a61345261efd3e5400dc438133562e30205d0fa95659d9cd59e28efde4dc2ddf80e0d7711bc6fb68e850a6bb16e973e9353e00371884474c055a3163e1616d7e8c54f7d6dc129d738439091849c8d3db736e491ce8e1efdc90f64d8eb492f5ccb6e5c0854ff7f01632ff6d06f2422cbf804b02c434805d5fdf85bd37a555cc23cf494988672d132c5986b44c452bf814cc5bc42a992d8309c846435ba453641214ee42ea244ad7eca8e04677ba46c41dab3b6a5593f57d6286d7eeaf932f2fd720c5663bfad755dc23de98dc79ada92fff7750c264bf646127df339326f4c887f2724bb4d982bad519d81763701816458c5b054e2ceec35f891eb64f83cd7949c3b338eb848e33e8b844773f609b2bbbae61c6053b9a27aab7a4c0a881d711ca7a83e55f5f07fbd4e8ca72184e87d8b7ef1cda77fbae1bf2cba5e7aec7c0d1ba1391a783b8524086cdcfd8f52fabbe9ed49e63af3b17102a8ba1b33298b24b1f5a3384238cf54e2fcb1caf1aacc4b9d091128370a5cf29613e492c4f1a46973c98e42af5501ea72252a162b090c7175eb7099467cf75a1e1e1eccb869ad6155c77d882494ce1516063b09973854dcf00847141df8374023bad0b510ccd3101607f998a31b40448cea040896306b5a0620383c93c8500edfff440b72d03bd171e9692616a04f579ca285a7a70602180dbc43df99c1221bba70469ba4dfa6a0adf223985a26993ea1eaef93a132effc95277ae8ea8b42d2caa036baa57d647100612cd06305967f5d93909505a7676fed3b50b9e726d1526901f3b5f4e510012041a95996f45a6de2d60489ce4ac227ab12a3bcba4f4a212ac6b4614177efe25ca0011b420844e3581bdb3a4fb6fc31ba8ab99c46e38b132d261e72282ca698f9a0a2a80da7b76b622e517bd016721f218a867b1a366bac22ea70795fb8c839e3732ced0ba7c99c5f2fa7a277b5a37f115112b099c83fdac0a538a673d031db02c6aa55bfc8624a13702ed6e2582129ddfb88f9e93eecc1a0ccef12064cfb41e377953a8c36a8195e4a3fe2086fd44fb4404ad88f356511e85ffa624468d3c89f8e2ed6d7e43c3575d6a8f424e1114e0f745b93f4b81f1724c49de9becf4347e21ba4919fdca14d9d5d5b688a3d0c14143d5b62ea5a547752fe5801c35145475c67cf8986ddefacd65502beeed36528a66db1927bca5de379d9d66e0b1a5b2beb43423fa5daba9d5afbf8512d862e07cb670af1e1ddc7c42d14eba7a9890a585f3ec845bce4df324c9afd34dd42353b7b464515a9f8ae81475284014dd25812b85b4d3242ed34a69b4e25a8c813a522ba3e137f9ba3f16e5bc958879b34f4b5b4afd24f88ac844fd79e4f287ca2715ef004901a89a610830fccad04811f72332e0b438f418187f95c95764ca0a34e4896f0fe479b733c64f670b63fe56ac5059dada1bc53d94a491de2a06a02126f250aee67e181f11492678de5bf2d4cd152674c27bf781308280fda7a1322a3519478e9566efe850022213244a9dbc2f0bdea15b6c469f9c9e0d1258057cf7ed5e1d0c93f005837de41cef896bb9ba03a9bc2e3ef761388582246878b72e108ff9ea073f26b6213d6eb45e9146d624e5b3f3f3a5cc11649fd16c223a81cbc56d09e5915951c5ecf4e95f0f0c5d286b2b73c390aed62e86df4c9ddd1688c88c68efd1ff5b385649302b7a462345c90344c9aa729e8f6fcf1594c4814ce33c8a29bbf648f0711605b14e0954d182af2193d8b635899e904fd2c985b85eb83cc1cac1f9b0bc1eeb057564bfa536d848e910a78cb2249949ed130a9f7da361a365e28be178143e05dc2e206e54ff5f9ff9063b3d763c049adc7540023fff6f4cf66f238ed43a9904c84be4fb59ad394a7cd91930da8d1fd073bd64aeabcec5e6518e3d5f9b5fa0b44696f04a4243cbc204032c423cb1d42f26bb645e6ed5d2b573b86820a854ccb522d3b600fdae7b0928cfd3709bf3ba09c3414acc4fdd5478ca14631b9f4e1024bab55307a698e5f6a43fc62a887f927850937d8e007f04dc39a1cfb5f2a618550e354658409142c18e06026d77515902b2d65793bf939fc4bed34af9e9cc1f125f4ded73396e84b33fdcf120f4383dd696db47c564accce57ac1825571996f7116041733b00fbc71fc07244afe29c15d9a0a1d28c153a5f7edeec4e70ab1980864899cce7fca6ece1fc9643db8013e0955803077738da35e98c97440d271d1e52ae45780830cd9e2d48ebcef4c8d88214d7daca0c6f412e9b3ca9d8db67880300b356b6696580bab9eed8fdc8f97e5150ce0ef341685721a2a15bf06ef9a11ce8b54209f11c178639dcb16479568ea0044185864442cf3182d1ebe662d108659a1eb35cd84382609ccf6f44bfab37c791d1d183969a3c2ff80d4aad92aa747db9ade2fcc3baa0af248a6b8c1f41a086c391131b4190bf6cad2025a9a8f98248135bdbc731cabbf4491ef20ffa1fdf60dbbda6b6508344f42c9606d5dc6e6977248c97150633f26f2cfa95e5feccc9e099fb5e57a736fff1fd919acb495af5de315760a7606fcb8e73a2ad8e760834ba5f4be8cf51564e021beae62a16d9ba78a4dbf4c945297446fd2c021804e88320a485124592805ecf6b40ae8ad6443a73797d0ecdb2904892bf78083689e5f482c9e6adfb334576481e1211397e65740f8eccc0277a7ad0ec26d6f3a1700dde4f14a8093cb1c2da5714e7586231c93c4bf11d08784b489be2618e62ec90cf8df0df00188a3c046b6fe957c5c3da27d51b0c48d6247e3555f9ced76ce4c5a24e5e6210520d16352f5b146673377b2934da3e79d68d533d06f88dedbe5f704f4ecf9906cea7ac89bc451f380b42c2f2812772e24606b217fc330bfbfef31d641c5de31ddff72c48aeadf5de8ba7d6694300ebfa43c73c0a6042d2df0363be077992be7a155d2be9ee3c0f4ddcf815c6117b3a5e1059c148f25e138823d8cab62554994b3f1a3f7aa2a6801e969e580a0e75c00b47e019c75a9c6ee32054dcd255c95d55ac12b057b595f830a60cb445c133111573ae51ec2adafd3f78b7e68aa52dbe0e424c3912eb32591817dc05273018094165e8b4b0b0a7f8ec745514cfe2fe0340b8be6fb2339c20dd1afd6fce490fcc68d49ff6b0bbe85799ff9088ec3da90c757bba9da0ed2484a420f19165c46d2083d48d1aebe2b330615a6941a7ab3c173a6ad067e901125622b62c1343cd803f48b6a023b9a872f929088abf5a600d4d27d39e3075ed4ea13bf608200f8c2c3c16607f87437ca033a42dbdd939b6b31f7f1fd6c35ce96d50d3d36edf60063462c557e6e2be9bc220cd5f30e76b5fdf1f6116b1f59f9225c0ff87415d0ae059f3e5f8630f984136ffc084ac4a5ae4cb61fc74a9d34c6c98f6a59355415c3b6c81bcb0d6312dfa32a9054648763d41928f913666011cf469f643e1a90150ad152e634305237e1067e27e0b7d0447c0d06965f722bef8c3eda819243989b1d67a9d0ef863faae10d6c8bfdb09169f5052297f0054a9fd5e125685dafd23c339e9f9e94aed634f5f87a220a9ca526ee31458c32828832f03d77bc339c8f0f7be02840b316c160764860efa912db84d69b8b4668e91ec80d31c400618e79f708a2ed9932838c97164fe2d4f019858793e3ec0d6c70319ca33b02cb5f7a5f9df582ce72fc605c60e6f4d68b696e1cfab292d243246e0c1ae51e74d0839793b6d49316f314cf485da21c60479dc3332edacfcba1f2337ac0296d1442eb32de6a9dceca0b85fa0caee3cdeb1056fdaec7c095145393006f9f798179678e6ddbd52a90ca026a09042df0a09205fecb0b8f93dd87f1a7049bfb9df49ad598aa4e6b736f721875382c5d0fa358ef1573e8b7d3edb574f78eb49671ecb7d9edae0ef1a42c86f596bc7974538ec290de30ef4c0fd16082618625419fe40638f8cffafddb0c95c248ef62bf209e3590f4569ec36e51d4930bc24a085b0af129be316c7cac25294d788d7b3e5c7a6e98d860a31274ef3f1d62d216f26b15f0c550ff7e50f0c3a0d2fb45cdbc1a07e097e7083aa3baca0d3d47c1e4d7472b4220a085feaa4b93fe7edddc8dca0a72a8dccc9f92c4cffe8aa14ba8d006a311ec60c7dd69b46a1e69bed0c529555a48dd782648a732e5cbb94079e7622b67e583cf433efc379ed512c924d7c8645c7097fe6598e604f0f9425b88af54ae36474a799a5b9519a9b49ec951e34f6e56def0bdb421f328c259cf5a73615e0f8643470bfe4095055ef40c3258495fed3bf4d5acf130630f41f5d9e72e89099369bfe7aabe54f6322f87c76a433b8cea834467786da04b608cd63bd6fd113094297b40c80a344b77b9bb92fdec63a7ac66d5e44f15c9b41debc3350e680c26900527ff544aa0b0c4930fb4b5078b8c6ea65d9cf105658ed657f80e9b3f635a460f41086d5e88d65ae6e39719924520abfc6b9046d76b5ea0eeecbe2431326d649afea100b84697f223583e4c20d50967409d8ad75457afa3109d8fbab9ea4fd41278f323528525e9ce90c5ef1874d225ba46344e8478b7b240f13339a7d3ddffe31ee76635bd229939b2780331ae1c6f99683ebf127370c3c6ddca8d5305523e03a55f02b535057deb110489d1342404debb71ed33a3112a7a63f1970bca22d3fdcd7a1cfeb29268d11f1febea6f04c8d2da1baa666f09d2f2db1c53143035d2833ce08e034800c999bb5c2748363f68e7483dbe76fda13b053f31889d5e33f453852ee9e2946bc668d53576f8e8e53a6000c071c07406760e7fe408eb4d3ab0e19c2d67cb2ef50f7b24c1678541c1a039b01c171b0f7d3802a0d1a596751ab6f4d5aa5b60119f7e73e04b309a2b3cc0c2f2b5b8469869e6648d9e163c8192427b2b66aa4f3c52aa2ed8c932b5f9f34f7981ade71c7f21053c9781eebcacf6a4b784ae132feaffc3ce4aee814763d466a4c017fcb0528e584cdf68a6f006521e442ece96914fdbc0145d20f09e074207572e2cf6c3139936b26c050ece4700b782226c07542477ed3371ffbe48d3f48844c082baf6077d4483101f0dcb1c61b710689aa9afa692d030f8eaabf4f21986dc745e04d43a3986b0f3ff0dfe9213c63b32004ccdf819427562190a1e7b9adcf1fb4605120bf33ca1068cdb51450eb9c8b996b0cf6518ba546b5240076f23fffc2f5db4cc7e2bebe999ee1c86da3694939a8f15c9f892244f553e90fa27c0a812390582986f42fe82fedb3fd9f778400540bfa3eab5c3f94b4d616426a6c82c68f6e6cc797c6073b2f0d8519b29b652b8ff9eedd70287e460718e55eb3b14aab8dff06ad04c726add013c6368d3328ebcb2dd0217d7407254510e0a5d29eafd72d7f2c8595a0a40f7a0a936ac79d2e38741acf354e454626ed221a0c45645764fdc78745fc2f252d38bafb4515396f9f2cd5b9447abd33e72deb1ac4f67d99a1c5c085d21508c253e0730f83c8d1eab353dbad289d1c7849ebf3f55830c603f91bbe59d5fc6283bb62473bd0ec6005d19aebead197c7f9bdb700911cd5fa142f4937eb5e0cfca230fcb2be3e74a68e6cf925f49c0683a6e6629a787fce7d1cf68c548d91085496bb0386bcd639fa678bdac902de87d17d1866f2d5230f87b0988a3b22c4e964cb36624fcacfa5efab1ed05a647ff932e553d9bbee32190ea841cc506889c4fb656f7c8b86e3e39895e6158ebd82627249d7ba7e20fb3cf9f4ed8d2a22be12d4da2507ad0f7f69f67a5c19b54f276ac4413f76e12bf75c7bdf7d8503df5a76a34878fdfbdb58b8b337331508e7142d125a291f168a597d08269175ef03dc8acbc334e71dddca48c20a3c3132290229fab8cf2f21ae5522908cd6e29fa3f46b1518714ce8fc3609276a9d1fee1ce2eaa20fa1fbd7005eaa5bed24314449557da2ccf3348e9f180c79eb6d3983be1a56ecd573350309fe8156da334c25d759a9a68fd802cb31724a11a90f80ac4d05420a96bd819e5835c77fd45ab868fad2ec44887aba73c5bf30ba7cad969d8e5c012a5651b85fde812b18a1d58c5288b04fc3780263ea4c3f8378a6de6d273a461b5f6d948405d3ade3ca0bd01e28a53f2f9f1b7049490594e54ec2270af0d28918a12519b5de2b026b3fba9381c57b3a82b51f640977abf0fff79d076724de3ad532705d1b5b66c587e15c9eb9beed97d10c66d816ba9a7541869d98a0e163a3b6449eec62318e2e23040a15e8570cc440fa4b8a9f27ea73e4351b836f33c50045e2c06d19662c9313819f5fe46daeef3b8d642cd630bcbcb54dc482199a24093e1501e8ac5d37f5f700d2861d3c6cd2906111427d5e13d3ed9912ff6d4e006e195d87114fb1453a489b3c5cf6396f50439939936c4ee62df8af4210e98b63db18fbc2b5adbb7fb45c4e25ba81079a6458d040023373e6f5113b2230030e475aada6cba9f759a902b0727801f3343acf867c5431f0fd7f4f434b944eebfd22bc43467c3afc7f326c8c8ddaf79156ff9c40f4357decdcdf986ac412556e823aad14778be5af3a9d18ff418e4394476b91143b700595e3210630565ba90f90f4ba0b411a08bc11d648705d900ff79d3ec06f788695db30ef283406ed7494ab15a60ca02bca9fa1a637f2db955ddc02e39e540b4654180977dbd9237a890f8a4f1d8bb86b1eba4bb1ea6a7a16f382f86a4b7a43d18f7a66b5a618bea4372e05dc194f53a3cf3694996d41d11d0d01da66b2a6adc9c8fb0d96fe30d29d58ba9c6467402bd7b4918b157adc9deff5e6465c58956e3bbbc6634807c68ca69553703cb241493cc0f543ef5504100c727ca670644feddb1d3d39411c508c61be0c771e2b909b21e33f5f2eb636e1b7914a86facfc9c3b4e7281c154e2d7e05da533b1baf84d25f0442575915f7f9247545112f01d7f9f3d13755ad9679f12a9488a0d9b80415f24d84b7b413b3a9a1ea9f0701b363a2aa5d8676aca585fb73ed34d722230c2b5431938083d7828af695ea76837471f24b980e884da7615614b9efbc4f86916a8660b599fb73b48ac021a70da19b75d700600b6b8c701b65b634327543a7eaf2155f222c5ae5b9eff55ff07582de3c23d62be3d2892b1d8c09ffc7c52dad6170042fe967c0bcf14fc4e439c05832b7a4173c2237e604e3df69638d464da67c08086340db3b13c8f73ced2066147f94b8d4d7e3abd45282159e154fb594aac5faa788a886adfcb8cc054cc182c1ff9c9f520712889b760a89b7e3308c8799bc5f0d1f1a0ea7ed21bb33d1b1b7ff2ed0f026b35bd3985d1ea818d8fe6be14c281627fffdd4120bb265aafc3a468bae5a32ca21b2515ac4ce86a3e283efff8c49a51c375f39f68a884bbac03c39fa786d1f9a6dcf8b365a630d160b88c08e15a07ffa6d2bb634aa6e33e45a9ca50bf96c9fdb3de28e2d9702a3b2057ee2b20090277d4af281e17fa045db34be6f8b9974978b872b5a677ef1fbdc95400cbe8e5da51561ea02a0068a2f3bfb03ca935e6a7f319ddbd7c1f1b8d99244357562c410dae775c0cca40265f6c3e38af4c1c65d226eca79d452e9a4fdc4c58879727b97c9a3079c58c363574a8c777c64fe8f7dd1ece0c888f3d202f725eaff186050bb7b92cafd3a89c6816244641a6c622c2fd2b0a0bf0e80961895ed589f8e7a57c0d82a61652b309b4439fab53dc497c001c30df631e7a442beb55d80a9a2349fdb12af4819a77c587134c8430abb47c9f9d63a3b47df232e8f50565d02ff6eaada148e25d0d7b27499616a660e96a8fb2be9301c2f7b8403db90ba6b4c6abfdb3acbea1156c9b2a75ab999cefafdd3aa16fce80866ec016dfdc7263d4a8b077b003d909ec806d1a240ad8fc73d101cd89a3143717835700440446e6ba154db35408f0f3ead38f058c481e116c1c3671a004015f504cef74ff99907a3a0ec8d570150f9291514b49f2278fa886fca38a9863ae950450122160619618d2bbcb94969d5f5a87ab5478dc97121bb6787b2380b080960dcc288bc86a0b726cec270e131adaa565ec0ef7ab14c0720a2f44ee440e76306b312ed1040c1460714b1cf880ed2fcae2fef8845131c08b54217cd2af0a9e3607fc2bc552781752ffa33ae2ecd8b4d9c57b113ed88ec6303656cef18f9559315352697bceb6b79870c480caf61f8193a8bbfcb24ae3a9b368b09578febc232c3f793d4d9d78789b99728ba053f728b2edff5d7aacd7c6bd1a0db269650c23b758e99d8d6ef7b03efbbbe622c7f2c15dd91c7f162718b203898c6039d1deef777ffc76a1b4c9938173878f8d3048957af3df2686090056651672c6edcc4f29a7407fa2c915a862ede2bdcef67832c3b19b58e5ec1c8864f1c6c4230cd07dc53109f084665a820bf15498aa86f384a067c74067c303010c4513b5eaa0f877c3c82b25473b9b66a96c07be62581dc12be0be8fb1247752571aa147e1f907a8a260fb826f676d27d40e3019b185599754005945b17dc8d97a6bdd8b659fe168341a5dcdd90c17b2a904c7b7bd649bfb59877c74ab3a07ab9dd4626b3e2367a82eb94341f7de347c6fd44e21d6afdb69df117f61c90dd873f3cdcb7c5bab1233cc484efd3fd8b14b621c1f05b5318fe888fd8c8e950cdfc64a5cc4ac57d988ebadb9fa5ddc8974a8c9250feef727b67c1717c14a0f741b418456c1ad31efb36ec59c974be01a9e4726f1c260fa371efc1a17ab48fd9102f745a1d23e03d5d981b1099dd370bd212efdf48da8ce38c95f63fed34a3e3d53a177dc5197e1f6b445b5df43cfd24a48ca5b1a6ee6c0adab41b4108c7b7289b9e4295402167f72e666ab82eeaf8fd495a1601e199b608641b90c02b715e2aceb9ce214877be081f21fc51bd88c5ab6ba65114f262f4c696480d12b8825e7415be54784ed13348c0bf600cf15cd47a51462fe731a7c4feb8be5443f86e1cd9ac0667346592e2e5a75d2fdd95ead35a7bcde483da485b18a57ee1850fd1872ed198276c4eac25f35d0932b27e46c0c804ce0f8b8bf1287525edbe9f6955f4a3c65c1f2d26f0dedaad8050bf85edd5981c18fa5fc4a14a72526186d7b6125664fe1c7220c4d7b3f1fb57d0acdc9a34d8e0bd37d8312736fa593947304a90860301e0e4e739f17340fa542053cfdd2dc519863ef9eebf456cd32bbab5c8188a64706327d88517e7d15ec68231d33e9ae075a1a7f2e28f308bb91da306dcbd935ef0fcc82d7ece6970562dbc724d484051acc7e0245ed8a2c1e032094a75def6df8d378d2635144e9ab54df9184f2235ca30cc5c1216d439d2626e25569bbaf79d28967e8794a6e457e8171cc5469c3024ebbe36757e9722e012616d7bfa967ac508da4ca7a2a1b135dd10c678387ee8e90a5619b4c074da1df1224264265d02bfa36dcc861c1a1d84bb47521986ddf68b7fe738084b39c8273326e1a4c60b8e5bb7b205d7193d17f8493a816741b5e854d4fa492f916b8328e5cfe6e85f0e2a560e6f5a1963d802db34f060671b7e2c60ca116871e03bde8ace35a08f5a0fe50e94a0fc26b04d097f31498c367f6f92800ff9edc3cf1ec55dea3de50478578b07600adf3a281f7bd7c4f52967a668758f9916f91d5a5789dbfd9735be4f3d6c5ebb015c3f8c08fc05902932a0a0f8be6dff3adbf3cd38abb265f7069981a48a30bc481a22662ee680e307b74222dfd2a6d4663cb5f6b8bd2bfb531901fc95daefa69b0de2857d58b3d96c3ed694812697697e1e2e2a6f4f38323f591c0475f811e38e57c4226cb238b2aaac5f97be949e82a73859fd2ba63decedd378c1c0e4239ca2e00553216ebe11c4ada0dc35744cc13cb8ff6e5e3883c9b77aade582ac7e774a72d04bfee6cbf531114d6ac7e91ae23467cbf90139dea095e5b88f471bab184819ae85daaf8974ec4a604b093dbe9dc46578865d201ff4ecd17d1fc7048ee9c146e14b9d880e8c5b6d5a17ba8300df12445af634e8a3811f102bcbe39eb4e6ce28a9ddbc517920375c438422b30dd834bcfb27422be8ed3dd6dbe3d466a435ad91416866b56be28e9b1cbd8c22f291bd51fb6936830094e0b7215f3788738c1ffe694cca82b8cdc647293f358da47a7c6b53d4a531b7484e3f0f5e8b1613f9f29e07df633b46634b49d094bafc25bbde85293c1ea5a7920cd2a6672ae6e71d731089ec6fb7d6bc9fc7ba187b992db1eb20e58fbe80889c17320c6e5dd506b9b59bd1baa1472eb8ec2c30cf933796c54bfc89c826a3749b58a4519a98f1e2a4c9e0987884f169a81163dd6cd6a6c28164105386c851ed93ffe9e4215fc5341171d4860f8fddf21ddf1a55f5b03997dbc01bbab5ca41315c106532b4f4a78fb932a0a5685398d04d194054f737638e01f759b0a44a546750fef6e6e2f17607e07cd10d3ec9b0c82edda808b89b55892ae1671830be4904479b7993eff56576ec458a505ef5e581c4ab140084ba2132de7099e617542b9d680afdc42c687d4ec90d57b3b474054ab05fc72c4af73f8229fd0cc9b82bc740d20b2d5cf5048927a33fcaa9f7b83a2c9c9cdd3f173eaf135f3ad4cbea05edcbda1a60638d903af2e7e53cba9e6c03b0acaaadbb8a1a09ef63b7d3da7764ef0d861942c1894a715fcfa246a5ff5bbacc901479ad503790752327655df0b4ca63cd7850f13237098cade74150c86fcbcae4f97b6e96d6cb9704ca594b610d96f1ef69ec223fd3ff99a09e58d6cf761f867825ce0cc5d66d021cf5dbdb0e22ab69908c100f248ff3035b5b5fde98aab3e17ebfef3677883bc398584206f9bae0a4efb8f62c4fef431c1183b338f9cbc13d0980f019f523dd3477a489f7a62b12f7a7263273d965204d204767950f2cb97b6df420c3584da9bdf9bc96e08d5669e0c332c000196d3a6c3a71d898ceae8811a774fcc39a25875d4cf74f1e46de20904d1b2ebfec1d46124d73019570e1e2d914de669a9740d30a3beeb61ea115d93f051a567c25fe25f2291a8582e2bc380e5fd9114dbc4e2ece08a4dbcb0709c76e33e9046056fc4f3ad6c215ad349c82e0cc91fd3f18478c6915d84887b00dd8d360e8ecf0e20e31081c19b3a787378e2261f1d2593c880cdb27d30df215eb0db46b51b9d720140d2c061b2b777d86c7908cc94cfa398341ed350791e92ccb5561eda0a29a79bf6298e43ed778082a02c98e4e5b15d28d33e8c440d6614d6198accb2f8719811f7210f1b8a9f279c344f30e125f577eec1b77316cd56eefeb96a54921d1781e8f3b253182ec857f6a0cc0d2897bd250d60b7f31d8e103d776fd14802afd50bec99ea46d66e0d2ff1bafa6af7e28a2bc07c4a65f9b9fdc5befc872093c189ec40e50a5a34f0e9e203f7cea625d93c1af49df5e16d236b47b904690670d4e868f37afb3a90984f41a6e84df2ed40d8267f15e46812b422a35cc59898f684d76568193038cd4dfbf13b012ced675fde691b617c142123da3fa8c66c24a19aa4efd207f4afe4bc8701db4b6a329a349138513455da9e236c1ed9b8c7762148fb0a878b1a0dc04e48a6475ec6d481107857da902e580fe25cf691cce4e0ee7004a5589ba81e57d696cd59f6d2a8df160c10a431d1d77c77bb93fd0d6d40258843a1ac47b01298cf28200e9f7b58d7b5bf6802ace4c80f50600902ff86e62a0603181af85c3d8b9d8497b6aef3d7b62edd7085f32e42bf277ad01cb26528ed39f5cb8191e317d2406470d164a3d6af1783ad71fa0d03691e4799ba4d10294a3e2d0e1dcbdb48927f48e9b5c77d173aa9015ea5718b484a140a00c1f1543f7e59c2c7c79cf9322b7a0ed523d435f993fd141c1a71a6584fb7efa72829c05d77b2b28862815c7a7da14a61dbe7e22ae96bf3b54b20ccd543924824f1ac05d064ed44c7ddd187151e6a80cf48a08ee7908870aca523e27f7647cfed05f2a7ce959eb2e47126f08f7e2e84326e62ede49b4c913e86c3368ea1b62e23da5d8acf5be9f81f61df5ff81e764dfe94e78f9758f9346474aa07dec1db7b8cfe061d91be180a28a9c9c3b141ee19e8f1c72f0a34dbb2fae2f7151d8298edabf679576b213d226de9940687ad97e4a36717df5da608c97ecc12e9cd25e221ace20f6e406f12860f0539c16e365d0a9af78c9c8782722034289c19688f7ee31a2c2e80d835262b2d5787dda40bd5060028fd73fefeef800987975eff81fa47507d272e980439e83ac4185924a583daa217cf969e17782f4bbc9e0e6a2027f0fbdf05dfde9f0dc0e86e8181e77bde6fe6286b005c4f27c11a9e2084db4fa8861ed020faf5b09807445d85e641cea24cba685251e2f88331871853b4a49eb4f20b885e3d6a08b883b4cbdf1b2ae02b9d67ceb4335a3b3c37a739ced48d1e76d10f71174e7e2dc3d168b8f21eb440e71b3621c8e2b5ac8bdf1d205d526c7a2f296472a1cefee8c7660a51cb430e5786d9344e682e73396591f28f622df00b6640d49d3b4131030e8f08a890f3bfff167bd8bb13350d3af7ced39e22cd8ce4852da729e927894a5e0504187d21324622507b1c842c91ed654c36761c81f3d5e5fa7ec534cd6cbb2a9d72a5d83a57ddde7999d0a83722f94cca2b6ce1cf00f9a46d3906cd3daa0909db718657854034a965e7a0455bad1847c66b4f4e71c8969b00d9d964b6ef7e5d7b9353e1b950a36c44201714c41887fadc44e0241f9e3d46ddcd11441256fde962124f8dbd4eb8f982209dc4d0cc62536e87cfb3e9e04a6b422d3456358de502810c72c715ac2999da097ca456debc5dd4548664cdfceb510b5ac124f139e902398dd519ba72462b7f5755cae6fc4d9ad69b66132c87d0abfd9ec5e75e577504d2e1e5fdf069464367945457fa464d29f836b486791cd5d617d587a6dcbad59bc05af0e23907941af967ab945c0761a2db4702c35f50d4b49212a0f3e8840b78440be1bd6bd1692c4f74bd06cb1c30d16759791651713e8a35694c441b4bdf1bfdaea523a518cb8fa0ee56859a299f8cf301d39e529a1d0ab055ef9c6ba0c9daaf77afe32e757d6f6046c423f6b5c5a92576b1a33686669203b75fbeff37898b8fe08a7d21730027d7f1512463456d326673a46c9f0f1bce883c515d5babe0d2ff6b5a2cff2f4e344a878bed02fe3b8cde5b82325e29e4a134f2c765dab5dadf7dd71a7694864511e5e030a5bcc656fc312f3c23db33141cb9ddc128803c54d20ba43cc692fe52e3d911fb7a9efded8dcaed0e8c7af5d482bfd1fbca3c93d97b5e553e0e4ad8bcb645221491ea506c685d027bfd7aedd2464708dab28d40e04ad8b167724c9bbd2beff0bac99e6bd2ac21354ad80ba12b51b1a7debef4c248f2407ff8af1ada46999388195cb44796b344dfb7615d52de248603dad4073c031c54f7d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
