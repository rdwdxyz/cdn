<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03c45a1f999ecae6f06c631301ba19eff12abf2ee70b394e4bacd22b5a58a132d549eea7141eb8c5898da554526af400d980205cddab3db1eee86f81039a565ea2f67a58aebb2a64034530270a375552a832cd7bba465d2cc13e4991b8f4898f4f0c1da19530a394b82c77daa37134c26d811b05f75cf9ad11f8733cae6b1aa1b5074f9984f4ef1269ee94d87964f83fc2aed0f7181d0b8afe3f6375cf75f45641ee33b6eee020a67e96d5f3143c5dddca651170d4ce785ac3f0e82e03398fb007f786aa5f7317843945a934be0623fb3f4c3988b3bf2d9becb5ef484192563c6c817899f653e4aa30fbfdba67353541c04ad76a6d2343bf24a49b8577ac6f2711905b90afd8f7e35fea9e2cb0674ffed6d20ffbecc96ecc0a69c1634179f05f469cae680db51e2e89c4a8c3db4ae8536ec39a5e0d0cb1eb1a501aaf25585366e265ddf2a91b430239c52643e07a46bdf8d81bf0c86163793201f41d57ec629e7270c2cd19fb319a581646f2096402dc1e05dc5edb10a7bdf7cd2425c330bfec78911415e24642aa979a3ffe265c16bd046d792fd179a439d730e222f71dc254c004ec2ad4d5834e08f41ddb531dbf5be6243d8e72be6a0393e275dd4ee1c8bde1eb10fb1bdc71a228448f33487a2b2e3da4118663aae48ec1ec0b9ee24a297b2350a4a16b7cee68b5dcd2291e5fe8d0f57b02b5c52af86285b5ba14db99e23fc49b47e01c312d9cea888df3687b9db095a9ff7c371c3ffef6b0c07f71ceaa58d0120c11378ccf95c3e8bfbca8090a8ad1d583defa79d524e526b86fbf3da6f2b211b645479e68f3b3483bf6453e0103201cdfc4869d93c9322294f74fa20d78a52fc730bbedeb571cca3fd6b60f3bb578537df7d84dcde617e28da13b3991e4a512d4ab58b87e16eb50c821eb111dc36194682b57b1049a2075eee30c6f2bb6975cfa159cdb4f67eade1747ab4006ec8f8f325f5dc04de1274452a374e8a734a203a20fad248bcf8ec0d9a1e5e0940fe388838088551cad0b185300b75e0cc7df199b639d2282b464302c5ada652171162fa856dfcd638877c6952474083e710d53ceecd36b5833bb9ad1950497f9406880d47a48dba469a8bbf0d3ece1fcd5ac8bb92ad6e515edac0060dfb840fffdbd11a05254137fe422e8f93da77fea82491bbff8c5689c7b51115ab9fe3623ab5f56e1f621f470a259abad29b58f9db1f7b9fc18599a37596eb37892907b073a79d59b6ff0a3cd5e4a5c69db43173217211a1ab51ade7c783a1c1d4a8dace4dcd67f1b943ebc1725a857d7572c7de5d389e94d9aeb3734703e7fced3fefcb9b5027abb444977d1dba79147e69269418a008c8e5370c0cef14a1a6c93496308eadae94bb7af384318811b8c99fa9a08a486bc43ec26cc41f880e1f941872b973ffd7090fe3af7f329e510e0b6f8cecc85981667bfeefa1dbd0935ca7a897b2a6d3de8a4f241b4524d08a2d45d6e3080f3743ba1436728a0811851db4ac9719133e516a239c9ddd74912ee6466b331e502a9e07cb13c6c57e4e063adacc2c01d35b7d4fcf0239d4b7cc8d98b11d255754a7591ad7f67dda94e348e41230d4b8054288f3619c54685a3859bc640e8f837c413c0ebc99c872b682ab7a92ddc4429eaefdb821b1a69339a3440102a88444f9ce8263cb724f426cede24012f3bb002a848df6d85aa00fc5886f3ae2e59481f65a8c32a5bec803ff64ef400affa625bcc42f59e36b576e70f645a713a0d4193a911e1c3b6fa2834810d595c32a05439ab20101d4b118bff039dc97f0889feafb54acd02e3d48bda7ebecb9c9c4094fcaa81d4b7e55310ec0c17541983d5a0b54cdc9ddda4f9f7c23e56cbba9b7599effe482c178ec1de464eea3c76f66e516d4c561e439d8fc63f41e6e7a3eeac5e5c6533cd00468b1ab02c139d2e9452c839c57f12a33e072ac3077d94869961e72a77fde6e93dde9d15760e411c6556e2feb08bd9e0328b324ce09b582112c475f8813971ce197016967d442d3c8a50ad180f298c30a701065c02a734dda2b5d11c0d4f7a5e0f5a5f0b156dbd8e18000445ef62ebdf67edb4bebb57890a437b105abfadc0d6f77416d917489893bd3c72f3a231f4257f71db6fdd9b268c3daa1c740f2badd380adcacf635b384443f7fdbd68d43bf7b4077d06d9f8eff3b40f25f9fcad5f5a8c248b697bbe4bb8daff14a668a66322b199afd2d19af660587d357b09553b4563e88383e1b1b5ce6f53b40fbf28d57880224261801df575f20766cba24fc9704a11dea254d3a3538701a6cfdf3f6859b3e4be2db5cf4d766e378a448c6e2bcb4259f1f04b0257b409b27bdc5885786a1db51cf5b142104e7d10a605d0a96d1c7ce13af88ee1c5b5c64b7103ae84fe593de0c0e6974c1b50ae1b8244f7933dcc7ee0ea5f2a9e0afd9b3ed6504a5fa9c53c7788e54f7a930a2f5048e7f01fe3b53ba240cffa8be6425e03ee478ae4afe62ddc9dc8b49cd99c112f5d9d019c8092fd51b37d4ede02417ed7f1c9ba2dda99b0059da66f44710949e77bd20aa4c870c0358f922ea17b1cc080070179cb975ecff3e952b614dc8969a21db726b46a83e9517bd6540152a0515e982dbfea6e10500f8c7c25538773a763d9455addfb716e9271b4cecd4074d4e466d8ad8b99a1ecedaaf63a75ec5cb1c4ae2b0a381bc38ef604f319fdad4550714245f0f6ebe7a43af0d6b2510af9d826c02007c2e54b276625b572b9036202f399e758f79d34257056a724eb2f6b332dbcda98b2d610d3fd82b540b1299be4b05f9a5238ec76b0b1cee24e43e834ffda427d444489d23852bb8eadff10130ec5483ce9d7286a20335fe907e241319fa71ffc506dab52328ce37b1b2e6ff2ee6a44ce44cb1c34c31aa58fe98879a5886f7e3a70b412ec4bd4490207d971ee8c6e59a5979d2b72da2e2670e95ce91f17a860154aede6b4bfceca455589ae0d73804189af95b2fa48befdf26e527242ccb99bbfd29b9d6a8e5c129ce2fe080c97cbc8c891ccc75c8b0b9abf7d7cadfb9a4632dbacd9fb3fd97fa19d38eece8d30a6885d1df5a675a803e7f5749ccc9d0e30c0dd00e0081c4f0eda1e713d0b1a9d1fee4965c3441872b5895de1f964aea7b109e135edf86688a91ed35de26eaedcf4984ee26b5a8c8ed7a2c97c5738b3d3323cbfcce93c30cce02e08e25e881225d8764325ed8aab61536954dc5fbc6b35db754ce973196afc779244c47bc877e510f060f234a0a62d9270c70ad8f2af1565a9b31752beb07135e5bfb3e40c925a64c8340526f95efea7e3d59bdb59fc5a54a6643b7301dddb83595ce09912766a1d4d6907659160d8ec87b45e145d813b035a5c166b9e863f4a886970e42d6bee5b57d4ff39d9aef4fdc16dd47b37144a8490bfd3fcd39a7c29a7760babf7e6e2e35569adc8a281e01cdb3a54978d9496711909dc392c852ac8c17a820814fdf19befea81c8a2ecc4112c64bbeaa699ab7d2ead442108c8828932f4b6c53535e23de9fb10819be040ee1681fce1be3b52379241cc85d4f3aa0dd4df3789269b7fa198b0eaa745095e63de0be7235292d8ec3f1682082723df5d7943601fac13c2e0d146020b88fd8818031bf0e1fb73e61a1ce310c4ff2c4c67a0fa511ff27b24eb456a158bc30f231a0fb76b44acb051879b80d4478ddcb06ae38cb57060af28df29f6e5c24f3a58cfb69221d7856e58b16c2bb3375c9f0d7bffeb4edcba0a8c660eef1e684321c73a2e99e7d1d94f9be6a15a8e92cb4bbc9ab73b86b0fae1ff3ac908dbd70283054d2524180addf675c96b26f4712f5996b62ea1caeb92aa71c9db5136e93edbbb5f736c65a315acf2b1d2b2f08681aae9e77964dfcbd13ee725203f6970a30963a9c9d58bef75f35046752647a8f3df5014e03ea880e6ca3a8a357aa0b8b79152402ef799e01debcffd28cd1458da47cff65f7867650fd944d399139cbbf44733f5ed2c6e72bad7463d23ac2900242909bd69215f1964afa7aad81436e2147da1ec6ee6275137703ea90dcd945e5308379c112b3a86e0863c7946bb01fb8fe983332f8d206f712122ce746f4d1777b2588086dd80c353d10d323cc6a556c72aa68c7a50ee95a79b9144410e5812184e3003fca64aee76fb2114263fc195cfc0a41ef2e8b13b9fb17c4c375545281feeeee58a3797e8e381575a803dff0da7de5ecd0e9fbde289fa2b4f4e48400b5d778e8101a5a67855d4e1af388c8dff96b1fc5eb3dd3913a40f5850c2aa0420aafc97ba4b5db0c096324a09f51863eb499f62c9ef75f4b8c96ae4c87c8b9f1fcedfcd4ec786ab004bf0607f6626ccbe8ab46081ec4bf96911fbc0b4427d0fd4705606d86ade042b4b1e177ad457e925ea95195022e797b11a9be282032572d64ee5dcace6c1b8f95bae8b14163ba6228260ab6bfa3f295ff7a696a3829e8e6e332fcf66b91ca3ef6b7e9a9d499b04d6e8fafe431adf0348f9fa196811f533f5143fb2d1f9a83992afda93ee4d9119cbc2d4b5ea44d3b1e5d66d75f159a8da487e1790f418468300a47903985b3783d399e7ea8aaa41b1f5c3c53721aa60a057a5df73888b9e2498d00a4ab2581faa9b4fac9953b22c8e9e04863f128b2f9615ab940b7db1014f7164bd90dbc2949bfc72ec23a0ddb616664172e79acdccc3d24d68ce1b24883514ada7c634ec555c54faa9f0aeefef33816648b410539116947888b003bf65ac9aa580d60e81a5f5c22eb8a782f0e11079a1ffbb8bd334adbc7f89b8a448f8d5124b5f0634dd49b42631c23b78881b125e93b8e5a0b8fdd41710256918f1aa930ea77a5f4e24cbb3dbca0f14f627d8cf50eeea58f52e99adf4335e088237bc4e9df421af0146f4199aed899abacb55abec294e94c8349ca74d3172772262b17f73f4301be92965ba2dcc673b381959c15bc2e4c6a69d45b3f3c088545874272676a556fe15dae0eda308f22b09ef39f24d6fa40afd0696b122fbcd4b645156993f1e2c90bcbbe26882d43cba82f42d9c12c462eda89c3c15e2769c9eca9f6147e6987b692b332a0ec101913501eb5a4f845257d81f0825c14c6f27e0a666c699625a069b623a0b06a62c5eac7ae6a8c884678cd6b2fa001d17b75eab565b81e553ba2427c23f02665c55a0cb5c915cb7599bb34389f4d3b129af7ae40d66887b0ad75d998fc12aa2e588448035169edf9e345b52e19e8aaea02453b5ce730cfed97d17cf4151756daa341c3dc0e0eae52124c8705f99645102a1f5115fe9355b93a506cb0ba49dacf8c48b1762a07780186150f5706f04e31f682e08ae004b38bbfdbef27b8e8c2903f1fcfa822b413e3d9e2e2984f7900dc535805cd67a0dc21255107dd45348fe2f2b904a26c22fb0b63ce7d991b91b90418eebfe1a11c45e35f8804a0e336d808df5909a0cc0f42ca9db07d033de8e999b82a1dea5a297b398ec1a0db8fecbb9e0c5d4fef00210af3a3ce98eb58a48ef6c2ed5f4fdc295e8187a601addb7cfc82730aa79909fe8466caec2ff23959edb98dbbb4d599024a43d9880e897a1f4accea79c5fcadc9296d09b44ae55699c7eddc0bbe5755e44834764ba5c6b27d7a6cee311d241d32a095c81e1ba043f3947c0e017e89e10399b77bac5eb29ccd03a5bc7cd2f15034c203ee27c5a703aa2130cc195c64ab99159eceacae7742d6b555adaeb232049e79111441a0dad1f75bed68345db98943c175e911e74b7b16b060eeac8f1457df70344b5b493ee939c5052f0dcf587f60bca778411346418804cec3754d7f7a2c83d5d64585ded896d724a0dc998bb1c32bf016fc6fccae0fbe2d04d5192a11fd6b43f47e3cda14198f29e7c9f0a56119bf39d0445f0224369ba795eb116da9b3332e3b15dcc151cb8980b37f72b36f30495dee110fd66a2642f5c2aa5e82b517db1ccd644048f878481fa4191283e728cbfb7cac0ddb045cd71fddd792e34feeb1503869cbd11eb4d8ea4962f080128a002abaa2f9cce86d218a482cc463f1207c5835f069748787f71aa952e5f2872f17d804666014cb55a4d1b57784ab6601d3d1b5d4e116f512e8550b1cf3556c17fdf9b2f5298023d81d727103f50bc08b446239ca76185f87468754c58822c0a85d066b8df69bab590ad94fd65f4b6cb9bbd22fa18c15a2432322f200ad8238f6fe261c580e3769f24239557fda205f6606b9e1a06277dea579c4dafeb801aed35fee5d5ac0d0fff2ed0af3e9b28a518c90656827eca2bbf609207d7e61eff3002874b18ccd394ff61af7c376028d31c666ed131b80f90a880e512361ae168ac62f1f75e2dd39b583c289c4dfe741409e5095bd430ac70a0c0984068238f116d5e489a851bf25dc0cba4fc05b1acb580d83577649fd6b86a20b605b46586ff03ce7712ce372553d33a9006055650398c05e33ec248eb0e0c6dd491434cd177dbe623035b935a66f0a7adfd905bcd1ac19fb7b9d66d4fa9af321c96bd79892c342bc0180946e438d80ca0a175771be586b62ab72243d91c93b2ffde7c1a771584ab6438b12db3b7fc918b3cc46915634b2c27c81982e5b358a7af71da81f91a992fc1c85c2850d00e1dcc5c0ac2a237d761582046d73a243817293203b8409c378efb58438cf9949c1ff02a708e26070eccf6f2404324c10ab71794777a56b6bc60b716206f3604bb663f49d50571c251e07ff36046333ceb380e73fa17374e1e8dada6ce8d74cc79bbefbaf26c7a5de63d474d14f367643eeb28db78a4ccda67c5862d3a1094603e89c4936301abd2fe88c4fc900b7d1c5865e83ab4474131949bd2f2e108dbf4f7da99378443cda1072852c3212e6e9f63d9c1e9cec06b0b748192d86918db42f0504669866ed55e240b5f06c53e25a39dfefc70c5d6989ae59639c587e3297afdb48b10c7b1e0522f9b4001ee137c8e83ec10cac41b47463ec1a2111a63988197ca5e77fd178680074c85f011d860a2b279bd61d496736d8648e24f9c6f9f513397be5b29713f70e3f965ea9a18a5a57c9fc629fa2e5a8554b7914f3ac6b294ed8c59eee70214cd04e6ed36bb427330ef9385ee0febcd4279ded39d796bbe3b56bc7345871fa4db1b6ed5a76acd3c90506fac843d0af02d2f98a68eafa980524b821104ea501562a6107110c88336be4438772932963778dfeffb063dcc3f91be45030bb6dbb3bf7b0f9c6ca052c85b28c195be632a8d4a2ceb56acf4863dab5deaacf92decf6b9e2141822ad8da3db5f5db0ab99ebc3009ae20128d59f638f1d93b942f745def4ceaba85f2a8617af949d41084c5993f0087f3cdfdb01989bf4d73c73e32789973d4d10d64d0c1720702f61a34164f964959c392db8138a2c8245b9dac81a31ae058f11ae67c69e0c950a2c5864be0bdb581dcbb3e59a8e73ab4af8741b76caf01569f32e3db2b578436c130017213f7d8406ed39d470ae16bd718c9d48a33ad2f66677e66b57b06a62712402509e2623e4558bab2c495a619d4cba42b2bcaa0971ec8712fd172feaf561348adf83bd56434cd6c4e4e28aa076c9b8c06c31e1ac610c65ee0d3131a771c9657c5aa97126f244a613630b5c5b3d9bbf0f0410c54975075a6bb3f19fa32ea8418bb57ab35f0bc7e61c5472e17e8c5e1d4c2850823423844c7fa4a08692d5d89937bb5f7909255683a3c59c9cf1296947d03c3b891d885196f554b13db07c50289033ce2e6e2c7542a068436d8a0132012d4e38beb2e3bf6e80487d1d1f6497b737bf4dcde882ce96e59e0c19f93a88d73bf28619382f92b2da061a4c1097056bcc1cd260358b00f077de2dd5c8ea6c0395ce737c8e4e1b8ab1f39e4eb218279ed2091e72459c6fd8939856d0014b9139420f7dc91e71b9f119f39a83515f8a83c38d7f360eb48738f487dcd8ed77d776be5998c396ef9a0af387f72c0ed65df05a25181e507e60f9f483a5ecff5857bef3644d66de68e5505d9de832fb6640fc0b9c4b30da842dad08bc9c102c73fa2ca1f6e0ea66dd4d801ac3998e60f44205fadbb9dd081258d83ce4d5c131cf7b470e11d2c466db723c48a6074de0a7dfd74c57a90c2ede423e78e1e8d9b3f118b488fef380c33b59a5226b33c135ae7e4cab8e55515e0e1cbf843126842ca606574c5c70648c17aa744007c7d9c25cd45e1f6f40d5c20908009c58a210f6b28bce36d4b1678e25df251e0e0a5a1f45201407c41afb0436b48c3f41cb438d7bb0d60965b2543622e0306f088f23497a279f9bc0dbe02f4cdc810be69d5894a15077ad82e85a3d5b56a24b8525eaa7f2c342f993f2b80c70526a069c9c57cf47c058f7706f896be7426b5a21fcced0d429c2ec0b954f70b69670b77e4cd70182d737b64d1a8012b7236668044365c89fb2d7de03ed4462f6ab9b01b6397b554dae96236cbbb6c144f82f33177ce37ef4e6e71a835d4ae7f757e827091c7902ac1b2e3462cc0a305b7004d61e6a70e56443ee19f5f10007d38d025301c03522623f115872398e854e409917e09dc5125ba90af5b63b58eb8a40789310606696901c88a1758f1ab7e987230671d19b4a197132eb96b4bdc7156a2ed0a50c75168b6cb79f533dc08b0d2ffdd10b1ed1553120650ef38e62909bebf835cce121477f3ae3bf238370de2fda6d6a683a17065acd8d40bd3367d0db151b8806a3aa03aa4f74ce7e4196c2daf52557c3e71b523ebab3861dd6c99e70561598bad017ce6a03fb6b3dbcf387c36907af87ebbda7c54e80ae7dcc5717c41d9f02af2e939b34cbc55f8ac7076b5ff6b84bc1a199a562f059c46d4bfe52a7ebb1b2aaa029cd47a36304edec97fd7792ef9cea2217d2b1376272d99ebf067f1319a3d03492590f402bdc510152e3a523cefa0e65bdd529f2292de660c1e000a226303fce42ebd39948eb397537306a5074df634730c084c15432ccf03e3eb582f5a7fe9283b5f7699f4ac0a6bcdc38588bad3699023b5f10cd53b31e3bcb7e27c7c6ffe637017809a4480e823bd08357226dd99e1f89e6e1d08344b548bd53c8f235052095347eb3d8393a7a2de3644cf3b70fbc614a51a6bed19d3425eaa3ed2895646c56fb42050ae0f4e8ef7d58939a6ea73f4a84d7022dcaf5b27ee1377c8f8f6d7f1695ab2766514f0f0c4f798cc4711950a3393d8df4d4a47612e7612e165f24cf58673717a68caa9b5042dc2613fb5af5225ac8d8635fd9df30410962b6dc514fe29af8e313e3de8ffa8ffa546848cb3bfa7f78668561ad5fa7db516a150d9e480119d2e1393ff075c473f4d4b497590056dc43ef331aa9688da78c4ed23bea80222eae9336384cc68641ebb60406a24254da58a3e49e37ffe22180770b707c39f00f436ccf5f496a7de8797eb637580668e312c17f8e64e6878aa8aaf3ed82d0b07688a9e13da00daffdec42ffb9c280ff7eb7cb55bfa2b21d7f8bf23af9e3354d9708d258428c3cb8766a0ec30300ffb10927d9de575c6a17422caa2a02dc10780e51e97f256cf6da7f5f5d0af1243b94a1166fc8c007f0f4e04034e1b3ecac29ab4e4cc914a1b0891ce5ef6802a76ed9a38ae0530b78892b35bef69e59f43a844b9926567dc7141e2f1af7f88c5e4e997550864584aad697059249fcb742eaac6d7fc6b2bdd8b5e3876da0c7c8a07d9b2555089546ec8f38192d1dadeefd1b0bc46f961a632a5bd35f3a87648a15f8ed9a799e03989218f020ea1eb834d2500b010e3f2390cfda3c16ae84e2f6ea471e56f18eac3213f18c60c1b0df5b46f1066db0265a3eea95ad34e5635d6f2494c25cba442fc136df2c7728b2f2b4ebf3b9f84991b22c2d1653384e313d475157ab88379a7b27cc3ddb1528ebfba453664e7404cc1bc1a60fb64ce1664dce28524870c03d54f2ae8732c2d252420d7a5b7d5ccc2a71c5348dd887564fd7e4e9960c0f09e5acc6b28e4d62943c097fbc2b28bbbb241cc6456bb40562ad033a8bb9f1b6d625753d734979c61bcb983f026f54f9b85ff18b0ca35f56f809dff0de6f6459dafe60343e15ce95df169e85703452b45acb263495cd6da5c1592ed6c684f743f9a5b08022eea5797b7d4f9ac6c04d4f6c8f855f885eb63f9d65a13bf1cbcb8d4be84c7855978426b6079e04b82582409342576ed671a13d66d939ecff7c880e783030b1fb895800c4d76d6c726da58f26a2cd784bed32f8d127e01383b8479c2b1f1b4bc888ec5e7a18c2b884787aa79a6f94f091e4416d4529534185d085f3da8d83ced1917f77baa5f2731600259f803cf1273bef6ae49c94ef39a8f11f44b12aa3dc33f8fcd9b9b2519b0f150045e525e5fb7ae853d0987d2f094ac2e000352f887a74c25adf2c91b35552331183d3d3d2bef8a6d27300d64c0892369ec8094aeb302dfce5e4f6362a031a838be85a3b868b0d9173334e086cdd7652381b9457e585f0cb6c486e7500146797a5e43458d9b9a3eaa81d0abbd6e1ce5c5381b7b6c06881182e5b14570c345d33656c91fa36c5faec372b38bcb3f7768d0029c774b1cbd3288af402736cd8e2f2471b86de63f568c3e55ae27d460be125963c0472990f0271c4adbfaa14a575f55129aac03abdd2133184b6866abe3cbc20b30a240fe02749a3649a3c0af7b3e1560840cc28241b5e66c979adff70e4472e417a29d929ca73183f21caaf6d631f8db3e7d0d25eef33fbea75b2231508ce12b1def32679f9fd387c9f923af2296e63c531ec034816f45b1f9687d8578cd7ebb7b01da2507b047229f342e3fc5d826d7aab24310284cf731811a9d6b50f4c1b4449cf1d0958dfb635c42478d54189a395efbdae398bee9cbfbec458e09a50574c0246a2ea911f37a86c508243ddb7323151dcf65ce220d10f9fb36ddba4102341ff1f26910acbaf6b55c029e1206f1a5fec7c081f72f07e5ebd8faf62e3a5b9f7e72083149cd93e68ddc271770f15a24d48d18d178c499ce785f2df4c12395f1519b5f1a84ab7793cc7343f017392912f9201856fe6cd6a6fab1c7f18074af5539fb1f5b6530dc07876a73355e3a89749b18946d4340b562d9abeddf6f3ceb5fae26f249e7e88b044420af87f9d33358b384474addde1b7cc256f63ced854dd183d4d26bf326c2c388994b690c782b0a9f60f7d1fd3334a21753a9be88a3fc4f894bfeebb0629fa019da416b26955b8166bd304f788ac7b37cb78ef93f879174e0eba5859a8119e091bb890d69703fb48ff3f7540a0bcbf83c2bb565e5a4aea2efaaca4813881caccaf8206040294a38c504d6e60e26db3aaf0665f59a39bfbbed0aa9a17ba341f75259116733017424a1ab0490509890d8aa7044a07f0a1965d5591d7584581fd0d45ad2d7e91463d707eb5aefef22e9923e22bbffbc3caec86e8c492c46ccee7ca73321b1628bf2b93cbbd67058595472ffc568a4f68d5f085b9190539c960bbd81997dae584d71be60338ac7689a5865e97895e8dc083cc7d8f1dc8413325fadad86e6fcc9d48a7737d6d30787fa10ebc86580be1ffdb6a5423cc35134871d3327b2e508d30677cea32bf21e04a061fb5d471fdbf0f07f83a7333f773279abc3dc1a65fe9a4eaf6247e59f829d8de7f8c261555b48b30e399e2f7122e68bb40a32c545943563c545d5eb270008d2e0e69d4dfc0bb9dacd7be5e430635a427c8b99022639728e836e197f294dbe950f66c8d0678c3aa3d97002a43a80434a37606cce9f77ed4c7d65a879fc51a98ddf60f0b81b28bcfa40e1b7246ddf09542a26d8995366befe09d0cfe534fddd218e5162410da3c3186c94e1ea04c2c68501be0d61c79acaf67b576bf51f8c4c6a54f085feba276ce972adb712f8c1c35a1e330504a034f8a62022198f4e087789b6bf0c5fac820940d43e89cd7bcb782dda43a8c9027a2a426f182222de228fca7080931529f01ab2c7abd6df44d5deb0f1383278d4bfa698e84845bdfd9f9b883374238e481eed94fd593612830472557ebc0bd01670fe57d16398631ef7d30a27edf672b233bbe86c15c2c0e7ac639adc183ccd6584af503cfcefee728f51344df8f580e80578d7519bac2b03779d2d1f601ac64b800ff631a3f601cd3c030d835005ff89cf441529a3f4a956fa31999d4932e8cbb1072ef80e2783ee7ac0bc43f77c3cd050f275f3622c29ef2a3fa51c6dc7fa9e5f805b2b8cbfb4576c1730e45888b18df586b7da3de3444d0003376409ab781b1bd22a473ffb8cfd23a483ee9122536cdd09f590c9fa15e0ca8ef148f0621e3c0aea761c6f41fe116601821c08c6f538cd85d0f98774fef6061fcf477d8085f3923f5640b38aa8c1994e3c1b4412848cd16e2cca8f2389f02898380276f04181f12bca4b6620760df75ea91120f8aabc057b1380c92f1a0e4e70ca5be68a35542ab8153edff43ff77050d3af1284735480664dc34fee6e43a4adc55e423d63cb736099087eb2f1ecc250d02463b96a31f61042e5df6355193f03a787eb278b56866f819a277a908835aa07c97b8b4575600d9d37adc4912cff2a237972215572f7a6a48eb044732685fa2ce61ba56eb869503b4a5d114857370f4e8a1e67aad93bd0006a4b71da529c495831069a41bf242a0ec8964c9bcf14966bf67c8732e31b24208f8392bb8f9d8300ed4d07a88b852f127e9a0e7e075b46a6c83113c1b6ade4c837c0cc9fb21dd8e30f5a80f52b6aef501fd19fa73e52feadf59f945904c661d567ca5200cb650d07814d11d55d00aba74d1ae017c9ab534250f136de9e0d1956dd5e3d65b308f8328130bbe072be42f1b7233593800f90ce4df8664d14653cf71e0ed450ce77fb4e949acf16e25945735c0cd49c82a7b3e314b537e9c377a07ef9f94e18165225b79d74ff0eadaf8229128406ec1b5670f939f0ce7815f7ac6842688fb32fa78ac1e67bd52ef12026ad0f653e6cd376e7beefb9c266dfe9f19f3e164b3a38e7463e872608fa865038fd522a277f09bde29c4db72f9d3b7bdc74963ee77467d12dc0c03ba63b1c2161679599cb0f1064b430e96c8d766d81bf75ba8a996b073b273b3a86934236cf212bb3283fcf71cb62ec8098e097d2fa58c6af1ecd6182702e93bf79c29eae21a29425befd222a5a35cc05ea9fef03ad80fd6a318b356e12119b09b6b16a8b3343cd104f8f944db8113524fa95e9f75d9f74cd45f778466ecce399c0ee1b4da6c000a696926b87f5b8a3200dff69e65649f2041cb845445ac11147b0785810b38be2de6b8e1d6f0c778655b1f1dac16fa2cc7b46570005070d289418c348e6101c5f1e1d28160b1f68951e7a4c1859852974bbcffe927ae10d2155f1eab120e2c288ce7d5369c67eb123e771a3900d4eb2763231b6bdd73d49b738038b0148736bff0aaaa62412458fd1adfb858e712f28cb4000d461de9c021b11f97481773817dea2f2f6b8d38c7e8a73388fadc9a2faf07868702b949d90370fa2e0031d6e1f55724ac7fe37df5fefe8b324aa1d6bf245a6fe3ce660f9d0d437141bab234441048384017d7e4bc3c50f6ea629bb8555c9602a4e1f20ece48cd369ff41b7f5d0304df5d78a265f3a36384008cd727b23a2b5e9f71cbf62bfc6f5cd64a61a2d5113ef2fa2e82be57bf9c92c2b12bd20bc64dad82df07e68e54023a1e7b63cc9cefef69b0e21941c0f8e390cc3d2f95487835b3ad17f7386a80ecf2a1a77f8afc0a2dfa524cb80c37110fe4d1f9239f0abb69aff36e31f1a7447db6521a1d35a42415915b57c1f941efc72d68e4908a41e318501b8dee33de652a371ed154d8099d6401469d578a4aebdc55f6f2ad493300a6d8343f63c818e7bad26b550e8aef594fcd58b1a27518eabb7f240f1149762b7736aefa9c99525d7fe7d021f663f34c096c1147cae0cee26710276315695f986deb1d80a8e4f09650a91b21546acedeb7c523244bf5cc13b74168e3722bd5c7971ece4345a9fc939023dc13a165c979b06dcf17598adda657cdc146b83aa75bcc85064b7c6d6c834b4e1ff2a905f698f24ec21869d5afff6e7b51f2ccf13d658f65675744f31a2e4c9d29f40c789ef2ef7b30a241cf3de4c42ae5a2912591606c980b7d0af2b05e1a6f2f70467c6ceeb87df429daafb246778d2c24336b7ac4368af395c14e47b02e02f9028089e909da72f59b973b2690b74e3a1c5bfc1ab01e57a91cd017673b5aa34896b2f26e3a5af7af48aa616df802f77b8fdbd8f5c548988225a80084248e8128b656865c454761502e52ef00e23786a79dda31d27da7817d08c4c573fdd2767a916c936989db09f191116a3dde17812cd28f2b5bc8f932fe18ce383802eb3326655b89b0f6b920e46aebe3553da5245a0edbae38be845b269315b2b9a573c4bd8842c6fd20a4eb4f1085fbb14b21442b246fa58f917fbd6fed479fe1e6ee2a755da17bca86a43347de0c45b24003f5dc226799b05941a077520a95b1b359eabd27cf586111c2645ac2ce01ffe01dc13765b65ec2169361815bfd760f2c53316552c99aed3671694549ca19a814e488854ca2c258e09e7de5a919e49f84d82740d2c9ea0b75133b5aae3d3f8629c1092a822f682ad44543b8cd77f1eabc45299661fa007fd4325f2b3a274aa91a86711a52c89e19cc43e6c89b441c47faeda6219677fafe7cf5906361a1780cff356a33d1c0060a90e4779de1af091e1fcf4d24638d1be0ad9dc0bc11db43cce784a41605fa587ce7a41dd16d6c33f28f52042e1de6d2afb8c83105f9781e482a75033bcb5160bc051e6df7cef3a51682b4403e8f94b52d2f9998b94325ee41463dbc4a34f424281b92102a1b5f1501f026036fd8ef39b401be54e84946a8d5920860573c16458b69310db768a15fb54cc3f4fe8d04698fba3798a71adb746570bd55f2496c1e21460f69a460b49d98c44f37c66aac69788ac4388f4cfecb19c93ec9f1fc7ab8936a6ca6d89b7587eda45f6c5e2c277533168ce52681c226941fa8b73f298227fa89f0c16bc114ee2b3f0ff7cddacf4af021cdf5d92e5f0aa9b02efb097a98ed1338acb03921b689947287eea224e47f7d96a7eb25abc6e75a4a1689f8ce0588667a645cc23f3badbb5288d9caf6f8929f3b8fdb77c615e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
