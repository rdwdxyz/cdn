<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1d70878669fb1fc9ffd5578d6089abf1708ba8c8795c24345df1ade6042508ea4482097ed1aa6f10403a0cc785d14179234a7876efd4bba45986d8122751d271abdb786a36340933935a4e59f4676d4cf3f5fc3ab4a76b4ddf383851a722fd4173a43a9c003b0dbabaca0e8f4dfad1a843f031e88b92b0dcd3f3d35d6cfac056ae0b3a458ebe0500d3fd0a9d7394670825c28470b23a26d1b24df101811003bcfd9c67f2f2ceada53ffd0f488557911fe62bec082c7697b831c2130415cd02e00df0f7545ed7282849d687a94315d25a074ca7b939d2063ae04a8e9a1eb8e895f0e02a081411d8fed253e4c41cac1bf0c66d5acd7cff0f8644b4d9d0151127e206d50338706d102240d14da0aea3f28ef2df93d5df8bb92913c5528afb34d9f031f7e406c1631ffbd775abb129633fe51d71c5f6bf0fc29c8ac6a35456bea40d42ce350f92e4c03bc9dd2cf988753f4c27daf10a2891b9d37c18fc0c1c0f7b6c3a948dd940047b39825f63062f124c5a816c25efa5d740e7337d1af4096a2fd2d98f329ea22034effbfe8b93e6231df6fae97c8fae41c89e127aa9c02ab6abc34804e67e3c9e665dd268e4e5a3e9d568a20201cbe8a58c1288becbb4277e0b057b72e2e368e4745c011f4982f647cab576a02e6782d89e7a8a14f2273631264f7ff67b032dd87e085df67bde841284bb783fa7fd1255cad8f3fec02ae66db7bdf32215561486cc5d49ca75a0cd45ae305fc5b38da76cbf420e1b4517af6ae2365b21c1e86da97c7962b32937dc9e0dc14eed4121fe9336bb13b4a1f91e834180edca2f5bcc34cba4c240a0dfd1d4e66b8ab01238a7e75fa99353a0404ba1a3af641be13407a93239fc40a720ffb82cdb03575e376c99662a02f6792f7b7547fc17e648122b68429fcb2ec068d8c4bbb91d3964aae11b3d50a8af55b6d276c4224be7c04000c9712548d06f2a80934df903049198ab0391d50184fba78a8d84708a43d677eae4fc83f9057c30c974465133864eafebfd8f0633628e6ff371917d16055218f208ac07c7158296b51a7dd90d4b734a5c5be77f4dd3f33238e9483c9f1c89f31cc8d8d3f067f6651f319765a679807ee23b7a831e617d8128259b14f8495686d21c2b3eaa51c8fff86b22d49a926b00ae7265bcebebe6bfd2bb25a9562426247c78448f04f84eea16e0fcdccc5b72413632f4915aff7248c3dfb7fc57d5ee5a97480711b6f7877476c47c3dd1fd44f9c8dc36aa1696a4967975ec420423ab09fd9b59818be49e9b4f702cdd2da085b4fcdcf09eaa493759d4dd34e961de58611ffbe114045d8876c67cb9c73e48215f66c2897fe333456568eb44565c55194b6abc5f900585ca066355136cb4f8189a10825c256dbea38d86cab1b976fbf96ae6f348143f003cfb4fad321df335239270417d6e7bed8b791df103387f8bf9be37b2f4230309716216bc33d5674a9a2e636bd64e66bb415dcc258da228a38043aff8c15b1a913797915d7db75ed958ee58c121dd1db641e6cd1a41d4deb44b52378cb2219c0476c051593fa53efc98844d7ca92d965a9771ccd569d93968fd2af1019eb5d92cbad65e8f8ee82f0e0b3ae3cc63b05fb078c6845f95946975f9fd4d1ee5a895e0fff42972c0ffe4e267b2671f30645f99a2a81b67e96cc04409f951f4263de505dc02dd6ed705e2afcc3b52b52d52a04df098b64be4632982e9e08ee7e56c9b1c1d5e7e817a8759238d77e114363b256e34802eb07774a9f000a2c5ffc68f21a51a209eef1b2baeef0adb275f90ea44119b0a2a1ebdbeb34d5c4fbaa4db046d29ec33ae57e9bb12171f3e04c600dab6900ab7e8e3c44c1f8488f3e3cc9359b13adae6954ff9c80594d9f5458c1daac2a3cf364fbd6d04105c184b70bb8285c3d1ac685b1acd3acaed1106c651c5d96abc7d997bd352f5b2ae84a4c92a5f81923de4c84ed5a07fc85c4e7e749a5f1ea4e60baa918f83d2ea7e890563ade80d8a935f9bcd996b1746cf8363a21d01ec553535c22c53586c82b47ec3c6217c56a06f5f32813c56011c7092d586da42c60b6a712cdf4375f9f715260e60b1ead50f7d0a169cdda8b03b7911ccf024d56c0642bb2f55caea3f424bcfb221424dac2129ba067c1ef0533f99fb1eed748d42d56d7a8b9053df4aaadbd7e470f3698e3efb9fc84f4d7fe893e8b6f2c6851c385e16088c05e615778e03793b715727386dca126a6e846b9d1b692d0e41ce0f21049b272a01ebf405458e1e53995c009ba1fd6ca8d358474c1a24b28c1b6ff75f6455d3014b714804f3b3a422f5c965ee68d82f799e8176cb603bb8ea7da16f3fbe8a40eff7f35f0bfa81d3d63455696cefd3774974fbdfd56f3529825dbdaf97e8459addcb13114728aa25a6249d75dac20f775ece1887552d80fd04e31109ae7467e89572099f77767b95a6cc461f18f23136aa49b8b1f9c124c3613f16277c2fb1ff34d993874d063369ce83d91254775f471616fc8bc9d45b4b96ec6dad01246bde8382dfc603b8dc599d9ce5c6f9cc37d3702a9c6aac5eadefc11e05fd3aa99c947f281da0018b56a2a2aaa8fdca46ac98af2eefbd9a30df5cc41d6bf90f7c41bc80e14c07b5ee512458b709a68479a71c73526bd3403aadc3574a8155ab322c28d0a5cc35d9c73abca39c92d6dc36fbcfa3b59f5f9c2e8570d9790d9152e6ef6dbd4b4135996495d5907fcdcbf24fd8d02bf47083ca05e07b5a864d0d08f162f2eb85648e019e8f000e6c90de0abb70329d3e0fcff1a86cd3dd4dc8cd8615422a75c85520abcd3949253d5fc523d323c649cb8399f3f3ab29655abbea4aa5822fdc0c43049fe03cd0fc195cef7eec292fdae0e39d2ff3c71b3c92417ffd19eaaaea7c6e3b1859ff9a0aca3a0c68bbe0f82b9a2d92df0e65ad7db20f0b6723d8651882539ffc7f4087da04626826f842aadf05ad96bfb264c8e5979916bf52a430e3ed7553f28099fa77ad7cbe4cb5ff4f48040dd81938cccb1d22b7464f04bb31f1a1263aa83a99735fc366e593d9e6c92c163930ed83c62b774eb749dda22f62df639a5a574e668a7794f20f264e970b7bcb1d4965cd327805934f272533ff0bf1786106e56d7ef5d749c22d00c7215e21e323b5c4f0945a4efd37730baa5a36acfecd2dbe269d32cb33a6d5100ea400fb0510af6a4beb4e504e3db9244659b1ab1eec97e820f4dca3343595ad50f83860a3189a51dd156384351beac2515984d464530219891ffa9683bd5e099ff756f66dcc71ea2aaebbf4df13eaa46e96464f14f82a9efeb96643d3a0ab992605f7722beab496ca84c4ca253e5d6d8630a6898673f2645b5546509e789f46611d13b6f9be1a4770d9c86f7d13329f7f5edbfbe70aba25fef6b5ab49cdf31b0028958fffd2a945e6726e37093cbe8bd14af36ff2e54363c066ad93ad770350a4616b3ece9e1d314477b7f0a4f6bee778184e999b2590b25b9d72f97408fe4905941c636e143f73b5d36127caf4abd0b90ddf092e57bb3cba75d3e0bb0adf78bf2004423d35663fc9d947db0388e96c3f395e9f463f72352ba4b762389a7240810cdc37d23ccb3ab6b7f4c44a71fdd71003f6a8c23dbaf1349c24119509f1cdd6fd37f8370dd5d01bdd0209994bb4fe6546496253ab59b9aaa52d0e48fd7668b2a7e724ca595415ac9e5e0a5eaf6fbd69ccc9f23964dc1ae4ce1172ad25b76092375da9b3699862dc52a36958697d56db4ec6102255af0c5282a91791595bf307fd3eb7508cb0ab8d8db94082967e7567fdf32ba3c4a6da009840e08ee5e3ad9cfa33553d439c52e14bae39632dfad0a9782521ca0c131ab1d4ac8bd973bbbf51faf3f01dd7f9df232eeb2edb4aa3ba935456c223ecc30e72294541cc15082a840952e01686842f273f49cfe99616327af69364487b7490ac993c8bb2a4d3f196144c4b7866222ad8573c6f5de47be5e2c4d4f646b67d20d031a9d9fa9340dfd7566ae8ca2eb7295884793dab68c517d3d57c5966ef4dd2f5751374ffd96e5bacef87792e93ea64aa177756c6271b4e05680dc0f9ebd2d9035c08256c22e14401b680aaf3c49009ad062c5e9d8e14f2c9cf8e20c5d25a178a0b8d3a36d145bf5efeef2d583c39749ac77b8bf3c51cf5c07697c01bfbd4438af7a1cef13217f7b27e25e142223fe48e6445aba9343c1660b251fd812c29f1a14db7d802837ee92f0fd28f91efd9f3d40717d5a87a598b4c257e7fcd014cb5596d2551f040c44584d71196e62d6fc6485d54d9b413388d999082ea9e1d089192c180bf28969ff9a73b9c19653a492ae8d899daaf79e7675a1db3fbd12d6917095fec6566e3154eb619d13ede8e724d537d817834a7795567e88f03268380923b20a3e229c4963015c527adab64933f0cffa030265adf03ef407f4ee71a03ff27d7a2088f193493781bab76f022d0146411a9aae69048e29b71e33003f136b8cd1bcf82e7c21bcaec1d7d7f4818ed81242baffcdb7a2a7c38adf3f8f3c60bb33355e0e955bfa7b7b44db0c1dbab411c0fc052a45dffa3006cf11d59707af69cabc1f72e1dee8c41151f8b093d13ce6556f5eb8f79d9f84fc8fe5019646c54e4648d7e59fb3f3a2c340d694779f4e59ff2f5939db7a4e5284e95608b35f6873dfbcc4953516f2145091060ddde57e7dfda501a42b070815f87ca493b3b44c9bdd23cdc38c8d8c94e25b7e928a5f678416bb15b0f3d9891b0dfed984d0e9731df4a4b1df34cb869eb7f5ecddd5dc6beb0c86810d1ca85e44d7231f23aa35e978c9032448c1783d5168dfabe77ad80f5e27c19c432808b272adc31ac4f56f154280e94b60bcfbda97f52b1872c6b60456a60a6e958cd56ab15efb492b0a7f9945a88fb45339f4ca3d2ab0b8840bddb884713f5ed5212371450914ef422db91ffaf2dd3089cd604d4e2e45566e9ed7418787ea104d787ec4f4a4cb96d81378ec1b781cd57d2ff6ff82712ba2d03d86987a29fc4a4c0ecb53714b9f39cd8bc9a5bd9775cee4cbfafd1342e77c8ab49df99db9a76e6645afee98e039d5595fda1873d9e01f216592cf2c5fd7c62a06d1787f5b78db88608f8d1f18dfa8edc3d916276290f2529ce9a7ccb996832236461e485ed8d3973aa3362d2c7cb9c9b8cc4cbdb1eecbf698b15569a9dce111dbec33ae66b0c82c921da972d927ca2ce8f9ac320582749e2fe6c511be9e7d715e6f572cdc7ded0d545ace592328e68ab9f0c657169185cb0cdef927abaeedfa11f443090dc2668a981af90faef00831eee466fb4668df6233dcd5f4913eef563e282747e460ee23a957016261e96a88a4d6eda27906e8a4f4b2b270aa6400df086f0e6be5d9665c876a2594a3bf8d4803f0b0d9ce978fc60e03bcfe6ac73e055b2f9911d1292bc8774ae85fc379463ec62b915e59a8b9e2704ab20a4df5eba63b85ed3d108dd71dc25452b0b3d9aa5c888dafae56a960e7164b79e3e2c6f0e5c5e593789764108511850f431f0e8c04a9c5fac42b91b1baa0d34473c9fc8fb6a976c941d1fd3605c6d44297c1c68b236f35e2ee2d3d2b2a5b8788aa220581facb6176d7d35aacb7f66f8918d946e3c65bd395e65fce99058c7b535ad1380900b8ce21234372e07fa50f194c3af989a35d49bf668db4a142ec92af5ba4327088aa4856408045affddc155bf33a1ac2f43af48893256eaac448466e7039c7df4b3f12727c441ef13dd46f436031501cbe2097ef613c59eab5119e930992836cdc7bc61dffd73b26f373144dffb0ba93cdedfacc9a020ea1d5e21d7e1c33eb47d6e7c13ed19c8c6f00977ee523ac3193cacc4545bbf3e44f885d544d2628bf574c00c266f3491502d13eea8f3ad065ce2ae19abdfd63e9223fee0ee4188a7994f96c14a3c800bae0d64007d90edc2e0c2ac1c87258639cee8b4f6b46d673417676995f81f76abba66bf87321dac18ad953c3cf259143f455618f2739398c24701abec88ebfbd4730a1d7ece32b79b892e367d57228e771fbdb2196cb5de8b80a5e254fc569b309d0daa7ddb76171e51d0b3749c051bc6d8ac598c042ee3494947653a9e9c162ae59e3a83eec03f76392f1f21248216eac6c98745e32393671f05df06b186e323f88700dddc0b9924d630ffdd50acbb03ec4843f1e9040cd44e9731a24e2c062c3969a67b9d1549f44895b44b61bc20aa5d30b8029177b90092d8943385d2636debf59bd21fef2797eacc2b21a8479fbbd5ae1efbb1e693d5d8666bc8c882f8278d03b6760a565b48cc95df3539caa31fb3516b44da04f5126326a21e8b29d957279c05d79a3ea82e4a2709bcb5e6697da79a69dbe304619b650596d64b2b8a2fadf6dc3ab996aa0d6227f487006f6a77187cccb773f169a946079adddd586681b4f6d61976a5a3b6e2dd9f1982210303cf310077bc7145c3eae2dcd07ada8bc88d5d9391ed0e1a7339deb1fbd5dd57afbbc9479ab4206b9dce16370a3f5db195d95e4e7b293cfa703c57bee53c1f8cfcb344d929bdc23b6abba93cd9afb9a16ab8b4a40bfbc9ab385f89fe090ebfc01504086fdc49b793d56c945d8c417d00e386e62f71dd850e384562d18a1f3a05d2380e10eb7eccf1e113887abbfceade131ecf43952ad392d6044327e416f6f47731696daba36cfcf319e454e8373ea703568003bbe4a32bc28244718edf42e4648b82e01b017d2867f6ebd7a297e21cbc58eb13f9074689f393ffb7bc2ffa534d8fcfd68914c315ef05540f8c49fc46be09398cb7077c3f162ba3d415dcc8cfecbc192e9660d7517f22e96de8546fab2df3e9064b4522929674256e4a6397bd5ca0e13b5957b50265c9b7a7964b72a78252eb48831e691d012840a3aafe34dd2ff6bbfc2cdd08007671c216fb362e1c1e80d04bd97175c2635ea4119f63f2c872fc0c034d936ac45c5d6691da7059ca803908921a3eded084546e8c145d121e7dca60aa331c244d3ac8f9f64a92896a7c2afbfc6106810c77118dc10de42ebb2cc2cd150b207f7cd0f3adb7b2a2386f7160b3738882f3d9744fce9bfd262ea8c001013e3dccedd4f0e04b1f8493ff59a2155797dabdbe1bc68dbf949fd1ce49cb22aacdb88e3b0bca1ee7b2d28fa61fe541ab0d949e70fad00c7a663f8b0cb204ad1cfa6cb13c04377f43ad2c2c5827ead7a332fba884bb3e3f7bf88720a887232a6e8ae141d77e5dd2d0214225055e2bf213724d1a77bc658def7706321f91fd07b1d510c78574d5bf4c7083a637fbbeb5420b0e2da8321031bb2d407ed0eb18d9fbcc5aa8f036bc66c2311517e9b44ebc8a1e0f63c390325f18221d1ffc66168cc87fc5bea0f862ba93c8127502e1213a96428c38cee4f8b53bb583d4a63d0ba93c26b33cb875610b683660bd71c8db4cd4b88f932896c4a81fd4939a5dbf79979a681d881a1eecb0164332f2823c29e2fa57b6b0842c7a1f35071c579c7d715e8e36944f1d92d850ff472d53f0ac05cf9b3476752b64acf9a9fb7d9ddc7681f9bebebb3d8405053d24df7f9f9effce762c10eaf5a9a445befb5dbbab6dac932b6f84f2209e3f3c174757ecba8c5a7a30a857350e001fe46e7d5843be99b3089b71ade90720bdc70cd5fb43210000fe171b8ce5b268b85b914fc1f3a8d19b7ef5f517602a474f77112837fa70cb913897cfb073ed17c30e36ce5435aec96749fffc813f19058e83802f47c114d95954acccf316fddf2e885449daf0b57da5dcb700dd3079b260e382f4b56b9b1d544d1c250de159c22bedb68fda42e17693967ec48e3f28b441c8dc8390e21ec0d53ecce86f2e5b6c7496590dde935db3ca7728a37af152dd698e930346e0e7e9942fb671296335838f367d917cc9c14f8dc42e25fe5c3044d53e3058b9d947ef3a5db9f3940cd9c02364da85ea7b3fec776b5aea963ee39b0c5b51c9206bead6eb66800d73385ed3ff1a0a75e46efe32b47437fcfcfc6bee552e1ad4de5e1efa5abd5cb1d4807c576e7e805370a9af8a5f090d41fefc9468035acf1e2394140acde4195a38cbbd1a4eef061422a15d2f56e6082178fad871dd51ceaae8e2ca7f3d162c73c06fc002b35e73c846f9f4633fa0e1a95dc195bdfdfb775010737f8a58207da62af4ddaed8d3cb7b456f695cd31753b570d39385fe5617f2b23974da782729e2a94bb7fa4cbb85297cdea981bf9ad1ea81e8d27f916eef55663c470356d5d579f272e3cb6e58e0f70b1820705907e75d7b1d264d6b32a2ddcae39bd195fc7234d2188093231e60ed53f1ee48dd08e051157b0f494c73f2cf4f44ed5a37da739f956f24b615cfaccde903a27fbc659835198c651c272d54aa66a5e4c7b452577e9ff313780fdcc7fe5708f88f294c58e9c1b5b440c68bfb5f4ff52d8ba82c46bafee5fc68dadaeca3665a43aeed205706657f11e8c92f2db11f77c3cac1ddac0e8d4f38a1f66605167fc6d1e1fa9f116f626a79b070a36437bc5fc26420e0553f51f46d2bca1d1370dd57be7fd7898014bd09d79b8b5f80530031fea53a7b12296109ccbeb0ee00a06424cb262cfa380ca4a6058c3065679988f1413a53a9b00a1368d4b5005e050d8c27fcd9116a5115f0f96975d9f5178a4beb4d5e23d99221730037327735a1f2433e8a1b5e426a2939087c9d9aa034b4cd1b072d0635961b4ea77eace70e33f8aae3e395d55018410ba60fa7c2c0b6d758d017174e2482c72012cf47dae62ff700605a8079c047eeddcb28b0b3fbd2c73338b840b30ef716920353bbe844254516bb367277c8cde15b9ad3c2eeab116f9b57f2c764d0de6ad69b045b32334fbf47cdff5592eb1e17fb860afd78f5eb33f3d18baa3f87843aad8703078d636677b8fd5449649da33de6273843844e2a3d0f2633c5d24160b6f0392395b3a345033eca9032feafbe3eca64cd814ca03de392121db2bb256d63759dfde6066d55ab5fa9ec1fe29b03c3c0f05cb59f688809df3ff86687524319717f4b693785549360f41ba392986de76ddcaca9d49cbf26e1d302dbc17d0c761a2eb82e0224a4e515b9e478198f23de77afaa617b3f3112622587e091c77ecbdd7b8d99f7953e0a86a0159f5c821f67e48ca5c78d17a0340f8a213cfeb50cd2e2b71223362abbefc9c02e7924b9c5d568a48b48f07eb1757d6fc701a6d7ba378a636bf49381dbadbd61d576f0d609494e23bd425041827b2ebd232172eeb1ff512d9e9534cf3580b3c6df7f0b5651a20506ad373dac270328840af84a75dc822cf26e7c880504a13c4bb3e0396891c842b988a4d0f83c93b83edadbf1c68ae763b585065ef5613bf7e5a5ded03b2af2b97a8d34da05705aa8078760eaf6f4795e32471997563176f34df51ad014f72df5830fd7a97ff56cf4a27b1ead23cf71c0bc544caf4222739560e99bb1d69b1489b84423a1fd624f5ae4f8f4faaffaf3bfe1cd9aeadca11cdd96fe2d2d17cad722ba40c1895dedb7a0d90d1380ee8b5ec5ab121fe7ce6a875953e76688ae390e6cdd13569319ee6672f805b7ae4539edabc7c65b978342a069e44f6e70da9bc017618826a0a89615717ad5def4934f65d3b1e4dd87e53673187a33dacbf9ddabd1882c7d5fc9cda4a685aadf6879bf14929464becb68e856d7aa489938c3c2490d0237c7759bf4268c95ea5b7b6537aa3cd4efb6c7e820f0e00f15da11ae069797333cdba74a00eb590f1d7137620e19a3b686235fdf27b46a339fd2cf7eca38426af65d505ca10fc3d79b5902e04be57445e23b19adaf50190df325b8218aa4a66f1677eff4062c890c36ea0c2cfbaf17a6f127b377cd78a53c0411fe0e67fe668659c657a790f1aaf67e046620320ced3cb6d5deb85e17d21fb75b6f3d0a8630582cf7b422971a93d5ad8feb61682be57dcbbc3b1ad738bd8e08383a9acdedb48421c666192cfefc33037256182bac2d60c456aecc104fff94d14d95e73e3e84c896444582ae06d049ea890cff09ff870acd07d40bcfc515cff87f4762cb9a28177df7a727f0aadadc9ea86973632703d8c7761ef66bce1d8ba144ad3fea5e226f1d03cd136ad99ccb5af5c737742a54daed043994d3315c129ca2241e61908064e5a15e307d5013534783626025521f9e68e84fa2451f115341bc130da2264a35ca06e8843ac883bc803f41345808c78a98c9fb6492ca54ed58ae2e64f029de47365cde8efe7ef330113961891a41f7b6622eee98d490613cf515a28845c7058b08a78584c04e7ab845ba02250b690ff5835cf9bc25588d9700e3d74312375132a2f82d662a807973a9e6b9d0fc20484f19af3f8d57941b21346f9928e52d6ab13647d5078586db943d08d082d48a156e355a9b3e8e52c2e5945c46f06f9bde7f1620e3c6c12b41587b5c7ecd18c8ebaffed0eecba39f0128d5564d741a10c3af1c31011bc2fbb1d92ff0d3909b476b1b6286641139e746b42daae59d7b4ba0c70434e970f6a3c4495c2b5c1380c11a568dea82a326fa3b56153dfbbe29bb3eca5b29854ea6b7f51c7953d2b3a1a4e2e0f97dc8181746d11276baa7b5799424d9c531b3baca7f6258710bf26de11a6a41ea325974595bdf1af4c5124276cd196c8d713f6cfc58835271ff9e51baae42edf5ac9136cb72e839bcb566fd3b87e4de9fcf99f789d8c32a62518ab73f599b1957378649e8052348d4f1ebffc609e0965be04e815c520153e18fb39e4432f14fa6fb153f55b14af01c46b0e7a64a577f7c2a0c306a75367b25b6bbbfe6c8bdfc3c7a746246eec7889efd43ae1c692b2990ae14fb0b04752c89007f4779bcd0924a6526414389a7216b0bffe448c846468784fe6307db11b076e11c6fe81a823f3a6ec44d4b415642f7890d92ba7d8953f3294ef14f40126c611020009d67bfcf18d261d1aa0bfffb5a9adb5bec556a569e6b7f465141f5441cc060710ce821d7a6cfa2950dc8cea0d2a0843a90ff4044cc2b0bf67699fa49a096aa16f2f0e86ee51e855896af952f0ec8835e1b3af01dea9e55fe9c72565114ee14abb327d9b7750dfaef97c16090073db1f6d50772eabbd08b825b13a4bee2234b372973ca61604ce5ab485efbfa09e4fb3ece2f5e56f1e319433dada83ea71e6ba787eb17a27a946434119b2b1e0d3e8b73131d66daededb10618a58534800b61266312e006345891b53e0ae863f52cc9a026ab28434f6b39e86e41ee191ea38fe2c6057901ee0a628d228dec153a3059f9e7be2e4f8055fa40d4663107445caebc3b7b24b7a0666e22da89b2290a1dc6252c7f485aded3b6fad91263eef3b83c8ead2f5be3646e0d6d96529ad684f990e7757d52e4bede4ef6c8d947f10b8c587d83179a5f7975ada10d4a2101982398a2257e8e795decb3d4c2576a2a7a17e6cceb92f69340d9f7f9c07f1cce519f499b02646104da47c8db52da08253cc3d6561f2a751d1407f386c93495e9aaaa5b7152a045f1be0e58cbbc36e5cbd78e8a6b6b9737a20cc278e51a4c46e14e39a46339d4b01263dae7b27ccc37bb9bc6f955ebca2786441784d450bacc17d43f1d61e1c4f08ef61d864c5cf513527ea1cb66662eda1eb82e094e543a1ed2701dc4e9bc6957a8047961e2f50c70b6858d387ff42ac63d5dcfd77bda3bdc9cde23c8eed7d6fe8e8282c2f0ece1eec3d0cb670caa5c753493383d618340cdb0aa3d00bddd16efbaa2cb9cbe0f81d3fb3eeededa4f1233b6b67a779af713b8349a2e8651a3ddf3a478be5c366f6fcacd2ae18a4eec22691adf8bb562036b02178f9b42af51e7b79ef263d6a20e0c31b135dba7b144d328004d0331568bc0563a9280e23d257f69eb5460fed6e6a4cfcf068b73aafac6847e184ea5c724f01124c61cbefecb875e80c87bd355f6325b88541d0279b996157fd97410bdac7bf8021b449e9bae6323d534af68bd690e04b16df20a66ab35198131e000e7de7d3b116353568b9df84c24999e4fca5e2d0b9bea912e7e9bd1236ecaa30989ed969180a154cc42bcbc0411acd9c43cee79cd34563f697dd7958a0b841e1406f6bd56e89970b9d1e9f2aa4ff6c040eef102fc0762d507fb641b68b49ba8fcc4d352384181d6ac892ab17e612d9e75c0c5313711c52d59fc14361d467b158d151affac6ac2d75462522bc12f319a7195bf227ebd41e23cac9ed5104b249897fac8aa93f4b63680763e9fbbe3fea4e3a5aa276e334be81d2190a9454d9643ba1b7ba162c26acf9412a2ff31f196f9c67f277a4c355c875a409ec189c891a29fbbd2375ce95971b363997021c32b116a73e6c49a9923b3b0fea546a62cca764b81116ec61730093ebe9626a352a702b160bb84c01c7ee7149356e9ab6fa4b8ed1a6d0c4732697be276677dd668ad07bd49f73cb2a0dcb3e6d19da0d32996d6da19b7431ee64ad6054afa50130ff3a062c50f89fbac9627dd5721e7cc008de2287371dab5f963317239201b9faf4072afba88d3289c1ef0337c5fd0652b6144d7b649af0fd00e8f67a71878a9f0f025ba39461a52437246b716bec504bfbd2d349004f285986ed66b8f22294e8e3431537175057696feafa0288557436b294550fa4246acbb83062b83877d6172f13933ea7df720526221f2951e0e8f9313f5eb0cc5a3fb8373ea1424212f271aff3689490a6d17ed220bef456beebaa2c8198c33c289d2d5c5bfca4ae909b671c230dd58fa1643c4de0113354fac1fad833d7cac21facd63454fd89a5272e57cbf26abc259e6af3426fc8e3e655bdadc0b196c840a8d0b5c8b4449e58e17ae331d58b5d845fff3d94479bba57dfa134a5ea0c99cbb9ea6240eb716c2402a1d7177b7bc378a975024c088f4d12ab99dd53a417ef1e0ddc283539af9d3119ace31afe1d7544a1affbf518bbd1e45381878bf3ae9135eb714aaaa34d3271a4a701948acdca735eb836c10d3a0dadd2976b037732d18e4abc9d55f747ca4c69697ddae50b62a341080cfdf2a025b5f09ef2421633ee1c312b7534d3ac7967f498c2edd1a37e78eb9f3fb59c50412af742defa40e50a2d13fc63e3d26e15badab130c56eb30f004a5ac1a40a571f11d7c0b16f358b188c20bb6989fabaf02839a84ed977d7b40a915f755182a28d2ee3109f64fc7b07ece4a84f3088ce70b6670d1c88cf88b2ab9b5b9becfadfbf8ffd6744d369a9d81bc37bee67ffdf9ac170fdd99d21f5b8c6fe65be0cbcc98e8c056f0d94da7b789e8a66c8351ac5c047002c8574904496886d043fa21e299ccf809106471411b27e28c176940b1c49da1cf239981fd674a18101db57e0d98261f62f09c6aed2f5c8033e94ad74e214e137c66fe7ce145683ac4c6499e7dd66363c957629cfa6e375110a251b8b03f1b514b4fc34f4e50df4d72a0ac850eb1929771dde0760abd08175af42a80542d3e3ba63c6dfc0f4d0e30552eece250c6ff3bc78d0d17051aafcbe41d6dbcd6ea3aede70a5cb9771d3aa330cec55a4cf92eb4127019860c823d3c3b329b80d04b4ae9cc505770ec4293378a23a3affd3727c16ffd4660cb77eb81607d3287c9b3c0e9c45744950a36bc96b493efc93dc5aeaba3ba4eed7c3a402089c858bda65cbae0f1d4c95c39e778d07abe5c26dac32d00c18158f30233c916f4fec425b22cf9d13b4ad15f3f588984d011b1e78fd26af7add55ebdf82470b3571888094eaeca9fa51fb0dad04be4dc9891dee9b5ce9c963dca2e6094aca487184172b416cb824f11a1e24edadd0707c1704de5b7615cb3488a6d394699cb475571d602ed82124377bf1a2ce917b5ed6000039cf3fb16dc369d5227034429a9aeadf289fcde4eeb9a6228281233d5e42b32796a1ff68f73f780c439611c5a1ecc467153b1ba0ee11ab4a6436743be4b53c72554d507c2f0a7bbe0139f347ffe134b29e93ff3672abf1fbf55f60ce803f245c53ca432edfbfb4b72bc70d5a499035ff3f2d52ffe5efeaedb51b9d9232feb14182a1d509ca0a5d627dfeca43eabe789c1d5d06a9d2995cbe4dac23436af36e320babf003eba66028d9a2205657299f908892963958120f014eeb351d3dc825b4c33844fcc36fd531be4e6650009b1b4dcb8b1a4546a6caa530ce783624f6d6c2f81b1b1856618a6c1dc1150bd72eab3b62bb90b491eac105a71eb8412717b78a80ff263c5e0a33a9c2345f03d472c1ac188a2fe250d855e521a7e353c1cb4f6276e18e4d7a9e10b30e647f05f1c325626858871097efad44f9b8ead1c32f3b98891ec6a98763602fe91f881db111909645b5f284e895bc69e6b90e07f60afc89931438be3cbb2f46ea163b1dc19d5aa4d6e65251f99217a4998d7242ce804a76b9ce7d1a38bb4e08a5231c17712327d65084d96581bda8fe7c48e3170d6bf631a84e05adf3f092081c8b95c0a7ad9751501b3d07500af41ac9e130510dbb4f1d3999007c6d2302f522cc767790b0979047cdf7e1f7628c605f4d1943ef5fec0d6b4f7a0fac3d596af1d707a5d2bfc039bef21b84661d84357a435bed56039f95f823ce283003dd1c945417bc059f0ec1b9f385bbe63fd3394e100ea90f09e2884fabe4da570e19d3f1c3141c0689cc9377932474c7aae97427fe6e162ca287f6bbd1cfb870f2bf6ff161ff2503e52a61e50d484a5311855ea30057b3af39bc0bd14ffc591355d05bfc4ee3af7fb25c2f4492da308effca2eba64a8268f9d1211450760907c64bc8222113dae94702b94d86cb603c8f55f62b4eacfcf7874fed81dc810f85e4f904df4e2ac233ce6b1dae17ff6da47325b9f03f9c1f8097023929c0929b8aba8c67138397170f34e366f79060103bf08b372af315dd3ea7e2212856132396673b4c04c347df130e6ad94c0a1d98be0d3ac6a9506c35305471f283f1e323c632a0ba2ea5ae597a7c63bc3946dfd85c35a577130a1c1750e5776c9ef9a142c45d06f9c7efdf401b14e0ba29c73a884d80a8c582da40af701e7f03f842c097d18c724f822d327cca4fb9c94945c8bef7b1cbd46ea270839f377dc500995c50ad3ffc43933cf3cbaaf42fa549b1a50f96c74dd25fe2682db80f5d0dd15eb382fcde5ff6b1ee87d578a9314052391e03f4f0256bd8165d470fdcfa3f615ede3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
