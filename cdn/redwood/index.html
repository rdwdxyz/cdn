<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ba12bdf92766d288cbc3ccabe45e54c0e057106a69def570b392e4141531c424d368f2f008ab795923941892c1488dc893437584db3a3c8231786891171507d755f752934719d0b71dfca80a49715dca465565e66aa724f94e5eb2d1b351d17e0c3e7b6e75c42bb79a013647eccf14477ffab9bc9b357d79b149436a07e0a5a9e26a22b24ecf9b5cbd39e508e468eb5db1dc83d43c6df361c25fde612c36063d4e9c64f361d3e462acfb056fd9d56b6699aba5001881d8bce5af7e8b2ee97455458549ecd6136eea7f6e35cd33957058681e9f5142d14ca88adc806a39208412badc6a1e01522393c88aa5d58a62ee53972c358880d94ddf29d267dc68fd39c224c4f79cc233e34ca922199f768a1e8ccb8793c1457ccd0e8e4982c37bc24da9eae2341ce1426a901ce73a2ece72570ab0ad92ce7251fae5c1734dd019b3fee014d19636dc443dc5234590c961ccb8b15fede6f3c50d6876b71471d250a78852724bebcccfce01b5ebe32edff91acb8e8da1f6a9253c78ff065de988fd836cebbc659944582780ade374c783a495e73ec27795b2cc350a931809511a7adca354a9b744770131d08971850fbd6fd8d9cc3e64f4abe88630f6bf832032ab40d4764fdb87e8f3615a77700a4d95b429d46c252ea3665fe0b7fdc66124803d49a05ecb5d243d21d62a3309fb7ffc2b42dd39803337457ef127baa106b9ddb3d23132f053c63a165cacfe84a541001f446c5cbaa9544de3495b680f7df55fea97da2c2eacc591f029770161354b299b68883e1f45c20bb0f9c9ce9486f29608c99ec98cde1a5bb99a816c6a3df28a8a5c03c58e02f2231612ca890478586bb57c2bbb9b33d10400b2ef661559868c03ff20aa88d72fa76f24f0f865bb3328df79b6af817548eb7f8620b9ac9f17f9903320cbe46a76245c0f276b139afea7c701c091f717cee0e7c9e7a3e10df3d9b37b8bff6752ece0f447f2a5df424a3ebdcd0d8340c0335bacd7385b1f3d4a8a0b3a0c859d27737d8603690d9dd3082a3b3bc3f2242f35c4dc861f25bce5d34db43d06c6b8246ca8868d47ae300731481e2e0a01745078d932ef3ba2e2dff7730f3f93d67f90ea443a7ff0d9336cdc8437cc8da35ec7889c37d18585c55c004fedeb193bcd63b93d4f7d11a9f2bf5cf213a103379378a3deac2c3e8edf4fd2e36f85478b8a452128e7ad1270fe25dd86b000ae45d06afd55192db5929d0dfccf1390f1bf08c930beeb2207de39b05660773bd09116df007617dd60f7b61ef6a8a7dcd327b94903bf0913b3cdb5524e3f4d1976b9844e16278197deed3340d2d5594a20c9d448d2d621cd4ef607338cd1ab5ae8ffdaa0a57c9cab781acaa171d10b226b2eec521bdd28a79a325406bf1cc32ce0f0be2bbdb1bf0a864519edcef86f7397b807f5f9821b0a454fc9f9b26bc66f1c9265ea3281dff47290bb93286204174d48b092e0cb52eef0090825144f4c46818a0a769abcb17d4cbee22cab14b7b0eda856969791f00e1680ef38b5fe7f66456f7d33e9cd1972dd78b5f9953933cba940e289d5d9a8bb3b09a2aab182704f90f8ea76100d7f365f5c9318b4bde67efc4e2a9518a87d52c01c11b6bd75ae06496d918970fbcea8c4b3ff000ebb1400513fe32938f7ee894ff7fcd3d236819aff9ba971db6ddcb6b8052b85434ba0d17ad6ae9a3ad091a87f3157318a24ea282221fe3aa9b37bc921ae076f63df916c8107402204fc6f739a7568d2fce4c51a69e9e7a91639b879c5e152a741922f4283b92e8b48665008e1746a34b33001b4bb839e87dbc36deb4f29bd07eccff138d30f4c364fedafc226d3c3d853f8613c7150f1ccaceb1e8f48a06fafa89f66c15db7a36a59ae46416f7a87462331c35863eee48b086f39396c76a1dda474f74e4cbd15ad0cc449443e009c848a2c33ce1b7c83296cf520f17fd65e405de381129bbfbe54c2e2040a198f17c326796223aee923547f6f50fd2ff0ab1370b8027b024ec8ac6931d1ffcb9efe9be3ac3b7a698cf5d340215c33503af71934df064aab60cd1d060774dd78a71fb707a4981f69576ab56f252d01bb3b2a60d09c9ff9055a04397b19ffb1032046e19dc380bf426536a49126a55b14ff70e10e5eeada7c9644f45b07d678bab9dea09dafa7d4f44741b8487ffd1684f3b3de7f442d0eceaa257e2f46c0617ec34fec05da71635ebb128a50ebf2cdbec2ff94140f63cf70af88da0487493b18a54d99b66ac6fbe4a22861f36b10152b09cbf4c432d38c1ffad790afb6a230f91079631894a5b4a9248ce9baad5d6397885306574d00e9b055f57fa1c6c9162eefd87c658ae28cd9157875fa2c5cc511822deb606fad29caa288e8811d0b0856405643ee65b1e8f80b299814487bf9418b4cb97ad1b3701c56c7c99ab8387cf0ef62e71a662cd2c21583248ba703d60ab3ebbffda9cac8aad8ed3836717dc7654ff1a6d74175dd010ef312c87ad0f92bb1fd7892875880e0919d4621cde3930c5697fc62994dfd65928c193dbee6dc56299e281f8bd8cb5873cd086e17858235232524a1b7de3d2e82422d4f1a5aec38fb819e0abefa72924b9c3dcd6f7a01d266813f7b1ad3f0463a872b726e70ed9b4604edb4cd4727bceb8daf4e951fbce259902e8be4b85fb158ed79b4e7f37698bec77c362856e5ab9e0ca23b9266c1991c5b5e8a78373bc989c05f110181a9235dcb9722a196c0a95fc2855dd327cf70f9164c202bd23942adbf314edddc3521b40ddce90b92ed4c145b51bf7109e4742ab586438ef3eeaf4b9a3ba31cfbbec74d202ade456e09becb16a1fb25f11ea6bdc3e1387d5037b4392d43c034effc63cfa2b4136ea26e95ee5fafd7df0e79d3a705ec53bdbd833ec7a2e3072b2ed8fb8775f14818749a2d2ea7987c391609fea74b22537a96bdb9a718d4027b65afd974744dde2e818b60cb54cabf286cc85cd96587d0ce8adcbf41c42089cfbe9c84866060be2ec0db5cc17ae5614bb5b97c735b807311519daf7a526f6892143b4ebdad9e95fc4669b0411208e34cb6f6b8cf1007fafd59fd923c254ade74bb60ce714614e0e87e9764f748506ee5c21cdf2493fc96a211e37eb7f2e29f96497fb32fd7a4e4b37c1df7787a0d4a86483e48f9779530cac986afb70204639abc58e4da45573dfff963652e2dce3ca3c6cd6d04c23b559d9190d9d65ce5a440944ef13018f4102801a8d439ac41157ab69f69a95423bf05bb69cd351ba580d51a89827b0b01994ed200c6f1fdd17ca8fda5af6dd00e006367ffc41e1258ee73e46ff0ad07ccc42d4549753e2e1f48d759c728231d33a40d9351bda63f60e2acaa1fdad2f05eb44c2b450f7f029ef949a7791ed4ee09eeca1fe683d4d29469253fe396f717c5fb8a5d75ff349e5c1fd2df2b05e7e825d04d06d9b5c1ef91bb9087518fa95781f67db491450b69b60109f9c5fd93c53e906c79a4c92481b5eb4a71366ea68cba910822328e093c8ffe0b8f5e588edb6379b7afb9c950bd9ebd8ddc00d62a0bbc1b15dd7ecdad2f41943e8008864f3d0d12485b5e4001c1bf603bc445d8cc81b647ae2478e198223eba9fd568bd7f8089b909bda42de3e4b38695d59def82810891d5de04eff08f5b9834ffc802d1204617f249a51885eddaf11febf3568bba47e63e990e01231592a08d028ca9e7be3083158ca78ad2d44bf6990e079e8aa9796faf146996b6f61922f5a40abf56b82dde3b7e72b36b70865876905cbb2a36a2119cffe6c790e13008d96a757f81b595991cd09941d13cbc2717b00a6f8235add398428be631199845159028c766f307fa04d6426e08caf8ec34d12578d866933ac2c1084a7791046b8cb183f5c5444a6641f1e3dd4a0ce2ed4e2d8e2e386ed1433af139a6dbff36958b90118948d00084016db552363c1ec348506072db06121813f026f86ba0c7f9f2767587c8d3d160bb00047719046c05a5db4e3f686c88e5fbb5940c97bc89627232267bf689af258ce3accf261036ff3763243aa6ecf9e4b64fe422a9753f795b5f59b5864cf867a6c95c6cdd125398589b9a0dc93fa15c6a07ddd0a36efb6407b464efb329090fa2f217a79caf5fa371f708c32eb42894d235d67dd82fd2d2c1c43cc58c493f9a5974d30383e67a007b88149fc0dc3ce6c13ad4c0478fb4cee6cdd12fd7bd50dfb537a117dba325080a876a878babe52bbd2dc480dfde726d77feb051a9556605e59cb6d67b406d1a8c23af89058a6c89751471dd267ee2372ba19c25fcce55f1da9ffa95ce12c55efdc9bf34d283451a4f9feb776f9c8ecd9deac8e30b6ee698e39038c154be494f23e2d0e5adc3a856342a7b4505eb277f6644e33a2fcce372e551731fb9ff87605d80776f66f64e2df579304f4114da1f8d6b80632bef72c067c27802e1b8fef7f7c7bf381137fe313419151327dc337466a28a41299ab930a95b2dea71a5264ecb8c3fbea1cfb90b96616acb9aa1d196df302222828121bc1280fc23ce63fe4cdd5ad6ee26f58264bb854893c0998d7771d517f6d0e13389669e4defc16034076da275b64b875088b71926e25e6b793ce36425541183dcfbca6efcd805b1e65c324fd39e23a5f0b336d67501f3ba7b68ca9b7377103a4e7c466044308741125b168d0b2842fbc91039bf35708ce745dfb704db9c0a855a87c5bccec722a19f790c45f4d07bf8b9f5d16308c4656e17520ced5fe682266d968b13a13590fafc88b303d6527e2f21840c1c2567ec13e33e249bbba6d3ee7b6f5c8843ffa7728b198fcf799feae00735fbec422a29b33ddcc81f07847e1f1216c250de2c81e95756d7c33aac0590caf7f642b4ca7dc0a2dba070b2a7129e260daf32d114790063ebebf6ce0ce79377d939400fcc900cea6033cd8909de84150f5266e32c7d9dee36cd32bc9ac484fb573ba97f294a80ce792fec50d548c9d37d9d183b96283a47bc220eb5cb596d918de787a121b65e6ab31c11af101ecfaebdeb7506b0124c7e43fa431cbc4d44a4494c3aa51245ca423324b67f5f2e48461375dc288c277d84da9208d0dc1a331e26bade0b28be55e34e4e11f7bdfdc5450fef9281568ad573f42614732e4164ddfaf7c459d885dfb69cb62537ec8d64707232b568615be2592150fa443873ba0933b8cb4ff1e073fe3b2cc9e789780f6edcd8f1466b14b1df37666c3cebe3fc5aa87f9c81980568a77434972008f25078dce996738cd9fe9e5701a57135e611f2fcfc7f82b560e5cce135f9149442856d8df20b28c7cf3b547f389289fa111c180e323025c9af18cc6bc5e7e966774ecc00ad83a9ecd71d6f3b0d83b6aca4dccb3f474859e2618170526b6352ec527b2d4a39748e29bd679a0284aaffeb13d487ce76da4778676a66be6bcfe853d4155a1e3e35f57eaf43eb3216021b64b1246a61ba3f919aa643997a0ab58e0809ef560c774fcf2075778b78590c197d1ba3e52c3b5a463ae454d6dfbb96d287b96a4b6a5b916434f24f2790c472460a854cea51eb710bf5d17796a9bc63b71e4f7c07155816ef27cf0a899d2f8bef82825ea0e9cba19cc5c84347828a3d3b2c81c067a706a50942820245e45bb87f3680b6377f4715a7a90f1768c9d79ee4308bb223d02aeb5dfbd6a282228484522710edc198ea4b9666e4504c33b0a70f95a18d4b4d2d479a8e4320c435397eacbac9a9b890d442b9e2e524a410ff70ee3fb66758d537283fc95f50ac5e21d1395fd2bf3ee3d0708ae49d1dc9a4dbbe4c95d86baeb5ab99ada3e7d31f3bfea73e53dcd9394f47938c916b058586cb299754d584bf144d35726997c0b7f27958c75f21703f61e291f125541afd70ff66f8df822c5fdd9740d4df67e1da870b0017112fe9d1be15c59b79823a258c017c6d0c01c9da1f6168600564fd035b3ee28c53b2452aae325b58485ef4a5e21f45f75b2467ffeaafc9fe2d66b6000908ce8166588697b2e5cf0a6e44112b1bd31960224617d08352c972a2eeb47d44aacfe4419f6223ed81df4576e45c7295474d35e6747bf56a81b5ff9d845aca43b29e8af2c29517487c4d6888ca8c5daa0e0b19c4692a24b75d48d23f27f2fd8bc33beb9eaefb05da81e0e183e168c351185be12ab53a5fe3c4d522e2d054de4269199147fca30d90ad170408ec224bb2cbca96a8854c96b643de07853301ab2112be33c1ff6afdc1fd94c22082cf4d9d7f810b292566d34e4f50a955d8cb30f93af7a538231bda6b81c9ea2b59b4ccd03bb27b6297cf31ebd8e095701eb96de2683ee8a312d2a876c862fccf7f32c91c23193db761cddf934f8b4542595ca5d14fbc981f43bc34a533e3ab7c86f9cf1320816725c92f2cfcf28cc881a344e2b404ab0e2a438140edaa952720beab1b5cdfcadfb7b3a5d8a8852cc14997acb4d09a43ce894de262eaf10710ef5211367090feb81d3bac0dbf97c2206a3fd81af38e6defe77dfe5fe7251a4b2c3800181e3f4c3d0fc9ca4f73c814200d35df9674a5f40af5ce2a2aaa7dedf195e07c0cfde8ef7744c52f595567f1631165ac06336f82173b68cab7614fc65fa56674b8f8e3b4007066596ebcdb889a806eb6f931f335409687c986df99977e7805930c410bf164c6b4c5bdb795f31882aa582ada344f0fb69794212a75c791efbad427cff1878567ee53ecc2ec6b97d44cdd9e132b9b56232d8bf84b15ee115f631f6fedd7e22562c8af8a0fe2a86f3f95aa1e6dee54074139252b851aa87e5d80dbdfda5bd457065f6cb10638238fd398e8de86be66c72802f23ffcff211be7410704a5d05fdf7d1e5ca7786f555031438e6d33d361399379f7bbe1dccbd69be3a2f3cb0f638d8bac3590be86535848c6bbca78ab09c1fc852e0cde6d7beb32767f7e51af8b10183e504dd00a78bb0644521137ba3921e6b29518124a08cc08d67a20adc989a10814396978cf43b875e1cf6e5d8468faf3120a8c1c4d3407c63adfac521245d1a9a2c7b6270f0e407c48bf00b89b900f55220f2aef1fefa0ca3fc087641c2365b76ccc6bf85eabfa4d09d42d064d3b687aae2b98f5a4cbc76285af95e57ae8cce907a9345ec0b343641459840b3f19f37891bf79110b247bf1d86295525870a2e1c430a5e6121257931eb331c422579ee8782c3d71482f06b4f2988ecd8c87aa0a5ce494e3dc99e2505f3dfb2596588c521dc093881421bbaa515f63af0c78d7feaf04d8c69b3be7d9dde0c9e4f087859843111c521c4d3850d65e53d0d75d97550d063ee35755d82ff17afbb00950f0cd3968e5f7fba67716a4333fe56b69e086f419a234f8406a960b9fdc40fda85046aa9efe23f847bc2671d183e72866f51de661cd38d894e4c32943ebc46088e3302c6a24fe018978db4adf2f5ececbe2c78128083c86171c06ec259db8a1da1a11f874ae4819ce68ec0d2450d7e2f19e00e70bed6cb2401c814de70770a373345e7cc9c52cacc5aa1140d2d4b13f6b817572c80b3fcc29f56a0844cdbb8e1b3294e6ee1fe11595af5e8ad8195bab5536d311e84761339608a5b416dd2683b117ae28b659756dedb9fffd8eeb72d995350bd810e9d9ee6a02314f967f0bed54175159c93685dd070f3354da5a4b652cb3c6fc1f8b9bc27602ecce895785e5b540fe584c1b4ffb9e3675db74dba42160d605351a2baac31429ce0d37802d89c8f9420a6762fb21dce2d0d899e7f35b1eb3975b08614baba7c7204f974e9cde54e0a321624ec3824d6f8fcf58d402a01235fadd17416e8aa8dc41cee992f04130d03257362a2814076c0996432c8eeddec6273e4edc6745c263b0e01696f4cafa89f80026917ac0e372ab738bd22468f6bf64942595daae171d80eb11d0c0bb1ee332864243ac77659c9a983c876bb76550ae21e64529c5a9ac6356ce95ced2c30e76aec592a57ff0b9d53c1702b7bd46d6d89515f90c2b91b8d1b445a6f4a7fa1b8e8453652f116088405b6a21633cf431ec6846d309af85760f83664e1619c7a41c6162828482df28f3f2f30a8a095cbc6ed03796d3a453a37aa0204cdbf4906d8c28177fcea363399481a6e90cf80ba32c15180ffc5900b751c51fc36bf98ec35198aa5b7acd422ec31357407b9948e8ff34e236724c777e77ffaa02db1687aae0d51bade0772e26b02c8d924d4ce4fda73f66abdcada8acc1f1caf0ce61de6b3b7d584c385f05f0e6e46d1d34d15274b51c8d0e0b58d4bb6808db0c39c447f6500fe50ba6362c84f097e089c5049957752a22b6351b5c5adf69198c10bea2c1158b04b0930fee7efd1698a31e3727291b68b74318c48b51bdee4c558679092a8c2b4da6a8aef5745aff4568328903253a64aacc6cd1cb4e4b9a4ec78f0443a486f10b84d985a9322ae5e9466c8f877257d33e6542d9853b1e0dcfe183049cf7f2bda2bbe701491023a4d12caaabe91b070065dfedfdb0c1bf43b114d4a1c826e48cdc57057af7762f707de3ea938c08682619419e9db99412705041041d543da3c6714db69cd64b848442e61a7da8c6bee3d965c9f096e6402aec970fb26a2262a0dce9883137f818a4d404240f1851d4c656c467ba6685353fd39f1a786dc2ce262bc034b8d3f7aacd5cca860302e63fc36f1ca35013201373581e855c47adf68c4d1c4d93add770e163e1a21812c55b4c24a08c5907298ea3a00e2813e4428daf91f83d8fc626393ce426982875f46a22c71cd48aed649f371584333b70e4936e61e23131502a2d3f5a2b161e1177ae6c993e407ee1daafcf237674e22543eb656f93ed87fde0b8277ba166c0105c940b28db65868edd776c511cbf9e93f0b07eaec40678f3651aa55073b9d9a12c5f89372073a67d6c8feb7561f4205e2d7367f9af35e11db25972ce7324e095e381ff7a2306dff6b1243d018418c858b8a1a210b79af7a7a0171d8a48276ae81445280935ff4de21977697e687879c3da6bf50f149feeaaa172e7718bd5b9d1e213141312e12e026eec9ab44179ea956c8fca456259cf633b03e8c9a7a066aa5d38eca5ba2126d37de7009f95489d366416c0eefb49804fcb1e921917850e956ac6d77ba2b42973c4750cbc574830835e749cf8dc3f8155d355640d8cf5bf5723267dfa0ad602365bf79307720d85d45a74c571713de4d43f611337c670a4e01241347c69ac365b701a05ec25ec17f7a9063bc7c39e7cf9400c5e818a178aef9d3a988e77e1b5c5c158fff24bd373f485cb00c993fcfd53fb1bf7474bb48033956131ed6d472a36aa90a9cc59a7578edbd805cd239dc74135bea0e991978a89cead0aae433573d21190de54024f3194804337a41110ee24998778fac6db2c5b3ae9998dc1827b8761e09fea9dc900aedce9f44e65d4320c2f20c8c0e8066b64e5549dac7952ae2b5a51a27feac8b00896032dc260deb50b92f295ae1974ccb9667fab0affcd7cb44657341f297d8258f1a01d7b642724565c9de578eb364a5c04c95d5ab8ba64484a07af2498161a2ce95c014b5cb2cc36b48ab828a25455d026985ec336df4d090e662084d069a4698f19b96ad8d3dadd7a288524c1a4fdb69f8ff52571ea9d52b6981d539d0c27dd133f2aed0769ac994d9814ddeae19a088618a4433a67d9fae7e80f7dfa970b54d494c060eb7220367ace78b510d28b8d12d49297a04114aeaa3dbeb10b57c7a8f7b924c2ece226b78181f2cbbcabdb938fd6df10720ebfe7ff01a1c8f913c1fa557cf6e84f3d59a77685829736ab38994e2435c53b40005946bc70a909b9fa933d5f6b91fb73fa2b803b03d7274276143488500488720ce051a9a61a38582e6e10dafd2974be836a52538ccdeb521d284e41404b973933eb2c75437e804fe8401b82b59b08a9de0144676289929af0497a01c430eb74bd9df69d8b0bc9c4abf62b32278586143a005ab2c3cfb4aeb048a376966009246542e2257796d38838c31f6889406abb47f3dfddcbfccad19263120d3c0074492a668589be4063ec9c65bb02fb2859cca6b05a3d63f05c324d01048d5aea34a13c68b933826c00a8475c007dd25833097b1bdef803c4b3e241c4005b6a9174721fab60ba7e511f3f8fdcea912baad4467a5379803366663be383642fa395274ba8a67c3a2dafb9f8ff76482ce69e412b6439afa8589881f1675a2f574585f76a0c730fe7859fbd1b06088b0c2a6542a202fd20cf4b422adf8de27ba182cee33b97b3fa99b3aedce89332ba5d545f0664641b36a5ad2bf75ca30aa821eeb3aa4d2721261d4f30f3f9ab95dd3294bd194c84d398729e1ea27b9845142c51a996da67f3917f1f2a75ef88660b973e81a77579a63836f5ee733a4691f8d8eb90fc3f3ec94308c2431a5a84fc4a19f1674de449ba8421ff5552657c15022f0dd0162cb2470f9d183018aad6000578934457c39e071d37c44eec1a2bf82d827f2e7431a0c53e885ccc931813175d53c5af5142ad4a0cb7241b7db68439a81a6623f66806d530a5238aed28e6d1374e3de6da26a9b41da956fdc7a3fc48aa936720e9910c20b73073d3c38c513182b5ef2771f80a389ef515fed0db8fff8695cb461c31b1cadf2129b5731928e519d1bc7e22b30683e461400a20c241e0524cf9f2ad2885c6df7ce2ff7ab6193eb66bb7abb268b06a1fe4c75d3cb728e0d6d79893bce01249cce5429c9fd378393d2632c7754acd232c1012ef395d59563660d445827b09b10c53f570263bfb3839a6d3ef705587b2693db19bda89344a4b619df38a604869d88812fb885a719ea7ebd6f61b9ceaa75d6d2e1511841cc2ee86b199bb741e9f047ac212094797f1bdae00a3fa5b1c706fbdea523410a3316b5071e5ef8c72612ae4f98fcb5732be633b395b0892d4e553bb2b52c8890a31dcb843247bcac12a3360364f1f28fb328a36e339eeb65c56dfff198a238241a2b2e3a10200b95901bc876e88b8f093ac3c18f3f11bfa62bf9311ba7b04087c32ac118f6bd94206771848b03db59bcd196fc703de0219ba037a5ea61bc204fbed8cf265c22686a6ec134cc1094f11adc7dbf241bb5f38581bec73f81f6a8672a729a5c57bd591820602daeec1a4a7137b48ee298664377ade695509e7e6150254ada5268eba3b7d4636bddc539c1dce396a2ea8a9ed2fff0e10772a4a281fb354bc4d6e5ec99bc0b38d68e3756df86e416e33a87ae3d72be1ed9b3d8923c220e6db7c62f05e861c1ca37f971bece0978cc566cb43b05d3495866a442029b7d7595057cbe7ed92985ac3f12c94830896afba8575f5a985c672315f6169cc61883490f9704d61caabfc4221ff154816d404e806fd34535edbbcb23a57b408b29850ba72ec538dfecdeca344af10884213697addddcd92901e16a2ac4f2048e578fc39f59a7bb64007d1de591feea5a15f250893271263584c17be4170126c2d5dfe0832d53c55cf3aea3a02a52f6cc433ee345836b17a9ef0b25c9a250c5464adefea5544c6e1c5e5e9e833236c5c2d7bb2493a28a8f40609504557f4836676c55e40c3906c70211b9e840c904ae5884e3e9d371d6290d5ffd124c294abec55e1298b8a286ea208e33608b2b12534a678e2a81372ea0fd7d88f3871f43c76ede88b8e3c83be4921aa6f1cbb91214b6613ae01b0e3b60f6ce21466021e54ff1794d329bb4aa2c92fcf1bec4abc712e7145c02ec6efc93efa07a476f6f97788dd95450f12db39184bda86a8dc70655936901d67c1b65ca483225f80bb2d1cac13eef90a2b2fc10661454fe9e8dba35b8df29955bcb9fb68447c1d48b42913ed989242b8edaabfb70d61405dd520fab3272441e65701afdf3418427d848e9e3038feecf15b1693797409e99c809ae9db68f68add248f65ed4578b23171ed34fae25720c76d6890768fa4549c725779f37ae79cd5c5c2fad806e8494ea2d381da62b6284fc8579a02110f50f830634cbb25897648357eadf2574be893e6d5ae94d76b0e07cfd2e59bb6d1f99bc1fad9e40ab0f98c21b35dbbe885cac00b8ea0c982eb9d5d87c2dae93cd177e8267200b25c81e982d4a4ab7c41c90791da8d89bbf4eef425b007ab621f37922dc1eb0f3c0534683efc0b9e8788af4cb347dba56d6762406eacf39c588e99a6f99baece42941672d7c6daa2f19dff184543b783b7f4935c9d4ca3fa10d8733c5fc3a0f7e6614f067d9a912d781f0878a53e275414c1d5e66aed73542712bf8272e09915057dd5ff1fe577156d8d0c3fc6068c63b0f7c585fed6c93524afc9d4969e93d7c97ab62b5af282d9b6f53111ba7dc39bb3e59f2dd6cd5b69e80fb7ce30b76564970ac7934cbdf3223ac8504db84047d825baea6233192d9d628bc72beb69f31537d95aec1f332c9cf588f28449893e279fba5f312684b067ce45243bbbe3478a24382f7b97278e7c2f7f7380c4e4d042e2392b907ab683ec37fbc5d8e209dd8b21105518ada9295cc76071fe4d7e160214b833be46e85dbe0319a98854786b4bee402a38769b95aabcf94c1e206ac6e9405133551a11396ffed60ed0f5e90b70c2a0e1e972c88359d47a28f2bd48f3fa4905e7a593d9aba72b6b44eb735bd640723d125f816570ed6a0ea4148e2a7a0c006ab954e57d2e436465be6e884c6ad7cedc831f5b1946d37b6f463eb72b62024dbbee61b0dab882d3795664a1a29ef427e464f40317aec16068e400e4b1c7e875df71755e04c2a7df248ee0345aa308b28cbafef847d5623433450d1c28b15fe16ea298216619c5e48a2039e8f5bb51d40daf4b9574d29f0366ba8c3a7219a8bfc5e9c8c3a33cf22557a3991df8c1460ee59c09e7c46a375c4f4be96406e03762bc709881433f2f5ff7097725e0eaaa0e0042b40f5e16a1e80322e073b82cf448e35530afe80ddb7d8f33aaada7c999e2eb965a3351fc0fef989f3a1fb4626046fec4e4a2e69fcc5a3ec8fb112afc1f1ffc438fd3e89f7d5ff01a937fe2a48395fd938c062bc14f8bbeed93cc96273af3a3f9ca83d168954f50a98e936fe4777aed781b83f574e9f01198dc46d3b220044f446956418477dd7e55fce9a51996bfa9a5dea0e4eea1daac3e44b07acdf3e6c559e0855e8a8a6e80707061e02ba76c67144b2e2bf052d84f2613a14c655f4c69f8a8b5b11303b401181e91583e7b4f4f95fd3217f7c94e45234466f8ebcdaadc08893fef5dfb0f42cff9eee8af7c95a360378888ee7b800577a68b576e33a677d7eeeb755a04595ac70f419fc47f2394483c7326ebfc75e42bb2a2c0c4756ba26735e4dc898733fc0a2e25e4d6b48075f0af47061b053b30660cabdab91b08f32cef0dc06bfe3e1937818737c94ab31579bffce093cd3f90c2f038ba4db532d08782453e7b9382d67cb82d4da06825f3ea10130deeb563cad203be1ef7ab9dd10e549b893e715a6995de6a5384da5b4a764a2fdc09d45c114379e52c8a4d2bbcc7f8ac81b762b6060290762a30e7668f4e1dede3b788d8d42377476daddb18438aea97b3cf5761d13cce73b0611a1273ae5d42b92311f0d34429c228d64629f53f93476c0de8a596127d79fed2349ee9d005df069101f66c26552123eb48abbe816c70ad62c59ccc493a14b82df5ca6c0231a3dab59ff6b49dbfa7513b1e4a4988533572cd1b9b1667579d00a24e572d72db1bcaa92a67ee6a8307b3d4f0e6acaee93ed0d5802933802668caefc3f8fc6e0b22d9d9b3bc3f5ee56359190719df9a2389f3c3f6d6afc400ce306ba61b9cd3086f1b8c645cac062aeae665b52e69eeaa674991395398a893be2d16a8de078288750c5e0fa5cbb722917fbf03e5652f7805499c01011ad9614b7bc0c236dcd120623d5d548a1377970d8199e868cf264a8505e84619861baf8425b00a5e4349c89b41022b80a3a760bbda6913f3f4175de21caa64154b63dbbb2279632a47dbcff2b73e6370273ba9bbf100ead01d63f12c559d69f7ff140b67aa1716110254e8cb61c34f2d78f3c9ed6f64f37bda46ec5782ed930d5bb53d971ed59058e01e0b2b72ec4708ade473a0f89e162843548a67bfb4d44f48be52832cd338bc347e85410b8d3b1eef6a5a21864ff2dad1df6c327fd3df04704c1fa2e3019bf2b7bbff8b10c421bd86c6317b29197a2d1d90f92cf286615735f7c89e1fb3f6590f1cc63ea67d521f867bd85d78320f326110c6bad036e422a07db6efabaad714f53fd5866b8b7ee43f69ee6b39a7cd4bc16a3bc2844fd883e8aded2f65f3552a6c5bfa8f95dd114686b87939f813f322d560388ff1317486d0e302af1e11a4d03d020deab2bf86c1729135d19475d9a57ba8baa98062c8edf69ed8f150a7f5981721d03ce1debc21fc8451241068c935305c3a22ff5971dcf5267942478e06d4bdcb6d10caf1f4a89953901cd23193306c2c14bac7860080304f1b06f45762f48a9330b51a6240ce53c6ebc69a5cefe3b973928e96195dfad64ec37f674c8eeb9e13f3435187d1a4411da9cdbf324cdaead42398294e04123d3b38ccb9a7e0b43df2831530216e6f1a60f7efa6761805fb40ffd53ea0d479cf9553b4261f4a6be96c02b986f1ee445c82edaab75c196cbde30cb91ffbd3bfa4c140d1290c5221c3058c3afc333e81fec8fec1633f88f9360e9430e877d651a94bfcd1ce38b193f5e59a079b62069208b3cbb5a1ea4c5b440d7cd35be282c17f3b6d035e12a1471e319a322489afe0e0c54c6ccd55d9c2b3a278c8d6c1c386f8adfe786b0a54743db6f2783d4f591cba5358c7dabe215c5a075bd581ddceccdc8400d2710d252fa4c3f5eba6220476e0f641b7953b2a7a2c6a5d23dfeb4e99b0439491a1cfe0debfeecc79500db768a283c4a5a1b643a91645e00e90bf8836d8f1bdc6026151a2ef2b3de1946f5eefc75bdb305fb6479e5143f65c4d1de6690c944156f713f5f384acf6a723b0d1cd20661ff253d741723d5c522078b14458cd4693f6af6fd48b948b68465f5d95d8fd6994ef2e16abf3d4cfeccb70e1245c3cc0aae96aa7b640f60572274c84726e986d749ea0a20f7128fa7b921cc27867aa99244d95824206d63c2dc3333bd8a793e1444a71b6ae1c0eab25a5f365b608ebadf12ba2751e25e79897ba205c6106515ed83a17b3a95cd4eb05f925a0dec5cfe6bd4ebd92782467832d8f98289018adddd7098ab8f846625925f8d20ccd0987b5b0980a56007fb89a7eeb82176de248349fe5dfec44fb903724b976ebf9645badd474c87ec2af71eeaeaf0a7cfdf167a6b02d1df62aa40157d80eb44caed80735c85cb7e61e23e6e352620368afbfd12ea08a5f79eeb77ff8c4a8aff472f73848992ebeb384b1ef10721f30b34261e57b19be5f12bab9a5560cbb65d5d0ed1a06cc78f198e5da8e231b9fbd3a8df2be487bcae01584c307431e0eec7467be911ff3c919181650a1118814c83246d750dfc95d0ab3874bf3a1a2028189480dd483c60b1abe021318e5e897979c1e6a2210993f76429d2de20fc270004895a41ca05ba42eeb370831ea5697cfa4ae7a9519166d187f588e397472cb5834d07420cadb645401b4e0fe6a879b58c5b767a5b719c9ffb2d16cfccb5002a8c1a81ba6f8d51aea29fcc5150bc80f1d5d9b0b5aec2e99b55843bc5ab72b48efecf3502458a3aaab6d82784876997e231c7106ce5f733a837a926814c275f7b209f92082c48d282acdf17cada0cff85dd014edf2715f309756c5b63ea2b8aeab2eb2670abee606cb29305afef6651c4deecad300ed9dfd2d5a716c8cb270863cc4a61fb3ddd9d7984b4f558b0d0e6943a3b5f9736f95feaa08fb362ce02f982c28ab309be8a02924556d81cc709c99e4033efa02163f15455a48b58881e826b0fc3bf72d43b2b47e7ff241538f021fbafcb79d8c20b7ff4bc973f54cfe316b12a223dc969b8f0e045645b1f6d88d5a0619896ce3643acac599d1e10c896d375103a4bef048056ea6a07cac10cc8f89e72cafef871c5c3ce1ae42b5d200ccc18cf1049e12b779fc1a78046846b7a9d0df1b63decf328ee4ed12064a61bdffa6fec1af37ae052e5c303bb7206966f6f8273e30e1c67b0fc3da4e8b5d8c46d2544830aa50273116a5004854ae4006b8b00c7976a7f9d8207cd008c9f8adbf65bed25631db1adb49c583fc8d40c936a942055210a4e91417b4459a2ef000ada0f4794ebecf8b2156866e4d2fc9321c66e18d17e86f4db4c5fae9ca0afdf25c4a3c1a040b490864f4d227f97c76df6a6e6ba8b5a972554e8828d1c622775453d30770985f0e2d301a08abbe91f3329560a0412bf221424a6c2119d739e8c1fb58e0b801d980ee67cb8465a3295b13932a25d7812cbd15a8b11b7a949ecafa5a2e4a7fd72586d4d87dc254eb07af4847b25cac4a9ea9164a3ca7bd0d611f17ec8e763e12c703cd723f571cd87b59e80bde189189dfdb1d8c0792edcf512d9f9237f8f756c491ccc24a36f1d0cac7b027e3fd1a42ace7918ebea55b53cb5b4ab00f98eeb3d31ea0bd72e39de9d248c79a62017021471fb5c9ec6f9ee40da95f430dd464b04646fae43db5953cb83516c85d106751e4f4d38ba152a37b64cbf8c204f88ea32f0c3d88fa717722f94deda434cdb97d9f96943b8d2430b3bb7fc636f71a1e11c994fc95f42feb8014b0290b9592cfeb60b6bd167e9158caaedf2fcfdbf5853a89b6c928ed7ecaa38329e11414041cc25c0e8a3ff890c46f94b44e780d64ff36e8909fb1944367425f00885326dfe38cbcc86bc96cfcc9f4f059bf39248049cb1cc53b684ce7c005f29ea4c0145d492ed3a89d68d85f6d996027fc76bae4ba6df33c1ad05d8bb2a8828ba0a3455626710e952d8b47ab33e3a879a8485b808468cb3d3c9ddc2a02c23113cdb8d166c9ae18d6f85871e97a71cf356c36a09d1ac58168fbb0b4066f8730f28bdd21c092bc297dd494a4c93bdb9ce8427bd1d185dc5999f419b9447d1564b89156fabcf83f1a9fcfebe7ef7049d65807360fd4b74a5bebbbfe0b3f9de8d398d95e8e538846394e36d073d50da9c6ac468891b61b985db46154129355d9ead0b50d51bf2bfa27c535f905271f549a16d099001bbcc7a90cc215447c13ae2927b74074fa5392ea875b0bb9ca0e8e6025d327ddb335f10b171afe6c97ccf40fb77c18fbd181a67f412086f82d38620ba5b64d663cf60bc887fa053647944a5ed0d6de1be2ad448152fb627f4ae9da3626d9de36f7e5bf5e2b80e9c9d8ff1509d99c4015afa1ca456233057810ae311bb250ddf75e3e8f108e1fa8448954d979333a35ab9581c487548dbc5bd25596eeddfa1b0d460274f255383010e70ccc97582de3730f37a2728385544e750db48e186db8bd6c258926df9f66196fc7c8572cf1bc440581b7e61fbcf2eaa180d4191ccf8f45b4199c5d7c82741556c8d60c9da7c58c02d7023c02340947af213256dc55a02672299de5059a2030d10f72ce6e6248a4250524b1a7cffc35c21c5942d2cac92fa7cc36c2451ef73447a47ab79ca44f34fc6f1c78611159768d894f64298a501fce223da7db765c9442280db11a3de8551617cc316486b0cb1f13d8fdb2a542a1c9b947927bd62871661c9ed30b79c92b1ceb3f76c1243ca86d5966d42f33f2626a2e8cac01a7de71393a4e9ded58b0933b02cf80000df704d9dbaa4e850c84cff1222a9c62452f4dd9a8cafee72c60367adc01107c8e3cd4ea2bc8baed0f9005f69bb332c1155c1ce85b867e132cc42e2ed736ed69b4146f1627eabecf3f25f18c49d8893ae01d166edab394ef7679fa794551d56d6252090b4d309abc21162197cf823ebed3d0f611d770627c56332aedd8868020015efaa7b9ffcc142d12a417787745345cb140b04703d036b3f43e543b426893ba7e78be08a91c00f9d02707bad6e8fec1cef663c577068a187c3d61a3b1a0412d05aabd448a1c44b78811e49010bcfc9cc816258f82d4e458fef2e5387368d5b656f79ac0885815d1a86dd845beac875a0360fde0783a9dd5813dcfeae13382175c55635a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
