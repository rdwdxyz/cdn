<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d3b6ec1185263e6f98dfc6ff777d3141f357b6ebe94a99845f45ce2e98cb388883818c5301272b77ecbf9ca4d63ceb90c43a75f82d8581fd04726c3385ad8be5104ab6c07d664a91ab7d9f6559b62a8b1d98528352a13f3128ab6f9a0c9954bb408bb82d42b448820b5e7956f15c39274e9bf711d94b9290bd38a10b51a8a3c7503c7fce2f7cf9088b2c86f89b8a5bf8ede90e283939b5623ba10188d3134f50fa75030957b5fd337071b9afa7318a0a22496b3afcb7f193527c27e179316e5e9ee15b6184e23345f7b48206b0482da924195b16ce49d5877e7d651fb7118e7ef500a9aae5a34b7d80542b9fd5204daa968ed55ac87f156f4f7a0da3f76d15406ff7ff36648f24ec3d0b320bd3baecabc74534d4f703c2c189bd38b38a1be745cb2e0fbabd112d515ea770b959d42f5e28fcaeb6decb33444b8ea8bc9be7a75589f58844d3e789843c2d80853f3425fabe5feb09b35b30edfde6a7a05304defdc99fafdadbb19ccc7b4c7ce655e9336dfd2ed829e8f1213839f50b76a8f4f6af4506e428ec43a6ba5e4aeb613b80a6cc9e957829e273c1ca639b2bbdf36cbf401fdc52bf9841a68c3c746298683af2f8276be5f5e1c24616d594810dc0394fb6d8f2b59dc13e1fc20a40bc4dbbf6cf151f200934f9b2fc186ecd5e77176537499fb343ab54ca69b964bc0fac78e42297354819cc782499ea4d681ed4239542fb36f132788a407ce7cff8eb4030d24f39dbe7f937d5f80d0f78b056391a2188c8cba46b653b92923c71d201a554ab21923e6cea9e3b212dcb10161e10af916abc5a229142cf6d496567d8318324f9e15220e675e6788fd52c103b6633bfc1e4cbd943345c3abe93a4b7d2301858487e1e98bce0008e0aa6baafd4f0d14d524826b0b98c3b291fb354616c59c4ed51850ed6f5d81b6e56b79cae33d5728560f66fc68dc78f4414e620f0b11d059021ff262241d059fcd98cfe7992aa7be44c16cf8a3d73a438f32049cb07a06c2bab04b54b3033fbcee2ad1746f17686475ed1e5925efc6e3fb6f1853f538847f62166f6d7d3f1e04f6983e2cada5259cab225616078803629151e4b74116d5031b7baa77fb0aad2391e9be78d9c8ec39bb3004c736af5685811a1f5dc15d3b0664d2bab8f6ffb8ef7e9c34d57bbaa1cea8e7d1ef74d7a4b313fbdc78bee7029e8aff9e74504b4840bdf5b464072191c27a03b75098103b6b7d4c16eefa7e794d09d4a9d16e01d606e509767e92da6b8202c416f13d9afe99ebf2b2db9c7394e426b052ed06f11fc79c8db55f3ed8f5ce8641da8d92e29468388b6e87b7f035d6b0d070ecec2efa69031d35e0c027111366752b44e15044cad709c0a1caf2c9b365d23fd47a53a080dad3fc47aa6c14a47d982508813b0f06d08c17824f1bfa1a27fa77f23f9c1342789a248d576d4e994c6e0373b55dfdfd82f7b292cbe6178bbf83a09670d3f7e5da5c9d11b6063d80e306ef0730f3884d006cab0eec89330b34364e9a14a461d353342176a2a74545521cc4f4419e1b876c41aa6907509216121de32967435706a1f7b53d3935ac0ac42c796413cc731d6d14d0d0d473f411dc94b316146b157e0ba320cd5ffafbe563e9de0c0567b8b6f347b12abb8f099068712bd1312ed2ba2a6d14e2d3a5a38e10d70ecccd128ac285e62bc4bca270af95106054be05793c8d9af4506d5c6bb29f9a3cbf6f147f317998411f970b5741bfc636a581c645c248beaa9d9dda941e027de2ec90a1995660db54a211be4e974aa97022085feca9af41432adf1d1de93cfd48b0b995e7257572a84b37204b4beede994c240821a415ad6d094f2ad0bb1e5e9fd131bf3a2170ce1662c83efcdfb2506bea59cd2dd9c3b65d3c28901af04ea502bbc76799392f275bd5930744f5d510c96c647e00b255c961d1aef27e830a4c7bef059f298e613b19bfec0bb0cf462df5b735d315b582973131f8016eb55f9a91ef60394301af0c885e280c5d7485d5e21e086d84585ef89a74c2a420ccf576fb8615b80fffb067d4bb40acf997ed3c8837dbca82ae0bed073608b54fdf13bcd51aa009d92c7bbf867ca6e35f49122fec3da90485695578d6202a11dabfbb3d9c187724d55dc4d98f05f01cb29d542fe72de1160c4ffde1d464bea01730ad7242b8291b1b4c246f2a5ac9fe257cf9b3a2961cf63d9c9053290d89b63c5eded9f6a5d92f05bb95068d47ea48825401fc34bf07fb6c897781d721574f0fdf000950a28643ad5311816c0fd708d0a7ba8b5dab4341bd6e34a724bfd0036ea0331fb4f282c2b090d7b0573b75359d91339f7ad4785c3dba2a0b765ffa19cf77535da2eb49f5e4ef3f3ddcb423cc82503b659a4c15eabcb9612218db1d66c9e507349eb5c7c2924f9c9b50dd4fb438002ca321e33850070edd5f47377def9ba6f0b04abb8b9ef87b89b9fbc49e2aacf804b9c5a8e137e753f604dff8d2cfdcb348fa628eb16e006707d6a295348ecddaa4783b40269b4a8c8d63c49545cb0e7eb1731c4af9983306d6d82d783c3b8e76e49dd5773003471b1823201a6fa1714dcd8d5cb1f4570b43f30d9f3222054db26aba14b6ffb9cfe70b8e693db96d81c2ee2eaf9538f9b3de912c9e1deed00d6f7cfcd17bd7c981ae91a64650bda85c652c153305eb3e96abfd907747ea3054133f18ca696526299de6a0d86e38ddac00f91beae4d98549416d7a09b4ec33522a50a0b3d168b29218ae321e1f292559ac74e0664d6652d60792e80d0d16dd20662871560ba17185bf581fa61d3dbfcfc0048e277293f20f038319712ead539e191ceaa347577daa879a2b2052c1de0fdae4961d219101cb914dd224483bba7138af62c2099666f9b6da9220b4d2a10c2def2875ecaa3dedd54a4aa250c5068a004d35eafd69eba886ca0f87b5041af2d1f96ba9730ccefb99bba72f87166931656e49b0eff1021ae251103772f02aac5fdc4459763e1b3202840a4a2eb0a8710f5736d24f6235145999d3f5d86b86f28d094f7484b4ae8ba09df9c24c395e9e6e8ff803d17e6280dac9142eb2694bc3e7abd86bd818e42b693856d0d30b913ed572e5adb90e0f5440913a527b8a592706ebd22bd025b1658304051bbf46c457d9bc09095f67abc234bb2bb267d2c79e9b33e379ec65c9ce05545da134ffe751150bbf51ba0dedd25c25b2969cfccc13b0125ba9d0c038ca4caf34c7fb2c886d50c1d6eb3eb649a98d315c69c14abedd3d91feaffe47d5121522572425eeffae89f8d679915c78658cd1c1d88222e39f67f8bb7b6b6a68136f14257eee838fd667915fd8cded06fa2713fa19ff468079e36537c6667d3e0b923d53058217505070cd56a5c9874dd2a11ac8a1cece37169d4cc93653f6ad529d4b1ddc278e460a4dd0cc1990154bdab2565fd8d8bf3bd6ac4b89396519608fbacf27cb3258a7352783b0778d89d9939f6daafb8c08500ad36a45cfdbc713c618ae248e851beca0409128b142497711b131e631905ebec3851b57ee47ad303f859f0df2c5368ee1af3e77ac6c81d120f4b63a38b1a3506e1814a474353b938694b5d845ae0f0b095b4f214484741f9753ad76e46424806df3a1787fb2ad0208d76d5187bea6bbaecf0a46c30a438210cc097e305577b8b13b33aa7a9501fbfef2af8730374076914f1b17ea244447d9a6e2bb5c065fdfdb6047ca3554ffd19a66a11a4bdfa02667047defd01539e63f44ccd0bfce4c77f90b76e59cd1cce13fef5a7e8e352cbb3937e7422d40219ca0be450475dfc57803fceaa6f59803283f1c100c06c34e811f3684b1337d110debb849a6add15e4f0aecb97cf4df07478a5e764669e4b86f4f877c469cc85159b63e51aa4da2a82a09d941ebf9a628409782db21d385a418fb13988645ab24de3a3146bfdd316764449fd6188f52ba2dc2aed4be3b9e66be95875f0d0914b290089e93ea9a14792a2a4bdf5a4ca5d54e1be806204b039bc4b1b8f91201768458d751ffc5a4d503d7e20f77a9165b5d99a54945c7a33b2be6acad5775cff36f32991b81f15f04a4682ce197e0c3d76781cf22fde47b79de26d107950a359a555903b8961bd4045a327a1356c67086d44068ee7aa76d83265b67e8d98f15a66726930236eb33ebb544346baa7febd0ab0b65e369274a6b04e81d90ea744abfc7086e176d92dfc615e393025977fbea6e680cb6ffde46ae88dc3e3c0b272e2d5f569b092d3ef3637f491bc9c509bd4f1cdde1d4db708a0b90365462405a00a6a74e6770b795e77f753d764b74cd7fe7202133a1b1a36cc59d244f3c2180fc6966439ecf652266fead04a079e1cc891bf9291bcf43257b584d2d7b46e1e59970bddc46d2bc9085d94b9fd0ca68a1acfd7661938d4043792c5ab71b027d1c8d02d18fef3fbd470a0c8659faa37ffc62e1fe580d4743cb56ef35e5f8854d6c062e5799cb487ef81e6d0175ad0c94f600ea63a1d6f848edde481f638855ac8b1093488ae0b7a6abbff5077d64b8e12d06824ed81675adf9f426ba133d1e063aeb2d339beca12f10208664a175eba97c8e2c60df7dff8ee4232481d98915cbcc7271084ad24e493ff111d2b9c83976e7a5ab5afcd5153734ac366c3357637630190fe536bd7cd4692dfc8b4842037a330003a5a0a8caf86915a9a77e276c40f1c5679d4e286ecfdaebb8b1750b03ca08a117e50823fb0050ec2f69312db4edbbfedf4ba0137071dac64e933095a5e470cdca9f7ff96e273fc807a8da1286ac025735f017ef0b8b9cbf0c59552096736e2ff6557f4fc28101031244da764725163b0617afe56bff591ca3dc8e3658ee5a4dd7d1c41a600cb4cbb36fb63648b14fafbdfef3555a5cb413a3419e0a9ecdd7b24faed69f64f14ff9276651561382494a1f3422b42de383f38672f3306831621c66302abf3898d4e418414c2a2471acd9376df309ca5bfebe1471b609450dcadfd853ea6c84178fc71a79765c6f61fc50598a49b183fef12281000b121bab5d18573432d53cc942eb83df58f6d7b71bc4619d0915a106ce3fc84f54dbab08fad7d58d0e3b87b950fe3c53e737b97cd654b3653f1b66aa5f816649989744e01f34e80963b0b97b6c77dccd061de1556df3b924ef8b2348a6425ad6bcbbf0f7219fda4a6e3d335d9a46f40babd5db7cf2be4300e90b17ba530c476f6d11f5cbfeafe301caa285cb0f3fa7c705fb9a9acc377e224f0fb5549f0d7c25a1d42ba69f4df0e2a75aefbe0eabc313c9b25a1e972ab0df1e98f4fa49c014386fd92c675f08eed657467e58213a519e283f735dc1a1efb30dad4ea96f2ab55989c5c8694503cd1cd9dc3593f06b2bbf77902f62d898eaee03312a92d62981d6eb5473b159b979a64f3c13ea5f41a6316b484901b9c93eb1631d20625448d066df08bb923e012aa1bbc8b4a19ec343977d7aa044e837dd0202425cc9791d7d675d4b65faa44f54b22ac5d25e2f9e19809e3895c18d0281376f5cde837c564e02350d5d45aeab1512cac5e1b0e6268ddbbb5bd3ee80833fee956377a0d41326c2af44d37c4400ada12dbb157c58b931fa2219dd94913266db4c3520b2f17fe1ac5a1d08329102a577805aa962f82fad23214717f12102e65d0fcccd5beab0eb9219e04ec1792391aa4e3f618a344496c4c712f2e7300aab4da018994dd41540f365abba91ae17efbe61b8022032d934846fee87f76718edf01bf6b1bb35782f8bb4dc982eaa9bf093ac4e3417acc5c2075d2406b03331e0a485ec66e3ef6fbefaa152410447a41098c4104b199762f4886aef1236aea5e79476def3a1476efe0c17e976943c79ec89aa287691343cdb85c6abdabef3a5bcfe1061ffe55a25b4aeb01f28d24c8822656242159c1b6366c03f109a69fddd246b10c4b921f74364a72b404f313efdac601f8985dc4f72e32ec09b8ffaf5984b8f1be1da8bd57a43f184502e077629bf85dd3ded1b3754a3402dc74eca32c85fcdb3354c0e39030bc94e9856942311433bdeec0d0ccb9868b5ad0ff2a40a14d4f6885daf4a42b20c7a517478e71dddd6cb625bd17d5ef92526d8545f058b972bcecf29bb495555fe402ba2ac96e0967099762b277abde989b1d95f2871c0c4e8f583a27da1c4e4c05da913d1c9ff897219fefa33d9c91830fb51cc4f5c0d03edc11712c692df6f64c14ee12c363892c6c0b4c1bac103cc07019a083dfb99e8e7403fd0e86d9e39bf2f2a1e8840e67d340767ae1cfcb64fa51154a2563af882979dfcee675871bb777ba32238198895595d3c56a155dd8138fa9fd611a5e2010fcff8f201b4daf0b773fcb19490e533d07542f432c5f5604472c1182f7b49cd0cdc5722b6f46cf4ccc49a0fbd88e545126d8ba76461b9c65ab1e29fcde1dbd26358e6272ff1aba1042deeaf5f8ca0fbd77c57d381952f177e9fbd69f995c40d4e03b043c1d7dafbff9e3ed4201003a84ba3ec52b599a0715c19650736e998bad84634ffed875ac1b4f55d30815abe2d3ef7df2bba5791ea231a8f65b07e6c911af975f528b9e93f92e5679bfcf2f02fb6d951a736476f178cb4a7950132399c5eb1cf325651c353e719563561480a7aa3c860a0f5516c3100494701e38351c70eab5e6b836100606c1c7223aa115bf9f102c0ef21c4a1a17721ee19539377b6e2ecc090458d482bb170f733d4d2faecd88685401c7bcf97692be3f903eb17b14f476d527a4dd930c5037b6d3cca2bf4957817cfd31feec946231d4ab51b1e5efcf37935f138811b26720cf0b997fc38c8b76486031b1145fe8ce1f4861129a2cf007a9180d28f0122f6829fa022c409c9eac1958605210116b3ab226adbed4ea0f707d1200bef8e7f87081f2c6d5d4e6d987c740d9a0551345e9f4a485884c75ecf63e9d4c21c6c5f2ca8b74fad80c8024b907d26de2a82055010a6ec548c9b27a26b378e7a8098fb8f1a925abf68414a937b6a2a1e03746b6d256596033ff36eb83b39fc2bdca2a08c616abc0782112e51cea9201febe71547444d345e79dcde423f728c892164615338916c724743bf8d8aeef7bdde42dd5261352eecca5bc521785b256e3e873bf33f073927f73a512eebcc3b7be50bed1f9fe4eb3b4a4a0bd4e46b5047d7a9ad1d8a9c42e48a64ddc6a0d49abf959971a19a2c693f7b8d942b8be0991908261d8c95d426442c7b08549f5d0510395c8f4dc18d32582507aa6ce26ce4d03a50c60fbb983e0a24b58d405b0ab6d7f145c1ae10ffea351c06e9d5a44ce86880c461a0602e8ea34796e4245a2e3887959be0f1a8c6b3f4a744ad70730b9c45e222329ee938d5ddc233a0e0bd29ae4cb903bf72a69a97e5e6669363bf5e470be068ce23291d74ea463c5b36851d9ecdf141ffc8f810e31495805bed09d9bf0bd8ceac8fce7bdb20dcfa95858d860ad53ed6337c1ffba86cac333a4194e00f345e56462a7870d7af65c7ee8cc4f852c4af61f3d04d6eda39d762c8034729d368bda60b8e52d968972775ef8fcb59d28e38981555368667651c48d6ab6a90a11c44181c63ab07468ae8e1f713ec0d8737c17be4bf086ae0ddc75fbad727066b6b8c95ca11db6c4d9c52092d5dfd9e152ad258a55a916c2440e9192e9d35436dca07040ed998d0110dbdd11a5415a94b930610a67f42cf198048912cd48438870244dd38a5ea14cf5deda0de722b793833e67d4c8f440d3fd01f7cd0dc189ca1178692fb999476f2239e86b9908296111bee7aec86b038dc76b33096ec22cba8b19caf5046357c3c3e0d94062ca1f6584a2108a4ff92fb6c7b41abd80405b5718708eafa6714d0af30463af6db92bd1a326c63538d086cdeebb3cc2ff92035512707f9c802d5f7c3c49dbde56606cb2dedbcaf785ac1177a5904197f1e2c942133fb599f5e32a32261c4c23ce8c0e79058a8241353bc24c7cbbfa502b82fbad5af0c0fde3618b71452a1a0a7f08464a303d572a8f9c136dece86aebd4d59d9862f8947932186d05695e5190e0cd2b8677b07b9f54ca4e3f62b9184e17ce23f393592b187b4e7d8d7d399f7228db143fc8207b8728714f6f437793f52d023e6fae9748eac09fb93884580fdcba993d0f7654a185f75e5215d4df0f0b536c19f5fcd3204676f6f83ab6fdce442e92db5671b654d3c20353ced424a0091d9301d07e258baa0a8c64a94f795b7afd248bf8236cb9fa1f4004a1ac6e6c0e66a6a596612f55404c10c16003415f784e1f661cf60ce9551bc2733d294637f63dfe3d83c925b74945624df84fc638cb73dd448774f43893327e9efebbd93bdfd73c34ce3ea77fd8cae527a1a747f786272b4c35752717fed1c3b63a3b614343a34b15e316426193bf12794d070814adb91e5389246f7e2b0939bb674db3393c7741a32eb4cfd3f82ac4243487a47128411dc96403981b56b66eebc608fae33abcaadc23f4fc8e5279a3615e4816834d609713b51530b421b30cb762f5a51e9a395f3ff5a4e275d7236814e9ab7195579ac007fa17db2264da3b2d5a407c1567a6c9e0f0c8b1576f0a37eda1a0a57d5b27c2d6cdb8226e3c41a1e06f5f14cee3f7ec3df51885fa37aad8888744738160799ec5219465f999f8788542c0e53e8d86e2f29dfc2d83ae701e8ccc564c633357500ddfcbbaaf0d416b2ae33cedd9f3c785dd27459eda5067405ada01872bc2554cf3de49b5ea273a763283add224eafb8d779d2b103bdf30171658200edbc1ed856b3cec363f380af95bb3b3d7a9aab3e1c49249cf4bafde4680a5664125708b46984ba9d6c28e1e4aa3945a71edba1c34f928b833a237f3220265bb9ef2378cc52e6034e392e627a63ce446787387b77999ddefcfdad5b1f631ffc7b069f8de5b2d1073329aeec3e5fda7c37d8899977c96872f28c7b1cc94da10a4e2a9e30dd69a376174f4bfa196265b369a1e70bd742f14765d8e9c6dcfd7b62cc02fa94ddc712e0ea66a466eed723282f84983793b40a465bd8471532ab70763272ea543a33083e9a09da71cec505db6e6f0496b9987913fb783884b0e5d01694e6dcf30587004a819bdd963e3579ff963767b82000133b2c69881a94d45618f9f4c82faec1e85ee0d91f3eea62048e79408735f91b163d96a54c129240d0968fd35a84c7875ce7a4b68f4ebcc2b26fda165be004c7524b0f5dbf451a513ef5bc764e773e5d1bc4c4c41b65a3624a66f1bd78baa684363eeee81c7cc0a2d2c5fb4023767b9e31b5535325ea1ab0d9228076080c2e6e580143f8f50cb92b3bf34119e78d8b3ba7dac5cd8974b780a749b5f41acc915616f51c12f88346e821ad169ce5798a82cba33cb2431071936cd64fddeba49457efe150f2bf2dcd76879059967f7b8e6910bf3ac943a901bd1d7c9f9b554bf3d3cdfba3c17a1ae33ebb04be0c63c584eb8cff7251d2eefd4dcab7e079c9a60dd54da4246c20c5049fed3236eb3216ec150d2d61e5bea92d442e528cd7a3bf757eb9755ed736bee87ab55a5e47fd57475a5efa2aa1d6950c863582a42ca0f5c8a3d21117f09562b132f97c1b1d2b316c13a13b4ec18aa61e2bbe59d37a6dc0e6a46e406636f4611a1c546a69b6f861d24ac945ea739afd8ba2d3cf0626fa760581fe89a7cd9d15c8e317a12d539dba9e43a7e338d2a5577011786a78d7949b6c3dd1c9fbea2601d49c92fc9e995c2f6d3d96e8da878ebf268a9d8e78913891cadbf520f45bbdc75a7681064441148e3cdef04920802fcc10e33a46902af3cc6e1ed08fa14f00b9a54a015b91b121f2f440a69ca8e8ec4187595e336b09d6bf2de60427f5b072c2a878ebbbfa2e5d7440e7ee48cf4f15d89eb3177dbea5149f3a345608efc7afc4166e5423e3eed084d5da90e25b8bda6e62e56ffaeb4ca0494d80b1a05741a5597e154306c9d8997ca10ce78f82c2add66e1b90a5b6a15b0eb242a6d668b69dc0110ae8227a883d7fb128d178ab92bc742dd734e4620a7f8c12ae0032d98db036aa21d2006026da9e27efe00bd88fbaa92d87acd7b5cbe88dbbfddbcbead52f40c1e7459c1fb1ee9c8d06a055d19eb082b988941c527763971e73f366f87b36346224e8cf8a9c350cf325e0798471ab36bdbc750b27edb349c9b1628a2aed03a95cf2f1fac54d4c1d85c6473b2ff88f12db6e4146948ca50c4049a02e627b1c421482b1ebbb9c3c95ddcab75564c9838c6e754cacd3b5d6dc1565d15c6e7ea2cf6239e9204451377f721a7e9a779666fb8a5f57efadba169aa04ca7587126b93b4d579a209a06daf38b5bb529aa1a68d036a57e514fcd1a46ff032cc382597ada6b17b3ec3398b2854293c4fc57866cb0c52ebb870095cb1fa4ac63f678a40d64ca53ee6fa048a877008588715c7054a682a22f1b00f18dc5158327272761324b6b0cc4612b31f86b98f60a3abeec126ae72e5836ca86f0527d9d69225a2058e98ff6394c5e2a6162117ba7edc1afb63353243026813aada30f377cb287dbc1690a0b6a6b1713c2234b0176af60693928e0988c7fd4fb63a442a5debe620babfadf87f8f0b72e3e6f682810ef4778acfaae249b4bf9ce0f1287d74b825b1d4dc61226de732f589171c37528f9c9c31ce531b05b77d58db7e14a8cdfb88952aa38012a1082b996e3ffd5b4c74549b7bb24d536198a8fd32fbfe1331bffed6ebbbd5fd9b17cad425b8d81b2728823ce88f2a195caa7e78ec0ba6250602302df2d4f5a3e05013cff42a42f2c8f87fd9e86fca0d334d04cc45deb0467f44778064156cdf5d29649da12fa2d588c597f8c17622e8e1a374401837f24eba5a6efb0c7e55396f00ec1aa12ea0d81c1c6d27c6187cde180ce70719f9350dde69ff203a29da0e195df3ed73a79ab5a7ab7c3f8e12ece2758efbbf85548e2c3d165213d16868390b9129779023bbd0a439f5b0bc6cb04c82387df807c19417b944546c5b562e03b9093fd0dcfb4af48f4a49b34c4512c180c33bf1c0b0b2da3fc2b3da2dce2ad0c8809c2ad063f9294b1e1346085ff2b8021096bc85bf82f4c95c92e4aa609ffc749241e2cb1403e2889e6a1386471743333b87732e43197eba2797aecaec21461e733e843314f99da458a6057099d8469efb2a0be2f98f07c7e818d58322f8e3d03c1c3221dcdd11f5b82c69baa1de6fbd245e46fb3cc120d921b92fca79ef4fc72c8801ef5e20342c3b1cccc8dd75ad3eb5724977f47d5338dff4b9a613e23c55c00980fe55d267854a90bde385b1bae3d5b352d53b47c60679742d3f4dcabccc5603aaa7f31a958bc2467f007ae50ae83576be9b98fc0be809de22a30c88a5c9588c68c21a7bca9bcfbd28268de0e09a0b1d91e487069b851d1d44e06fd849f6fc0b8d819692953ebec9ed454c96ce131c6046a984b036ddac3b35b37f433a37650a1c228a8200e4459f0914d43761cdf810d9eb0190ad8fad11a48f350258d075f0c61e87bb36c065155a3f6ad0f8be03478765e995c6caac0375b38ecfd2af949292594707926dbcc64e91634a574969f449ce07f5b19125547a696a048081a14f41855f1f74369da78babed28a97b9ac32c591c85ce963aa7c4d3965a1d28472f73aafd842b7a42f23fae5ed9296f68bb1ad6d848c7d0a5a41580fa78a8e2fefd75fbfb9d6294cafe9e137d2bb49a51a655de24cad7c111ce1e4b8d02f7efc3b68ca3a090cc342df9183358befe9a7ae9b9c1717011e2a0123105fb0c82334fe0a9e800d377eb63034537cf2577c85f94cb9cab4dbcf2a1ad3078186e1ff165e7c5c9d6e36cbad9ce1729003dffd4b9de8e99714cad8291f51ca0e1519a201243286257683c9a35b28d51674bbaff8fa82e12eb1ff27ac44337ce162ff6ee1df9cac9891b9c530062497fd927b5a06aad8a5b7de0d61b2ca1154c783795b89e0a9d88e05b67eab2913b70fbc8715ba3d49579ce29ba5b4c4f4ec773b2273b61ea47254e5ef2bfdc61124723031d84fbd1785083f6be5b794f6f88cee4636cc063e807d9d3b32297181e41a1d7695b843c2fcf8668fd1c156b4ff924de6480e6f69bb0581edb1db9de31d7a48e2cab4efff817a8a0d85738c8439078e57c7339d14d382d2d756548642a65eed77ae03d4a70f6aa01c6466d7f67f1802a58ee821fa83ac1fd716ebef69e50fcbe849946c30ccf79d0e667da126fcf7a089e777332edaa60619a783e57f42e398d34cdc10701d143fee7d26ea9099d7e8e234d29279d4d6068bf167c0725c20b7fa8057e8b608c3647d832230821ae8651938a9d7b85ba546112373c664c7a6e7757c808bb117e6c9672afdc51dad5aeb393f1c5d2bbed741b3dd5ab3d39b7417ebd734a08c614c6b8d01fcc91d976e8e6cc9972ac5b4ed1a50093229bd4a88c265f4a6dccae05f546319cbbf183374a6198386f9a7530573f956d377132340dbfbb358356b0bfe2b2f4ba434bb1ca30fddaeee83f6f3dc5230f92e4acf78e5fcfba0730443d4c910162b2f385cdd478616d2b2a80134eb6f938e28255f39f7c4577385d3b970eff3c48dab918fd56f6d75c4e3f2266086bb059bd89ae2cd2da08f0f63edb801209f81b6440fd46d73668078aa9039cc018d3266528615d0c32b7c1a8202b11803707b8e09e0b19760d62e90f095736829a6ce9a106de14a618f982d17f1a83eb2fadf6a2e5ed89e17f72edc00081372084ecf48d7022bf54a51fee72f76f2e827c3f202d7453d503042a21cf6683404ee2762388228a8c39b61fa2517aee15a8f821b633ee8736a259df70971db2a13cc9d94557353af020b8d9435537831e5dd680755e7a5596de8a9f9940da0d18f7980595e4a205f9f976fdd4c0f1d212f16eaee485a4c52cb2baa6c32364b87f91032ac06c1fc73ae11c6ee78576a9bcf74d091b016992c99ec49131cce46c0d10bb33404774b939d6a396b95bd0d721bb451e34faaac91679d7a8f3abdbd674d4b1e64a6e178661fc50dd3995b9cb1fb7384ba5eeb7272fe471511b76d44e53d77df76c991aceac516b66f460e7cdf2b3ac7a802ef93a87cc2ae9fcada539cb9c45d8ed3c5e5989c92a3c8594f0115321c887a953f17d3870114d34e89d23043d5d1dd680141348f0d63b9565ef65b663c79ac7266a3a67f3ffb22f47d85d843523e29fa872a797fb48f7a8342dc2fd7ce0437384bae0124321d29a0a206fb0db01c99ea869907f044b1788707a9edd64c3bf5c82ab2a6c6fa08fc0abcadac5794161e599bf9f0d44170433f025ef5047e40eb5275fe4537167b7572424fbe8ba6a2d6f90c639b17015e3e6faac9815583877b309bdbde3b8652790614fb8bb37c3b8bb56043e658285de7fc181a7e5291957932429d9637e5261a5d902067beeffb1e611bd7f066e6aadf1df46388895c6c6a27463b097a1e075c909ca7334983059bd52b3892babeb2ed522a54afe58d41fc824d90e9f02d08e65b2cad37872baef67a4f739f59bb949bee5d0ae3e1b58253b18d67c108af4ac333433ca4243c80fdad845a369486c2f16c752914931cca9e573083ec63ad66940d59be76e7c30c4168a3f019e4763b4d56112219674c405df9f4d19654e40da9f3522823b21625736b8fd7834a5fc09204fca69b319f418f2c27ade60e9b9866f17637a07938778a580bf75e638de79052d31eb6ff55c233968751a3d96c90d6128451328dac6d7fbe497d916a3702adc90e0dab2d15c1f958fda571126597450108ca3ca357d7a38195ba6f279924a41b5b68497053309b21eef90891058fd8dc71beaccbbd7544545acf92e0ad10e4754c545b560f6672029eb7c975ae1f8de7b568ecf0daf53360aaeef9f70432e6661e9f9c6788c099df13171deb91beeed62bf07eb81a7fc0e1669a0f6f91e5e4994cdef54c52702f1f92b8dc5f3c89f76696bc4db7d94968482c7a92620c53fc02c0e92869b6ab3a306b7d32571104dec5f59df5015a691b85108bcf962336fdd2a653f85dbe51726c5166195daab7ec11177ca9a56ce4a3a87153ced0807c68127f599748e2837459025d625b102a0efce5eaba3d35722044e4b456940e5367d9d1817a07bf3fe25969068c2918df599a8dfba8c7a377810ce284b13f6d38042c2f6dc4057bf41445c996021eef4d053c6bda4d3c947c7ad403f920883ad162e3a1f01040d595d4e71a9811dd7e70f62cb1f004d93170db095a657413e9db8b5a40cc0e26ae8e356b55ec3c4ae774c3f3e3f3e13ae46ba160114cc6a46932c4a32211a98f41ac8d34f5acb3c4d5b7a8fb1516cb9f3b90f8660c725a7db835371bdca046216ff55c69306dc6de3a4a3cf0e4a3ea7822a0e3507d060f8b5e67fd57ce13b6f88cfa2375c295fe5f854e86b9e25494f8450efb0c70b86613ade171994b541dcc4f2a9f19249df459ce02448f6cc1d1b5adb14d47919af0db5cc3f8157cd2a9f46eee6b2bfd6f2e9412ca93937b01b2857ede2bf783a7ce51c647a75f8ecee8eb7331da14ff22d4e51c516080fd586aee75620afc69cc60f77e26690577b5b78e8217578961f1f596860fa8601de1297e63185171bfd898ff26c61517cd49ab3d12635c7c08576e92bebf72b32826c06c549fa100403610fc920ca1dbcfc55d83e3a070248a20c373fc8f6c4ba6f9020c084fe4c3974c0614dd82223b7c70e2b64c43d801fd7dacdbcc42a21793cf54d47815b3d6cc976926a5f1caf0315e1dcea63559be53c6d5a68864593d1abe67a031d5376cdd0e04a403765cd493976976d63b61077bc7c907fe9b77ee62ebbc862291a6c8ffe59077b133405358ee779a34c02c9ce87423114fc7149d8c6f2f3d8ce3986d5b54830a45ca1c2251df7172dfd50fe5f72ef964a251aa4b51b29cdb58095b4e456cb8e2ca05066058c25cac661fed6284406699855dd9a7ee5f4c133efc4a975fb086d4fe535d7de230a9a08514509d8dc9c5242038ecc8b580e09e7586ebc8e860d786c19bb4893c9a1b6f27fec5b17337d34e6ba99864403b38b0be52aa4774872b75d2f9b10e975274fd5cacf3ff3f6883332bbb5cac830d4f2c5470ae672d2031426029423d4ade0d55bfdb0bb7a75c97496a604f9682da461a71f08f93f10e22d31845ecd2bf88f59afe48f29d05c04367984de49ec85c36f447edae3e0d08bfdfe71a5d900f60de741deecba140f4e915fcd84d081b87d3c4123704de69fabf0f99def1f28f30492c57dc8a8ad23e00e9268113429a366ce3ccb0982bb616a74a1ffbf46cbcd3956b58d74257141d38e2487b1544c7865bf8cf0f6244a540b85d917e03cfa004fa632ba6d89a360345ed4b1eb9b076dcf7b540ffbd5eb48b9a6e0d3f3f58e81d9511ca9cb5990045479e1918069cdbce29228983ac7d57591bb251a76005a43735f4e1b4b79fe12c7974a301c7fcf99a5a2ae3ef28d9dfde15ae3042aec31fe951c93fcea7625123ace82377280bd405021dda239f477031d5e2f93ef20d63fa669d8b922e3bf1916d9ec1238af3b5a2d9192bd5844277795c4839126c12e7823eaa909dc1661c743a814407dac36d5f4cd3f5213b4f63a9989f5bc64566abb2dc391f4ff6a18c2a814281895c473f1f799217010f4f1218f53b58a2f11eb697117855df2cc55ee52fcfb7b5baebce00aa94e912c9b2043a9f46658b3530e04290d1bec4a6dc4803a4f2316935f2700b052cf17c937a7b60fe5a447f4a181e5c2700676f25a30adee3c5f6281599a5088c62f4a27e953986b1ebf62d86b455eed5ab4e9b3f4a45625886add9beb376f5fcdbea1ca3b6c531ee52a3faa0fb0acaee7590aac632a287f393c607224b16199d52b3372dcdf2307264544f458c4c000a4bbf93401524790a4d0990175a518088235994232132ddb6c6b210855762b5081ae94476bb87bcc1c3bc3b0516b2b774e7d27da2abc982fbb8bf3363d15c33188b7c1e55cd80001587b520f6672031e81b5ce174b5482049fa7b91b127a9763da715e5af51b8e857d3563425290665f4f58cebcd49882c6b37390c7c4fe75e8bbce60ab0a7cf388274084dba933dac30db38577e4c9a5a900c113e0d182a04205660b29cac947d79e451c2e0e50a92633ae9ea0abac8def356c2f6ca2dbfaf09d527b71045c637b55bc883e02b54f03645be15042717c3ec2d0907c8d9a5a7b2078248ddcb0078e9c43d42d3f95b89899f356fcedf583fb6ede4b3005010da715579cc785e5b40b88816d31730134d20f7abbf1ad8145cbfe276918ea3025efb959e167fc0f6aa56231a0f0c4ab53d5acf84033586d7ee2d9f89b7b3e23dded54afed21b433fc8ad4f86df130cb5859811502e3e4f28448fff8fd3b2300ef22b0acb3385a46d8e182fa3e3b5de83e16efb9b2c2ea72cc7348db353531a447fd991b110d688cd21802b74e6d0873a2aee3a7725533f72f30b5d41953f5875fa75ad6c702d23ca89901bf2389ecbdd5c138ab9c4c315fac382e5fcdff3c92e84ddb40a7ea7245d36ed52b29d01dfea45688ab8e2dbdd05dbc81f78a86b81b14ffd4523149c5d91d56561df9e8910f96ad6967743950989c82b0ef61beed74811be2b458b665f9722e189d83c08086e7f321f203bbf27fce82c868e0e66fcf2427a2250139882691413e47ff25cf687e5cdad98682c91bcff10c172d032f976539c1e8cb01c46bbd399955465a287c3c043fcdca400809de84bf0026be777ff9140143ec141eaf1341421e72615fd280591f73c993fd86bfee21d4783def88feab4d1f169cd8fc4d6b43dbc52dea0c968a7777db6b1b9d456815837a79917561fb23d15e5917f707dfedeab132cd2856b8cec63261f0533e3ef4b41fdc7a2bc68fae6bb1adf6ae7e8f9f9950ceb641080ff9f8d5aa9328af72bec58bb3a8c64fdb3a2b24b8b3e20aac5f31e43e8dcbe32f6f4392613f7a6c4892bc4a651b9a454ca2772ec9e8768d7a64dc8603c7fab170ce96d51ebc8ee9ebfefc87037c3b4e6a6925f031c86d2614e516e874e3d6aa5ed2962db4d1e18c8540b1c09bdebea4317b9e079bb431939997e08e0573cbc26f97d186fe46660f51751004f856dd8afaeb81d4523ef6f2062fb7d54dd289f81d9d00ae4f50fc1630d73d12868f987a5f4e6228c215cadd64ff48134792328e4768558b19b2861230408295b14193b617574d10304dc041c137a8535a1b1d7a5c17b90966ac6e7a1e945411e576919fe227a2714e9c41b8794444503e37ed5d9b149a0f917b7ed2c427ceed40dc47fbe4de597f07976d7e87572688f322aa0dfef1ea0263e77f4503a8825988f793ca1a80286aafd0a55c739cbc7239be258d8aaab8b2fadb54ba54ac32580ceb8d25e26bf1c9cc768e27d58d5a2dd92d0263960f23567a0cea72b42257301bdb793e4caf3e1bc1dba6c14e7690643303eddc88336842e3fa7bd7855079c517146122b23ddf5ce3006cc930abaff34943c212e0b34a57661393825bdf775d6b300e6de60eca8d529f0b85fc85dd391ee50d31540210b8f0db4c4a3f18efc53bb0843c36cd91f25cbb0c981481e8ea7ff29549745de59f6910643c67f94012741c8787e384afcc77b3aadd60e4b63df85b636530f243b80130ea20938522858e8b24a65fa3e61d8327dd2f3bbe24796125fb67f355ee0d135dd590ee8a63fff72c5abfc919a8d7bab2b862e4c3fe632bf9a2668633e8e58983f3ea013ee72b1254003aa3dff03b0b231425e880aa7c1c84c6160706ffaf8364efa3605eed6755182e87bd6892dd987a826d7ad4d34ca5d98b6a40c7e691e90e7394de114dfbbc74dc614e29c2e5591e9933b02146fdfc0afc32abfcce5f33a58790ea0650e7522a6db1e1166c24fce5985bc7d7bd89f8893878176e40b49c5218e1898c099569abed993a3cd6623b5d11975a093b32ea71833cf0d3cf5ec78b5106cfe3dd456601157404cd69e7fcf8f16627fddeaaa3a8f7722ba4a32f5037bcc9fd4104b291f586b3b7a77057d45018c756a57d02551fcb344b28385338429e25b8c64ac6f2ad139cd12867044cadee3c65668fb5f3d41fed40a7066","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
