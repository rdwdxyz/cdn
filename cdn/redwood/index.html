<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e3ee9ef976f05ddbf6fedbe9153860b95e98a272ee16488f1de47027814da05d47fd10b4bc6b41f1a9077dfa3d8d1685ccb457614a0ee6058f2e945df64087699da8260f4349bf05612f65cef368b9e372f9849a17555a86377c5cf43878dc157b66ea868ee12d2206e3f5aeeb9e44240a8b76bf150da9f6acf637b678bc1d73e33206af3cad32fc25f1777263cde21d2d9a33c868fd05770c079b065753c06128b5228eab0ccac5308a2ef27e7c7d8d909ad87ba0ac2958cd037bfaa407d6efbe97b78c550d3919e97e8a4b0dfe9a8687b402b74b5913b2e43535060bf4cb48555f98ef0d66bf4cd2b3fc998febde0b3dae8b7fcaa37df90fb1e7d526634ae757f050b8be55994734c00c4a32fa3ae0a6f702d11b304bb5830819f6abac58fc69749b17e8bae3395fb8668fa5b2e4ff475ef6260dd7dcaa7d73f189a6194951f1b83b0887630023a8cc51f517e85b8f0ca94a5639d7274559afd4529572e39c8d2a1a9d3734e6f7ef7be2c39510475bd024ffd5cb735f5ae077e631a0249ad88ed939f247ee9a130348c9eb208e6d545b3b25abd234090bb23411d20292c58b82cb3bdae01ccdbc66449fa724eca83c3327ebfca84a5926fe5d9e1ad1474e6ca6cf863830ef018a0e899bd1068a010d94b150911ac0f9be17ef1f05879627531bc60c4c31d0d2c366c3c121e8be92ee530c18f8f079f41256d62db7a0d29294427be3fa579b5bc89447b30414ef755e2ba155855678f49417a470208accb1c6b79141f491c677889e657732d7e984b98905b967dfbe8a6b1afd6f31f2093270af0a8e3e5bb5667e580ff56acf2d45eb6d5ece9c60676c281b7740986738c9ce002e267e5ea153b23ee6fc59389814ba5fa42c23d582ec540a58b28e925bbbdaadfd348ee2264888102c2c25deb6412de78b294ae99e813d11ef8a64bb205c0f8ccb7a5d8e672983d0e37b982c606cb98951911d04d7874791ddb65a48bd2bc99ab16ad16a8051902e117b57b7cf17263c39ca39b2abca0cee89de803c8b2412c4f937cfa4ef0a75e680b30a1bda38ddc4fc591c7672da7f1b2cf9d02025fbdf7efbb83d4b3c7d7dc16890271c7f85fd45f0ffe190f4b5af70b7f46892930fe1baf837c34ccbe48ea051f84fb33cb0aa0ca59484f7a1c4c90d7a77cb1d6f4400283eca886c50840683b1794828864e50b2640caaf1cc01e041977593c75a1f64b4865dadf04be91dbf00c243656891895b300ad61277c319d8323a44236c5cbab2d1f6938608ceb3492791144f2bf5b5a942076310797eae82ca0b81b4bbdab3581eee4d7545353cf4e3e8db7eaf58be6abd94841929daf7e4463eaebd1b84409dac3bbbfd957682edd7c56f54ac10ff8e0a9505e30017d33d93a7297a30bae18b254ed4942278d2c546a828238a81a0b314be868ef2a12de63bd9bfad2b5503bd211558c3c6aae8e8c7dc416bf470fd318b72a5e1f6ee18c0d0261b8919d57d55d5f7efc4d366a35857041f1a0b2133189abd73f718390f5c85ecf300cfcee8500e0c3467150ec55298d55efff080248f02a86f111cd980827b11e05aab4c86ba34f34e2e552599e0857289bc57b04f0831d1d226ad1fee682154cab02a14b3f8c1e56c6fa56cf8a6ff75408257b5954fac7de74c52e32807176e7334b571479ac43f64915fe2e59083356320ef4b725f4fcdeb44baa26b3d29d9853c71612c594c1f95fa75e713433574ba0f68fcc9a310136da442a8cfb76e91285040f9df544ad26ed80f066d955a66b50b4ddfca8fe621fbf223165067b4af5babcbf618b737b7d40d282d7a9ea54087c7f3fc20adf6c5e284381537b2255f30c703fe99c08508fb82bd0063342eb132991eb78549336f1b3889b4e487c2124aeb4fb9d721772bd6aa0413fc57a2ac79052c9c996eda46bd9b9764c6f628149fe2c0510e45103325005042a40db73604464fc66f72de44a89d84dde10ac2aa4406fee05038a73519e438f12da89c14847696c70e3449dac6abec245c56b3b770deb2a174e75d6441a5e9d883e82ad1dab8cbb40220da5b1f0db5c73aba1c76318bc2a25a6da61ec863c43ce94278e28f93bf3b669ea6ea389a43211d8fcb8985abcc7e2cf62799d8fa384f0134f71825f28fd609d7c1012bd8928db978404c84ffc13665ecdfad05a51ac7024738419a1026e1f2b10f9cad2854f5e8f82905213535b424fe032b48c17a4404cd69abdee8534228ea7faba9486c24b5a2ec45ccb16f176adb13986219ab34ea815ebdc24cf9daa5232eaa3db40e9fac2eb8078e233066be19bbb38dee84b44ab4f406fdc833d068d5224cd6cab3f5dd55eee9a32b68c3b7e7671ee69363576598fdc91f19619141f8bfa5403cb1e2cfc4f9dbb9bfe363dd685f51819668967e6320decf66007c7e42912fb4f94d8e4f19f9eabc5eba37c608bfdb62fedb8479c2cf2b9efb4e514e26d8ba59f198e316cba41d9972e6317496eccbe999caa120c17f4140c0fcaf92907c89889afcd4163a18b2ec7a707e717d16e1161950e26a376137442707adce7a37dd2dfac86e7a0dd99d9ad0b87ac3d4997ffc289eb4459a3db16d7519d3b33688db82191cdf5569975bb70c6390a90dbd3c37edf3da122b7c68c238ee4715a35f4efd8bafecde3ee68e7cda6e9a83f413553d29ced76840194746b5e581cc2a7c8864eb1ffd00ea8d08bb84ddf3c680a3ace175daac6da01cc3bfa670e24ba35201ffa23cf12ef2ba0263e5b5200a5d1c72e4effa41dc0cb405fa0d470bfa31bd64dab079cbecc0b898d1ed9bd1783806d620c793bf70c3434f1f2e8751fa2ec9966814195ba75d637460a730391d99d205627f684529f1b236580c347af6c86e6d5c78a9035c6ae5bef3dae7c75cede54f51df609f653eb6bc40eb70dda68002a14c115a139e6f16f180a542f31ca29f6e6ace851b07f4ee472f8a59ded4bb144deac0b70e40dc02b0b7f05494902bb2e066b52ba6dbc0c888736b0acf882cac04ddf5cdd53d2820454edda6dd52a90a163d0540316a950d0b89ab049c8865deee3350256f8ea62c22e4b0463e5985a5039052bb9b36b1ca54e7eb487be084b4a4c5d93fca020891371d24d81862a9de6e347c2c98d2a85af8f95bbf4485c89ad6b536a2b3673172ef78d57678a63fcaff921cf8050397b1cff442fd41ec144f46f8bee76428f994b884de8128f4c02ac804b4ed75e1a60cae602ee9cb126d6d40cc23195c15aa46ea95ef661049c07ee257a65e6e6b459d764e5cbb745ac453252a74ccdeb0bc58af76ec3a3717fd54d8a9e131b90130394b31bcf11708d081d4e9e2496ae8d39116ef9f569caab406e71669f2834dd45985892c340016bb8480dbb0515332f200e320de2617cc56756df90a19d2052166de019132bfaa4f2b80f4a303c549499acba1681816bd91bf0ba21bda1a89d46885bb5868901cbab5c8bb6abdd2a17ed37ab86135e0bf548f8723fa17b03b2e9562100a3cb38035e75c1bcb677cf99037f7f8aae9c5b090b450b9a2a0d273048a77665be9756f0f3cb54f01b0db85615b9485b00a28eca1e041bd4b3e2c780bf884e32a52ceee65566cd67ab351c93ea6a038b4cc686b8204f8a0459894c28c1ae7e24ff901389915c4dccfac94d703406800912cce910571fb4d400c3db9e7b2f6fa67d04f19bf781a7131e68842550f380ebf03c8a1934b9551aad5713c2c7a0b8ead44ea35bd622ff8a697359b4e75501cb63bc5613e82ca8d850c7f37708faa3d0bb253a6af309fd0319e6c78dced49c936144c640ad2fbf3ac324aa482a00cc6a3523a4df606ce366430b134b968e45f62792e41231c99389a0f48e315cfd0fdf43ec0d0307a4458152f75feea9e4683fa9af3b24e5bcc6d87867c6b61ef0d2bb5a6c8da095c0e92aa9ecb6cd711af553554e33cf8f7c495a5d504c247430521a01f149f20e0417717cf41ef93e609f2c18c56d59fbd60ea105071de61790dfaeaa0760140a2fc12d44ecab0a3e15f8d954a60d67cf3774ee7189c11c96b522b51ac8ab7892691053b99386ef1db2e4f76cef97ab275ff04a6370683383ce89fa6e61793952dc229448c3eed795c4218b14ebc8e9172ac51f08cb64b8e12daf6de4c6da369acd1bf54948c9538bb3b77cb8c4f39d354c65e09b3832d0dbf96918dba5f0c5ff86bb16eb56f77bad6a95898b70666e8c6334d2503dc995dbab3a06f67823a9fa82c7a174b199fae573c977e5d4875d67f16cd7b725798277827adb9a9cdcf7cc554478d6282204e642690f39900b180608eb1917d0044e2f1d9b78ea9e5c4257b915654161b52e97c24129d7a8aa00c8f2966cf78d3724101fd2f7c5db15b5fb2867876ccddb497eebb57cf8ea3908c092a7fb85eca114b88679fade7160dc41d9206a4fd4faaaa5a1a009c8011f99af9d88ff4b364dc737f38fa054b3efa20e63215cf3ebd726ba078ad59c8816acdc3c11b7285329ceabc389a2a6c0bfe18f9be251f616f1e0951c0f02072071a4487ba67d27624c8cd46b7361b1cc1fc43b39b49b05685739365abae64440d07b06a95ae99bf1aac1d9a395ab519df407431c55054cfe286c44d307c8372658f93dc22631692df477c1cdb984248691fbfcf265fdd8d268333e19f59bcc733ab8fb66959b9b4c4eaf3ebd260adcfa28654dec7af7bf908802f4f2fa8154bdfb8e4832bbc5e62b321c0404f316625ecd593224aaf6977214b23c05bf0a97007f502e4d631af53749e603f1471f640a1f428914b09b26326620356cc632a325e83e70d3317496c82cc2d43907f00949aabec44a48609b9b419f11febd446b4e728016b8f47380b86bb2d544e575880b52558ece8e76218a3f9027c7be1ae972b5d7f1e942570ddd60d4765d1d0a8b5f15c597c8cb38e6c91a864cc15c1663e48387c90f7abd2563b525377f3b566cbf959f73ad2c90910e942c6b40c3f75fc1473d27a0457723924906f4989d82d2eb3ae5a77263382eb3fdbe367deac2830fd9fdbb33f41b210614c02915f0b143500cebf6dedc03f39a1876ea9a3875516894ad0cf048219068051bfe7b6d06a1ebad8727cad064515c915a0cc212f6275b38e2746670535d9643983fce42aba2c91d9ec76ccbf6efd8709e6c7807d763f20d587a6ce9eb73bd3ef83a22e11990368d4cb135fec9e5e90e60331200ce442c729759fa5b576f29fe0eaeb92bf8f90a9c0b8875a023589d4a19ed08fdf8606bddc77d3a24be9001815f89e95aa51fd69f78e5df86cffe09be9e2bd9b93f0ff783c214e74e0898198bb04e425cfb8bad4b49a395070ca7025c81d8cd17e8e1cb16e580e09c2e2f5793fe5bdb2e5608a8e3f416d0d43abbd400b898866b1c5ad3ed35c68442f38a9fa9e716689bf3017cf8629b7c156a1bab0a1e555e563f9bd4cd81e5c0f5f9cba45ac7e1189d1bff55bc03812d0e38cd266caac9844e6e624b046b7b094b06c57b034570d718eb4aa0ff172da4dacc5b0142c476bd8eab702e405985904c1776ce9bde90d13ac5d2433d8d00695b301d55d50dd4c74990ff08b3e7b4c50a2033067d84b8defeb25c3c5636707d26e6456a399fde476c1add70f6c0b352658da07ad984b298be85cdc1079f217da249f3d61debd95b1ddc517b683eda0a0258de6a2d28ca72289759d23fb50f24be68707198336604260bbae1b57c642ec8125adb75c39f7bd5b7d731339f51513fa375f4b358eb74a5ce426d41180d121087ea3af2ddd4a046db7edd3a0d1b4c5ab41730f1d84a1dda606398ccd51476cfcd3de23181fafbf6bcb04ac7c1e29360aa699633328a7df548f7abb0b46eda45b561aac5a1da45f4186115df81babeb1ee54bd0daf4981b67545afcbf65d0aa78acf72e0bb340c6357319e5446f5162d1c2f6b250b7f2137236dc4c960b4d2d1401eaf1f3843e4e510278ab381e8f589ac81af4a5534388a2c146d744ea83acd0f04c67998033ec84785a46d1d1b304106a0d38677e2708c8f41ee3f753539e99b21ff9a9b5a28f037749f56287cd349309ca9163ccc3548399d1eedf2d55e92d5e28109eb58202a7eac19b9452ababfed782d5054f1b8f0cf6f43a2fd25c7b7647338b046fa093448a111deb0c9f41a01e5b4a40eb204b7229051caaa55909c63a639b4f67ce939d6d1ae2388c2c2064166d1ed86a141848c59abc34fafeb8f6bb8de6c73e43bf2446e6575b07670d8637f8f05c2ee3fd07e4450915a9e4586eecab923434a86daacea435699b6d5153c35d6c6ac2898b104e506369f06cf7c137ff077e90fbb0a98a4e5e4bb19c447a43fca0fac5f3de7782e287151050cee9450b152aee365ad3f2346e6613973e60296e7dbb103f02fffb974da4e63b99ce554da5aa614b53e2be03eeac1fd505b27aaed27b238fb7ebda1ae870f998392cda23900d7a77c29230681169c9e52733f0a283b23f2ce22a3037c3dbc6d1976f429b511319fc3106320271afd44d5c8878d914e5d80dba2ff89261eaac986aa6e6f2b1c492159d923d4fda16580df59e3a1a1bfc4de001a499d0516093fd9eb7ebc9e17900dcc4f21f34e116dea5fe1fb9863b9368e23584d0caafdd3fb202344261659c4c46807fa18ef87b5885a051deaa38e72f4e7a314c9562d07293e6fbcdf3dd46c69562084c2e209e9dafdc76fb421efd906d834f8eeba0085e825e8eb87a9a48f517dec0de99be0168f4c14bffaf6a653db5de34aee70f66a969850def7057193e273ba26109b77859fb7aee74f0de90182dc97009c35abe2f3ce38a883bdb0e6dca2cd569ca4015e9ede887f59f866915fe3b2752d5f013760bbeebf958b1378f82355d1440a27303cb23c1f69be10274ac25ff021ed6a70a06eac085398e94f2b0f1d78e597c2b4bc30cca4162ec7d0f56e27179b903ab499b60ebfba26369d5ae60d584993d1b906855ef73489ede0aa4327aaec0a3a63b1ba4f4d08ba7fa6da970e9b3783b2c21ddf9ea4ec4a49981b1944ef356c041a1338071256b9508ad7a2fbd5778825695abc94f8a165c1da0e6741b9ccab0807d3a7cd51d5eb729d2f1ea624a2e7ad6c72ae484787f461fda3e741b53d913d5f526103fb6f3dde976fb1a6ab1156c94fd12070b568ccdd05343b6ad422aa2c26dea3983f4789114d50c2ffbfd802d5f89732c11721df12ee3c0ba939f2a8731738f054633b82daa2ba2ad3ffe1104b79d95b7750ff013df76229ff4cb86450a1853f259a58f57bc063fdb871f601cbdab91a37a8eb0bbc33be2859b899b51692333dd2ed39a2650adcb81e827f9267b3d268920e20fceb5c46cd349be9feb0f11bc9b2d09bed8a5a62679c3e6f59c7c32c7a2279c7e2b9c97d9496fad6174da96e750e45aae0eaabef0c87f5f3bfb19f16157dc6268ce5de13e9efd10f803865f2621430724f885516f70d37abc0cbbf1d1058d5c275a204da02fa05ec351034e9505bc6cf44f0b1b23ed795a01e5d70c2c3414c9d77e4d4dd181dde1b8e9f16cb2304d44254d251bac49dc3257250a9f30869db592a6f75ad8c0ba707083439cbd521a155b1d6fc99c0d0cdc539f910f2f9fa1a3b97272a9a113deba40f247dca4db43aa39600789c4c4c8c7c431e9f69934eda29082695acf2074ff75f9b0a0f01013cec9b7816fe61848ad74de6a945618e7d0feb2b481d3458dbe8f60d5876b9f1df0eaa192c960f89531eb925777cd3b3a8286cd894555d405ae5075b8e7a8a9dcbd56dc895fe6065da84171f21c6cdfeaf86ee7c64efa0c885f3974985f615271dc0aa946986bab451f484d10bf38cdf70052405bab0f0b3968862e52eca8854a0f4c661ce69f2c8f4ddfed1a86edb0e461ae9e6184b5bfab6f1ac43645e98c9d23974975c6b9f3ed37b3ad59cc8d9a8069eb9a61e1b3116e938896679693836eb5a3bfbd2dff4ccabadab83a40e0f72845f5648f59a0c55a90617c3d20255158c3ab9bbc5cc503bb5f053cf3b008e2de214a8e7b8736bfd83d09309bbd0e7533f0805fca81e2c37b5f951ba55b14b26ef55e4e6b45ae18b34bdac8fd953ce5bc96277689bc6623b97cfce18ca23a2057d268d4f5cb8e125f3b01ee45f152fa34d2bd5e030a4885251ca454416b2ad4d268ec3e4495e1a1a4f01ff65097a101d55ce93193970d5eb6b5fb66b025cc4a762ef06f3c3d4af8889b766f9296ba872ba5d6d014f34aefe3e2851cbe11f7335b6a596d33f3c0e245c96f209d2cce2fe67b819395c4b5096d9e8bf9e77fb8075d890bc7fa7d15e2b33c6130d3ab66565de5ee1530c9e89a7b24c49fc203c8799841142d8a36ea6bccd8705d6de3cad081e2d38827e6fa7d9f3c9b9d035a1aec1c4958d269bae2d975ccf4e957b3938036bcaba683bc47b364cea735e22c4f635ea2ccc1e6ada729a6ced43c4aa7e24d6b6be54e6f600f13b4fa0c95b01c19c9352ee2602b3a35e23ee968e58e18a1824c0130de9d0733661cd6874975c5fd03808c783e9dc8906e54462b0f7729d51c02b8da2045e9f22979a83c7f72e1e881054736903c31828715a912fdbf0acf71567e45a12dedb1fce25e5e4d9216b687a60bbc6b20fd5343dc3db574f77f92d568efdc5dc889465dc9562ce1b71b0d03e4ab2b3994a930f091f1dfe02527d9ea5c36dc71baf7c1bb22231bc57d7650507fcc8ecd40bbfd89f1485e72a2f4978225efd345857e563b797af44b9a073f4355659c769cdf574a16c718835ce896d93587e412dd27ec0173c4f1ccb9c299933368f98899312711cde94e89829ada4a1e72057bc8361687e93b93ba80a9eccf0c758903cb26e815315ca3c2d3c845eb923b694158ae66cc7914dce1e1d8bc156c474a48800585fdb60961139a5006a147b937c46525b68b759114a0f024c5d98db4e44f707fa786c5b67496e3bb43b33243c7f8cee56cd2f97f16b8fc5ba6c60f233e7b396ce58dd4d54eee09142c17d52adf7081b9aa33c97cf3918dc2c36c2af0d3a5c01c1bc9ca0903df91324621d4cbaec075c6ed9de0d1150e2cd6589babddd72771cdd1e613e553f46522d18bb237de1548a1905824b4056696e42dd8d55fd3aae6fe76a0160ab7ba1d3d651592bb662cffb7ab40adf85919d2a6d05ed9ab46ee23f3c572ffa1927877c78edbd4c5ca6582b4d0f5ec448fc5f36b36590aa6c4080057653fe3a410686d1be01e6848bb391b2ace454bf7ae88ea0b2a1f5c23016fba64720d74168a97ada36978e8dea5670f5c5249330e60a95cabca0f269b2d77d1dac9d545548cd680e5712f8a1d5df94e63fa998015575acec8914a5f058151a84265739d344e34d6c8fe166b13eb129c6aa30a2ce015ce9718ed233d71ddc704df69aa1ad1c6668d185657c7bd1848642524e2029798294fb505bb9229f08b81bbf6c58df66f147c316cb71ed87ffcb88c01529f0f89aaa697773d615cb02b899e4a9a52cb09bac150c04339cdf6cab16e5bb24cd3dd991542e5fe1820dc75a3e1843be33062227076691dc6dfdcca59822700fbfcff599d9615a2a4aca315cd11ae1c9d897bf3eabd4fd83358bdbaf345da31cdf3de0f68c060728178f8627ffc5fda76a93da9207721c8c254640b38a6320c61c6342e5c75c78aa5433661144ced93cb18b4513d4ee16278b89ccd47ca4f29d314a0feb247b43848711eadcae7b96f46b72f46b6255f26c99fd6b93004a2a2195f35c5c86e1d7b4e38d844e015b9fbd44746e9a10d205e146585798163e66e3d45795f8ac8e6e9a93de0360e7b3809caa3049e6f3840dea5d32ed66e7ec774ee9590c73946ae6b8409fab04ef84d63030dae02f155ee4077fe9252fa2245ddfc756ad5c06384843a9d67d924a87a4b26835c8a946c5c6a9e19cef351cafdabf0bf01445ddad993bc3fafe0eac8e69e90c0bf029de90ea677674be68f726ba6ea99f67a988e517db8b8d6f63771463e2411a5abc6d870ec598d7a4b18d2fb5d1dc904c1b61f575cda8358f47c874c2a903f35165b086aad1637b2954daee5dfcda603ed0ab1e1ab8457bacd47ab9754177c1e805b12ca8e3f60e518a1ccbc839eff341d6c4c2e22aa4cc8883733b39db07dd3924f66b840dd852abdff4e0e2b014e8717369a112218b32f0399bea85f26b1fb28dd30f05e8e1e200521a049eb05719dbcec58d080f31dd1e26c26165ed92c135facde662e34c0b99443d7bb255067112efb680c3230973eaebe86f5d28a7f80f105c74991b53925aff1d3a919362069f5165322aa98dea5ac7508ca1e008ffc9c88bac0b573ff46b8b8530fe06bef07151e7d3b242ae1f5ece8f2dd96d56adbcb48d51a951b58ec27aa10bdf9423b8e38c4683559596d63930f9ce4266d7c411c6f1d4f9b46d62fe2244b2b3373b20462a2b191c719414c35796c02efe1d2a8cb552fa98e89655d8f1656b758d7019c423a5805860121e9706ab9ba39843c00cad3159fdd409652b3b53cf3e6c06489d32361ad72f44781fd38d5178e2432addcc785674113167d54d1cda72addf65a7dd1c74eb795c228d67bae22b66edf735ab22271ab2b786c4ce161f1c96ee43c288cb660b56543320c239fb049b6ba6be28bfdb21abe4aab536b041aaeff4ccc9aa39a18606aeff925b76f83f440ba46abda9e74e527c76da12894b9685b52a0e7e7520dfeca171b343201f40215e4a0f215c69f528d02dd301547b17520ebac717f9c410248da11ccef606e85b4a1c172044ec901321e7ad7fc58a7c770fba03da4edc65295d63f757742454967493d79fbb5b3f3041aad6058e24e9ca16ebc92a524696eeac6760167cc0cdaf943ba51e8d346a94d549b7ba328fba8203af3f3040c37e791bcbe7acc1ab1dce9dfa203dc92cd5f74e2442ecec3579d386e0721f6333982581d453511d7a3831fad949c7249a575767c1e9e766d9cd06f270af20577621e4116bbb292af3e0c9dc4895d03db30e4a6c2d275e078fe17a314ef15bfd8de2d89de3a7ccc103915ded076cc8359727b9db1b1aaf9abad1222f2dedf50b3e8a9ac8def0390fb24ce3af04f93475d91b51f9549b53352e3a1e596bfa3d62038b1ec1cfe3ba29b8333155bb2339a5157c84e21ad4d7c708a2e89062f44a2430a714f3271bf6224f812aa307d15b9ec63cb8ab179a8208f3abcdbcb48a596331159d31a9022c1d045c82b31288b5ba9d7dadfaf5ae5163cbac2180024ac1d048d319d1bd3a82e57f60b4cadc7be45c0430cd99abbf522425673d614ffc655cce61b7f1932b2a72dca622ab8a03dce793125f805e64156ffa9ae345fbe9e061b28f35d43edba599c6cdd53159289b9257a9bdd532f9344a8e3b97f58c2d9a36266ffedb940897666a9e13f18ae5d07d52c2545b76f346a2ac2bba8720bad762fc73db6665dad8898c0b4a27b968c1612d2c446b3849d7b29c27e5e29aef9434f721a4d644865050a902511df3226ce3fc65f878500ad1840097c32694a58d94d7a33c7e01bbe9798f639028dd3d8c677a0098addc4059e33efa0c36ae6fe83f3188098e52e221e8db9b7841ec7e9e9df5d0a039f2decd7a2809dd0db0c98073ac2176b468f07293220b5b573a7db418b9bb0a6208936c450746d3e2828baea0f63e0a4b9ef3e67850059d3fa1135173ee9df457845775f44a711204d23dbd2378fde6fe5edbf29b75f3e7ec0345aa215720c7ad1c9507b156ed3296d7876610894882864d417b1ff2290412e71258d55dd44820b6fb75917cf2d862981a2eb2d674bd1acadbe518608d29d3f4a5ea767209e9c4fc58b43d9f6204f0b23e390a23f9a85cee7e9d0bcc54b1df6444473e67c6799225254abef7d6368e392c865c7d3de0b325a7c05cb4e3475fa560a631cbf94e6f873f76834f65e6077121b4b7195e689e2783c2f027bc39fdc2fbe76e6ef2d5bffe6ce4263b60f7ce1af4ea1663719318bfbdb53b92bfb52124a2fe64d2f7c6d800964bb7959f4d6373c984f9ea6e1b9680d93a7078568b39dec955683681463f733ec0fc05f913fa3c0d377539d024a2afa70cb5a8d91d5186fa01fac10628e36863b3661423bfe67911b35f642f9fc7439af2830884d1f494797ac826e175fc6459b389acf6c0b2290d09b5612bfc684361f3299ba9307fceb68a5ecb2affeaa92e696a01f7227369a065f547d551b25d6d3be64c83e45d9b029f67cc378a0fe6f2e1d24df3d067e454ea9d77e74131b15d2cf70e7ad63357cd3700bcfe2285811b3710cf596c61963f3247d9fb352ad334d1d22be222dd9f090c7c077ea504832434457ebffd03a1a7019fcb44d5ab13f7feef2d0fa4434d9f333e91b29029e8e6f60eefa7e377d03d31526fcbba58a50f9aeb476f5eba67d941e273dad71ff6534a8d47d89ae0cd80ad6f362040f308a8dbcc06e11b604b1912b3a552447a83e7dd62221201851df8c17e8d06bc629fae3b9bb2256e20f7730e33e087d03235533a48b019e0dfe57d894205936f68481914765d26c59e3123d5c6f0196a35cfc5e497b7c49a4ce2508676e266fa6d5766442aa785755b18cd670a1e0200109186bab43e07987b4c5f4d9ec3eca69b65a1ebbd5f98e1e080f37d8956ee351b7d7d1a4acdcf470ca935621c81f04ed79b2bf13affac94ea7bd419e8e0686a8bf2b43268f64aa8d5052c81c6a591187107b88dee3c2ed03a870c387875615dc06518b73dea5bd48de3b48b71d8cd44ef97025b41117fe6fb742451a21ea300c14051fd293c68616e6ed4f980f2236db3a941dd2972a859bb042a05008e8729d63e40dffb20a99d180eb7afc7be4b7bd839a4950c44f2b846b5bf73d08f9b8b96a7811645d6df76b765a23a027bd28238be03fa5fc40a24d5d805f3c6298154f1d5336ded8b89307a2351984db1809f8f9e45713f96c707c9e39d51f908be51ff3c9c14eae6942b66bdf481b3792c6392e07a7601f2e0510750d0c7c8574808a6c98deeb2eff21352bffaa7aa34bdffc74fcac90abb8d7a212174c98bf55cd2d3d23f272ceee8a79b4027fee71ee42f0ad396fbf6012ffc189978265f86a5a06d69cfb9e60c2433f5737123f158e8606dc7d5bdcc9669746df712dde6ac8dba5fb9dfbcf1c947904b4a09ce2c17df643cf247c93d53d41c65defcdff236256b0294e9f89b87ef7112789103ee9967702ce30ac521ff0630e2b57bc89a20e2988a58dc72324008a5d3e89c40b6876be49cb8de3122361da513b0016854d0e90e2920527165e0f19c4c148261a84ab0b99d59a34a9e548c1206c64d1e74df6f04ae7185f19a8393ccd3297d881c129f596320d86f1427b1983971869986f00ed6393d40705beea6725dc8391ff57cb094b0b356774cf17105e68201838a21995118b78dab6e44318afdb9b3a24fad0d2360a927e7c38e8d61d399317b5647360fb812b305496ae69989f671743050289c34965a6f5484a67fd94e5224958c635d1335615bd0f54c6442326fa47e531e887fe33bfdb39ac2dbcd24191e13b3f467ad470dbff86a1ced7f94c17d5d4c27294b9615361d7cb2b4b4cb0be6a2b0752525da869248932454fcb3c38861c60d2ed6fd881f3a0bfb49a12fea29d151d1bf266891f2bb9243f6f3ac32285da9bc5c44e1fd1e38f02c188a39fe0e1351f388a1c2961e2b9302c5e18c1f9e1fe8942e98f127c306dc9939d0e08eafd79250ad077886c4e82f1b088ee14032e614d5aa56ecc428f7e801366d0c1a4295b3bc2a1aaa9c2e0ae0128bb0115f6acfbd6cab64924de47fc9410f61b3cc6215ddff73741997d157edb8c61ad06dced23d76dc47ae108c9281c5f35e3aadcd89ab4d2163332ee2ae68803c38f3e682b9032a261d12e8e6d8e2b43982fcae50a1fe22cb9324fb01ec7a41a7197268e87828bdc2acc5d902bd12dbd7aa2cd53533dfd10bff916318963e652799b9e924a4d8b5a51dcd33a67270af4f51a005c12f2031cf8064bf33550edb6f44babb5b5c14a4802608384d5a9b56c54d393cc8009fc7b310251a29c72f4279234c689b6efd455c1c6534273af10b7584c1bd73c2173e91f53f0df2937e148c38d7908bbad49a7b37cbb1b28ab35d29ce5f44453dd92800f969afae4e1cb4a2fb97591a3487456003a549b83dc262bbc2cc9bd16c95afb9aa9dcdd08f10bac0a71d5c9ad04acefb32ddafc5d3731a72efd1254c9daa229bffc02ee6d8a1b44f59f4d6cecabb881f2440436403bfe84ddfde289891451e2f51e1b3bb650c8d6121f5cfd2339954cbcafa0584cc6b60162baf6f9cd6d71372bc5175e2edbea500099ee1949a5cfa7740958c0969dd5c0ef9186a9a5745de919ce8c420746bff27561a27444c664d5fde4e8148b5d59bb5efd3ecf74cd87b17e5e7913bb20ad5ef49d3ad78c2201b6274eff4ca922ae34de5106ae9611d1f2285d60b99b10c3e24ccf3e6f0b74aa45ea9f8b113b4d082c5eef9c82fe20646302b5ba28d6499823ea1c87577338f519e2e504a5b90478da1b80a5fb5b1655396eea5c675eb4077fc4befada8405337aa8a651e095efa4f66c1d3c590e3d13919f4d22bf202749efd5267084660be28c6cfe9905fccc92cc8cc20b6791c4a0a8b718cc17dece0a4cba5649c8a7412de62fa64ee71b7432cfa1461f8c91c261ad77cb548ea7259aa65a7d45093de3233c823cc14bf571a135e3c2b2badc839076b14d6b499ca10216039b660a2dff06a12a8f4e26f5f1e5510cae53718db4970c554fec46d7941e8f0462780f4bff9d19199979079e406b5be479fd5f54a5282b32e4493b85ce392919f67a9644249cd34ef42633615ae681f84d0f7794a9674b85258ae9563745a61ec3d9dcd9adde81b6ea91a3358702be94ed4e82551e4500e94ca7b7f283f61f7c1478df49879a491ebc666b33b3c587f300746ca196a76cf02f7240e524fc5771e86760404c31feca89dcb0584d8a28302ef22aa19e6f7cdbf390d4f6aec6a09213aed0a2319707dfb0b80bae3e2e85db0819d9a63dbad28d17186f7cc6fd2d387c1ec6774da4aa4bc3f01823f3321fc388080e5d07eb658f6bddcff0362830ce2f8424f234258c5600d5fdba8eca1de6cbfb58e8d7f84ff9f14b5dee4357b819887ab23dc114598285309c94bb307e78782944ec7163f83c8643530d18d27e0d676f50c356d067c07b706dbb366c29db76ddcb65e91b66e45c56fec155d2556eaff037b587f34cf4163d72bb90d83aa872e2da99df94c1ceb0b97a70ae1f407dfec1539f446118bbb2c0b463526a71fc62a0e429565133a94c861d9416d3526503d789d48ed3021af81e26893c1c771a694829074f6bdb512f57686175aaaf938008467adb2478ef4fa8e8eb25be35db8768588e4404bdc8768d48568629b1b6e233f980a67f7bba49ed2dcd4cd13cc4ed668db1bef0d72e818fcc3c7de79096d0c848100d22f7b8dd3f0b381d188365bda32c186f77c496d2d4d1af478e1df04dcd60cc74233006dc3539be2b6db49c71a64e5ba2ed0d95f6e66c0f2f054883181e3ede40891a88bafedbd7a1c377c83a629442561da8dec3167dec85856f251b79be58dd6f55d23f3625c7d59a62c372e952f22dfefa377a836a092efb0bb6f1abbf9d81e8f9ca1e2a2d2cc44c411866996deff4ad8a1ff49fe9c2fd2b485395083453026d1b7e22992b8d2983f07f27558bb483abae6126028566e7ab834ef58469e06638449580d3977ff9276d22abe094270643cffeb9e39002ea3c314c0b3d012db2dadd327eb9825962a89b52361b82d1f9512442de0f876187df6bee01f32aaa4702723ea05c2a509a3eb48a69f411e644cf4d54db98c2f7c732936800f792946307dfd78dcefb234dc8549530f6e522d8b6ad478a5b3ebab602d229cc7c7358bc86e68f1422659cd1c8e5fbee3e61019684b0ea2f9702155bc0f0229d86be86db474d9a2c3c4e10e20c35ba4e830fc9750e780f237dffc59f7413355be141bec7530c1a06ac00d486d4c900ddf574a0f0a55e49d668cc4d74905fd96abf9d272f8725ecf90ac1fbd33c1596bfe939ec20de5d105299e9a2428181909bf5a5cb7398e6a67314e002370bcecedaa138b5c20a94dabb6f66e9090bba18b29cbbdd2ad1961f48bf6a490d323916d7581966db55c81fc5e99771edc12d9c3949d99b3cc4cd6e0fc25b2786f517dbaeb423526864b83bebae31b729e14de5dded5f8bc05e5ea81dd4afda409aabd6a954ea96266b211d86d8f269e13b1003f04c35be8f3579527b16475fab3e40cb1e41a8701264fab505d49c339080d1f278374130190d47b4ca018be9fe38950bf279fd19f0f5167d38e89913b6b615c3fbe4d8f73a2c45ddf31d580063eb95160a621383b12ab39ca65f8b9cdfc8ef744331848162d24a4ec722587585510180d5d84a8c270185c16d7252d200a44e72a542ecbaad5874baea62b34ded678e96b59c09f426d6bc360a46d6f3db7ef668178631bb415f3d327b026a73ec960703a87bd31897bf3351c3ee54fc8dda3e8a226ceb9df4b40550a1295b24cbf4b1f3cf3594529e0ccdfbc049eb982e697e4ae241c001adfc2008854cc8b350aa5ae2b52ea6a3b12968898f138f9fa84b36f7088d07b5e28959d9f2ffcffc160f927552866fa28fe928a013c813551783568d2279b67423aeb115fc734947781633431b56b83ea3d6bcefd8bca23f077cc240209fd0d63a849803388c3dcc53cc8381fa8eeb254d631aa62f24bbc4f18dec1b49fc17d652513ee99deec59088ef9f6b323b56b615e286768db945bfa560b3f3dd19b2cbfddbe987c2eb067e45e13a249cef6fdbe450fe34df648bf31d4d6577d9c952f99a361a144f67ac725fa86df62a168785a3bb8cdbbb653d6c987b420a78e4d7ae9874ebc31d8b94c9ef827566ccc62fadc3cb27c95c0ac76e7d90dafeae81ea0b00ec66929efd8e66a3c2fb5eaf26af4cba68db41e0629c30e246496c58fafd4c41d11953c55fde3fdae7be48b15c2c9c2b8278281afe31d507fcbeabd912b0e5c3d24a3555d1a6f316ff0f7c3e25d6e642d2e6e7acdf581152682816d7d2bcd7a815b4b5556026f544cb0049ee4d8e11022c6e0c7fe3884bccfb181f43de3be83eae2aab0c55697db3212d155ba00310bf02a33294f1e6e9e32d8f0187c016d5751a5908df97dd86d604e72ef4def1d213d47966add205903f118cd2cdc3d531a4dff6817da8c8979757720174f7924201b02bdb9dbb79d2ce846339f5020e855053f568f968923d48f3de684d81f5f3b74cf9c599c69b534cb7ee7fe1c581c2ac06d5fb847fa3cc4bf631eb90eaad904b06b7b17a9d8b53a2345b303f212d075b04b0a83b76a9f3acae53df55a2a17a60ddab50f876a24698a612eafb9a8aa355948898daaca578917823a7dedfc36e629a679c65e7f4442c479490a1be77eff4257675ed2ce2ff37f47b520179ad2eba161b115820bfae95f29264e96ee996721fdedda0e7aab99921e3bd6171ad842ba6372a8744f37194e5745b9312394cc954c68544176ceccb839c218ab9ff78e0107496ea7f07f60535c640d18e7a781b935171a05a75836691f733cd8b66a33e0ff7eed5d40cfbe107d91e00b80fc3d5f4b8b7df4b9d69dc5609fa8babc3cbacbb6d1f07156c098022c425227e27a8c4c4a06ae0c7afe26e7ff2824c00b495e31212b5c6d8d54a83857a09e1dcfcff454eb92c49e9650cd65b96fa2720d9fd9f6f053a019d74e68879116d22fffcba53b2b263da86a1220c572391740b8259af56a53f8beede3677c3c16c694e7c9e01ccef1b19690b19de5fb2b6ce52b31f36e718d24ce50f84ba19b5e4b532fcfe093f16c5be848fb8f3e01e86e12ed045cee93ed878b6a5668123bca125112b0ec090bce2991c71145c20b1b1c7c684dc4dbe09924021a777de77d36fd69a2bc00a8c0ac8a1b4155748db8745ff929e7bdd356b2a29f2e6434d4bf94917c9f7080396118e1ee0879350c808d1576c6475e497c395720e0af108042d4b6e22080eb4ecbd23f6bc06a8f7d8c71c1a7e48b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
