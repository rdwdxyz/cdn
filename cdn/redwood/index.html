<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ca9150ef6753441f2e79295efbaccc19941ae91befd145863e04d80a7e89d796f3fd178af3e64288857ab63d1c20cfed63d97d50da4f9eedfb0c544dcdba632b307a0f1a8424b79439c99b2d4b192d8f3ab5affd0763267be62b6b09952bb7995dda7d2a6075bcbb5ee039b4dcaf9a07418c72d5281d49cf54340c25df7ec1585aa09400d2fef7e1e6eb77796c5c43da66ef6a6fd8b68e25be33aaf61e5c21b716f18417ea2258a613570e58ff8fe1b1d9eeaabafcfca18661ab28f23444593ab340e77f075339e2775d5de11e8012a9ba3f2ba257c432cf23973480209e0257d6d4490e28b95fc3f676968f6b7576622dcec5648a4c044aad9f4f37f19df8a4976d2307fa8c17b9222f72d9359fda56bdec52ffcc2d6317821c6abab1e81226fb15adc652b9e41b1c8c8f1900f5ab03c56421ae9b32861e6fd13c3381bf096a105c2c0108a9dc1bbe854cd8bbfce5f665eeb7f415ce84f824e3379303b17b72e1e06cd31b036297ef03be62a53db73ed8b859fd9158a6146547c18c671f81a167eb23dd33b2bcbd399bdaa11e172ac4cf4cbee5cce4c3bc88e390e7a4ccfe2b0889c0442cbec246c4a1dad6c3c91243548d784b91bc54247323dfdac5d524260d0902593aee027c0808abf06c6d29a46f0372cadad6a46e5efcd55b287062c16dc52ad5cf2f169c6782d18c3045099d6e58b46e33b3d1501e1d840790892215c28bb9c7e79a664af9e6dc9de75399208f0bdc8741755487bdfec497afe0419da307471943f434e17cdba8e19c8142dab78af39dcd8047100dca8f45281003880ea87b100efc7e3e7aea828d69b8ba802dea4607b7618d099d3857a09837a923bdb7b626b05d6d23adfbcb085a10257da9aaa59283ffa71ff8acc5883c35530a29aaeee9e3de61210c35af67b9f8f177c490697d20dba7061b5577633ac1cb6f61167d0833e4f5dde0494779d318c3a4c179f556c474082f98bc46683fe44a3bbd2c738473055e4496bebf8735ca5997404dbf486a91081da2582b921af30e05fbd5ab40b26665dd8cee7444a0aa36b575c1b3dbefe4458a957d5a36a103c1c2f05db3b73895dbf226ce97749df7bcc60fdea15fe0908f7c09a8f7178eb783d48592cfe18433b17d87c013eeec1940ae6438acc8cced9f2559298ca2a4a10d9aeded3788ec368f39c6a950faba653ca802a9cecf49f5fc88f03a7bda561c8d45364f42abfb540212f82ec86ffebe3121f919825e72cf192467c2f70e7b2595ead58096c944cde999b289be641d450146ace804e2fdca9a5915d8626c444f73a23065aacdd371d27b69fd50e0fdfe2c725a5b11954daaefcf5920aad0562e040ea5ad3e2cb22c5ada25b14cf01918c583f6438d0e6b1237903a020a735b3206fc25dfee20805cf38eec6c88486895ffa7f449d6e0f0af81f6e69b1f912a6f96d431a711afcf1dbb10ec46b255575e067772a8d32898d3e64cfd201124a94c84f62ba5d087fae8001684bec64c4a3543165f3849c59ea71c9019610fb21a97f141d852b8b1d180585716b7e46589bb28b94a7ed9161f9914560913570a2528bab745fb6bca3a1d288e185a02dbc01c6b524b53e6e41b6e0977ea3ed6480d39942f91cc7f94ae73a0e0d1462475d23828480b31ea805fe4d5e4b2483af30689e1ce0938a904bdde2f3d929dfb9cfaa22367002c43e04aecfc789afa22b26cae1016143baeb4bbe07617d8bc3e72f8a995d2429e93b2d7e49f8c9adfb11c76f42732f1fdc406a011f4331a281791ca8213743943f701cf2299b7fb754f8974c8768cebf973b0b2aceb5b714a1862ecf0c02420882add7af252bac1db071c087fe88e9b756c07dfa537002e87c85471c6c2391477461f213a4b03d0a53945a977ed2f511357e09b1cadde4e014587938dd55ec77ffeae2e93933c40e94814720a0693073777e247b951640cb4acd087f1c91882298045575947141429954279cfa4eb583f896c8033e99f0d7ac9df678960e623ecae9b6e717854431c27a98c1b210a32c5c85a69ff314e09fe2bdb4947392b45c5cf4e964e18dd2e7291e7a0c125d30f679c57d5d186858f211c11d6475e9b9082425c1684ebe701d38c366e6b0c2c35d8a7a242b96ee7fe6610409b35787f4752dd699b7c60dd2ed701c6f97adb0bf620460f0efac397845d739817e33b608098cc64f8cb1a62aeac266b61b6f6b443420157407634d165e0707a8f12472268131ca2460b65819673abe4da9d50f6933f58f3bdc09ac45711d7c94add75036df76969371a31401f012f69a81e1f2f6d73e3faeaf946f67c04ffe41b5d69f240c7ceaf3ca0435b0a11eefb9c8ae9c2f8207faa92b3f3e080ad1ff93fc02745c29d85b5433612c3ef34e3e6e10b3748adb23018144f9cfd0079d5965e76493885b3ad4ffe8497735ac0629b8964b95138414885eed32f59db4bc51d311f52447d9ef316301a4dc7e84bfa62b2be05691b4ff2e52e2d98dd9fc9334e6d1d49fa4e83609905585fe0b35dc9d6fe1dcce0fc3116750c2d2d11d22d23cd56f92dcd4d0897e86c6b9704ba188cea5f812157ef60450bb086f54a8d3e3da96af10450ec0832807046a728addf76fada7820fc9110bab7f5f26b0f99661fb7bbebb3ba2f6058b938cc575e3bb297c2ff311a79f3a6eb52a51b4ef85a53b69c2a36347226472a0ab998539bbf9cba15c064ded6895208d117513440560858c0ca01c001201634c03d60454834c7a16af599a2f9415369301be54e06892b77fb170f709e0d4b7e02a6ba8260a5ce0ad2692ba4cb224956de7c00f30e76060cdcaaf2fdae6fcc50eb2c9e4bc036079494a0f36ed1caf417e4483c5504f0e3b2e0cad07b9802fbff9f208902cae24c28f283dca41b398c8545d447685d62da9a3f3b27cf9de8731e382609bc9e1e4f3a2923dd66546ea72f89470054944063ef41b60e51e717a4b9fd1b57cc15d77f8b666d79f50413de25e1a7018e9df6cd58197d47a9cd5030c4764234219324fd6916620e0a9dbe8584e465e0eec141611016e58099698b32d50aa4cca7450bf033125150de77e782211a55e56f38c9d6984d9573a0edd732c8dd6cf707503af549e6ace067d79b5b7435df316735fcee42b42d7ff074aff029d46ba53d4a82e8f05966b392050cc57ffe053758702a9dabf2db9fc6e848e94cb5b5de009bb51dc93f9aa0e21957b9214dd5bf1a50511585cefbc271caf39cf6b571e8e5bea5eef883791d2529c7871ac92961a31567597a6dfe203b9fa32d607fceb106c6b52fe3dfc1d837b8c7dbb92de8478fc9299cb93fd788cc12224ad3b4321933cb38e712047e97e2ccffee271f18bf2afd49e553f2901bdd41c70a10ae1de231fdc5f270a6a40c4379784fed3ef80038acb095571d5dbc956738e601c95cb5138981bf952f047623434109d096005254bb4355faf722092efbb2d9c8c2edef6ea1a6b6ba40de137c676fdcfadd3cf3fc7a0be207cc1b2a0436c7bc5954f6f87c03a2442558823488a4c7c089ad8ab978c4efd700cccb999005fe4f7725f65e0eef22da5b8ad3815ef3520128fedc72adb3a05c07a4bdc0808a2949d0e456424e3707d983d49e6d037d2ee1e43fe9ebdca3ef41b33330fd5904215becddfffda50bd2c25cd69e41fb188f2a2031da0d0e2b882ef047eedf943ad96a7a1accfa4660f21788e298b5ec2be39c4f24072ae7c4bee87d94649fec40f48acfc4aed68130d24a3055bffa0542a97ad18b3636bd0797ebaeeb7f26d56ebdadb04817bda4cf78591ee0321516d77af9d4770d75287ae1217b6646f44408a57c39ff7ae3cdce315e3c1341196a00be3bc7af3f107b4b7b3c526791f6d57afdee145e48c601a3d49960a165b9af6469cd6759a625ea7f4b870be48a1e4874ef0a22da609cc07318e79b90a251d1c0ab89ebd257ce98cd9f846ac3a342ca36ace82f31aa613a427dab94bcf03e18f6eb7e3920ecee6df1b888ff3ec3e61af5492d907a08d89302d6ccb7f05864244f4a97f804d9928bc999295036754cd2e4ab1ad23ec7ebff52b4dcd088e7085708e70ed5303f509fdca09d39eb1f6931dc1d02ff313040c12b4f3679e91a5db39a4d4e4b1b4c6f22f480c069c79b22372f3e672bba34b364364da26ddfac366a4be0fba7231c0860335379d1e046235367cc5b04293d6be21cde74e40fd6b1327294f7a17f2fea70a8aa240b65b89ce6bd3fdd7647f3f74398fd771edec3a4616fdbf87dc36e1fe47dbe8e491271bb04fde1f2a63b4ccf2782d4e2d32dd003a506cf108a92062ec7ae6b487bb82940961a80833e8e2eb5c53a0b3d568acdc80d8a5d12f40e9966d188a983cc2813050e3833bbe0f9184a734be262d740862d567971b95fcfd06b962f03ddeda0b4d01fc5447f6c1e4b65044b2e6ce5549d5743b84ada827bd68e6485146dc9dcab8647169a0057fceef965b8a32ea6dd0ba06e9a7a2429adca1aaf7977b3bd1a161a4ed9d722e2deedf04b061a9cc865de1d93dc9d54b50328d086b0f96d7986ad2ea973d2dfbe87110fca416060e33ff9313918a65408f1ce089467762429a86c731c36a00dc284c3d3d829f3d5dc008b9f924dfc88b7a8cba27759993424a63feb42057798e89f4f1fd5b238bcd786ffced6fc8e52bc750972fba2ce2e5b9ee37453003395686569388a1f60cd73bbea969f80ac976da151584b62447cbf381bd2f93604fa3a2e566d2406b7f62ff0640b2891e92a14f726ed2bc90e5fb93bd7acfb7a5fac5fab17b83d786da4803a6667800a2b46c0b86aa4d60af45e5a74b8db69c58a6129b7d4e10a98afb2ed9b18420e1b40fb28cd34b549d618332f8d1e0ddacd0c7bb432a2464fc3ca74fa29d66be941a87ebb846391e7a8276d75972bbcc164ed28ddad2c3b93cf4e0cc9d34549147f3a6711be0136097006f6ba23412a742c8cf4889dacf374cce459ea0862c6716668e6e2441fb0eedbb43939608d8999b6eed9dc925972b727f488e3f9341e72b1b41785ac9340390210c42f308addfa12a8639072da63f0d7022a75ff53a1e82c9862b5a036505e8825b08c7d7ae12b14ed095a5ae521f71704f811a329f60ecc6a4da90a700fbf46644b604dfde94626de62006a35b492810c35a4d7ade14bb796c0645b5eaf4b87b1888765f67b5681efd282945f4ca9c9c1ec66fa423ee8f796937e5e462aa9f2b70ce3bac5569365e480e27d00f5f7f10d497c4e2bf01e501aec280c02ca129ee5b292e83af595217e91d2b79368c9411d7e8e6327e94234ea7837dd205d4e667488ac632ea4c9380e84cb3064b8ea14fed6da1d81cb279095b48b9cfb67f5e5d29bd0121fa9876d408af00351208ff7a8470015778f2c61e03341425cbf10f35f33d04913d1ac83a7c9a98ccceb4962e37bb885dfa9899d5baf7bc71fc17e5427cfc622cc6a588f7efa0b82c1d6a25f7100791807ed16405d9ca4b44736b0f6df4ebcf5b70714355ed96f9f05ca4d2855d192181cea8a9b6a83964bde8f0ed4cf3d10a69210cbf7977a3d8f1eb6fdf6b2e9d9238c411de78c083f104b0af3d58895b860cdd0ce791b57bed3cd8f51a54b37a8b60443c034ce08888180da22647b3ffa0404f8deb9932b94140e1cc56db4bfe5606f686da7b5da7bcd5e6bdab30b9863a1aa9f4cd401ca5cb5001c277a0a3b4ba9a0a38bf053ade218336ec1266b0b438d5892371696541e2755cbdf4dae4d069246702ff7715be1cd2580630c4cda44c2fa6218d63046c69b17b0bcefd151c33d1f1c4728eaa21f811022ddb3745add3bf1ba53af6dc11a79f839ec616d70239277a73b044982660f1c9f6962e71417da11991e1caf1d93c67219e2f9d0f3cb2ba858bbc3bbd28a32da3810543473da2870e881858b81a8ab997ac5966c8c59121f7e1468c927035b35d509ca575eae359a413bb155de89aa54f9c4889e197b2dc16ae6f1b553941d247bf904ba7ff6f7ffdc72065ec9f87d5791be4ab05b55e2e6c403d03c96a4e00d14a043f209e2fe712046abd2442c5137850148ae12de8141f7586b32e5bed94362247ff49fe8c36f172d52ab7b38139d6f74e727f46aa14ab62d172bd1f548bf0553d6e87188332625c11f8d62c18f3cb7ce2d606a6ba15144ef0819382530d78dc3f9c7dc611df4685ed89b20ae8270fa431110ed26113f8d7c04a47408aea212c2c00c81256c2f8943064dbd0df9d97e305f7f209fe637d19bf576e034352ac4945a1b4ca07fa9ba9a781a989ccd0125ec239e333ea9a5ba60b86af93f606dba95ecbf0578fee3f5658e78139e0de1dc224b2bff3908d7bc42a1ecab0fea1374a426eb2f0ac11a5f4a96f6cb2ffb9aaad53e9462f82a0729a4149afd56118393b59521d28c64bc3c7254c0e1b1e14df553c270af8cff3531d2b9692aa8b7e1ebb5eee8c93977e0e79d23e281626b06bcb9643f06bdea1d9360591218b94e2e2b3b2b52ee91c6cf18081f8343bcdf4d8901d2b60ea729f47c923e2a5325e24c9c48adcc0052f9711ac0862a58a9ecaecf4127a10aae3aaf8a22f7eea03b38f25a83e6560aed88a8a344670932ebe72b34ad3fbb4c3a43145c967ce865d3302d9ece5526630bd56eb7e9eb710879e2a287d00bf55c0fa24ffa5ac1a6ee18e9b756c89c1b3ff329e6c43a8a6f46266bab05948d7313dec4bae022b4a1c0109c699078ed3fb7de01b57868cf0a8af254f1654445f8478cfead8769e76903f78c62155924659392133d19d5649270cd1ddf871c84887822f657f35699902bd78b98548ab58ebac7b09c23152b27c5440236ed8c376e60313e4ad4443b6e5a5f6af02ca8c165723a6d87f1d871218f0c02ce57871e9ca9dc0a5d35d654f8c41127376bd4d415245fedbf363141f423407dc49bfbf292e21281d2bfdd98093fb7907699c0036fce9a77cc273f5801afa682faba3df8367da7c0851e02e4dba7e865b1e683ef36c58af2c4a395522d8b564faf7c3f226524ee134375af766286c439d3f0b712459309daad13a69fadb3fbfd0219b6be738d3b02dc8b92ac2a38c4b28e5747a61668ecf78dc2769adb6a26a64f3d32438e0072b56c3e71ee8d19ae33d1fa9b156b5a488015d96152bc7c11745a0c7858837e4252de5d1e4a8c137a8e47fed10c0ccc4a214486874a3b02e6a0872400e464d5008b16031bc02bc29b948733b7b911f435557038cd18024eb6a0230d235a9622a04eef5b52e32f8b9ae4081230543a3ca714ccaa42caf566aa73818f6e1ca6f4487be4b712c9ec7b409807f9ec0ad6ee1c650b87202785cf6a98d0855328f6ddf04bccf036b3a2b17766291ca2829eb91a869e04276653f91e71e351054abae685354f4e01a6ae0f8d9457655c0ccf97730e0514d799facf63198e4477da848bedd0845b3bace774726dedeb7985194e746b41ff0cf35251d82ba34945d46d418a7ae0f9910c1635a87bdd66957f31cf1c5c6a9f7645f43aead7628fcd21c52df05743f225c1576f5d57688d03f1f91cdf959b32ad03df76d99fabc4825c03f6f6c4a91dcde5182a09e4bc5fb901a6db2122e9b6fbdf8a5db520bae694546ad967bf43fcd8276cb4fb28d2a8a3606b399d3038aade7a21512a5473e4d2238e4a6903f19b5181a81c70143fe7d37345d74d00c82264b4aad04b23045a01c330b42b3ebc9edd319897981528c2e0e5890aa00ce1deba9608e7232d225e8f702e0020e56cd83039f70ddd285778a76760ffe01a858a8ca0e258d96e68e01710628bfaa4b977750c31a16691b53c8d5151ec4f426d37648bcde4e6070cd3e7c8e64ca426bb9822cb8303bfe9f4db43b583b490d73a97be353cc09fa6c303f21923ea1729a61e93f536fb2dfbe10cbe7dc4351026a6e4ae5ab4f24b00928d50578bf83bc293a81c387c4370b13a23d56d86f5cfce7613d63e7c5a9fd7b10bbcb46bf7387b6941679ac6e5dacea66b461ff5e089a84db5e4458e3e7b7e7f71f299d3c06a85465b5509e0312a15427b090045bf5797d6e4b84523c0af2f269067c9f8030e338fc0d42fa37ecdac0cbdacdb52c5166af1d3c1911daad63a01fec1108636a5da17fdf1583b1151f05581b8da0c0ebba19c8c67cc439db4939d309a234fbb0e814b9a7170a8b5560b4289eb0d392c9824b35f1d7513fbc207511ee2e9fe0ab22b7fef1eecafd1c846ee83433d068310b3cbba2b2500f3ffb26d665c036858c7f8596857906e26d29a37b76b7ecd46d70ebbe06916048be6f0c4e320ca9919391847c70ff79712f9aae5281d7b12bbaa9ea332c497fc50cd96469044ad5786ca696f07000bc68d062148eaebc4a9cca6e94a4cb894eef76573510397a146b9b18020bbf22ffd1be36b10be83983ca045c9b58fd4c36a3d5bb643e5b9b0d47bc66608489308cabc02926bed1764fd70ced2f6a8dd173f3592742a384780fdb54333f43b2b5b7615bc3f824f5dd255900a190a1edce3068738798b8e57aebb8c3abf0083782dd15049a98b21258d3512e8dc428eece9d2edf4b06569d433428042beb6cf6ac8fa6639821ac2bc5bccdc9555660b27193a1a18f42542423c1d440f03d187c817323d652f46f191239fca5cd23c1ebe931302c54716080c5aebef040001f14fc5305807e9830faf56cc23cbd1b1499c6e17d442c81440a231e39d7b3daa72c48b8ad3fad3e115e1a2da9e611f2b7ddcd535d2004debdcb532018ad1655edb460a97649addc2a2eb1207627720ce4ed0e83239b8d2de992426f6b9b5d225a9b4d9aa1104c9705dfb38d47e526e0cbcb5588f5a864397d6516a72cc4e3ba2161ec64fa770a064a839e1c5f1d6583381bf2663974d6af4059e92dae45505c8df7e3af7629558e1688fc605dec15aef229618f502bfd274870aa241565766e2bb8fffc45acb4ed689986652e9361d67b73fedbb26ec3dd05a7ca3e1b17867590d416008b6a7551012d978396ce8a81dc66c0f14bd0614f0f3d9097124661a4234f8bf05403804397491f3f1d7782a08aed0b59388c13a57ff0f3cfcf2a334eb82b5d2bc0a307371cd183d001568e2ff4cc722c0aed342cb1fe4107c2e9974208fed8f3b1bc2bba0d5c167c4cdb97c4e058ac675059df8e9797ac96a54b3217e2baebb191506b208d0a256dbe7d7ae85a029c08988b5e901eb5ba94b1502735ee2c0b0013edcbecf6fb363d55b4e4cef227c6965d69949bb27596c5a7471a2abeec3e157a0df3e0c64559ea3c9e47d12c9eedeba253204169825c4863551cda8a96692b57d510ab284642d61eb4189c5b1b38f91c15eede749560164e75b20190eedfdc2a50fbfd8aa693bc8825277f6ec5d1896a9df96783cee67a0ce1aed1596125a56b52bd5c133700cdf78c816e9be169cf450a2b88aba21f88311575cf2a4dd2e0985dc4129fddeab69e556ae9912841ad223ca65f39cf70bc88c207de333b84ddfc1a58a8057cf6c38879c78a2af6cce8354eaf6ac9b96b54adc06a23c2dbdd1778075be53429a1223bf09e27d3209ce493ca49422d34f89b2122b8f8b68f014e375c72cd5a52125d9df36ead299e441c9bd3bd0291cedcec13a69b12ef76eb7c45d0991f663381adf6949a80a29ccb7a0922c112aa56f723f5c904aabdc47a5e75f7128978de3b075d1ec0543a0a549d9ab64b65051d4f5df9c13f4893628cf2e5cd6933de9670217426803904d42579bd640933a691e4d4b805433dd0ec546f8363ae1f769ca02ed1304d92c2f1c61b65b1a2a60ec74ada8e97e15a954904a641f5c70578ae2ff69482b911be7ffa48c0c8f6c3dcb4fb4b734614abf0ef23afab216fa61bbf6adfee90f32f30a863c9375600e14c5c9cbdccd412ff0db6ec01376e08747fe7312aeb61db1883409dde7e2f5ed2b66ba3d720cc63d02bfe1db59fb274574a0450f5342cf8e9367039072c41c94e1a56c9704b28afbe0d24ae1cfb1a69445259f3a541b4c562958114e6dfa0a39b9f5f2eb5e8e69be3b5fe316204f697e42de50b880418b92c8832f6ee4b2c896cfc77d27fef7769ead95bf758f0761ccf5371de029c29416a2fc48b42bff337392264aaa462f1fa7dbfcbfa21399390ed401ed52e6beb9ea41a6e43d3eab85261191e1a95dfef4d5638b54b657c275afa4d3a074fa09a2fe586918415f673df5e5c3e8cf5748fb394a047671fc3b5acd2eea171ab119267a64244d07fdbb7d4b4b4a977e1ac3692b61100d58fd779911560795536532026031bd4f498c5d3d11341408738ba514acebd82245347d7f2db12b94f17d038a898e20c92da1b70103d6a253bc1fa868e993ed009df6708b82881775db4ba14f9b57a2c4220eadb9798d73c652532f58669a40349395d213656746da659660a09b6d3b55bc26387a9f15cffbf0f80964491eb4272e77192b592634f2ef3d77b4886bc010831cb6406b1d297287151fcfa4379686d30446ab27eeaa7a787a6b50f4f8e890fe09118eb0050f24659ee4bbdf1bdd89e0d0eb675b34c1078916e68fd277167d2a9fe112752d04befa876e06c9212dfe29bc3e5eec16ce5da231ebc1a1d15c7cff4e26ff27f9dfbda8a1e90cdccaac09866d14dab85d552ad7944a6350def4af8d01ee61a8765bb093eeee79938b449b144ec1f46898ce6ae586e1276f2976cf2581bae12833daa4f770810278e33154775932e7c1c64a02a26f88cea79d857746a2c159e6bfab3bd4ecdb67d7221a2d1a254575577bbbc7679194c962203a2fa39052c14d27cf4b38f67fae498fbd85273a174021b4e3d11f5d228ecfefb36d7e25996f5d494b405643b593d855808e36d45a69854a2eeaf9e42fac473c83656ed424ee73e984aa103f71bcf47902d87e59ac9b7fcc757e7f2f912900354170395a61744f5e1261280fcece193b87de378d568817b82bbdc4beed27f9d0b25beee4411b5e9c088cd5d073fc7d6a0b1122f959bf26201a423ed56537ec603825c600f13209fdea085723215b5c978e341bff98c2c2e92d6955a9a03f0ae68c7aaca9a32543764e1a678b951fbe014d5da4809123b3846986e1f8ec78cbb5deeac6cf5e24dbaf7fb96a6169c7c1f8c77fce6ab5c88f2fcaa4d4a07ca630e43ba6be09ea30d1f3f60efa85a8b02adb4ccdc0b277e05071db173a6dcd6d78e6d5a6d1a2afd7c342237288605dd388a2f94653a65408ed97a431a5bbde5c5ffe91bde140c8c77f3713138f0a81e29b1527455aab9b76c5c76f8422bb41187b80d99904e5672dd1a9cf67c2465461b2c240249cc062f7f109d1964c401cac5ebf3c93ea4f6389e444488a4639128cc1b8a2bf997136fa163dfec112f350bbe57006fca12b5aac6c2937e6ce57f5724b20e0ac58f2075490f94b5e515e4a52087303d67f72cc015d85854f9530634dd79468e3cf81b4cbcc75cc0103176dc821c0aec5da941975511d0e62c797954d11532d2c1ca515ca6cc654cc1b7742064d4b5ef817c580e74e0220fc2cad41b7c1feaf4524be77482ffdd4369994dc7452a99404d38d2336b79f9be71faba89828eff26f057c3e0d2303962afcdf2b504b86fa9a8ba9688df9de7d9c2092622c3b0b1c0c11b62106e3242765351e6337728bd8defaa9802447e8317dd83fee0332f26d9a74b9fd2ff6c685717dfd51a8ffd496828da581c7143c6d1a46f11c706f3fdb5686c46eafa9a8fc33f86cc24ad601d5518c02b82b9b693508fa5d365b6653498f5cb7ad8924d490eb3e1b4b90ea4956806fc7a47e39b56b47353520d6091612d73bdca29ede43dae96832583112afad4586ef998caf384b79803206c90822ff5ecd9e81c53f5442d0a6b342953a23aee0864bdc4620bfed580be68c3ec151a118aaa013f9b1f2d39df3e3c29d4d76b72957620f9803f94ba4c618c91bbd380ff7621d335c39667c0ef5393d1551881f08b40dd1474c146c014626a96cb36e7e3130da70677f9fbca7e1cb8805616b8d6a27b85ee13cf93001fbe03579283012627758f69a23f6528988b225fdced3a3f6e22c2f926caef9aea4f0f30f1991f7069723a3c5104086bc6ad9dbb77a2646d97fa5cf2a92e9f1570cd6f4770e89c4c7f7f0c5a864652fc2255bfdb3d128c07895681c4c8f4f0024bdaa20824217c086f9725184a879a6b9e38c479cd183fd3f51bea12c06bab24dd7ba94cb5dc471e37aae1d3f8160bd4446153f6ac5f1317c58b422c2e6ab921b43cccf46431a60423994dd018b79bf7e0407fb015431036ba679d1ee2ad1f025040a1072dd3b166e5ba31e84ef9823eb254df9c2f6a3e2bb907cad14c81b60657ab12c36e1d4a0b03bc2daa10ae47195ffd07952a0d3f29049a9d2e8cd8bd33d3f76c2bae784a9e2b1149baff5ff18eb8b31ef9242dc7f67625bff918f8c846eac1a86cbce93c4eefc856188bd2e908f269086673a810b99c90d198d3af171609eaca5b2c000b4300038b396f62239ae141da317dc553a418cc375ea1ad14fd5c90b783f04dd8ebb916ce45c7449e5495e57390e613db2fe346b6fcd06b2b5e2f29931e6bbe36f26e7ebac23ff62e31c394748095bf92b584cdd9a26eed2b1534a5439f4ddc94b4e29df8f1eb401ad9518b8997f712e0fa13faf1dd4bfe15abc51d5ff03452c3dc3299f38035849ef6953b07459ff8be14a2f07bdfc1d0381fbd1a51b9b83e8b084934cdfa76d09b07fd594a8f65750634587a7f47bd7c6a60bcc7b59ee7f8ed7bf6fe240eb9cd70b1d8d3e419ff0aee56f12f4e4f8fb93487cdbb302ab81c9c270ffe8a6973e87732438cd936d60524d63c84d99086a6647a63fdd469b536f12c9992de0dbbe6db46667d11dd76665c8f3eeb7838d10c87ee970a78589a32b2cc73ffedfcbacd99a6e7aa7cc31eb08ac851d26e1be7509e2d95cfa938be0b3a42b6707bb591df6977b2fe5441cd92f935f452b3489b5804cbbff5245f9a72f510fc775a7ec9ab1715e67980317a4713dfc971c7ba8c0e14b93f765a74054d9f18bc5c1299047908b1cc2c1cefeeb85a8c6f7f2f278028ea3aadc49bcfc61f2f1b3e5a7f9d765371f667cd4421d26f36850355894522fc6920ea41792e67893db0f4f0696089b8452ad4eae543206530bc2caf965404355a646dc223ce35ab7282c506abc7ce27d5b303d61c20d11f06bc0da37d4dcce2b7bbeb361edcf3a6dc3aa11a4025455458f1bd0a7fd2c64d3c1f7d426b63f5e6333d55ca8a40db1ae573f24a3fa0e6eba9462341fdcc41aed6149815c8a7edcdefd45b77cc20ed40b37b47fddf03e395ffdae4a8745aa1e9bb5ced38ad3476fcc79e6b670fd76625543044f1a1b124145b6a8cf3a21b0e3157d5bdda9a6ccdadce1b713c29f302358f0b16916ea74c3e3ac04cd1d6a92bd6b563c077cc15f6e66d8ce7fe6966ce1392119ce3a68b1fc5f6c0f9e65c45a75e7559ec756e3e3c0d3062570bf1eeb1a48bff09d2e9ab38384f239c1e7bde84acb62e065202225a0734dee99be1128b52a7cacc2caba0c5318d65077d48ad4133db7d851ed8ef28f50cf49f8d49af9b67842e3451088c79a12dbd6991a967010eb6a345288932ae745b3bebc28df14d17de21e9b4dc8ee5d15002907d15549c3836991086042e46842f9649235fe4589f2d3c835cc393f48b0e8d32972f23aea02c3a698c77e9bbae26f7d7748784f927097e011f7979bb9b03423391fd7cce26c837685fe403ba84613295289f6e618dd9265204f5a1d6256307b7d18fe558b7172474bb35b156127d7609fd85e7dc8b8c37411694914f9e82af74a0580758695f9d1bb1bb1bebb14ba61548e5286df8837de91ee6af6e4e28905380eccec6c7325908b90e4c28c070b6f099e8c2b329c7376fdeaff941bff3af1b854c369fce413193b1ee2dc862c1f72987c55508ca31cd4f7093cfa63140fb20ccd797eecf863ee8788bce014bba0e52af692f39fe0c654fb0e7e2919dd8f1aef3271d6be60af93cdd6e7880798475a095bba25c6c90a72be2ad1aaae2be227b3be1d564a6db8b839c81a01daff20a870dc0b44c857d18b00d8bcd16145559906f214fb6f4c9d5d6575b6a39ae0e1179d1f0540c41a16a0b47989b9268f4968ff5684b82bb37d9c350634b2999ca27c7fc38e68771358bfca40b7ea63876662c66bb20f879346fc4ee97ffc8f231942930b39aefd2840de243c8a95106cfaf35e4de6a4988a6fa3bffe87048995113b8fb57e12543f6a243ae690da9f0a2c86377a6ed84ae2f6cb794f2528c2a47421c46fd6d55674d51ccbec60d8be39aea4a9eecc5406fc8d0fc4a5821fa08c11b1af004da5877065b2abbd355644daa0b95f36e74c70d06a0b7c56945b00a31fd5abc5f53619bc2f95ce6be4a39951c5219b26947785dea2847f3c3089608133417ba4ad1eb3d3eb84969964009baa4ad8c1a76e7b3e6da833a4fab5a267aaef293f978a1997cf4f88e0809260a1297dfd83620acc3029d065c5e73173845532a37d83b1d7479bf286b1cd2cfd9ffb6b119c2e559fcab4e7a436c1a62f7d4d2327b86c40a71033aebec6cdc903a7cc609ac810912cb5da25c4630bbb0a81e2952d57a3cd27067b2cfcba69b133aaf76d965881c0a856013461ad58f5afa24264cc201a556eb04a0894ae05aab233efc3de03a3c8dbde7b18fe3a6e47c9b41a8230c255bbf9089e877cb349f6d76f85a18f104033fa50fb3be640fc45d10cb67fb6cc09d260c42c0372674f3d185a6e5b4a855863ba6b80f321cc0a14a50d578b8359f235cc7ef60c0bda53b6a688b16c6d4b562b40ed3a72c097dc7d44ff65b7a5d5a63d4f5338a3a68e2d0947ac0e000fc499194f6570460aacd9027ef417e54585113e8c36c6cfdc0102da54012f7bbbe570cf1de8bec68a4a8a502de896cf3f3fbfb2ceff4711cd009ff71a740315dc7a185e43dd765e64f141e0c856614bf569fc1db8b1948b21fea4c25c30d238284aabfea497956b9dde5d4593081dd0291defe1e09cc1c05d6616a8db0398e2fb7b6b7c6f68fc8018ccacefb1f290a22bce6b3387647cb5f38e30959b30a3f377e31c4a98c02137ae342cf5781a594b3e7a094183f9ced4554f1127b62faf384d9bcd01287d4117353d2e8a6efb52f3f17bf0cb085753885d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
