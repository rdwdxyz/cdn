<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd901f52471e38808dfda4c27e71daea74c42ad7dfb49b0514d72f6e0488a655ec02bcdd9ad05f2f5e7ce511888dc4c676569dbbe7b8bc69bb6870c9dc83ebbc81c27e80695087755d33389740483fdec696527805822f54bcb5d37eabbda12dfe030d31a276ed06da67facddf192a24ea318e0d17b542f28d6b1174ef1aec1d30967d58d78f7730c0ccb5d4f7fb0a25276ebf6c0a096c0e2d0070d66058cda739fd99ac1788211946bd897eff4589fb74b6d128a3011f3176476ec66d522b616915e9040177de5bb07347a0fb64ee1ec258d2aaa12d5e396c07a4451b6272300237a97e740c52bb11a8b14f7ddb7a6f8bdecbb231ba58fc1ece676160b65c8fb2d1601fd10438f1ec5999c92129094323c02b00f322de15a7345a7bb658b61f37fc0f61b3b1c0a021f0a21e7ff59f747c56fee11237977759d0b3d5e3350b8ef1eae7b790e0fe055d576907bca90477311ac275177ba8b1f497026f97515bedd76066630b3ef80a8295674567d7b804cf9640e43e191ac4f25d8092be26583269cb3cb6745320ed24200a8b91978e53a27e97459824d7122cad56235ec63f207e4ddbeb839a70743ca40d8479d87f1acb09a1d5450c6b1ce89b15b8d29678986fbfaa384a524a4c3fef050db7c12e9601454b23cbe9d8403875cdaea4860891fc9b506dc2a971c8189d99da005953aaea547bcf652b2940b17ae0f0caaefb74783feb99a7291eb16eb7f8dccc74b77b7e90a7a7b4948eb856d0ca115b15654c96bcab440085b011e12ac0ea3fc720c7f3cba6942fbc650d639ce126e13d83f33745c75c70f4a80fa10d43b33efb0122cc0284f365f7160d6aeeaeb9587ad3fe3df17b2202f7d073ee15c6485574b446ab6511442a125a9f0d7ed55174503c04739196e3e9ff9908ce252998652a94615c615a3b0595e68587588f802663931fc908b61c09656d3cf18fa9ba28882774d517e6c2186011188641f99baa980761f6726257282c20609824f01fe6e67f0861620cf2553859813728ff790e3117a00c5413ba4289ab675b12ff83d00df12a06de0a0d026ea8d144ee8a192a7d3c0d52354af7f926967a93d19a2c28ac281d9bad133f3a44585c9bdb750c68bfc283286348a7b52765cb6ff43cdf464871f20696221682ab7bf0a0c25f5e6119795ba2af847405c1129bd59a398d35cbe657cb77854c70d29a0058c2b032ef5f6e3edf242de626ecd3c94461280bd5b65c289bf7d55650771c8efbed314e21d3512f88ff1a74251fa1aabaf8b7c77afa6d0583d044990e771f5a0517486687a3612098581d022b980aa8ffa3fe953d39ddb187797d24d0bf4739037438f809912447f685e950b3468c08bf3084289575fea8aa9727fd09c7e9edc8cce55653f2392eb58e5da8a6be1c153ab513a95dea48502c91ac3650231e9080f99aecade7ebbefc67a9624c968661ca181ac3dfb0b321f0e2710ebbadad12f458f33ced9752bd82ddd45f2447c4d9c5d5f9436dc0c4abc2ab79dd919c7c044e034eb2a32dc80e00959ffbd4f16229ab8687d2bd14bca8c14cade4ebb191a480d177400dd406f8d3df4dc4717f41d23bab454caeb25cacb813f3c0ed4abef21e316e7f72c0bba56d043bbceddbd4dfe15f271ffbdc62d81be26ab253ba060c75d736bef9c8f7ac1139c4c3eba5894af4684f6a7d7e5d9b3548b85eafc327a390674deb5d43c04fb7d04b63558d894136d5d207dd0a1f72854bb516aaabb2f90de72c5643271ba349049d6fabf077da80020d1f61a778007ad455cfe658410df570b8cf4347af4895ee136a2860876966c594213cde4000c6706576542773095fefe2bd629161f5bcb6e1a6f58620a6b92be6ad811fb1c337ffbffe4eedb18e34267f5eed4fb6570833f9c8f1e523bddedd71f64972d0e6ba4fded26d654bfc80f1326415b907a0d60f6b1bbae5af930fb0811b3353a29715ad9ec9c2f2c1b40889e2a9e1aa84aee7276e8e96bdb106b603830155bf53c3713793dfeda7e60aff57317e8d25532bce87c5d32fbbe1e756b6a5223e472646f370754abc858f5119abf301894add5aeecbe336c10aa8e36b4223fe136525476c862495f8ccc0b847bc53cad297b8ee0bdd5d2e0f0602468b56afde863c3a3e8eed16be1db2c4272a7e0d8a55bb412d613c28e19b89adb4f2c152e46f42e6028f81dd32136852bc68a8be9666120a57e3445b3b8995f7cc7501cf06944facc6fae0ef4a4ec6cde1c55a91f9ebe837c7c076a7ed9d1571c73ed0736f45f474ff1ca0ead596119a1fce012ad36e89ca808f4dda05992509bb891a8c96d990741d4caee31c1f56b61474b4ba201bdef5f8cf0e00bed6c228b5a0e0b72e272c3220f9324a3223163ebb6c913e8831d65be7cf3110ad559fdb69e25db3b40961f481975629d2d01e8ee3215d223ecd9181ddf93acf45113987856b4eddf892b650771c9437d30625cee066f89dfe6f2183c85bb9c47e9576a81f81ea54d4d9aab4617d9be2f28094e9e5d84b0484630f1c94bd931c38c5434aa65a21dfe5bc1b403a5f489ec0de44e732b88d576f7453a466292f6fff2803f09ce78a2115e1270a0d9b8e559881f858ea5cadddd64b4dbc9909e746953bda3bd81ae68144e7dc0d2859a39dcb321d9a855d4696522653b9132a603fe4adfb1c029e463ab28b78de3967424363d9957a8002bb417c64fa6b11ac2fc27d15e53e559aa27876b91c527e99e6699e808be5cbd96d633b561fcd523c71f419687ce6a168fdf6bcbff7cc5eed229645a7a81efc51fcbb249e7efdf7db6de5572148e737f3461a71540c56201ba58c14abb122fb076893277349c3ae55dcc824b0960c441ae0c5d1701dc8f1371e11f237b402184b52b950f3206c4cd0004648830fb1009df409228b61b42f591697113ce9049f2169fe2ecf549599d0da25bd001dcb0c2fa9cbea6b2de9de17b5fcdd357e2cba4c0681840eec83441dab27ae6aa827b2ede53ceadfcae2dccfe8553a0bf346185bcf0a18f620312d044cb05d8fbc5c3f0a09ab33ef189fb44214addd38947dfc64170bbd1a6d30f3a3256d1e4780f32dd07ff2621c3a708dea8a38dcb9a7a5d5a0d87d5ab629b4612651a6a754519802078abf028a1106050f3243d8335ab2c5495d89040fe95beef48ea6856db043a3a41c81cbc99d4ae981a17022eeaa009fa2a4c2c8b220d3f8594695dac8469739be35d2b29203b18ef4ae778d46d742bfab461eae220cc600ef262b097acdb42c90b1cf9f27f3797daeac746e77b0531e843a1bea5596ce19eeee73b74f76ef2d6e51b56d9c9684cd5c0f6a453d7d5c697692792f96afe425302c029b9df238a02c739cb9f7776e84c44c0c4650e495b7eb046f8c7b49e9419cedf8b80d04a59f6a93f0aff60db60800ac442832bdf0ab147e31f4c078e95f9eb8beda683885dc61405330d7e7d747c43a05e0e4e6fca24d501b04b82c13d2cb3ed50f95cd258e28ff611de942105b1667dac5116ef93ba13b4ab143fcca3b305194ad59a84e67517e6a46ad9353318b76e4816e676be4756c15f330d6379bdef6ec43e9aa9c9bcb634733d830542f70d22b64bae0d4fbd925c0bc22f702f89794b745a563c4293045fbb620cb534a16ef3dc5bd665ecf18485d1ab3742fcfe6789563ff5c393b005dcb3c44ada90cb71e8901a15a6009f2864933bc9cd851ead151d848e1974b4dc4411c8e85df029cbbe26dffd0f280433f1cb422d414fdde04db8ffac16233fbc2442a8d05119c7ba8312c933cc0f2f2ed4093a375bbc6afc1a84d94488bfa99ae30cfd37d4353e07137d8a1583223f385c97fa96a7158eca7d6815cf6268f746640c5c396765d411a204700c50f937803d0c82954cef629590f76d45f3169238302452a854ef13028561a5ffe7adb1bc5ff3707609b93862d3e2439e805b909ed152533c95545c0e42d6f7c16d6342eb565565c0cf1e887fff7d58b5d2206e373c9b6ae6df73ed02f2dff5fffa9bd7223153f84abf193d3e7cee52bd24335360f73a359b083b6325d1f960e11ac8e33519e08118089ded40f5ebe770d63a6de83165702a5e4456274bee6f35ab9f3bda4c09ca34d6b363296b7e10278073732d907f9646a129afea053f027d0a23c7730f8facfabc62f6bbb2413b281e32cd1944b2809a0a35cf8ed4f9fa825759cc8567de50ce740dbe989b3a44b0713960995944b0d45a1a7fb131e4ea4f5da8513b4e58176939435ea94cda8a34ab9fa9989bc54f9bce39eefe1867e9f2b0a498e1c2e05415ff840c12b5b81f9810cf07f3351464677d63f9b7d8bc8e3a89dc1132477390f5bd8f27a8af0b3008a432408cd9350e137daaf08b3a4248c17d37b4d6e55ac508e3128c6eeb8a35eddb164695d8faf3f66c42f888347c021829ddaff9ece0ba907e1b6921c9cc7ef91614e2ecc642119661027bfa14dd987ccc44673b229249fb8929e297f37e84b52f667a3cd96a73ef5e7cf8453f6e1125b8f743029f2421349db0147da9bc2309ae0394a735bc251cd6037d9e175a945ed0698bf58dc8626053dfef4ab1961be403d91c92afac7c35e11eecd241929e3ffa37501c169b9865d7005a2b8f652eaa2e4e4bf10b70abf1caf07d7b9957906e457674f1b959e326c812f61e3cde01076d4d04def60d0606bbdafd4fcc2b13b05c1726309e357e47297d0daa5dcf3eae51ffc187743e360174746a79503709a50c9ed7ef750198b39844c81aa81162c884955649553bef248dd3d135b6b6ba98241425c2a79321449aec7ccc2cccdf2437e6cee8248598e72021b5011ac4d5bdea644e5d8900d8b2440ea6918213084755019b186ed0a919ed4bf7ef2cd0daa1a206e4b13f1617cf5e6d20cd4f04f6e371da54cea6399127545fdbfb592b3216c264b1d3a6a5315282b6ddaf731b9b3c1152374f76970ddbe62d57ca04129ef19537c78e3c4cf623250a2bf32e8a2782873e95ff99c9b66d96efff32bf3293aa635f6bd7806ff136e2326c6f7ce3195786f653560a6c50a93024c6642db662f1f659ed752befc876811457e0d8701ae39fa886ee99da2b5bc2c904dc85d36230eb18471a4573824b6e45b66c191571fbeb5f5238116e1891b0b57acacafb173427a3447f2f2b56252cd5903701526ae7617fc70e8c9e8bcca55a74020682cb968afd6a791eab558438fe9f08238a8e435a638d7b4a0000704d2862750f98c4b9acef754da29a5d5bbf2260349f850380c056f6abfd5ccfeea9c5f16397d4c567464646161e95b733908ed0b993354947fa45784427e809caed5e5c0ffb2b80b17ce7441bd495d5922b89bbbf2d616f1ab49d2bb2a8aa45494bb98cec7a317f32841cd7ac4000249899fe0d4ad94515d53a4257ec9d879e16065c63b714fa11db40f1a8fd952e67997a09476f7f3b1e8734327ab890d15a2445c643332aa8a126648c9d0b34fbfe21946cad90d917110c55cb8b3caf88c3802a5e6c3e168627db967bee6997f065a41c3b265495cc9706b944cbea35afb41f183c46ec1195e4427e2a725d2ac12e67a1916fb7ad38fb589bf80d74b8cf4d09d099293bb9cd22a61df950e9dbf7a0755b083dc47ad69186c355b7a46097958518a2cd134d44e03485a4bac9042bb687f05054311c42e16aca4fbcb1554f48e50ba967aa9546a615b7ef170bd1a91da9ac612835aac3f328cfa74504430c42c8900b08bbad8d51ccd792916aada7f89e1dea6c33f7e830f1d623c1ca18c66bd4f038e42b67cd8cbb11befdb5fdf860bf446336df83407f58aab09e1bcb25dba7aa3a716529c39bc2716b6eb0053e4e1f2b542f5af66d20c22873919452079f9c0e67ebb2ee65d92ea40b1f5fcc3d45b8e8396ea79ca6093168bd6838c644d54699026fa87685fd66617b8665062a17c3ea4f0a24f8f1fa580e4a01a1ae7cf6514724d0c557191ecd229fa50ddbc0c956ec9316b394a081cf7261a760dddd33a98d37a8eea9e4d003c984fcaa82ea4eabb63ee815dcddd64aedbfe31c3a85b450b6062628112a93463497c7ca2abe0718dda49b144b3de519558cb050b1cbee294ba2d1752f826fec24a191e0bc05bd16fa3d335fedf005d6262d1babe32fc4c65b4efdede87fc2158e534e04c09bcebcc2bfb96a47fd353b3fbe4827c5c8502415b20cc36cfb0834ca00e5a8137b0d7d0903b0fcd82989c08a6045a65c18aa370d5dd7f1a2e458d41ed4558ccc862d68f71ca8f02394b8f5c4394b71b3cd31c55dbb056b0431fa13359c607f0bd279f285d86b786942f6c11b5d96569eb8c6f0148fadcfec0a3044841ba238b078524e9d6961658df37ae81769cf73d77e3cf8c31a349662837a0375ad68a44822673e671c6718d6c073e6ce0d0ea5d91787cfa0b3520a0c423a1e12f854a5b3c996a3d0301c0e6535cf689f699b39f3832e56cd75ac836bafe086f59d4cba6ea44d35c01f4abf10f08264f225469992003b3e175281c917ec6cf980cd6209976cb50499456d42ed10ba700f96914fc020fff9975f14b0dd542ace5d024d26db445057da4f8a07a0918a14dd4a595b73d0a0640979bea9b0705615fb96ce55d4a23bb505bde069ff9c0424dcda47bf5237441491cd2d6d8a338b9b7b6b17ca8f957730accc636a517e5153e6ac47c636c62d1d280fcf586fa34364053eab7fc7a21190d2ce473a01481c5850c59dbffef390f1d3833b477a05ced6aa85a34a04ab55c4f36e1fea7daf3846851662636c9cb64b265d493d8f4e336849938d58f9d35d1c48f9b1bbd96e20fe858571c6c25a96aba7ce44ddb6dd1ebb8b97e8768d6208f18deec936547c7bd856a63048c1d83ba6b184adbaf300575c7eed94723ce178f0105fa44e166669d6754f23c53eec31ebb354981e255bb2d28729c10b937917da3f3b54107972994b8ef4afc61d662ce5ff3517b40e4d9c89cff27d04157846e26a037f181777a46fff334450af2d8f0225b759cf012053f3bc7aec3e7f2ddecf0312794555436b412151c035c25a506caca7a3c873b24d0da8588315be933b901280fe3527988b525825ed6cb65431b7b8e6ccd7986f2c223711c11bc43488478b4d6ee071ff56674763be7033499657bba82ba616dc2ff55fd6dd467e599e6440368ea0825250f333da8e4472700e724700bf4f9d4c9c5f53a0668dff2a9350d3c0f17c3dd03ee6196439c19ae2375b86eb66458a2c36ee9a88e65ae5139d5c146876baf7ef533beedfb8dc9f3fdb953b3ac4683f668c447e31c07682bc6fe53a040a328580e02a0dd56049b91928a22e6dfa24f41c771a9f14b2558c07906c5dccd9afcd0bf37ae92a0ebb78980547bc11e66be5921175becc7c4e81ea141cd8453c54abe7113585be31190d73c0a0a6feb757ad43975fc6d5f5baed52f1820955a7622b68f53589a46808cac5f22ca45783e83e589fce45c7505c345ca8c54309598283be817f4bbdfe63b21252729cf8df94021889987dff20dbdc9cc14d3320cbc92ddff7401f9903d609c3bf4eb769f7a7f2d21b3b10d25444acb2ebd69dca775dd7c017deb826ab910cbfcd7dcfafe76f0082af1c99ead00178438a493a30c1032b7a05d705422152dd4d32ba5056cb36bae96b647c51a176ec049173e463ed9a0ac572d1c2f9c9ec1ae3ddad3991a0fc214b8da9a30a6de9b849f59e2ad2d69bfbe4c09fceebb82eb47145383d7cf54b5567adc672b4b906cacbc7adc5d54b2fa96a50741dbecce24cb1bfdf0e4f887234fedfa2cbe055bd2f6a16451200d14af971c38664da5594c28601b54cc1c5f0210581dbadf99d041cd45ab7d8260f25c4ab82c859da33ca6b233512acff1157826db8bffd9fa772f79af899d1fc4d1b8e8f9af2b2ba84444105e3a9c3bc147c48f836ce840d75885885e4315b660a16dd819e8afd448a9b07399470e36c9ddd8c195bc335356efcdbbc23c8550e3d01a1a9d1de19aa7e1636d525149cca51f9013087037de06c638db5284ca40fab63304472a9c3bda8bf65a1564541e76c44c181cecb644ae16365f7031dcbd73b5efb1b264c98f4f7bfa5443e9b6f92260b2493f493d1199b98ef6310e0dfb6a391e5526dcc8d23a5a4be80d5557585df9891941ff84343baa4c23b3636350065d1cf331860afab2d0d3f4af8421ac8a190d3d768da3067de96be52c250f70d6aba08eca20fcaf642ea79279eb0be7b482c803b2d84fbff689a5ce6f8b2dcaf7622978340280a366818fdb192175fc4c2a306efb7c4855aefc9ebfa03a03d87e06db9c418ee93fb77c68f227590ed00e7de5f4c7120c801825b6534f091bf40a9ffc3157a97e38eac38961b8e3ae866f54e188f5c487ecc344bddce695ab3b58132b078cddffa49fe28f5b7be2daea57e341fbf287f3ba4c79d25b0ed2dc69d19aa9d3c74d8230144b50afc9afb2cae4fa617790cdcf609e45c645ed678c9d2640b3bad7cf0cace06f01aaff0c7cc1c1fd43e0c4ff67d3978e1c142391a88bcfec9b8b4062c98e6c8f1e167e2ee3b507663e07973ce60eb0d9a25f2b555b26feae9efb7c79230828529cb27458459c4a80288a51ea7510da6f9c42b7deef21136583e68c8c1322754717d7c0b6bfbf170efb3a5e797b6400c503e792f6e5eaaa73b10ee5318df71bb9836aedadef9d3d28b6e70fd3ed4e1c17c66b48ae64e6cb90d153bbb5539ac4a22c937a0f3908995f0c49619358b69d1aee2cb9c40a04f0d76d71b3a416e675499fddb6109025243a3efc6316696b0e5ec1b62aaa1776197d44871bec4367b2c1c7dbab2cd73d6c8a355265b4d7a2ba9c0bbbc85766ae35e2d53fef35e2767ae0406c407f821c6f3e63ac48c045799de6c887847c555fa173d2c267676333cbb5ac48b5cbfa2f8dd3554d1d48ffd55d8a66e6b1eecc69988a2fcc882f0fc6bdbfeda033538f06197c8f1df36ea1acfe2b76c22a86dd9acf8d30c79432ba6e5825d655e0c4ef2e2701fca869a605af5c67341596718ef20a703e3be1e48ef4d6d58960e4388f474321da487b57f363fcbafb3c4a09437046ed2754509b705431f6133be4a12eabe00c501816d790dd60bb9a4e431173b0d4a17a3cdd66d3733ba4c2aab3da1aad94c042c3b9941da5f708266ef1c14a7961bd6046290395693065ad633dbfcdf1bec36ad223621134afea74dad7ef03fe52914df3a376412bf5ad0da650be5e37b675b1770a1910e3b34e684631f3a3566209712f1b15d00633f7a3bfafc8e2895b7330895bd73756063d19cd0913957e492ffb382e356435de04b0ec7b8b5e3e2276d45b7c47fe2e75912a6007f08a42ff31fa4bd7b939574e1ba5a99a572464c1f806983e80e5488368b0295ef9fc20051870a0ee9afd79ca4f3e5e3d2c519f0ecb91996b61866f0323c73a391c8adb3f7e5fb76787ecd438bfa29affe3b1e1bbf9a94286671e672d3f32ec611e27fc377dabb019e34316ef7034d4f723940720061a3af48f13f11d5b51b6b5a714d66de535e1028b75da82931734451bd4e252318a5fe569caaac272a123ab9448a54f1306dd888933ed311bda38911119af1e2bbeab826e0f7186fa29245883bdde848edc522d612bfce0baa0b427b8de79cf3c351ed36c42f2e40850d557bf778e6fd6244b04a92e5a08d88b32a5f77e2f63a24fb58aa6abd91a5fec1f7cc8125f900feb63ab08d82eb85d15dbf3a603584c063c4d61a9f672f87c4ae1e02b22ab42e1b35953e20d57ec0d7a30a66f6758a6f3a4b0704778011e68122b4ac72db73084f5c5244450d925fe0b9c5aeb38001e660b35b4669305b77547378e08081b3f78c6e33c4c4b0e66cc0741489900551ff4753bece2791aacef75a1dfb324e84ec4f58879dce2ce44a13f097d97c4b27568acacc4237db0f9b20d2de99d7c12e57b21aa1033dfec1f5cfa39347ab4ee6909e5f616388bdbc56531d964b1cec3d668f8c3432ac477a779c23c88f25ab480d68335051023184df8918565dd752ff034385e789e63d4849bd612bb11f83a492e26bef305b7db1381236796ad3cf8bf18c5a90703d907096966258be44a84b25f19aad83a7aaf43b21e7f769cdf571c62b047fdb92e58bc28f5fb56e2d1b01dac74ffe62b01e8bef9f7aad2576a2fd41c5fe61e63ac30fb621389a39ade00cfd1e32909ca5e0b08d0ca37dd0fd2529e880ac2e41b75b61b1f9c4d2939feaec2d8215417de376a2f136d3631a742e3ab83ae9d40cc85d9b2065ea4e3da62ec4f3580120578b4995ab0a6c5b886eacd99a2ed3ac4bf5a9eb8fc509ae643d94eebb03ee9b9d46c9b36675b034405c9fd81de02f9cce90315aff791abdb86fc02672633d3734c5bb42f60c1d5641c991919d1a8418bdc83cf9202ad63b38727f6ce376d58e63ac8aa72911d216a37d24d24ecaeaed2d977e9426c2065be1ac0f34e5dc7e213e77f2b3992f64577d132875b810412b84c5be88b86a0be1b1306393f6fa5417c357dc462ad5f3a3faff786be4fe19c5ff3909aebfe76529c15a2a6a4800ebca35d0108913384f0053f79056afdd16ca2c733da72aeb4fa54895502531549bf8e040afdcc96584589777489dfc5bb1b426a2f6437e1cd39f3173fd93cefb27761733288c0ad9fe72fca0049e33c39ee128c4a95e8d0769660caf393f96970ee7e0f9df56c510ef4ee31d72b1a3126fd8cc67f3e547e8693f1848a2135b6441f221de8d449e6393cf824bda510a100eaa703050c376a1d1df40e6880fd9b80fbdc2d1afdce17e778829a146f65b42c68b5c0640c31d1968b5e128f3153c478c0a60b561451aecd1dbc5d07b2928831bad007a04a25e4b1a24329e4fa3524bb97e30091f80752cb7570a0ac1419c93ed42b5306bd97f4569ddec77f4d5326f6ff5f68c1ab5c4dd0225a0a0702e437e3e3dd9e2e91908be9bd051afe574cbe5245e5654d3e7a908d4608e6e3bec127106e31ce46b19ef6427a82928826227fc847ec9f8a60bbdb9131c936415bceca19864bd354f007c4576063c49128882b8fef41176ac93b62a054010b7298b772fff9ac50dbf9fe08456b00436e0736c3b3ca61b35b7910fd74e397a25f2bcf00d0ca54e51953907bb28845042f78469081ce9889b68565ba99f3b29cf7bd3efcf0bb4c20adbdfe1644e7c1733879aa9763c1f38dee455b2b7beedebe74743f2aa3780ebdaa31c40f8951957d5728088fcaabcd07c9a429939b083724a76253da920ab40c2409e118c09ff76793bc204a62bcc5161dfc748827cf6a910e1af9084b2e3d825e5c413c289581c5761d3de51642645a7751b5e81d412f55dea1ceeb98e60cb76514d6cb216249f0c44b4d71f8945d9b8d39e8454b1bd3b815b6a845253f5b20c194ba7078bfc651bc17fe2ddd9033d42ea6d9c909b78ed8b6af1735f02f88d8b3fc308d5b12296f713bb446cbadca4d73ad8c365226371427db068a712356148a0cc5e98712a46d864c5b985c5d95eb91c8912685bec21bfd1876437a94d33ebb1a696a4adf1cb6add5da0ce56a0b1e2a35e272df092509d3111b68eac94eb4595189e9ab2732a9e682adf56177c58f3dc0d42755d4271149efc7383effd8d3234f84399be3f5916931c0c9e246793546a0795e19049a5aee0b92847170390b935d1de82df36c1049acf0080e231010c9676fcdeefee70616a58e749b5763934ba9d4697455ef0806b19f7d35d09c1f1fa9373d3fc0e445d867ac1c141647546e040dbb2400a94a44c31f68e8a520b290320484011069e110cc19e13cda098bb6a2a1ea5ee3dcdeabc5bfd80e2bd9c2f9ebac728ea0fe5e4ca31b63bc541b77bbe560fb709118971aaeee4e0aca8b1899756ac9856f97c5342047220d00261ad033500a14f3e76686513d00a62dd0c699df3bc82ce0bb0a5f4d51f5e106e6c6222340f848d5d5903006222bb67f503d27d789675ceb34df4b83c42e3a2e94c5c76fdddc4add771bd6eae9cc8c01a3ec7ebb4a3846b8ff5705ccb6ecec49be4306a8283263b8ffa01f24239b6ea3a7be65a46873c5e0aea0fd7fc04f8f5daf15ba1813256ab0e1fa39bf1b9a48a28be0361377f4a38b3c7f95203508a889fb79a2d412cf62e7f1cf20553848fb35ad418e5609060701d926e5d6e1f6da357c9369fff3468419d6f9585c6f6fdcf340a253078acdcde9c4fdb98df54561854a314227923f0e6395810a0c91087929011a8625ec60368c2a7f633cb09e286be1a8c31d4c681bd66f1aada59b853d53f9029cc3fc73efca99aa0e5491132382e83878e689a1220395459f1a16b1eab255d60744583ebc79bba038f22e842b7e682e8fe1b574743ea17e7009e826541b24a6624f20c750a8358687c7ab3fbd4044986330fe23dfa8f8b4fce68144c6c7e47529141545b5d69f19128c7e2c9c23186792269923aaaea6475f61baa6ac5a5d9900d800057578a76c00554b2003225f90ab4690522905be8f810f997f812399b7adeff13feaf5ce08d639419009481aefc9c6c803a56da139518ff607382408f444ca4a8f4334554854819ea6257d901f4a41157dd0eb90cbc29e281756bbf23896810af4c127a0a486e678c91c952050bb7f6aec37aaec445fa8154a51bde3e95a710c2288e602db0ef86ad83f1b752f455272664148878e563cedc533c276c20537007b0c7834b5b9eafb78c821fd08ddd546ab9dd663bf8e0447ad0768a40d55fa689e0afc7ccd5783f58f122866037c0f96d613dd32697a4e8ac87535c367d1cb97cefbc9fde657a07f70b81b7a04118af5ea6eb7a9176436e0008229c2b8e53d52b74008e9154eac671b1e1c7a5be8e1f9aecc76c162bd6624e236686a21b54c4c0d42f4669b9239bf0aee85aad42b8bf6b33fed013e7fe1ef83f699643cf1c91597b3d1dee52df3c4d36b216027802f8487f0b78ebdc0371cb1abc3805c252cb40681cb8474cabbdbeddadf568fbe1e1890a57056b5a033f1de5e3ccf237149494e96dedd5bc6d26b970f5e20ccf514b013b836049150c0d8da115d00938b53604784ccdcd5b6aed5df4675cde6f114284e850353abd14b67a462a91e95f16c16ca99d884b6ff97dfdecddbdca0e2f4ffda39608accfdf5353bda67b0f966d7afe8bda42423c75720fdf54c6af7aa694e5702150c548be541e8f3b961c0a355b3244a2ffabea7b935f546935d5f0a3f598777a37f769148c6d9dcfd16916fce95b1ad87e64e39c1f804ba51163ef858430872a13d69c5fe71dd874721b8f969648e3225e9b7c201ead67fee10cd6698bde745e521ba076c3ba0dad6724231d8350f7726d9a3a49e91550db400c712926ea7659028b2c77e8eae826806d03f91921e9f0ae15a5082950ec0f58b09fb8db0af9b72128927acf616830c6e31e3f6df47e60f556fe8502401192cc534802e14c5e20bda5f5e211a5d6dc938a48b289019b6a3f563d63e44dfea0dfc604b18c4f1587af2833d1515e13bfd6517b6b587870a213741b1738cc77bf11952741786bd8ed598b53d36dba61dcfea9c5a51b758ee724d14ccef6c872c748540566498ceba913bd715238d8cd4fbdc2bde84959945e8b7626d82145c30b5262b65d71642ad0558831c43e58d89242b2085ede98bc906ee8520818ad4568a3cfba14813124d6727b635b81c1730ba2b24250005303fec90597524cdbac917fc4a0c84e072c978c7f403f65a6dc76fadecea9edb9e325bae8b5f728709aac1c59207d16449841addd2e3f9956dcea70860fc3fdc04d1ddf626d9d707a50d558c703e34df86802eb4553ae0a4d9e530651f9d3f2cff9eacf1ff75a935cbeef86e5cec7d216700f8aaa2d7e720b363174fc092767800a2e6dbfb8e70a31e1c13ea59caade8b75e079bfd570f720a8ce73a8a050bc5193e41298448a4ff113e1aec4a3be2b1d0bca09b6a3da7af04db8bac5d7b6ed3723b1bd1db2fc69a712f4caf7922dfa538827b7435895870a2b4763f2da4563596e1dfeabf0314ce9562a5d54e368b2365942f8d87b9c7e3cc92fbfbda19a5fab8f1372f52fc35211cf95af3bacfff4abbc08e2f952f5d67d0a5cc4d58effb6e2f66fc20a2960f8a8e49528924334e2b9e32450e696be9b63b5d61375b7fe4bf2690e9f5ab6ddbe6e8c93604f8f0de8ca9877f5fb8a699d16e0050417c1dbb320b446cdb523437213b89c6e1b043a98b8dd53e25bbf5dd80c3caa59f6a6185415595626efe7a1f47258b7dfe644082c53e9b5b23ecd82cb29110c298e584180ee120f49bc690f09eb9df2493a1a556e312e373697c10992f8038475d9e1a7746f44cf8ad435bb53066c56f69b22f372ab588ab1fce884dd165650870ee5fe2241c1c1549b218491fa58b32fd0c76ca17a017a587d1bb6c4b24b56fb34dfac35623191a86145bd2df020878c1428ff4716e63b8632630fb0092ff7eafea22e3de484fc1646bf3ac37d2bac6b2ea62eb6d7df3c059eec2cb08180ccb02885e96041102315eb9d63aa01ee98960d4f00e46891263e966ceab6f92102e6eb07b9a1869fb2bf26cd7db8227f360336aaf8a86d22d5db684f248bb4b1575f8d4fd7a29b4107af10528a89961d37c8594adb11e5e571d7d3ad3e148f6036ab80fe969e4a3582c104a1273a3491bba5df6dd1cd30ab8c42b7968f17e2a35ff714cf53e115f67ff149a3e4e8e8a869cffae6a634aa081fe48aa8810ae080850c639fedc041122417aea35d21dc490bd441b9f857a8451b274926988f244d5f09a510739afba1dc775caa64a4a81589b44e26dd40036a971de36ede5be4a68e640f9066492a722cfd6f3a6c93b909f1a44aaec1167e194e2ee7b14d8fb7645f9ea1f015b53cbc7ce3c447a3b155d13593441ed2f07dba0e3679c62f56145c08939b7232bdabedf85372d126363ef41163f9602ce36716c5c4a93f001c5d4c9a72f8145d245f6a304445917ee5fca08c9f9cb4c99f4f4a0fcf21a999dd7ef81ce8b5d5870e6a662d49d8e85a533a52f3a35028753ef6f9d939c41ce05f85d3dfacf96d11fc02ad24b2af3fb36311acd91638782ec1333a6bc05f82cd5efce3dedcd83880f84163422b17d0f285523132e578770a563abb3768c8914dc724599ca0f3ec75c9b28e1a425e5e8c048","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
