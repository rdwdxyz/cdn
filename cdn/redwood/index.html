<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8e26aa370091e795edd9603ecea6f4a008b1d9be5da89ed2222846d79c0c668a9857808f7a9e0ccc00c54933e6ad03b5531bc1a4049b889710b9e0a8e0964f72879fa00460987a201f1b6feb359af0e04aef17ca393a926a0959a68cee2d744c255e6f11b6c99f94639a32b05792a29167ebe604577baf25b8e64eaf36b5604e1ddb400b93d2297f8388637c16533865a3c78b4ac5c2789d1f588772db5b401c5f9f3964f79825c35637e3fa93da5bdd377345407639462a88333286984ac571aa303611b4ce02e2cf306520b34ac226d8f8d085c4fa5ab9f656c3f6bdbfbdafb27851e5c49cd75c4256f0489bb9fd34112202e70ffa7273803e7aef91baa143bf63dffdc4e88256b35606a39f9f863fc09a5ee7d921a34b7b87ee8f1ff4c748763588131e8deecd14b5a7f9ad200c667ad10fd49e57eceb6cc663230e917427f380bb5b2e2f9532387dec3dbeea40e02bcd03b5a9b8d7d9c08d920de8af0085c4f971fba884f0760912fb504f624db0b6007537888e5c9ace6241a6187035432ab55bf42be21af69b961233a43ea9466a3fa093b1284ff232e21a49fbd2337c6280fc4f792d5edfb3cf45e7d7d627ca484a50b3d3cab07fe6786db52f105d9c9af4dea22725eb743faada9d7098e005749994d87b00f6f3baa801547d2b9452d4e22792034e6c7b8ae0c8386ff2c593236485e8ba3cecb445c2f768cd160989f7734a7b000468c2ab1fe1188f1ea7230dd3dad5b25d6ff3a5c022f7269e7bc2a5ed354a673e95379233e260bfed8a6b672c201a98e36e7691c4869f80bc8a27ec45fe6956744a6ac0f38a186ed174b10cd6ee41994dc5c313d2889efe00a85cc3888418062a02e4531a58da18a035849a570180a536e529ca679802f91a130cbaa20cd9859f7bf089f7662a4bdbe7adeb247f20dcca1185f84c94254b21f9d1231591401b0afbdc140fe0daee834ec03edcf04dc36705245cc9c178035d340ce3cd7c68f4dec03d1d651cbebb3de82453c61cf5e23ce75e22ef6d21ee09e489828c855077a45b019d1885d8e0129082372dbb88751910b8026384df6a0dc919028083a93a230e9add515b09026fd3628b695841738ee1b481bd74ed4db363956574124b1d85bdd1686b78dea25ebc77221dcc06a09d4c32bbe512fdc0c9f037a595b26e6b5abf895ea73688affdd2c8cb23e8a127d26f9d70fb0032c2fea5059a22f755d6a087c1362eb74c255c91d2ac77b1de6a147e9013a80bbd7a57f7ee5cb5c1592fd44c413a888ac385877421dcb58c3cf531b7a5e4d3266df21f3da3fb2ef65778d6dd1f5d8f417cfeec462a6c4663c2b3b92cd482566a60a31d1ec287ac5e0e232ed7a8b38acb256e939ce3b4c6d7d7a8572c3a932cfd1fa400dcc70095a945352863b7075fa3347827fd7de597c20fc0b0e7dd4abf48a1f5eb2b82a29b736ce33a7a072714e0cf802f042dfcacf7325463163e1495592d6b2b4704260540162f119e23a864bbb8c636164c9bf9ccd6845fc3fa94291882b33b7ac580fc7b76d9b58b2570f0414839b0f9e15817c5b99aaf6b0f5cc3701dc956f2715ef8b8a1e929b4a68ecc002ad1bf81a518f5c6ab2191f3a150bc4323b7ddc7ea5952caa6f17cf7c36163e2460c4b7fdebdd102fbc09a885205babbb1181b8fa14fcf23afce30ca247979eb6805ee9cc8c9ff7850e856accf0f501a44ffc5a04f02f8ee2a10d70d105cdc05a7caaea61f9b581ff854e0f934cba8b05bed6433c4b2fd839f78308395a7c5fdce169ae74b22e0f5eb210c5fd265557bc3f6a4c76af36493a6c025b1b0f56d1262fd1eb921269b75588e9307f994d01f03e6ea2fe21d1651c2e9151832bea3810f0c3a07f7f5b439709f8c2b5ba92a18751994c11104528df93c81b302362fde3456126fa306456a86d0aaf9ba24634a0733ba9a79df829da76ac3864efc1798f3435792aa044ec7fdb709ae8da9807db94c2b516bb12b6a454006a01be6b9e183cc79943bc062da62e304697b58114f70b2ade37e61e4e4eee64fc6c251b55ff654d2f23e90dc89e61dea624fcb6fe5876195546a9478b0724ee223811aa0e18e1f2f5df5b47020b1ca9b88f3b89f6657809b92c6410a76afd6718fd9778311ae1a8620a20ef31e98fd111caadcdf8516825e688d8a8cf519c0753bdb7feb9c20e218a24f6dc99059d7a40e5d817fa7e73c9bcc64856ea5dcfcdcddbfe68ae6eb210a745afcf57a2436c3c2b8d552e352be88007eea9f1b86597c7f58fdd1ac350674b689b7fbd3f2c1f310ff448fa0a19b9e7e7e54991e72797ad4c47a8b14d537b670809cd70128996ecf1e02cdafc265b9097d0038808f9a518f1905749ee3b11b4500056836512a00910ff60cb95cd0d35855a55caa68349d186d5cb05c6b39bf0dc96e9b28f74ffde2ce3ecc9bc814e736b6ec08ac537cc68dba85d4421449be3022da24f3abf777e098422f0dc9383aed59d3b96f311d46a594136eb3d53a029821d8523decf39599ce558607347f6cf5167ea107a77b08370182f9f20b70c1b451a32aacba26230a49ff648230bd86150fc0fcaf1884473c99500e20a0eb2623c369bca68bda25f7e08eb1eebc23e492824333f6865bf226c51aa75a9d99755c3fbb12c58dbe17541427e41c0982a7d81e77e30c171137435326cfe3ecb5ff2b7ac91af0e717d7a9401cf79253c0df1e14f280ed16bdad920144bb2302fb1d245cba7506d3958a8862f929a925168ecccb13547fd4682876a27e650dacf63443f7bfc65c14aee35c7e107e4f9e5209391397b485bf3582491eaa45e89d4937a422aa436a7f9689ff1bbae652da5e43dc2109bd2329892728a5ed2d9fc4db0c3a7aec710df6b3682925ef41964fd66da5775e36a332092cd8bfb860217c50fcddb7e62c3c4e49309b40c266721a06207d9f6da26253749de46ba49cec41f9639a7d02538cf52691e36cc4a7516f8462f003882dbc8d05c7049e3bcf6782c1222581b536c7d9f574c1a5d4c43b2f26920b413056d818e6a2720322bf3e02267f238ec1550a6810ef991eef58c618a064ae7c7ea02610407d60bec4844e27d9a730eb83d8cbdb83594f4ac2a317437b15f9a547c4a36c8979532edc177fb9eedcb184af7be3996c3d611be97a22e1bfededdf6c210fa6db349fa3805bac6c6255f9b60fb8add24520501252f2983eaed8337b4bfe785797f5adb94c7fb9baf1cced72f2ab18faccf183a990c58af54d0b268c366937b7377e0191bcdcfe83c629c509f05537b5ab1e76d1768dc1a483dc5dffa8b1966f00923396aaa0bdd66cdc4006b8259dbfb47de6a12d0b44f45fff890637025ec414d0011136621e20a1ccd5c1fd6e5595370a0806c9815ddd21a1d46a92a04657815245f420a533da61b4f975c691e450f9f008e1d1de15dd571f2187fc21fd5d1131f2a2b44c2a18aac41e7a1514fd1ad2fef8ee915ad6b01bded328d158d6d1ec0c99cb87e96c2b2287230e4e29bc17972b8e458ed58a1f0d845dbc5b1814688e2b8eae74ac9a7572c2b976b61cabb2a4e44548708a0906356e2ed643b7595bbbb6b5c07336db48d6bd7808faa3669e24ad8950f815f06c13947aacaa806b0ce4474b8ec8b9d45110c8ed5f46eacdd4261528ad3c872d54b5ab5d227e8714a47924ffbd1a20509f7d3975882325ab530bb3cbd7454a51c411b0eafe1cc6e9c498ffb334ca46b61d705c189098c5b4987b413a96cdc501c12e9e222aebcbb5961039d4e35bd4ed9d61996449e93604aa40e2ca9abab1aee2fae767e8cdf8fe0c6cfdb18b4d2706eab936031ca08d3d055a87e583548139a650bf42a07f261d611ddb74ed0c8b3489626a083231a80827bcd5c953467eecb04d7fb7ea7529375da02cb9213233d03a280dc6bd933dcd68b6d9edf03e5a650d5359fe95a6f92f6625c6358f438d6d60ec7c31fd5bdf059166a68c2cac28feeb1622a9f5fcb6420692fab65d7db8dd381384bf1583ff3b68c805de6f55f0167d04d4c1b940969a4a21778117104c945932abd4b8da3b003f005026d8e90afd2e88068451cb5a7eeac6af1f489fe84c0e898490e08d550f447607f395e20c398c01222b8f878cb550e7ca46133ba1275ad8d196945baca358a836ce660030b0a3da2c3e67ee60943e1008b00d5a888270597dd84fb740d9d7b4705dd39b46f8ac5cc720a0ff62bdb8487b18919a8f2fc37779ff45d369c86789f5ebf51fdbd5fe24f95864107aa2f05e83eac66639033ab4fab60a2210d19fff752cef987e6af3fa0feea30ea160dd529e1e91e8ad4340b5b78463937ce8a318ce58a95e29d887583f312e79eb56bb22b0bcfb217c302f64e17222beacd7860a72b00cc641046a354704070f54c1cf4fce0649c31f4ee85fde68dd38fa006a7dbddcdaed6efac4e4ada0628f7f47bb7f7f95608ff1d2869d1c8fb63d2690d09acc30f8e544ab407e8813615e6e319f9adc2589476ab9dd088e1a21d6cafd4e9d56e17d8269ccec93404eba828ceac49e218bb145daa8daf8996809e9a4270ae1686ca4db8f57cd1ade8986581fb622a1d4c51abf4287eb676e48896d0ad17f400ad1c0ce4d0743b345fdd00a6b8729f00ec1a86b4aad26618c257be58d6b68b317c651dcc689fe562c7faf4ff315578d7927b4e1cbc8cfc32a4983a231449dc4dac1d49bce4180cf3b19487d27d942c5df18a0a3a42a57327c8dce1fb6f91ed3cb484bf82f5095bd091dad9d3bbce971595fd1a72ab4f5668a3f5220ccb54268d3ad4270eb968f3b259e5667cfdccf5e8cab4ba1cfdb48ab148dbfb0c2f58990fceadc31e9f5ca1d2e0b4921c626f733efe35258cf3adc6d32b85f06ba30ab4c4d96f598d64aecb7abb2b75e10995770253945e098ca8dc4073b3df0c0a29bb4b8f3f9598e842d4a4fda84f34bb92e7585e589ba38b171da433effbfafcc5c7824edc6d5f503d911fb2d24937377fffa3b0b17f47f9fd746ccb85678bfec6c7237c124bae95ecc38366031a384d093814ef5a2c5ef26870a2c17bd300aca7f9fc35e1d8877a3178a6afea047034e471b6be281945e2e0fa2549946dad73c25428e771a5605a923f66c69a0aa3d2554c8aa80a6aab95e9eab1fd2e6595be025766624ac223149bfd3eaa5a46b123030a3358a54d2e2d291f66ddf995ab5222cc73d59afb861d1096f71f2e2c327dcfae5f058cf1719a55e39431072e482ae110d3734c2634a396472b3dba1536d608955a144e98a1761c5ac5535c4c76a6bc15a35aeff7b7710d40bdef9d3a4ef38d8b82ede28199baea3181623510c83d5676c908fe395c0a56644c111525d4da6b9037fb36abee470e1d8844d061b9247932a2442dc62a755be80c42789d6dc3fb22404a245b8cb2c342214a7cfc156aa67f71577b631b7293c7f0152fda2433f36d43b8f25cbc43665318ae301311fb410aefac1b90ee011c7d666c319ccd1818d29889ee2a8e36d354eceab031f18493bfcbdbdc101ee3f3f64b919e511d631d2a40204af077ca14123b66481563c5e861c472ff70fb1d79d2fd93c18c91681129233fe906c2235be1eba30a7785b4877260b6c3c14cb7905a0e69f03724f7f4624c9352a2518f160336b28e01fcf2d666f8a26b400e69095c6e08d555e6c819b5fb65d7fd39db5defdb9a23a1f5f418889b3ec39f8c05f746467f05a8dfa8d24a4f93b12d86cfd7c04a9633afc360af6f23dafad91abcb83a3107fcb8e08509d6040d889df5d85eee9d26474b486cd9755b58c6bc1249ad2cec15ef44ca25be2272326c0c5368f36b0d2af82e259744e4242c8007e148efe2a15e664fe37f1316ab15da68b53c7b41ab5061f67ee084529bfd1c2ea257f5f6dcf1fd4b62b97056c371174b49b26e3a1b8e7c8db9e3a3bb28994366f2ed80eebd5e28368a89ba5ddb298fb9ee6954e20c2b9ff018a66618800b5e7f1d36dc6b67807fe755c7f975a01a9f24c2875f5d7b77c9e96991d4e9706d833386986387a48767fe417373bfc8bd28d1694575d2d628807a83765659e6b7f225afc86b2f5428d97a39fd3721f5fb813fae692c81442be03576abacf2fcceec15588fd2e2612cd2d7d23288884ad8d4bb8613e38ca777deb3b00fc92390868c40388323824df3b9c4c47be5e6c5d5e03d31f910aa999c5101d170bd0b5dd848d24af7edead5fd18f542fc86f1b53fe76ad5816c7770394f6f4afea568d7595d4cf6b4bb13df1c1a2ff133680725eccebfbb34686c9d86490d534d2fa2d21e2a36051115db33c4fb62e4384076d0d600eeaeb9eae2ef5199bb50afa4ae9cddd9bc995de5cf809ef9e575b37b7d5968cd9c18ee27503fd9e6b079f73d17625d07d49e9720866db44ae7395397df517c1de059602c47f2783b30d3eb19dcb66901cbb23d1d2818ebb89b6b5f17df794a7577453b99334a8a1275913c23648b1321929797e61f492069f671848f34449426bda54f0769556b6478f1b2e19420d9e5e5a4fe04c5c72c7e8a660b2823dfdaed07919f45cd2347b4c8d99ee45fa9197b5e7216dd852a720f99cea5315a1db6ad68f81750df7adc42f570544ae0bca47015ea8e942363682a96d36f21869b634ce31647818e6203816eb97d142fea11c9b38ba14b9c30d8fddaa04873f96bd6428fbf0969ffb26969bc4dcde3f91cb0ccb92ccc283e1f181a309b9526122baeb11e5f4b3bf107eaa777cd7e1f605d8f8658ce8796fde13830341c80d65d96fdd4da03b41685fd0fa8266aba46897470e531ebf0e681fbd05054bad4b3567c7aafc0c877f08db983d22c8367e6b525bf259cda85b045b0634e61f790fd52cca8ebc7b2be9b2e8b0658f289fbb401d4d9f6743b4e0793983770564d4e1f6087992ee13dff290eaae09dd1dd1f1f340f92f24407df7ee249039a93b489a8561ff1fe5c8ab0d02fa6568005fb0f73bcd920f6d6501ea14f8759e7971e072bab403ce540a67157812ce0db929d427fff6c9eb95701e097093c23da812430ebfd485862a1dbfe7e390f19fd798b6f0d14d3b581ec7c0e56a29c24cf4f66d730b631be1d571b4cba8616f115df14d6f079b71cc9c1c90bfe7c3bcce79668245e02e3c6f40b94a8aab086d10a7eb85384c9e8a3e244ba1eb0ee304cc086d7549447153181dd1832f3f186da03b193e4d417c9984bb39c2abe4f585f2ad0ad8a96bddaeade9083845660170799620fdf67e1c1db4c91af09d52db53668e452b62fffdbb51870c640494b450b510a0416af5e2ee611e9743941e860724a8a6cec7648ec87bcb0f9a3b9e16c744091795f0a15a6d7811c741738e1c9ac5e19e3a8dda8da3ad6a6d6d15fc9b36319e610df9649a31f35feacb95775a444e262f423022d41c2d118cba772651266f26a8cb6ecb358c16471daa9c7f4b6403c4533325c5baf3b7ec613066c713051f1aeb9696b4a6e0c3d5c8b783d76ca307cda5a0785b5d194c288295fa522c43ee25117205b4f5e91c4e97dbb053bf70811d6bea978aac243f344dbe2f6d2225cc80adbb5f8b16aa8b83b2a05c96b212f7294e0cb8cfc09a22217c285ce93d2f40cfddb9de0dc3db03e9c698cd9d733b2e53c9437fa074a2d92207dbc70d6fc95372ee64e1d8eb9e6cb53c4fa3894386e98d188c3807c8e8e81e2083e47d93650331ccaafcec54f7ece87d7db62ed29aa79d31a91da142e08ffaf187c56a0e93acc0e6e349403f54017dabb37945648201ad5b8c1dd1549153c23cfd45bb0eb8e30f2d547b17c5f51ed4db07b60e5f8914fe83a0ce5eb8234aa726512932ed35ab7eb5582f64143940448c868f57853df9654e5834e270481426565ae27a64a472678361a5d254651d1470a9335c559a3c6096bfb6950ffaa3f2334af7155d682cc808ccd97d66dc163dbf685e3de1e652868f64e212d3034f8817ab598cd75aef48ebea8a352db66f4eec860e25793f38981dabd6d7bd251dc086044f13fd2ee13c4e384a754a73771c571f04f973b6cd3c92ebc4e9cf79c43e3be1f706b6a32da3d68c9e872c2c5903bbf91aebdc538b77ed6cd3fc6d46aa4b1cd8a4e9f17a1460ec6d2dbe26459f4b97d3ef574ddbf60576f19b47b3100bc04234ebc9b0700432507308c6799a6656a1cb0f6630a082ab847a0f9f86f08818218a9ff43eb30f9c97e780825518e904544702e2c4890b9329b384f077165b57abc36050be03ce71fe19f29b3e70f561b4e52baed1a3bfec6e24f43d6a614e5e0b1ead30f9141a7ae1a91ca888c0fe3bf231cb2b1cac35bb59b0b0f9c245aed977d96693bfbe10877b729e4b0eb4ee1dadf8dbdf9498022fc6751f43dbfd6c94d295ec985dad4d9add27d3b68366d842c343346625001859d8cf5652756916adff8cd5cae4986c77a3341672a0a9ceb370c873bd1f85a517cb2f23c086445cd5f99d26a890c7c72ee319365167e400d3d90f8e14e9e815f5c18a27b99568f6cb8f1b2a8cb30194de96358db2ffe0536b1f3a05bfb751332ac5a1fef40266b1ace0b49c4cb6e227ccb4a90cd907ea6dd4575720b16856c7f53acd04dea79c2cf3b075fe03d68a2250e9006da7771115ff22d2a09e1312468dc8d91e822a9e2c0cc611b62205782e8b5f7bd201f7d6d50038aff135fc8a46f61ea11f2a58694886c9156f2dad0b3718bf3f3f9cc82bb4260dab12c697a131dbdb3292baf05270d4ac239e43d2fa2f55c3a71ec0b1fb040543f97a884130b03ccc5eaa66e6b5e1947e433ee79b531dba29bda008a4b61e61eb5c226ad8feef875cd4f9fd225093b5f64fe786390f0a6c0b439002509d5bc3b74dbb2708b396654139c6bedda6c685c36cc5ea7dc9bdd63dd8d3adc80f0f03a0fd350f7526f21f0ea6ecc3ab94f981970265e949c86a25222d2d2862090f039b93378c581270f01d22616886b1b46adc190b519ec82da783ecf7371248546b4696ba8b9f0df81719d5b11bd5e1a861e9dd7f5b9c8c6b1aa172773b5c8e11fb3803f435f9c06c2e2efe4cedfd557ed34529b825ac716c90759b96b404cd739cd12f1cc209dbac5544ee43ff0a6678a166bc45b1f5f5779fe93a482ed8bd04a03dee099555676da3d8cc7a05c1b15eaeb8a01255995124f6d6a1e00a5ddeae930b1da33f9340f2240b3c0c18b29dfd92f63c656817379ba864b293ccc16cee0caeabcd8506ded0bd01f6e44be72b9cabfa9fd4c8598165898722e0e48144502caf9e441aad01c9c5334f40adb5f8b6f577cbff41447134b384afa85a4c9689bb5dfcfab226b95dd6b1331ad324ce611efc1aed224ff4c764bdf776efaab1570ea167f73f8965f5cc14e9c3d4d62646dac12e426e5c8ec651b5463a46bc8cd34ce0210e8d2f923fd46a54b03659e6a81fed2089524bbaa231f326fc099a5092b4eead99ffa3a9a52d45e40b0a077d72da74503191e57498ac8f1418eeccef0c99a68ace1478b799537015bf316e6a25fd35e0c67b75a45ddf1512959f3546ee6812fc90efd5815fed78fbcfc6532f9dac2e5ead4b4e3c822ad1312aba167ed39cd27242def42266530e28e782a4bba9b69541c6159d9eb4ca05c380720ffe33477d792a684b07e5b5f99a952ee9d631108fa8494d079595672dca647f4dae8a5fd012b8fb96a3670640eb9d529c95f450df1f83eaa20f27c463b2f680f15189cea9738d68462097128d265e1a9c9878cd479b2357e69ad23ff62c4f82fc923bd5dd405bfcd8415e76ca00516ad404f813f088a9d654b83eeec8b0c5cac471b9320a6f16b3ea59ab813b9684afc538e56e1098ab49b55d1b8efbd3fa9c5e3b40823bf280f9d054c77accfb4aa9a75f349300570ac56ca526331f6ee02c8e5850235c9e2dbee0a042e1bf4b54b875f06c01bc48359c119483cedd2c772cb6f94cb71b7178ea5305e3027353ec92fa870ddc95cb7ba24b41cc9b0c1b584b12d4ebe37d9330807db87a869cc84933c87ac8fb4416806e8d7ec9eeca8b3f41be54c2c18b1358ad51109f8a550ab0ac8294b0b8f34cd8f3f9c450df0160ac8b936905cea6e44f67f3605938f3c8a9351a708262ecb444ae2fa9a645ece6dd614a8b659453a938e058c7dfaf5747885ccfa30023f45d2271b85ea0f5f4ca302b6ada0267b3719909a6d9f98848ad9c444167a8881b2995ab6f4130cbe9574c5617a0fbf5db06d5da5cbbcd5b444176fc03388753e3662c6863f6b2ace8ae243876ee36e8dbeeff2515ed62727433b40b6127eb06af4067e53aba14a870a566c431aec76a1d30e983bb90ba92ff3e852993b10868debdb9a097cbe10ae98d3a061275a06b29ff191fe940d1ea53caf4b456f0a5cb50d4549592478f9c39e0b72f0f5541d192b70fa44f3d9474091b4bae30bc69d55f6313c4cb7b4880a0cf8c7a903c5403ddb43ba9c7536da18e62176b6ba471bb3a1727bf78ca4c0d99f5d44c7f0d824aff5e4db0bf48655ca3bff864ad8809c2d641bf834fa8995b279e68638e881e435ea3d3cdbe30fa53d4c18dcefb92713e19e5295edd9fa3dcc21dc76ddf98c67472b7540be38d4b4c3e17efac94ce00bcd49ee7743b41eaf14005633583dfbc67be3f71de71356019a317dbb22ab39d45cbc8e3cbeea7b9fdc99102ccffc315798e7ea0e6624dc9da123bd5c6d133243f7c3c6decfca95b2934a2b6f4039c115c4cd15048c64a6ba747c8fabb5f82bc317e69444f49fb175de58031af3764a77deec1cd798b9db75173a11f2203982975bad075b3df90d4eb98c7d87f6b48580d2622705e07ca1572622661d5953c0ff0b71a24651a08d08e0b9cfd8dbd7afe04a2edddd4eaafac9d5a9b6c8b34b24d4d8139a73c661caf0212ac01394eff60041431428fa40df38cce350159c2e3fa041d7d1f6cdb93b1aa9f73010da20825038c8511e7b97cd1d096c9c98e2dfc4522e66e44d1c4a4070a1c3a87951465a5c9bf34b245fc3062ce13db81dde4e9367c78128211fba50030ebca717bac8c8d549d69ea323ed6e956fcb7eedd754680f0a60993129dd6cafeae1c457525f47693a6e0df5d90c8d2a1d66c069a04b9670c422f78f72a1f18daf9450d6873dfb84be383ea9f55476feb336bb534198c0dc1fed9a92c32eb1061f074502be3b98ad6528712082d76201dbea8d73ef05e132b48b70d081e21859e5cebb90a7280e67b750284b6ee9d0b4140e29176ddf2b9a87184cd5f868edfa7b93f56fff7c5dea25414105fddfa24043ecb8508e9c188a0cb9cbace75ad491ba8b81a922689b7b74c31b05d2c8bdd1f00b313224bf993b4b51703a3655a22ac8d86ba3a7a83ee43075fa78e453af99f011b53b43488cef1fb8b17f1c6411ae34c5f865bec555b12b03ad7f4dd66490aeb61b39afd252a2cf6ead959543c5db8d634ea264d716ad43896f56b0df255175206654a27064e8f52ea8129f0a6ae27bef9a93229c9f6199c5c05297e47ca6caf0e7ced9b678b9e4665cc148da8523c55dbca634776f02b32a40c657e22836aafaf36cdd63a6abc8b2248120cee0400e5dd95cf399ef838cd5c016ef61015393bc778c7f618ee0cb150792d4b39ddbc92cf79f8a617c01b4e929f0c74744eea063c83b917ddc603c8041e21d86b0e4d7b9165825bf8bcdc4436eb363b9f850820b1e456acfa30635b1c006b1aa176d44c4ce990703d85e90b3745fa017f00c0cf922b3164c32dce67c4c64a002d851982fbbc95656b6dd2841fa93b5ba6e79b7a8cdae07e95ebde21ae067aee2e5069962fac825175c88e09a52b8a1c91f4aab8a686c1c02e3dfcc91d54471d6bb5821d5476a49a0e31b05c1a426cb4491ff67253c181126b55011f4aa02141aaddd661fb5b6c5f06b7e2e7d85bef2e6c1b67975242968e3e36c51905f8792920e0e917fa74c54527062abb67da2550321ee4f47529377d8e36b345cd6df840da3c30f10323b10bd746abbccc9c8ea63a4ee75be1e518e216da4fe8974ac8f3be5d0bd5de54c50a8445579c1129122a5183c775d3f5674c2a240fc04d433bf8778af279f3dd57d4978bab53b86d422286fa76fb944d08dac740769d71117e5fd197e2c64a5f0d7a2bf87d9315b8b6238893856e8503569521ce6a9f8652d99ba034d94eb81ea20d8b4e585b0a53a2746912afc985a8eeea543c45622915092a96c777554162ea1dc4a3a25f7cd42789aecf412ed5c808990133cbe0fc16a427f652da1487a771a9615b4bbd5f85c2e2a04d10641f17ae88246dabe71c585348d7e861a1df658efe2c54110610ae12e261a8bee35c9d0ca1d580cab6d0c990c535fbd78fe3721190b3f924558835a617aae0f4155fbcbeaa0e020a0f837be48ee121d49dce3587f56139ae201bc8b66f1ac2cf18d95a0ab2e2c20371f0dae72cefe82cac53130571acb8f485912ce450ab5abb72ba19724b15293ad21249f1fd0c45fddcafc79313548b0c49d8645dab0131c056fbabc23699fb1af937345be2fbe2387460fafd97126d46db1a97fabdfeba3673958aebefd73b0097323b511f818289cd7f67451626514cfefb3c70ab3962475bb51da50079946a181ae51d1c6ccdea33bd4dbedcd656c50d55b05d9e076a956bbc01ffca5e986562ea4ec980aeb6ede66779ab8ae7be4b6944a54c6a5e8e3ff2a89538c2426460428455f7c0897b90565d5a4bcd15c5af449ae8702639b8c2548af3a115171eb05529f879aaecfb193716fc5a211556773d501e3d521f8743520b4ccdb5a33101a41afd9bc0e9d8cb6dca93f5862c5a07d24c2859a16052a173366e748d07d09ca4b7d2c81224d9328c7bf72f488410b36fa80b2879c435a341eb259b03d0639963d1c91dfb67e49fabe9672a36d3ce42d6b25dbacd89e6e7ac87d76c7bfac4e71b880ac139a5c7ec2845fe862b335ddb7e9441c5f440fff4d6a48efd3d0299d1ce144f6786de6b545287388e2f31a01f1f93734803de9a3e5cad74975014fefcdba448083cb39c1e2306af1715af3b2bdbc07e17b97a30aeb36bf52c548ce3d279b91a69454a4184467648a945a89c1ebe0379b69a720c0ffa867b6e85d3aa16a5c866177a768f762ed34c00d2d90b00301287a891a1413e24c004fb1b04c0a65dde50698417c6fd380cb7d902607366d216ce3c7848917be8f109dfb7bd7b17afc06a03aafe6bdbe24389eb67f5c367f77c1b8663c8f9164574b0f05ef8d741446700b7d2e76b5273e70d53ef992c7230f79548714193ea292d1346844ce8d787e80da7e8a53469ce44b932687eb03b876ed6cef676692d88fec68d1148971cc94bcb3575d347a211dda4df52a50db38c253e31f56737cb9c2dd6a2a32fdcc0cd674eed0e0b42f6d8dfe0a3447f72658740603b2017a4c32e3ec91aa43ebcf5940c300a575c4988559416e7f760d5c722fc40c7c3ae43f049e823e9595554e0ea8f4761fd1ca560ad80c57590ab7126a733fe4a809b0cff49add2fe5ed4b89f8a115e4c3ecaab8f06c78e2ddd15fc3cb21dc49af24525a41fbcf156afeb4ef74ba67b01b2ff426c3c8cb59def4ca0bb5bc73cf5aef7cb4617371932199658aaf3d616a4c17fd4ff39c3a9d7666e2f9d279ad0c6c0941d7193526c3a0ed5576f099314b5e8f01060297048e77e61ea652bdfb19d48a89b468db3bbbff0f7deb26cb5e8354400750c0518f818a1827ae46ed0fa9313f5cc78a181997f32309687a985c06de4ebe0a2938219897067f20d84846bde3c0624b6efecd1288ed77ca4189e57beddf6feb7e3dffe7effe74c21e9f6bd637b229d582e18a0d04912d7309f75ce1b360a410801a16269ce08621dfef3391f1b5073d6c036ae371d0627e15502b09d53584303549f99284418c4ff7f67ebb95190f0954a411462f5b3d672de6024ae8a631092350154e6f361dd9026349dbf40216fb851e20927b9afee9538695f820b1deb1b10f297ed09153ce91829046fd900ed01474b82133382ebbbc2f2f72c64fae0d3a45663fa1cc6c0b59e0ce36c563922e295fda949da089b934b4dcf2644329126414369553713da69798b770109483b11425e6544aeefedf162b90dfdfbb0050e732f186553d8bfa3d07ba20ed3574b0bb66604ba2017fc3454baca2cf3cb95dd55fe50b5e52aebc962451357ee79f842a48610033de9a39f79204a805bb1bdf9d1b439abda8f7def28dc294b02e529bbb5b4b8f25278f05861df103464dbe7c343a0e69b8946e189a76f6e8dc8f7f592e71a8992a6fe8a168cf51fff8abcdf78ef5374dce4f2b761bc68b3004d651f71d81b6bbf0380def117cef0579c805e9e30f06ff5d4c8190bd82631c6c8157ea789edea509cb1e7ec294c8b8e7b55c2e24c40ceedff26bdb9e1d28a525eedc192a45e629feae28f25b82c481616dfd99dbd9ffa935103ade7ecd7e187193eb1e89951344fce0da562b1270fce8ff6a0bdcd5c7520e2090c190c2c52497493c6dd24505698412628a64cc5fb31571a9914d9a983f4c93a1d19fefc0c2902b3fcc965dba87f9068246cd50756e9d2bc66d6c2d2e0de1af850696e2c887f4a1a50cf55c317e145227643e8ee3c5b755bacd42e0954425136ddc34261b1c815a941a612030245fbac1d7066f490969beb94736313a3dbfb4c97f464ad9ddefe113b5ce5cd3b766c60f8c88dfecb8115c27cd5ae3e35ba8d4d64c22271a01f905cc29232ad33dee022a9d37894ba427f383a45339979c1656bcd551daf9f29a128a24b00c0570fc9d5bea155e0a544787ce5c601001a6d9bdb5da859dd41f0095631483852bbd7280690d8eb68c7a055fbad5cd9cc823752188ab207282fa95f44c907d6511b4f4072f65520c9850caf9a345a2f8db433748223f8e84bb22fd0fecdb209e382141a633eaddefbf6586c475ac539a0e59c1463f2b01643dbf02bc382a923a68b28fe0ae3093c99ad32d338c120e9606b4ba52f26f4682c99e00940dc91b09fa6a6d09076ad6c4f03f75d7bcf8e203bd4fa12a3142bc259752efa393485beeb3935603ece2e801ceb23e756d41805fd20e23c801092e6bfc0b5d46398116a5cb5f349c0e7cee3509ce8eb6bca3f6b8b113fadd9106ce6018fcb4f2e70e31a0d95e7ccf17f3f31946b71e79b122557199d19901fd58991b75563c64fde994cbf5c916e6cde664027a0d2936e4d0724f20c8aff395a8d63cde5e398be75c37259e38a2be597d0fa08462e5c0503437000883ea6b71a024840b558466e00b7e10a474d5899792b354a5c4d4d1198c972f7e2b36846940cb91e83727a3952d70da557ed543e5f24c5ef3abeeeefa32f3e9df68a1c418a4d7451b6e7a6f653789b699d4473422fbab8ac38a4f4ab2ad7c464be0aabaf62967ab7e7571cbc820cee5d03b9a3ac61719c443e481cefac126156bcc867113d2aa6b3dcb1ba06102015753d9e1cfea208073ac8ff88098afa415a0e4cb0a404ad47ead237772ef4579d9cd147e961d1845b037115c68e22462025ae09383ce78c5cab8ca3319b1294ed1eb136801d6fc48e1fa2f52ba433855a609be11a483665903add86b22c79599f157d7bcaa2db9045fbbd51db94deba1e32d13fac842e9a76f5157036183dda525157babbd60dac7d21060fe0eccaa85f07b83217c8a0f497f49eff9fde5fb3b0828fc7f49f1364cfe99be537b884e133d32a87d3eccd74b1dc2a8e2ca16a9dfaf45850e1054a7d44b2e72e59a6af99c6c1e5d068ab21545364b8b114c8b531aa07324e0c9a6c2684fab3018da1d89b89c8178b28635ae79970432c8e53b8c267776ee79bb410e22bfca1aa714ae312edf96b5d6779361aa181a4bf4fbd2dceded359bf72699443b5cdfa07337442b0dfa49b53075e5e77bf32e9757594a567c5a1c7c7534d2862526896f7e56535a4a2ae0ee9ed578f30ee863fe896e1f616190e30b74361c3106558ed7b4075858a235953365663b178a225293435ff97a81cd89dcbfed038a66073c529559a60ddf000c3fe8e1310bcab52cafe7b89e306009fd3709bd653768e3b52573ccaea336b670ae174f0d39a903ca80ef9d3c3b2d5606a79f5bb40d5f6eb4ce112a65b2e9d4a86bb2020261893659573ea940b4d35d3cb8fe17e86db09d7685461439b2f03a380b8ca8ba86899f287b51e646673489f522342bb180fe25ea4aaccbea12f12d51bb92d107a7f4a3a6597027551134d2423531a82a89e5c12bf0ed7d249d77294d568f2eb47cdf4df837e56782822c863b8916644c5d7e7a2a58daade5d116820aa0b02810c38c54782638f4bb1ac4efc026b564cde80a9554aa06196554b8c696767a39c0e98039e49322a56f52bd60cee1fe68b974002f22bb7f09542841b18ce8f68601cda692ea0a30b7b64b22457eb790de79d5866c034e27ae508d879f07841fa4e7f794a11134ffe49c30ae27f61cf544a5f66791d429e4e4a01e4f72a59f115066f0d364c1830a129c25778c43b4068b5cc48ba849152a385fbc5ab5f15376c78480620568d1a3b317427c7ceb857cc5aa68cb834bb19a388ec269b7cf18c2b5e00c11678e6b3b51e7abdad95095380c3b712963673033c5e2e29c52ee72fde4ffaf5eeb44ac1f62b4f8fa6689067cfabb5a2fe30a7d89ab0ef5aef7571e253d2a58f3904908e89d6aa0e78d5471f0b70812b357cf1d6bd2cc619443f415689fe0ca82d0488b06a0304b1101dce46f5d03a2be26dfaf9bac0582957eb7e1d0d864e4c44d731c08fb8743e78e5c7fdf2df5fe9c3b8c914cb57c5f3a5c60e81341d19fa25dba86db4baa52a09f96ad3bef4b2b0a039461d1371da02ac5f7f84b77f5e0b8133d1d4fcd65a3ad2c7d1ea7801f3eec23a1eefed797f6818c22c892c6b664942e27e1245ce849618314ebd30137b7802712f912a211f7c8b2c9f762fb1f7682e2d7bb94301e00b53f2e2b7cd2f4e77e6446670b5ce6d3e9fffeeb99a0137040fe827ad2238cc60a0d14cf01db2146da1836b5a02d729c794407d2c6dd270c7e5592cd7bff99e3838d258a6d4233942a1fc30baea7913b39e155c41776167c4d2db3d99b7bfcaf066b2391b97b56a89375fde859ace13ced23496e3542f792f9d878fa80b0c4071a638e18727b2e73ea07ca90a7f5ab820f3f66c38b893f5b5ac70683161e94c659f267fa31d56f0256a83729df4b071c002b707324c2abbea22f1f8abcea9447e5fea2fdc54540e5c0a23aa6108c2db2a216d24c2fc66d941966ca6ab61100e9f57069aff757b145527706b1679046918b8633aba18c550397fafb7fab5945600932e8fed1494b29486f38a6942d2406e32dbcee10e3d8d677496df318a6d487b0455c83bf1352b1852f24ac8ec5dd311e047e37169d3b0d83ba43b23c84f7d6bd974a83706038fc2b3d9c939541785eea0b5d8bfa70a1c1e9a8fedb40bfa42286da3a8944bcb08857d38e61bd15fe729983862792b626e30cef25e6b4fea605494efc1d74c16c7cd970d1c45f1888b41f059a72cd307e18354740db8db9233d6dc357c42d47a982c66fee6fddfb81a9d7faafd63524e7c090b4800aaec970192cd154eafd12e7076ead2809ad4cb64e2941e255f4ac375d90913235a5649ad6651f347ebd3defd65412a782a7b783321cbf41326bb9483a0d1a1df65c42753caa2a45f0c071ec8620e622eb212f208c418edf1c4fe2d55eeb2ad473ddf68f2547419080769ff05aa3c15cc3517ee22a8c91d3b03a663f04cd48e10d81b2c1f58a851e9ea8fcfe32d4d7544c32e0202125b8ec16368867634a44033608c69b2805f8e5244a147b443c7c769761761a0abc12b3ac60956f6328050b7d16a63e3bb465be40613a2ba2cd53a32440114bd2f10dfd36a921dbf3093e001cd8c1bb045501e65167a5a99c081789616fc9d5e1b482ee89350f15926e4a340674a1adfb12e9bd8f7a81e6ca6d3e71130bf90ef7efc124e5f73ab9821b3066121afc8012234abdb63f7f5d8abb095fe34f80e98c254ae338fee3ea18b914d5a0e3728131eed52d94508a3552241addde8208360208bde5f259bd71f56b75fd5fbee4d2fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
