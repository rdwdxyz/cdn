<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"875ae24e35ee69bd0ec77979505aadcac1d1b9d45123406c26b70b94c9a8f1f08c13140db9c6a6d03724802bee1fb4952a9820aeee70ca5fb16ba0ac97cde5b732c53cd78996438e1e43d125798e20e2701ed23fb4711935e5f048190c93ba4e52b4f51e166dd8b2cbc73770870ed23b4924fb463b19cd1274d9e6169d60702ca7d4a0f213820a65a53799412652dd5da25c063331921309d70410bb12396246379e2b5b3e25553c932aeb871eb4b72b650e24ae8b6e01534d0f676862a5c738f6380354f5d6d815d704744a84591a662202c31ba69693c7a4664cbafba9a7f7fa62b8f56167518220051ab5bf40b3ee993621f5b8caa792e6856cddf2996f146db526ec38d13b2340eb904cf66ca64943c1cbfebfa319f64d9c793425a0fbba668c5b71cfecbf3a1fd04523cbcaefca57ff2c3ab70abff35dfd9efc0d2975d6ffd584759c63063196797a9ef1e82eb131315a28510dacf2be38b829426af171773caddf0b74747178cfab8ed3bb385db5bf4c7ebed82f7ffab231caf55b1fa99ffc2273d6a6f68ec615685b9019b0001bd65efb9eebe3fd65acfdb1f4495135efab972ade38e15b3e68929b2bd3cf3d34b9ba5f4966b8495b3365cf8b1f3fe761135ac1ea46c3c7d62ec90540107f66c68da6ce27041e4fee567aaed36e589ba5f4d5f7b6f90f93aec41a95254d43ad22f4fc7c0226305734bd3310b1e5451c08e9eb925d9c7c76da3c605f119b1c7577352631803060283a485fb79d7f78f48369a065d3f4b9af8e85a0e3432250faf9c077aab9017c500f46db7c82939eb750a950d73e91c9a7916ceee373a47e9c3466562bb474a54921a6c5b6a278b0b71e444faf4005eb518255b58856a08e88152edb983bf72fb0c89746d7afc79dbd16659d662bf12570e1fcc6053af21f2ae5382912e3a71d0408d61c1abd975874022fb36b8ca7f7a4261840ef5200d4c0208b5a07589c0dd7e4b444b6105edb088b186a2fb6e93bc3911ae020f885a7fa936016bee0965adcb752d5005c855fb5ccfae4201e94f12fa4d4d0bb8f8fe5ec9f8731b01eada04e77118657c8167a40249d829364b215c9b26f72ffe126e1ed24adcdf03de2a137b49676ca5d80371852a25ea00e17a825d21ebd2a1051298862ff57ac43997d4268f64bc5333e4b53bbf5053fcb95474b19014cab9da21aa865e531ffe573a8ad8e4ff9250dcfe240e27bc48bb6bc80a2a5804e07d30cd1b08f88777966f48b9888a15d50d9c43a83963f75df3bf1c7623880ac8f2844c1ca67297fbd907078ea03dff5d5ff2b401bbd305f46900b84d690bea5ccda91652ee0b91bd115b93221897baab77ad26c888c477a7d99c77a0f0234348bf42938e4642ba74a26308b9403db42fbe4b9d5c8addea1f3e7c6b829728205f337c55df01a8765be2b80adb02eb7363ad5d9efad4fa8e2afe1698fb625565c062063c78af440b0222edfe6b2244de6db620996555e32e21cd3d0779c06eb3fb58113b1fd9ee148a95d62ef66632cc2261c4245cb76fcc3a9520b9f539283c136005927aacdb931053d9242f30580682c4103e6f1e300314adc0700eb32ce2e3ef57b85b8a4a3c62572a406e0ddbe731b6f8f45d7ca6142e6690ca980170e07dbf709602ee9fbd2b8b3c7f76b7e735ab85669b0ad53b75dec4cb6816d6f48da46a6f2c70fa48a407931787004cf3f182083fa14bad27b6ae52ee659c26801da32082b387e1c4c01f2f74315fa0828f2bf4b10f32bbca655a574211132dd8089f9bf001e102109cbaeed09aa7d5d26d32890c5f985bd93e4c14faa0109f8ac2d4c5968a12e1418bdecf4cbf8d5e706c350889b5ca9028cbc4dd0b485dc996a2da08448347400d39f7fad83072d05db50c0896068e94fe1d6b02bb7b8e808d6f32145ffa863162c45d2ad33f4c7e50b884c74a23c696b0efb4c0d8ba8ca50c0c84c1479f42a393f6cc3c1140243da343aa2f2d393b825ea4e8cb6704a1fba18c6fcf8cb70077c5831c60976be046e201c2be6a9dc1b6818e73a88988fa265fc1cb7c1f41609544da98f3f17508e740e13dd74bd149c5c567819691da47cf49b92875904f8095c14cb501091ab28518f75ea2f6ab0d818dbc212c25d9e799448ff75cd536ac88cfeadbcd09fce0499b4c47f95427af1b0abc1aebe3aec4b38defcbe6391b5c2ba9a99b887da43dd4cfe43957cbf97eee04024c9523712fd9b1ead25fb55dc812d16ff7735706b0fb06c34d3c7e1764959a7938bdc7f539c32eba8ae4cddb3b7e603924b898655b577d8d76e55e42abafe9e55c092193b1c078fc17629669158d18b33a483a7a2ff6bb63646e10a5525617340b9d012804d1d0006cbaa54157280505120da773a7404765d7ae73e51aba0530bf2fcff5aa04cae2fbc5a35c0d4620f0ef48a7727726e2baf510aa78746507ce5bb3b1a129bfe60e2971834b21bb072985b8e968233562167de6a6bc264edeeea474a42a77e8f183ebc47161e18e5ad10543fec1ec49178f438b0d0763ba7db9154db4aa0c1b21cbe7a4aa6884cb45fd2dcc25b7f4f3f4d6254f48ffa971e4e9324cc96a4ffefa1a1d7b44af11e599a53c92a170376ff45db2e7bd4fea665a83d2c384538852b200ffd4ff97a663a828434cc611a64a6b1b6cb8fca87ac98758ffdb845398a13e5e29ef6b1c4070931731ca5ce8438e1753ad95a1a03de357e432ad86d6bc0bf2f373d42d6c182808ae1e59a526451be50e839c8c1811fa880dcee187364ed0787c914d3aeb337ab9716cc49c32285d08a91eb65f9b368ae74cfc3529d8563e05972f72dc252b14cb22c1306d752b8e4e6193f1091f9271e9d2335afabac89102eb02ca2475f73091e12cef4a40617878cadc133db71126408c10ec576403bcee4ab352df90f270ba3a2e98bb2c1458698f0291a2d0c34ecb9204f05161e1271107814f1b8e87eb3f2236e142d56e29edb57b793f9fcbba47d1c7cc88c9380232a66a12ef79406f4eff8993be96d0d8b3aa18a3f8e0202c86df677007b133ae6c2da03f7b9507ae35ed98387354c1d1901271962b9adc5ebc876fabce200ff7fcd227eaf653d0e53642bf1ce1dee02c2cff5e5570b7feeea59de68fdbd53f3f3e34b75c06e3431ef37a76379c73d1510d37bc16b33931596bd9a38eb0a2be96e80220cce01db67d17c352e8f2503a3db24b3cf724926af7fd647ad8b061ea70f3769f5d54793279dc48b0fa0c120d5b6b1e0e0ddae0adbb32707bf273525b22f22c0913c969a226208db892f3d7c199fdd02748a710eb1bce8621d93c15ec6572531411ae41ecc594507010a87580b1694515bdfde854e9366d1ce0a6fe855a933a6e3c4cbad57e64841ec061863886edff53d2df7d711e5bddb4ebf35684fc90ce247ec51d13abad24d99afd02dceb8fdeadaab4536ce405a08952cfddffb0c16d013bacef0768a3d457fe30fa4276a2f7aa1d59190101f1f774f96e42c097efabd49bbd8d9db8938e435b8b4824263af3b610977f03ebd85efa015f9d090ef30e468c439bea1fdd1723d9dae1b65b8ce3cbb717a5d6ee25fa5026bf5087a67d5220d8797857743d7865320d4109a992573c15bd7b2a5d5fb4397c73bf3eed1ff3dac6c32fcbd84612e004aa5ac61b68c994b30d6cd651a7d0ef7252ef78b308826f9903c5addd3d7f3ae0b816be0d44322f482a3f89862c0e9d7401d973238026985f6dfb144cd2c32b4bfe5d35c157acb982cedf8c2a15206ec4427aa244169f6071d33294107c6b69976cf45af57ee21b98be957ab4ccc6f27fded200cabe86a8eeeadfc85c38860c201a81be75c4c3de0915084c81c97c2c2bb3aba12c1ee26262a8e147ab43b45b7ed30292cdbffb6f5e62aa2b01b62623528ba4000d6272f0a479fe4d044ab13322821c14729b120c708f43f4ac17e167f344cb94412ce2362182707092ece0632d28ee3e29dee6f8ae35fcaeb7a59209edf5c469a7dfde0d9f43be3875d0dfdab8cc931afb58d97b9a1a598509182271e45e6294531787e6a2d58ae135274769923f5a3be0bf365ec412852d0325b64b83514f11aa1138e8c74f8a73ddb64f012bbddc92b36ca972243ff60252ebf9644f145eeed4e14c01a58427eeec9281f83dd5568c05a04841d7abf5a8d7abaec6ea8a7773338f4e0064ba2d321b65cd4adeae13f67f58c192b7a99314d6a62634f861cd86dc9e5c75956aa4daa60936c7a5a6816bfd48805c1f8f603f22869270d09a33f08715d958041dfe3baec33b1f223c676c8c6e15e5ed724d639a2acfb7153f1a31fa522f5fc7eaa7e2e6c2ae9087badffd9373199ebb310036e1a39afb14c93e6438ba696d733554abc5e59d00318e6ddb0870c923fb1ddff23932b20b18f9f7fec478cb1b320674dde187c1c8b8f635ef3e8efff50b7b609a44938ed3ba0394f7da37210b909a3b709b59af085d541d81f130a516205eb68baf4f3810a557813e45c83cfac352322c9031e5e756b9e91f665e28da8d5a98de65678f1c69fc86431ca41ffeabdc0aad9647b2278db087029b230b3d4a0cb66ceb31e2f3c26e5f881e75989adf2f0caba1485a12a9ecb144261cbcd84b400a979ecd5ffc53cb2a5452957d36dc38e8f4a4e7916f2b967b6008040a9edd0c1284be603e82c41d01c7a6c3561e3f0d6151079047ab0d74ed71d24c3cfa756c93667f8fade47d5fb0e904c145b83f07dc16b1db4edbdbbdb7b87b80bbb1e6b87db92e0c6659c07c0ecb4de2bcd2b418135d58b430691d88a33c2dd04143ab477f726951d3f7fbd24112552bd45cdd5d9bdafcb8b72ea19f35bfa10537653179b4b8322dbef1ffbc9324233ae986ee01e9056ba2bb2810a800b40f2b46ac78d89fe899a2184fa0f19351ee37ae49cdef75687b2737c73a0137f81795c2d5edd330d329034ca8bcd1fda7b57ed289fed67437a74a2ed4ac2b65821139c7309102a0339149faa9c7dd69100ec0a66af15053e2f346b45b2fa3dca0d7dda204fb9912a51bcddb8c6594f1bfa1fe96d6608ca6dbe389f65c881b12b58cb0842074450c2bbcbd89a2af1c3a3878bc37fa3450204dc8d445d87d6f1bfda43c878868611098bde5b56b85bf93a4c3f0cf4aab21de8b84937081a62dabc2abd6dd52040da4f80bea9297efbbcbc93151790b5d255eec6f6c5611bb1ff748c96fdbebf2f4542ce594b69d3d6ff6ac8f2a82f1f9ac40bfccf2e09c2ac37079831f662c82e4db11bb54ae0f388a28a92407a401e27dad4b39979a66ad81ddc54d27cceac81071c96f59298b43b0f120a946f26fbe31a0ea421fe5dbe8de2df24b025f61f0d17dc066706b5cf21fd646e42611930d84645dc37daee2d671aeba68246fa501939cc4590f983be362e118bfdd5f1f37b4f8d552a9855a18a7f1aa623ac00258051efb116a25bbef11d264c9f854811032e0953e791f672184157a543e0c7ea1cb158f95242acb1af111308db443f69a1f512ee8e3a1805675ae7c549352f983869bfb10e38ba4cc7cfac73523b301a1793268ce935e70114337c3683fe4d94ccd98aec274827e813237f2f27c81c0202ca97c8415e5cae9cf2cf562808ed34c76613d6723e9bb8bd383ca3492a87a37fec858ffa2c24ace0f143d907905259e97f8240dd9e80a238b368686757c437a8556cfc2f35a276e66404e3014a361a49046ffcda18d1094775a1baf44d602c8211b0cbc207e46476e004346055cd1943b287febffa7e73717c3b2b3268385a4a92f95b06317bf91667cf617d0dbb845eda159daa49f177e3a2400c28b60ebeb2bf56c7383d2d901b0b0b2761b6196624c851f5ddb405a2748d5a74b35a6556580b7832cfd73795574a9a173f3ad67b0917568eeb6cede0a6b309571cc4e35a8f74c0814024bf97120e1ca7bf0434f5115e40aa9caa144ebce210b0af66e3c16432fc7993d6c8530f74ca76c863cf293e2220ff6dd5911f39d2f6068a76913c2e6d6685144df73d021531e6299706122074cc6534378e78df890953ae8793ccb6416e6a20337b22bd6d0bf5682a33d435997c10582e6bfa2ce412accdff5d245924f5ad9dd1f2985ce8c4d0bbbfcf65823603ec21d92c89862b37ad957d9239a2b563109e5d6f392ccc0f703080170497b57c639641e71c94944a0ed73d2dfbf6e705c8b8ab2f050786aa1e4e88c9fca04f64330f78921d81d8e62a7806cf520f0486ed34382974541e21a43ef34c9b2bebb47ff07cac73690f3204b8fdb8b61d7c4610dc2b578838be2e1181920ef914b767c398bc6800244734238cfb615326b8d57860e831c5ef3ec9d11e384cfa5baed2e5f68a055ecde08e53669430b198ff9573c2c7efbe7b13072c1edac8912b5f6c5b66994183aca0cc3d450e549952bbed3fd171307515eae872a8e9c002b4c5d2c7213f137acb7f58b22bf1a7a5633a9a3207551961da2656fdcdc55e7cce10fff17da100527b73cbe2fa0a5fac8f763d7c9599da445e984ab915e7cd36441105f7fecc25e8ea93aa1fdc25f98fc9b483687f25f80523f91b41d3f35e80e7d73df43cff93f588dd4cbc4ab9679a2ebb2d68b6b630f8e5d6613cb64acc7096e75b14dac6e9edc1965ce4f939e5f111c79ca9872f38b4ba84eba80c0b36a96d924a5aaaa8d8d7a89240f2b708a0600e821c0bad47067520414bacf625b94375c5d6cc55949c1724720b5d1cf1003493cff6b2800294d1ff7f692f00867925ba29276cf142c3ddff7de0c21ed6cd4300d3fdba07868eea40121fc20bb730f4797af9cf5c83e32c31862873790d67ea6b29c9d2644d9fbbd1bbb4beddd1e2714cd2f6f0149c22864f7391a19104142afebe5060080feb9f4394f8e1a0a659b56a89b4626348fb8c6645ebedb83594eb7a9879d8cc683a3502acd2355d2cd746cd923372e67bb93f00db3feb083320849848ba207bc08d1527dbb1ef3b588afd20f509f9defc787318692582e6d2f24c95578bf5a56742aec461da436f4cc00564c0dfae681476d219d73132dbaf7cd96ca2438a9e03d53213e2cc5f2a66546383112d0e480d591ec52b0ed7a992e2db17f8389ccbc52e978c883db33ee910a3f665306f4e7697b3b759790b9c6a95a6e9e52745f06324bd92a97f486a0591051a19cd12420e753d16e1e206ba317f823a9faf14c618f56131f1c304d731545131ea08539e7543d244d105e607d2888991e7e285f02fb36de2dd4c83453e3a40fc0487079c7eb4ea4082dc382d435e5a11e7cdc2673232f2e70a584a7fcb4baf123694378d142db61266be94b30541f43ef62e2fc1eaaf6391d5b984e4d2c3c1c5dfc715370d3fbe4699b4b105e56c59264608bce9d329cc44fc960b72a5c777f3ddc9869f5e47f4900a154b0e654127135ffcca11481db81f00ec24942abfe4e806a5a024e6602dccea4b391792bcba54f7fce8ff80f491a51e4495c531418c078c0933f04ab28e825ef299ff048c38204763463c22c3bd9f877a4c5ae373a206e4fe26eac04bdaa558fa8ed45768beca26291138d6013208706505aa857243cd1095169dffde02c36a446586551ae6b948a18084c391818a2b858bb43b54e6a8c8c4b5f9235b9b20ca278f0bb7ebfe89359765fdd37d83230007d2a2d57df1c79edb00b3849a3e178973143f8a7c79b0fd780efc15f6dd818c9ac61b47528fb79cb23cfd69896c8d5b6dd463173e2a7db7fdf88fe7058573185ece32588b604e3b49264d814b01f6f2e86538fc3a400c0c4021d6e7a52d60abd3488403bcc52ec02e1f8f1f544752b24236b3afa494159d542894e659f3a197c8a6f32e2df68f783bc3bd3414b381cf4d7dcd7a8aef14797d1e090dc6cb7f24ac7e698e9d17e434c065732c426743b2878ff67003ae7605092725ceb742b6e47a92b0de16caa6e9fb1d816c5467128d1563c42d9e0bccd74c6951191713255c631fe6f085b0484124fb590db44076ffc3e4b639b2fa4cdcc4b5623130652f2c9b83e4886fd21c0838d60db1f924ca34732ff22870c8ea41f35f57766917ded80d20c3a898761b105a5d4100c41ae2659ffa3645fcfbf3d14a442e18857dc5825952aa2c8481416606352c61b831657fef362acd7aa73ff7bebe06aeb3fcdbc3543563e7a8c450da095515b896c5ad00fc11f9bed252ee525e61389c1e23b16c79c38b9040614b55dddeb5827b7346efa1a873540a8f064df966d4bfde10920922ca75a5589bdf8dc5b2283df4cb7931305ec2d2f69b83d2c08f1b4975698d3fc92dec95630d4b8fa66d5a392ee97b9ff86505277f4b4e6693cd6323c3930f5c20a517d7288c28a8b963278928161b742c9b449070ce0c4bbc9200468654b2cc7467a6d4a41aa0d17b41732a4ba55d6b321b9371aa6a57ee154d969a5ebcf9ed96c5698787f4377d2a122f3f17e7033f7916aa4705fbb23bd9913c70a727aa08fb170bc273d5686eb53d29aa5d69a1584f15bb6c22382b7f48535deaa3694345dd76892f78e5087eafd98bef2d857982f9d7635ec0634e84cfd2f942dfdad4a1451548862151e9f7cd92b8ba5febd433ef9f50e2e3740b6f2f4d348f94ced9b8e519fa0c025aedc473e90cb25ad72f9a94ffc93e0f220feec4e8c5990e2f52d8c0527ceca64c0622eeb774c8dfb8f44b2b3b9eca424a5f7f03b6678f1f88572dd057fdbb88e580940b1803eb51f57e306e73bf8e313dbc6f14f9be54707f33d654bdde152570b46fd8dc68eed9eb990110e2e8003010337a26d93cf123c9cc26da301321d4225d155cf771d6498c047018f7cdd304fbec9b293e91ff2c299300dd325dbef577beeb6f1a80e63b4925a0a810e547d80968d254b76f42d0e1c051e343a3abcf7d53f05f68d2789ddaab6ade3b91582c72fe9d8f39042d1a60f283214e982fae01e792af0f64853b9ec0aeb6a77dfc2397fdf5a2f76f3ef79d4c4e4f43565d3a38e0194d416247818a8178c4f295e1ee9fb06390ad61617db3db5abd4fb496caf493aa93bbe95f0f7f712128cbf02bb984b1c225c68887076d2c8f5ed6cf35a50b16a7fbda9ffc763483985ce401247ced7871a2ea2388fa9514d86a036ee35e2c6e9e62d93645f43bc2f5e8d5ba851f10fa0df1bbf8ae88a8c756ea1495fd132f5f094f643b00a7e80aadb8e99aa5117a36744fd5bd3199262cef4240a5612635eec9a4160097cef25ab7bfc412fec401271380b086b90adc1f39b06b8d4abf89d617ed67d5c5ca9e00e7745a7d0d5625a916a54059a2370df07ac9a0a7f4c6837bf9d4dc7a17153c29ca09afb07c98a5f6fe76354fa2f601105ece7d5673ddc57945db409ded1ecac92e8c3df6a0e8c0e278bbee3d447d03b1895a5a04fae87b59231a052f441574ecf0045003246ccecd7e3d93215599b42d6e9fe2a473bec6e2707e12cd7b9ab14ba9104eae96090124af35593f8bb983a46b20f7262621dc7c181b6022295ec61339cabadb102e6a595890e3c7413be156aba5a553ab5dce03a1d8f6caf09190f294c2d12b7603df547768cf2b60548262fcec12c4be2145ff7bb3fa393db324973047afd80a22e7b5745b226cba5873691b544f5554fba12ddf92ce92e52d6a186d5a239e9452c57415f67495124fbcc130b7cbad49a7189d3c42edc7fc13e617695fc51694cd7f4aa4e2094182073c7830a40c0c8a3deb4e722651de312b9f5228b241b4761aaeeb18f032b7960f9ef6e01a87ed54287d9aec93672d4692cde9cd4f287457f5e3f2ea42180e5cabc6e9e2d90935089d10337aee3d3bd9c7bf247a004e1e19a8b643e2db76fc1c21e6e45ab938c941f68904b64570068a81962989d085fe4798628436b98a2148c91d227b985bb1d8341fca2a2b0e797ecfa4790892a61ea0cb9e3d0fc74c0f8fb5f469380873490ebc5bc6d411c55e0ba130839465ecf7c729bce0ff0f4137edd8575ed956e1989e8d0be5f2606bf0a2fe13a2b1a51b962826b71ac0d99b2ac83d30829dc0804c8fd0f3c7091e14cd1799459b9619737efa21e27776c00428fd7b99a8d5735a970d2880de57c917d6a93c06b95d5e182454231597c79f5fe6b4cce3660e29758cd8fac257deeb311dca110d110ba4c36fdca565975c1854c0c6e7525611191bd13e558f9ac8734abb43b9fa7d1e667a83cd8c264ed4a09dbbdeda94091c0bb2102c3c3071198935540d24daf7cab904165ba61ddd35f0c48906b108be7b85b3190c8562bddb026be8bd7f9cac079feafcb932cf14b6bc8629073723ae11c0090ac368c4c04f4c416855ba1bf25cce7d1c2c5d7a1d22ccbefbd33baa2bc1af98040896390aeafba60b16e5871e27e747b047f6e300adf531f2fb4244f4b308151398e3d2770773c9184abc8407d0d6b4578ecda1c786009c4d0314ba832f5f2a49cc25841098ef5f846b9e0872eab77358edc2ba389ccfd0f4a1a2d72bd623508278659c6a1e907ab200a631b03a3644a658a5eb8b3d83046891e15ca75605c1de68c10117ea217376a91953894c467e526341f9660c76c8b618aafed379c5f1c37a4a4e6606b38a46d299d12a40d7076c1c5c5b238cac33b0d7cf4d3955801dc145912bb2d8a5e4500c14f67df3d4a101d51a3676a48534d6c988978659547273035ed0adddd7c2d88059dd33a5ce9408ec9abd4e4d24d663ee1ca8d5194f9fe4dae041b6fa2d63fc630ecab53adb66332d54cff7a7595814d086849bae5ece5ea0565d2b3200450bc0386a087508c630e3bc287ae089d1ac486a7636a9d1fa58f57e19757fcfff1784858d34b60c4726b2e421ba09fc9244fea448c16e4a4d3fe9a6275f5ce64c5516eef0a3f2fb3056a0c46814054d83bf97e8ce2a1788e6365a4c4a148bd5be80b02836b958ea5892561cc67c20a0b74c9476dc634e73a8e7d34c4c139866af2e28bf2b37b9c548a06f321a8dc267cfc3c1e1d09f72b55cd8153d687900d26a5ed79fa8022ca181b6b780a8f973ddb8e3eec57ced7737513894fdbb09b532195de33bc2d01a019d533a944a43eab52f3f201c81b2b9f05f0db095c9027fd61a084fce7c2cd89c844081a1635d29e0db747d9c6cf8a72916324fb569af3fc697b4a22789f204e5bca0bddeb0bf5877fc62de1833f34797ca65c1d75827cfd1df1119de6af88cf21fee12a4cb3cffbad15e83e765553275658f9541f926040a422722e89a1a23439b52c0f33d2ad6251a9f87d31366f08f6717f5312a56d2f00c9f6fcacbd4bfad49fd0ac70b1b0dd3f0d9ba24cc8cd6d8851f4799075600651ee8aa308c19f18e99484042dfc49cd78c1d136b1a501e1c7e2964dbcda8dc65ae9189cb1fc4839c41270b5fc497acece4d5ba31eb97427ea91e530435ab4dd2881edbd9a87a359f8079ee403c02886764a8ca07b0bbda82eb27e4c4ebe4357f8faf68f214a74c30ed32af87db2ed4b94c3bb446f3244c7f9c4d37e1a9dbbc5f350c9c81f5c1d3f9ef5d232664f251d700867fc9832578ab56d6b77f3822e75fd6fc0e8ab5d32d66ec9aa46c4b1faf0ae6c5236b91978107e371804e5b11eaacc49e5b3fda70ae681751ebbb19474354979f3d382d56f26d8f96b3acd2aca0f9223b24a23afae0236e44df27ad79ce857d9356bc1953832185be82a67451c5de46882bb0a9583348a4494bddea4042db13fdfc3c4b28782a510fdd8709671b762678f35c1ac3749ad01f897a0bf9380262096c8c9928bc0692b1b3ac9190dd812c1c98099649d14133485d1fdd16bfd921f36416b3e69a6f52858eaa323f018ccdb2a3972da6dd3c9d99e14cbbc5b1469056b104a166116e905625b9b5e9a3f4785f875002f99570750627f8fa37d18cb9d420c2965605b4a9c900bac3b273c91ddc6821e0b88f1e67a8b86b559e69563f52528a82bad60efab42b866e1e0865becdfb1e96c7e90c29c4b68594ed92460cb395f8a64985048914a21d66356fc3a0edd94d5ee96c0a918fded9c7eaa7b1d0e5c21b95bf4b761fc6c63a8367a9fae56d476634c9d734805a08b30de2f24f4441fbfd077545c8714ac3d07cecbfb195781ec64fcb5f8f928470519d9db81740c66e0fc193ccd0e76c2c2f6ef43527d26b50f3ad3d39efeda85abade6b6c1a4350ff730f6040b463f404753702c15a353daf347d38a9871a56e107807de006594ae8da421e2d89fc075c810140ee21b194c028b8d3c34b16306138bd425bf6320befc4470722f21e07c10771799fa631f79b3e5791780c761f3d90dca2f52eac649946cf747757db8194bc2e42c813c2615bdb1bca8743d62403308c1a56a67772c388eb2c28a45e0a4dfbde6cabb585486f82b0aa0b853a0850867b76971111356dbd6e079a8a04bb2d7854b0893b52be87dccb925f5f7ac1908308dde763107945e2722d6bd4df3a1932645934a1515fb65875c99b7a600607a463c192e0e5c32254e4f866663efc32f4821f69ca2fe426e5ca6331aab8527992e04ed500ebd0fb6ede0a1cb751ff0e63115461b3d6b4b6049ad04fcd370c2c1bea9f82862638163e482b57019858ba4eb2ecb9fc2539428b80a55b08f103fd8fa1f2d565be1a85c0c191459d0fe541643e18413395fb66269212a7882354eaa4c1b7445d573299e3ce3548bafb2a3ba615e6661b96cd4026befaeb23b6f228426a0c337c3f4bf35119e8c2754cdff08bb115e83e3b15a6a5bb797c1753e9129c3566f0fbe86e86aa0ce5d3a7b0f3fe6d27c3782b35927e18f9f1d87ee684f48a270137d4e64ed9e9eed90877f0494568cb80ac48fc6de6d6b97ca93e30013763725a44cef4bf26c233c13d2b799e072ade145f39a8e8e4c75f49097a219bb51b9695a44fc689ec7831f4a2d171d04e99d5c088896c165ff0e5df1250d9a7fc645a078652d6f079aacae9e2e8bfd49999594965eecb03a2a9d692cae90fb4d056655a07938b917d9c9a5a514760618fcc97e4ffdefac8cd31275c152dfc43834b526ec0b16d8f9cb6e4bfcc1a68abec7b437e567fc652768ef49d8a380bfffe8b94b292f9344cc453b19d9229dc5d2fd3e688557ec7a1872500e4bc9797cbe129ff2e25847b635e40e7c23d780f1ad1c5dfdd6aa25a1b9cafc019c6a20901ba471e49e0615b25537b12ea71663cffb750bcafffe50fc8cd866a7024eb7221335f727d4c561556bc48ca6a64a12abf2d5cc06cf3bde1b275b3de04fa6f3723facd2411032f50d17216d9d377a86f08c5b43cda7089b4c0ad752856ccdc5987a3b3a58b10662c5780295ffd85a7062def7b59d642bed194491f9bd08281cb96ce773dde05ac6c2ad887153c08d3559d44ac6e77d7a8b3b40dacdfec5d311b50c9d7a0510792dbad62f905e277739cbea3a75de05da118a8f0e0cc53d705e7accc5facb54a8e17229ee4716fe93cdb6dc9415931a7bb8050eb24c2eac5324e6a6125909faa75afb3ff85cdba43575233be44992e5d1c57765ee6414a3a8c16453da4c8c5b7cde6b752b3c01bb796512831ebcfd203b379824fc07e8f3834ea39b2b6bdffb29e973df04e5d5fc447dd8f34d29aff8c763a17f2b63fa5be85a8a0a1d567f72cd71cb549b2e983340ce887a789d4a1d8bdc38f15c4fd9dcb1d6d1b8434719fdd6c076fc04302f87d3058e180083a10fdfe3a013ee1bbb52d43cf21c95ff675fc2c206ecc9a4225ba545d2fe69f1bcde70b33f7f093168621e84a41a049f5b882b42c9dde73b6b8cf4e1696a0499c2e7e512aa0f7cb45693bff8608837c8c8d18b463d98f200d4e1de1f76916d45a5d1619cec42010e1ffbae1d660acba8b8c9bb0228871b773bd771fb243d445324bb76eab833e7ea31dbefd938821fb59aecc8adf22d36727b404d80960a6e925990485a9aacc562ae4d7941d8ad2f6978978fdd0786ae943407b473531c69d50f16cf0dc338b6f4475a0a8e703408b4e961ba0bcbeda2719016dd14a6dd4f2cb4345d780ab0d2b9aa1fd57a35a79c847f18f13449e49ec031fa33f8659cd4b74d1a85b1caf3f2bbfca188cf5c86ed449a6cbe14fb26a0ae81a919bff0bdd45d3912a532a34b8674f1c493c795980c3fc563c6fc3067a75b9ef5338be1c4ef08b5fc2b76ea89173a9c6c93ddc03024babe83ed26bf397415793a256dc146fac81019c755dd84aec53a62eb87f66f1a5baa00fb5ac7205fcb6ee9cf3b69c5081c696a9455da1f7b7730f22be0142fa0fb2cb082e3475a8793b39f04308978e634a6d918b7225b1cafbf1f90e77e609cfb7babd2f0083050daa193a3f68b85d42b8e340f3865cb2503c874c91a45c72ddb0e73f4c0e43cf23b7a8794b1ef1dd696d2fe519d2fb59c17000d81ffaf4f58288a0f1125801c79f893421adfd831109e78f09f794b48c6dff2a2798e5def08ea3018edfe8574dc59dceba64bfd933af19e5fbb1ab040846be1aa6aa086e7ae52ecf9399ace2398cfb8badcfaae974e6848be7de8dea9c6a56ee62d22dba2ada19dfa52a3444937a7bdf8ce366a7dae49a1e2cd082e13f050028b9413e4290ca67375c664e5fa5a56bd07757c17fc9367172fd483138c896a356870331091d34e573a58ce54ede67a35183d4ffbe59cce5d203efd3976a1ccdf066eab2797622b3267ac581f3e1f98eda6eb3b7fde3e7a52f46169b76608b78200f0c0fa7414880851bd37c8ff55abac4f6bd2bb62aa5b4458368598b7fa12a666fca548dd0c68452f7ec85a9fbbbe03f25a9d2712614863639e43b273f3bad860d322fdf894f21f0173b06865efd5b31655bf3f2c272ff5c74d1c08a2ae33da090fd4a5b41deeee0c117f88b19e2a0f68ce265280d786c3dd60988939ef254c136fdd0acfd81221019ed652865aed12ec58b4f1d536767846897401a5077282b3cfe46a90f7b3a97860f4a33d37803be13e113aa940a8f75fc9aa2ca881640750bfdf863ba6e0c1050a2268aba55463c40412cf04d9c8c78f695a5b9a818188c245743ecdaf4894d75084f861d9fd0c0f03cce3fe4198554d23d0bd8a20301949836200ff54547e9c639d9744adf85c73d951a699bd89469e1b2cb11039b73a1cfea02659363aef3592dead0013249a674b158922d9daad815f9c54baadb3f7370bd49b0ea1653ce2286f775dea8e6424aaa751eac822256f0029c8c5277b2e7913efe9dab3a86d55dc74abf1d02244a9f1175ae94ec3f30a260e124ee74923d8ce76c7091f4d538f7c7e648d7718dc4fef540ad4639235cfee5af1e8f7b4f8c4c3a2304c0878e6c763eb1559f98c42b60ea145107bff6765e8d1e7d36a08bfaf9b127f42e9cbd89086b28ae487145763d811f9f4af52f53a42d8532d38110da8a2feba58c0f86792e347b9a18b1a0260f671d881738c248d9aa6f04b379bdbfbf21db6768fe9f1e28613c7b3c247a2a21b15e9ec5e468f38727da869e4119a09b383f26f5ea291b9b761039b42134089f823bf2af9b3842bb3fca40bfec0eb0b9d42ae7fd2d0b12221cff341db77eb77c6178a5674e7e65130e5643530f71089bcd1903812bd02e014705b3a54217628513c48ce48f6daf205c801e0b1b68ed3bbdf24139fc4517132739073e8aea396fb7a9a28f5a15354b782f200ab25ce92a03a46b41584dd2513db1c3f174c5006c32b11f47ae8348f8fc2dc06f35335468d0ea4a4360e8e9c1e01768a1e1ba020bf9191f79fc0fc8ce7a91e817cca09abe646ce672bc1b1ce62d70fe2a49ba8bf74936bb7e189bb628786fa8eb0c5775bc8b328c95f9fc708e8ffaad1d2d2f68c74450f1b721b425ebee75813c71808169f69b708943d6836594493cfdbe2e61fdee546fb27b7ddfc0317f9541f7e0502787ea11d98cfcb4fc33ad5637487df534e0a6406e12dc9473c7a974750ce329e6977c289b6f0c29e453701a496e4b4f4a8d124ba601a87cb59f35ca00c1a06d0e58bcbb6a3b7d6315ca4396580ab39358862a1b1392801b24f4a269881354d3cfa5ca1c859050768a7843de262d9b0174a6e6e44e344591ec54c9f5f4edb3029b10048c9991c72d1ab922a997ed475271e089e493f6de71b59792ef38e65ddb82ec4c422d557da81a40a7a99107e0fc09846998a5d09b630a25db6758af5eaad258103b5838a848da90cfbb081427d59901bf089b7b3926b3f6fe291a6e0fef26fdaa787e0c40cbaef56272ad99b298a7c635b5164ddc0c744a3a2741d004c3fdce2ec4e8a3dc9cb6695a83f067690cf0c7a3556b9cfc3cffdacd52a24fdac1898022f03dc0683a100687aa43a3155a3bbcc4ac160623c28aeebf6d05da7ce6e8324a9ec16a0f84335a9fee888db4659ce2846ee3bee3569c7807a20382abfd43081c793d71e2741b23647b72074141488c85323600041fb99281c2b92ccaf8a6005fbb0b99c48379adf2141edcc7232da798dc6bd2b90f0d9cdc9b9d67a00dfdb65000fff46226eb1cf1b722fede0ecfc7a4243cf02a53564a7daf789554ea0939d0b3b79a4be8739a6ab5bba57d5d23f40ee8f32ead19f36ab02cd15ada5ef98edde1f7091af7e8c8efcde041eded232cf5487be8051523325a279ab3d49ccfca6241610a7549353f7287174831b784fc480e9843e00269709571168f6f22e806aed18a472c4da1a86cb4f9cf9ab3169bc45f45d28644f41aef93033949298cbc7bc93ea9e54903a1647b87f2d09457e805b3d44ff6dca3598fa37e9fcc849d2fbca71fb74961047b396eb76b76c5735222607c6cd1a665a1403cb48c170b51ad2784722f486be0639e1126b65d0856e301f9699c8804065f9a17ba356088234d44867dc2bc57277787e8c479ba9fe5d53b6616da0e6748b386fdd91c21c002b1975ed639d245b520cb02478c11785bada4a5a03d8c7b29e77c194aa1e4decd83502c2b1aa2545ec11a93e1f037307b3f4134e0563bac8bf920f6dfd78d922ec45244d40785df636926571f66d11d9e1521a07e42cf869a5607ecda3ee2cd25d93b36fea7be6eec0018448fa02010d69da2473414565a6b3241235a1de517ce7e558129dc70462eada605677ac805658b5d4e4e9511831c7e1bdcd0cabfd9630341865f5cf11442bb21a64873394c08b38bb4cb3ccedcdb769e90e616cbd6eeba0516e741ef793b4bd2f6a7156a1dfb1a9d8ef2102e79f387ee585203fe1cae0ef509843eaad1ef0a3725f0d709fa5852b63dfc7393523a3100cb7e28184b3549dcfc6381ac7c164b9cfe8769ccc1b12ce4ba4001d9cef8ebf0c846943361463c7902bc25141bea8962b1d26387665f667703477892b92cd05df0e309be1e39a6998a4cd07f37184d358573d3763c10d05d6524081a02ace79a13663bfe05790c47d3605d13c426654fc9347bc433dfbc4f78bccfbd6461bc10b2428fd3a4784858602a8482abd323be12be47caee32763177a2afb460e748a2b3a07679b0d012bf42b8336e938b107c8698534d4277c16e4049fb9a6b3e56469895b5435deefe31d1831229d269ac797d75f8fea055457e299a47084985067b082a5144ceaf77ff6f486aec8f52349591807be1da5b4e2146fc8949bacf75ac87b0777c22f843fb1a9fc1c9f98769dab322dea20178c275a58d888582f93cd1373239aeb031b842a00049d3aef136a61cccb1092b86755674fcb716f8df0bbdf2d8bebccc2a2c5bfefbd58978276db0d5bb96177ffd6a75004d32dcd7300b01f147d75a5eb786cfdbb72d820ec9c29c9af3c2485ca383b647da81adbe4520e8b7bd51e133e2e91f22c1a61f8ff2b93dd7069702d7da8690f9ffa5fa30127d46fd92c2628bfe117b22f5306d8e07110729ea903bc7f080b23c41e11d11263532c631d064e232a839b69147028b06ac6c93950811096a28140299387c959709d17d3fcd9c0034df843d84199852f85a11336dc4541a211ac3318fefcf36db25eb9fb026dbbb95a4226bfd6238f6f04ded36e4d8effaf7dcfe789a3e04bab06f408dc4d9f6d52eae4de3b56c0fdb2f457a36a5e55db5e6e18d9498fd1589addbf75d98e219e691151e881ab29a483b721df0bed54e4e3c5113942e3eba16d9d8d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
