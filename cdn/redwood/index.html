<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4c19408acc79124c24ad9692591370d652cff752bc9408981a520c503ea49f9b4a3dfd7bde334b58d19c6d2cdd0ba83028202bb998fc26a1f4f8df90b666f99b0d630833a881faf7c5c5d49f95dfa4004af20201ed8e4991d3078d5a7ffbd4fe1c505faeeca04a7ccf86114d6e7fed5358db5b97f6594f073686d188db58d54e0a85fc37fbabd5bd31d34c120b7af79c508f549193b9469d15bee073d65b72dbd9c2c4bc9f52e25910488cdb8b1529a09a304123a9d801422cfa0d9003c0208f094f54852613528fdcfb05bb4e99f6e2cc04f77630b1eae9f566d57e2788014d1779b53ad8a3d90f9aea40ac35bf0792c64b50f19e148326a0ba4417b20b992fde82e86e1b4d7fc7491f6869363bdaac10f4186ca0c9bc8949e391c8b8891e19ba0281207f8ff5504994970a27332f77231513e0ea6555e881d8c2a5bfafe4d5361ee979679aaeeaf3428a309513f14dab9294660370b5d9ca2b407446a13549bf47bc9cdacccebe37d3a43f5a8a2690de1ebd8ea9f2ccfabada1badc66631db2322b4eaa65a00e28fdf52bce5b73449dcf3071f702abd5e898d223b5314833e5b044d590e4704687a3200f70749b0286c9c9dae8dc7deec143a799ac0fb3d45c54d00b096efbc4bc8c2b0e53ff45661e79f5c609afd23138ffbc85e4f7f141e70547069405003fc2ed8511ab4890ff48bbd4891ce90a6ec22e1803d12aeb835bbdd4c472caecd8d1d720bb0b5521bb36ecd79dba70c7a7ae30c403ec39b0ba109657dd1bd3fedea5892d025d8d8f6a0e8c7df6887371fef037c66eaecb30511b96d135921ce89341c6bcd7dd9ecccb7426a286360dd2722521a320b67c04ca67dd40a758b58ad01338b00b904be943dc7156d717674f44de208b021fb256fcb47959473c61bac0434128c2908a1dcb43242a5410d7a39168ddbfaf620279681cb5582936349842f69297f5f80a08fd5ffc77a32d0dda4e343e95968fea98a04eda52c6b1a5e1b36eff1363576d200871ed8e09c7ab1b77d82225ee7bac0ca532e7486b7bfc0a5d2e63bdc9040ba0f387677da1d9b4bc276ddf87ec3d98d7085727226a8d906e846acdca6b0e597039651985149daacb05e3da8ddfaf34b6bdca8e747240592d4efce23f400c5b48a9961553a9a48105c6357c08d829ff2c75e7c81ad3343acca77921ab0abe29cc0eb2ee835f9e20ddba494b6873aeea2935c9836ed087b74abe5f39d6701564c6bb28635a9de8e9bf6e56b4063f834d96dcd738fe2275f78d5a0f0ce3ed56055e0839604da09ab8993893bc9c470c12394de3e64aab5f2047f0b45cbd299df4b8f2f4ab3c03c2126adc2a201ea42d9ac5dddcacec61b8c20fa1c20126fffa0a377d570fd9390580f199cbd2ad4e4dd054e6e54f89aabbba749a15521f8e207f69805267f392de0da6854922d7d64a8ea5508952af91665438b27f0c29588624cb62e3936d45baac9732e070453832a8771bd65a2f092b8e65d4c3ca00edde66b160bca032ed248f18ae57eec8ad18f337bc8d483fb1dafafcb5e87cadd220ddc76699e7777e230d24107759b4389c803fccbda5bf6ed539f8f4af84661fb9ad880bc6b8ebc9c326a35f49d3532908ee25caabe06be84411905ec194f1a771529b6d054e0a2ee7cd87d6de540b43ce2317197060a7938767c05db943109b794350b5f8d7784cafa4a063f544cd444899f56b3c2311c809e839746bc0c8a94d0c28be88ee087818ce74e8a367d8e618ae19029f9baa3cd2b275d9b2af49818a68e619b98a57029e80d3a06b7e9d48584bb30477ec600ce38bca83303789979b30cf8bc67392872159fa3f4a5e44287b006e8a451025203090b1c8deb154e28930f6637c6c5f77eaf49e40a46dca54b8222638f3332fe3ee65956351541e86b48dc9fb2e1cc271dcdfa2e76650fe74bdbfe56e4a5683d604e3e833ce0df132c685a59cce7929035bd7e19c4a075a952861d59a58e855c5697510092030ca38bd8482d0c6e213f438e2fab3b32f2cef4fd794d67a8df3e03c24a24e7cd8a157998f0d7d58b70123db6723a21ead174281baa708c14474c07a9e10abe0dc7d4fd88bd7c0e03228f60047e5a0d343b8a01e5971e3b69d85faff625f08e5f4626a5841b952df2a55f0b6de079424a3635a4eb08666cc5b09ec0503846beeb698326f88a0ccde70376d30d3bba5355e7d9a7e4d9d949d952168bdf21eada9c7a20a1daa9e12fda0d8337c05a2f0546df828bf9fa3a052e722be4968cec9c2c2b1f7850410ad7739fd6fc84ed7bfb655296015563793cf8e257a844ec9c3c8bc9729f1ae4c546648ff000ef7c997ea1c69816f875402ff7784025065bc68177db6156ba43da202e8571de42006c0d818c7d6d9651f19e9f58bc2f394aa21193ea098ef1082a0c00f293373da8083c290db8a423db67819ca6795b008e5912b0da3f9d5519fdb20bd52f554fe3aab7db913b45abed60ddf906010ca0e892d09d31a0807dd61bf8af7c88bbcb6ed4dc97146ad8174cf6aa786775ecb6d70809504438b317ebc56a8416e41e64f60966a4115d5666b76116a1e79a1949e740adc28c066434cc130be47bc560db35ffe16f0f48760bb714f23cd9453ed9e68f48aa552685171b75c07f263df8934cc8914b97ddc709f44d471f8949cd8d14d46bc7ee2aa9d5b8a852a0754dd8ebba81cae0909114eab7e5feca1406f21dee38071c6a78f3be9b750e75b9a2967e70e766f2c86d74ec20c91702e162639df6634af2ee7869d5fa79b08627fda689fa470f9e89a32a37bd6f4ed002dcbf0bafe439332b6136f08f1abb6a99303a985aee2dc7e124bc83e1fa7ba4a80a41dfe7456eb28ec68c21c591cce59222e99a13243017e4a30c348e63bef16049822264282e529a00d060cdb6c70f39748b2f7d69d499153e6f8b9dfb445a3384fcf029262d59adb8677ff4a79761fe13756623b56bfe25e85e878af13bf9cf97b8bdafe8e8c3045824d44ca2b6f6808c6f94c11c617d28973c7ac4440c4d26e7692e9f540b521f338d8d2e280eaf074bac0c3f00fe66b7db22c91e2e06e63393b5179c7781565c4f87209be8962e7cc2c33050636fe86eaad0e24c522568000b7e7f319afb407a28529606783102b26add1b6c3ef6a5ef9749b99f15ec03b444ee3ee8e196482a455554b6476d818a785d5b879c379060ebbb8c9e9d71cd7865d7354bc2fa341cdb96bfd79b2ef57f3aa342d54957a62e4e5b97b7d7b65ba8a0b9126f3fd63334dc5c9944a561f8b99c1668a99919c0addc6fd631ac7139ce33a6c87cda462594a46e2467c2adb65a7f69b3c81c92466b994683649b9630b272313eb145b5ba8d286e56699ece342423c14ae1e6ebe19f351162a94bcdabe25aa7fdb14b239fa48828480c8d28be7383a216e7d39a06be6142acca9920fa744823566360be97d5729fcaf0d6e847883c7062ceffb1554a7bf539478ff2332da35ff54695cc61e5a96a7ae7a1a514619a7f394d2feed11e0c11519f9cadfb37aee2ee1ff4a63e38e3d3d18223f749b6af78580890b3fe0f7dddce0595d9a46e2f8c9b0ebec683086419abe4e46f6decc1e0f6de6a8bb310e276c03dcca065ccecd046d413b2e855a9e216e77ec8bce7030e2fbb2f24c37ae21caaa6958621ecff5a04fa18bf18d39ed36f3bdf807d315fa6e74c9c53d2cc1fe4f916afe54269a41cfaf78017dd2504e713d6506177c0c291c98014aa1a4f20b562074035b4951dd4cc0892febda89002c233c5b412ed1e0c2300c3c18a2b93faef3ee8d4d7178eb0d8396a31a761e8ea8ccdd415905bafaba0c202dbe7e03a00b1062aad1ea9984718d6f343d5cd0077987682a430c990bc33abfa255fe150b38608532a31622e3a9ac61bed77b9021601b628fd4851c1c9145dd88490ad208423460e49675f03bbb15083205be94c332cf94ee634044c7dc54006a9059f26d2d336476088061fa9fc61db7a939d488f912ab5a16c74353fb5df7d28507daa41cec6f5747685b116d146d739c046676e2944524c3143f72aea76d8b97f3f067ff32814be899e2cf995f0002439d0ec4652352f539f3faefa45d487e0c3778475da63d06f29f00f925e702eb3ae3a78a01ddc8254b83201d0f7bd12efb3261438a3486d8b38d3903a5f5d7c504e7bce001d2a94631881d7efcd78c1d426ba9a344dfe7ea916a81d2e4137b9bdbfd0d956b9aab191f978996401c7de121483c5e0491d032bf8c3e9ff478956596956c3c1e39dec0b299ebf1fc9075672823bc1291f08ef4c317bb4070f3e69a00e3adfad643d001d976d3b99870c3c3ab91284c82c6958f297180dc809cdbccc9b4cd39d45e93dc5d003021eafc1ab51889d0bc62ef4c196967d3abf7f0a03b51fe325dd0d36126efbf964a1eca1e043ad67e99e14df4020b2ec3014c99e98db4821c9df626302e46a2ab5c3623bf4bfda8f571ca42347f20fd3cda272bcf0772f3d72189b26f4a589d3bfada37644af2dcf8594daeb14e6b793b511d93a8e1f6b437ce8dde850108e44cf4cc0fc0f39db932fee075b396a662efab2cbf384279a250eb1bd4f8f06c6d0757b12ec87e33b5d6da627f0eaeaa3b74e300888adb7fcc9c9357a555b51af45f1e99325bd7192762f049c5d788716bb5c1a594220a52e1fb7a4b9398faf4db2ddcdb02399c2cbde3c67b7756d583d254a7d2f07695da74fee570783df6513d61d0c864f2e408a44dfdfacf7b29e7b4c8e5049ed4c4d039721c6b294f59bda6940ab70998d1d827a09fdd28cf11a829f9e45ff862a3bc0b3f45d61ff9354ce0488d1c50ab195fbea6c3cffac94aab91b656174ef7ecf7f49bdd11cf56bfc0cfa291bb78cf8c1a1130794d798481173a13c35f8b03e00ad08d2164fc844c7ae483231c8124416162bd7b693bf520d0d6a1117375aa6f044ee457902d5d910486ea455feb11e276e11852a04d677615374809717e272261d19a6b0342492feb42e75a3e8539dac6878d6ba037661eba7524a734e0c34db421e6a550f1eb4e83592eeba4938ec6cc6fbf3825a27959ab5ad101d97f558d79732133643f5c8205eca5222465c830aded5c36f6731263949d39c1b880314457feca2356bd9259fe898055634cbaf461396f89c753960a19cb9d36721c5db419a2e83b28e3809f1e0da2e5f24a0b5f6311d99a78374ef90544479df690a5c5e76e2b757cf16d4b6a1d7846b05fdfc3be4ba991b2b37474c2091b5f61008d1a9eb8f96174baa4eb12bceb61daeed40a6c969bdec47eeb337ed88de33c673fef9863974082cecb60eb5d0f01e61d3d87bfdca7b51e1f013e89d4476d548b31fcb4678b8af6ee100690fae48eafa724d5b6b7fbad84406e0bcb0ab5838ba0a82938821b78a9ff59fb452a16879fb6345e2b588c8cef39044cf493bcdf94fb860dd46e731790b51e22d3c4368ec12dcbbb6d53354d8cc8d2be792af55e452722ecf6fd829cfbb1e0607e6453be7efc75d0451dc7c7643b92b7fa4fbd172d729e1fef059cc8b7d8310e588be26ccfdd50d99c12d7dcc65e7c54d778b2a567615e681753f9822875499ed156744c8f8357c303c09483abb09a703217643166eef6a3ae1997489d101b727e96995fb357cc48316fd028fd6be415eb1aff95c4f44ff2b2ec994ccecd06d18d680907bee8693b8a3ad0bc0644123e776867639eec35aa0743b7a819a432935c4ab2d074988c8dddf39525e6ba93e7e735529b6e352494675cd455765afc3cbe58e8b1f08c146815cc54999b336c41acdde0c2204548a7d96476c70da53e7ca5610780d7f64a7b10e48ef8fa888bbe159d8b233238a6aa0cb2ec068ff764340b580ee48c250921c4572aa84286f7d979c90914971a11d0a3ac030868f2933f3bb7068145390231264d57d53d5f0caedccc524fe9b02a8de1fefc106ef38ada62cbb589312e4c1caab0a1b149e358f654db44e6ed0a7bde61a7e0c19f0546153732a14e6e6c6b20c271937ed95c6e1f7c98f661ab3c09954a441a9eda8385c73c6d9ac2f3eccd16b2504e72a97199e586f841915c7e419808a00ccc9861489b2f73868b4ec8bf1090b48581cb10f941e46a552378263c784945faaad31e481a5041b020879e3f9ba8839282a7439f97e9a52063f04a22b708ff474d50b671505daf9d621a4cba634e4f5290f49cb5d0368387b2a9ec939ca4509fb82b50df561e6027d091f6c83264972dc4ece0dc815367428af64513381510939061688d73d90707b3770a8f0ac2b3e85ffbd7ade0d688fbbc972e29bf8f1b7bef9f6b10a200359f5cf7825ceb32bfd91c724346653e86b9a789f67065dbdb68904f555109ed2dbb505f41731208ce5ac6e968ec52611232bb2b479707e50cbf61a5626d4008c65f8e6326669c3827333446145222050a5a48cb10b115ef02b607b23992fd29d9ed7f8b87e70d5b82fe62a48552871a736c695a86dc85e465001f1165ecaa145b9561d657f7709e4018ed500d0c32f81df90491dcbe82689f9b90a13f31752342db6d4fbe8ace91c35ee2c3690eadeac10bbe1bc397374bc2a2a4c26354cbfd80011cf731ddbc566105e399d39e36707f9abbb5bbf1856c3046e48de1eb235b2c9f6fbee928cf2afa806db43652cf710784df040c09c85507f98e5e8409f1aa7e3eb43465453fb99d36373d10a0462089273350102b1d0cb33cf06ecbaf3d1d7f9f8bea25c4a5598af8b581867b215bd1a24c1dab00d1a85940f9368be2d8c64a22200cdf0090bdb3b767987ee83826a18f376103baca84650e2a2dd733cafde7d1cb4c52718f28ecfd4b3b04092d163a6d01e18370994a5d359954bbc99cbdb6757df6b9d32e5689fafd53eb94d45dd72dbf93f3261a8d0c2d38982007bdff98c6912fe6b31e9bb4d18f9a8c34cbcb3e8373b72574eccb0f41211c95031e007579b8fd3bd1c9336c133a08f10fb08928fa93dd039da4f346287f020d34903511648c3323d748a5695efd8fc3dce397a107861024d74cdd66611d9ff9b3dee5b7c29dca5d2646c2fc7d1073fbd56e40fe16170bc354dcc800acda49b8c36bbb1b93485721f148d2b60a6a6857204ae696546d484a581e9e2e3dc72803f14ed457ae82b946ff71c32c12f09ac28d20e1fa55a093c3068331ad29c6b541ab4356a8e8272be7a29ad9d6354b1898d760b623f05fdd8d4497f0c3a12e2e1f39ba421d2106b8e4568405906e930947871ef9e27842caedd453e6501abc3f969efc4d94ddcadfe782f8f9144c7ec64ea6e4823d36cf767fcf1352079020c582888b2f09557843e942b9afd4d8142fb4a75f3fd68255034b2fb1669ecc8575103540b9485bfcaa264fd0d77eb82d591fae0c1e7fb9a1b29f80c1f44d3c16ef368eb8d6a3b5b9a8ad44039c8894aca6ed39fdb3b56c71cf8d324f3dd2582fd146e6424b8c07908551e4353a2e2836e93f758031ca413510a4fd3128ce356b0e665a2f44cc276aaa7a2f9f1ecb47abf94dc46d7850d34dbb450861cbc867a931ae9f69cb2f51645c8ec9c81110f8aaf4b52db1787d16c149643456f82b30367af3b4a6650b6054b24f8a9107ea472a3af767ca6f4581df1000cb272cbcea016d0d2b8cf4c37069e57f28b4caa371b8ef418eb49449cfab1f4c7993b00e206477363dc6353ef34f2e78403cbf697924c2ba2996757b3ad3b4206eaa49ee2d5b125b9545d7bfac525627c35b2ab85ac14379f039d543309953309c406be90ddcc347b99de174047db34b84b31b929beb45d9e7b7ec86a9bdc43317850fc22839f8aa0af9b805c9c71460337a3a4e4087d6cc68eb522416d1748dc7d03c6bb8a32838366717b4ce449b8ad4c0e22b3fecc0375779b8a1028979baa29ac2af81ec46ad2512b9222de056a044486c43ac8560c685d60998c8f6a5d22b802408325955f8f9e236f7c5e796d1a13ef8c7b6a38550550b096e015c7399697077bd75bc9479df74d539b7e4904bff91f50d3fe9975e11e10b398ef6bb7d31b8120b5272480911e9a0ffe4765fb354fc2a860e7d5c02e87477706b52796cd9261336fb5aa18209127fd96a8e6e85d4eadc85e1137b6fef1f0263dccf544825a6d788e6d91ed0bd69f9d327091021eb9d776720bc401145586e0e4551e7df7859f477cab15efc4bbbbe598a0bd030be961b31aac442ca3248c84bec716adc1a551f425b5f7ac46bee206559aade8339c3940b5721ff03374b3baf17e501eeedfd5dc4aabaf029340e24a7b24624987039a4c4fda90bcc8c4c4a4c34061b18350a9eaedba6217e5975c25a944a749ad6c2af0af4c19f538d4b8d2ba8b3ce42f00c1e9594755d48f76ff60f746d64a2f494e19f09b4ed35fc2e9ff9b274cdea4d6554dea75cb8f22082195c0a1776e65056cf4bcdf28067c14e448c78f66cf75b5ccbc349cfca5b7af2ef3adb84197b0bed9077c920bea86971bfe21c3564fb6cfe892e4b465969ea7d1cd17d553631ebf4de6b5212279a955e5353c8e75a42ae628e838c266149781d0d5084b1295785586276c558c444ced598ea229d7f38c39bbfa6f28ae95d62ea09b1c47a4ed3d3633c9ff3db4b827bd6400abcf57fe662a5291a09c54018c88c8baf338af42ba666dcec1b9c46046e8807d143525d9e8ca38cfde69e12ac2aa97ebf9adb0d9688fac1f08f36cb5f9afca22c71984d02a2ae8bc1418194b86f6e45d7d8de8570f6c84ba20f10cd1d93b2e7fe1617b4cdfb9b7ace762a96ace9e8985b175360c4c52a3ef890b3f449edc064bdd7d021020ac09763ba16ded0022ecc9901e1f0f0b553f0bb801ed82412301953cef2023a0c9cc7e0a7dc963ebdf2b7ab59b4031d81208407791da0279d91cb2147858feb77213772b709afa036717ba91e09076e143dd6ab8198886fb71c7ddfd443b9bc9af359c5cae008e6337cf3038274ca909e9d19be4f9a214ef1f046972de7acd7c4329fceb91adf02c2adf8053ca6a6571fbd6f624c1b6e7f40d4e892e01326aa09f2d4e2e112dd42933a16e699a9e50b39742b652306707a1017fe81e5f1db7773453ce8eb42e6f45e5dd37d86719c8642337f95844407a8ddbf233d15727d9919fbd4e683e5a893c69069a9a9ad5c13ea231c9eb204e386895ed85667585488253b9c6295a914b50bbfb731ad861b1363f52a79e99f5151828bba390b3ad78b788d89ca672815da255cecf2e1f428407e92aae45acfcb259749af9e645f534de921933a2755cf9417a4a02ebe23ed233091c8aa693ad4370bbf73dd4614c37b8e7f96998f322d45bac332d1c26b673561936cd7e017d344a116647bc979e0134c4489da6108fcaf7cdb1adbdcd267887c049a739d1181f70dbdd79ec6209974df5e1f2f02e7ca3b5510e2f1a691a6dbaa1d6aa08a3c777544186e32a24e5c22478367fdc5328e956f4ee34e5073e5e77497347368b15ac85d82d8987c3ac05b59753e542e8efda9169306ab215e7af21c935657a0d21d6adb4965edb9c157d9bed51f0db043422e4046be48bc0fe3fdab03873be5a2cae5aeb39182a76c5d382347f7398dc13c694f21df3496cc2c7913cc1d6834ad78ce9f4f8d99312c612bf18be4edbd85f4b82e50cf8004de9e720ffe8b0bdc4d604319cc8bed512b2ec990eb22ffa4ebf2ef5a531af7250c343ca0ef639c6de1852779eeac9c43690b9abd63432b5c43396656698e18ed7ebea3690e483fdb94eacb1c0bef180be0d770a4ec311916e2538e0edec2270ed15d710fba612cfe36117c899b107830005e93a527ef9b92476a2d55fdfbd718d698253df2db41fb948f6c9b696ccd8040104010ba911b57f7cd12abcaf6f76a8b3235577bd9a0586983734a0f4f8548fc12f39b08e8187c119331d1f839cc424a3d9162d930e935aae187446e7054b8a9387956b6e989e7fa05d716e113462d49fac12376911c275d7a32d8f01cbdf211fece6e6fe0ba8dbee02e01f88807769969fab30611c32a4b58a4ffcf53cebf1b998533e488eb572da28c890efdde237e2078fe5e2f9cc252b47cf6fc5404870afa2fc8e55a5b2c8ee5138d1aed4e737981a83d7b2b89d70e431c352961162eff31df3ab750a4496115e9a5d5de113d4ac07b87875e16154c80809414bb67d7eeb3c0cf1f5f092093bf58e7d7b4a93d747f262e5b60b60800c36fbe6dee21b0761bced5f7e3b89390799ca53bd8a541da4e3290443d17e7825bfbbf5d482c7e1ef494137d10efc809967168ceef76bc31e9c6db649a219dd88f31d00c44c7bf200fc7a26773a0abe8ad09b063b2e593a253099d0499c1039e319f2fc6abe3b058373cb698d34f66ac8dba817b0fe520d4a922078e11da43d237de342ff9e6595d7f4a89b3357435c4e02f7aef4cce8fc430ab740d368b46bc66a661b8fe5d2a908de80ddea873909f99986aaf7a9f0c44f043dbb706de0abfcb5c5361d9fbade62fd755627d9040f9eab58b5f3e2fdd95f08071002093240b8f5c53bd4c06a18f50110cf0cb0b0bf445211f96d4e4c360b2caecd7fc99493407937b9406f363d2440c001bcfc95180b0a3f9921f75eb211db1958a31593e3d7bb269b45903e23d429dc317d3aefba82b4ed048fb35233213ff9b87806bbd506600f1d38e6b5909d7f00321614d7130ea06dc9501db464f220867803a452842e1c5da08ad44b3cba2c2d0487044b524b007963bba41cbd296b000d26b4b2a7380311c975d4fe2bb744245f587524ee28aa0fe95d885eca80f2af3561e553d3291c6e1f29eaf36ede95aae7649b7c5feb4aee5fa8aac2568e58ee73952d601ded5129f88098be6ea919d09a48972cf6cb11fa09e51103c869dcf857491e252fe0b82b2fcfd2f88d568a4af4a1557395b2ca96157f5717a33518744870c92593ead42d5529358541d802fa16b56436e7cf86092883b49da6a1568174cc9d179f9742835ac0008c94e12f07ca2a040ee35455a83015b089e53b6b9b0195eca1725eaf80732b19aa28406d975d8d15a20f4f53d8d82c4b91f59e31c55d647bdaa5a8b9c0b42e97d84365e057e4043c2cc4a3e27195c1499391323bb5261076d790fb3485004eec5815a71213fe117b3ef752061b021fc278fc936f6d481ce54bf4e366d71d2a20bfd9e14fbff4bc0f052f6eb381436c0c590ed32bf88c5d83b8d0ac5ef9addd82b29b5d29436e39e007b1e75fba41df2cfc5f18f542514dc8440bb4b42481f8489ceca17f88aaca6020599bef6f5b2c9b273824ebdd0e03f7b948c8f17203f5459026593b867827540700e6d863a69c86462fefe92abcca3163a59b9b0e51f333e621473f655305ad02b9a089fa37be7d0d3c9e7903d3de85c0004cb7b8ac0ec0a3a57b077214a2d9e5e5d060c7116cc4c06611b24c802acdfe495947b30bddcfd829652f077d294be8ee1d89afc538434307338fe2f877925e70f6cd2a8d94c26e7cbe73aa72d3d267e665cf6ca525e5faa0d3e54bcc0d737f63b025882aa412328c98b06673af4474991a7f8d984564ec85ff2c957f82a81932b44e2d946223c3145620d15d3aee83a52718e24fa529cdfffffd9b6b17cddbc0bcc232d576e2439ca60c6d58de0f7230d32e2b453b76d2ccdd91bfc929bb5e67d2df5dba97af2c5e8f729baba99b74dcb0dcbe813410ec1f43705515a714fb18a81f6ce7292921866d85a24fb24e47d2adbe0c6b240efb0c937fad01063ec2e4b9d948a5d45e937ad393cb9771d5b49ae6af0c7def1b0dab843b6e317c87550cabfe6591a38b5a69a6c1586942a16f00cfd6c84c5aa7daaaf5260563e4696263a49daedd954b286ce6b4ad5d5d1abf1cfa107cf1dca3d74dd6a0ff2a11a6eabca1af0ce3c360a3a334cd8662b2587863ad074efa5c943501c2bb8979edd2e4d89e0e0b514693bd88dc55bc28446b6fc3e3fc467b0e38fdbc91b72b6a9be765076a6c1b112533a060af8b0109397eac52c94bb33f3e62f8efd97a0fcb82d7008ba7f45ee9fa0188a879548b83024936a5528f9f8337d1662c15cf8d2d4456ddc331207c56fca4f7c048e0ae0bb73843986a39a522d0568b3af05b1aaad0e952fc37bb923edaaf0e779279a4b29eb30f01a5095948bd6ef0c979a61a28c014ffa64f539c188d9a4d091cd7e9cbcf844a55a734e757ae10654e91acee1878bc04c299f87e6f6294767e75926f1982584035deda321b3c14a2cbe132c0ccddf6d5e5bbf9ed3593c4b57567e90f6eb4faef313a9ed089b6d5ece35464ca11a0382be727e4cd212bfef076f1fc780962a281c615fe5725de0a25f339886420f996be9036aca9af7e0fad60ca1557f7b86fd36b6ff485961703ebf740e9d7869ebdd18e0f7137d0b7990aa532d156acdc72a650a7d3581c67a14945d7913cfc2200f58cd2a919c4a02c1ff77131d308cb0604ef80a4251a845ff9e46d67a09ada81c74461f7d4c6315ab0a70feabc56663658182d7ea5808661995d461fe9874bfab3a9214182cb88b094670efe7226d4c3b68b881e3a0df89194eeaf65537342d99100c162e64acd68a6c7f9f046bd731777959527aeb7e90dca1f5df0c49640ab74b9c638e33fd051a0ec47451f0465d122a660ab098f55f4ab78798ed39a7203409e1f022307d4f1ead0d1aaed82beddadb174c8807c601f2707cdf9bc978c8266bc47a8288d8356512985142a3948b1da6e447278e693ed6df670ad2a64c305de3212ebd25682aeb8ebdcabd052926f882bc71f67ca499683d820e410413bc4af58b354548b5cf597e82619aaab5e94265ee71d531df0602117946037dc375128fbe5b9cb42dffbd70f79e4bcf3163f0b72733fb576b19210880f3338114d3898bf0452922fec52d6a4439930671b77366b6cf11ee776f0932cfa10d5229dc73a9ec824f48a1988d2f867a631aca3953ccac93724e78519e372bfa1d47dea2187dd40ad996ca671198edf1ae4576838686c8d30dabe77d7db19a5a1694010c805a9c23436b374972b9e219716b6b6621b13837fd50028d9629c088554b750a8a21eda00bde78ff5d2063f4ce471585e95f72be742103ecee0c3efb2ae99408ee9cb54b018bd4ab375ceef053b1e78d88b6149dc730bb94b683bbc9b7ede49998d4d603b86c108a7d10d4959970b2b22853787344120f7fb702ac6cd1dc19b337ad0bfaba22b436ee7e653647aa6378dda20f6b28d3ec14596ddbcf23d0a68aa727aabd565f58b57512e47f80fe58e0124a4a21e600e4520abb8ff91cba47d87eae07525e56579af1b34e51ef9929effacdce2cf32cd58c876deb2b2c0a3c486f378443f9c49ea13813001adf90997fb4e458054454c35261caa8754aeed3d512498ae608a0404768f2ceba8a6929723dc41a0a7c47bfd6965502e6157c33801fc65a44951fe0f708c4d922212b17427dc6f072d9d7b0400e84af28da9d16cbc4ebbade0bb6c0d37c976a83989a047b804fc0bb9b63a66db0700cbea263a06e764df28ef1d76d8d9f027d482f81864c9300903cdbab5643b16919e7a4c4f3ef8ec6ffe8e3a02bc9ed076323b1e29389de98eed46439591e3581663cdd49a81c8be188e82192e03fb7ad0df37aedc033d1e576c4f8811f98522640d88c2427f949608f4f1dce301bdbfae5d7aced4a2d726c57786acc25ecf2f9bd9fb14d5497201f29c37bad7088dddb48140647c2591b2a8ae57dc925b5affd392b75c33e9f125098ca9ac5f1e6213c7d5854714acc3654e5fd34e1afaaf7f558d79cd9ec6566f8d81bb4bda38836392f0ddf8f630506482d802838b0715d2ed1f5e1aeaf083b401f155a3097d131176ec754eda928610b1f64739a6931bd0c70e300958ffdc0c6a010fa222dce6254bc63480e8f52f28f84e8048fc695443c05bab069ed2c01c18e114e9be0734ccf53e06e2c769e6f9f1aa855869616c5b330db52425ee4facb0f5ccade9193b533baba4bc940d9fb9035b564190d8f03ce4e43698f35ec967af63214885953f6f6cb7fe49ada5c913cab7daa72a2b7129e13842665456022c9e0c9ad11a91d8f7ddfaaf094fe71d6d8bc7330042db461216e66e1777f897708be1163c035a3bfcc23f46d94c0e19140ca26f35356148b82c3862f3e53c945442b75052d83721f950df574d6386665a1b1ac37e68b281e9e9e6132842e8687f7353977bb95db35d726b219d7b812e52cc2450842ff24edda050519c5321a9b3a619bfdeb92ea6a47d6cdb3c4983128609d1ee4d25678a3df64612c35369a51b16b719e125da2aad22f4b6a03b6cb8f7e456d7d0765fc77864cb5e50364b00656c9ea67fef85532938ffa9171deb486db424faaa12ffe2c5d0d0c1977728b4df4f1348fb4d0d1134bf9a987f4c7c11b76d83bf6eddb6aede62036d087d99a0b9f73073de469269760b50e607562aadb50baa17ed53a98050ed8e23e6119c7896afdf8707c547f07e049599a344ec4a2eeb880b1631bca1b854bbd0e6abda2bdca247818389e5d1018fa4046908320e875f14df107030b3d1890ef1541fcc42715f40c82530219005755b60861d2dd064db11fc15b2c2ce7e8142ef236b57003a819371eaf8fe41fb5b20f25399c7a9f1da69239718e970ceca90f490e07323e33682703581e5947caf74111c25eadb1f547bad053fbe630b5bff3ff58deb4ee81a4fedf51621042c3e184277f827231c1fa949b751e50edd364122e980c7c912ecc216a61fbda0ac7f7542c05fd336990c9005358f551d845ff1bdcdc4a3306679abd81a578a6a5f7e5618ada5807bdf4918021c3bd0124a60f175b6ae947772a61939d637c44ae08db1828dda315b50d12d1cc844032400c235fe70606c4a9643b98b80583e789ca3822a70572635c6da50e05e254109a8a0a75cd9838b9913801eb7bb5b6d04a97456ce79d3a91fa4d47dd54020e1ad82baf8b1dd965b73607e4632e055995ab5000484ff5f34d13ee15517b2cb32dcb8224948cda63a3bfcb5fda2ab31fd267d7d7c609756c7d3653cf4f44a4dbedfe5aa87ff78498547bf699a0caa8fde9c0a508c65b30f68c33f770c1ca441862c3e49c5a4f981aa6e989b90b9fa3ae271ec042796223cef9bafd53378cf79e20eb2a21a40d98c2740148132e8a58566ca410813d32e47ecf05d1b36803c6eee51b79b97b73c18ca3a91bdab3ecab67e373afe159e22ceba498f878f7280260bacab0d30c4f32ce165ef45be0be2c1b0beec21def263c78b70b65a940d6bf3665a697a964eba989c4d1f7a9f77e2b71e73f118cd40ea2e92330f7f265111e3a74624617941fa2935d19a5fc3bbdc532cc0b9f92c399217c68534fa6374f797d748e71d2783a14bc9d4bc3e64066a44c6df9c9c0936cfbf93ece1bc5cc7c2a70919b0b060c709d54dc616c08f7399635d62cc655845d9ce7f5809961bc9763b7e6081c1e20c332c5adb7b23b153e2433854b039f08a1a331ec468dc96c376d45a76f1012638863c8d13aa53f4a4d71d94904534e2b70d8816400cff66a0728d934c718539530ed5784564e6e390fe009221ed1677621e22ee77d73ca37e80f91f71573198c623468b16e01716c398f53839f2f56315f421e1209d26d3d3f5b230b3afced754a83f9788df0aafec8c9a7fc06e7ac19abe0ee28dcf634d79f163bb1b834594c7fc56d5fcc136afd1e2da2e33a465079397ba103f14ac34cc298e0602181463a4b4283195bda0f2ebf0a542265c49cce90beb1a0dcbe39ad19e6d970c86be61437eeb57c8a1935feabf3232d4f10c86790871cdcf6ae7f05df4844508f65a0b4e4244781712774963e496070659d64a59e44465d5b921f4655ec6dc0e2cb837eb46435ed27b2fc9b2ff794a4878a306f0c04f202178f161c3c250d10c321b4fb48a08a24219be40415babb032079861b559e15edf4815cb0b9724477ae61c7935254bb60aa16b79043c60ada272c144699a3c983dd23515c4da24d92d2200a647d0b86696d58f6ebd904eb64c64fcf9387e4866f239778f7d68809201a8179acb5585e1e95db9e49bdc75cf0286668d391e2304ce9e527eb867d335a00eacb012a2e4b3c852023920f9d54ba07829d571d4aae1cb3dcbdaf1e3857b2ebf7e9616164c0e0fb6bded31d5cd2b86ed898f36ca0ecda0afef1a9f8cb32500a4fef118b8cbf6473dad6313d4d07e6334e10f71bd98dc5e9e8b3ab25569a0225f1c641e42f82c7475aab73e33da08ddd1a7048612d1f830896dd5d2b5283e1b10dcc9f66d0c53d620b8703dd564683616ce4466bac18e20a6720334af117d25ead69fc1ac25a27770f146930ccacfb671560037bd2c33ca62f8a921d3d01f235bb7d74b434824c45ff4ca08d9da6a9c8f8a956a26364e171c437a2e8352b0c0ae1a4a130a998660cfdebb6f4d00ba055ec18773ac1e6e199e821e7dff652f550aa6a9ed3006728cfb492782b7ad9df74033f9a3a802678ec658ccaac217d42119a4bb93f4c5dcc882122ddb571b060b1e76ef66b7b6d275b16910a85e49f18820d259053bdc9693eee771cca73c07823e7e600977f8f2bf095cc9ebb33b284a492223dfc022e75a4136272040d4621288d6648cba3a3da4eb8e71e6aa42923fcf53407d07eca8d470d7ddcb3f8ce10b20a831a3939ba5b9184c938df0a028356534ad457b3bf89df405f16ea9d58bdae6b1d486362f662074272919ee9464cb5e392ad3a6b518a31f935f59e2484745a8fecbbbf46f47941a136c16dce9c4aa042d336cb5a8ce858d6cf5a9495264b8f59615a0b00f3e627008fa00fe9b8b514ebf8ba0f2b868a45b8121cc3d314a2d6d21c3a5e12ea1ed727903970a48f62f02c182ff6774f8bf48a2169decd3e787fa2da4ed771e842f11e50e96a182fea348cc3a315421a09466266999c92149cb4400d1f1cb5a48b9aa7d361ebe2896804d76ffafb31b33840ede58ec8921badc526f8c10824991e4ee61accfc0f61eeb01ef8ed43dd6c52ba663ba2cbcc0bb74cf595ab784814ac1db87ea7f19376c02f42da52fb3ddfbab78dc3324d3a8a0c3e926772ac70ebc658738d1c6de2141c3c51a31c9289d48584bf8be33226bae20e3f50ed9e57cc07d375b4236f11bfb5cebd60e7486fcbded7c47380070056929eb54b2b2a059d0b2601eb5d7cbc6abe6b8c20a223874d2d9e60e040d42526b867e773ae587d65ced176495872f3011dd3dd17736005444a97be97369987c9d2a8bd699e08b6c1951f7f4de6df0937ddc1951508514cf637841e9a48b3c2bf8ce59c4858b557975a4659b9bdb7249cec4538d03adb1f97d857c05b6ea05a1de96a838163ff6b0ff0b784235f18c4f0a45209e6ccb29fd99a7cfafd7dac320f01f550fe41ee03744e4ca4067a2c9de635b8d9d8c4e2ad919b62aa59bc2498b73f95e61109c660b8ee7cc78b7088c168aa0db012d2ffea861a20b792f0bb58991a4cdec3e35208a7bdd5753a7dbe047dc3c34a734794ae72d53174ffcc4e8026b56908f2667f6f50b5c823cfd4615a48a43b1800cb7be6854636187251e763a02642786cc1a19b15b52540b9edcecb7f9a0039a7ba2cb270667e5b4db78bbd9c7f05962b9b3eda843fba1a5f90e8b5f54acf21b06c89e3cfe33d69222f931c802901a01d84637a54aa30e11b9484f0f4e403336ca606796930b68bb0334973d5fdb0ef9cd5201fcd9bc5103dbd3851234bfacea246afe11a32686bad128a7f22f293a08c053a27cdc6974a55b37fa483916b9485e4c56f165620ba0493a076ae450ade3370de00611cf504483f9a342fcdba55a60821f8d525f517efffc060d2c740d77c3287421972a72159405c5a364af488d3f54a4765dad1baf79799229f78a2c3e61d1b30ac94dcc30b1198fb4fa1238393ec27cb6dae1c25c9c38cd09dd54057471dbbab4e0fce72296dc95f05770278422befa222317562f1087689d7afc7a4bd3473dca4043274519d54a55717fa67f72c37125d543f4336ff37118636b7ab0b8fc26420160d25041ccb11bae13cad1f0a713d36957c4f124bc6537e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
