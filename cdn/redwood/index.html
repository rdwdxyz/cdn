<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5c32a9f97ab54bce75b67de7f01f20314ca8cae9167ff28f1658589487dca80f8c761dfe5a4670d3b232337140b8000759d7637dc5435310531180ca599ec8a3ceca89b0e0b1d293a6d1ed1c0bc7687d0451a81378856ae749fe10ce33d3b0cb7f9e5164c913f0a94aa08f966367ecf1edee1d031e624759136ba53b64506180b33b9ca83d7d020c69b029ad8812a7e5ea8145550c79af9d2bbc9ae53acf37f36f77e2ca333e8ee2cd8f26ef3e99dbc9fd2b279f7224da4c6b8f7e64203d7dc06666a88cab2023830dc192720ff225e589c0f7d93d2870cae234438077f52a8bacc214aabbba1b80ff04e1654e23b63108bdf47d3206330ef5586178e239e26f58d7dd390fecda1fadffa24444872644bd672b020a575fba90f0abb4311a642a63e6d0daea942242433df577b4ebd05485796ceb7f3bc59eef3a0803a4bb99c53dc1f5a020027b6c7d9cf6cfefd6cff817688fbebef5efd0af6e9dc8308b41c46545c83f64cfc3bef824cb4f00759e93cc101fe4241c97a427888757019668eecf569f64a71f1cfd813fb5689377d65df328e64006a72be6f148d867cefcf18ba8172a3f72bedd431d967805b6afa9334d022a945f34634558b9fc5b017cfcef1f0d240123114f0b7990a7c9499f65ae18062ed9a74fe7c854c3508452a761be6448aef6342817f35dae36b44bc894ea30c4aa096deac3654bae6443c9cf69657f584dc62f4dbcdf1251dd66ff1b73853c0fe4a391d19754c95cf59642569358c91d86526e6d42b1cb4bc6412f946807def7f0a97b08d5074eb36d5a433de32cf762e1c7c274343f4aa6df80865e882e6eea7c3d31457c1d736f67ea1dee9ef2a7d9b3070a89a8f469b2dde28f825052f30fe6e6f7e0b81f1e271fd2b3dcfd8c13451c1f6e90a979eef5f4b4e91dbacd80f3a475872940462af759549640aa6d0d4165c4880be9bbeffcecdb11730ba168d8b0d4669226338a217bfabd7eb3694bc36604748657691c79e5ceead34006257fe1e5e66355937c48c9eb8e4a1a378fee86ad445432c0892be0455aa2885e1df0cc335fb743ca9960f485638a132922ad216d1af6e6cf9c6cd9ea1504e524aff4a2bbd60a873194d20872bd34f0e5f52f996b8a26e811ce1342ae6aaa317612336bd9bfef7cae25bc9851278da47222fab12a0215d49ab88ea78496dd41e02daead6a68c0f8f2d5900ea8a284bc681c91778f3d20b928342b26f27ab6d09efae2536953e3b3f4ffbd3d0ec530a8dfc2e34dabed4f7be4c6adcc8722fbf2870940b9de693dd51bd2017654a02d99808c8371e60130935afd230be3a51951c5c155e37cb4f06b6ca8129ae6d49617c5e2a569b97836fb3892b60a5b6dcc0040e14dc84b4ebf037edd34fbedbbf4250209e85d9f6bf71071e0db2bb8ef6f1ddd057787d05d9f91493e25ab91f3abe2ce64bec41ea15e238ee4169a63ffb3a47f837140700a1265efdbb8b00f4bc80eec6ac9cb67ae56c15e072da2a13ee038aa930a6523a31bf1a481b5f1b6ea603c1f38d98de4031ef3ec8e35c469a67a80c54673d7695d34a90ccd170a6f753c84ef2f419d8da739b881c324bada5d10381d7b7cde3c20eb71fc65d457906ff9d610334189d62c6df5fa8d0a7b762ded0fd98a33e4e9247253ec99e91642076436df34fb2fff12378d5b28b8c91e5108e1edb23fe19879255699400662901c601b997b1e6f3621a17708bc94ffc32c17f9637b5b86f2ebbc60de106faf54dc56b0c658404efa4494d30e40ca07ffcaf5cac3701bdd24055b25646d05a087968eb59280935380788d99a4bf7ce5941257c2c3697df4f4aa38c2714727c11ffb4b3d84df251bae077fd939124ec1c108b23577a6eab7f60c5035de37eed9d217bbf6a0aa19d77b49199e48c05d47b2de847a23c3286d9f5726d60b9a70d00f19d0ae205784a128b353e03ed713a0c6df00a081ca36495ec9a7a66118cc6ad77ea2de074c529b049533044d60c74e3f2e0f41af911d14c0acaa7bf89063926b881ea571b9703d83a629569c7057898b7857aaf57171f44ba9210749f02849ea09ceed9bc235e8a65ed1427556a46bea69f0669cb4cbf631b12254b7b16982e20ce6515b7ade495d452f44609cea14bf7140a5b97acaee7636a1781fd0b434ca43082835191769dcb88068e078e02e940c40efa3d1b14e20f2bb2466c192188b613c503d4423d965c58cc6b0ba365266ba61c6e958d0996f6c8ebd7351c7a3cc84a0158b11148be58fe6b5321cdb7b1b1ca8e8fe4382c218f1c24d8e22a47f4a1143db764bb6a357d88521ffa576f190560f4b7c39be839ae7e5eb94f5dbf494185828dcfbb65cb899b08f6ec54fabf684a99de27b7677f741ef8b217a39483f880144ee0e7c25d0b14a9e78d8ec8a91f8a323e246eeb5315524bb4f3652127d4f1fb03e59d4799a455408239e60a2d1e525475d811b859bc968d7eff8fcaee33d86335836a1a85acf9dc529a74e2f34c59af7d63e1f38aad5b0904759e2471dbd54065bf6b54c0e720488e323adf6eb6ed9139a144f03bd3c3f17c656a1808f5a42fad0017314c37bd1fe792e00e4901e5afa341b69da9e6ec0507b71f6b7db7c3c7e8a3a4aaa9401ec95e153afbe431a053d43964c707cb4a614facb47a68de4ac2e5ab5cb8389d36f63fbf7d7f0ebd5b092f9715c6bc2bec96bbd491495eff4d752c14410970f61b536569bb8741901f243386163a690abe814e4418f541ca3cefc3437847f6dc548621e6a3a4ee6c88e0544bdb24d78ef08593c2c178d5ea0b44af43e302814ad3df41961653491b2d3563196d5d4f03aa2d0099f06d7bc0f5b7548d7227988a09b1e0e15ced8ff2d859d89f8a29219b15572bfd8b7a312f59c268be86b2c603a650697f998a0af84d797ae407d3754e3b91bf15ae8a7aa92a81596389b85e9632e441a544ece81a131920451cec846b00d920a844db3baa13efe857a574435c81caf96602a1f1e53c2282ef3e8f766b3967ca8b70dcb19c666a3c8a11402f8e9999113c17a09bf1e590b8bef9d0945e95d90e7045f3fc3b7ada5d4da6e09778267f6e2ba8e0328f8aa146979e0a187504d7793f8d458f715ed5a1a8d436a4a48ec6bea21dffca081ea1afc50fb00c46025b165cba62dda3d4a88d6a57f275aa76034002477d1be22339185a918ed0e876cf5dda8e06f4eaf169263b6151d18b25b984db9234690b9f83c7c57f1ff7a5d8a7e453201479fbfec854894e98ed6c0624cd177859b47fbf6070be8f6d660b50efd303537a0e97ce6c0541883a5e20da5b1aaf333ba7d60af6e6fdb67fc22a9e3fee12bb3102885131cec0cfd80f85589bc781db28d765ce9e1862fe43fab35ea2eec2698a98c048eacf3c67ded516808301737f45062f452b3e3e4f4dad78b07f627838d91d680d6428281b0f52f740cdd15f98e96cc644d5dbabf89b0cd10bb3c0f1f797b9a384cc620683f024d834c62c90843b7857d803bfebfc89b2230151aa7294cef6c92798a82327b7901c4348251bb349f39711a75c90f267ce55abcf5b0928375eebf6c570e0e0cf72996f5eb2ca24fa904c3b331664a827331d76637519f8b4a5fbfe32b3ac4da2df056dc1cf4a2e7809b7c2f64d7fe4083ff1f45a346fecc8c6c08953ed09b12e1463ddf1027d33a770534654b63b50881e1eaa1cc1aae1f8a0ffe6d1e274d5630599ec2ed330ad83fbfda19f7d6f0247a67b8398ae8cda4c6dabee728677e383d897d4248ebc13eaa8bd7e7c6c245235cde6213f6c8b2b62ab7bf10d2cada16cafc64a803569851daa2afbf03df2f922eae6a51b3d60c56e6b23511e544e8f8e39a8062bea78561e050473f6f3e579afe0fc98a08ea51d9029a9d5669c9ebb07d108be2b1477d280755fe5f47a45beb0c487e172effe83d47861f781238b125cb3a4418ab8cc5d5b2534c80e43bd6ee18713cadbac0834f5e8e36e03c5654da17af5f0106dd9341f8586349f74a68d1e2774bb1738c3e40518a87370efd484537eca45eb1ff30dcd1992fe78456a3c503bd3a1ff542ddf0d25723033df608a30caec4f1b9870f9c61537a4f70e52e0258aa2bf80ed12e8f4c1e3a13d155bab7e30310af55480a30c1011a1ee7da0dba9b75f2c3e912124dce1f34f858bef94fd0677670747e8cd33094567caaf7c2ef4f4e9468e7494979fd65888d42cddbc5b447b0fd234c2c04300f0726ba934947a642d1105e69a7fddac3b32ca2afcfcbdeeffb3a52e2b7c60bfd7e078cfd62bbdc7be0fce350752534bd6737da1848bd06edf6652514de284121e38f0d96d50b68e943789dfe916937a1253ee7dda42738fe398e007cb655774500c153005d8c11a9f9ca07823b807eb156d9613e082ee1fc2c2f7dc335145e5e2f8b9ad89859a763d537897262fb8002196610c08d71654fe7cc72a6ea051a5a2b6129df494b3bbbdb29111448ff9eef4f748f553fd17971c0017497c82a7c2468975fd450aca305952e0aaa93218134b5589b99602586ff77c1b1fc08eab2133bc38dcfe75f258ba60cd709e779e3f2bd99857f48fcae49954910ac6568a8f0bf9632e87f8163c5ab2603977d4675b5a2c779e5c03dbb94d2266d52bf0034a137669cca76e9d418ddd4257948592425733fa74e9355e1627701c2f77b6e32cdf2f02d38b45bcdc67a1749c9a03b54cbae771e9038ee0f5d8b0e406d13451fd7c0cfc480b806726e8b9104c130fa2f3bf467e511a9fe4d59640f214cee2989d30820fd3bff32f355b8d5eff4eeec8af409ba8fbcd5236dbff2f9cc958ccf5b9aeba74a36ee01c1cd6c47118ddf078cac323a0b41e68b379aecc5eb23983f493dcf3d79c1aaab544ef94e8e6dbaaff32104a546624935ff6c57b0aa18f90b2f2c857789fa0be27bb13f573f399462fbb812697847340b0c5ea04d71af5400862473d5988a440830fa53324ed89677cd0927ca3bcf74c7bef9357a413cc4f3362392b8f195dfc3db8c58d46f487aae3feff0876da42d9396b1d0e03c9c38c6648b5bb6b6c62fe1f5b3ce5c5d0d327e3b3ded1657bbeca64cf558a80d598d61b2e4335e7ba32eb4771a382cca25dd096d735d99ff273231cf12afe3b5d7533f2a4a0a1ad63d22bd4be862a3d8e9a328a72c236b89a2e1f38ffdf6635494ff0cc5478002e0fa43f407cf852399afe364ec0e14a2d1a6a78148fefabb65f65056d113c40681e3291f85d24fdd473d08d53ed568822d669cef2f64f79a7c8495fe7f42b955f38f310ef4753da54e9c331f11bca197e1aeae9e00b536c03aea3bc7275f048f86db9d2c848c6caf09a69f5f4d6ce61a138b159ff3c4bf3b149e8a65b585d04f1950371815a193228ed5dd15f04a9474e38c0641157f4567711c40bb859f63c097b9f52b7d14b692ac44885056fd917f77df135ade486b8ea98568a1c60d8f65068e71e557fa3b8ca1e04adee4c7a59f398b2a5808d93fcb57580ead3a1661cbe6d2dd66825754aaabbbbc1d21460a1f0cb90814a18606869c4fbcde049b883812c7ecf05f2e9c6be6fdd63239e7113ac2b06be331dbcb87a726073ccd5bbeec9184c3e1accd089ee66628f7c00d47bd8ba395eda82ae27b11621332dfeafa771f3df38364b642b14d5152663ee0190d438745ec804a8ff8b5e8ba32a486867212e7a3c20f81663bc4510c437351611f1e2cec5304f0628b576725890986df51739218b9faa30cb1e65c7e931061993f0a2ac700ce78f4ef48061522ab705dadab5072dc2c6380b27b46e661ccb50a1495828d915412bd7971903eb8daa5b6b3cf8651664fdc1114bfa80f316a4b2460763afcaa33ef7bdde63092475e56b3ba82e856e3342e9f43917e9da8c698b1f987d44a3d1d0968eebe82c223350a6a78108ee25c0e83127175ac5cecb8e3486083b1fcb93f673a687cdd4252cc359b6b2a152ac0c09bb74c4682a8d3c03ac459b1eaddcb4943b0907a4d46c3a9f7c354933a1631e6db0fa7134a6da1de58cf7d6e0cf94651295dc1ef2fb1055395bc2ed81fa79a2922b3e229fcc9f9acdaca06f2bc7c698f7a6138dea7e41520edee7e856c176a58409cc4514aebbbfd748bee06f096e940a58a633172d7662df682105c43bdec2aa7801356b56baaf2c0083e7b27c3a7174dc184782ceee8e95b0c931487e3ad2718f88fba79e2cc1190ce49d6cba5fc969d2608b776d4225a818b5471afed4383dba27e3cddfd3f060c54df83832faac0937228b8017e216ad3108fd427ca5f75a5fda51642889c34f6872a1017be1ba050996aa5bb535ed861ec91f50343c2e150867357fd16273de9c2326f3489fdfe2331ed2861a2148d3c123aabb5bc402b296a9296afd74d8432d90f30e81e0eb9f504ebf1d224599169b1765a43ba66eafa95176ca523dc1d145f47d5dcc737ff17c3cca795be135758ce4183ad3d780e2ef9ac2ee143f52bcf46f79800c31f126bdcdd1954ec2a77b8c52e06170c6039648a2df256a874a30b600fa6fcf4fc94a9672c2d00e0876317f7562b45bff1e4a49d7c727cc914c69f06e2b73abe93ee7c6f83a0eec7bfef9722229b1ae37c54a337785077148aa0d45b49516fe8a8e5d4bf75fa5508428fb109a4bc9dc6ea73d1760517354e7fef4251f40e601cb861e20fa8e4aea0be8f96c0134daa674044b8153a5bc93d4c093572d42c5d97a67ab8b3a0eab82ce36a62e92a524c10a726d79e0f37b9b7f286278e148f9dae1c60b5735fc1a03d1dd6887f0ef9bc3d99e17cc7aac037beaca3372cb1f91544a62e18865e0c4af1282daaf812b8c989bb48528715a408d49f76cb7db358643398f1667d2853ef0caf6877507f0f7ae95fff4056346ba8ae6616929031ccc7bafe7f2758256170c169a27e037df811ed81d5c99007faf0f6aac0eaf4a07d7e2bab1bdaa05a691d032bbb70aac8f108ef56763f60d9b5a84185714dc06524aac02b17d70239d1403371f85aeab74b186c8d4fac39405e7e200a0bae8bf006036eff2ace4ac01102c8359ea6844cf0fea33596c763e3de13a7b10377d81353969476cc90594b79bb0b72929665442b2aa9421ec6c1b5c687e42688a0e26ab149d1901d0bf6162a0ece65bd6623dadb35c5862ac50e0ebcc2ced458380d17877b0eef68482943dfe09bb5ecb1badc338443d0d8513ef22f0e86dc3ef2471f8bf7576b142eb568de7019043afde305c7d2659152e1d2a0605ea9bc87fe8ef37d81b197ca77f2820d396e39eba85cd24d8835d803ceb7da3b06886fecb3da63bcbbf8c257130f93afc43165f55ad4915bcbfce628bcf83b69bdc72b9fd8e4e980d7716907b4db3150bdbeb6eb7db96c92d03a29f7f365ae68fd61372b2f2fb2fc1a3ed26768baa57bf7b60799de0a5915d027601340b0314d8fe84148d811b62e44068909627be57bb9de8c2958da140526cac10086b661fe0031d7fa896c80351fee6de8788aab44c85ad512a3ea80d0a68bea81f9f932b9728004db168edfd5701a5f273b777f7df3c3b27cea6530dc4b2c0c5b6eb1f5dd48f8f906fcedcb7e7a58081c14b0fd392030d7b78ffc8992a8a253e9befd3944ccf87ac5a64b80e60613268ffbafccab6485387912c10da72202bef93214a6c70d245e7276268531467fe94c710254329aad4af0bbc2543123648538cc9d3bbcfefbe32a36c6a62b96dbac6172f65e9a66fa5baac0e45f896eeaf97d7ce6a00c21f19eb6ff45939e1b1d22eb792db435094ef8a639bd512ad6ff067378d405a47f5d9257b2de6c7c1ba729e406ad58a47d6a7fa05ab30ea2dbb13d07509be53eec5e64b26d224c90581e15d50dbd0c2a5436ac7d37e936d4e1c12f7f798504c73f51a5724c09c9824894a0058167f9e3900f5066c1d15ebbbabf475363e88b4b2f7dfa57c5cd83e9e1cabdcd0eecec7d245792e0f4de0a513c96a1c96a8b8cfd0653a202a64b0e8d5e1a510d6a5cd826ffcad30997e5060a5f941c4b78a6551dedfdeca6df9cb1a01e4cd4950ce5a7361adcb31af386bd70934a781cc56de0d2e9ac351c44646114b115b99e6421a3a33638c6b76bf92ec8b11c83290f0112e0a22cd8dda296c218a60be0c09fa9d12744e878212973f4b91ab61895302f5917c3642079e72bfea953a74dfeab16de56915e0235f35766c369bb1449954d9db13d20fbdd5cdb4fa541f635b854547f4817591b1841df04892e840a7094c89b37d6c594d9f1d15664d44a8ad8d835bf38db917a188482a231368c1cd6a66c2076573ed14d70210c06181fdcc389761d93d55b634fc3dcd763da456b10bfdcb6967459ddbadfdacb131f76f7aee8185d203b1a2432b3409f582236b749faf10da6ffa7222ae00339a97e1f75e99c3ac9cf69eae91b6302c00a0b66199ea3b21b92d599da2e3b6fed15b096d98b6997a86c93ba3018bfdc122f73aa94b4ccce83f5d6980820fada31674ef819ade42fd4f9a62ab912a18c398a4a6eedce7d8c411179d74228412e5ea6eea7262cd43a2034cfcbce13968e5f8c3d766a6481482ad484e50533d91739604a5c65f0b3d2067dce37b9d135c8148b945cf7031b2dea0dc6ec365094b864354bf6cfe738d7ad5add14a1327540db3c1bf943bbaabb3dec07b2ddf330a912d8978a3125906c204d8032ca81acaeda197733c97ae0c1bc3c6c13a7d3f2038a95ec5f9b0e383281e8672c1f985412288b0bfd69a0ec7f682b2d445ffc7f7461d98e5bf3216a2f36ad92cc89a36e598ca547babcb8a1d8cffb99ccbc6ab81b402656c77e17862ba2ba992df9c310e0cfdb990517636b714a0e5ab0dab2d874d3af481fc39e9fd7c87f661ac2c66aeb6e5a2d177f23a3d644be54e558f5d411aae6cdf327fb2e7794d12aaec4dd0642bc0a3fd7df6aa06df7faa33dd243f2e738e72f67b62c323ff10d3f40678d4155f6cc03ab1e3a04cc69707192655a8a9f98a1aa19493bdcea0b7dabefe6f1b528d0452fda9741321b6b10e6534afd740e4eed657b4b8adc0ff365a14307a3fc1825685f63c7de14953c72705db690b07cc3c663e113ed9a3314aeb2d6f85b06c3c87f918cbe95c8580dcd00247d6f888956904cdb29064bb9b4aac65df4db002eeecf839af54675420eb80863b3d63e6b45586a7d048ec719616c0b94ffa0c676ba9bf8f09df23e88255e936e7537cec0db0b486e181b2de0837c10061a1cd4fd4d6111def375475a8da75d2c0628d94e071af84cf0d75c6eaad71a3aa8d0967460e9338581bad80a7ba2200bfea5cf74414b51dfdca323e07006ee3b3997a5c8e7c7be4b41b1f9f3d16c53b5663dc7cdd3da4fac972b67902ecfd869816056608f8cdc45d8b69af39a3105579fde8e098dc69f1d359cf0f4f516644087d675a257afada26a7065d53d69c63ea8060d8a3ee2a61d79364ce40e18cfa5e6fee0995c45f8b123a750a7cc805aae70fde54289c17eec2f68b49fc3f8e8b48eb81c7bd14f73a895a4eec19de9993681d005ca6fcdf6d54f3eda78da76e17720d22209d8eeadda95b132602e2c3e99c5839dadd81a4e8b5c76bd7db02f905d8464f597b1a2bf01a003833ea7e923aecc26be132e5d574e565d78702ebab183e5b800962fe04884e449c035edcc16556c34d5fbeb901bea986893553dcf455c2dab87f6a978446d258db4ab1133b53d0adc267f38450e34c12e13f487378e7c7040b69a78c9521ed3cca01481cde6450bbc9670c45b7a945c05db6532ce636115e10c0114cc0a0ee4b8df40501edf1321c9d99a6255080abd95070b75b66e11f1969be987f4c70ff4dac64a8f8073cf90e0bed12456d4b72e8e32a5bfaf7af756793ff8cc7cf281f49e5d707f71ef3c74f0400793afd5910fd7b0bb42451f58bca3cef2a5f375558a815cfc7b3260ede0d57d667ba5bdd28e1960c66c303286dc687e857d818ae7a830f2c3567ac7cae1fc92ef7c6798ac4f592a31463640da4ce14ec47f9b284f0b0157024c0cde11f21f2fcf78acb33b81dfc52cc553c1d57ac41ad241ddb79b590c2f2a14b4d83d1a81e0ae643c9aa18a3da9fdafa5c12b3a816ccef1acbba90d8b86b2551eda77adb0dae2bfdc324e4fba6b7f4d0697bee1e1e1f45de318243a73deb43fd62644eca0cd1f6f374c4cf8db816e6f588bfb1ea4b580e1fa2003dcfcdd562e3998f3a0191fadb996548858760390c73e62552eaddc5d92fc31818f0c5588a30315d497a4925460a682c5593659762918e6558cf612d2e4bb04b4bf517c91253f12f072e029ae4fc6a2dfe1c878c7fe49e28ae2e2284186e04a82a66c2f8db554872be9d300ae841d7746979c7620ece1ead1f686df5bea436eea73df012361c3c45e48a11f8e54050637805b0118f601357720eec7fc1198ff71d37e750c52bb55d061667629d356170cd2ae42bb66aae9b2067e40cc5d5c904d222da39b3800ef82c2cc014801077fb035f30914ca8fb40522e29a461933eac7371abed6dc996e990eafb06c456ee220a82d3cf02cec9db867ac5049031ac89def54ee9723d6a87c7e27cac038f8714864611989f0d7f7e2caafe43b4d8ed646bd04eae29dbad4db7f88f0d2c2962696801e39bddab195d2f4a4575201c6ca46bca61ccb5f1b2d25d8e2525e539efd558ce65ce1430f9eead683af3249beffeb6a0d8574e6778e8236204d0459d39998db051eca983d62867cc7a472cbefd4a59973b97e7350e249065a59075350f8d1e27a8054b36813eb3b285862a46aeeb433bdb213b6891d27907b373178323563734c36abf12c76e9d0e4b6c2144ba4cf77c39de588111518e78d2e12085132f0fba73f59028daeee018d4a181cc25edd07e26425b2bc4aefcd6dc57f9a72ced8ddb2e32680130a5523d944ce53cd478ab0e707d0fbc69bceb920a44c0013985936c5c26b68f6c599a4d0e33b687ad3deb218052b2a9e225fb845992646e2abe502c1ea2838307af421a51d04e087b5a1b0e3ce9bcebce76578e460d3a82da0984eee7fe2d2f61df979467025b862bfe10add1cd62e58e8b9aae07713fded7494a96976ae83e39deda6e46ee270cf22f1267bcc258fb3429a54178e67aee013a6110c8da5d26bc0b782caf3cb2602857156168323006d298572765533cfed1ece98755f437e6d3914a3a76c6cd1198dca8928a5e1353f1ee8c768810964db5e5889795123c420e90571507330a645fcc383822eaf537e3fa217a6e8bc358c923cb315e0727c3df03128a9f301f1407038df4758420aa727dd2fb9498f52b1fee4a766f713e672996332e1963aad81a93f940a726bd1cac515d56864246405080b95d2cd54e84c05f62ff1e0748620ce260a6bf7307e36294e3b53eb6b144c2f5c0c43f23e6685f6ca9b50f025424117e557ed8009304a1246e752492f84cc339570a1a76ff43abf9c10b14465a81b6e27b7890eb38b83151a40d5c248a6db73bfcf3df6397058a210c94127ea8edaac06dc87a080f542c155af5659f26e25c0bd45189f78db9eab7ae857a0c7b7bfe88cd11c8be1a94ad4e67326b94be1a752d1958056f39c477b8be3e8d88a0125ad24d0dae69c5b6ecb9eda531e52e7f3000f6f31984bc9f40399bad12c9e921d8f604dd81c214dd849770ca9b7636978afce17b01281173d1bea407df2db6c739401efebadb22a3e705186f38fe13ad8d1f8ab4234a468e5f304fb6370f447b77b64f875442cb5e4c05cf5cfc60e4f34be1ff5cadc9ea2ca604c5137be5f2696ef12a7dc54794c03d3ae03e537e4b1ce4c5343277a74aee628ad54d550075becd97320cd3288ea90cf60bee4a7df9d0573e91d4493f41350dad77dd943610fa8331565397ca817a549e0c843dbf824f24c79d188b6b8f66f7450b8e7a6348dbb7722dbd9914e5d2c301b98919319edcedfa7174e46c6fb7f3f82f35f87c174f2a2739a9e67adfbd9d7427f337087d3b2cdd35ddacc5eb128f1f15cff3f1bed94b3a3d5f285c599811c826680e1ce1fdbad5c88b1d59f30f6f44e32c0ef1421f8aa83b09de690235403a1c84cd06b2284fca671daaa7519573e354ed382a8a14e8382752f0f73fef0d5842add87d6bf7e7cf44f9a46b89f684541d140049b55d4f4edb60fdf57f0edc9bb15e1147f8da0e8316b0aea2da8a5516a97e75e0f1594237e90a7b33bd382949bf676251bd8a68c6e7dc151b1c723ccf40ff760fc2d17ffd32c612446174abe759f4fc46cd27ec610d1c3bbc4ad9c4042d951256f71541b358d751636903e1c331882707c567181549719b88f79fddbef11767d6a6b684bf8e3b92778aecdc2cecc9d791f09fc330d0ae9ed3c2467d093544bfe583870ee5f41658e932b8828983bd8cb08f5ebc7e943cd128aeeb49acde825f9fec9be4a9452a826ea580a5c3f2ceb102c14b9d7c3cee0392acc292cae9f73e7da5afc418a9314cb693f7b3c1a795d57dc0e52f6e27ae3740bec00614d58f902613e3f5741d069119f5bacd8625493aeda7a87553ba934dcffa05084a4ccea2e4780243af99874d064012066dfadbd268ae57c1ebef1cbafd516c736ab334182fe9d5bbc6eed533c2b7fc93b5f690d6a8a09fe679eb8e3070bab17c00fac4e375dd6d95305c3f500a6ce14419cd790334a5b06e65a144282485ce7ca7c387db3bb96d0a471c6e57ac631c2a81116965c374cdb9821b4cd6dfd85f9393578acae2a06fd5e2b3300fb8b8f3e43a6d47e5cd7f2ae2c8761253195962bf3b1abaf75ba7c1ed3f0e333852bbf9e2d7cf89a0c01428f4c1d3ee463fc7e4017dae4c924170183264685da2a2d2d3c8630d8e7ed3610eaf01f92d3889c7d350a03e5d7ed35ed0584297e8e42917dd087c4768efd2664f4a20282663da9d69fe572dc7f3523f64dd6e93937cdcfedc2317fdbd739017fc2feebb76c3c64b3f4067ee0589feb3b6b39b1cc86b568bab7bb8953c3e99ce069a9deb9a5e8a3215a321cfefd730168b2814f1e3285d4e278ca6e82eb7dde670fbe263d0d822c2034f3f91eccf2bed1f866fbcf21b6b60bb87f9e28eb2bbf2f51dae6196b8164615cc183ed806385a01cbd8e8cac516052960dd0c49f37cf0eab557b7025c1f41913714bf2906a264be1743e3cf1ec5572984e211f7abb3adfb70a60e365c391c57c849f98e5760084785fb73b2e7059e490fff7806142a603ca3271cc9734a3ef584025b2fbeb2386d3b736669300082e51b84c36a8203aac0f06f0468f6067c594554dcf389cc523ba394851d42fb63b6686a7c760320d4450efb9c2fc57bd22d9186d7faf7bcb7e9717592f831cfa509b7592c1b5e3ba7a49b5a2f982deeebc22cd7c9ec33ceab80d60dacfe142ddab891b011b70a677e234e90c11a21e52c751388645e7e8b5e9b89fa837759b7d6694250a44759146cbd6c0709749912ede69dea81e621508616e0010a01daf09ab18268863572740aa15fdcbdad678ea0482be0164072596ee14684147a5cab977c7bf5b0f2c15264c648675e4e1be8759bab128be407f486c611cd5af524b444dfa6f029bddec5fe0fb2a95b5bcb7848fe3f44bba1b95b9a76fc91a141ac927d67d07a0afec77df6c89e706dc3e7147df4b7417c4c0d0cd6f3213548b8cad07b54ccb6433bc149cb92636aa8e3ccae353092728954f91b6f2cfe5f237b7bc9922f6d757fa2f9e894d13d98596907b336b6c7a56f17b3e7a62f6a051e49343ab07d929e6ec5459c9f8adb351064428669d9b6341248302932b8737487a8e0fe653446b4cf2eb6d3497011dc2694b25d69208b90814b922893672cd7737ce06cf31d86aef6cf1306f6ef0dea6040279e0a2dfb0505ce88c3a9a03dd6d4bd71ba08dd3ce928fd7e745a4c6a28b003c07556de4d8e441b534e90a56e1ff34a1887e4776ea1c7506ad2e6df004e36506e76f895e2493811f7fdc8fca093253b5d6321f23dd8ee1a537ca8311c0239c985b3df20ad76f0eec87310c1156ebad66b3e01727f4d2b944200e9c9c901f846f81f50c363536f553c582f960ccee5fd3e8a21ec62f7677adf076980521547d04c4efe04bd98883861005f5fcf17b9849f990e0d5ff27b1ac02fc801c3a561edc532ccc6621a4cdbf996762953e782961034bbcb45db6332012e842bc8596867b8add679b73bd1e19d58281513fe6e31424376212d55c73bf5a1e6dcd5b9f90c74d4e2431c627a26b73c017f9b148c389fae15e6ced172a11b044f83286decb0e4cb8ea931d046d379ef9a67a45cea4f8aebfc3b32c6d19284fe886f3f6320c191ed2e53700aea844eda922c807607e324deaf1257d29cef83de1919205350ee15786bfe1f88e5e17cb51403bb79cbf6be6a97d981e27072b035ae9f43b5287d161ea3811af38fa9be0c8522c5340d57c61f2032b60bbafd62de6dce9766195c64f47bde3617d99cae16619f79475bbacdc28f0cb273b0039cbb4d9754ce275d9b05c4d1049f7f055b5193a1d55d588a23f1d69f1defa5ad248af14ce210c79f153b8f4269a948c02235e4cd5a6dca86823c6632e3a7998b71476e0909b1a911dc7fa1ca1dc4655bd6a0c25c21b52cc3b925fefe4fcc0a1f2c7e6aa9372e8f32721307d97d25094e09fdaaaf1e5a510ad6347d0b3a9481f0c3a25a8248de20f2398872824685904ad367751563d14a19a0990db07cc467835d540eb7dbfde6d1911ad18eecd172a8a55f69eb2cfe3706764869d06cdae2efc84ab510fd9ea7b7929c360615bb2b6e1f39e755e1c295ba820a4eb07c92804e958c77d39b990a125e748df59420325584f8692a47d1e629afc18cbfa3245ab8dab90b641efd29fcaadd71efc1fce0f7e67b1588988448bf5e1ead2b7e5cec8edfb2896a3e358cadace8831ffd92042b4979462aeadf2925357c772a7c22130e0a3bd56a6832d118fd22bbc33667f46c33f6a028c17d277de94b2795a3f085beea02f9f525092f7add150c89193ffc2705d27b117b6b8933c335d1bfb438d56e81f0ef1d6186db7004d1194e6ef0246bbe638ef87a3a704d5dc4a67dc7adffcea95903aaf4c81a2ea57b5d54fdb5cfa574949ce37dda9bdaef9e4f194c20b4b893fdbf83bdf72d4fefa5b4f5cced6362b42411ca6d0060f0770b9aa1d9107e3dff5f0f1db4377ef5a23e4d997e39c1aa6aca15dc3c3d0ec18cbd89b944ba87608b6cc10308bc966250b7d125c165d38527c6a86a4280f43df81ebc10a4d76014e32af207d9a636139f1bcb24f5ef100861adb522129171c42a66cbded7d704cdbfdbefa0d12677c0ae74b57eb1f5e87990e3e6f76f5632a1ab38763de57bda8d700895f31f521d7c6f1785ae2703f2b64a10387c5a2b55549de106f95c51f4b015cb827ddd5202f3e8a70786edd70d072e724fe46c800dd3fcf9a87f7f614955ed00181e14baf3bc675ef71e09d919d84af538edf2efb7b344ed6ea5d4f02dc305b3ba661961931c3ce80ccb7a46805d87e5e5aab241787ec7a709b6f77fba08408b3fd3e79c975c90d1cca7e78638ed252ecc18d3521deb09151a60ad53a4bd3148e097286edc121464541d38188b286dd2d58ad79743b03b9757c03d5069e3c5ff1e299efe107d0361de28ecb9cb9154f9883fadad455161f24cd7b9623b312a8feb9e571129d1ac60cff5ccb372affea3dc6c405b7637a30ef35ef910ffe3017831d600e59d478156756ec595d8dd01b05a5d46845fe8cbf8c1f2d7ae7109ae20878daabc4a074b4ac7587baab59b18e43b36aa2809a8d6e37fbe311a04b61ef6cd02f67fcef22d4d5114e8f9b0098d61ce93dfea34d7bc2bcc59b0b6a7f72daec7488639c4ad7354f6f14cf3638bbaae93c9446eb83db25f8c26abd2a3a3714849c9443e80b8291651c664ce8dfa19cdaf77617c03d4ad642e24df08bb4a0d69c5b64e7a9bc60fcabc6ed352a16944534ae56523b0796a467ba24d81b14dfbe7b04875da262aff6b22a773ca04e31abfc4a7da605c5df40af3651de7d1b5844b4ebe7a9fcfd0cc360f9a2f8d5aa062c6bb7357f69b919d37d340774f8cb18512059e14346502c06795c47d4000b6ff0c25cf117154af46d554d24843f9886d777b99c0ba002959e37332fdcf8a5dc7a01d15ee5767544358c5f6ea0d47c1e8317a59cb203d18a21e57a427ac7989dec0cc15e9635694d461afd80f5ec32d4bdbf07c0fd445d919b72307b3435cea6a1bd72731ad0c8d9c3aa919347c5a1157c0ddfe510bc8515b7297bc64a5ef0dc54d2f2d08f863f0fbe23dff2cd2367fbe7b945c9ee7f357d0e2d20dfb8d8bedd613d4fb3d919f2196bcc5e1a6b10e161ac9a783e8f3afe668ab88922e22b61eba3c4b36d3a4b57a4783707bdb94b4a29a0b3fd021fc8685419608de580f1363e4ecf654ec7692ebd26ab05902349a76fc2859d02ae7ed599e589bdb7af6100bebde8c13e252ebc711ba10d7cccb368a01520eca6afb6f8797c8bd78f25c04ca841f71d5ca2e212dbc1bf908bbccb6b31f08ad4b11cf2b2d18314861196a4328ac5df8b40e42668ab84f37bb88a3826ce20e25c2ac6d1d9de49d2c643c1856dfc4597e513d643fa42f229f56f89dd1e88566343c26ff607d2d34e7c4ec0ee8e8a2693fd1d9b06b72c87c522852f7caf7a7f825c81da49d6394b321be382c635b02cf751d026dad3976d7ee26722c8528887832860e95f6f362aee12b49ddbbc1cba87f0f9316d873f63c6129d5e79af1c5700c3733ca283ccf9982e4a4a7777600fe22c902811dfbfc27119a9a705bff7ddb8c3335d6f6f6870e79e57e6e77119b8a56dd4dee973bdd7e158b121d5f8f828186814da265ae665499c7b1c3ccb004f03fb5d7ee4897b508c88b13c55f0312d60263713aebf343a2a82dd2709a09ca7e3af7e579be942e1b27922b5d3b1b23527300a3d4e4474717b13e35762ff7083ce957a7e54d3d4b029d71e6586e0ee9ed2c59ed100e46bf0e40534bbc0cd60038a4b6f2132315f9a1bd435978fdd6d1a0906b64a50ccaa212fe7aeec1df1e641fed0bd66062bacce26010adf50a9fe39d3fd584795a4dc1fadcaaa7d0d30846b700fd6f3d7e252c1e46b4082e85b1f0ae61ce8c47ab44aabd2d0a90ad0cda91349a402d38e1e47f60c4434bdd5416b33023b81b0be21108052372f62e6db6a7006ad8be3401fbd3324564ae40cce69580aa182a36ad61e3f3f769a58349c2d8a8155e18f2bd0515b4373a82772fcdcf80cc6beeae9b4e3766010ecfeaa7440a1a511973cd51aa8b88508e4b64631320baa7138288224b0de3c2239a12cfb8721267e3acb893ef493df2e3e3d31eb9289c4173977cc61974e14c1934f3913ecc7648b1d4508926a1ebc91f48fabeacc3645bf0740de186533200bc57bd713588bf2b59e345845859cac9fee5d2057661ee6796e71ce39e57c87dadb6a8fa7c388f9d790aa29b30f06ab78d83dbc3493b91caf322dd9c6018e805b8be4ff22caf5530939353451a90d0de7b6c42a623f564c6d78d9046bc619c0295135cbf60dd72cff4d358731aedd45ac199228faf49aa7cc171ab6ea103abd7a6138756325002fd94a75250b3a79b42f5750737fb5996290581bb64bd94763b04a4fa007e2bf7109f15cd117f225c22528b449415555774e9bcb3c0561fb37bf5ce7634a5df0a18bd1e776e14a041707645e27c4ef9147030873a359ad844f1754fadd0cd2cb72a1478c6e506ae997c8fb5dac0adecc763b55ebc97d430a52da9414a693569c822836e2c0d16bb3a08ed6d1cd5f11edbde883ea4ed9bb06ff84fdca619fd58fc264df786d1f6f0a6739a0074576e00562a52c5610afd1be53c8c0eca5535c44be47651d133d18cbbef08134dcccd9928e5efc167ac4b137d4b2a9d6c957d512f7ce09c64fc887495d6ded574b3a1e3256d1464f2f8589cfcf951d36447a7dd3e5aeb518974886d6cfee7feb6b75201851f97dad05dd277c44d31188bfca1b0e583393aba361d1cd8369d4a2f207d89ac3387f75aa6a8d326bc1cc026a059d5596783beb3ad0921bbefef59265a945cd7287634","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
