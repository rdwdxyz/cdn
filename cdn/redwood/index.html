<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74df2175f4a7629abe368597272d17c05e8365a0d7e42fd108d5ac936e858f8a73c8d84fc4f88c066d616952b4b4ed4ff03cf104089f37982c795dd3feb5c7d5799d6927c052cb5e91630ecfd014af69353ce3c81e97424499127687582641914fc69b62e221dfa2128681c4a33363b77f8bd26314da7de3dd9cef95b32d1c80c709afaba284c200ce82c520871090b66373fc5bf136848f3426314251c41a8a3fa2f3f310ea7ad6192e08e0611fa9df3024e39e2d049f85975f4a26a59cd58d7d1de11e15fd866cd21a1717d8a2712f67b0d44a1eba4c6df8eb1370520aa3f41b0eb71700850fcd84959648f78d6f6b340d148471cf1db44d0992b039af76ad76239f783258c48806e6f0e201bb48457c48681740a43d59c2a13c149b06693a1e4d363a2e65bd00cbf677e6c182ee21a1fcbf05927e354646a44e5c10b606f4a59c78ccac86108bf1c0087c6bcb2e63b51f2ce8bd1ce38e25fe9ddaeddd650d489fedeb1a99bc71c58147b8c48f466b2589cf20711ea6a801c0213a2a5f7bff2052edf242037fd2a6b3d1cf432e90d58d9fb2c58889502931574a85901f471be6dce8abd4e351c4c9cc4231e384dd83a56d1be08f60c8169adb80123292f0a6e95008ea049d47c28e2468cb248016786f8f2cec87e3b4a31ae1e8effe868b584949ccf4b97f9232954179c253529fcfe071970473fbd70aed56e1b1b905f467e916918a49f804fbe0009997045729164562de8d7a26a58bb64cb1718c05b1f0184a485e443d4ddcb87c0a0625a84086aa4be20a07a8f290b6fc09c6c9d3a7988b121b1ad4abac6e01bede23e616aaea6e1648bdfa578d546ab02eccaf25f64f33fac63fb9414144257d1949294253f205985d905c89346756ae31c36120fd308f8cf07e3b38ccfabea21b8d6668354fa0be108807cf4bedd7a5297a1ffde8697fe3896bb72080779a971b1a25828c457e5d05b4bd3612b1916450e67f2ba5820872c8fe3439cf6c088fdecbae3deae4c5359e162fce7e3c79f0175d078b87e7b3b8381e2636038bd3d45f959f6022c47938d15564e5b5038c1094f120d1bf0f4f7520a54fdb528acf50e8c190b2a39c2e23df51710e21565e726b846073a7770c6fc8ae6985ec3a18b4800b0641bc3d18284a336bc700b74c0e514d257d09d7778552a40d1ac3fe6dd7f93a7b6c9760b55502b320e445fb70dbb67c22fe38fdedeb3842a7735e11fecfa3906085c87228c268d9f531c54a84d117f02744bb5fa41bc3b17878083e0b3c4a88cbdeef1aefd5f815a388ba4e5180561aa73da71d38641f3aa7628d6fddb8fcb111d23ac54cfbf3e1d41f9dcc98c7395d4b087b240acc835729a60480ac7354e528a3e7f30efdc9110f4ebb23801cad8a1a2ea63e698e95f9203216d9db8d740a369b4779f20c58af41deb395723b4ad61450d3c59f2e3f2634ba5d30c428fe18424e0abf26efe1eaf4399462a15957ba283b6d1f9e1cf4692a74641704bdd3f9e834cb8ab4a7d1e99ddf3add2ac9eb1bbb835384cdddd08676c69c7544eb69bb868c109a691a0cecfc239668945841fbfdf62ba2be7263e89021b8f454e3de5066490f16b1d16abeacdf1ef0eb28ffb26d87f5380efebac9c5d196f63dea43f065432e2491024a7e3a99a7be5444e146a72b902c6923fe8addb732366891c5145980c6c5505143ff5a5ed4081b9abf12128fe23bf89d45e85a56a0829f7905bec197f6cae2b2eac90f6f8c456dfb7ef6859e3e9306f151b82af88b9e55bd1fe68a2df573495da0741c791b2ea0adb0863c3956fec3fb4a5ebfbff6231b696dc252f7949a2e94df757ebcafbd80331c9fd7d6d52b80c7784bea4cc39ea5e8e78fe843f30a3272af5f8977c69ce0d25c6c426d9f4a2a34e3fc13425014fb901afc07e9adf815ebac740c9fa3d008fceff45fb4d977c483fe6c6c6b38c132b2f5231c4e6f306dd0c9e1d739d0852066181df19f7349bebc8dc3d0bd0c610152bb3fcdae7995d1987d8a3f8970f568bed40f12f0369b653f6f6880424d1dd6d1be258da5d9a9644056586941a2025fc1d6fb8a85a37d07187344d364b842bf098d3ea2b3e8eedf97a6a07c0d8fa1046d485eb57d426c86f657e1a0c8ee80202e8de43008c9a75af2751af572b7b04d2c898b6956c12bb12d199836c92fe97f9c90d9f8c45eacacbcd8d246768d918909538d24085046f60348877cc799bf791b8a7eb5af39b8c8b371da724afeeeffca11b1da0f998a48bfbe51bab753c6d3706463d85c5cbaa555bc31a379b9e502219f11ab54813487835620e1b737a028a29b64a01d4556e0cd08ce01fbd2f5162aa5526375b70501f840679e9c0eeb69f8ceb1895d63c400cdc4087adb83443f61e2783fabb4c7c65d0984050874ba2639f406217307d33303ebb5e61977ad160078c17bba241b70d3b233cee1f4eca7724a28bd1de17aa54d74a6b3e1202de17b5b01ce661cca7a12c379cb85f299cd2f1ea7753eaa658699aed10d6012ee60bcdea0975ef1fde1e51113ff924e8f47e52be4ad857f2671ae115eedef8927282c41a29949d305e4715f2d3054f545a0059017e8121739ae362d7d49e9b705cf5e4f96d10357bb7b24596e8500787000d28fd468e3cd51fafeb106095915463597418b6d4b33bb3f98e4282f19dd5c38e71b465630c3f5329b0ae9c0ba95bbffa01e2515b10eead4ba2b9c1f03ca47ee56aaf777ce2758cf8080a9379b3d48f668ded6a978ffe0d0ec0d7d4102564b5afdd1cef5d93ac27c3728432f59c012a7be36f5bd8ae9a47f65a0a8d915519f0d0140f3d0b09353f0d234dd63e0393cfaaf16a6bb63226e7727bba09d4ae1156c191f8b68418e5218081e5947deeeacd161635de4ac34a84062158645dcd95bef5726a6032cd147ad87d526b138e44a9a2270fd00455f4a165cd33810e0f2cf9a86cb34ba16e9de812fc6526a963cab3a7f5468bfdb45575aacaae9d43010e0c6a0b2a5c8916aeb7da60c386508a7b04f9e73b6b2b34375ad7a542af91aceffe3391cfe3b0ca3d4b246dce32101b39d260c92c544eb23c91733ebae428d359becd0e653abce0d16918a2b68fba6ee23caf3f410ecdef1308bab7234d81f1bd4a2dae8f97ba8856dad3944bc86706351c5a21efbbbd1fcd7305c1eef069fdfbf2d32c1485782df565c05cc2d42a0788a64a711e9571e4fe266c4ceaf092e1a76a0fc4578556cfee5e92561f3c2bedf6d4fe0d9d00d1f7e9669540c1714f89abd5d282d7d9046c99ab28b1b757eb483c169fb0288e6dfd9db7c1624411bc319f87989adb3efbbfaa92adff40a596bb3f166ddb48da03b167a4cbe276cc2830fcf725005f0d4582285830cb7df38a781795407b639fc278536110f0b16b5aa654bc9fe0cecf5707fa4187002bab5521c3737e32241a9507e069050a1735dc22ca2d27f840b8038019d6e8ade12855a0b27b65c8e9dec0885d5c23995ec00559ee26804d361c5a2bbe26b5449b5f31b6f0b7cc20c0df3b7dba7f95b22936305b11b5d5a185b4335b2cb88349d28af48a1645b7e1c1c55e18ca5071108f43127bd5416e1133abe0e17446e7b842e4677ecb61cbfdc1ea52856c0eb9caafb4f15981ef32ef688f9c66001cf5c59021d5fa2bfa3643362955922702d6302087e191259311f07063d7fea9ff0b2d533526cea47ef1e7bdc08e7203e26aa1dbc58f4d4932cffaf5341ab20ffbdb1880d2b174168b48a4c4bbebd4dec94cbd9097eaa2c22e5a9df7290ca0d6be057278a7e61d838db64fa47f480901c07ca1e94331a37826c5479b0e865df0f0af8a130b38341241b5ea57553b8078b1719491b5626e6fac84402ef2b98273ce3d9aa0f21c462b5b235e455c4a71ad6d9df827677287e95b1e80ce179fc415dd95acdb227d15dafd2e8eca32100880a1ebbcf7e124e72bb4634c0815c1da26d34fb91fb93b66d8b9e205069bc227757819aeb54bee36b9ed204287ff25424fa398e2e2a759d2a3271aa78b18e7a599daeaa77e51c8654622750474a76e725f8170b7ab212b163c88973a745ad7be68e6a1ffcde1c8f803fa964be78298f786164d7717d4ebbcc12a3a69c05e0f09084d50770540939b44005090c4b91e7a539588f339c62bbe1768744a5d57a90f8216908f2fe514dc74c9b09b1c2f59ccd63a755b2296d275fe434dc3fec7190d48effd51eb7866f4f9407bdae225bcc0cad44a1148d77d022e12fe295ae1ec029647f8d10d82f3320457191c098a1e25c2c03e07f04876172a22990de9d0539e17f03aaa398fdd7630ae750b03e0931cea1755673c2f3f2791930222d50007cd16f20b4c7f344c9d1ba980060347cb36c3892c204d8c59b685160eab5c31d5f92a879610e36778b6e26bf22bcf4957627b9788b2e100cd9ccb33eb94c9ea6eb305e5bacc95838ef030b9fb28a95ea72af1db86882debe0a3039f46e6c1abc350ec7f894cdae963557574d09fd6bc1ae456c88bfa5423bebc04a5d5791295cc85b6f87db2acd0233ea067efe52b064ebcadfd81328d4f98d20f3f13975d033bf5efd907d3c955e8764adfeff6a7a621cfb682271711475684ebaaa4b340e6d511c03b1b511f19b6dbc7f999f5888af5d70e86bb9b947a271f90a89b62ad4375cfe3f4582cf38f8184645393ad4155937bf0f8e036128d567de9fa8058be54f0f465699dad3405bbebbc8f09f7068808ce78fa5d95fe5ba0f367ba37a5bbe18860154d2f628c75d167f922800a05d106bf9971fbd6705ecd0c69c7560b28ad4a9ad06b6da89fc9860b0e5c7a85c14efa8208b751c5a969c05083b075045c74c7f0fd9a547d9827a8d5fa3f569d6c93cf4a7485fb9b0d4d3ff9da819b1c418a705ab850c73fc332c65096daf102f0553c7a23dc89dc25a945a30c2a5f19510876d131ede272134ed0375463a1a64519cce91a18a4fc9de6219657552e6002f7bdd17806986322a6322ba5876cd91a7defad62577585025d0598cc4efed8e720798c9b04a25357ea8c8b7171b8267f6347f4b7516e42e6c42f94d620837f2da11d0e67c3b13dd16cdfd37139dbd8473c845ee75b7418a02105008df710d78e70c2af4792f3eb527d71a8a4a3cbd98c7e21a409868b1304d8f2a812dd43b1b9e0110e3d9435b3eca87cfa938fa6a908ee2df79ba24fdca1ebae339a0a2a2c494923d160fd3baa9d7bb69f956568937e735c74af24a455588f4768477d675b7a26df93a95466f0536c2cd6e82121149c92874c272b1ffc58accc7b4232a0cb8683598ca91e53f02848f6638d710c85bccfdc497dc122fa582c6b6f29ea7855fcb2d38c1a123a5c6623e8a77d72d675b0ee5ad29dfa3ed0ab8a5a0251a4b0435ed5ba23da43102c10426092931d3c286647270ccb854035651584c803b9df39becea69870efac9024a1dbc2864827653d30f9d009d709ffc690efe3471c6db538a040daef84a155bda2d691d80561288bd7d392a05496488475a16ebc4c30746777908ad1093daed7a1ea102c2709f0cac3dc7efaa93902c925498f0932e8700a28c736f75205bed3aacfb7fae5d5aafd84e5cd3c515e3c2c178bc0c92f68c3cbf8c288b50ddb5c614ade6f599306a27f7446ed682ad6422f1b8d754a8f5ef0745f4eae4b811a1c305ad315ad9436eef3c3abb5efcb37d7bc6970ba3ca75084bbfd16e00df427ba62c6165541fc18014493acbc13503a7015b0d523dcee3f8890a867deb53c73a53578de20790655ec74dc45665587b4c1b49aec9fcb88c126a0724fd6e92b65cfe53e3d45041520d688914adf2d08f544bf5a769a716865ce980a687bcd609b1b141f96555f14c9d91ebfab262e9666820e726c645778d02ee438d503dd7ccfe77a0a34697cca13a536a131ad67221af1f5a27ff995e7e9082b404ed8da285ae10fbb6cbeb661924a123bef5d04cc2b4f017060dfa2678a0c3f3fe828b287d2aacfde2e18b3bdc95fdd8d20070a9013b15a3440dd4ad67a7225598f29b5646d69bd358465bf409ec3d990bb8b61cc647b23c50f1c1a7ef73fb1f606c6051f292642fdc505fdf83f43572878a1d8873f2514cebeaee917d312ef3c3df3c3dfb80f9d13102e06ce0080edbe54e8b00fdbec5d32bbcbabee4668cb397d5316a2e4a1cec144f43b7c0ae66ace7719ad5f2345f787b71109bc050f2577865110d89e79516865d87f2b74f80369019e98ece015fc7bf3ab4c67c8e2d217ce4ee32db23584124f37dbda2976ba222f62a538daac0ee261f605b8099c2cec84fb9d040222c214f790bd4ea416afa3510a00acd600ba732525edf6d0676a7def35955eecb2c0307b8e59f1202d1295a9cd94799083a7f47aad59b4a98eedb3129526c042e63a297da3034ccd77c1288f9fb40de240208d50dbc8f0ec8d8c62d1c3391b788216b7f704ee8ba6bb008b519da0aed95f1b335b51043c86b5bcc29f249e9f58452e8f584753c761af92434254114e8d9a792b4a9e90d7686cb1c81434a9f6678d680cfc615ba80bed258a9436ea6eec335fb6598d8f4aaeee4613d88b2d5fe591dd5160435541634e9efcbf8cb991a87a3177a5082888231d5edc1d7a13003282da36c74759f3b4ef0d837cd2571b944d7f0917e4cfa74007ed75be85c2b30370824096d8a36d8548bd155b00abd45364ba95126e6d57a488b6b96553b53b7b6c6a9eb9601f5eae3a54394184dd899cbd97a135ed5f7423e560e7c02c355a34a8683f55fb080ddcb8eadd36f3b9de4eb412b27dc1460e94af4804b9bea49112292c1fb81a5d07a05906b6b8e85e7362dcfe0db88fb046c4da272ee6940afa0a8bc1a5e22b168d2822963a69a63f6e59e955ca7cca05a75de6b07babc138efd3ca4c419eeefc5044f95f2b89e34edaaec722b73c2baa2d62eb14880430f4924a99075586b6dcb4f9e66c49da66f9778170c553eaa3863a445909c88146d0788b6cc96bd7e162ee009aae516c5b197df5bff393746002c93fcdfc1c5c50db4610775c94698bfb6a442c737a0cf8927b369e260681824c50cca7cf3d3f64e0db49d2e2c599529f62e9146eee40344d081b70ab66af66e0be4f77e1b8b6d50cefdbc5bafad634a702945cd363dec2af5df142883b84b640da602a1a134927875c0af4114d11dc41f43bb9cc74b20fad6d7093e251deb38117d8ec4f8791927fc1044f6fd4fdb27f821d8bf93268f967891090254946416766e9c6bd5f16dfc87b71910013f561704bac1c386083886e925f53df489209d6a4dbd9fe9b2c44ad0347cf4c6ce0cc3fd4e2533584bcd4f69eb7dc737778c16cb02bec24824357db31594f903e8bb464a425f5625e3d0ea0c7aeaaf9f92034d1f79430fa527cf4a000405009587eda673273cef3971345ea98efb36f13ab7a0f54946ac18559c07d5b107d3c9268691438f983bb8df140ac3d8923d722b652536463c4ecf0aec28069dee59487e432f7c2083d59ff873ca71e8a834a596b13f7c8d39e4e2be61a4ef676cf5c3a35ea2a5e57a05982107c664a892448c0e191c83ed0d7a63346f953e1e28b6acd189a1f9b2f7239f611585e9d395723df3177305b5b3ac098a44345d7b1df2ebf3f1dc6432137c96c84344975cc43f6be9f0da61ffdd8b5149a5a41e6ff6a34031fbde579f62f38e532d34137093013146c21ac3317f9566d20ceef9133caba3233007dbd72c3d961edbca8d1e5e1e8309d2055e0180c14272a7bf5b0c8e452fa9f7507cf8805d02da7f65dc124fc80e074c68abe0843cdcabb57562e1f683cad619c448e12b8e579e6710cd6ed3ed16f271496b8e07fd621f6cd58d5758267f0f056558a4fb9089379d0bee0e18261abab712db43f16dd1a4f46f570f6af9b88f58533e28ac030f8ca38186e889eafd4ce2bdb2abdcfb934670df4644638de257265ceca660004bf9500898057ad9d1ea28285ae554f8a45cb666a3ff4198bcb428264e5a2efdf4df48672e9fd6584faee90ba1a74419748fbd5837add9470f27ffa8b4c93d9f92f3746387e1b25682143d0af566fe9493c482ad8223e0d6a9080450cf6360f5c0e2229cd941568012f122e84279584fd7a168e8cfa512a3e01bf7e8452d672f8537b8cb23f182acd82f8b6f93b554407769e882856b5d9e12d89e985dd64c092bf100f427f2451ff75657ab5346872520954804cd505ca5b3d6d251123e53513092d562eeaf40fcda003135c2ac8645989dd75bd25b0dc71420124bb33ea9ac89dd1a8c698a3ea2b571c0633aefff83de7567dca53a462ede2e613fb3f521ad0cd56a48a650ce210a82b4c28d92a8874ba742297b0e75534ea3fdba5515cded2a9d775ead36a8bc56ffe2ecf769c5660047cfcc52c6339f134e3e413e9344065ecda6df9c3f8232caae78455d475d4452ffa0002f27aa0bcb160d9884a3477eab9eb7ac3df85e9e55952b73ab9539ed3b445c2667ace72db7f335825314666ebaaf6f7e14f246dda5967c5eca287d29441fcc1fd9455a12f16a7431124f0e87463b27d4aca112dbcfcceba07b2dbfd4caba2a4f18852eec1334f0849053130e6c7508dd1d2a92c0a14314cf5bbbbc3ea907adb04489ac1df746e88940fad99335c928094db6e65241be82e5cf8b59952b845d6e9409c6316c6201a0bb4f9fa3c1b6e56f8c0d42caa2322b8d60547a8b7d9135d6ba82be59c9bc67b6e926bc9bb49d0234b82eff68f6ba1a876ec3ac97de780572ee0d8c0e4c8159706dcf09361771889ac33c47c5d55f6f05dd5d4e582ffbd0231d4d1f56153752181793206b82ac84513d60ed32fa9c0f3ab151d56fd430d6c1e0c3e54acf0b073c994f4fd8a27bc81790e315f9ae1c3fd37436e52c8182d8183876a879cebf44b0739ed3b7a5263724385eeac41cc981f10bfdb7cc9bf048bb9a970169b65e6b3dacfe25c1e354698c43f9699160fa2974c1813e6d33918e523eb77826623e7d0bffdeec8fb703648cc98b5806d8df30729b1069b205fd8bb71beb3e347f2609c5a61dc9c74508f3985433d380107c2118b0acb59e75b0834808233fd6be0a84e8057be370c5bfec7c41965bbf9d937057ea78fbbc86e5912f3aeed035f6b849b808072d2ce9a77e0259f6edd5bb8f371d95a05b9e0f093a0fa0b3a5debab259fad054bf7439562fb6d7f33aa60da4d10dfa7eb121c9a3ad15dc51573c4b9c10ac9b9a4216e9ba41c72d248beebf2d45e3aa9cf399376b9183d4da7a35e112fccd1749a43d6927eb39b2468723f8751f85cb87ed862bdee1c71d38c397076bca408fdcc5db5d8b8893ca3e1fa370b9092aab5c63e4ad180c36f46dc253d65245ea6514c1761ff57c9f92766887e121c5802d298930bbc8243e0ce4299086bcc2d918fe0e68774978ac6695e7ebcfe0668f1fefa2570de084074887992758289c1ef6b78d9f7c08e9007068bf34c0003429ab313f6589af07460d3c04b6f9c7594f62f9c254dc944842059c31091bf82b27e28e35fbcc619566439d6d9d833b5733a560c13936e486efa515c37bddc803fbfe864f4f3bdecad5a33c307356cf40fe05d51c0b6e565cf645232d791d50256af0c1e782f27215207ad88acc45de7f4968886dc1026fecf7a5d351bc746c38dd64d2e63236c05cc98a571401b28acb5b57467d5aada7c961de648a1eaa22be5c3febc84bdaa1e5d621a3cd7ae9b33b193c220c19d0c6344a228749deb68ee440539d11d5f03c9db3eaa03ef44fbe6b6fb4f9200fdd8dd0394149b7cd86d5f3772e1bd3c7e0bfe0ab09d8424f51c70f41ffb2e2dc6ec7292082cba6b6426ecb3037bbee304684dfca60ca4b8b65e7ee0317564aa85e523d07d108503146a4bdda864f12283e60a102b9db3c97d7977bd08e1bf8abb900115b6c7819b84ba509085afbb1a0d867ec49baad9bfd6a8a0741a107fb0180947141c9ac087c828c4daeb0aa6f1c31ff9565b4c5b682c4aee100737d3727df5bb420c7dd85c6b8607c3452cbcdbc0bd7ef6702a5912953fac5558c2768953c520a6781e4985124600d8be7a8bfa506dd7b0227041d8b1bc94c4d8b8c4b13eb9770feee0e2e7e95e163d0810a980a5e42c4d1f080ba83573726cf0bd774c28b6a7496cf58862bd893f480dfa1c76eb9d782c5187ef765af9692e80ce3ffc1a8a7be085310d0b4cfddd3640762dc19aa4e57de65f759a460b7b192d5e0679aa044eac9a2fd41481dc0d37c7592db481b9842bc748dc9efcd81d9be0b80f597aa25217f5db162991ea873e559a3649feea60d1f19a2c64ee16bb975294f5acd4e35fb614011d9a5400e67313b1817b2d12d91f30e271528951aac2cfec3b7297ccdd68ea00957afe6d5b9f9bfc37d10586e8992ad96ec1ecd67022f0887466ad395202b582a23c6b299b76f6662618cd813197c1859a155f179c64e0b8ab7ef098bd2576e26f9f176816a90f457861a94ab25ed9e066c7b714e07068278d250e3a0cda1f304aac92ef2cd574409e198acde22d0c71bc039950d562bbead3e33ef0b466e4a0326c4731ade244459961a41ecc1a990345544466bb9c464aa7061f192a4a7d91e35de487155192f9ea0f940537c84180672c90b171f5cc6007f627bab2a2b8247ae65a288b28ae489a4dabea47a8cfe0be2cedd36c2fbedf6f64fc80130efb53abcf9c1ce23423695c35316a2a3aa7dea6e18ab3b755d95404310912e656278544f26dc08b39949262ac967accd5475bff52fb08a8bfaed049f324303fcda9a52d706e8180329b1d001865d072ff462e1107258aa7d49a48ff8a12f78b1618fc243fdb6860588a4f4d9f485925a53f9ad057f316a40797b09aeafdeebf68b4278a8bf098975034feb8d6e2dbe56569f7dd78de59b52100d5aad7fcef113e5d3f677d69a17de30dd12bd1af1b928c3e55eab97311883b6173114c357d76a727f5f39cf84edfd0973e30a52ebf76c635a0ecf336eb2895a646397e3b68f11c8197d4cc9acaccf20f7954013d63aecfed4ae996bb521ddd809c70244eebf924ecbdb1d2c2890ee042491bf36e1e9010e767ce69f48cdff8502ad006202257afc559b559ccbd3d6de8c6bd7d3b6ecf461351114af2222b06bb534b3024e0e3162dc6df779ee072b8f8297627afddb63e8cdd8235d8bc25017e738c6e85b00cca4bd90ad0d83e45a8e12f42a38626dbf499e9b56690376fabe30bb80e3b7c6f30032ae5afc2a6b085bca80b8df643fcc2f8554966ecc88e3a13dd4a3441ae0bce25de7268be45d1428986f2eaceccbad8a03d423ed30da93d365e9925b41be26ecf46aa9838e346dbf833136cf162de6cc01e713455d9cc7b9b6935674819447559ea2d0f2204b7828c16b772889090534da813f2dbd322752eed0142862d4faed5fd3a6c70cad9d87adc51beaa11478940beff06c31809dc6a053fd4d6f3de4d3648903473117de132629e154d2e998aad417f0e308c1d7ef6e5048552fdf1ad3effb8237fe582e8fa766ed254b62fdd1d5e286d4e2f2b4e86ba9cebe19aa9ea406f5650b6b298b8c6510659fc46fa44e9b892f57f19825b5b131dfd07430246925761316fd17013f08872b7ecd5373c10395a8da0e3c6e5e91bf7d4880b2c1f12925d76c29baf7d15f399d82fc9a9c52b36352ad9e4e0b8e32de02b39e3f35824c3bc1aac743635a31405a6cfae9976ddec2d08f42f1948b87e490fe50d69f417c21aa8c41c5bb8dfa4eb25aa9477bfd512cb8a5436975eab49220fbf4d5740b9ee73ff9d6b961f4103bfc3fe12ef17c187d50f84b94b09bacdcaa8dd9980508e49d0a58f56e7c13053c846bff49e63f024e8b1722b8bc4edf1a9590f634e09a43fd4793435bcb2d7b5c1026ba661f06645a0fefbdc909709d89660f9053508f44de59a3f14e9926b7b32bbd0cf4ac0a9808ee1f6e237a4111ffcea548ffd842f25a99c5909777fb79dcef9b2eacca5a42343386ed9d6418ea71807b5c3a94f18dedb65bebce5d01d4fbd3cf8164573bcbf4c7191cef009e4a0149b800c85cdae7fb6c9bcb3b99f23cb202f1695e38d4f877ab08a8c90bfc2160ad11919b3396d921f591743c1a663b1e6a282a3cde45a7d63085a88f81f7bfdfa1f09bfd9954a11f253e44beb5783a99c47c0836a2b249ec6f3478eae1c1e31f2488bf49aa8c6604ddaa02481902eef5b72afc73117e479e4573f571352c4d7d824864f337d3724c1b871ec6bf38ac9d3f649813ca84f226f3206cc6ddc31879999c9575fc4adf2a5ecff4167b497241a4e2146d94f47e5407ca2918932b6bfb0b43673a9ba33da8705114001700e0ead81692b3b5845a6c9abf71361bb8cb975a1ac2fbb264f3caf2affbd9246d1bcd97b111f63ad728764036e391261d5431471ecae9e45c1c32327075b2f705cfd076dc14e36bf4baaf72ac4f1a7fc8beb19c5d0ade3af97d69391bf5cc398715c6d689459beaf0222cd275c2fb4e6f6e9f2cb2cbb43e9353bd261c2f8fb1005cfdcff96736372262ed768c95012d338897b9a9b8d70d4e269e5057d92ee518efe92d394d323dbfadadd5fb45c64403408f464322bf41fc66f0a8fb84f94810490f288d2ec9f5f41cc162e3308ccda8354912717dcfae95d364db57d16d2ef22d7654dfda015ca24eaed934345569b2ceb6549ee06fea488e6be1a7e657e6fb21ac5c67df2251185522060abcb76b810cd3ecdc0df04b13fdd9d6dfa5ceaa9d3a65bd87180d8e759c666e8df386559d55f461a40d1533e25c0bfbfabcd84e4aaef29ebfe23b1e658d8729a8a4d815810c09aac3f654df42d69b8398568750c912c856af5099370fb6e45ecf50f155fda4bcf5db6d82c4b39a7435b4c51bf6ebcd131c21adc35ac3b53114a7b0b1553b21c36ba6c157e3fb2394f681d73a31873c4e27c15207835219b1465da6179682eb9829bb408e2257d7566dfb78112b5d70723719068d1992976e95db84ede7d0fdd60323d28883ee0500b47ea199b06ddb40cb09a88a7bf59f71cf7dccf7a5641d503ac20ba67d8e851eabceb1e4ce6614028fb61a7b406d9b24ec33af90c3561349ce47692a69d5491064c3e04f3121a08807ad615be5582b287145095aafb411d9101cfd2c4fc43158feaeee604811078234ad371885265648321c9d92677f8debbaf895d190003ce4b807170983d88d9cf2ba1e140f12ed4438016068ecc90e5cdbfe942344d897fcec2ef2c12b4e11045d3f370f07b472cdcd8da36d76b4091d7a5b33188b37855242c300a22538688ccf37eff2f3c9c330ebfc00937631408da3880e8fc465256f498e184271aaf3b1c6a461f9f242ad39e32d741904fa06c26d10d383bd600075f6a5ecaf6714ae636f1909e02b7cbe49f6cf438b001191e6ac0f48156e911208852992c42b9375725080ebf8d6e04fbd8fff72bff16abc56ca851acb77106a6992373d84cd07f2127fd82919f5bc12fc76afb626e4310c49c89cf034d222f19e2f4e3dfc89476f4c0917c5ac72a2e9a949c3ba18411e9bf68127ce62e69f255eb7b6ea3a17eaac9b2a983f9b575333e497a077ad950ba20173a8678d74876645a49132eba01c3b9eec700ee14fb0ae5310573741a5394060a210132dd036d816b0a204cd8d3f30a5d08a4ce6218183e36d9ab21db276eed4cee364f2ca7177a76923b8675ea11a76286fcaa05df9bbcea49b49d6b9a1c10ec1dac83482f1e07f20aee45faa7dbd878f541c3f22f2bb112aef95b817e0d5e3606b8f2275fcd8925eac720c2884b7fa6d764ab1cf0514e2cd3f3e86685dcd06db15c271bed8a7a3a1e6b663f2eb3d8d1e733a838e2618d122f47f9e57561cca94d531f13c6d8b693e0dee4bb754da33bc0af89b246e1aed50eca160d1271aff750bd30f332a8a0fab1a8b882563239f7efc637dd45621ddef6af5f38189216f3a4a4bd043d18d3ceddf6d0b5d556739fb7ca8529205951569c0ca00fb8e552318ea2b93ed500979b8a031736b9255b591bff3748b7a07204f273338dad767c1e770fbe7ce0e873c6cb948bf7ea94b1e4f5a7d40706f2a676e7baa7c01ebb1378de89dd1642b524f1117088518fad794503e096ec8bf9ecb7868b60380cca62575c6dcfa5fe4bdf1220e0bc455d0d955197be30f7ed3fcc0eece4195138d1aa55a1db8d469413f68c2da512a1929261769103b9c261f0430bb755a55c5b1bc23a42317506b36614ba80daf599598c449453f8f1d965976a90994d17cf7f70dfb6292e9a6fdd3d29efdedb4caa6ed4fc775bdb3d2a5b82206feb4e1d112d814379409af967334e9f64edee8e38555ef3d07c4a2f2bca822b35399568d62836ea67d68b48f5ba8322bfc7111d1593e43646d3b8ae4724b60fec4d415eaf0edf27f8172d90ce913b8eb8039e16fb05282b5cbe7aba8a2a419683091d59237805682608c8884138a219f2f09c455febe97c84f35f1c97a1f0ad876fe5167eb92695bc8926eeaef2b7c1a024437cf97826511d4ac8d191a49f7e7ee84a6e024eea6dcca0da9b59664bacb4ab240314e299488dc9afefa86b19eff55e53dd43e1ac993dd35247ba477627edca9c73cc90dd945e9ee1140c32bb898fb549fe17a5831aca68a42b0b701f1159b8f9dd2bb19ec88ab171bdb3cc416f593d824ebbd7ee3c514bde11d59abf9cd2625361736a6863b5b150b49c2e88d836110fef6f9070b1c56a372b5bdb2663c324cd59d2415a3fe7fa5543a1c9554d04138c2908c791618b1833228f2399e7c996257ded0b9c861a090ea573118b101be0df72988542f15b9a2d4198c4b39abd96017b1026da3349403f4f4467dd9d249943f4090d0eff21dd49d9834e8cf98506376e94b289d0d4d3e2098a3c55dab9762abd676ba4dbef098077fa4a35120bfee35465e588a7a90df5d36c2128f5290fb17caab9302203bdf0c10d4ae5e30e1ba508c9bca48d9bb9d1782e48753831e4204f7a531c4bc954ae9ffa70c5dd348be0d0d137eacffe996fe7f362c3231b33e7b4e9e7eeaeac5e523ffd918ca02c1429d5a9045cb1a0a5d8c4cebd6df9b5b50ee78c7486420a949c4915b2ee3d52bbfcafb9234582b29fbfc62fe008f98df3f18c3ed1756cda316a1bc88d9e605b87035417ba57c096440862f3df2abda863f4131b03b723fb607e5e7a1f3a05b24b6289f85b9bf53476a3fe44b63243bd800a8da20933152b55f2b634e624b13ad90d2410e4952851ef8da664e16bd8109a56141feb3cd52486fd0b2e1525cdf19672816c7ffd3a28119b04012fb120d7e6f5db48ebb2fe902427cac269fb0b9d7d492881bc87deaf431479ec44e60d06d36c9a86e2529d0cfa061a6f24658aa1ff9357bfd79e22d994d0200b73ed6e9ebedd966049ea55aebfe94e76aa708983d3e26739cfad8f1c9a096e802ce327c8d79c5828fbe89c48ff729da8792eace6662f4f911270d6ca275a0b7eb00ecd52ae6886b5ac30e0721eff78f6b48c0dcdca0ef945ee65d4e48be7adc3feca10189656a1f97f22d2e817c385770311906361eaf03302a85b6fc8fc405473f74cbd96a636948e9b278d584b599f264abb8db4f8e7298c2ea882a47c8f33db04fe81c154caa41722da0a0dc4ec9b190326876eb53aa60f560baf224a9c39a278c7577e59274155690e597433d4caf48edad33f53d4d1b60fc6f9279e04285a6e80315ebc2333e02f68b08b45eab859dd236f44cdeb9198a046227d97e3b89e68108a9a438fbfb91c3ae8aa9caa7fd2b2acd6f97d5f6d45d219d1809435141baff8f87f8d1bfb38838214ebd86ae7031fba9f1fb647e079033574438809dc0f435ab539b39f82f9bada92452a3cf68c6ebae4ef6c150f27eb888ab4e708386d6d1df8e6fda28324b61cb37590ed1a62f82f210ddec418bc0f5eef412488a93d4c777778e52939407516793f970d94e953a99a0301d7b85f19fa0f7e1f0609fe594ec71f8a28b0515d87f8661ce2b1c40519a695416fc7d192c677f30f07754759cc6b34b4a22cc833f6eed460c7ed8f3bb4e545658a2d86246f7a4e467c36fdeff6a699ef2d60a46fbf710f9b9fc222fcb073c3485db4c07f8627172d2bf957710c4d38785a368c61aeef9ef520716ab2b0b0636cdee14da8efd95e53c50a1c8618c439666f709923f0fa07cbe7f13d66940d5560b919b57c104cb35644c51485eba1ddf3d13e928c4e60c841fd90844af9b0dfa6e424ace7766ade79bbb05f00ccd6d775400a69010a8e627c2c70fab267cd99fcbc02270e98368bcbd5c0a0d2b78892f6d2fa3710571b7430d5e38d0ecfcb73c29429a25898d6c65a089148f89b3fd0d9ec1c8a1181ae9719b23eac1c4953c03de69ac2f39cb1a5c589f84773a1269fe71d2633bc732cd71bd84fa36454649939cbe80b94f2c268368ead7133b6a7e2a04c213d507b91034b30957eb23a775babbce8619117a7b0fa3e9574c616a0f0a78c069a2bf49023d5592ea267d8b52267350e23df6f1ecbf3e600a2d4b13f5ca80a82b5336d4ee9802e7ea64126c977e3d5a9bf2bf3fbeea08660644d7fc7c510a79e0b319ad6ef8fb6dc7932c752b232a9709e64e5544708c8378370d160ff98214f7fb96e0c1ef690e9f37feefefd7b666bfc0c1f30df9d8ccfaad19c1f0e1034b766bfedb576e6636da8e76bf98af4c2efece7944f254d0a5643376ddd21fc6abb79db87549efa430a2b6938d7afdfe04c189f60aaaa7f5779f22663c360733cdf388664453e9bf3cd7b7fa28b5f5baeadb2437460a3418e1c044815ef1177e07789b7ca0245477299d212edc45931f2b8193c653080168f2bb5d5edb44d8fe68ac01525daf0b191da906d9de9ea48688e450fecb84848868249a02f1538b5d781bad96a45fa42552adf811f9889ce2fba41ffd87089ce25392847d065fbecffb70bb5f53ad0b1f553b1b26675cd3504eae7ac5307696b5180decff207ba34908b7661befb69eb1f8f148d47298aa42f981362ccacd09c66e282f68cd84548bea3fed62b0c65d095a9c7e3746c894cae0441bdaac1ce7618d9666d6bf62071141ce11c9edcaea0e2a200111e34f267592f796fbb328c5d49f0f6daea7b11bf82cc73c3b3d27d8a3f03a0bce70011bce9f700c9a05f70a584ddcc41adfa67775d9f85c971237a01dd746c9839fcaada1bc6919ec865a2934dfbf6ecdf33bb3ce191b97185a16cc03ec0e878eb41326d53fb68bba0aaa770aa7219edf54dfd35cbdfcf0baed48c21e02a6dec818b26457f8d5acc058c7190b6b3df864ab8c60adea548c05f8cdc060b83947d38a8d496dc0a91834ec6e8c4b15b317ab56ef82beafd6e1669f35997fe001e5a891a6533630d772fd9aa7762febf589a0c69f9295cd310a723d73f2ca83bf901bd73dc27ede3371284504492d7c979d9499fc309d64c5ece0ad878db5515f3eb3a608f61b475ea6abb7fcd98635b50fce8b2d0fe835bdca88e5e1958f1d4c2be7db7a649c32b989159122b7c02ed025ff67ef18d7b1429474c428ee5436052702d4d8c029c43bddf0a29aa269bc997efa33434066dd7cde1bd4bc5170388dd29340a252a6566d849bb4da742ce9efaa6e7b563720ab8132e501fc1dad106744a2e4ff820b62f244c5fab864b1f695e5d93a003d3c3cf8d685810afefbff99b5c6a236cad925aa9feeeb925a3ddd9bb3401fe90b32624cc7b57abb010744fc4ed2d353c39d19c13f80ce5236ddb816378bd06944534b52ebddc55dd4672afb1401f8c273948543247ae8f0eb1618bdc69542cee737932c0e7b30d2b5b88f4bdfe22866cb58f90c258e76b10952203ff685c6809ce762c7a76e0a2f715a386f3369f8af04e935449f5e3f3168825c56b466a8f14e9ad40418295276e4377b38153a44c7586a3ee7a52c6db717b2547ba3fb903ff81fb0b34fd831e3fe585bf007ccc54d4fe860e310cabbab451d6ed647754eeff588e5f09d390f58d117db20cdd62664af0a40e197c71f738ad07750617bbef45ee8a6088703e42a4a97c4b74cd037180692cb35f8b6e8f8b11cb619ab05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
