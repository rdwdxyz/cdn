<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49a8d81e3c6a38b4002fe01e8e03948c9550b5048f78ed6bc2f86810a4a61da3c841ab71eadc4b83fb21317d9853ae8b5c0ed8477b2e118a0d0a0f580261d0d9e3254dda5796e72e3494b266f6c8e4a43f9bb2a69edbf69567250ec01e79a1ab383d4a6df5112bff9cee808a767699e6603b57917ed002ba096865c44c76a0f979c2adcaac4d4211ca7b8be2424f82e84877ebe6cadfd92990bbf9e4430e2e45c53aab1a6418519d452a7311fa16849b4247d8b571fb9926bef22892d7f187dbaee4d0357a586679dd59b04824f0d26f1c9c9e84f94447d9c8fbbc59f98ee71e2dbf1208ae15be50d8726f2e60497ea6be8215adeca434ee1f8469d7cf18cadcd8c68d0d2cfdd0eccd8ca9fb28084e035f58366785db0c906115edd1674dce5baf01a585912ec4192da9ea82b7f938b6c1cb8f4fc31d7e0791989f7104b7a892eb3e381ea8903d5bf097769c275cb673deb044e535d85cf79b9190de98f3a2988c0f2189fd2a7ec0e5f9da500beb464c5904886fb551bc5b28239f28dc61bab40d2a859c858fead56784f09a28705448dedebe35222aac153c205896478016715105c547f105db4d049c69fe6ca1a17ac05f2e9136b946d99561d8417f7e443242dc1a6a843fc1235f89012aaeea1cda6548b6759f35829fb316c75578d123f708698f1f308e845dbd932e17368adc1fcea14c6bc17cb2e02257286ec7b7085861905f0b7422854811d340103ca2dad285e2ac2d6134ba7013aeaedfe667b7d8f0a2a5f168ad4356e0357f88bc76c4a999ec363a4baccab6682e4c938cf8f7383e86876ee288c0cf3482e415987c5e68f442f089a0717b5aa5a31a9455567726cb6d0c44dbbed503317950b41265227d6da1daf3df320b594fcef70c8a1fe233510a049d48b22188f88c37dd628c94c7712d15bf2067b801a81aea0b7bddc2f7fc1736d3f2a78c31f45350f5fa550f4b3f772d1de574ca9cdca34a817c8c7eddcd0d321c284880c3b0fa4aa79a7be9e7495b1ee33b90974ae5228d97986cb911cf7ad5f6fec74058f19c5d9c8c5165a0def7187a6b014c5ae5b236210b9e5d782a4c7f41b8cff92b383708c9ea9b1627430127a48ed37272eb76822ddb0dca19dfc270bf91eaf5a561051048c75d8237556fe33b1703acd4e217c0ba786da60d32d5dcb407b2a8a351c1d66effe38f3555552a3abb3986189403cefabf15b9a16d34e71927994c3c36044fd15491521262a66f38e7fe2d469ea635f6555070bf884e136e7d3c4c0506561aff76cd6ae29ddaff8ce05e780b8c3e62d8275a57639b4f9fac26fbfb48bf4ff0961d627c5bdf8c08ee7798c5eb7bbbb903963f58356d1b210542d8d01b8361db0749c29a42dca19e9c2b41fa5aad6233a6259024a8f7df908f71ac0ac99789a14cb71b29a9f5f0cb27bc33615de6ef6e366a1e5e36dea26236632c672fd401f075b39658a2a25e6c10a90515ab790b93e959d7df960246975a027be6dd85b6ad7430882fb3cf833de6c4c516dd7ef3bb04a6939979693c958952330b17a5fe76cec7682268da369493f122ad66220f1735559ba3fcfc53d1f9c317e67508ea21968e6ad85b3136bad0f93a0454b0fe12a8d4fdc214f7244c0fbd0047afc9aed029dcfc17861d88e95bcadaf24d06071f46a2e106f75d37e0d076b3d4d39b0fe8efca6c824d0af653d046a13fe4ba6cbfc701318c57a8665b2b410fe4d47ff68bc2f48287fd32f3502b009274556f4f5b6b0042bc45056ebe20abf5ae7ad6922233e0c8c011d9d7190a9eb793ed2e298a9cb2fb7fa7d249599dbde0ec0b634d1ee3dec53abc8adfa15610aeb4ba4c3c0475910cb3c4b244d739aa2e60820be1acf1258cea663b7a4b3c8eb428f4f94c438d62e0924a171897681189354a0c732efa49dde37e5b7ceb9a5c5b487d5a82fd468cdc77f915661df5a78d1e6c5fcc023f9b6a713b822007d538a83e65ce6d75d50f0c65ff3a8daf8710dee17237205f0d7bea726693c6d1645925ee7784b24963e70fc144ad3982c2cfafef65f321828179c02d2ad0340a65f15821262662451ee795745ba40ed7fcdcc0a5c7e830fa8cc2ca2d6c0ee23c7659f8703270110696956e0bc9a327453b86de55458411410d3a4117b2a152dbe1fba697993195e9020bd345b2dca6aa66f999cd8755c5be7a65ca3d1db639feb8f910c4d577a24c9feb24c7855cfd6273202ca8c84fcafd9c193e6af22d8eb628aa48d0b3c959831ed6e7a4a8337981856a13a2d0f7a593249b29d702d31a3a04e71dc141f7eb88a53dae3d9795615311518e304534d35371a602da7594b269b65c442849aa3434e4b4d8708c65ab29398ccdf70c7dc2965d2341cc5718c366847cde5b5811d5cf7e34b58ca73793678a08f9dd8f051f29ad1122b0b1d8367c1b60922e2abb283d4ac1a81c8e4b3d95a94b53f9ff5700ead2cf372e123d1356341fd72ef4e0defc01d15d843b3dd1367691fc93460b73976cd4535c9d966b87475fd61d44bb597516f41267db7f53f7c0b7e0ce8ac5585ee44bbd3d7e859117b5a006e44c994515f5a3a6073926a38199a36fc2f0f955f4dc6a64f4457188c6a23b649ad1cd4a57ca3e02aba6e0b6a45c7ead86a2b0d7b702e1d9ebab1b81285fe36b4a9411f8606d4a8d5cde4d5824adfd697fb7778e88666ca25e5286f50c6ea0dfda932760ba7be7f79d1fada8cd68a7e12b8970633fb539791ee6cc07a1d733d57e1d54d54e8c0a786dde6a765b33e94ea17b36e93a96c6ccc799516dcb85657a35d97c05d1169d37611a8149ee1e7be44d8fd03eeded934521e3e0bece840016b2958bec55e4f7551e8f6ac7acbc5f1e3ca6ee571313e6cbf7b5b77be8623121f634656d17657b4a06beaa61a57756e66511b72d96b2387b36b7686dee2e8e8f3b2eef48858c73eadece4e53fd202cb3a832ceb009b9b24f65ff057d629d50489c01192f0c1848a59e762e3a3f3b5c8ddf1282ec64e992b97c6465c11cc77a999408514badc14fe53da90a724c5fed87247e7ae848a2b94d62bfcacef65a82a4711603fd3d4542099c928e8ea27409a45be75192ccabb935b3565acd20e9536a7404a969c23856deda2248d7186fc65fd9e1722447d1dff9786b7999ee18e9be757976f2ca144ac6137f54fadf0a7210cc1221e1cea55f3f1ac02f744550317a437074d3935bf38f9d3d9423d45a7bdcfc4d41d5084a1323feab3604f393a7b18bac77c43d1a8d0f1e353d7202328a4741bad09e33995d5d079ecb30377d65227714fbf06c11181f3fd8125d638970cfd78632f8ca2161f1a4c5e6982db027ca88477e01c2b468f7aae6967039116541bd21a2fa32fb1e5aea17e69413a047c7101a6b7401375071b7b19556f22252a6059979cf2d9733b4de1e408c1df6b5b49950a920253282aef4aa168491933329dbde3aa5c50d8d0810aab5243ae3872433304cc4523d25177435ac87646a4909044086b9278bf147f2fedf06ff7889be3b6d3242fa6162751e9b9caf4f9fd40f4a0a55df3c64a3005c094bf38c5faca0895967f7fed49e3631413ff0e6f7cd0e18bc1b17f22f2876eb22cb3e571f4b4e2de83ba44897d1b1ebd94170b337aa991edce364eb793c4453d5e502ff3b8dbcab281d01a99faf8dc5009cde847ac378b8c40a8357cb3dd3fbecac0ac8e56645bd5e9cd58d642f0e6cf13401d20e163994cb907c54122c8a885385a36ee51fe89949fa83b6b7da8f835839a5af058c6aa4c62fc0a1f74c7e476e542e7c0ac5518c6a3b47c73b79e7a99c4f713c65a7c259f132c2284a1523434723266c179f4e96e065642314c3d6053c21b9e38c28011d8900492690c84987766b05ef08b171e19e4d87ba4d33bbcb15e09abafb70a6cbc8bd9f3623794c8358b073019c9302bf3fd5397e2e1ef7fdfeddd944d750cff6d7cd0075d12df71fe0c0c21a45aada4811bd2e93394c948246606655ea3ec5985ff15e58d959aa838913ebe238e122504d47f8250b8de4c24833160327f2d4c9215de7cccffcd31ba0f5abad44ec124a764ae4263234732b2b66e92464b67ce124ad8d2d89def4f11dbbf0f8d06b88f161e6bc313b2af404b5bf77e601fd4bc8f4cd3dd25d01bd06cc3488029f5b0285c6d5a049c85ecd4881dcb7cd88cbc9efec97f0eb9e9e577daccdee019fe9695912bdf1cdd74de95ecee1ab0b3ea80e77e332d0477d1bbd5a5c496fe75113f8993ff981d396c92e587a83659aa701769ea5998fd847169945b458b986d12b5bd74880eb2ed872fba09bb6c1fce2f3b37d10d9c9e4800868dc21c94abbe7e78cc0461989c092a21c9c2118da8c01dfc4f7650f380f9f711100a33515305926ec0e24f16e998ff305f79e7be601f60fb93637121ade3c594bff7f76af65e2627325cf3be02b13793501d5b1e86c29fe87c7c8dd9e4642589c6f4b4b3f4d0b42c75054f1c9c4d7c464b02d38c7bcfa3700252bc98eb6155eb038d7399cdb1e565db09a965241b7dfd8bccb9f526ae3d649e54726e0bb138407b5ed978cd6eeb3c84acbb06c366cac328a05671955b7668d3d5456031e5e16f5836ccb64840f8f9e5af6722f8f65f2b734cae01e1cb52e1b66999c6d520c56bc3a72d4e5732e0f655c22672f9db51b020489415e21bd15e5255d0c863e6e0fdab2b4fb448618b62199a41c41909e86e36e16b4ef040262ec4fcfd9b8916ef8513916c3224548652f4b038e1437f47a7765804017a8fdc3f69d18d4c6be93b372eb30dd0b10c9bdce00620e988aead68a91db2b376f24ce06176867f0f312f2f7dbe07b664d4f0299140edfbb6a7a305a4390606698b3a460af79274871581e5d9986e715e66b04f54ff4aa796ab7827e2b26dd83686cce794a8a96616d5af82554233e68202852ad90173b623718afc3bf37890a1329a6be53989e7a0c236bb57d3d0a85a4692f39f33d25576c8e9b6c7b0a3ebbf2f02908aa3b92b3cac532e264ef6d1788b25600c8a9f36ede06e44aa3b46bb23f9d407e59e541c6d27c56fbc101b26f51e97224d5b9de034960bbdee7597262c1d390c303d3c98d77f491ba6236df344fea72eec8eb69c079d548ebebee3df50edcc4e8999b35622eac4067103764a723e3fc2b9445251ba0106796672674c40f0dd890d6fddbe7de7c268661805b0b0fcd58708f09f35754c2a27590769b35f87f32974f50fb48af11646f7744cf56a7fc907332a4f52b6ea67de0f56db7ea49ffb4146e50d9356bd793e31170006ce2e858ec40ca1f2b12b595b4af6b4d9a773e9b7667743eb5a3f4b36a8cc2d331b5ce1fa7905504433a18eb6bd4f108ce8b870f68b3e5bf41ef9a944ebd009d3a998267ffde808ec2a7a13006f29a3f17201566227190e298413f6ea48da524651f8501b9c242b5ac0cbc7bae031058560788e8c1d04275a4f62bfe0bac4bdba447d2c853b183beffd2172c19985f27851a98362c623f1db73e5f5332b58d8b5d20de9f4adf33f8759424b92d896314621f9a23434d7c1461bedb926b5fe168e14be2498ece29f7a12c7fbd078c0ead6a51dd1d1e69717dc485a111a807e286ab6221b18ff52efecae9563e2bd57b1e4ac512f53f38a965dc218b08d3af78421db73461a762113c530aade628f70975eeba0f4b9c9cc7f7ccdefa729e813d323a0ef553c29369be49c4cd6fd5af256855d3dcb816187736f0fb6607fedb32f8c6b25a302647b346ced04982abbbd3ed7309b3f4ddb1fe4efc163e3dfd4ddaf18a7c12b84df8a2c57950104a74bbddb999acf902278f86bd81f592ccc657c2e801abf9f1847aeb791331f3185f72a62902ff4b37f859250332cfab7468382f214fb89185d1adac17c08d28fe6c02251fd36d3779edf232590495cd9ba424adbee75d633be606c8c1fec7eabbdd9847d7bd6dc229c86524d4c76ef68d50c38ebd739b99ad3955a9a3bb1164618aad0743d602df1ddee9140c37bed0cc973b63ff8dfcd5b3e3184ec3d8170578cc5652f46940f5f188c628cd0de9fe013a297b11ed053811fe2a148d8948ce451d0672df1e3a9f027ba767eef124e8459fd7cf5838cd2c0edea88ac1e4f48368a1dc899166bd37196b0fbf721e508d6aef95baf3f6dc59f285d0793f1fddc58cd0861ce970d61d6d1ad461cc268b3c9a62db885792341411f10258f588959275c9b61ed44160eebe20d7a0a7ec77730301d4c1dd669c8c0429e8a0c357a7afb95e37dbc41db45c0ab95849303673ed527d06ce52a62e737653f114b3232b90748fcc6de8bdb1829a0ddbd03d5a7e1cbe990ef7d473a2d97a50c319cd7b184f66ef7646a8fa69a2959404ea6c5b196d64ea2a6738d790db6974dc2165d25a76e96157f07806c17b5c124318a016a2f32d0a9d1591cc544a6fade091e16cda765d65c0cd816c686f89cd10e4cc47be1153ddca82bdcd1001467d990049d058ab270da752023cf64a0809ae1edd342ad3fbbd96222b4c2ed16a10360c09da1b76f9ac49e503c60c59003eb072cf76b25ad203194abe12f2c431b5b8e82aebbdafd801a1c9a73702f0a3497a79ba3db15354187ac447238ade5b8d3e654b644eb6610e9da1d84d16f355ad7fb722da67d41f885e6e5b8450aa7e2b1184e350c88d7bd7d4190303d2d10b8877c3283753f440f5ed121ede44ef01b607b0740e9f15b08caf6cb55948696c1f9c02be5351982c35835772bc88b0b580fcaaa1ae9d738f75c7b109c011edb38b2c60c37b2553aae51787bd65123274333b70e0b9ce2034d000e63664794295494dcb4918e24aafff37494d64dfdae02aa59cd892e74d2af858add42a918cc82cb64ddb21c7ee3f260ea0237af496813bf67c9465b3f96af4329f4d1695bb36ad8bafd43510dae0fb1ffbde638ccfbc1540a2c327af46e462d619bfcdc90530e4c2214ce963495e3dc654e05c570a955bee184e7b44c21583b621096fe22dd8a47b3181c746d8ca6a9e108015aa43c60fd1fbfd4b7f3909930ec6a2f4275144c8fcbe0282d091ec98cb17bf2a0453a8c1c0c01ce634c94ee9ad0a4879877b130fdb5798e6f55aed8fb76d14ce180880be438660d556af8e20703736bacc1dff47e7ad9f18f79f6789a3b508b133d6d4967a4581b0383760a549d63312f313c239ad88833125a075d9072e13f5bd299d3dfc3a2f28ab14819102a96d6d7c9cfa61e74080984db69e028e11dccb7563128f36058b28eb53bd274a4b3aed2fb670d94b15cfbb6708a78d0c6f8cb538fffa282fb5ac0f8de300376cc6c778e892e300fa04819a607a3427adfedc573be5d54577ca045380e818e6aad1cc67db650fb5ed7683df969a3fdb2877bfa8af2dcf8fb25a9b62dcbbf583dec3d78164f1d6b735dc65013f4a8938ca93c669a171a85c11e4f760c175768d46a378bb13113ac1782aa9175deef9c141e05f23f427e5aa47dcedd32396553df0354612cb73db4144344a361970300bb4d05168ab761d70e883dea0ffddedebb158e647140a717b36a7617641b515ced48415ccb4d48e15cca63fee10a04a3521b53b63c7abd699ab7cf611817921cc07c83be31685a3a2c6692517eb696f1daf2a0d746d80479e5b7db136afac594010f3520f2cc364be4ebfaba4d99aff117b120f9dc94875dcb33676eea10d6f514ea742630d5ab8726803724ae0303973291526ffed1cc07d17b436f4f649a3f122ffdc89db04ad78edabc6e6e8b1e000590fc4070b1cbb0fa04338d34460bd77e1ac79e17c69aa987ca65d8748dcc8c729857336fd273d75481d2925f353ca3e87b8a1dea3774107efe8a6721d223ea4a416251ddc03e15e05e205f6c72f9e677899410f2b7d603127e6fe1484ffec79c7e395ad749ad2ddb078b17403e2d33157031a65b88c3799282da374114e01b70a77bd313807f3040a9c440459b8d43898a6bdd8341a852f94a59a5b39edcc459ab9e6432d925a2825d0852adc2c61ad94fb5a10bbfead40d33d077043c7e952a33356523f15e5147b39bb77723ff3d6b3fd3c290dc24dad4b48b0181a2f85f232a0825d8e6b69e83a59bb70e5e708da44d16e0fd93e8b6ac2e0097e836bee1956163007a8cad22f72732aafb7a7a232da0c2f482e07b357e528f2edaf175183acc5709574c5754f0f534d1311a5d262d6931ac7d0806d0db85f2c55bc3df13bc3d9bcd1659f53dc53e3aa8038006b1f20f4f02d05ab4477613dad1c1fd667b493388fb06c200cbf6e2be5627a4687d474de7ccfb4d77752d2210612bea61bcf8c4e132d4ad9e2be8abab2ccc4c4ca55837881e0b6747cd0d2a70efed61855b28fad6141b160906777c8227a6aa705b3a7e71166656725286ad6a7ba1c50366d512fd4786f103d5181e1b85bcb01246cd4a85621c8d4f9a94df2cc15629cbcdc661aea4b7b9e6398d9473faeeee3c98345115d36cb0a586e80235549e43b8ccd4b3be91ff52f2ec872f93b3be615b7b28f0eb8853c688ddc6da2550b02060772e2037f65199557b6bb69e08f27f4f07c3b73f38eee3146d836e468c642c9368fde053d065fc3678a1d417a7e8e037b8cf2b956295601db02fc37d5d8d03c09e78d80ab968701a71b534c40db3385eedc9db815d351b8c21e770e1811b0cac50bcaf675012aa2af1a8b9dea79da5503f8d5fa96926c4b722b0c1c6cb462a2a1e3072648a8322ed318fa2a4e0dd74ca7f4829837226e24dcb283b5409fa5e93db873906d3a41a8077fe54736b5b546d73a716abc0857f27eba4c005ca446d7a4bcf8edb9163c0791464965369811ad7ba0c22ef89d01eba940c8a05ff8357181c2d308fe725d76141405f4d6bd33106e38c86b7f63478c32e2eb92c354e9dd13d993a10d9cbd507e6442d9b153d1e2e64a147b2644be82aff2ebfb2a47f45abc5a0bac690fae3462700c01763f07c5b09c19ba1491192da747ae4bd4ad08bbeec510e4bd62822dccb947b1b92095bc1adb7ef7ba960ab3704da3ba549dce015d3c107cc4e4f3f054cb45e0419ea78af259f4f8a58af9a549c32e5480148ff88c6a4ef9b60d6c67da2746eebd10765377f771711ad724894f769b2d3b5a2ad51407cc4943112e1fc4ada70900536f6e8450839427f6d5282e8ea38b1ba997d97ee2a9689c91d91ebb75ea3adb4366696021d3dc2fa564ce084b628b53b9464b5abdaee3bd109a3261775305e81d422b73d3c9cc30893c72ce371b6b8138c4150b3a10f6ff7bcaf650c5703eafe9df80633c08bca3e614249d1d7bca0679dc013f143765ec60c972e2f9d5db26f416e696ea97256b78a336a9b4c932f84d5a3a9fde0e864aaa921e2d27de3737f94cb88bea410d307db36264a34ba3dc69d7c4b9c568755aa9344646249cd7500acc22ef24adbdc92242b132886e081bedc0263894fa447d0b8b78ffd4d5136dedec75c0dc0ded0c9dd6ef587efa5d951ec028a1fd1ea16456ede6a3a68fa570a3d7d21a7b1d7a49142d87e1e1a00326a980af7001af64099d16bbe842bd2f8a5806e103b3ca42fb4e7b87d0ce29af2f8a1f79f0fb407fc9a18b4394a7d1e8ad403137395c831a284120db8c1958ba06f67fe83e2667b607a2ebe6b4e1d50a827d9c9c703212f0897d9542e95d4f84430ea449022ecce54060808fc542bb64d29086cb718acd3d17204b79384fc04f5d298059a6b938086f0c9197befb405b60c6be36d26541456f47e8a4cd6c92ee0c676179bf04371a8f8c9aceb7b78a02c6b40077879a59ef892656fbb675897a2f319ab96d188f46c1299ca99718e42556edcc940b3522af2ac8a93ecc0ea98c0815c6c0acf74d8348ac5c3e004c115e14def42cd284ff6a96ac969ee7eed3991110a3de2c2853160d8d1cb14b1e374b209b2bd796797559c20b870b59add14807de3f33f0a659600d87cecdd72d4b71dc7d640f82695c97511de9d2a7808ea56a68dd94196757b829b8c0076703eb26c0ae4e0779db9351526c7565ad627c7432bb7adc76388c2695fbd2d2e8abb26b7865d1307255453a91b3642643768ccc47de3b648425739f937275e3e329adb1c25eb4f5372139569659f5e50ae030f66d55f1ce89c0a0c15daf7901205d347e97d4c89c1657c6f954d30c808e474d9438067c11a40ee3bd9a75b34e0eafe7154d86c5cc7f8bb50f3dd9cab7163bfc5d324b13d4874e8e0ded5aceec3d1c22b8c5222ce2bd7228481b59bff4147cbdac514fa25586cf163e807f767b100f401f7a9465d5b1dc0b944124f5eeaa1c2cc37d9aff5dba82d82d89224327977456d48a37cf0ebf86e3ce1a18b5a9902ec53cb2743636c5b352c6e7266569213ca153fcddb06d07a460e5f2d507b6079ca15bd7c47cb951b9d602da01ee6eb1f32fa86f980bb5682fccfccdf7644136ab4eba7c6ccd07cb8640f0b5c27f0f822e57bb147660af3e7cce1f3b4b0135a44b195aee42e3a43068ad0ed4894bfb513827cab10599b8e3b5972fe3d5eef65f48d7debc36631eba09de3ec91d19b518fcf3e9d72b503cdbdf66aa1efb338664c4cdbacfed83c660c161686cb9af03e9117e6de18a4e26a06c97937f0af4979df46a254617e2517fd9a18cb5d2976fb5eb85beb12d810851db7a01172ec33007ee16272c2cca3e4f75d6be40d2846bfd0e668b3202f3221a22deecb718a6cde62db1104ac3409070e1c8a25baf469d9a1d69194d7fbc86ede025990614c89721ba1555d85159e8edb30b4a8a691c2fd53f950b347f0ba7941d39b79d0ff6d797f8edf8aca58506a9ba832b7c34d87069fce995f377915632c8abb1e8827473e8e4a4923ea9e9892a14b640e6a8972c21591663ae5d14344ab477377a339e4f059c59e9d28fb30dfb63f12323205ad601cdad4cd8a63b2918f36a99969c92a6bffe7fbe5a9f69c90e01a6b66dbabd20f985aeee91d98f7bc6fc258cb7141db6a7acd1fa0513d51ab51f6ec242abb413f43c4bba0dfda84d7eec196aca241ab94af87a75c18bc649fa9c09fdfdf17eedbcb80a5fc90758413cc207f3763c641f90de566b1e249821a5c5a5dd36507a85784a1c4a593fdf33520f654eb1ab141f41aa49087ac5294a1a3d61371d19a84e64cae2b5a8eddb6d9ae86d6a43ad671460579437ff94067e6bfcdb4f74609b05a231c2f59c8de9a6733db090135166d062ca08b4b42b1884a17dd6ba904a29a7d537e1cb469e5e28a21550b8f4e5cf2b628dedfbe5a1d3f3bf6eaca2a17bcc716decb7a068ac9d1e1b66d46c45dd1154f2dac2673858742e14e2095a5f96c9d9ee01a538050a28525476e5b7b7c72ff031ebc0da0ca522e9521d2e7a98ef16f158fca865d13a502e97541cbcee6103f54f0d158c7e4c02a506338a8e183f7b68c49cdda3218115daa27bf261e1b1c33290ca575a30f14222ec5eba3cc9254a2bea6199a6915b4e5cab71d16df6aacba7dd8e655adad95e1d8d127e1ae8e5a5ba7e620b907441ef5ca6453c5b18f679d25d6545c11d0c0143cdfaecb9c6e7ab9e19c449a905dda9688cea46ebd2a4c90677f4fc804866cf1794edaa878c0b32bd0dae8b48a102a54b8e97d5bcd299614b92420c035fd6140b9f38add2463aac5177a2ce2d9798b8fdbc6746eb72a673e0d0f414c0ffc81c3ce0b54d5cfff9983269f86d2d386abdad9bb22cf1d58d55694ca67881d57692a67f4143b12b66fbad3d74bfa4d51e8fd66e8b6694089ad363594aa3f66374324157169e56bbeaf0944dc0001ec0b0fb190ffca5c7c8d5635256e492513768ff31e2943cd72a25ff5327384a8a7c66a1b55e345acb47365cc7913da5c8e119fc0bff5c4d79a3bba335dc4b2e0db3d8b6d627e824e6f0fd0a3e061bf7696e9cdb2c048e7393895bc877b0b6b56518e20fada232db6a3051e23030276ce9a17bc24f8bd59037e9bedb075b9b0365ee24c61c4ee46d24f777a6a876316f8fa06897ad8601430f520716f9a9dee57dc69c03699199d4a4a72700d9737700dd0df4f17b524bb3a335c2f1ed2c8246ed78f3a0bba6eb77510cba13a1dc8025040a70b060358b0aea134610d8b6c31534aee0536f03022ded21c4acd1f3c48c58bc3e878bfe25e0687118d72369d80bb77325f23b58073e227e28b0dc7de45fb1c70f554f307e255a9eed0bbe2993c141d248f6f8c4ad03e3fd615c5f02879289138267b01cb8863e863a8c624637770e100a6c1203eb4b20adc5bca5ab0d7db9a3fc8d13729871cafdbfcfa2a38dadcd727af770d841339732a25dbfe98a344ea9cc0ed68e6e823046b7216b7362040b5feca768711ea396c2550b6af702f6d386de9e65d4743645475183d843c3476e886e649d0c119949c84bd7f981e74e81b111c5417aa54a7b166275bfc3305df4638ddb02ff2bcdd1bb40d4ba8d510849745466c317a5c7556ba9a5bc50332cde0d437245f3fdcf68b9156d50869350ab8984246edd64717f68286e82ae16740f54a54b6e8aa624c045bad2e79a2a6835d95d543f0bf454a677cf443c0cc67bc1a4d11d357378a1512385d7b4e0909c2142178aa803fd5641afbd886e708841672199f31ff9cd340a143f5882353ad9e5bd3e9cfc8b1a1a67a11a57cd273282697f3a5f27841566eb64d3f36bb79836e57d7d0ac3685885d980b1ebde7c0515d15bd0ca4c8502143d29c0b29da96de7c9435acc0b266dbccd51f5da9ce72d7a0498a225d64aa01958310d61f21262d662329bd9d5afda2db5e0951b1c698ab8ab14461c736683a9e388626f5fafdcfe1f21c3cedb77f38fe66a3cc333ed78636435fa562a4df61d5b6cff04c6c02c340a9ac11e81307668e6ebf096d26ec92e382a7179d298273605b44b029ffed5c4cd531faadc727a07688bf3623ee32087fd3e962396b129fe35857e78b2b9119aba4e83728049190789455ba4538c4a6a44746e8657575cd4c3feda2352da2bf03cf5f4b899803796f09fe47ecb07681c507d5e72a4c9c8d73e11309de6615892f86e64ab7e8f4687a0a89fee7be8e578118b3263a65adf26bb9925f66812e5160e3c6ccccce35bbf6a16386047d8199cf67a289bf973c1a978af5e11d73e0828643a5a2b8f39495f8c8fb7d5d1e3ecba490a3a723bd3c041014c1e0657be799d874b517c73e09f7e400d3689e0fb9a73b8c02836024d50a348299b0999837817517aa5c120d54173407cb7e9d9ee612d5906bb48f6b21828be0f5365456366eba448db7d04412a2e387948402ab9d5c364547d36cd9e598711a32ad712f51f28f30880002abe93ee89c13e6970d32ed082476e6349b33ee3267edb4162df327788c4bafb96ce32015796138e1603bfec6c980d971fc052e568f796946760987559d47f1ec5f8cb32fda55813155dee04047a92615afa457eb40a4a1ab7a3b21cbec9a468d7371eb0226dcf147e276e91d776b55f79214903aee90154c3a6b6d68c2c0f78ab3cbc8fa17c59f6f1dc10a8ed91c735138cead45f7c62332ea8c5d5bd7060d012f898a0157da0fb31873b34cec6737ab8dcae96cbc8a557511d1485f747a27fa3d1283007147fd87927b4201667a93922be425c2777954848985612e92fe884cd29e10a34fd6f46f2e125aad61164b92b42df800f3ac42fada4aab07d6028beb8ff75aaf4a386b7c8e19d36538f7852bde7a8f718119672691035e83156dc62be37a2647e2fbf8bf06750efa47771ebcae86e74586e1bf78ceacb8dfe48d821b4d44b8145b0a3ba5a56e9fd332dbfec70f8d1ee6ac21a07ce4bca30e2c3d66adec43c487be44a41491b6ca1d8d137e4b7df7f79f44a6ca69ec8ea42b5eff17e4f4c937589699f8b4ee9ef510bb6f8f02b83878352486bc87e3f39a64a3e2670a4c9cad9744ed09e629c8a9ad5607b461531b8ef85c83eb454978d9e8bf5a2275f945979a2b3135dec34ac3cdb70dafc18f287eb3d745b1320be85f877067615c1857cb21f013dfc776bc5c20aba90701e1d2c04e81d8a0270aef901096e6f761209bdf2a1561691185edcbc4dae63f2bf76dab49d7a06f57517b55667a5d348ed3348e8dc05668c2e390baef7e379d6a61a33109774a7bdbedc27645e79105dff1b3f8e7675c86f1aecc76fb60f0778764855d917e259a63fd823df807127a8f6f204a4a04c83f5f848b76f1e26487c417e6a8e039e676ecf70d30b25992e985f62c9dc853c34210f70aa77a96d5b90671ed7dae73690bce6a24399987b6f8807ce69ccc6286dc305e21e6bb23acd72ebc09ad2da81b2f8dcd201f070532d86f6139a607fe8117d9e34286b4ffa3550da8b400d5f5cda050bf0ee5bd71b57da4d3aa1e188085eb548a45eced6e4f133a146b08fd7bb5f43070b982fe1d770880f8b6200472a971d79009a2e3a8f8dbdc5e7d2c7661cd5d3a3a7296b48c30397b2aab11b5a702272188667c2ccc3ae7828ba58cb76d483e111c837eafef83fee00f01a768dca7fed63140355b2abcae8b9d6f928a925e661b98f4140940fa65631e0eefb97684f2326d5c316af8b76e37d9dbebece4b0cbe418f1df9a94f66b8e62d2c662b4e1c1b8c65136a2bc8ebfa2a1c8c9c87f26f51a616616bdd62c5ebc5a294c9c794f8d3af6e7ce621ffb340512dafb652e7d856402c581a9c7da31de3e0135d1b36912208c7f0e771067ab452d936bdf5bb35002ee1102672e8b0a6f7e41117d614cf6c7c47b510468bd6483a0600ac27d783c7dc73cbd0f6b8d8f97cada9f29c86fe2b744a1a90ca5a8685c8858ad50046aa47e908de6d0df89c4349cd645c8922d6e1d0b9c31c2b32023fdd820f17a442d1db88f20c173f0b19ea2519010f7eb2664789ffa0dc3ca8d55f2841e2b3263c4fdd5a1cc8f842b5328495897cb4cb1e4a002788e3388d0609cb0576144ada8406d74274d4afd2816acb55eaa4e4b2f62db31a043073790b459b66a00e9fc2e15703c9a6b36845ff6fdb12bc54ecf0c255ac09673d5bf8d246085c108a9005f5c12ef59642e0f49e7017a493d078a89c847e35df982f93e366716ec9d64a18ff3fa48a4b9e0c6618ec01327ca97abe9e4d8e08ff983b4a7a71575b7007e903eb0ffadbcbb5ad6daecf5290385793d668f5a0451d25fcbe60644a422516a424a361f69364aa25b89bd49706b2c12394a0f72aae4e2966329c4ce63099672802bb066214075a7b8e64669111ddcf7a9449e3f72cd67a40d795c05838a2feaa5f785cc95522624480a07221a9907d194eeb88fe6f3aaade98a72c59406f6a32c1f9adca7c0523c0af90a20bbc52e24a56a91de04ca4e635de99e13dc7fb2ed0f02dd424d590fa0f72432d2a2df17bd1375b7a9544878d4b56802198e52356f54bba3cacfc29c50bb6118a16c5f167cbcdb2832dcfd1c01088b9916a15ddf203a22ea67dafbf341fc8b9fcda34c5d4cdadf438e9d170f824140e1c20a703bbe892e7ceac2faf3468353107c96e13143d6050f330c54cad7fd93a8caf20b8b960b19d0decd3729e611c86ecc5872ff56e80f5d5807b700b67df09570709d304a34d1d62e63f9fee3d586858ac624cfb0ea6750c512b7bdca6dee1588e7fed1169937356eb34b69eda7f73440caecb28b5d7a1ae5e185b088ebe2a1340a78d1eed1c639947aeed3db1f659339091a934d5d33a34dec7ffa494d17ccffcd725972ec0ef29ffa9bcb35fe87a82077bff76732a15cd93cca5a29d8a4e7cde69dc73c373870aeb1e320be20a1514bcda97b5a8c9721d4d0a94b255888545717212ff33d09c4cdc6a060ca6a7df3ef16b6b2b089b26402a4768728af4c39fdce481ab4a43ed80bddffd81e70fb29f20e7e4de14439b68db550659af370f4c2f0d45ac7477e36334f28cb538d7eaf5bba169f4880e5883c7655cf59800a9ce6b7f4b8461cec601516bf6c58b296d102a867b4a651715e93beefe2bb23c95d1b0c19898c2cc2f00f38be2491b0479288fc558107e94b15f7a5ca3e02202a75fcb9e04e7cfd6e630bb15d190eceff7ead1cc20e2dc6e12c34faf875cf069af4fd38a6c3c1bce2daa5fc1ed7c60c4dc407519b4cb3d55b17e7e5a931816b2f5aa4fd474130ba34bb71cffd687f96f7c841731b53f442e3de8a7a67958a9cd9f64c1c5b2ce0e1e4df7eecc7894489acf633d1db80f062a28fa31169d3b9f81a887c03ab99ef94cfceadfe57252c72116f080d143e28a98dcc6308ddf9e539509816581b35db51f6f4168bd5915e49f1b32e69b4decdf61b8f29db45e0da6d4beb08db9586934c3c948a0878e899d573770d9d64f7912ea4134ba19d7bba56bda4351919da6d84b1df74e336f0ae3c92c0d1ad3f5d71b6598cf20d1d1b6e63f29771563620b944499cc16d991d118fd7ab73f1c168f2b5719d8aed36f2e38d9662ff54db3e07f575284c5588c99277a2c365bf720a35226ee33b0613531884075a3caaf4c9013d7024a30c57056c298db48ae26abf3a58c98f501f845d01d81c3c18d7673f7028bd8a1f2b2039dcebc46d2dc8b5ca60f0626eee14d341766fb8b05e4ac2b065ebe5c404606848722667494909eb61e5989f953d0f824498f2035f4cb5ae0fab7a006d1b8e092b624143c9dd58ee627fdea6c7d67915bf1a38e7a57a352e1cbd8110528241ca5bcd4e500cd4e4aa595145608c1565cd69fb8b26a96b38f608295964488c54cde512761f4ae916fb5b24dc6513d5c92a87068e0b32c2ddcea2606dde326067abb864c4e918a8b39d2eb7369a84bf5dbd9264779564a67816cc799e46449165a893da723231d8a1337fb090371bc746ffe7b7d311b21ffb0c30a95dd9352a5ea423eddd836f5df57f20b6575d7f064ea9b7eeac18ca7a7138de9d4aedd3a6105bbaf9536e00c221d0e62ad6a44173c2ec8e24b8fb40289960d38d0a446258e8a053c4b7e19c3c38a4f78c88bd2bb0fe2ec73b6045cf4919336d4a90e93fa9f2e7a14cf626f2b2b907ca3927056ad58982230a89d2759f0ece5e807f063fd2324b25e9d50f86e5a821fae43f4dcc293dbafb9d2123b62d0bccbf7bfe4c2962dea5788a8fddad183c06f13b60471a4cc7aee30f95057d6e185c4b565722fb53671bc0f5ef4192a013599e17e9ab8a1a032dee027ee92b29dc6b6f246891c779d2305b5b2d4232d76b8909ea816115fd4b2117d9c024b349018eb0d4f387a0e8d9f1be8045547a57e4723adcaebc5b634ddb9f752f5476fd51995283bf20142b10e823ab460f2e74aec09f335d667e1d23721a1bac9a7b2722f95117a5e4229aeaaddb9ad9f3fbe0493960edbfd0bc946f3c9e9de4472a1e4b8e70363e8f2e332f5c25e8ee36ea3e92866406d47981f7465c1e51228842c190d52cc34164b17fd20171a3ce9a8b65c25c163a9c9c7e9568929d1e305371e7db245d647a6a7e1af304e5c8ba3b19552dcec11752c38027649ebfe3cff87afacbef8a8af776a32c0c41fccf4c679a49a3de471a3b9941afcf4a72f1f443e0ae452ea151502d4b3f921199f126482d3a53eb174a36ef190ea15d8a08c715a5be214feb82fa0128e10e05a7434985a0880d1464795e3ee080f74d44829ec781d8bff578d5a9b8f3b9271bb0030c6407590f7dfb087e33dcc227df975a8e6f28761e780ff081b934645f68c498e621ca399fff97cc5e4e121336e957699c1ceb7ad5ef237b5b478b6e7be7821b24b48faf9e5b89cd6a27e980b1104504b522133a2f3ec17f168ccdfe3a298d1328ba24bc92ee31f61143fc20d83a6df449c0be4b8db9b76f6d18b9c12636d6dfbe72bb58646197dd3c2ee10fe9081555721133c1d0973fdce1d28d43f6a8ec51f26bfe4874337533b37d62dbe6e928927f04658b47498890262d678c69361635d952653bd68ffc37478b130a714c7ecffc68d7fba6c1e4294c91aa3ae7206803e149676853d823b03455a2888d9042382683441c967993db0031bac400a1824d173bf43c1a3f0f17335035d388feca3a2b5ae558e399a76b6ccc401cdce63a49b27622e2da6155a94293891855663a29b2b98b9422e99ab70c3569520fa4e26d9321f221f01d27fdf6c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
