<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d7f6dffe6e87d0b5bb7cffba1606824cc5dd27d22e314fdba58d6d1e8422b6d3493bc41bca6e1954ed68b46377487068f7add0ac01cab259e1e5c33f1ebd83ff2dd8fe67298653d87a24f9ecc17cd4f12d705eb89d1340ab3c846debdee005147cf8cdc72dfe8e140c8bbcda102ca5e24cf2031adbc37b04a54de177d3b7089bf2d4cb57af03b1acf7ba72861659bb5debef9653f43285b34116f644df4517e6eaf134dbcdc01c5345004e72aa631a3f0b1added39dd1c6a291ddc611a503effb07d748b7c40bc38838f4db7e41960c5c45e5863507286753e15c1057495e15110b3e1e292e35dfec6bc9195198669ff94f1b8e76f9cabf27b96984526d4c7a66006c84b843e4e045bbb3f601706b37aa4594b7b6fd0fb2f0ca2a439d7e600b98993740c11c82ddec13e95aee31238b892414d0c92a7c7b969945975810573375a429f1d8cc5a5915b93bfbba90b9f486df6844c93a24779e3add60438a06bdcc1ebe2767758891298c3a17c9144639d72f216dc66c42e9bd0f3ac588945a4fb051f682f6d044b1b3620a7158818b6299ab1d3d9bc07f2247cabcfa855e39a7678d79b3c3db092dde44a0f465e33d65bd5ba70b38ffbba278ac66396c009b1ee8afeed7f361cfb0f5c3e3d8a1df845ae41d9e9f0986f571e844b038ca968f5b7ee7b08ae3046635b17e4346828d4881d8ac54b657541c091eb7b4087137ca138fbf7d86f10bc702da4b2fafb90faa6ac3bc2d45b03f246ea28bc2d6243f0605c91108535a6fa9cd6f4890fdeb1f482754535b27319327fff74a200f605ed6b26660e78a190603c2ff62575c9d68ce2a80bfd441d4ead46b4e0548b54caa1d23176a364667e75d781e17284487bb0181f30d51e6e65a4623f5312f0be4b83a557748bebc950689d4819e61fbd3a01dde4513ebbc056d16d82e929fb82c0ab062aa5c37706112052f647b0cbedc9b6c1c74cd6b42fc65727fa52dc29f8d456d1a24fb65061f6778f17b397f9b274d642e9c9f9ba258caa0ce2160e51b36d5385fe6c68fd1e607c1766857cebcab354fa76f46de9552c2268bc6b2367bd018baa0b9252ccf825c65c53e813216d94ad1a8ce396f939b496118ed780cd27089a1d330a362689def9ed7b810182dc4b2b1d2c07c6f9f8543a136703a1cd38d1d7477f49e11d46a32feca7d3c026ec73942481f4e1abdef943d3c0293183a73db2719fac359134d2564e59400cdfcc28d31ac5b2fc069df59ad14ec00fa56aff1d08cebb9af58ae874d5db14f6ca026cb99ce882fd59a35a61d708036996c9f863c600629c17be14a4cff7881ac391cedc53a9aeeee1cad1eb12ecd9c3867f7e43fc9eca9385e8bd862b66d3844fe5ea36c888cb7a8757030f72b3605d279f64ebdcdec5a0c2252d84624cfe4ae878e043872ca52e723ee50c57ee9959a41e3c0895ccfd2bd41efdcef1f93ff032fab963c89c82284b6bd182784845e8620203fe7d5869087972bc1d5106c753edd23f8400d005f335bceee290660d76feba0686d26a40575f15831aa725ce78e7e9a80cfdcdb21dd64636b914365c6c3f4a4e0190736b67ca971a4ae979ef5a3198c6fddf1d2613aabb4040c9ab6c2c2bdd59e1feb36406ce3f9b3ea8e49c9ddbf5bb20eb5a4257927687a43a10a21247b9b618af28bcaa97d4e3425c2b794b74ec6e7aa2bef1a99f6033b84f4c64e9af5172346ebc142a0c9daf73cfb63c824adcc139f46ff1e413ab72a8fb17bb6168eb830450498ceb6d6bb019e149e96229880dac57e6366da58d3a163e302519f6a6532b3847813b25abca5ea8f43345578de8254f2312a866a4fbba66224470bdbee8aae5f793acc131e8a19bcabb336dfeefe88c096b94f9bce8374420f9822ac4f694f104c3ed71340fe5fd38b641e4423922469ef57ebc10a6b903a70801df2949b2f1661173374ce9c8d685e37eef752b0e339fc7929a497fdc21e4eb47cf35fe2c4247b48809af0c46e75d7354a47aab4eac6e6e081d0fa335fdc953bc41828d63ae33d7f7b25917d8313899b144ca64e87b00859b601cab025082b86e866982c3665b562c095ae705ba3b89b6da020f4c5a10c2ec2b93ee2d28b808820d7262d596ab05e91327b73757b602b58c1540b17017d33cfbb32cfaa4900beaec87e39160504ed7218754a56c8b05085bd36a6c6d3df7d88cabc8b1f3690d24c00be20d206adacaaf6f0c5d128cd05d17665c59846d5bc009abb6a75ae2a77a38fb90fefc6cf3635f7b13c2a8ec786468a57becce8ad6895d4245e2e46b07f91a3f0075600bd8835fc6dfeef2d0ced8972857fa56f6c58da8a06e38f3d06d480115e6bd702f30e388a7d912153e25c49ecfebbd0c46707bf3ea19b585d6b3dc3bcc6cd3443f9200dd9725ea259866f008daf18946fe04d29a3e445fb267ab891522a02d25afb786db289dbb1bebaa6a9339009ff3b9e59ef4918511ff53c23b4b7bf7f97edf122d1aabbf7c3c5796aa90d3922da3e1804f2e7510cb1456fd4c2afe7b6fc6e5e03d5b65a8ab3723a8762dcd85aa9d9f622764cb5251c341612e5ef3d8349f4cea946d2bddce9514065ac7161b75d53847e2bf471b43c78b6f829e761618860935a8cd4d65449ef7d24d739c98acbaca2b472d1ddd371ce4a4a75c2553c62cabc64e2cf3c594ac068d3b835ecc5f1d33764914995577ec18e5a6b40a503a7652b2cfd7d9ff9b405c8366d99b220e4ee290580b0b0220be1c7ce19c87cc1b2f00eaff74d6dfc18dbe2be4aa01d5a32d03e46738cc6e4ebfc1403ad405c69cfd236264d425f14ed2b8665bc56d27a39135cb45e77be196758c47cd6df5ffcb3212d45db334512391ae4fce6392740f6b2eff4064e8d7a16ed0b78c1816f6ed3c46a586d824354577cc39706c94c32e903bf750f93adf6c0220dffaefa555f858ea709bddaf076f99a4ecd1adf7a944fe19fb547fef91e2153b34e3e64a5cfc41e192a8b431d6df1a8ded180c1a20285e384f3c8e7053b9ac60ffeaf033e3d8e05815d2a7aaff1f1c851c9e0a4c787e37b5a5e2c89697b68899ac43e6717ff5d7684992d1fcc33593f327bfce9a8d84080888a86e589618f01a3fc1fadfdb36756af01ab390bfaf9723c0c2df4e66a887587270b6423cc54d38b8870d6fc3be9f64006d1c49a6063eef65513dabd72e1f8d5ab9af44ba474d23fd4613e85901b5608d93adfcc5bfca2d6fcdcad759a266e26d0b6a77e5012b04f7d5fd3c21066e1d276d17be58df4e9d6b7b2c8787d7a82f11485a2a4aa8e1c6aad73103f5bdcd34e58387fcded799b2de7cef01ce68ffbcec44e72f57b46af403759ff4ff7fb067d7a65c8f28cba0034394c9e5115af707376d9a3c7788054d36921800272730a4531ceb7166510493d5b08059bbc6a08fd9b7a1867328fd2549d2cde4859b37b34ae36deb524c80ce1ad71a00846367275c05f3a07b0a6d772df615ca00d7b7bba1f803535887fae03a9d8edc04f1af36535d6da4de6613550e63a3c321ce53f3cfafd9747f1b553aef31c3f19e09ada3242355a3d7eb46e95ca8ecf07ae71a0b9596bf46fd965d19b4db9bab9a3e58ea115b6ab2db890ddfa5e4e451f72c2d8685d56db35f0dd4566175af4f4bc01d72107a8f175c16d5c319eef03421c358d571d005ff9f70caffe6ca61213542ae5aa98643856ecf4f16128906a9197976b25efcc8fe2677cfa615c511e5694a09d4df01603fac2205a3bd880b48c1b0e6f4fa171d2561beccfc811a79e0fe43ac94387ff02f56be2f03e3c0d61f49ee6c75f084931b971db3cd9bc3e6202ef65e838c05dd35e3ffa59c099b83505446900626711e0aacf53c9492ab39b4b705ae7b2c7dc3b5fcb9ddce26c42b2499f4387028aa69a996a5e6107a430b359431343aebc3184a13255d9ee7aa46692787e02c884cf14e88fa81d6281dce9e5c16148ad9619b646c1f907181027a1e4fea7e3ef5eb6fdfe46b53f78f94dfbc6c989979dc65df406b04ae1bbd98273bd8694bec8fe17d0faf0030aebdcd8a7043bb67b0090ed0b442ed72594fafae9640688bc55752dec94523d4616973f27c185571c27096918cf600b5a6c434a4f43f41cfa9c2bf063ff9cecb3a970c844b28ad3c2474a73f992d5829197b257c9030a40b536a4f2875b8ef2b7fd6f56c970abfeff88e2e886be6ac49801d420e303d4ae92ad65d09fb6e4116e2ab7a25e1944a4afc214d7ee71e12ae925aafa33f757bb038b8891ff8ffed1787a22206004f30be8c9d7be038c1bbb68172d8bba2815f750e9301aae6b476c54ac9b468e0b9586b6ac57772f5ce9af88e012b63c11d6272e304c1a1659d3bbbc1a63905e812ae89820465c83b1a6fe09f553308b3f113855e4e261dce4700721af0cbab0f94311296ca0afd63789a51fed4e93f1d827b6687a78db048e675543fef5cfb63122d0c8ec96de6dcbd8754f3e7c2455f399522230d035fef9a8c5afd7b1dbf54cb6880fab01aec215673b47ad07e928ad5937c98dbf25622358335028ea4cfd3801893cadc1fed9f560b325e907c7aec1db676e90ea380ab7beaaefce3f79fd8d165b353f7bf373bb180d1f8c256b83e4861d0d193a5e1e19637ffb54c6e9ad00b9235136a9a0e8346c82dd338667860be4f4480c93fb926f9334e731c20aab94eb0c8316e3eb86ee198582a36b3d3f76af0147ab20d612fde841bb6bbe5845d83add38b481d2a8e854ff372a5efbea0b9725c5601ee439e1ff1b02198475ab93f3d65a652d09f2111ff2295b62340af6839a0a02be71f3eb7317b5e4356eb1e4a60a9d34465f412dd15f76d039bf3a07cd8e5700eee8d3ff94e95c77cf853074f1ab901273ceb580f6cec4167934ecb72bbbea0634ca5d6488c96f02c2ee7edd3628060ea4883f352123f4394d70b2d34a98e0ad7ddf2bbb750169a2c75468b75d7dd4bb63f4cff7fe250a34123737ddd026f5bb2e37da4ba9422855c1ef590ee8987b173d9ca4674fb52472a4d6f7e60840604f1eb290fcd72bb8b0e94df22a7fb9e530bcb8b234f88f543b1b5d3871e4e8f624f57aeb0a0f3521b19fb7d22a9d11bb3ea52e1288707fbbb1f78e1b5354efba775c8eed90a3df7ce1ff6836c201ca1e84b8f5590d884e5226274c3cca391cc11230425fbc37b539ebc653de7f72d4581791c8e8f89473af59f8f501e91fd45365e18099d3f255ac65094477c18150c17541d7856f861ae73ce46d0cb2cfb51063566795c31ebc8211d05e15551948228883b86e2ac6e216e461aca1c050f8d947125da284ee41d23b98ad65557165bfafd44f14826accb1c6243f910c9b5281bb45999a56f1cdb3318146d164d23f127f18d67ac91f3dfba41cf44aaf432b9007cae2dfea66ecdd371ef6ecec51321d36581d7a3dca9710d0c319103a2ec79cd7d5aa9a2a6416d9b6ff8e3b0d45580a949f49eee4dd1fdc184c61056ee9aefeda96673a36324480b92866a73357c5ff6ba4d5a8748b11d07704066e0fc1dc8c64971a3b05425d73a85a3f39cbd9ec0821da58cb39da4f1ad0475d41163744b1bfefb49fef6e4e5d047e047a151cf075a2877e16b9e7abd59301590d03203f9b424b0cc295238a077e12e0f5a96d8c0fdd5adabb258b5a098aad1e8bc38db034e31e0265715d1b5b92a8b6570f37c5f735f3285705a28acab186b55d3c0f32825bdc75f7193930ab9902eab9016c1ec7b8afb79b1f86fad457e06482e3a9b6a21d343037916ab3e343bb0bdf06773f2e6106db4865d66ff7468320e21de9607972261fe8ecf6201e1892e2b759c52e60af1fb1dc5704dc1f4091951a890778f6b039e7869738def883fe5b262d4227fa129872285b8c5f43b2f003c5b977faba507ff262b2ec5d8757727c7f4478dfac1684c54765d69bb8cbb64776966530c9ad67dfbd211cbead89de5bc91da90fe64cf6c45885f7271d7c5f3255d4b26a2869ce98ba9f989d073688a6aecd1ca50e808af1ea947c50595fa39d8ea7ae4c14c81767b5954c94b3afc9533c7591c791275a99d81ead83a7653b54d5eb41c4c9c534f65d1e179056976999ef66be691ddfa7e4a7ee7cdff9fa03f4e91e053b5b4d9df9b00e8da5640b70111c1b4a856fa3d6b06c709137674ba5b80539b7e420817c4e6eb7ba7b14e00ec4bea1d3dfb714a1bfad9990f073d0fa369affdf6734d196e5acb7560941df65c49843d8fd368e57369fe8929965b4b20be6906e58fea090a04140750919a7d68b014d767c32b18ed414b778c547cfc37ceea79ffa56f2e5b468024d4916c9e8e611ae16cd16d708d3980721bd675e1471e2f03461e5183816d7975cc6c4d193f2a9886a1f944e6d18eb31aa0a4c42985eeb2b0605654854994fdbb3c1f2c5da1f43c03ab26a95dfcb688684cd100f17d087a4d3ec5214aad07021c805ddfdd1d3a0dddd316275aeeed25235167b2b792f803200d074281d250c6dee0c833753de7374a439b26f62ef17563f3f4152aa6e53d7a1cb689576fa1e14eee24c4b41dab9ce48e387b996399623ee4a3fdfd3bfd3b12c2d7eb8e41de6ed85c4d446611381201074090f735afb031169bd1e40a2728d0483a2f4a1c9eac8c7225bd0dc7feb9a8620238fe3231f3f3ef8c1d2a8ac63221f77cc0d604042330e6469b86116d68f7ae5dc52c041f6816497659ebbde6ca20c19d3fba12510c1d1997fe530e182b196c0ac519a5cd9506d2238a62fa4d38a9b9a356557ede2682c670e562b7ebb86b967bf16c058a6bc5e451e0a872f5ef233613a4f3096d6e19c086f08cb5c8227bf13c3c7ab7769586edc67e7f4ae2c7ee40641597b7d113658e6e31d6578166a73e552a1e26ae387e1e9bb9993d803d5d2b8c5eaf987a5beb3dd9f63855a6986fe36bbc6ebe41f8d9025bb2065b434544211ca7382a9f7acfa8825268304f628032dc64dae487f29a21abd8598c3c49b26674f51813c786e2d145321359455de7a63edc35a64914f5ca5f914a787eee900a6882daf4b173de058e5753f073f07ea96d86774157006c8e4e968be735a1255f0ffe825930828c1cab17d997b4d09ead9617638363804c670f2854cf5d0a8b63b55a00ec8e573801f22c99e6bd6cd449e6cd055327f830997ef18f5ac7b91e39484a4a90c9e283be05119e72ec69d3ed7ed7709ff3ba318f491c24b6ae37baadfafdd353158f96a786d36f986537a63f898d83966bb5c7b87a20ab4c869bef32bd328c6cb510ce9da6d8be7ea43049a159abf7211fb7388cabf8dc9b807a44fbc6d7ddb03c5ddec2424a74fe9d673e934db4eae12529d2af8989bbf594c2258f5545b4cf883f46c6e16f5f9b60a134a36c3ef2dfbeed2b7a2b67f19dc0a5938bbfffa87f86841ffac1e2002648b7ce160d3713e26f49132fbc8aeb8806b6293fbde4dd80495345f814f85dfe38d66cdc551262742f193b5d48bd587ddb4f06c16f07f8bd046db05a78e1095559e69b3939b8f5ed49f6524c02d8f0415c529d3d0ce35632adb27df17446177c7e6149fd84bf0ae5301c0e82ccbc02cfa156ac1d51cbe766190a557de255acb9a4242745478d7f1c95dc6218c4c13cae73e3a3d1ef68381130f6eec20436524f43c4de9fa9bb604a505bf354096d12d4ece005fe25b5107f0d80ba800e2cae236e5e34891f6517de7b1275ec7d1b752ff1843702de68a66d0525557ee00a837844f13a173b69853bb9c52478c92874b6b7ca4337b06454aeb613e05a0b5812ec14479075c824f646c4fbb42d538086a1bd2465ee5663c5a8b17648217864500409e04e407e008b72c774859ec701a653f8b174a9d0126b625a11389a293c8a50eabd44a1ecdf79536b1e985d660c12685366a80579ee3de91f073b286a9cffb38638e00177a9bee9e1327b22c54b20f6439494fd0b9e0ea923ca26a73210bdbc0d1571eaefda892ebb39b41c21e4f9312da14717e68611fd83c31c8792d747cb0c8ae9b91a2c7ba54d16986eced64dee8a4bc2686ce4430d20eb86fb888a1d22f164816cd6e2568c781c21a233432585f366b818f517884c145ea457b9279e5b18e6015ed896fd3681a9bca37edb29e8a1f58585ac1485aeb861f86062b30587405a371af0a53c46f07a67a0063bbf07d0392a3b930d6e63afe3efae43669115dcaa8f49b5d3259416f9f785dc3374cf3f3a841433579c4309aac6987309a7a09b0feb8f48e89ffedb0d9f9eaf9cef0552f069c8b5b7db52937bf46462c6ad15d2096b100ca2cfb7a7c7d263715a67c286902ab650493c9a93722dc656ece70a2b5d840f8fc53ce2369b2419eea93199bdbf0f7ed732d8467de8127facec09dbcdbab985e18a16def3a9a5bde65f286ff001e22509e554d0b06f0b1448e1feb783426cdad9e98def40c9ba2ece7612b04652ba40b36a7c5947e91c3c3179503dfc33313fe78d09611414e5a47358fa8c5b11211cd3772115a6a95e65f130478e6c72ac9709ba2072fcb7f4dd70b610d44a54e405d79844e3fc3215dc8ec2855d6566e79900bf0526b3e849003d5c20942fca5915a4b82ee163bbfb0da9d7d8e36d8f2dad2d8603cfde59d387753cc79e5c99991d8433b66a2cc4ad1ba6dfc2dabbdb13848e6a4a1e2a742df105f718cfc337bb61080a6ef58f68255af52be16b4730aa7a5b51ff3d72f261271ab0daa08eca581b52ff20a00c31d7efb145cf7e482f3a077c321d1f440889b1433648d543d5042ac7545c18ce3b3ae76e5e5ab42b4a34a6e41ba456113533c159006b59b0097a1516a1afd9390514518cc953fc56b9d0de073289c680488836cbcfb28b81fa9decd99770173533aa31a850e51fc8ebebebcfaa111a600c2cbac5a7d9f80882986bc37448b84098bd4f0f40ea2113613f807112593c91bc2553fdd9efecc17500bd1b73d4ace40cb92bc92370b8d41134da4e6e0f9daed0736303b0de546562cbb09ff662728a9e5fcf30401f119d55b7baa010c932b1002adf8b967bcbf5698b0fcc0d0542aa0b5aa6e3907b95242754fe741686e05749ce845afc32ee749ea99fad9599bab462e9befacc19ac55b120e496a78064f36f10313196f32a9e92183596840663b936c85a364831081baaaaf12c6f629c19fb8ea6b9fdd85fa741a69f68344862317a44e28fbf0fde896938903aa0764c7952df7a2b9c58aa9d6da6f92ed660257d3d3c7273e1534179171ab4ae01413c27d25da52c9cbc96127664007aa1f99d71431541b1743de495e659cf6bc7b573c96077b0e5c35b2862347b6270f3340d2c575910ed588bd356fb02602cf1c064456c373093b86e87e30503e7e9a56db3a2b26ac9be8e1f16528aacb8542aae9e892f8086bbd8a052f7ccd98ac378513e6a63d33a80cc8ee74799628f700b948e521a71cc992b813d21f58f696b0399ee56ebe7579bea8a5d53156b5fca400981704b9e6cc89ab48fab786e94f72f7a0f019215c41c558527844492f2e99a481543e49451dddb704c733ef9d6b54ef544c4d49fd4b57ded1bd7e84cb144f89e199d0e3baf64d3fe5367667c0ec05f2dbd6ba3aaba6fd2ec4b2fa874d0afcfc94a1c68bc5f6afc7b453e8eaa92e0f88c35571fa9665e946f19866dfc9a2ea57ed73134119c2e8bd4fab313bc1a579bec473977fc2c95cdb7ede4e0eeab919163891287e723cf91fc9d17f717625d34753ff24e1d9b493a581cea0ef48502ecd5666dd7125fa6fb12de4bfd36cda588fcb9160214a1c6a800ff206409e70cdd18a308cc9cf22fffc996f83be6e1303d39bc154023d34f1090d416fa13f8cea1ddba1c3ec975b9ec93c033cf487cdf7a9d5d66c80a5ff60c19602308ffd8b960e00e1b6ceeb4a555a1261d5344354902b397a856259416654b4404df9c0fa53bb9ebecdd067de57be03a27ccfbcfc96ec2107d4cdc45a47f8e038f933d41e90e7ba18f57463d640181e088549c3316130bd9dea19cc5a31e352398a04e9379ef27e6dcd9dc21d9c2af9cd94b5c18b2ff6b6b7caa8e1729131de192064b1a08c5efa689ba4d1a3ce146000bc3906b3349d14fe345705b787232447539f0c872f6bebe7ee24ec4eed6c9cfcb874de5e5839f5904e682646a3ede10daad08b8d1fabd831a85fda721ae64a01ec53e5df13a153aa26143f224f8cb42f265f8665cd9b4d91677fb1fbae21f80362f046ac4d7c3e4a177f43cd5da01f869bb093b8f44a5908abad8c3c5215cff9711d5c3ee2556d7dcc79093093443a82964689a200e5a55b7aeca74f4a094a6bbf34756d4b7c1016aefefa62b6573262d8fe722102aca07faa2a8b542e5795c49dec5381ad7ead112a542050aa1a00bbd1e33fdc8f21c090ca0ef357f7858864c26b60c3fca6186747a4d47e4c3316a1483ea8fd17f07cb867540d67960a25f65f559c8da95bb7a9583de6267b912b3848330407d6383aac859c5641995e79cabd8c7db8ce040efb0aed14d795222c6e3f8cedf29a0822e6bdc515f1a7942ee5cfcfde520440c35c9843edaa4cb4228d62e6e94f15d156218cb8f06eb6a12a81e98dc991cfdadc5fe6450010c2abc0db486b69669761e9c7cf262d49f2fb9ba5eb54992aa62738597f700ca018401c64048d897766d204ed1f311ba1e72806f68cba148715885ea7973872e363863bf4e391655c4f4a44dfde9070c90dc69f45d97b146a077fec06b8c12021c4a3e04c0dc4c10c0df713e975e0aec37cb9c16c553ab62aaf18e7223d856f19c005e29a2c19444d856bd4d7423d578e9d882b81b4acd6030cd82f3d321d37572956e5675f174680cc6733bc092273acf8e1e7d6690fdb9c1f001a7cabfb7e0926720fd4350bd3737e8af6f2003056bb7f7f2cb5854de645ab42c3b42d909f01e2baf2b75c0dbda05f08042dbdd62742c4cf70472ae9998dfa4e287c7c3ffa32ad3a2fb93be034440bc391f37d01209848d5c3f5fcdd81721c2118277491a37d12b3b94c51ffd8f1ac67e7848b02d0b432430334a850046e0d55de588c379cf7c0d44100eda9a290029fedcb950163f240118f3d88ceec723b91fe729b0ecb454acad4478a581e65aa21beb7e8360068f8c669f153129ca2bf8acc11174ade4ea9f5aafd7530e143cae80b3d36abd7d9de8d308924c69f654bc01f37905cd245cb06303142b6ec653e8de9f28c3403c6c19441635de03869393903bb87aa96de568cd1551fc86785455dc589f44933e8b705a36a529f39acae467e1c3a86f5940deabf8abc36de77f5029f728d892170714187d0162e93f3d990fdb885611a0c83767e1f11215f42efabf1def7b113e395c67d3d52276dd1699a2a13589cec49aad46b2399f4666229baf81fcf442f2a5c90d6834ede53badd04e2c9eccadc36994a0cfe9ed2ee8643793eb3755851dce5e4b283f84d195e71ba4bf28177e21caf1e0b6695b9a98acffa7e840e30372fcc2ac9ea212b793a06c2ce341c05db2ce16ea5f5628496aadb57e04ad28b361b25aa68409b7782fb60f0ee06c5f667bb3a39810936ac64392677d7d3f4f51537d7de8b414f64e974350ee6d3081a85ae7ff6135d419e30d52522d27fa2bb379a3b49d865adca72b80411d8eb40cb305506c3b2db0b49f9e1684b3c44605effd7260854547fa5b59afa0d5f2aeb70497f460bdbdd131c1b20fbc3128601700acedcac974fb67e6fd03c62c27cc6339b303c08a472c58da17f028de65770620071ac0a4f0b0013c9aa55d97068e23d8ff5743a50804bd6746a3490df8b25a225e173eccb848225f65ad6043eef46dfb7feddd46c9734bb73441af294cc6c270bf2488c90f9e2c7b8138e26e131ebe443dcf9e6f2486459c9cf112e6ce36f5c2c33c937bdf60dbaa24aa731e35267e7ac806e9c31e95f3cd258240230c642af87fb249f6dac3ffd7d8fbda1fcc68f4be33a0f237a78fbecae8aad427c51bcc3319944ae05c8e0b3295685b386212c677a70a9284f5f8c86e7c7697531acdce808cf547725d71fcd564dc655c420a95cf5595159a57314c06f38f8733fce6f3043ef893672c930b08e8190dd69c3cd9f16cc515e409728e773c76102e4efa0828e2385b7255ea4ddcd4779c8d77de9661e600f337fa7b1bd6f73cb4228fa75ac4e646fefd2a0c0e7c37bb623525f5543fcdd21e92df36703e88f5745ebf7a21e2fe61a724c2a5b6f4c3301c518360f9a954c163f2a10ccdde552cdebd8b6a480e459b3c9b17d594cd69da1da0c72fc24657e5870e926b7ba0809bcefab31643e2498ad9edbe6febb877398f2399e51e82feb457072602c2228018cd05055b2819e85aece7c1b35ba621ed58c24a11e2421ac51e191637d4ece5407161c8b90cb1baadbe2a8d51d7040986b2bb202bf2d2523a83ee82c20f4d7c0866bd68d5418fe818486cdbc07f32d4d43b172811752f8030323a67e1b905bddb91e6e0625626545e09d4ffc93dc0f36e3134cb0c1ab875bdfcae57e0029b4a7024168057f83c00ad65321577c04e57fd4618273a73722c9836e0ed91a74f73929cd7c1a0f2284e706623baef8f2df3692b23cf79b47025a396db468e3d527a360ea375f40bd9b5270e1cb963d151216ebd76971aa55891c6bc55c1396bfedd0089bf948d80607eb278a6b2b8c222d746e3aed42654aaa491eb864ee044f0055b1619e6460ef15ab32bf278a25967caaf86d063afd2119d93ad2c5fc642d4ca87358490f1f122b8de80bd46130d86c30efba808fc8936debb559265c610c58d5372bcfc5ed3a7646216f6843206ea5d239ef77014dd0b2bdbced7fa9afeaf52a0cd50d1db223aba394a0415f7863086f6b60f4e24c5ac115e513641d19be233bf8ac35b645410a9a8b54b06dafadf45db5a45cbd5f51e00f78bd08018a728dfba4d3f7b9136ec87ceb45258bc36516e156b3f4e2111004744cfd32f3e1b1d09f23acf6889258849d80e5d91e291be798cd898eadb7764b4b26da6302849edb331af4fc867da183081a9e2bacfa9776e3f40998764735a1b90b896e743eccd52ffabcc63b02dea0b46cf809deec4a268bb158c3bd8764fe2849ce3e2bea8e28062ef03863605deded5a70bc501acb6d2498556c0bbdbb98788e4a5cc793b03a54ff0ae7bc964a110353b4205fac6187083412d01f1d442784b8cbe8f7cd8668dd381bef79d51c67a7f7c9e097a1e03bfd7fd2dc8270ede5e8a9cadb71932baa5731d854a0a80474b0594bfe4bb2551a74822346d6c4182891fd535440a791dc9ccbbc704f5c25fe3422215752d1628e4891506cf0656defc600f041a35817af7262a211cf191ee253542ae301f48e11c2c86f36b657369fbec7cddf3e7eae574a75e1dc0bfad9f3632f3f7f09edd9c33d9244c5d3baa354de37cad6133a7eaf464d4df10283dd3fb18fb736ed0a11d607f71ccbf8138e752a4d9f932621effad1a92aa85fa7d7d11415100d3021db26fc9662e3af99813e40b1174081c35e007429c07488c72b9c3730639592f01119bbd67e52495d0b98fadff691400da2d6e2f66564f17216c48f890e3b67982d0fcc3b2a79ba8dda4d4ed156a38693e7ab20535a6c7f028bea7d94d5701e6759546ddcdffba4f4df074d3aee665f61403196cdbec1c39867de663738a1c126a54a2892712cd10e529fab3e49d15c0b9bec7b73a9eecbb073c2044ec5a91c0a48b01e908051f8cb909876d634a7a01e52a049522540e12f3afe21865b2ec098bb80b1b28a21b26f449e6ce2fd43c7f0165f13dedc06f27608089738f7a030ee956daa5e3202d7e443c05260e982b2c681875fbf5cd7bc91559a9cba5eb7996dc780b16f649232e50ab7a7b690d1f18eecc08120d840ea1af42223677b576099ae5fcc8f0396428aa5a509e29773f70805393d87735c772b37f7a4d75bf400c696c65a0013263b1ac66f54d6116a04d70a9d517ca948f1defe5083ceeb8da0388e6fc423be9b324c36a702305881541f183fe1379deeb761117be1c81c727e9beee8d63aa4038636d3ff7a9df71147714db05b7ccea12fa94fc8bb97fa71fd3e36652605218d39e3452e6e5c0f3bb61835a14e7c82a88b3df6e169251fcdf0eab9c28c5ac8683e962ee67fa88c80419e1018331621dfbe843bf85fc302f1bb720769469cfa220799bf98b8a1525bd898e1509793678d1d4acdd42990b1171a4f6ea57b20cf509476aa49c1a4b81db32a53761ab93fa64366869b77da11dcde742a8e4f91931b8cf58c8e69522e96a0eb4476627586d9f7309dcf3ef09fcd2045fbe892aa2ce2b0c28ff287e398b458f2afe95f94a1efbf9e126964f84ea6e836959695fd40f19b489e0dd476119160a8f61a3bc79af59e69389d7fad75fe620f46756ce54f1e4085557f465a1248b046d55b9be90e9759f4534b61c13243ceefc2f971109616e23de5c172090c5ffa350d347fd56350634eb69e521dfc06d9314260328a5f22c2ed5be8f28df1df035ed7f73f8b3b71d6af9a5b6ea5e2bb6deff516fe0be67dbaf072ae8f93cf6d61801104ef3917a95c7a2b90014b76aa70e20b679f9bbd891bd0f6a74e4441c711f5db86c80fb27c76639401a71d7037882acbf6850a6b91da3c33050e60f37ade3e09dae5bc06bc43e6b2a5b21af1195f5362916299bd7de7afecbfcf9f191df6530c7188c3716445f08592a8751a081a6422350fafa82fc0b08c472a02ca4954a39cf5936af68ac48944b86461b502912114a429206693ba4a4f24c34d88e04c6315f4b7e401e63731bde54d2628a47680b64eaf91be2f8bd15ca767ac18ff15b648ba944ae95d47f4ec09bbdeec06fa997f5d23a388b3ef6efb6b52f461b2a444ee322bba6d242f6c971ff9bcad5e858a2a8631af0b7ef72ee5ff95dbd00b6668f08fad7134e8364e8bfff671a9ad33a6f44d194cc102e01a9d5fbddcc466c64bbab3025a13ca1a2b22d51f3e8b67f7c09cdc69ce32b8a44c46867db46e1873488c99b8f81c05b3564bf88c9eed437e23ddc5d88c88f6eb4001fe242bb30c52eca37190b68b4331c3371d67d9cbb681a6a637cd1e773811c4bfa4f7d992819143264dd468c635a6a1a5d53399c23c3a25200b0623409ddaefe485b208ff69898923a952bf767afb9f82eae7c58134dd73bcd18ee0b74179d5fb5405ea3271b476f83682a24c619457621ae4345d508c7fddc4b13b00e7e9286db0d91626023852e308546ceaf9d2d773ddd614c4ebdcc06aa6203788fd4f730214db468ac909be221d271d61845a9e7100e647ae7674a02594a01d84d544f7625fa53b202520af164d15587a9a7c012b6e2d72c652d7966e4f2d2976c90736357eaa11bdcface94f72778ed1756fec3b5528754991b81dab38bf3548ecf989465eb0da308dbf2b569a2d770ae9fd2316facf618bdbb9f7ed8b5f86426caeb9903548738bf437b0deaab45570a2b0e0288f50bdcde09aac022b06f52c3c2d6d47892aad4d9bec03a15ecdb75ed2cd79ee2d91d88bdcf4d590e77be66926ffb9c0c6d5f7660ff071f74d485794815b40518fe3e943894403180180bfc43475c72ab036057ead4a58fde543095c8da77c4beb25e03d0b858482d04204f55bb2f5e40f3364dc4e1846c0a5c3588c11f6620c3d6a759d0c835b4d8169bf2a5251bc2c712d21ec8a7d9cf717504ba46983d4b327fc120ea27b567382f2e349d078269ba13615071b7cc02c0146dc329528535bab97d37dd1b90729e8241ed67e1c4a543e02fde363aab7360c4751f982e02a0a4110c64b635effc9166822872bf79203a587f69184f0145e2ab798a35ef2271ef929525fe67acdaa836ace9bfc04822e3bb3974d5437192daa71316e26e2f481b60865e5c0aaca5017c779eee627aa26db0998dde2adb707d792a522e9d1aa5e97d64a89253aa7e4c307d5a3cd745ceb62f70fd3b50bb789778c639e3413c294ac1b44bb1265d01772ef09a65438c9e9489ff6daa95740f70d262dfba26c10a06780acb636d6ef212a76fc24676d0f2d55ac6ea1fc8c3ea3a59233afcfd833c5d36c4dd511617048ebd0ca3ac813e168353ae9c586386ac89ebb54f155480f4cfce7b74436db651f10709c936b6f37d4dbeb990037ef8b7071e2d8efd591be018447abe60d5098e0a24dc8016b0e455d15bb2ece5998b571cdf46d5292274b56854dc71d7ea32bafdf6efaaaddb81b2d175991f52cee6261cf61c5116ae1aa5563ad44adcf0cdb08d6092b696eab5b56e9b2874d9c4c8efdb844aa64605c7080746354ee2702abf5e8249d5c82f42d09fc9f57f1fc12fe6d653485fa09a3ac77cce1d58606f249f94541d33586e863f4ba092e0a92ba881ede052ec53e20fd95a0b622c5a162be49a27ba5184a8343d48e134accf1b55c71ba697ab1d255347b4822aec098b94de06c46d791003e02e8fcea11f6eadf37fd60f828eee21515a19f607c3276cd2eb5e2e8987674a49f5f98511c5d3757f2ba55bca63b824934903b5624cc37b301eac2020a1b25f1476f337df4953af025d5d0b5eb53fa0fab2b0a28e0a5e90964ecf1612c3a4eff06332cf500e7bd3269bb4b48049e2c414dde62e356eb977db960b7c1bf85fab7c524c22e5fad3b9b75a6e4ceab7992232c87290b2308ae0140f09a38321c6a28e5e96c39281de206d9a7cd4015adf5a15c04d9032adfdd47849e5d7e7a02ff1d38bee09e4f283e31a084517d953559530150af3abdfdbd5ed7557bd809e3c1664feea4aa8acff8b851950d156bc82659d49bc3266a973d94eb901653a75297a1a5860b870f9257183d67c23d235fb1ef470bda5dc53fc2f2f4c69ba310addc0540655f1e55c66ab061fdd92e26910b38fb3fb3b522a866f594d1c31d0118cd105707346fbaca75b0304032b00e705a52a616df0edf3fbffc1be0b0512c1ea0f706d51e2f6fd641fee2eb4ac7f948759d119fc50f27edceb6801f6ab1847353504e545bf9e1ffd39966ae2c868677d8595a2f81795d976378446c8ca40441d5a7efb0e71ff0f08e15967a7f46ed24b4afdc9c3b68352894edc82652fa9ad006c6b78da4483b393c1ea217f1df88dae99e2a179eb461ae842913b07f4d42d83f091b594f99f684345ed3ddf8ca7f3da9a4234692e20700ea0c62084a1722bfd2414a7a6ff04e694b6fd3470aa1de882b6b6735dd5015fedf111e0cb202117b5abcb523a246fbe456330da5862012bcb721b2df7c45f8acad1bef4b4c1cb8673bcc0ca33cb09efa8704498bdc2e9181ebe92ade1810a3dd8d6d661f9e72cda40a1376c122ba84b2159afddfbdee12a1d408311dfcc59a2b759f8a5cb15a9f7fbbbf4cd772c4e8ec818bad197a2f13e61cda1a1a974996bf7bb8047165d1b442d0e3151116dc095d53a6e4430587688efbc8425bd97c7438ca20b61f06425ff7b2ce3077d3ad2a7b72b4664ef4d3c27555405858f12262e553149149c7be8d241415fd1c56be405baf9fe776bac604ca318a4748868dba6b37211ec9dc0e6012f6f515feba0098fdf462878ddc158fa70a3219ff30a8adcb41b12b416ea7030ff7d4c234f8317b33eabec5686cab11cfdbf53b34c321b8c31d1099053596ce6b2e3418c682ff5c4085d256d4f4c62ffefe06fae529652cce534c5ab0e091f17d5acac3c77aa536e3fc163546aa79e904f2b5bed15deb9e633f8aa8cff64f712e57912b044ba673028774e2204b15e64d3fef719bf6f91d0024e27510fa6623b5ed056a622cf58cf6d4cd5f6f55a2ebcfd474e6f3f5061dd2b7b80cc4a03202fc614b7537680b4a441cf614f61dc1b925e1dd3bfecc58459a956be18c10bfd740b3986063fb0bb386d31abe22815fa5ceac1c3b2859d9c3962c775c5f8dd3ec2efe91cf21c50fa89dced1c935d47223e93273d568650b482cea13a9d7417c778bc0945bac4edadfa831c4207a3a4a43382e7d22f4090be97053e2c3df9c33c17551fba38db5c4a4ee3816125c02de1a8f67295cacf42fea3d8ccc6de87554f92122ad1c7f7d61719421cead2fb3b6127ada75f68a001c684e5126cd4e1664d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
