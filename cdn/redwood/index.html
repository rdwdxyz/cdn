<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82068ca3455eb87018cb1d0226b9003ec1f457f73ea82acf3b0b43328cc2c0a07707421be4969713aa59e5d7dac375279fff1fd685bb8f90025cbd95db9668f72606fc0ab7e0dfbe00cf712b46a140bc80167c54ec3ca3435082ef57ff1cb761783a4ae88626db652bc4a1839e732217c0280839732454a4249796e5a3acdeadf76913cd7c4a5e33ccd4293417c6d7e8d25ff2448f2b6e5d34a224fc763924861a9e89e2276620c064836d44d2c8d20604e2a76aee882fa7bda580c57a4ae2099c04539f916568a0993597acd45002874583f8d664468c43b2ab966b26648f665daff40174ec5a827296378e86589d2e49a0ac4b37ae40528113e38590b8bb37e8d3ef927f976dccf26671505ed7e3757fa98854763f6c02a9f96b7e0013ba181479398dd924084c2a8fe4d3e8eb1151cbd920d02da06173c5ee975645f1b809b1f16b8f8a7ef8cd6f01459f4e41054900bbf000d318d5a629716cf762764068edbd52412647309de898f7a9cb0779519e13dec62d86511531b3921ccc93ee2155813f8a8b4af89d1ca57c6876aa1cf9028feebd91af173c75d6bb730a7e97cf66116a4340424f93fc5d286f0a7f7d5c92cdd7ef9ce7ddc1f82ba0c9c0ec29e44dbc459c4d16b593dc548db6505cd357d5e95204ee1d5f8cf9647ade665604fae5b8dbca209a0aa0fa5ca1a086c0b080bfa3abd2e8ae4769a538adec709a4976e61428569d4fba393c4f295ba6bddf510acc66e178272fc26303c9f925fe07ad274930b0b113b250d2dee60ba84f1ed88141f00109cef69df5dfbbc4ef22b559686ba41993e507c92067585049c317db152196a840981efd1874301112e1892788f6c48b0b8be6ea79e0910289783627ff48decd8ef1872d8d53a13ded698a64feb91dad07aaab9a62b130782311e1d8f3cc750daf3d2d51d00998d9a76a07d1922bf1d1fc2eeae7544e1d6b3e024a6b1ba86c4572d688565566b68a28a2e13e80b51e0a439b929c149adc71df0c26dd18b3ab0b77febfe0098dbb92b3fa20ef3c1091e3cfdc1c231509071572d458e3d82a55f713a42d1ac061bea0688d10c177b60be9ecf168b3f6e819c7cb660c00a67fad6929d53486a0baeed8949ec6b6def836dbfdf8bd486cca152d03d119c85c8ac42ea938d3a2fff619508366bfc99a82f206fd02415fdc4a91f51b1b78da79ef6376dd032a1df32034ddfc0393a957678dd58e9564d6e84b715234772396ea3543e9b8998e3bc535aa8d3db891d71af6e19c1d271f368a3b43b6d0fe93768fe4a8cbe3dd98dce21638ac6e489d729801b18e9157a3a79ab015c0a810fb67cd5c3234d4a813667f93550a5e43ddc4447cbe7fee33cc218fa6aeb022d866536b71240fea1754232a58fa480156cef57e17014ac9fe170018623899cf529e8bf0a9135a13ef7909b41e4c13ffe8e4d51d3c17bd253a67799a8d9ae4d583ceaf2f2ff7a68b9da18c2cc850a78895e920b42ab0992155ad3ee1858ed598da48a309e746573b8f0c01b07e4edce575764e2b2cfed548c7139d262a13b510ae0d67d23fde308892626d4379b7eea1a16efaf9bb71bbf24889442054ff4a7d4935da2a9b8f111fc3102616afe246e459d1083223ef60177af42420d53b1364da7f7658c5b99a5c9b32643e2efc87602a48167f9ec8283b6488394e96927ecf9d703553a0680d97196e4a55b4806f0d8363faf494506e9ee621d2c0b351f01afb5e1060d74338650704091e43886e5bb5c21b7ecf2411676d1b7090bf017a6b2159c3c220af1dde0911b1bee6fe8e9ec1549a6c8e0d57a27c54fa88df3bbe7eefc4815bf3d7aff376c08282994c9f8df5ac779396bb073d57b39ff2bd9fa1c8f951d31c149ee779e26ffa96867bfa6d9368c2c19123b6d7889a72069796aa4c30ce9376517155561f55d25d62cd9a70e74291a82ba76a920339b1482e5693b17bcd2d84c7da7109deaef01a3263296bc053545c7e8ef8428aeaa3b9105f1e6b7c43ce785615068779d324f3782d8cbd641910942fb064c0f5a6f1a8c1814613daf4eb4beb7347a3409ee820cc9c4a9e73272fc04d2fbefd8073f8518e2403c80661d8fdf7b2bf6f67cda0ff1df717c334f90917d61cb06a93cf6251277d650af5d2b90479b7b90eb36f260b80dfe1ab66a00dd259dc558f1e9ded7fed1c33e9e6a40fbf0021a64913e72f69b55d32c6cc9b733f81d59da2628e2416c7ed2d01c49c277af0ebaf226d8b8b4cc6fd4f11c6b2dea90a960908fef4ac4cf4a5d232540269977370a0b6423d765623afc6ca9b19598d3025134716a5fc74be1ce4d2f0006ad170af0eb0afe9194082d4ca328066227d39ba5ce0d2b16428d00932763e26498bb85766a79cdea738aed180ef9367c5724e99fadf755302f62acb73309c96ef3325b0ec868bcb4c43c25e22aaa6ee1b1c7ce8bda678e1eabceb45eb6b141954324c4336a6e66940b440f74fee149650459006bdaab27f18f1bd67575cd5cb34d984fb43e996e15c51d659b450cf057c0ca1f9fdf0bf420df742c8cb97d930f47776ff6866d923e55a6be7779361b3682a8435315b8692383fe578a2025a9c4fa944e7e943435e987a9cb49770da7aa4350c1e7c2068f9ac9d423b34a28fb26aa5ea2f1c9e196741ce8b1bc05e3ca0ded2de571fbc75b9be28afa95d63b94719a9b1024b77f28bfd02a8d5e5bbe8f9bd9596d79f7269e7f515ccd4929745d767c240a2f044762e7a3384211045230b441df738f3f1e1f193d02b7bcdf42a6949200a5b3dc0ba12a99ad2b60727b4421d41c4c6b32ac49db993c66f183da28d7758b05e49fc8e52fc1e97ea4e00780a8a621b91428871a36832299ac425cf053535e31e4e28dd933047b3758ac759fd1509bbbd802a6de0534c1a8636101a1c1ede0e3c2f32b01050e8c4a41e95990d583b864c373a9aa9071167e740c9006ef96d22d1eaaa2145a16cf64e8126049236f23813f876818100c848c3a36b5d8794d5f0d7e3f359a731471a4b070ea3b7723be29fd8d5dc61338f6156072e239b447c9358b7f663555f783c7f423d17fb7d60e5c8845fd7867060f0cd3766a8e93a949c0c8253234df78bbfe58a8c1fb2d2922f536f89ec779bbcfa1b4672cf79c534b5f8110b228f43bca3808969cb476f0b89b376202985bc8762d3c0b3ab5c3d88e9bb00f6d80dd346e3666ead0739b7fc26c140121d62e4ce683c483aeeb63efc491a99a739f98a506e2d5d14be044394857641742432ae40245e5502cd52c7c7e46362aba4e6cf8b087108d382edec3679273ad50d0838b88c9545a5fe487f9c0a20421844aeee1bb0dad3947fa178d7f03671c19dea2f5e83ba2a825aef2d8ea79edab0f199d5654c479a5d2542b26d5a5a2abc0deb41ce373e0c593bc9525b46f5ca14fc4ba7c7f3cf2763d040c43e7c51358bfc1a0bb937b38249d818212d6b01dae670394d51e0ad026d499f8b1d593f71364692b3fd33d5d3a807da89b828035487908c060abc21a0a9bdd0f248c9d698a2d3be9f198e849268c8a666886f970723a70b027d7bd2c12619c66240f3f794510b66eb7c4243c271cd68dde3d167308f4ac75068f80b3f2ee149accbac2d4d67f11176fac1dea6247872d8b838988b543863f0164bbd3f1bc55c6eae97c0b21c8a3ad118b35cdaabfcc9c23f72fe52e2e7dc7c3c6d5ef5e76896b1f08ffd993c55362392efb7a5a303c25d1d0eab431ed1745b7ab178cd4010cc4d049b99d70eeda3376a4e336b676a7f468c05e08ef8ed205173bac62c0d205a55c7b28b6de66db41330a7ef3f9c34108c9457a114a872e21ee06cf14fafcd0c4e7d4474c987e18e9d33a4e152161059c0b9edb39f49d23719b12896b555dc65da6d06699a21b66ad139846b28a1ae5acd73f91054cc4a57ac1b6713fc811ae63e5f1048b2c3741b2043abe34e005b5e3d909956864e8f39efe662eaba32dfbcc6323412ddc5d2f95c8190cc610962ebc3b94a592081e870f6ab40f2a847905c7127fb924016282273b5b24fe25ab2c4f3811476636c4c4d16d8daef6ac60f30fb70b9bab5e8c24acd1a4af0fd70003f0fe24e991c291ca84e55236561da488fe7424ea7652a91e30bfd4dab412c156a8949be5997394b9d7db91f19b9f2f830175ce3b8bdba5d5b89466670c87072b8cf53cc6fd04b61478e29aff54a9ab227bc08a6f776e44c59e58e17ec5740ec1a3e13e0fcfa6147c314678fa3eb17fafa9e99fd5b74d2721560286a28112415f3cbefa2f21491437263b1693727f62eaa103621c5ddd62df41b9e9f0b82c94e8eb8eea5979ace1bee1993795f893eabfcb094dc6f210234f1754936dc9ef3d4a54a6828ce1ea708a312e21183738d300681a42bc82b959056ff390acd7941ed1c320f619dcc5deeaa69492a19d78ad05ea1bec5fed848119cbda8ef7166afbb2724d5462ac52a2bd6e24b75958ce606685a48aa713548590554f244b0ac2e04017fe6608e321de8fc43dfcb1b8797ac065bb957a0515c232b3a8d42e939481cd0762195594501062370abfc5fc44980647a7f5307b57a910dfcab8ba66e232817e618d12efe6ef0d0178e21142892961ef8ee46ffc584aac11fce9b3e9017417b422e62f85f18631229b82d42a3f6dc72167d1289defc3ae81a8b79117ce016239df638bc450b218db1e8f86ee19f5e21f273d73170e2503aff64d4b500ea8e8204f29bb80062bd2c04839cf6bacb6ff342d6dc66ba7438daf29218152436adca5f0ac87fda0658fbe4920539cc81db44398be4be98a89251a83d23af8552184e1761a0f7b9eee9c858986699a3a8bfae40b8cfeb12eef6fdffcb348edc7cb8062b051e0c3698677b430e370ffd1962b70a7984117d49e6fa6dc747661998f36124e818dcdc6ad8a92b44d53574ba4d670128187aa8bb020caa90dbc3b31fcac6f5442becb4f047ad60356c57b220917047fdc740e9c348011c51379f9d4f31c4c7f81cb6aa043260a5d86bdd5331a9cca7db707315dcad0f7eacb9ad7f0e584dad4a344380861bdb679ec633b91cfd45c810e4b0adb505795737587b2a71c8fed9ec5b280924d7d1fe3aa6900768ecaf41bb769b8a4a712f0ffd8ab33b47e47eee769784a6c9a5016850c9e7dfdd3bf35266fa57c5da35cd54074cb518d8fca5e91217f26895ebcf2b6401b5a82dfd7b14c1d7b8fce6a9140107cd3b4b05b5c097de9bbd8b89fe470c6a57dbe9c71a984ba193163b1004e42f8284a69161ce787632eeb474ed6433f282054c2597d11d84ba5db826f7a728f001f97892cedd382ff6aa8422a367db13c643b7dc965d56d122c2b60c018b64dfc8b301ae96c2908287bad893a12c5df491dc14c959997e27196a0f08b6f8dfa8e3e929bdb89f0adade462a74f87b0c0d54b5e7b25ef4f5c253ab50f963b6167ffca6b13afabb076cd660b9803e007c8b98dbaa434b73c7503bbc4934963411f9fe3b1d9b6dac7a35914db72e67545720ddf0e142e846dc49406606e9010056c746810a42e047472440957660f44253ad7402344f07bb4800a49cbb3b04ba631e320ef9def54276d5d03de954c11ad167c7ac57b9bf2aec1d1f05379d515ca7ce44dbe93132a00b4b6271143013bf5e66a951d4751f71d8bcb7a0983775b47c437c773ef48e84bd1024c216ce2a1b4b48efc1796a4a82d643b11f6d89ea3f87f93ffa9d88a41c903b0b0e8c12813151935d06a6592572a28163b359990e0dece2e169e83110b73dbd841165883cbc77ad5043783fa9410bced8530dc4f294c93638ed552931ab07ad26ae38e4cd187a8c9903dbccc2d733fc9ffc11fc459d0e6f7745bba304779e32bed9853662dbde6b127b27a52fee8f2616182c0e1ff19b17a4046dfd9fe08b1e8ae83e62908a1ce84d74b34ca6918a9fc9ec713356c5049c1872c7279879b90123194156daf8fb8ee6296382cfda5cecea8365b7ca9ca7c290414a769cf84bc36fd5f8e87bfe62c6fac283e53601d0412dac41e0916ab344c49ccb51f5aa6e789759dc96b9d0f98966fe0a88621cb38e47c2efbfbb15d8ac28fb27064892af9dfc1b18921676e94778e280c5542be47a5f2fb4598f46048268ce8ab206b7355216b58943a6b43c7d94405279158e362ec3a7eab473904fe169419484ba3b4cd53387f56db3d869e7e95bff5854afa134dcb9ecb1a45c0500bcc032b9c083212f1f11a500c3bdeb960f2614d231942206f2eb0436aedba76b1520e72a08d4a53d9afc04c6aade02e174491ca16f431167fe1da12a7ded952503017d5a5ca19023ec50e8f182dc8f57223fa9a193bfe64234df02599dcc3ed2e2b77abdb6be129b55b4736b818ec1e925f9b095fff23e628d288afe5367de9e2766a57df638410801d1cb439c7ababae778ed3bb2e3e1b915e3cbee74f31b98c5d18c78c3e064a91be498e8e36c26917c6996aee712be4a966a18c67d14dc86d2c48ddf7c412dea5644e119febe175a674c03b3f7df92dbe00de979c09718ff8d2643c32921001c68f98a9e023d8bfc9714f193ad339d8fcc467b7ed9c210dabd9086364b9c41385539a4e561d94d5f88a22b2e79a610442eb9797d6d89fd01496e7e03d96ec0fdcb4b924371a16009994da279684508902405bd77bef94d8efcc0a7172b23d8f066f359727388b42b9561155b0414f6ebc0c91ca50522d8b5f78139c9ffc138a71f97ef920ac5012e9a94fbf2764521e25aab8ee3e27a2dd9dd2db25c871b81ec9f0daf217608ebab5a2c58dd917e2ff655d2ccc4539ae17a658eae5ba363d2dd876d20f0415b9dbd5a8dba0b6645a095ddf41a38c3dad3f7305b5e0e8915b0471e1a867b7743848aeddc54c496c6ba1f8de32e7661141ddb1f22165caa1296f07704374de98a16b53cccc0502f4614d54d94f3f1506c0ae7409039d004f95e244b1e4a3327df8e1da2395f46caefcbdada91e47031cc9ba32d387820385c91febc0b903437da7742acb54229a83199965a6b1ab8118a0f875ef213c7b4b351395931c0e19d45fea6546587d4bcbc818d9a981141036171effd73ab40eedf8ca9d53b457a4eecd533221f6d0c4837f8d0470c79401cf5704ce330325f4706670cf031ecbc41f9cd178b365979988f73cd68a8c2a5f40a6c07eaf41416215d8b62ea47c6c94c6e24301978506fb8a66e58767e03ec656a21977b9906974ea8e1fc42180b8304836a080996cf06bc35e022eaea1dfbbab10d8f6188fc6897da3357d823ad4c3f6fa61524c77d46135d81b06c9ef2ecaaf605b7c3011e7ab78b25ba71ed52706de2ffb03b367d175ff6526393677c0299288c94f493533953ed20b4873b404803ab72d9395e0690ca2aa3c3335f7321aefc6b7890b4aa8f0d36f073a974ed8f3e56d82e5a12d87a466a51677f55623db9ca9c563c8ca0442bb15beaed48aca59b178c6a0c5a4e6177b376214c7d8e52dc3016866f1a49d77af3bcfb20011f732f64b4fa8ffd8c1103948377a232ae7dbed944704bbc5c5052dd6a929103e830792faa4149ce2111f7cf456a09df9c67d361c646291ac5c2f3feb72737838ed4db878d0dbe75bac1c06bf31689e5eb5c68dd85134068abcdf97f84d6f12e91f373b2876f31bad6989e5919d023515e766d90ce5af003ddab1e4a90e85e77b54957f04c26c0f0f7c8681ffca4cf33bfed7e14c55471a5da9276231047e5b22da6555569c2279ddbba23fed29a57351ed9edad5d5a7d839d1679605fe6e1d745d9aefaf861a2163a9a76e627414b669b3c491042d3c7fc49531daceec473cc53792af23279bd1d69b8cb94d28dfa0210811d2f16bde4ff98220a4488844217c83afb18cd04e2b97cfcdb2e1ddba3bd42151849c31d668fa0a2823ce5778fb6a12dff42b0c75a1db314d3a6603abe86655b5fa713364562ed91717957593345933fedd415fe2fecc7f1e226090ced1186bb8008e8534620264d274f09847447b5aca2f2358b013abe5524b4bc00f60f955f9a7e74deeb11461ed1efd3effd5b5e4ca9726f1d0030822f8b3f531aed59b7317ec2a1909d288dbd96e28dfdbb98ff8a3634cb1a50b632203586b8e5e024a360de4c87dc2688cf54566af04a7e71b79d849cc62fb8a8ce909622bc059b7bfda9cd000a8b6e79d21cbca2569f4e674502ae169904345c8ae5c925eb1ee72c2593bf92182b486f339e5afca9294d3b17f4b285f4c330c0dd752dd840a9a0195d837ce6662c20a5491458ad25f97be1e9c295a42029fdc6ff7ca8917301aff385287dc53c5fabc7cda151238346457bd6edcd7ac785a28bf33b5e5004b553ee4ce23dc24382b24234883fc8e48e61768576bbf8bfc37ef6d39bacc51e9c9ca8119885480dc96afc52c85ba0118d35d678e6cf0613737a01cc225d9f27c32f778e1980cb684d879fa0b8867d09d3ac98d30ba0121d645eebea3ab7d28b16d407f1dad0388c4c05c7e17a8c6a87839ed2aa4a64e1cd9029e20cb0235665ad4609953c91e56b993de09bd6493c449d10d63d6a2e870b820b13fafa4ff3d2a6e6762b5d4b8081dfad80a553fd32e330e81f0534188a449fcf997aad119d0b8084d63ec2ace46e886567f903e1c7ec73589fe4b007763a8bbe3504fadabf4ff437ac488585c73631725179692fb581cdef18b56c7c7fa8772c08d5aa6f64843a0bcaf7c18ee2a9daeed9106b757248e1bd039c3b473f4a42cac2d0e2ef99129ce410890b854a33deb28420cfba4c767eff41de5e3bb0508bdf4c18c22c05a4e8467c56b90a0f4c1e494b3c9f261516bc41fc4085f1684ae748be20e5e5c8bcc32af41572d952b27a46ce5381dec847a3bf42b51293a569802e1e46b5a4021bc4bd4eef2533c4337060b53ecb9627535d511b9cd9d2d227c232e0d87e8aba4a0894a1f9840640e9edef0a76a164a932b674895b8a3a1c29f716f2e98083cfa654497356780e8337009027e6b547513c09acc621794707cfb70159d38b588a771c37c8e7fe163c6bdfab0036700fb5e5d6b4f6f6b3190fcc4e02ce1aa1d92dc3e6338f311211e8096064d5cd669064a3c721415063af5faed12986d0ba23ce2119d2b9a32ab0d2375843fc67ae727eb622a7576756764e9cc4fa8e8a2b213f256f2526c4d4811c4245540f4de2efd76fbfa20456d85561d303f53ecbdc0dca02511cf94cdddb7b7cd8381569f5232710841d5d0e83ed92e7637946770024e1eeb103306a2bbaf13873966c9932c3eb814f6b865348260cbeffd38fa100b0331eddbc2d2e9d4d9eeb3f235175584f11d00e288e2ce12ac60f7c3fe9218e0593c1f5c4f354380d3d770ec91cecaaff3b7482318b11c12967c13291667dbe5e01e0ddfc04d0af43c4e37a861e0a6aabc3a1c8c677c2d8cc65aed95d8da888a3f11a31d7dbbd7b966c99feb0dccf3e2877f185105a3493c80c2b693170ceb422256cd6760d0ef8eb574fa8930e7542e1f9d0a9cf36a58af0afc584972678cee9af60d1cbc2e2bff7b7ffaaf44c888215784993d5b7a2d7e5042f42408c38109a7be21baecf237867d91a39730c58e59c4dba71739663859b78bd343bc01b276a5cb3e2cf57ea3b5e2851bb8bbb3a87bd77d2d8c9865be0baf20a4eb40c31f7be7dd0bd24809f1c00098eb03d139a76d9c95cb0776aca82d5c3ae62367960bbe34746ab4f40fba8bf2c62baff6008b5d5dca1a3231514f93efdf2f216fb804db85c2b073246aec3157dbb37c74e39a55bf532f95d256d488679a503b5ddd819fa09e73085258d9a4699545ae946a9e415f60cadcae577de9c1b5fa7f63114c341aef6f2fe762603ad2d8385d109b0795d8d6918879c3fe822fca6ab46251e15a1993d8197da7c3a0b9a116a76080ec2780eb9bb40cde8e40f50f23c8e47339e77a4caa92c5a5438bef38265bc8d5fbd9ddaedc1815742feb4ade226bf5ab40a11f15deb1130954e7c326e58f2384555f3806a23f84ec38b5fcdaecd2fec77b1580eca7f23d5aa991fa31dbf2f1e5647fd56d4c8c54740f9bb13cb74aeb6995b10034f25571cefe59254b09e12f40aa10986e226735107f2137f4330188102ac1aba798c697bdcb337cf4e51b7c75ddd51ff1ca107d2670d1a49dadda1de5c342207ecc9e3aa0db454d36037fe65c4dfdcf4e091759abac2bf1080400c04327f8856aa042a4e559df223caacf7a8b11988fae13d5bbd14739b5d5a8ada3799067407e6e1a3fe9df88c3fdc471773cf442eb2adba565c0d1ba370c11a5df0d22d0890574cf6142bd3788b763980cb1be410f87ed415e9683efc941964dccf808ddc3517a0baa2a8746abb4928096cc0b1276864f487218fbb14c96b7d192db5aa2e42315710c261bc8e4ee3c17a55d9989d724244f6460ed083487f3348fa065688e44d884bc3aa61337552e6bc9ff84cb59d9fe138b04af9c2f57cee46ce0c471871ead6eb4ec82311696b626db6614773a7cf5f72d8fe906ee662643d588806bbc7452522f3fab62f9f15a40c2f5f8a50af31ffd3050e14cf176760c6ce7ecfb3a9a7e7d8b10b51c6562a94162dd85a9ce13cfd3963620ebf977ed529b937a3e162c56c8e8fb2bfbbe69ba67b5d45c469d6dcbe04f18e70d5b2f69703b99155dfa5c3c168d4f997303189a4199b77c24547fe0732fba624ab985b1e0ba6a2019bd22c572bf0562bd4ef70260cb401eaf583043b8ba511acd06397f6d10340efc31ca576cb3ac8f2bd6cb87dfabf2155b880575b77c2f521c5a40c1308453aba9d6e00c220cae3fee860bcd86b15257c7609f37c28c332cff4e4d070fffd284bbe5cf9d2c85b8fd6d28b4195ce21adbc8474496496d032b72a1eadb2ca05569932a30917731c0ecea1278f8b5cd9a2ee8861da145f77c73ba76d9c2670bd4dc974bbb33be57510ec953729571de029daa8b13c5c96a1b8ca5e1badb1674d0014d18a1edf3114f6343efd3818df7e45727b4a8d0bfdb58b2c0cc779e0e6d408a753e4d569dfa1d5a1dc2896a5ba67d9ebd553ecf1fc88dd0673c83c5ffdf40e5b065ebcc62656934ac6d8381dab919211dd849a4359ee5f793bfcc641ffa52b3f28b4e15173816c716d06071f7c5e02022bbf489dffc36ab002c5cf04833767d059a046c8fea21d3b6c9c5949671e2c66e8140dca569fd9d393eec954bfe960a07d73a6341a37073033c0255ba8ffc1473d428b12c273df3b1b9cbc8bb808afc4d681b33858df3c4d048b29e1d204d164b946008cf857bbb7e5495eae401a16fc16e64efaff3d25312bd94e6ea86c27d0c6f9eaab557cf1bb74c388ee7c268e7d87cc521dcd6bf9d91924531b65029cea0932cb10f5664bf6b6b3d3e673e7aae7f9ace0aab4eac00da47ddeaebeba43c346d8fdcbda6f4638be7b1d0355508d0c89628ea1bcf636810ca12cb69126c2da50d1d110898039f5011603e8d9e90ebc1923c1244bcec3839f8e4b7ea6c80b7b4106fc5da90371c5b156b7bd3ae4c579e9dc287c82507afa01c00976051c36a86b33e2c6b786081b829f78a4b7b9739ae4feb51195e8937ea498a7797fa275c5f39c5ba82c5f02c492278544601ecef9e764b65d600d7b17e61847d6b066ae040245c0cbdf9a14d0af9fb8be2eadff3f54c38ea9dc9991ca4a0bac33ab649565e5cb8f3118d3e5f8f7be23b160a7843243d875a5d19fd7a33966c02d4de5bef0fa965dae17c0e5e34fc0f204a794abfffae06c2af2b2bc3e0bdb3068b1abf0850c005777c66143b6f4d7797b9184865c330edf76ed0f5500bd99db3d75be502304b14df8dbfa2fd4ce6da2d30734728cd851d31c309baac7a060912a0c58a89614d53e6d61e480d48803f6f61fa131d4faf28da226f70e49465a3bdf673ba091118eb9da67c848cda576d4cee4db19d4b01791f3747a7119ed9e7d35eab3e71cd79c54656ce705489b50c60c19c38cb77ceabd8ec782645a5c92db282940a8c50e30a135edd45d77629c72d5641d9c966d0151088ee25156c5cb9fd3aef347ae7ccaa4d4a51c534b1b28beec4d7ebfba573dee7256010607bcfd3f3259e638ae6a5867e99a05e46d49f19edc2e160858960326549b954fc9ee39b180c7419b7cce5bf296170dd131d778b4e61dcd5f77e67694bca59d49ad10cd2486956f3ceb2b0da2c62864c27584d8440f8c157a38acf6e2c5a5fb042eb7dcaf0be3513bb5e799e25262c39d15d2598595cac6705d8b66582e8a3600125f2d92ccfeb2d9f978af4802bb452e8aba07438b194e3eab6b699f2d54c095397f07b1e274a86b6f2186455a2dd18fdfc27e50786dfce9eaadb2555336615bede853462ff0d786fa81bf1e4566cc653f43dbff6f03eeeb77db59d81b1883dcc8e4afb81d397a9f2660df35f3fc43617e25cb8049f667c5870c694801ed83ad5d9872f1b66c7a175e9536d8d913950c65de114f434ff0eda7de0628c72358ea795c87fb699b495e124694f024d0174dff20965f98e1908d5d599e8c2e01cf458192bec28ae54f4438c19ef946e083b740b40d88b818aec2b6ece71dbf99e81c588951ca4c0eac5fcfaaf68b1858175fb6fb5530a0f20380fd887f0ef657f9e9e66bdab7ee67baa7fee2e7e641a96c0132bc74abfc59fe8c6ba2805075a0e1c2d04ee5e5952544bb018fde514ee6f95fb50472089f5db053ae93b102a05d6c5147987de7238584208904091b42dd86ceefe60b2dd0ec69abd629aa263d7e87cee8ba65ccbfee65167985cc266a626503028a7ec1d01f4595061ce58101f5f66e51d36dd8f80e89956b901b1bf8c10d5a97bfc60c3886ed7fde74f915b16bb5b76ab402f9571e14476179876074833e83dc938ece7ab0e1432cfab1c810c7616dfb33b4bda82010b0c79bfbbffc0b086aa43006e29a0ebfa2dfe27a2956e2c55f20a584525a78ea2b98019327d392bea00a195bbd1e40841705b0df82f49485c8361a45278381db524daffdd310009dd5ed88d3943b3c83d3cf8ba758726d17792fed7c968877903087fe3b0fd6944ad98bf600b171416b1420c1044fc9ade2028ffce39d34412130082370c983ed3b613e4537f6de5e77bb8f5fcfd2175bc9934973a493357a9a6c952cc39646cf86dd1d3792ba0d4c6af5d48ec2912a81bfcce17e4af88fa62af9e4c639079a37f677d64ab0f07c20cb3f0d80154cb6a07f1f0536b8f1a04c04e392721411508a1111e093eec1c5ad46094ce5aa85b51a8b2766b4697d9c0815a82a19534e5829d6bc919f8a664eb76169f75671a965558c882f3eeec0711fcd8305d7858d5702495b984c05eda973bd4f24a57d32a42ca49e355284a60c32c06baa9c4899cdb1d9ac5ed4dad15254a255a273cc950779109bf8469e987c3c7c85659546307c5291144cb7213c5f46c103dc8a7bb6ec6f4535bd0aa2b56cbd49f156bc2a28322f863e75aa408f2522668a8220b94292e5fbee4cb066a838582c45362a1675c45c17c609e6bb554e1f797fc7f67f84d39e1a8a676f307f8da4da9b1a9db89885fac70bd96a18c6ed59bd20bac51a4496c8ba61b2a66435930a815f0e5f6dfdb53949a481ecdc382db0241dda2c5db357cae615e5685b6298781eecf82a6bd712a4218521b1c31adbf415accc92fb1762241ac7a45b1b06b10974850764c50672c5c1cb2c986037afc7716ca2e73d23c1cb26aaa1678b6931bb947a2dc1e5cf5e2972a748ca3f4a9fd477311b2aeaa52f10f5ee48c3053cf83761a921e7d55298e84aa9474bee4040334e3a5de8b81e2ef0c667b28258d529f202a1f96cba19ccbc98f929e7096c04576b1249d9bfd0961787325991fc940e405f87acd3de01cc3d15006e4e8ec03655d62ed9a30c9d0777319a2d8d5a8755cf7b7d01ff89cfde722fd509e463ac00864ed5f1522e2e34d1be92d74e8ccac2f6617b1abc2ea2f6ecb60d59275d76c27488a45657bfe6a0f2eec6e306da5e3a769bf31a78229c2584e2030d7218e5255155861b575a34f26c6f77d87ca3ecb6fb37e97a08b831f9970e69d55e7dbe59783b8dfd57e29d040af78130323a88a22b714a7cff0ec92289a3b998afcbced17624c8c46683a94f004158ce1ad1ce652ac2f8a69c6dca7eeaa385dba366a445bf23a1a7925abf328f9591b23160a91bb3a4e46fba7fb216553ee0f4a9127c2436d007f808e0eaf95ed3f64b2c0bae9d94120e30b02cfe0f0ef6c394cc130ff52e85bcb0b75b24a278c3bbd891553ff18c67c5bc3d0dabdeea2455b5adc43d0549dfc6f1ae58e0015a6f488bc41211b794f336f3db38360fb8182c1c4337cde41a5a76174c4ba1e405e7713421bab2376269952bdb26630376b8ca50413db3e76e6232886438d163805684a6794090364f25225db7a79c6f16d3abff07b3286152c386c4298145aef91585e827968d94e0d80154ca8df6c966e4e33d3a59daad77917fad0db9fd5bec6e1d01a7454fa4eb634302c3b47c2f0f9fdbfc3480058a50c3fc4d24e9629da1464ca7d13f34872493b73bbcaf22024b03098c8b7c27bbb254c7a8a46c9d8242a0f3ccd2d690d9a04683f46be964634c168c418e8e57fd2073aaaf85bc2ac3bc8fa51229bd94a7af5ddf1440d3b2161bcd92666caa291a7a7b03955040101c4313553a98bbdd8711749338b96cf5c5fcd4bbcffc31b2943c74a4fd3c0b17bf3d688d3519e12788aeea43b3dfc70b9ad39e51e9839239aced54a9d67ca591829d967c7390bb82acd2f319b3a8f06463735bcab07a8d40f0255c7528abe040c148140dd2435b24ae816951184e641d6e0f291a3d07c3616e0a4f9f5e85322e5b7d562297c06bf1c209d64d2bbbfcb1d4a1ccd69324406c650c7c5011cc685011e728e986d944ad5c59a3a2a056c8b2437bb18a28e5889c467ce598be0d3360301ddb2ce6f909d806299e33df56d17b9f2adbd75cda8347f1b076ade0f8e9b3e19cdc567332bf2be9fbacd545326bec7622797902fe10eb07159985d6eff87f083994cf9f39e420939655a17769e8ef6665097cd3a9a47a3c691633fe69606818e3116ab82d7811c03f5fe2ab211d876073dcc5a99eadc04f5d261c24139a6b192c9021fa40af376ba3975772ff39414aaa2053f35601725a7e5e9fb4c532ca45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
