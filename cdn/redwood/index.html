<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9fec52d7de0503b31b58b9d889371e0c27e0896273ab03da7f83d83024127d56011d05eca193c168c1b5805283a4da6a7aeefc6dd166f358ebe1a2d1458b98a0ae5596a50ef93af4b509250f30a1dd675574735f36820cc1ba2caf162697a629f9bd8b6d8161255f53da5e17444405d04192cf37ab370e077bf87b187ff43cd3be55dbf1f03f0c77a62a5d6e54e69e0155c181f731421d5f9bf321d433fe9a1bbba6a2e1d84b3c38f90a24520ac3af3264bb960c06e396f821073bb6139bd670b36eeeb3b3f3da1d5179976f34129a81da9f3fe08213215d01618c5e8676e5ad9d2a02eb8a617ce4be82ff0b4842262bafbfef4c77534133cb71f66d4e77578e203c4215f00328ded5c14f3d813738e0a014305d674c53d7a7cab8867a5173a0bd18c4b78194c3938d3d85213c937b7d293ee8cf02edeb440c7cce36fa2e30e12a564bc617ac3b7baebfc58bd22a4402d6d8583e730c84b32b1951c06c91e2117b411172c929a5a0c297e3da656c91fd05b761d3182290331f0e48345b32e0550cec238de633e365f89329ec5fd79ee34b4a1e053f24c2473aec1f73f9022fb5303061a16a0e723dca5971e73b4a2dc1c8ef69016872c40d63f8589d7470e490e5025a5ef587d7bd50b61d12bfe41388c694061c17946e328ea9388694ecf7efe41ed55f1ef88601ab2602024eb3223ad8e95e0ab4991c7f2d0b35259ad3c5550081e32e9d16026b3a9c02b861d3dc8963e007267f0508f1272e45dbe6595f95cbae1e2c6cd2ac65768c2be2eb56fec53c635a16c3044cb961065fc26c39e04f8d56d6305a39d1e879fadceeeb34dc1d30a4ceb178edb998d6890963aacb2434e67432af3d8db9596f66761198eeb2336fe9579c7c30bfe370bb97cd9292c14c38ce80163dc292dd6ee7cd68ae4cb3a21dd515fb85811d2cf15338b46fea175079333b92b24fe0aa3ea8f316d7766ee5c708acaa514a835dd65ca24d7e84858df14d328e7395f5adeba55a998a751143409069bfa1c1701a6b58440f15e7b1ab988391824dfc9f5b0fadfd5bb8939187668cc7c243e99c94576a962988d3ca353354d4580a0e1cad8bc495caeba771010fdb871d116a6ac53c3ae2d13ab2278ee49c3dfe5f018d0ce3b199ba9000573ce727b6aa49fe0e8d56c30291c3c4887593a497c928394fd6035444df26c009196b02b2c48f32d2ad927394d07a74649b481c20019d2bf5b4d274d1bb4ab60805e34da6b56446d39cdaca6074bfe471c071e3d077cb682abcb272d2e82d17a6ea3f2be3b291bf46c1bd018f83b27d588820f017ca567a2fec5729b077a703410372d30c350969c997b7898e3089aa63f2f8904fecd014f456cadf45e983f22b2e16a57aff983e30d8b18a872fd772ab81ee6a9cb99fc98787a563819b138fdd722db5ad7a73b1b15fa00e92b64a64b3ff56aecd4ab794d2393b834dd2714c795da39e19e50670fedc18f3e3b4b0e6f8e553a57c0a67e1ab4c821cfef41b443c38b0398c79d92f120ba62362dcbd3f16c03875bbcf1eec7f7620147b4fda137c61213e3b35462cfa5cf18b1fb9956877c659aaa049bf8bd192a9e007ad4e452454f280fb84e42f03a0842039449f49e0e30b3615f03431ce90f6dbdb4124dcb790dc137fb315a33d0241f3f64b6ac05b1bfa7a63198dfdd43cf02640913ce6fe42337f3aae11cda7b5dce9399c01387ba9a565c9cf3b8a6a58f0f831f237bf528237452386f668eb5f7c4810531c454a622b461dbf716462bd59b20cb072583e5a684214659cb1cb41563a0cdfe0b706bbe391d9508f4769c0114cd738a8b520b75d05555a991d447b1e50bf3f77aed8131e35b0d1d5a0bd3899f0de8331b17d8474f5a890a64df770e715bbd8f2e277abe7553ac0a3280e7538c0b1d02d646279f92a3a919545465b0e4f9871e13f77e6dfb3781b677dc433f4bbaa9c8a4ac2ea3fd6d2c7a8de51e8a31fbac8d5baf6d7a7242a8d03bc87c738f3e5fbac567d466fe9fe95851929c34b3ecc0dd03f2c6fa3b6f0a87d598875ed63153a5802af8346116fbe6dffeb7f8b7766356f46d7d0d31e72846ec8e9f20751b44963852b036b9ab1e221cf1aa40f1096092e525c843a2a6a7cdac42a16225d3cda17ef96e9251358edccf515e83f07e3a3e4edb8f5524c6d6ea148581c6f6a77e9552710641c38836d1fec0ced4acec10d1a78b17f3f77ac156a33fba84edb58c505c24b0350a62a43e45bc3dccf3679fc2ed1995eb1b69e140c3ebfcb1f2bef8208d8eb4c1faa1c6de35db8ec07828fa52189c3520b6730159bc713059389b9901b363ac43e5575295b9ae65c2c9eb05731244fe566921c2c32ea9f66c4b1a881570abe4f2e319efc658cd534875df653a7814fa0f7e07ac59a292c0beb5e07388e5a008006f4a46dc38721297900d8d8bc8994e415ebbab6bf199e4a8c16794bb33f5fbb70f9b7f0f25f41ae504035c554a2fa51899b74c3135cdccf5fddc38d21178a130bc5037304f89d60e34121ab9a757a06455c493d53a5dbd57ecfcfbb741efa02db290453c2cc33d69df8acea975653ec116f7ac6b0b085f0a9a3b9e90e5c298bce230048532041c11cadfaf2b999e9f4cae1211edf0c265eed650747b6ae9a4bbb09fe61e15893d5a18ed9f7da97c1ccfd7e3d088809b0dc72e7fcfba704ecf991d881f7ecbec4759adf2e9829f8df07c0ebeca495fdcf843032fdad0d4b38bd6a7fa229949bff06fa62bd4aa6c294e356bee604f8787b7fc6ad28c2b355021e17b0657678fdd3c74654005a8f39b81315d406e3f9cdf7bb54df036b45701da2295af559cef1f3b24d29173499ed132658a9e7cc5d6095de7ef958e52db13f4e58c3a444755a7aa00c3fa1e312403fa02bc3f958bb816c2d66788124ef47579959784d83172ce8da2cb1d0505314ae1f6ad5ebe3df3547ed7c8df34d776fc1ac848a2fca4bda8927c642620aa2acd713a478694e7b4ef892a3dadb98fc34565b90a93a5d50d804d657dc63a5e38a4f5bf9ca5c429734681f9ef22ce00b88b7d110a33516a9eacc71dc408f4324fb043f9f12c5451437113dc3eb5bdae3d84c586a73e48c6615062719fb09344f5332f9b336fbc39ac258db7c14ec971c34542697ec07751956ef3464908345f974c894f779f8e001a8e1c712802e356cd10494f999a31e5d0533a05e78b64d41d4c91574ee90e915b8cd9e3b001fd8e5fdf17412f96bbb44809ab04271e5486e25939405f8e33fc7dbb23dbecd80bea06015e16d827ee43e2a7797810ca8f2a72f7ffedd7abeeeb07cacd43b04549f16fff739be8cc394e6f8cab6401c1b407897d1f37cd227cb969c6c42fe9cda4472ade498b52dde4469f8b30eacd45cf6180809ff2754b2bc17d8d376d9f259356af466c1c1d2bf4f5450d9a76879b8c3fe34541a78bde1d831f5582debafbae5c8a3aa9711a0ef9e03dd77e3d9c6415c98cd6e58ddf0ed665f207478ce4936db1b080781f146d8b0a112771f666fad4e0976761b8868b34b4e4b3dcc0ee4e7a232feddf5b0b0c6fda651fef8a946dd028947a2f10cdabcd2fa51e160a26350c9db0b88d2f7ba763bb77d073328250381cf2b428a236e6543bd30b2b5b8c887f2eb3963982b3cbcddd7e161f785573f9655dbff6e1090467b3fb53f8bab0d9e21ff234f5b3725ace6d389312e8591245fc748d5458992d9b4cd4bf0c44c985e02e7896c7f28149d5d228c642c0098dce225831c9964d21e8bb516cad9b1f282dadfc31189ee434a3603b2d391de5fa240454b50fbb9ac28b07a3d0fdfa280c5c4b563c857e046a1ce373fb0b4715cc98709c385471840804fac5d8e8c7e5f64ed11a38dcda6af3feb4a6b54101f5bd32c5580aa5d406dfc587b7abd91188e28fb389083916511e87c44906258cf0e4f15819ec9c22521c52f41c474ec8f7a73961bad400ed8ead8eb5ff507c4377bf10197ed291790dc2f81294bfe5fbb062e185b1a4b55a4bc11e63ced8bacea018a429b754a24d55e240acd966c387a129fd9f897f1a3786927b11047b68d2c884ee88aade94c643ac7a5a979f9bd8714ac272c5f3bb59367635588b39236808a13dd801c44a7f39f1355eb2568658779f7d80d727eac3cebe5ab451c738206add213ddeea1f857cc263427cc072ca520974573c7ef158a628536efb0f169aeb36256f9706492a950c023dc821f848e755a5bbacfbc16b4e5b80d92a5a7ec9e3fb727d13cbc29c50b75be06ee31712315a157dea7261ecfb5e4ec52be5aa567cd559deb6ff1fb9b194b6d7043efd247643df061915b78b53d94ff5d83a4b294020ba8a56f0a85677865c3b00922bc2c314b90f4fc86f9bc3ce89a82d046decb2fc9a0232a65c1736dce077f1b756067f5da93d9492df334cc17085ff405c3f428248e00ad2d07b5817e31bde78510128a372c7abef4b7cdc4c863ee5ec909a5174e73225902ae4652c4e0919f51676d78a424b5ab4aa97c077e78ebf64877b2d5d344fd7a0d3082d0582ce353d0dcfaa2ac0ec4fab3b026d342920b05648382e6b341a69415ddedde1d9104c779194f5a29a10dafa15176a628f0a118fcb4447dec8ea2437d635d85549f4485b5c82b37c946cdf834ebfcfcabc806fda44bb909a1b4410723f7756da9d69260a382e924b090469c513d289f438e99bb347fe16768ccb51476b6024f315552b936645f73d84f5efbb069fd22654b9c8ff7e3b11cc48e9e59104fc2ef34df233c01f001bd228a272f222b55b2277a5f8d7515ed1752d9986c0fed9f6e07fb60ccfe9de9f98cb0d555a1ce82a7486e5e06ef1c02356b47b63199faa6c0f088c285d9c1b66fee4b0510c75b30f5c96e3f4e6a73f96b6cedbce187ad62e10258874e7eab2891000dda13809e931d79a19298c4967cea459b93ab518f98835afdd349618168dbfe9a5413f1e3198515de7cdb9e5426e715e983589e9ae5355d0b96ccb135291aff10350ea038ef39bcc8a4116be72f4e08dd7d24aeeb77c0b294a2228a0ca76f16b58799a5d4fb567073825bf4e96813620acaefd710dce7ca6ed91c0b66ee5e7639d9946a63c32633391b9817f40d5ecfe81f9731f062eb7e35b23859182d21fe8ed05595a87434ea84f6e8f70dea5ddf42852207da24bdc06f4b428208cdfcce7d038e9ae2c8e415a753695e0eb2a3f95f75e234e8912e24985ecf9bf7063fb79ce5c14bb5784adb8d5c3015246a123eed894788be78d4d405fa391ec20d3449728fe160ca55ad5bf721d33f87419a205d8b79cd6c7e6458af13cb0a341f365eb571dc2b212ff8f3f550bc070b5779fe98fa14b2691b818a193c302f32bea71dd8732447e6efc159d0c163d1c7646101b5521a7ef303fb547ebb17d55040c0053654305c27472414fc52761955162911ce55e7d5efc38d6661ca7ac508c082956d52c0af4e8c620e165a082ac248d731ce501e73864226e930dceecb9db0ee842f4e8c2ac28c01800abfca635e7a5e781a31f63a2c76b66524481dfc4fe16c68fe618028f7828df9e5e2085aef8b181c6083d3f130b1b0ee8bf971e4ca90ec80b3c98bbcb23f98e33aa136422d0597fda9d493e56141aab17fa3b35c91ab05fe8c6ce6685d0de82fdf8eebe23fd88e7af28128fa95086fe4833b65581294be2a02facd9191a01630c85dbbb758664b87935fa0e49274ca153e6736523ff3a43ae4eaaf6e89b46ee2caee3a50c6d631850429200e21910e714cf11b43576a5912f4485cfd5c60dc4f0f1a42ecd01aecddb445c5abcdf952a0bbb3c81ec488d5c617b83621145fd60ff5226da539e33e8ba8882836bef3afd2ab4c932abbf56e3e675fca83ba3270380b99703980146c495414d807780a88fc6523f08d18436d8544c9c9f7c9c47464efa40a7b8565bc7651d36026d83a4d5e054c62bd9fa37f5f5b29c84588b9fc84d3b2f90bf4121e7146bd48a15cc33cc05a94349bfaf6b46a8b08851a3d73f2bd84fe7e00b54b2a569f98bd1309d006812403d38db32dd4f285b86ce556da8b9c502c26afda9e2d6efc88d61171af781f297c644e0a8fe05acdc3bf92e8bb33f92ad107c4cb29868857782935a15e38224c4d774182c4b14dd513ed1f44a7d31df373b81347c7f5b5d0ed4c62fb3f33cb949476ff80768f16694f3c44a5b3d04b186a6127eeba8601c070ea3382e43771851c93972732f03cfc5469d83b4aa9c9a7999a195f73747b1fe1dede3687d79e026eee96b3a19df977bb02c9e34ace93138ff4d55ffe0646fa3cdff930838bf56475cdee348fbf0351b4ed73d0a78cfd71344912e374c70fe6ede74582e7f1ed91eaa0b3b5152d2bd698a6ecb5a9c76eeb0cb77bdb636b6b87f705288ec7ce5971df347cb0f87041f97b1338b28a313c2b49e38b16baed64c953e0427e91c51af3ebd76bea8d2a92c2fc022abf802e1218104339274de6675bf1e2ed2cf32bf8d6f7472c896f64c277223c34c962a812cf143f76957285328f9993006b4f3801837b148a146a1b631a452e847b1db72bf6333d2dac3719feab37b8187c73f4284656b8b73189eb71470f8457cc89d57abd27b30fed6e6885e9fc76ed31cc4b32203e543a7d1716905d65246bf7d1431ed2d0e1356ff4d45e0a7bae368686e1fa3ef80b68f66e35fcaa6391e3db6eadb13ca4f65e1cdc54a5cc22b61ae5db837af26dbd7418760cdf80709cd3c51023857515cf9dedd892fd6214fc4865e5b9ef5bb6e74193e10cdc6f1e36450a10cfffcd2149d4efc42c3b0a4e1fdb52d43e00f6d1d32fb1013dd84597fa941e37aa4718d6df5e1693999b9860671ebc69d1fa6302162313c4a6115500d8986d235f810d1da13c3ec8b835f68c73a6ccb527a2de715274079a37177e235d7f9c8f80e961bfe5eb410b180984147e434be3a2de2ed4cfb75391a3d46ea586e7b0ad20c5388b3dfa5ced27f0e717d758681e419c1b4f74aa81fb53e408d82f8cda8f871c07adba828feb13cb179cd2b4d4f73d6fe2b4b3bb86ccd9ab0694362ba9326f32edcfea2eb68d732921909cdc41805acc81c36ee1272b35115d82409aaba079c39e052cad1afa13e277f309a4b5e5a37d0de915c93af3078330034914e6c6479c3b6b88ab001e6aa6fecd2ad3e09e858cffec7cfa561dc4a2dc0138ccc76d328a283ec139e18c877ab943ce7b12dfe530d1e3e8dd4974e5e0dd72a51c9441e81ec5044706da20155518af6aabd234c1c175841c0d2b88f5f32034433aa8c97b3a83583958cdce5dafbfdd95846301fc5a6955eb3ec5f7103fee9a35833f6c354046874ddedf5aafe2b5b1935ae585378be13a0f390e4729e53a625084452056d6a0d96638e665b2cea4bfb711fb4c4a5105a50dbc4ff719e58eeb19854a34e463e1ef32d5e60c7185666f99e35a24247c1ff02afb4627c1b1296811e35f98ed71112bfa7e622d6e7a61e6d2bc9dc9264fbf3aac3e439af1191311cd49a91739e55bac26922c390c63f369c3498a10e614bac4da08172764ed00f51e7e58ca8ac524ce2a16be0361bb789350ed93d43eaebacada6938c991677b2b3a243b8fdd414f0083650f511642e6448631feed5899d455ce3681bf1b61652565020e29b460db0402cb04752563590db1aede5bab361f2f391b022f37219bd7396207cd9036328362fafdff3cb64c086b62186859d8d73e29784add772e59a6ac0e69780e15357dffc5d2fc3672078be7bc668dafc9a252ae48a783bfa67940d5b7b0ed35e26c365ce9abe778c0fb3d18fd0c8ce30d0a8e662442561a3178f5c763987083fd8b07acd3035435ba342f462c1ec034a386d4a1a66d1b149238d958f6798822912869466f89c700779f344a819fedb9d6c534f4e363ab67b711a455199d9b12b8e77ed80c71a89117bdd8e8be2a35b80b1e0d0ca7a9d2954bc07d109b34904cf46502310236e4531145af2d454811c61eaed7090577890cc0ca0be4110a5e257fd77a58d070d94a8386606917f141cc1e84fc576bcab533175279833be47f4c4a40041126f0577c9f371093dba6ef9039dd7cd01b9452691ffbbd7839f3a53b531fce380299d93c29aba926addee20b6022bc0da41ff8f26c822c20e80aeb4cd1acd7dd8b6103cc03dfe91000671a5b1dc803a67021fa2346179222043a75fca32b3c5b2057c0b412ac31fd2c7d134998fca1188028dd733dc2b8456af4c561c5bcf9fbe02b7e4dd2368cd5ed36c34df9b0378c43ceb726eac633a5f4c9de83a2939b44282d959f8adad7a4e4feb4e723ffd4509a900dd2957079d2b2e089464e5e128308210fa226b623ce99c715bbc0a87675b175a71d7c91ea4da391eb8f54150196c4311de3ef85da061bfae24a462107b52f125506ec2b36f8d801674adf604b4d2149df28b620ac79be6c20dbda041ba399b4cdaca58a45b4108976577d1902692e0cf4752107a4e3b7b9cf0d821b61c6134b24ccc1268bff1fda31395cefa01aac951cef883f3cbcb50defc833f14c5d62ab46e3ffd2fc20d9cae8aebd8a4b018fd8ebb7d23b4960b3afd0c727532176252eac8a463eaea6407a511b11b10870dc25c95c6325edcb19420bd1f91e8adb02b8a444e5af4d7beeba7e00d1f419161238dd183f1c1c92176876f2b3cdbcd582d56c4110dfd527ff9063123d78b49468f9879b0363e505863886b1eb71ce136ad6bd50cb6a98c157a770d3b383fa7f2f8a99fd8ab48df8e3745101694e851cfc4be088a8dca019f80e7cc91d9b3f5071620c3b1db592af362e768e11c249ed18c6b925af140f90247beebc99f8ffb122e9e9134b899644b04d3b53324df9c84667001f9340e12d39518638145b268c6af3b5ca874b95d37b33634f50e5249baf68753b40dfbacc25c5f559091ed7ac1e9f2dcd67dad6bc51cc4e40da8c1dcf0022f4aaa99c727ea9d9075377116f26490d769d045197989a1759bb342cbfccbc398771a13ccfb1e99c9a35a8eed9d8b39b1cbe89ea64b8807eb74b65a01e4c1a6951e83a0fecd30ac72a5c0dc68c222d511ceca1cf6e24e4860fc447f574e7a3f2a1fce70689aa8b1604b5887eac4ce28f33a164c62443c945d35d9e04301d0727aaacbc40be40b915f4ccaf016d2a7d2c0b8b4e9857ccfce96a94ea002ce1d05d741c1bc6e462b7a3e5247809f101ff3251c47320d5f400a9fc86bb57e4330e532358c6635dfedceaa96c09ad25ce26e4cfaa85d4656c9a971717c74326ca05317bf478947c691e2019d7b94387523731aec6a81ca2330d24bb38a546c3cd042b290c28ad18006de77ba3da51db33b7a5bcf7d54d73da9faacf951620de14f437a0ce0f42c0900fdfeab64671045c84c71b0aa36770df500104e496c319209bf81ee8f8cfa7c79e9ee811cc1fc76ce9dc5c418f303db55adf7dfc234c39a759c4550f9febcafd0c07e86b92d8ce0b15d851adac4334571abba531dd6c4eaf289eadad92197a392315a07fbe74787c96a2c07b52b05449054370d694d44ebe882044b8a3c0cd393689c4886d09accb277781cc6280ac9c5891dd83d8cd8e75abafb0f08164c08944584c9b0c5b3da84ef8e9d87a95f9e5903d6dbd9142409e7b5dbf6438b9e41002c24c2ed05c5143adc4d349be0e9bb6d8ebf27185d254ad769cbe2bfa85463dd7ac2e59a626b704b7423a120aaaf282b8f90d18eef2257d2f412e83cf95689279c304de55e3b4b195d264eb1140c5202e586aff38515140d41b4c3d0571ced1f05ee4536e12781dc5d9b0edf3148a83904b69486c686e84de8a75cd98efe4c300770d7826d8616b4c2b887aadffd343ae3aaca6a7afd489f31f5cc8fbc680ac9b8c0a2da96983c5f5885b3e4069a372e75c18b352cb1b8654f6a405b961656e11457d5673927da2774c9a383ca40840bd20e84adb95785f5058244daffc8f46ee0ee8ace5cce53835c8ca4517c13473dea4534a4ef2b6efb39012fe8b406d231741cf57e347f4f71e5155532c7fac9d532f61ed34d9ab9c7bfc3779daad48996978cfbba49fad7a039a457801b24f0dddaad3511092b5f1a90da426e0f121903b6dfbc3a560f289cc71fb7e4fa1c032ddb895e8273e9651dc7cacd494c16211bd595064af99911ca8e394c1c99af2ea4713edff3148ab0a38ae7852286c0e44f9d64d1171beb867969abb8b4f3310ac656306e31cfab8b06a65f346e53c186e06a4e1711a3b907e687ccd6c27105cdc791e438c772271b28c1870b34afaa572448653ebe912d5a79e12f1418669936319e1350079e10aa0d304d43420426126da3db27f9b828e064ba4a73b22a90f19b0e54fb14e6df7e9bd7660ba36bac6bec9b667ef55646decd5f3d3313275c4dc97e57384d2f5b50a37ca2ab0323bf20256ff46c34cb79304e2a0fe8b0a6ac166cb867766ee7c74f5f46fe191f464d0ae9da4a8d8024e525afeb59663a7d84e5d9f8eb623d3446291b5214257983d397dee0571dd7b1eb51c0cb89009c0d3098f8c2931fe4e48cfc6ba14c9502f6a88e43bb45374a1dbf7291ef5f665493624d13336fce574fb6b4d4df9a97b6fb9a199bf7a960161f64627b9c4fa132d441530ff0ba8d633a9c9edca6a9f08f6c97b15c72b7d1cbf24643afe34c47fe77676ab63b09f373ebbf174e30357e5f856193b43de174c642256bcea9518cb1accc20de28a89bca363707effaddd5c2e0ce0eecfe3c26be2bd6d9c1f01f7fa2e85823bc0a108ad0d0201b2b08125362ecc3142957c6d5e4ace696067f06bb20b643b7a7f1da1644595452522ea2b0b77450970d33f6dc43460f8379190d1a968cddb59ba4beaeaacfa20ab86cd23abd04e104b4dcf9a3973d1fbf7f0814a57d35304eae08d74b4a53448bc76f172a2d638b4b3a12879f5d5b5927b9cabbbcb80e801e3b25c318d8c6628b1d008b672d8d6e150f82938d281b51c7458901d3ffd304e63272ddc2e432728513c0a4cf92f6a4a79f12a179eb016c65db71b2567e204b2e1dd48bf5db5df733ecade024b27ac71ea75951a6784a136321e3b31f4188d6942fc1b741ea63bac3b301158b512bf36abb3194f137af6366722eb51b9c1cf6d83a108f0c30577abb340d14dad952284e290aaf57e36909a02bd8dd74354af145a849f2fb37e824484cecffbadb94505ce3ac99cb7589dce457411d484ffa952e076d64af7809f164b52805e380a7bc10a58fc82203b9db22b7a7a9bbce05ca1376fa90a04aaac531048c745193f0eecb97032aa20089514ed554a2cc2ea8a270781b1e9d701090b6afb7f733c18b59f7611b009e87cc16806f3093fb806ba000f8b635cd9bce66ae64d4f6cce093debaf61edd1b2fd5221644e91f617ba9ed54a3bd924a2a41eb5b230bbefc386ce1719168cdb51359d18f8a0be9edcae4e5cf64c1899b9c22a54168a8a5277f23b36a4c5fa8bc8108aa112731b5fac15152c3bba5323d3bf6d7976e9470f3807695c119a66510c128d8da9f82d2c47793e87e156761d46d3aafa5f1cdef0997e5476a0e022f1ec2f38a617fe9e68e57d8beee4faba6d4f60026dadcfddc0008949e248c4bc59db5e98295331002e0f103a5d76ae268a90250db77af4647daee20ee7c2ed6f55a7ba05dadd11c6c74e6212c28d8ec886f7219867426064e13d15bba30e5357734e50f8f3399ce16ba849c6c3cc262f359a696a3702aeccdda01ba0872a125cd93be0ca800b5792b96c095cd9f6b369c3aa3ab295584cfffaef1092e721fc4d6fc940a829f9c2e4f1072b59315c7caa4078043a51fd5d976a1841a2e5b5ebe50126f352d68736f136cdfa480af12a66fa1647e4cd650dfa33b3973e80ef48f348032f9ef71da70bd90e21eee72baa3212a2cc81aedc5ff006dbc92b9542c13d209ae7bf45efc279fd49801b565e52370f9d3a102c71a98274924aa890fc163630f0fb944fc1d0fff6a2f8562a5a4e287fa98aa87fe2a36919d2196dffd80217aa9cc2319842811dabca6205ca0c77143901fb36eba9f5f7bf6d49a05396744f19090535c4824d0f8051cf2cfbbfa798ce03e07bc5b471b031c01cc0484153c48af94225ff641202448bffd23f97ae92e12482b21ba581c804a80b89d51ecaf1d951bd938413128848c27c73967aef81bab1ee0f5fae97d1676f5ec4972dbfe95cb0554b4cefe873585141da31589114e3abb8da740cb8f811f6e05b5ec749cb8bd8f38b4af6322a583eb7bfd84fbd46293c10ea15d60655abd83614afb0e7266f31af76968150912a4c30a9e4468d10fd18ae3fe08730cdc2293ae0b5a55ebc7ed9ae399d5f9960443b21eb56625a72dc498acf276f8e82b92bdfbf597e07860057e6f69f7beefd7675bafaa87d9115e1df870771242b1640bf4b437e98237145bb0269a222001b60dbb9594443cd3d81e8fc3b0b0f3503e0803a449e382afc5fb30d7414012a8f3a97c3c033ba13a066b408b095e39b444e4116003ea4405c3c3a92ddf3a57cb85dedf393f870cc80b2fb3dd5612804c516d6c5f74f83fb1ddfe2a7535296feb335aa8398ba6d653e3c882b8a2b73703cbfcf18506a847484d45e1b3e012ee5a2e070eba1b52c0b2f61a2d2bfb15c1a655d9fec5da4d395cbac4a914029294aa42289e313577e4f89a24ebabd460e82650dd44db9398880b3e95cea1e118bd73736162c05640360be88e565ce6b434c179febdfafa86ceca6c8b0316847bf491d9e8985cf78789480814a53008741d99b430015ed710d5fc2fd48902226a57bfc63b27d4c2d55aa7b761f3a7b73d49614a23e5663d4269b5cfbff3caacca333d9c37cc9f934ac3b4bdf66e3cc11a6e5b7fc2ebf335f3aebd73d9725e49cbf20ac41b94eacf15c0f92588eb40b915948b5f6a87bf62e20b5cbe6f3a124c75159f5b0694a30bebf10268d07d436b50a17d0a24d722aed1c504f6f96de6f220a0086076e79de6909b0eb6cdca3f73651f74aaa530e809e1b5588f10c89536a92b1550a0def64b93ab04b727e2faab0f417cc353ac77625a9bb243f28fda6d5f11ef820e8faaaf50b50aa1b8062c695be0619cf63ae0ac0af5d58eac645a39605e2d15943017835e27d1df535c8f65d61e656f4146c116b95932a6591fa3b464da9bef50023bd96d1827157fe5d5fa985d53508925d98aa129b0d298e5f7d926d4b2488898896472abba0f6704df84e181ef6514b8ef395509fad2e932195debef3112bbd6167fda12c855f602e67a7dd2943537f4b983c327d32e511fdbf4d25b5cc9b6e997a6f612dd72180ede6b413fef356b80e260bb933eabcf2202fe2ac15ac0e409b4b52e3325897b64afdfd8d8edf22ee6d70fdd08d83d2837e3f3a6e3d5698c2d37d9244b9ec69a744ef25507096fe1b67586f2a6a8e30ac1469e5090e3087987f2e61e0c6f8198d23e285f2a876a37a847607b27646891b510c66e6d1d701166225cb07184414c5219f4845f1be530a72508421dcd29b74b751c4a1201a447b103bc3c18f5d2f3da47c8fe3053f4ed1be7dea7f44bc8731fdd4cd60794b05888d541313059d9820004078b53b89a646f3cef8966fbb08e395bf6e950cad5ce377af1a8b106e4c7bb3076110271ee5b3ef35b4380a5fec5e5d609486e29845d5967edd796bca39008594a96942aca55cf932d7f88d7895a03e568bb363ef4344164742a08eef0c810488edb0ec9ed50ad96070c8769db29b5f44e8f382fee9237ca2f6e7d65f7f4738d045b31fa6b0479f2dd10655ffa5ca9f442c5b9c8d5ccbe6585b15f8eef891507394a13be2d23b89f5a0785a14f9105c722cb953662bfae636134d1a44581d701d17323bafeb5772467f9d9c82be2b21cf72e1679a3b9c7ad9dd2325d048acf5deb9fa720dad57a9a3974f245114d0d825cdcb506ab6da4bd4cc0c6df51573632ac913747a11a34c5117ac9f581374ae7b215233c26b99fd8a1112b83d350c60463c310b3dc10eabde5e989da8d60f4e13619e9d6542b43d7ea984e1166e4a30af0716434ddce99cc748e01b3295632c5e4169620c84aff8052183baaaefdf911033f90c8c3f61e42a7b8f7dd24523a3eaa3e0b52959aaeb5e77084290412df6834d408dec545983f197efc2b9dc391d9e89a3976dd4cc15de96dac382a3a265542a4a6926cfc9af0057fb2f566eb7503f7147f292af873a1f65b605c0a331d69c7d29af2bc298de04f3d533ff7ef5ed59cdd892baa46d4dfc8112eb0a95595222f843c28fcf2d2f58341d410a9e3052cd5a072c52452c74c1e0c35366dea6196935cfed7814535858fa2035b97fecebf6fdef57df459013fbc61d7681280c78643ab4d850836da9944b84f2615e826df09e9b6bced8a66545c4115320d7eda82ac56eee5380ea4a95c2250dd347f3847093b69820f2922a213c4bce5908ec379383d0c49b81a79fd1b9e207e18170bcb9fb09e7b40bef7f3bdd79d159ffab23d758b85adc1ad5353fa8252f56d864c227f785d523b9db803d0e1fafb1a273a713277388eb54442bf378537d40e7055372799f0ddaf58b383c63a7b06e5dc6ce295fd622892faa008da8607a161f0ea2ed9ede37ed07b8a97b06c1bb261e577e0944f6d1d188cedeb2454f2a04602f34d61290232c36e594519aabe023e7ab41b59c7e951ec8f31ed4eb67b7039d42eb68ca26d51e409e99d6135ce52b4913c3abcbbb6f42cb0a2e0c5aa656b91d51802abb0a1844560f58d95944e1eface17ac2e9d11ecbf48675c7e8d0b672c26ac04d0f8e1de9f508c3ab507ce4568bcc4f0eae38c44eeb8482fb22e7c9939b00e3046124ad794641dae90fa377b59e319a2b36584e9f43a7cf6cc22f47ac5cae8eb378934102a765fa889395ccd468bab3d433afd39dd46e4bac936e9e13282eb7d83c99e47b0eb1738cf9170de830f53a6cb7b1ec9441ff7d48daa91f4edd13ba818615e62e129796200df79a49caefb0fb78e05be56209202243469192e540d6f56e47a3b508f2f76673eac9bcfe5c526d433ce8539eaeaa323f2d6234c31a8ce3849cfdbee022683f74f684bfe9f1a97247696bd9636d6cf9bb93b71748e40b5a4dc50da725c8dde74c2d1f970245d786563c11dd88fbec380316b71167ee7ca0dff0d9b1434ab8544c102b24a9f6415af836437d33a9ad8becee62dea3d0e8a0f4453eebbfcc405b35ff680c84e26bb14e610f1a6a5d0e9fca7641ab1b2bf4794011b37546d704bde595ecac0739464350122a3e2d16d2fa5c755cff94bd91ef0527404c958c80e390103590ea01d1b6f76d4880458343a668667d0dfd1a584d28b64fcc147c601427e20f6957b58c1e81f5f4ec0369c1807b75a6be4b224fb6561883e90b10613069e42143b270e99ebe4d52b7e7c39d41be82e64874ffe62414a29ce33b1a48c1bd44d2a72fcbc2ef4e86c58e604580c5d4132ace788d251f18a9717ebbd0b77fdba80d60c54ceed5f963953051aab55b2ac449efc2f218235befb9d224fa2d6ce0dfbfc5a0e1946574f844d56c46f962dd732a67a62d9567d2a707ae238ffc0fcacc679790f9390551089492958ac52a97e200a5b6e1481d9ab73d2356fc3724a71f4c723a757ea7990a8ba14d4f4ad864e7da3fabfb3b75aca370eda619d4b63fc6ecc047f1d50db86f9ed81a2bae71af22dfc6f91552c790a29096c0d35d27665fa62e84e8c42de0393c932e279d7d2cdfeec3416bbfc6f8548568641da695e8b9c921549041c8d7d91407e4e2e89b6e6027fd0b2711b2689acdb41bc55e5a27f5f350db6af88a7b6611fbd102fb6e02b1b4c9e271e5f845e6972deb9f3bfe3f4d92f62c4fa1cf7773bdfe9ded6e5ea2c0ed8ce486d8c722e6cab7e56e6d0ebf132df43a031c831395baf7983cb666eae4c968394f65c510af2c98270ea3aeea0db8c05f8f1818a6bf982a725802af069251c6f89c09c95c2d800f96c7e0528114d67c01991f35fe095f95bd4cd6293ff29a3c59882bfe1affd34f17cddfe394a94e392e309ed5f7b7e918a7780a1a49b477cc7ce23e6538798421e2bec7b7ce31f7cf6ef92fa9ecd65d7362cca33f52f101522ea87bd2100e37be81cdef29d36f8762f47da819ac7e22164750125c81b2b999b28907195d2702edf7995c2a5fa36649b20b3895a2fa8ac33b8313fd51b25c85f0f4f4874d8ed79ca44f078a0b9291a0c8e34b72d3896cca495961cf2c1abe931f8bbf45534005ecb96d8ceebfb1d69ef725fed7fd3a12948674ca356dc0b51c22e06f7470bc4dd9c5095387ad5de5390f572424b66b01702d77661ec9c5248c03a4ae6d0959ec3edf0c6438a39ff155818ceb297ddfb315ef204974eee4acbbc6d3f3a1904b93af4009402654dd5b55f3c3a569856e893502bfb71fac7b1fecbdc0d19ba3b61c9dc65de38faa7bb3eee6b5a4e6bf58c16616381960c1b9f234d0ff17a987e203c318ac5ea4ef82d214293da93a660a645bc68e97003b6155a4ded567a40ad5e1b70ee36ea81d3f2d51fb881bdcee663041b2f16aa108ef79eb111aabfc0c013332d308a3ef37c786b9af8f5d485f3765be568751c6b4cb969d62915650fb3c2fbfe139009ff606182ef2c874aa98a301db1126cd2fe677dee7b69ce99d446bf977c7858d21e12ca68e31a6f057bf581a0d67809778462e64e2c68c0f3d1b0e6230855dac331ccc3fe24edc89d4edcf01a74913ed6237abcdc7d9bc08edd3dd06b147d5beba89c43f2b135ac1f84f9a8133cdcc1afbd12597f309f5fc83a38e04bf1768832285cb5dcbd13c8de520442864c2c6c5a32d5936287c340e7205b74e789893d4825fa4a081bdc4fae749724b7db124e5f56f7f964cfe373c8785a86424b0f21953d0615d836b88e5f688d8b177d1b190497035d620238ef9b4cd029e2ea2a7ac86e9f57a3a63b92de20acbe8eadf063e70ad899979f6f10f8c066f23bb9231171149904e813e1f11165cd579a0c1a5e9574d68caec586fea6bc88b8edecb867457a59ee162d49288f0f9071dcf478259f75168fc988ac443007cb93a0cbafd10f3ac7cb90e7cbdd969ec96bee380d937ed182058ebbec00cfa0846f0fa867bd54977b736fefb69a5242ebf9f34b68be456f1d9dcc3c7197040dde761847ceecabaf0ccd26a45424e5cda7350ef13c6f5521a2d72513b2bba9ffa72d0d998f7b687ebe51e723273a403358afb4f95452078131b41bc839509e60cd56c8d15c8d6d39adfe4b4dc9b3f9875c182a423fb8d53b62d5df05f0b4ce0d6b344be55e3f0293de0a5dc1d75c381310e02580239ea03170a1714d870296fc4e1ba20797c0457432fbd26a0bb44aee999b8a8def72753430b963ed26ad64e030fea1248444feeead0f61303b1127fd4be31738398a2271a511bb0ebcdedadc16c2613286d8805f7c8f9ca3de71ccef93e194b9d65ba17f8581203e7efdac3394e86ace69ba9cd587cb0c7089e8f7ec91c0b96bcceee86ebb1bb58f1638e2ee4be955432b543c5ba489b996ee07d862ed190d1fc1f2a5f1be949007892cb944afec6dc93c7a2e08e64133b86401ac9aab9f4855ff9068ff2cc0535d129c0d1f34eed56772cbf39b3ab2857052dfd45bffecd00f295edf80c4a9261ec0e4cb6097497a98b40dc6b223f07fdf56f53c2c9952f7f56764d4caafb9bb13553d7575165ec82e160a0e9e7641ef15c5f85c93fa87bc66c66debdda2c0143bed12e29f42b9b96ed51fc91efc33b75b3082c1b107a1775394f746fc982e4db706a678f31dc176ee7b7de6c9a28df9004079ff76f945459e74f6795f1a5dc960ebd71cafc2520e4064447a9a98db6fc253cd60daf8100aabfc165bf7b8c1600839f8de0067ca885383db41f995ca8a32898907267d742ad910fa85cfb747af0b9bdb2c206a0c5c0221f2e0573f07fa238eff650c91325d46f2d2aef7a1386ec5f7196459680fc960e80aca916a433d50e46ad32fd88dc0dd1c961cac22472315d27c8c9141ecfd95c3238fb706eaa311d225b4b557d058b68a761db27f573add6c1459e0a71465bfa24d2e79f5da2b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
