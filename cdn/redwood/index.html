<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a06d577b78f23b7c30970db9ee229f81147da72e85003d5158d976ad9ca217ab6ff7c6a09abb4040a050c7828dd12a0d44beb0977cfdcc13f0b5a86ce7a05dbfc3b81e3061bb0f8b68dc1e660856f3a28b244ca5a4671e9326b0dd509a50ecf24e8d31a95af490491916bedccb32257afc6c11eeb6d3f79bf1fc1b9e49a7935ae94c3d59e68e9a953a29d24a8f778701e0c821cc439544dd4136ecdc6f01fcac8fa7e2300b16557f34fb024a6723b5da9ef160e4175f7727a0621f31594ad78b56cdd61ad874041ea350121b91f8554df430dffd9a2014d913af7e54b54a91ff6538b4ab554129ae36d9ea15d67df7a49968614e996537327d1221b16bca480c667bef78287a3ca40fbf0e7a506fc894604b5977a34e1912cae2d470f8a8d788b74fecaadbb3a1910b182611fbc50fb850c7e2cfb4334bc9ee219328beaaf9a49c83c7e54f07d8e73703a7c4411a1817d1be57f7c4a3ea6d2220687dc5dbb0eb8fd25ae1ffb6251bad3e993e8c5b697ab1858be24c53a739ca355257d021bce345f66e09d2b57a8d3d6d79a3e65714ead67690b1477b4476ce6651ca79708d857c20a3c33109d6a3d1ab489da8fb15ea3a532cd401ddb8a3693aea1c3261de86f5b1dea5f43cbe3d5151430a07b753966118aea73737150f192a22ba31ac3d3305f1fea8d47b01105a72097135c250dc15ae567d8987fb0f4d30a217eb52433352df7e47499c2eabe4e1d50edce820eb29101b2f788872b2c6af90b3828f9b75eeed5693e8e25a2f2f8ee814fc7d4760ab9b481267be51806df70bbdccc94ee83cb461bd2843f31a99f3961b8a40d803cace6d8a4a6d4614d5aacdbfe6fa0f6c39273784b2c90db64abbdcd86548028167c50a222e157b4f2523469108ac069690f6ec41cb11b5aec5b8b6dc833296f2622923e600b4da597919da72e4fa3d8e573312e4d57102b55d4d0f0c92b26e25e35c68fad9bb4cc7e294ed3659a362d6f3cb40088b129415a9c7168eb133de707aa6d0f73485eac112864680dd95a6ec77e73da47f39944e6be4e23acc2f3d9b550ca330ce149f44f14365d5746d8331f6d42ab6904d0386b2c775428fd16f4f71676e40ec9bd7a73f4085bced204cf94eeb1147c4d0109fbbee3cc6d9bd0b020f39fac91a5519a5f288ea9b2abe5afbbbca9786598b2cfb3cee1432475e6e3e7e3a5b47567a2f4e39885fc12c8b7e51d5cbaefce6c8773441b5074f1e759f4ac3667c958f450a1a93d987e49a10d143ee46210a21c5212468825f13d3b69897092c114d6808fa376593a085cdf190959500a248422dc267b3aec5eeee2bae1c2f0f4d1796ff85de147ee7475427ca31966b56595c58c595b05efd01aef4192cbcffabba899e59ad3560a3ab3a005f7c805d80b34fdcbf8fbf3bd01ea03b24352959c577b9d6f4316d164b9544f93823cd54eb25b53897cf20adfb89fb5fd5d2cbca0bd2b7b277806238a5d3c16f8d35408c17a97156d991a0d73cd4d7c89b2fa751a725b60d6374b9591301900994891db27ea036432fb3e9ceb127fd75e6f85e0bce07ad19f7dee27f4846af7e137e8ad880a26df1013af6a7b2b1304ed8d0d7c1eff6b2bde68011bbeb1889efd960c7a80bed86d820c00bafefdeb2ef8a94510936c690e58ba210957892425f22fe37f3a1f5be07d1d9551bddfd2d20c73bc0a9731dce57de8e8821876b222618ef82948778d8ab16eeb389721a41f952c0ba4b216d2284f0a24ee5e9a82b56b29115c1a597117f6cfcd623db867d4cdc41b18667f92e5c241a80d42a4361f554cf69099f112e6228c301c04dea949cc77c0364f541ef2938b82561fb479691c2a62449feec552620f2855014040be4d257fc9368e7c5556b6c96f7e868c0cd40e66d3192606d1c7e6a47d5ee23ad2adf222fd30f425bd100aaed70e9e8a33cdc232b2d71adace726a781ac201415105aaacb6e8b9f9a9f749e36c2cf96c4bb8c08f12868b141c931a3b4ae279abecc04a5b754299d7d39aeb932297ff7f3bf638ad19996995fd5c081768a73c43b03a1268a617738da3e1bdcd561e530c252bfb9e1cd0d535a6ca354321f8ce66b844c018c8280380d1879a94b2006f26b90fd29a2b2d6057ec416220d590cb07407172df8b8549684c0b4bf16788a76b9bc7b577e49c2e340bcc783dc4c17cb1fc84a00c43550b39474b755fee30ec8cdedb24ab0f62a1d84a30ad0493f7fc32c02a00d7f619b5831cf6e052b2b9189113a8fdfb4b46e67f753a15f1dbc36358a1ab831db3763e4e61ac6575905e677c4d38f85d6b2d9e83d513de0e5447c6b0d76e5cfd9fa6efd14e2b7128214aa8cfb2b0dc9948788ce6d2420bb0737e5052697f4b7e3ef4e196bf1faa2a0d35870e94b67a00eecc81506ba299ab954af6cfc34248f733ecd5584b31e3f2256cc1e1582ac27ffa99be777a131c222d64effc0bea7296c2d8949e694c39aeef9b3636059d7ea9131a870cf63afeaccb6911be3967c12fed3cf3765bd1e05dff9dcd592e48fb6020650e1fa747c5a0684e7b6cd66561730cff7933ab0e2fcf4b4c9fa42bcd9e8f94b29723852f10c4fc8ac82961e6e9ee07201ceb4a28eec78a447f1a9f165b5316e691e3c6ac9adecc70278c83c900a6b072de8e37b2555a2ed1e474f0b447f06983d2eb5f2b68468fa069720830971ca951d92c61528cab784c36643e35ec4c9269444483740a996a5b3f0813a314a905731a68ed30f0192bf76c3f41eca358895f3c0925be319da0b62a1085c0bbfb390cd65e78086222d8dfda453b7433f46fe4a5a3ddabbe5df71655a16e6f76b216e5cd77b727aff3acdf52724972f16c699ac8ba1402216eb16a0521920d0fd26c51a1ea449c899170f4578c8dd5b44e9416bce7660b21294a95a6dfec006cc2832130ac32d6de745a0ff1e472cf986bb0e0ef3b6a90f49744757ecf5c284896848480718be845f3f154a7906ae7db9d1defeafbb38fd4c054c11b5275e1e6e853db4dc31adbd2d96ac1f6624f77d6bab8d02a8bf5710263e341cbb5e91d7fd8983c9860020d04d761ef236170e43a1a6c70cf07cb665880596addef4fd328cf1c668786767392d0931fb7318a899fa0a51013aa1b88bb1738b0a887e5238c9dc098920c884fa07d3fc27081ccefe2d6a154da47bf2f33654c68cc1f42117d1e7703f712efa23595fccdbb0d5d99da1547137dd3024660b1328385e54dc9052ce55da2064f58c139e15f2c70f0026ec5ffcb4256ecc8b33116f930e71554060a8d1ecd748e44c0746f3616d96a4dfc23942c60d73922cd40605b4534aff46916468cb3fbea4277386d3f00ebfd380ba542d4a0171f02e406762d8a0e5877edd940aefc95d45889a94997eb307894cefc0e40d9a8263f395b3a5244c3289b0ff707d4625a74093a90dd31dd71db39b787adce7482b3fa12607fe9cae2671f4495f55bb2df8566ca586b41563ddd9217ba913bcba1516e7626d0a677f3c8a60c139c0879ce5899ffd4aeb0916de7d7f6d35587f49a2d289226d6e1070067e7fe33acd40c8ca813a2d962f47bd1372bc1e88459f07aae080f15c86bda0b4540c9e054a65a73c4975e6e2f5e810bdc7dd0371ecd67546f9eab04ebff4280d689344747fd2aabb97ed0375c43d591341e566da2a01361489aa3a8dd928f771471f885a9a869d523b9485acaff4a14179e4727f36d7babefc0fc42aa3447c75ce93340d3af974bb6e0bcfa54bff0b179c5069a2b074bcb0729ffcf8642a17af687e17b510c741d992e412f146b959f035f6c520d3d20470e6d672efc563a8b852a6d830f50ac73437ebebc0e9ac085187611581cfc57352c9d1823b0f189165f8e70af41777da4c37cc92e94b3b3cf565f60ae52cea3e66f9d8ee1b36c5029ec8513e7d62b1a0fe8085f9e3a4651af0a7a1ce5930b6ff7ac848d13719f089da2191812f6be0a1450fd43f0723a0c27e0f034b444888d153e7afa2474b5addb66ac28fad90acaac7693e02e4e96066c5dab1277b2f7465ccca271bc193165e37a751d0d2f369f04df72d478bf8d31beab698226e0d2e17c1065a99f48b9fb77675dce54071143796a939a657ce5bae666af6486e16cd6f5f5f09862f0047b1a4c05088a3f424c60f45d8702aaf334366ad1aebd30ae48b3cf311a3ac7a701fb6c997b234045d6a803e5694f8e221ddc556d6cbcbd4cc53bfcc1d88118c4b7ba246887e1ae6dc188d6c421ae9957edb8af00097776a93b0555f4a1dcc62b3a40aed905635fa01bda28bb8d39383560bfafe073dc419c5ce66a257b8964e4a4f63f2135da4ce71e6115ce2323c499d019d8524a2c7a6d45166d7638e2ebf069bfcb72516635115a37efdf25f00f77618d5f2bebe7ac0d828a4128b66998a679e8910e3d4e1854d0dd8155e1e639682ee6c9820084a6c5ccc6929c870fcf2eeb70001c13ab4e39248ea20904a2dbddeb811b1832e0ea06e7a340dabbc6659ebf5597d7f589fefbd67f9d16f899cbb4588e551f552b143c0f12bce7fe701c3fb4a4d21f02c4a10695e66c806872e7e4b2d60b7cfd9ad3028e9c5a1d1def20097c0441ba27ee3cc4fca1a5b725cada5339a754f4cf6aa8da7e6384adfd6aaa38485bac35c1779fd6fc4690ddf16b5a1db0c656c312e0fd2caadebdc98d2286daa49a53837f4aa81dd5fdb2a936ef5c68cc2496ff53f7450806e4b9bdbe036ea0ae6e43a404be4e7ac81a8185ce12c968b19c643b12efb756731fa81bf6272b1808ca1612c382b5a280808a60301c820d5ccd9504505cbd46d0dd110423900518d8c4ade7371697e5f05494e5814d3135af5cb3adf7f957f57419b97d96d214b6f4811851cb5b8deb768b13ef026cad7a7fa34932d906b2c2eec58b1b2dcbdb36c0f5e827ada7aa1e9bdf2f2ede31a2d05864ff4c15021e9838764948cd12b2210129814cde2cb6df340047ab01636d3cefdbe5a82ad273b20d06ab69541f41734774011b7f986c1db33388c2f2aade9e18b5d6e530f770dc4936319566d2c1bd39d35ee90df745b1db65abae9fc039edc9773005b2749b417382a6f3f48db0252633b149e5f0b8b8fa055ee91d09484468850be02b9aa5ee472f75b65129ff0f4cf8c5253d1165d5b6032fcfa909d4e370168492870e5ef18aae35551a72fe4e7863acb1c3edb1c4be3bffea1d226b9618f033b090bb069c8182da25e3be628c05e9a067a67535ad689e52829479e6ee9fd167394f6972d81dff10147762e3de5cc910b050a39a15b742d200b1ce3f266ab4bb302787c233d40fe8e3921638acc38a52267d6341471785d865089e94cce46254cc7c624fb914aa3c189f8253dfd9fd331c14f881f4f5a6a178e11dd3cb720bcb35ecca0127d76172ae59bfd6f31b55a586e13373d2484d43924e2e86fe749c6729c9ffdcf460a93857aebf3464a6577eb9552e4c924b6eeb8659e524191a0c85fed2e3f9ee1d73a009474ed2d4f1ac5ed5a523a5a997a02e6d0821b2c40a5a273e4034b85ffaf4af1c7f0cbd33aa6a89373ec6d1710fb76d7eefab62edd637ed67cee0323de1e400be83e0f94b05d899a5a66ca5cdf79895639af60429521fff030f511cd7d9b69c2db569994ed70a993d384fab8d1b0f3985e37ff5de079c3112efef5ea5e699ddcf89fa0816dd9644a5632bb66ecef6d532d2bbd4754d806e4f00f98abc8a3cb1fd4c10564bbef15d87db958703429b34532a1e66e817e58170267affb0ec206e09c2f321fbe520875b30a22c4eb2b89254edc4ac558806ac73148eb2860ba02c208da51c28f4d252ca989725848235a151be7a7aa4005779332e482cbaeb19e3f33469addddd5a092f05573d0da20bb3bc1da020446b83c19cc113dff21978d83cefcbd3de113f393aa0e6cef86389eaf336dc31878c485bbe08575f78d9979a969cc84148f1a43fcd96afc9a9371ffd129c2055626aa8bd1536ee80a9235089d95ca71beab03bcc24139aca06be0fe30929b3d0641848d8502bc6de736a721878e9394e0b99044978b57c6aee4aaab425b0e726041e05ae8b962854a6b971ac83f6da406c1152886332f166bacc810758bf44d957f446d1528e28e94af339597465f56f01a4eb23e921c7500a979ea7f520383cd13fc4634e7b89d37b5f00e0d2054456bc159e6bc978ae0f8e0e74a8f70e01542249c7891091c42122988e50f0c6324957fbc5e591787adad955a6a03ef2300a9c2cbe81947921ff21c772e4cd79ea7e72dbdffcd0c111a7ae50e938fb5e18e2f186beae0e9c1ce6024a7a7114b26c752182fc13a09b1d4114cf624031c23617b91f4d2b0694ba96c4b22b0fbed55e70ae3b96cb7f6d4bc67cd04911b7362c8eefb5be973825d2521ca0d2e0c5c8b09c0c512fb5d1975905d5a69674d460f5c21b9618c26fe8217fefb4a089a1779862673c61851f292031d3c0af7318686be4431ec74499a8b50b68ba1259e503cd724264607315c806be9c428bd0b047b03d08c56d5f1e05ba2289c3722dedcbd66398b84b0a2256e8eb0e4d5495bb7191dae7fb047e1c7664207d4e916d3ea8aa89a6aea2cea81f1c5572cbf499fbd62f93403ebc22bba3f6f1419dfe32aa7169f65b1842518f4e8e31f016f20774ae9f2208b13413921587f6d22d09969c0a3e7a39389d37f42cab001e4c0ad023b2e052b60ccf045f02fc645302fa667941feccb15cb842b988829b5c031e477711e5b2910b7d56f59d30c5604a7e1cd9050b5a13cb007164102bccbd7fe697d8cb5917e43bb99ae33038fbefd27fcc815704effc68bbfac5e981b1cea54cae7fed82db70e7e672122555a2520b7f50f180aec249dd4c48a448416052d58d71a06b1262170e797b0727137f02c0782a576cec252d27c98e7977f12d3340a26f14ec10c16c2bd08c20a7b2d8da0092d91f3a28cb414550b3cbd31cf39f191ee8bf07becf2a5b23f4b1e047e50fb22c3833e0f00c653aeee60423bb8222d3815f92eed2de3f426b997c638d88fedf3ca38d478a4861372efa2680c38d8d1448f66029bc38d639eedbd28db42b015b8289292e6fe173b33652cc3bfcfad264785377a983382893a5125b8d6febacd63158ca5802b68c7cacd531c0c8823d2877538ccaac17c3a15555a38476d82c8e8af6c92804d07c4a8d8a9b281f5900fb2c653ef813ed986fbacef3ae499d65c1a696422018640acb66879c149a8451b9058d1a15dc2af7d8cea967de9d65f5b55d33afcfa3d2206a92bac91e69f1c3624a1d178552ba59fa159ad45b3e74edcf116b6d199b7d148d3b6605f4e1e0c4661987f182c12d5c2aabe1f9ae1f6e5b9f5b8d1eff4454c2129cfe7721f1c13622193a3f1110ffcf58c7a6a998c49cb78e39ed9ebc65f71f64f79c6bc80e763c6256bdc3a8d7a74ebdd3304269a0f55da404e58eb27fb59bcbbf06a28f558f8c031f68b3f4d3adb29f9ed7336c8b9bd97fc5ef7a7805abe04157030cf5b38530cb80be8818d4c4eae0e2e674a7d76801531ac9ad10f6950c85db2d220257a2c92aeaeafea592543ea872c0e651f65300a4ebb98cc05a11d16c6cb0b11671cf3aa45721e1ac734bcfe3870e00df7442b6cd11d029952d3199a7abe4724454810bedb47ca0bdef56fea2e09d05adc64c7aaf1920e09612f3460a893aa8df369b5b1e760837250b658c40cdd63f230f0dab9de8f5cab65879bc045e2338cd206840552675c5ea5b754416d6083aedb58378f3b21ea931dae37cbcc28e089bb020df681b0460675921917d8e300d78997e0ba8759a82506be78132dab7a9cfb3c1c8bd3dfb2be8acb894ffc95fe4097d6421579c758de0fe9cbfcebb7ee2ddd4bbe3ebfc445ae2ba41e0ad8fa051538477208e64ae2f0e79154069704c32c0090e3ec59af5c247bacc9bafea6d5de3ff96632cf97fa76f54aced28a56458c751aedb7be0b132467dd0a0dd2ccf97d704e2cf80ec1a71e1bf83261dbdaa9d2dca7b61597edd329e0320a65f9854ecd78529e4bb0366eb43584cb1d8d430ea2c5c36698d17851bd3a128f33857077a3c4de116ad616e38d311ae70523506445a03271e7d7217115c207b6498d42a58d9301702a41d26b52032987182ce911444ba8ee5330e4e54e1cd71c5a5a7eac1348e8fa328d72b6348f713c83770cc0e33583dc6f759f756392d526550f88526e9f497b8eb126665fa74ed260b30e59e6c450ae9be852bb003c335364c53a5cacd84d22bf1e8ff9e64577575802b1c9cbc87ca853a0b52ac69a2be9e8cffedaba8f55b3f38130fac185e2121b7d765f4c33aaaa5f54fb7cd8bf721f3ca4c4cf44b2b5169166693c26b2e3085872c0358c5d036ad3193e1ce967c61ed8c417d7a55f6c3908e5d91ecc306cdb4647b41607a3ae358c915c4edb14713155ebbdce23308cfeec3856ee560f982fdaf73f4da128e8c33f76c4f9022d0ced85da7992e410d14382d195253565a9e08a3051bad10d6f4aaa4f03edc87aaa049e4315eafdf6f869290c39c1e487c8946d607150e57093c0db8462e50115ab83252f120e28a183a9189829240e7353aa651e5623b10e56f2db01c8193c1fdb4e4b03824ae55fa6358d1a60fc498c9547554ba88f6c744a9905bfe44571088adbff0328b75cb2a10d6add544a60ba2012dd88cad95a8a1b959b2bdf327bdf9b8321751096306240a1ccf2e7fe71cfebe84c7c82fc35e6bc37284d47e9fe3b2b90c9899983bd5053e62f89d4662fbe0fe26a31f291d80a55aac1242163af997293b1fbf243a0acec500af9c4496585fbc7908e17d2f2c409590c0435284b85a524ecb3b9d62b6d2eb3c13859d40de7702b99f9c18677c4698fc5aefec7f9a04577bd8bbb067787f7a32e61cc1d68a8d3dd0a22b826ea6b496bfb8e8cee8d30bb5e153faa8f0af299e656efd60ffe96c7cea5c54beb8c61afeae7f8beff8b28d5cd5bf4b2a5ddf5242051cc9a1a809c5969072d420ca43c45cb11ed78e6ab761d269998e79384f6c3bc0335284596d6b9085accf517b8f3e95b55724c40f08451084338910414afd56a7f9ab5a3023d2588cdc2cd24e132fe34d95a6498fa65d1f33da193da13ee72b3dc65ffa3502658a2dfe903bea13ce480a29c5f3f6ad637b04fbe576ee3b19aa327baaeb1a8b67f3ae666a7f569c9a3116adc382355698b3b5b195e71ddfa4c342a51771327f7c62f6d78b3ef8eda68fd3e86c253a1e1431e309647c8df2163fe7a8781323558399c2dad4fc6dd23c4c5acdb960a7ee76c8e81f8a814fd3390736e5c8a2acaf50ce7ca5e04784e09437329bfed52b29c4a9eb01c7b2a10cf5cc1f3d6429be388a5c49aaa41b82fe13f8d166a9cecffe01e573bb95a2880e05b1336c57c0a823a77fbcd12ebfabd4dced2d25225a27b836a7ceae213134c5f02f63f07d931b160f1b29037884dd979316549ae310c30a560f2f106b31a4fa0b8b36d138640e72406dd962a56bb7061bc444c4e6fbef3135685f811bb4b1f22d06d54d90a22dc1344566b7824092b84982c6698e6d1edd88fc610c373ba2bd5509fd9481c542705e5bb1402472e41671ee44dd2b7b8c0c9102aeb20483ba6f73d87777d783344b398571ae61f0767d9d79e2c35390655dd5dc96f8c7346847702952f502cf403dd9736dac73c2d19c95262b94e5b3fb1f5b383ee4d94c357915e511eaf9f8166e14311ad8ff9a333f00a99ece8e8699c5967733d1843c35725b5d6c33e498d6e8231c0e9d3bad3dfc4547834ae4717de536047d30b6106107f2361c737075c17037503672a49e98b212fef7d88fcd9430510920162ef67e4376a2931a8c19bbf69ee1f55a4c8629a4737fc4ccd16df16e7c727b51e6810b36e3bc6d6f02d5760fcb4c97e775daf81dce3569e991081a55783068f4894f054659d827c97db6aadc70fcfa9ac3091d6678394d3bd1ec1c84fdaeb1bff203e4cf2218965031a70b47b4426f1b8832caee3a7643c222afe670b7364bf72a6a41bc92ea7a04ebcee4cd274ff6a814a38799eca0320a81c37786b2179f006a826257bcc755f2f61792a7040bbaec0ef7ecf8168546e57897695623ca380cba2540eedbf08b7f4e27b502004ebde138dc1c0b74d855bff264248dce27ccf708d11867fdd0d40c7da5e9e1bbd96b947955b2d850fd290cb264db67567e83ba3ba94ebf6eb5121ca34bcb74e03df868bff785bdfbfa86bb45172784338463f201ac9d61a7c21f027d09040bb94dc2a7e9f770c1c4e806cc8fb230cd47d1b4d91583a830ef7e20060c7ca36e636a5658fc2142a4b5ae2d19f35c3ba075d1506ced9b435b607cb59a056edc551077bb0555f278612032cd78f85062b57c36cd481263a59a1fa1c43b3395993692507dca934bd25b10a338b2d1b2b15c4b191155f7444fc6461c40562415b259d08752743ecad64dc670cba1543d324d5ff0c5aa34da6c29563dae50db39c1e63554b22c591db2daf7d532fd31438677cb4c663bdd9c7b1584a3c118af5e41739d539762947527a386cadbc4b75e3d853f2197e1788e47c3ea4d29aceb5e7df85713427ff6bb14e83da4575fe126f46f7c5f79eea4e002eaf9996784b82c56f759ef15043e884b43f5ca19c22094bd5a4c2733afbde46bad3c6209034bbd24014a72d9636978ee6c1a5d1c3bc3b83922ae4a6ded93cf647938ab93ca29e4a7459d66f02f8e889aaf29a140051217a7ba16dc78ed5754fa6d813fd973db12126ae4d62d6f480a286b72ef645d22c05278ac60ff522c9fd128558887f5c34d69b7610538fb002665fb3d81e8ef7924f5328bc748c4998dd67aca1779978154c68786a403b66be7fb321142dab674f2f7e4b4269187b6d86f7cbdc917f596a91175b852e4ad972c01d71aa84edd2a961267dddb4aac4418a6be6861b3e9e1b8ae793861ab8ac9c02329f277edc7c75e6efed9f382f6ef5ada8d315d91f7a26eecbfd900cae606b4e89d2d65a296acdb634f8aeb59c68cb384868422ccc20864675d8c1477ffde69b965a544e5f8cbe9553a217668eadad06a366c96a0aed6a52286d978b4a61da01b83233cc12867809b313a6934627a3e70cdefc529dfa4d2fe70fdc1167dbcef9491a5c4d0ad6a281ec7031f83cfb2ff24497902fb4d9b46cc29cfad69e504e453a76d22dbb47119f4aa785b4e3eb507e71a10607c12326ca652e14bc6371c733b10991b5f9eca7eefc1e1b5c5b616b574fed51e89be7afce7667f5579942fd2e0ff91c25788509fce21a3547b39455be7bbe074c9e43ee176257c144add41fc43a339014a32971346b2d0ff662624d969cba1b5065feda6842933817dd6b4d0befe4f7a43ff7e771ab5faec3d3594de98b2bc32d747adb2fe90b4608d603e74db262b37b52e6357140ed91bdaed066640763f3c01acfbcf3010e472920364e355d0662d7013248c0afcf16e29f32271ef41df6a3912e6ae7c7e57642d715d0a68873dd174c4abb998f26a39173fa0cd3e6fbabe629d787e59c244128c4240f7bb3c875edeab2726b9a46bded72a9689763d419d13225138bc1c0d67ee0174a506d70649fe568feaaccf2d87bbea0d08add7eb1a021137716bb09a80fdf306cc3726b745d506253dd585ee85b6bc237fb8406a4742c6c845230ba4d3d193a524f840ed75c3658e3be9a7008e786379910a75f8a0cbfae95b65f7a0bed5f83fde02e9ef895a50d6aab1a9878dd2f5dbd81c2e8c996f13ae30deafa95b5e3e88589b29701cc0ca86d985392fa8ea0fd21014496787c699fb4524f9356804996dcbea3565c0ee47c2765f6c84aaca085f186da87074bb473dde3343b2bf192639ab6e264ae564116e9ca6095584c9cf180b7b95a7996a8abb4fe2121a9cfce2dcf04ed457dcf0e3e4703442a68e4866a3453838fc9e2d55023ca39f3da1e0e22359ac67287ca04d7c016a97f279c662edca0cecfe0809f5bf0e5178cad97f9f5f579a90e2101625f69b2efd0222be8bf4182cbc1ec91176efabf50b4be03e29d52ab698f0743e7202b63c6cfde2777efbdaec66636c0dbaf9fa432a2d62c5f6c8299ba902f243a7f020c70bbb5e62c4b2349825564bf31abef8700d3da7946097f785301efb9844a577afbee66342e0c91f43b10fa5106b65fa828e442d438c848cd36560e5f173eff1beae9d0eb02c1ff0eb02ee56f75389768589a2cdd258df1ec1c96691f84682d9f208088f602a4b9635678656726fd4de763d8aaf3a129b7b63ee1e5cab5f53c2513410de88feb164ba652459feef9d1ca728b62537ab74e4bca92a13a03de8daefbff0c07d84995a26aca49b1437c794ee88f8135189896e3ee41eb79dec79e8fdd84e195b697e386924b52794cff838c57a6db6a227faf7d3e97ef9f2b9695367388692299efc396295132de1adaa9f118682a1183c93508f43d6c490692948e7378b91c8edc0b85d3963931e13be32f7276a72f8c1537fe50e7c4fa17550732f16d310dd6d595bdf717c220e1bf9c6b846abb1edf83a3d7048cb02330f7d1aef1b6346344831fb296936cca82a4b15e4d001fd7733a19dbc4cca3511c2044277861a9e70e7946ec9eb36062199cabec2fa82e9ed3943854fdbdadec86488a6b823581ae331b06a212e8e95893521483bed32ce4b013dfcb94a9c9f56a70b4f14536eb65efc3e9968a1c753a57d422831ef9340de404e5a890d363dc3716abd3e8ba3c2699869323853dd9a523148b618d5ae5febacda209e0218dce72e2a28634dbf350a83aa955ad0c284bc91bf1c113ec30a71f323098c96faf27381c01f19b8c97aade95f975d0133c642e50b21a251b20e84f364db239f7dcdfc47c61128ab178a2a2a7403fce29a57377ababd82d641b6099864bba181c94432dcd889ec9ccc4627b7d6dd5e67c72ff4ba89272fb967d3c5b12c1e39c10fc0c391facb2ce889e24b2a32b1b086a8c99161dc4e3f53054af8749379ea5c6426216631a4822dc06dc5fae6d39ba0a86045f3e77b893d9314ac1af8b4d387f973fbbb09cc448c02251fa409a4c86ba0e540c67c6ec8c3bf1355e1b1bd077d60fb5f2fad93a771a984d1e7c95d94b0a3095a3fbfbbc4a6971228936b0c5fafa1d7729170ac18e13b7d8f10618d3309949f2ebf82014d451c83b32a6dbc7a0e539f9e544c97a90a1ddfb216db96234d17b42ac92dbfb49b873e628c7e0d8f1224f4cc435c608caf504e5c7b283cb3b8a9463a6f2ddb7b1bc18dcfd1b5156b054ec1543ceb0b5b66e87a0140d35b4a262634b9982c30843304d7454a9c87cef92b591fa496bc766497f6ce773aa82d9b814eedc3b392d9ed1735b8b80f170cba344ce4b7c35cf04b4b7131c7ab2a3822cf89ec54dc01db7810529f865b6e97cdbb4df95f364e6d90e68074396ee8862c020794ce401dbee895b34e2772eab11174eefeef2093180dbb8d34b01d4937d70dd7dbaa2220df2e0dd120bc29ed5c95609201775b68598544af9d63c521967501271ce70eba7197c5b62c633c48e27b686c8b5a4bad4d42fcff09441c9fa0dc14b3af0ab21daaa09c9879782778df01070673bcd86a26a8256a4460d114fd9aa6c564a8ea229a4e7c00ca298943841deccccf7da1e3e5dd23d008429542e0cf07ffd038b0eeb03429d26e56bb9858fce4c9b4832f327b4f29847237552c30c4323c56da0999595cb6645a79d0862a070395cde11869d0ca14e4bdf7e70da5b627a0c800f496db1a4a2e168e973a2307929fe8fcd43e353d25b17749f537b1683d9574ab0ae2260cc0bce3d2af1324f2338f97860c273a390bd42a449bbbbd6680bcd2f4fac8316c9258e65b1652aea798a166d537c9e3fe9b29f72c12624109a2d4201a099806a3527d3e882e6ed4a839cda795fc09e1a38093099e25d45d091d50a41930f61269a53f503bb6d7569526e2456dd46f068e3ddec913652c3676f6e802484d4c2841cc5be7d131c7e1486939bd1b87d7f9641be464878798bcd190fae71cece5222f161de0b4a4bc3a7de38506f09015941fc3fc0eea388df0482ed5f5ef3adeb8d0cbcaf5408451a03f2e25cd97b9efb0eb17a7d4f372c9e370abb1c09ee2aa244918ca0fd4ba2edd4b46b616f1f8b99ffa68fee1fbae003e47a32cfe7d6cee5259cefbdbb5f4de92ba288f13b3b6be4f926661be876af01a686f7651b90e2a54ada9b674dea6dfb3d424b2cafc2c586aa184b3fda84eefb9ee4eb3199eb46af3daa6df86f0cf9f1e9989bcc09477d1bdb2b60de2c2b8eb5bf08d395457b0021c496d6cb38d245f18582c0be46329b85883babc32373d9737ca1e23ece9a9d3158d1beba3b747c91a60cd983268f972396be992e70762cfdd638831acedc99decbf2cbde0450b285ced2938e3e64851ecce60d96ac8d87c480b51975d4d4a2493f368d5b88072323c73ce53c921bfae5e0c36d5fb89bda7a39ab137c705e7a5b67b96474815ece7e85f012e2727d9121162ac92c111be1439014ff0f7c35174543ad47b13082cb2077611a9e618bf28085bbf63a49d91c0ed72faa9bf66309930376e05b607283bf2fcf7fc6cafcf5ce40335a81f618d92a78af0f0bdec9959d72e622bd84b93a2626a0516d01062d98b3cb48b9a57ae804883b7a46c8d262e22cf21f0a962f5b64c400e1f97be362bdaff9293ee1c70bb71f28c510048b473dc7f4463ba359d7425bb12ad10c01f6e89cd2a580fd4020a68f94d6176750389155f33737851e0f660b40d9081ea5c3d9a776481fa43115dfc7ec380b4c09239b02507c106e514812cae00e3dc82eea70efc7d3644aebd4e0a71224f7ff0873dc007f1da7ed906a2932921d6539aa25b58c7ec6b2c1f0a4ab7d4aaedce80ca6958cc2737494348b4153b187aac2468a0ed648f9eca27bbd27fb965e50badd984152dad82327b6a197558cc7dc34f39e97d469b84fb4686f66112fc8453528499866e58f6f3bd5aed895e504fcbc9aad5c9248ad76370322d73287d5ed2955d049c0227f3e5e8225c3175c33533124b56e837575eddb3c59509ec67c0cca694da9d2fa3239e405d4812bffdf56d6dd19ac2bef325fa8c6e57d7b3b5f20807deabcecd92a97f0ae6d1d1dcc8e26b7a2fb9c821ba2fbd446f158944938d31d05c9c628e0223d0e4478ef259e0f5110e0e0541004886d8fa25a531c7d5f2dd459ba298f50549ed9a2bcd85482476ae1489dc42e190aa30d6bef3cdd396fbe1bfd85f638e067d19070cee437fa06e335346a145d62494954a967162ed63e83ab9abcd613fa8f41e7ec5617440c0bcaf8124ab96787e311b787cb46598fd705cea805d71ac07130bd60fa01bb7f4c5f506a674ce8cee56c5622f6d3f34b1d76293c5e26bfa7f7aae47fade991516f6966afe44e504264a27a47a00e2014136bd7193ff9e38a16e10c10ac869cc8346d05cc5e9dba36ff15a6f2d61d4b4c8519dc8f5d73ca3a6be0438e5e0caa2cff6314db598fe72c3818cb73e985bc2d0a53df209af1b14eda468f7bd97d67991467cd1d2b1824344fae337c3358a63b0fdbb4f0b0ddec09edaff43d59a19cba6965e7b7894e01cec308c33218d814fea0b2b417b02c911560a39d70d05e167a075c654fbf7e3317b0f2a217caaaa76dd90526a43163087a5f0ff4ed801bc360e374e7e877f7b63b8b9854f2b753efbe1da0ff0157c8f48e4859c88b867f172db6e89102b70ea2222c3ff97b6d4370a4a1f8adf901294bced01a37b638d4f0058433cda785614aac740cb5a2eb5f36927ec4609a8dc93f65dfa71ce34432af304631f7fb2403b1da95f4cac086e03ddbc7638be4eb006021310d081a88d6066693e156d6f0d269a061472240432fabc9a60b05f5f0358f613ec8d010858431800a7ed12df40f90d29ec4ee285fda3ddf50d809286da7a05460197e615ccebb907e037fbdf4f8d62da6b55c3dc932c560ac72b40a82971394b001d1bcee0041975d2171e055ba3cf8f29ec3862cb01fd01792f2620d5f7f524cca35201b8c0c58722b925c90f5fcfe175b95c5827fafe3e46488b0c1c57461f5409d864e6f2c61f2ee4d4ee7cf89bb6440cae86dac0c0ea491899dd049ed647e2fafbc9062216de8a2c8096099cdb352663b6dfe2f401865e982d9adbfe9269996463cd392371d91699d85bc4ac8985c7a368818bb0e74f534bf6a7d119e43a9e26c8e2ed72afe5c3978a4f250f24cf76ee8ac29b53b879adbc2f7b5666aacca692c3523391cf335f33ca46f1d0420023d9034e9b12d725b5ef1561cc97a27c451a522a6de758980596360fe5fa906a116a4493e6a7ee19d6b4fc381cc421530821501bdcf33bee4f05cacc2da74b9a8fb7c673ddd76ecdce655f39eafae2f9fa5d5526dee5502bc2925a64f0d15e4e9d7c881397cf972c57f840eeaeb63c0568244c0db2d946074174cba3c02487b468eba1992ef91f16612719b07b323005a45c571a405b2daab56b2282038a9b3a730b0099a652e97ca6b8194bf3626db4e55907bb2bdc1ae8dfebb276047b4e5ed4c13d8d116e81f0a349f2e4284eb10eb4200e7509730146b75c188d634e6787b2a1f68085ba4f0367267e52b2d6f3dcbc3bfe03fe5e184ddc1b706592cd86ce02fbbf01ad1f7c2cd19abb3422fc7e7e11fbdc6af34e19eaca24c87a75b60f301f1fee3c2a98094c870fa8b95bea3cd8d73f0e5f223dd3dd61784b8b63ad3b257c82f205b4e9570bd4ec2faa878d205eedf1b247416905e5fc884620323f9288b738ef5d4e3d9d7d7f3bdd2823823a7d58d91d80ec516d26f697be6d7e398019bee8fac7b6de0795d799b00d87eeb72f8fd4c21bbd763a66eed2e2c127275af88944934fb0ca330c5fd13e6d27433e00f4045a1a8c362da7269e92102173f3c56f992a9aa2e5bb2f23379f61640feec08b8f94b3e7bf8647491439b30fa08ca94f23732b0ed865578934d753718471147ba73fb2f14dddd1ce1c5ba25f933f7968d2b83416c5457cf75e7872496013bec2b5dc4a9019c4ba3b0791f0021a020ba795e2438dd60ca9ddf7f5edf9002f74a0637b98a9b924738d07704256d79df8de615b8124eff698216b31fd144898653cbb8e8b65d01b6002feda7eee9deb48ff0cc1a182acdd80af5298a2f1755021ee3b43362b184c9d0d1c5942c91f761c2f1bdb2fb9ba373c2fc7ad9f8e87bb2d250723567548523ff74cb40823e25f898b938141d5c523e9e43cdb854ca82ad65f13511bbb2d40a34ba78c3cd5ad5a6bb9516114a660fae6de654b385659725fbe29b0c56ffcb70841e1c765a0a38fc5ef5f9ddc3197fd37d1f24e45753233cf2f3cd68c6c1369f5cd630a4a867ef0588ff1dde14f5f5bdba068d8200fc70516616672fca65c161ae49ce11d2ec2cf843d05066eb5a625b81e08f871223a83a7ba94d3fde7a67bc530189730c8aad5e96c0dc4f9c0f264d052735a9cda28ef3e90b86c317eb20156885f8714ae00df63e161ef44c60d0dacea41b6be631ea8e2bd4296e812e0a81b566c75bc56188868b9afbc1d62475578693c1c0b5ef2658046f20bf99288f0213461298ef7acf5958dcd131a61ea725144e588e69da68efcd8aa5458e500fff5fe9b3baf56c90195e62641eefa1569dd93aca0a90440708bac1f883a04a3fdb0c6e192983113bc371c7bf324532636fd507230ebf5a74b1c5535b72af3cf28a91ce34212b86cd1cbabd0d63361c54f8e4ca0558523fb5ab0c73e4b2aba3205bb7cd309742c16b2adaa69a5fe9f8b3fbe073f91ae649d122dda3149e5be3fa5aaeb3a07ba90de9eb4970b4da02154e93b67716476e8c92c6c88719d2a12afabcfdfe116b827dd62fc7f470acf01d5cf6b64f97ac78e7587c48914b7dae5d703338e16d5b1ced1504814acc1a618eb956d83935357495896ff3e05a95b27dd63e4d8fb8f6bd681f98e3ffe7559637540a9dde43de3f8d47f551cb21e6983d4c0f441aedd86811459e76dd9cb41f68b88cbd9332c8ce09af529394c8e62821a3b601821e3d6c1216a8e4b1956aca5713e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
