<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9c6098bf1de306c27a53e5b0b81da7bc8bda8fed653f673599dbf21a2d9d52a5746dd0fa54bdea1f3c4db6eee2f00d1f3d9c0b24e18274988c0a85feb78999da971f4212051b3ba65de2f24e542c771860e6340c89a8cbc3261f0003e8055da67dddfa993504fe9f352242d8f4921498874394060e987c7676f006a577e73473009f204e330797268aa55eb0773789dac278e3486480bbf5564d6e661a51f52d7a3a8066e506744867b23cda36666db25f86880774045a3d69b61dbe0a20322fa2e58f3117d2ec6498cb424716457e58fdacf61e4c4d0217559371be5073c6d8c0a2da280ec12447a608e7977df8c64ac4c4b3d463c33757147696e061addad2f79547aad931e1238ecc8f6080de42ed11689ef6603d2fe7db0a5f956b95e057ee4e9b497b347ff13e6533b1f7d108c1406e7b5086eb35d0175684ba064ed72f53eba1c440e2812f08bf893f3ed444c80fde4b813cd4b59e660b132b01d6b30d6454662f9c3dc54b932685bdea3ce272a16076fdbc309d1eecc9b7af61272a88e0cb33e68c549dfbc00cc204e9b765cb8fae5358cd4c56202e09d0688a26aee694679836440fae62976e34a9e89cedbcca6fa256e3c15f0d95779a60a007d29aaf86b6b3de58061364b812cb6cdd3d302aeb428a33de031af4b2ab98778a720e44b9b1d3634dd8b9d77259ada4893c3f61886f7cf023770ffdd7291b227d2d23b3f517c70fd5c06da7e5ed220c62ef2d38067193fceb679b38a9d2fc83332780f07323608f89a32efed99028af8d53096ae0a0b457e73f87388ecd8c2e6667a64995a2ab1a8be32c3c267a532d3486f997edcdcde7e52bdecc33967c68e4930f3dd097e97dd77f6f1f573d1adc512eb970457f458cdd0c7052214810fc93ad5c45e236c5ec533e57a89494b17896b2d75ce519fe85445cb75f008faf6e3f0bcef311129dd6dd3024d7677c4c9710db60eb1e719d43ea2f66b129f001653c44ebf1384d6e17bcbbec67334a271f46c7a782582db3761d6a5f91590d0ac925db3f61ea80ee0356e8356920cb35993c92545f934922b0a2345698748bb0bb8fb0714a829246b0a9b4ff9509360f3fee4094cfb239d8e76b676742f39728d3d7fa921291a9f745eb4f6a1e06b8a5058d3c79c31855585c81f04148930062c07f2095ce2b8710448180838bde02ba5d35e0c26373d38c2f21563b28cc074fb129dc0658410c26fa1723a5af4bd936d89ac58ba5a3d11eaca799ab8729a5090cfc136e7bbfdcf38dfd4fec7d7324ef6ef1b16610bd922acc388198247a9e36b1a6a6400af53c40e8b3fc99ccefaafd341ce530e9a75b7aea9900d5f522b823861fe078d3a7f8cab80a39862413b83fa83952f923f6a05c3c99dbfa62c6d86cfba8e9e533892f3451b572cc4f6278fa553ec29550c95144f7408071007435544157920f7208e42a07fbf94c59dae9e7e806646746fec0ae5a1a70d218cb5ab884ef36a2bced9f6664cc6979e4e6837706444229d59ade17866806030480576747cb5fe4a3e5bf70665e23585ce56a9d9f74cfff09809c834b59fc633d6d79f9492feabeed939ffb0150729e725fb988b0563d740762e6fb67750744a2395b65031e70e46666b6184978e5c4ccefd467974aeb21be76bdad13171e46cc65bda2ab254928e5504317230d1267327385cba28614de975038c6aa6537217659c5d0f8429af41062d6106c966baaadbd573e044c8ca5bb3e5289d5131996ddb89e89a30ac095f3661ab5608e7c1d9f7cb9b05f55e6e472fd9f95381d99d0234b1922c80c218fadb34979336f9ed4c39a6de7c2e442b2aa2baf010c5c8f4fb4d54e18a3f86cb04fc4efcbe72e7823707791520fbe8d10b602bb23c61d9e3627e1ace1653ce060633c706d0db89fe87c6b022205822c97fc2c324ea83eebe76e9913e579eb8bf5ae1a6dc1e49397db5b05214e0998a76a2143c728a5664d0e0aa78e5604374f8dbcf5c9517f5f00966def5dab96f898a0b3e95100b0e996ed6ce6b3e4833636716273706951904111bcbb0f5149279d82ac2c553512abe934fd3f3574061a5f942035073ccc0796f08a7d75d983ef2eb65f1abf0a72ea6a92799680695a825a6c579c04bb4656df558b634c673863882172e194da291f74a17db9119bc8a627eb90aa9401584f9cd3f91ae6c408eb46cde10b2107577856eafa12b813ff020faf9f721f2a3ae922a0c8c76b20c49a342f5594abc8626d91e971f49b7bdca7b6f528c2f43936863347b76e1d85f6940e57b58db470647f5537e59ee678a313b6472517739b6eb30e406525ddd59ef57ff73c55c0c7f7d51b25f6ba4b1467a7e50ea949657487962150810b69d46ab50ff786161732eb9ecf54ae53948ab64fcc7d58c3fd83bff7e784c742798a0244750c9417d2af45468251f610f266a5039d530b26e62752327a66b4c3d85a1a9ae62937fb698be14a9ed6d695b431b855bb040ca76fb62bd29f3c5af6c0d13a7d01d64dd5c87987a9531fd5a96d4fb3985bedcc353695a63920afa814b74276d47cb7bc333042758d361658caa254c61161106fe250de65f721fe1d6bf1fa3da9d5b67949effe34a5521dff8cb650cea550cde84ced1e278fa482039bc4a608b65c9efdac5447c050a6d49c9ae47da568a7bfd146a6c6046b38bb3db0a476284ad9e3bf95c2f641d08f590bc8ac0650a10d1f36babf2664da425ff4aa7a22e9e6af548cb565de00dab19399aacf335ea17b085556c725f2296a0d1d9711cc9d3333eef10037338fe56451363a0f00183a245143ec9ea9ea8e10c7d4463cf64d3361932b8a65f3fbe842d4aae910b265de5d64d78d772d14900250b0c1427649473e94909d56d40f26f0d07bd5fc65ca84147497e0fd6d3f768f913c38fdf148f712e09062be6ff269fccac5d698fac1df18b674e382e5dd9ea97847e3c5d73042f31a30d51d06b7ea1727dd123291904312e616fbea1c25a0ddb15f87d1f8c3949d287fa7bf28c40dae6359e05ac506143642fef9b74ede045662705936b19ca8cd51733c0d9de7c192295ae54fe63ba90b3c275f3a5811636ac98157130337978dcc970016334fd2a9470e11b8922de189594c7c7d1c8b32abf7f899623a849c630789f71aedc55de801f9a717f79e52afac72ef2aab92f37d83077837e095efd142535af2546f45baa13f76851ca303154d62838e62d43f727237cb3ebeb7d1e25debaa56f504296d3e3205701bb6d03f4436ba341d235a91d4320cade64a2c4bdaa476dbb81ec2a2b4a13035291f5a2b81d1e1f4bacd1c9b525ec89f63ddb541ff4e4a98ed872fd3cc0a27eb21c8ae798f07d1071a7f9f0bcf10df2aeb8ab8b4ab94e9c83107ec79cf5abf76fbd28dc737405fa6096dfc76a3d97f8c5c9ea972ffc0eac0088f3521bfecd748cbba1f1fe16279eed7097ef6f64c70f7a58f5d8b2b828aaf30f60a41346ef1a65c508f33f696488b7983e75259888e707c0cc41db1140854cc661b908266b60a6a7b6e3f3867ca14ef5582261e7a3c9826d2529b3167d1cc2273b5df24a91c51523346811cdd9b966f70eda157df42876d75bd77ba681254d78e49b2d1686b6d32a5c9c62ae88dcbaf60830ff41c70cdaec3e7bbf0a88dfdc7b1368acb9d0e550632a56ef4f127f28673a27f6ef2340a6b1477df144fd936ca0b462c22ded4d5219c11deb8b5632f02777b275b8509de81a2c0630b0eeba8fbcaa822b288cd98f60864de59e9f62a331c7497aecef8bfd56b31cb5021b47d512ea97f671557e69df3c4924d07e41d8a0f8ede38a5c227adf521a0f0cee3f890b7186e8f1014ccc30a93afcbce72c2780fe1007bd0a445dabebf1c210f4608db172c98bba67fe985d3bd387f5713d36364492bc82cbceaa5809ac6399a273e09c80660dd326c4e71058326f6212cd14440f5553eb9d7090409db08fb1cde4aa0bcac88ef8a823165635eec40e8aa40ceef020dcd524c52c8099acbfedc24ad86b30782100c8ae49f2e25684581f4befed50010c73381e8bf8c13be11625800f24674a4dd70c8bda372af0c79ce955e9d68084f6d68e5c28b5c776002c12178293882c92a6574723bc1c95cc82b20e1000f285cacb2e3dec43785f9763447e0e2fbf6333bcd573c056887fe1fe6133733083e7d1e8901ebf8d425d610400e6ab55c272ac9401160c8a02f39442146e38c63bef4d6d319d21904b1b4f5ae249b2167d232e79648b25c5ac473b84ecbf3402c43db1a1133d717d23d2f00ab687698820db1a093fec8a63c78e2fb46da4c16ed35962536a12a958dbb753791ec2065fe3e81b04257eb438c15b4580988393fb72c9280fd2478d55d04159117a3d9c99878ba6f6410ba3db594518735ec84e0656b467368c059edcca6b290448673b32464daad9b1e90a40389c18d6018647fa8c082dbc3ba4ff48322649897053cbbc1e65516f74a4ad321684478a8e438056af93362ba7d5678a0909395e75515f83e60e48818281bf754b5d1eff89931ab7e95adcbf4b01b4d227b686e18202fa9a3eb8001e49f81c1000057c79b8aecceef469137049897439ddb3c6b502870ca85b67c10b646af96d8f069ef762117fe36ff7d78d4f4a8b06f7bbbcc0d9f6d40f71dcca73d3e3a953514614e8bb13b65024d12ccb063edf8e41b35ab0d497abd812d8e3f3273160fe6e1e904237fbb17bcde164b665cfda9e00680da534a5febc359453bf175e02fe4f6573ccb1fee156e8d085f3fba850e4f875eeef2b42dd51777dbf6d0df5588f9bc75d1a9f667a15d5195899e3afa8358c2626907d932d6c6d38bff3bce6039d221c0a6062a1b7cf29495923a174581d33da695d8de18562e4218110c305b8513a61c83a4b560a2b35fcddcf11cfdb95054ae45af49b559533e5b4e40b7ebd4b97edc2e787fcf293e14ff01e7d81855a6998c96ff7b68433b67f5e6e8556ef29e7b1137ffdded00ef874e55ab4ab6dfb7897b05b9b1cbb4092ce0882bf0ada13672e6d395888c06287f4b32af42083399667cda5bade679ff5ee24fc6d426290b69e2375a10440c07d7e4cd590480ea7da3f20b71dc35e1545be26a0e3a934ef0d326c9177681e569b07f2428a61498fe50e2660703546be7cde8655e507662bf9e6e6ddf10a0764d853626cfd4ecaf8829cc935cd379a4edfb746a7dccd2d8a7f819848887e7ace984a6e626a77b6d69bd15a4465d100a9b56f469d3209eaad5d3f2eac4959dd0805cf8e34faba109da97ad689d5966810dcc60a4405bcb1ab80186e6f87d2fa3512c20a1ccdc5452c8f58373d799fd83eaf481b525c842b2b7f9d6dcdba8837c79dc0db9056325fb542af11d59cc7c7ce28b57afae1ac4b474d5f9895315b0c5cc99e144f2bd20a6087b1b89f03fc4b26cd1b8b2e8368f1e4e8622a011b28877acd30222a4280bbf64da4684cb133d66f5bb409cbcc0a9fc488d6a1e4da1856119e1ff6f6b2cc0a06a1906ad87f944599e80898b9e8d9e49395bc73d31505668f9e73fce57f32860332cf7165ab10666918afaec1bfb4e42ae828ac5d952c66bc7ee40c1f2c8799eab0e1631aebffbe181f57ef5d74ca820ce8fb004ca8febf6677a98ec9c829403a62253420dce6e586a6f380adefd6bc6d97b3176edda4d37e6e1be92eb8d812b00770936871dd96faf6fb8609a66d11c545ce743af39402a6a14e73d8f0a196038592e9198a1944d9beb2356bfde4b2c8e193dc08f1c6252bc964fb0a90d8b998b4a26c52e1ae81cf6cbb02481d6f1a9061e85121312c0d07de33e7040671d5ccdc01ca69a9cc27dcd0484910f15ab4dfdf1b7113bc6ee1763a743295a6860d677edd90b90286b2188fcdc49c655421d342acaee8acad0b5b4d2793a54a5a8c317134e98c701b2aaa3768b7deda73e47523b48f7fdd29ded1f784d81a40218c2c4c2a2fc8094dac52f18ae9bb6e8945392687ba1d482b5442d521dbf372444773f70e8f0118aec746f163ccb1e878fa46c1190947c9eda1f3d5a7e8b381ed772d68689c849b578fcd24adf81bdab115864505b823a118150da57426e07eef3f9266b2902ba3fe314bbca907f806d3963f21729c536186665baa36249d1ebcd4c9276db8904cd20d608f060a29bb29d4b551df4d3b24c34eac976f1667cc2458d48c135b859a81373cde3c8050c3ad5e392207a983fe368831bdce07c0bde91c8b50d0ce9a9a1be2e09cd4980707d0b89d6210b58e1274b63b09f0facf4ab1c27f663162811a47188196d34d1757fb20d9390e76313da5f070f929827826fc72c877a686b2eeebb93bce579e8bd30d3159956851b042887df1081a322351aaec940a50e042474e4a06c8b5ecc951a7b25cf5c60e3e1966ee46788c11f63ed3dc642664c58e519343c76df22e6f5c84207c57ac6cebcbdfe229443d9fa9a0b2cbf5581239fb3261b4f07eee46ec0c969f5b96d2933fbd5d75fc8d45f35d6c586738cf5c5672e98668e93ad19b91714dfd0bfa33786f1ff2ef46932b38d6363e666f8485a5080826b746af56243770384e36e835fac8c2ed3216992ca2c4beed89809af9427e7b5f19b15e9de2ef4370fcd98d827b4e1f3dd0d930dc59b04edd5fcc9dd461de8b97137caf83907aaf9760f73a276ce24cf92f8af1cfad863e84f4a5904e3b8a866a4ab3b38ff7d9219cf224ae923022174f17c509ab6365783cf5269f2e4ec6fd5ec9ba4f447a9fc4c0f640e2be7809bd1423bc767f54a559bde8e1b722d27c648c44741b3ab70cc8974a13649b51e858dd2f8380a4ed498f685a2b38d618371dc9f3763245eb017244f2e9630205a307f289738606770a60d504c387c257e16b486bfd79bf50c278efd8729563851b3911c467fb2df0a382c76ba5b869be5f285a6d370f52fa54061f3fc0cf0762f968db60ff720b8833b4e5037aa65c8c9f046cd796b44efecace11e510c74ad428030e537196ff6dfa0900378d5f47096f704d2a20ef2b6113f8e2bf19bd2f730d13e94df7d4e971d5f13f56880fda9e0f8c65f4c4a9b836467d6efe183078f6b5a2e3817afbb65950d885f38069b2218f13f648187b5b903f4cd2c64be707876f3b8de026328c386ad31b223324b6cfc9e3559d14ff278d865e4044b7c9f91bc3dcd6da4992d71725d9bd25e63f89d028b825c37668510b07a474471608507a6efa47c4ae6a0d821b3efeb8199015f63f3556fe76d16184eced9cbbe21302dfbe374bc038346d918e82080286811684583e6a061dbd65a5dc0ceb75dd810d14ecdbc7003b8c1b65e808206a740707c113ba0f33116a77eafb5eaf8efd59e0884ad9697b614e2e20c14fcf22fa59d2d47657c8461320f62f1369198726a81b9b047a463d1322b846774baafbd7ee3e2308a5ab6f9e800c8eae3104c92196cc7d0f73f4d8548fe4149ca9c56a01c16a37abcf02ba339470c0af5296766622746629470b82d360d331aa80f3bb87be7da1fab3363a4903c68e771f79e025a6d2c0be9370c471cafc47b36325994a8d3fe9147b4f2cd32a5002ff6bf859c8d73627fca1ea37ef3d4a3f8c133900220dfaf0c19a0f63e57eb7ffa03e0ddfc6795a5b722c2fc0c522d0c688d73005c61ce60ba57120bd7389c98976f437104a5ac3fde5459ee51e8742845f302f0cfa644ee1f8de92abe64c5e6b11ebb81517294f390e30cddd54afdd5a230d9173d95901079176e3c1610394925a7eca034cd70be4dbb62da0e3c6d3645e8da3279a2cb372e617129f936faaca106ee05c3352e7fbe957839ee3bee4cb22b10ce74115e7e429efb65810e984a96f88a449942dc7af0107164e6dc8fbe6e0294a33fc5eb35c6927cd9df1dbed0c60e0adc3fcf4fc76724dfae7bbbce199a34dba0b0e2dca596142cce752d17791d175affd63633efaf11c0117983a31d003c3f48210be90713c3b38297697df70e2465023148d10bc0986c73a51d0dc51f335ba76e9dafb9f0dca149ed44c45f2faf42c7075858d8cb4642c78eb60b5d3fbfb105565e5b1a6058fee47a66bcb5a45bfd23e23be3e167e91a82f201d4cee519e0bb7ddb90842093fed31d31a30345aca411ee724201c62dce0f53f0b10ef3ac6a2e3a5f618a4a90e2927b3a4421d371824ddd08945a9d29579826d05749d91c9e8ea245e1a89d40c253af520e6b3f1cd705975c3c71928f49c8eede7796c0efe7150b4c20ad0d2602ac87d48147bbd3d9bca42d2aa6f2cf0cc5cd0a839be4ab602f379ee981249872f3fb309625e1db3d82f15c745b83be76fd716a1010aa9bcd45c368bf8f749519ad761a74ee5e3b4939f6942b23e16f3c65755eaf1f2b16cded2576a62e8214306981cd41517a8149da238288a7acec785b91101a3076f9345c54e47219233719024703fcf8d03eaafac59f9072c7805efebd6536dae0207cabac7cdcfd8cc50ad5c2e2380d9d1d83d39daa4d96d94a62e1daf4eaa3b7bf17e4f9c27775d989a0f7aa9d30904510d395976903185438dbeaeb909e02008d0c0b0061091208d5f8ea2e28cb8d2f1848ce26866bc5ccd74898c255be95bd343a6aa06c74739faeb9e59b78e0246da027b6083b2ee88cf619968a6d31dd6d33bbf9f5a1832dfcbb481534fe06bc4b028f2d4cc0e82d82bb902230e6241193c1b33e98ca7d5917e2c9338558be5df35751a08c1dd71f932dba818575ec243442134d1cebbb532c42f6ec56058077d97ed76da5c40e9cbcd526e2a368ec203dc0daf4c5a38b150d5c7add7f020ef060dac0940892b5113599e901452c221b0788923b705609c0f8b2299cbdafcdcfe0d27bd25c8e9faf67f68f12765b7152ea7f886ccd8706a9108f2ee05cfb9a7fa92e51af47736c0b9c3008fdd46d681f7dae3d464145a789d7f2c0b6e5f9822797fd80f9dbe793fba741e0684cd490b734de0d356ad92a67c3af8841b2f0d59dbc4213f7b6139e7c7aa3ced6bf6db9f496ef286d06c4f6fb99b499f932da39b5606253059cacb7d45379f8085ccc1751b89712ccf1073d59ffd1995c822b31a7c27676cb720e9f9845e14c63d08c9c6dc872b1035a525b7511c569638bc2b85b636435b82c12a01e2d6f9d8b76c4167370ce83fa297f4522b61768135bf86f98e32e58ec7eca84f560a9aaf8c8b0379d834dba4225a72c55ba7a2efec91de34952a0968a51b129f7d8e3123c13c220753d154b88da3ed69d273b4aff9314010d7286ffeafa3fe805217e7ddbd2d9f08a3283d305054bc5bed0a95881fd4b5a05dbdd08f65188e98dfad2df2ea953a287983d6bcbf46ffee0723e917d59413037f822f07bd1e5722372ef5824c589199040eaa6181211c52700aa283422767ece5816bfad1b1681da13b3f33dff4e370472b96a0fcd5a3e1c066c982a91659cbae8ef8102b7e4d93539cd03f6bcd7cd95102297553e18b502c2bd25fadeda162ca1fb08ffbfdfa5ea0cf0e1a6ae496dc1fe8f314fdac3f8de7cd7128aad75870e910f59b63d91e4eed9f07626bc8a9e610f4334519f5e50d1295e7c023f952a04b1a95a19310623901aa0753f1668e211f610ada05da5ad6008c2f77c33d647fba32a7e2d577ecaec714a86d77b5013e28f87fa2db5c01092b8ba308a1a06eaa6e69c0eb8ab254f731d71cce00977eb115087e364a5baafd1dccface2e276dae0476831c0237753d50c1441559e19d37d964e3c2d8477c618f78563c7d4f96ea7ace6cc4e674bf2f994f0af363e8b2f22512adb787827be6c88f89a182f4425fcf311e31e4789c92ff6bbc56e85d3a69b48f0a50a0001d8e19b61cdb87cd9172c511789df4d7ed8b7ec2e96dfe5143e492c342b5e9d12f86c98687bfa77e303ac683ba2a4ac32f9ad15f5e51e547f3157ee2a1f4f5d849bedc444648ef032df48b5c5342b3eb2876fc3faab9e74d50614f292384199d13cfe697273a1cc9363c396766e50c1b6f14464a7fd047f01097f6e9c066c4376fcf63befdb9a7918b73ebb1b3eedb34eb35ab15886466642840d866e6f3e6c6eb0f8f98d4b9e2dd7ae9f55d976c5e7d05a8e3e41ff1455854448ae23b8b3ae6d34f8e218f3f6d1e41271900d27da0ac4e85b8f1891f266a67a4f57fad8156f19d69740badfed37ad7f3a5b89a79f3df484313a3f9b6cec642742e252e57d0a260bf200da008845e8ead1827f91236458582878f840d4fb971535b90f86883afc3737773d56725a62406add8616f5268f59f37311135c4af6e4cc899b3165c077782477d6c9da1838fb16511b91b03f2b69a2589a281fa3e89956a735ea76f2774db8800dffeaad3f952c2a573845c482726e58bffb1de43df6ea154a31b2870d0fbe48794d50ec22cd1ed58ab6054b33d626fe157c2ac063b6ee0d8b9aa1d75ea0591765008c19d4c2385eb507eec4718bd1dfde4921639084a24cb1b51fdc50f61e1661c92263253ae20b4775ed800f7499790cc46ded2056b3e87581ee0741251aee386b8b47ff24d25bf333572c4a340bcac574377dd16184b0c13cf7ac265c889b9f82bae24de0d349c20262557514cd62bce2d289b0f6866a669be3031c058961b48372b89c57a0ebf047b1ab566980dc1416b07377f9b778ea60d731d3946baca368ee51e70b185f2213d61dcc2c3bd2e5152863fa8caca41d980c50020c27fc99457c24ecd0f35866a685a79f2fe3bd8a681b76ad7ea6410abbe10c623f322d49817619d1fdc6d3cd727396e650775f7e7c9ed13762dceaf7daabb86339d8118e477e9b9f097ba7ba5bdf2698c011e6edc22c9fb25377dcdb74fc3ecba9cf0deaea55e9e4999fbb086a9f87fcbd56d9c1361ea8d2c37a0d0ec858bdfd8759c29884633b32d01260a2fb6c602fdf3c9e913efcaca25026802993184833c58ff2420142d7e8688b98d26788ebe31fc99c9e0e9b5788dafb2d1f1c0a3be8fc1250bb6a0b9758912be1073aacb2b0c69bed31efcf9f4cbbb60357532eea95acdf34d37cef445e47ddd529ce7249818bc0f22320d5bbd616e485e16a0e7baa40a404bda6101712afce8bdd468510723fd77db8f5a3b1bcc33084322a8a051ae003e60926728f9cdd94c9be962cebcd1bfef8296971be0d5249948feb9c00d796d27af404aa0d2ccc54ed4a7435c37b961e72017ad5e4598b2b2376493a9888c240cfd80baf64330946729d2eef66d4a982eb36bac1dfe3a5b61c9abe96ac86febac1ff86836b682169e94bb457b27aa50738da555ccc9509b4b8d37a8cbaa57375beb60879233f0e5cbc16f94a53046165cbc80d3e2c711337236e6212b25fc4f8539c0a0bbb002f219c1815fc92bd82781ae441f909244680309f301c0455f94e7e7a3aefc75efec264830ffde3c1ededdfbdf351a84513351c06a34d5a5d14284c86cd82ee154b56a31a9339c5ec794299b8559540e245e237c944b0117be5572c5246981e5fb0caffa08620b7ff7bf8fa4e6cbf4c218e97ba0c2bbb494e4b703d16c7eb7fcc156264c8a92fbb57249edd7bb1311c8b29e0a81adc9f547447470bda5d445e3d90ce10112ce0a27e7fc392f24b70350edeb1718060f067f2ccc113cd1f34f892c0e57901ef95a94a377f376e06b8a3c85191d1f69d91b7f345cc4b06bd9a329d2aeea030a262f8b6d5d825cc2d076dd1e8877e743797ee3e8c5c6b4e635ad8481c95ea235394a7ce1402913aeb977171f9e11c3d157e9cc53cee81d71968aecdf6a684a432d6b2be549d51f49b467323b462b17e82bf5cbf6e8f24ade4c4df8b5e8fb1f76d3ed90dc289e2d3dacc3bf05b381035a52d1d77d0e9b74fa7b2b3b13a7d1e96677469a71239373ce00e9c7111f8fb52439ed538c175ea9a151f1d329e244d3c0fbaad3d4cbf4d3f8675990ee01fa0b5a2935f795416ddb2aa6a8c524f0868e6af20f371e9eb38f8ff282079e34347d2655fa18f9913db03a9cd9cd21b9f6c555604a28c8d062013ba420918be7250d20801d5f110196a96fa058bc6f1f5418f781b74e702a33998dec9b3233416c684093d12707ed8585bb8de7d4a7036d6b43ac3b412b88761db2f04a7e3b76e06c79cd8503c53e96aa25cf8cf6644663458051d85f97eecb33fa2c4f01d3f51ff0573c85f843deb56eb92a9340d5d25632c2ab13a070c52bf8d2735b193244837a29db6049b2fc861e914b139037fa62bb51349345eedb5e3269c51675bc67420970ab950654d7e9dadfe25de4aeea34ad2bc5b4069b7ceee98a4d2057516bb4aa0a5fa13a3064d7322b4f277454eef60537a8b835023320a040a8bc893cdb0cb7ec058fc60ef5bcceaf93522a3352554e9029ed4adc953a80531c2b5d79c6475597537d3fa6812b82e1733a94ec7e2b92fac73eb2efc06a86b8cad0aa5a8a13d35864bbb87c5a59d1b4fa29f42e1744de2c95c6d60aa0fff2a40431ea14b2161f2def318673500cfc2502bc08849e1ac40b3abce4d5bdc585ae600a913aeb7efee2f4ac393fd0dda28b836322293a952cfcfb2f344005dac7a6d19dbd5766bc83f67ba2afaa8ec52cc437cc83b34966203b116deb4fde34f9a8269eec0b9e31f2e32e65a46a33f71e1cfca1a866cee69b48a8beee5e12f958635f2532a2a8a78c156555a33b505343163d9f99e93b7518bc85f4156e7ccbf34995ccac1373b9a10a7424845dbbb2d852ed225b8e72b5cebe85c2c2db8105ffb1768e35a3adc3359d9abdf4237de755e4033272497032a6820083beb72d33905682613905fbb21c5e107b2acb17de842ee33a61b987b9f643c92b0d66ad36016c502cb979a61f89b228ec3dd90cc1ebbd0924e8eb50fcbd99460f997e0eebfcabfda0acbddbb9a70918088e964b6122ce60817069e9f24e4c5e99b1a689534a6869c7c3b4281883c4a782758c0be8d4228549801800da77008c91f95f1165b0d20844437f32a12a74cca6907c7f4e8fcac2af60b5652ec651a530e8fdc90c2b45a03907798faf8d922af884c6ed52fea4cabbf6cf18272efcdb7bfb5169c63a41ce75b7fbccf69f5644bd7ab00565bfdb2583828f2ce023a0f43a72762438c31c74ab6ffcfb3a1fd342d6a84954af8f77e09018c91a5e1ce265fa2bea4366aa51c60c4d6093f1cbb3d823cfdc80f7adbf105dbb1dd7d6ee76f739bed12e8f389824207789293c1d50d5c9c46450eaacba58f476dd5258f2c0370e252950c754d48d2d589601438a85f232f0e7732f96d573a0b06f7c128efbd69604a4c24f7ac9763ee3536cb3ab99dbcb45c1cfa46cb7a730a91b8e8089f1401c43010b9537ef3dec5eae5d0708e6f999bf45c0eeb7eb9826b4a50b69de338b970dd5083266eda8802d79868340de13cf971674f5e7f22336df4c2d095be114ae0b6fdf746de5141e39fc3973c5d658387aa66015d897eb8b4557abc8c67436d7bb915b70e501ad98aaf5b5d749ca697957f717a486a1c98a48dcd7d00ed78109e9e56e2d65f72c6e7df8696d82ba4080ede15bcf03a76f82f1c5b541e2d6ca9f2e53006e666dd513ea1c66039efb810b0363646413a5564a63a24c0b1d5f240c6a55f8e9fd3712d415553b8be59ddffa0e1a8022befd2f32593e0005646bbb1b4d18d4ad244ad5f31171a0a5d688525f366b155157dbb5a531273cb590b98f869f20eb68a614f4f9742d2682789c31a922acba1729bbc7dd023772177ebf6d8b91ab372457ec03ca6d0aae08fc529b1f36fb5e96b479ed57e4555b1f8769defc3ff150d7ed5890899915825e8409bd1add9568fd03fffa1fbe1467848325e1331b4ef805199059fc898561b8352025c3774880a9f56add79d5b002243a24f2d76f3c35a42437eb160ce8136fe63e5ae95b1d39f700be4209177ecfb636d9adf8d707e16d217b3cedd2f45681466761877cc1c9b2acb533fb47351a5bb73e724b82dfa82d68926ab25306a5546eb54e9ba7cc90bf7f91604c7688e5392eec3560f3b2edbf477c232c4ce75df714f3731d7f7291859dc635c30e0729c7f85ef12c06c960377ca3f8c882ded7a4d66c3249c419fc89faf13f9fbda3c955446879e2b495daf93de46de6b96391262854d3a32a6c917ec2ca69e3575472fb00492158aed30679b39f3ea7c8ee3ae90a61c4feef0c45f63a87221358c0a683e199ba1a3799fa2ecda8032a7e3bc0d0a799a70e462bce555839b782143568cd66c19d557c6ce6d47e89a6ac0a0ef0c780416c227b28a369463d15e5285c1217b7abb69e056f2e52c7b2f4d27c80001cd64c83a050ba93dc17b3e0852ce3ec123bd7d5f886cc6d0ab7a0f8f34fa2ae32dba1002e449876620b2898627837f14607b7f2891b19e45a9ca496c375732238a854187decfba4a51ccac7b169727bad87e36a3cfd46eedf656df27fdaa6ae59650c633f0c0ee098cbd57245aeb6a21d2aad94f9e49213c81584d5e31a580811ba0dd8bc1f1b02cfd70bad3329e6ca16f50760e831485340f5734b537abbba992605a7d572e7c0f2dece6140824438492da4bd20d6ba8714b414c0261ec249061d3eb5f6fcd7090354295b74019ccdfae3c3fc1f77c11cf57f4bf88d20dd671b9da100eef6ba5e5aa4b1d05c206bffce38d9f878af6196e1ca68598dc267617938cf5474a63a29ea2ca3cd05b857ec1c633c5650d233ef8ab64639c899dee9c8722f111cfa6b8ba49bb71e75e9b2b9b4707c63e6682a26108f59d3983a63e5e199b09337001bb0cdb69f8d303b8c696e3b0bb8b18ae40fef096577fcaa3affe14258644b1bd65c7f7fd5cdd4200e0969f6df33f016e8552641e889209a0969430aa3f8e4992d549eb193189c9e893741ccadec4bde1d2249ff84c9a74e97fb4deb540fecfa05cf33cdaf79d82c53337b1395b63e4774e72053772310ab174b51024b00f30942e1000330365f133194b745251b59f1162330ca9279044ca1c80f0720cb052488cb667b19bb6cd8b30ca26894b0e00004f37d1c62e5abb2b80641b4187522f44b04c519a533d96286c6472c359d7efa256c316ad7ba753687213a4b8fc76a1d3439c48cabfc0d40e17744882da2a01063e97395656be270280d17c635bb848ebde7a7c09da83ee8bcdae816a6b5ba10911d5e8c16d03fa1bfcf317053f729044c8f4ba5153809a846cc9aaaadc3f869c466364437ae6d301606eea63aaf5927ed78d8b69fd2350a78a197865184cd8619ec226e4dd81a36978e9f31fd5999f67e2f68fdd3dcb77a50ea23265a73166cf0a45f7720a1f8b81dfb3f7818a2a88891e1489f98f065450b4fda07a437d8a6d973d0157ac3a6e3a099d26ab4ae8bc2fe53941a10c6b6f7aabf64339995d37e1f2cfb5bcd5e781e79d53caa2cde16457994f8b688cd5557c3a75de45bd05e31eccd78da114bf8ec272a7f18f9eaa3e143b7d662c954c9f6f84a76c3eedce1a0b65ba1a47e264d2ffc0c5858deee669210c60e4c5d61b489c4e5d51f23921f87123cef19cdeb102212dab85b47cbacdb097e2c6d4190c9a2471fbe6a5ef048656a487bbec3b01f24720c5c8edbd2ebbcd01ac4da376cd0aa6f952e439a8357ee0c2a9a7f7ad9ac3113018b22d1d88ecd57174e3cb6dbc853f6048b91bcf3971203348f66d98b0dc5673fae69ca7d1c4f4036d322e1dc51a6dd790e3b5fada61bcd401eced4bf029f403968d08ccf2f92bdfc8d704f3e6e9ca6e986563b2d9891830db3fb194f2a491d188b363c9f99dbcc1b54c0d73979565dc648ae988da931b7b9b5a7c5573f942b27f3ad62046fa8463d5b623f9298fb2cfbc296a2c4858be8e9c3896cfbb4a7f418bcd10357775e1a68fb7996dc5c0eb8b25318a3761de09f9bc0aa9d40e95fb140305742f8ccdec398efb893268b1c3c4c3c757cc685c68646945cc0309b4c2e6bef273770e431d82728cec159a1ca76a5242826ab2fafd3fba21400549be07ca149b282665dc4b73088753265609272a6646152ddb46ae9c462850ff14622c3c2283a5c4d1ab20e9d69d83a6d032afb0c123081e09cd0fb592ec896398e5ecfa4b0b4e403f85cdaa015673783753f5ad665b45bab7467a5bd801ed79e17044fc1f3c48abf98a41a2c54eacbb21e042c4c3516d3b96a63ecb3ca64a787b9800253e147172722052901a2bc93eb2d6b9e08bc3e6c5f2eadeb3032b77045e100f61dedc211c0049c9cfb858d66be313f830b9949b1d63855c6e8a08547853af133292300c7250f165bd503d134d36a95884dd3da47ff8fd7fbbebdcb15ab0762febc4b91cf51b027fae092b90ebe56abf213c7e8fd021ac9b8e683e25b521815514f9e04eef317cf0147f7991d1a16d4da93560b73e4ebc23576b168b963587a87e8a4c137dd4e3f85ffdb22101846d53ff0720208f28151cc238bc8111c80610d3eec44e4d5fe0b4d3a5ba185373ec170bb6ba2cbf1396faed8b92f352ddfbd022606252dca67aa9b8e56eff7901bed614f5b8414eecc29993da1f6b870138017ee0dfed7944ed7c4d9cd20b5bc0ba43848c09787ae49e0d15c455735cd123fae39c388e6290d6127cee8bfd4c8a585c7ff5298b224eea3854aff11f2b5c328f487ed3cc932c720052a9982ac79c80e6ac6081dade852d6f51183780e090e7be8275476496cdd803f544ce127a5284502a99a81b953adff2eba7d3b324a3dd3821efe9723dfa65bc4091726e1af7e8c64c789cff50082ac3af8b13e1f9315352dc17ef46602d968f99b1521bf74f15c090d82bf3c4c7a05ec23cf789b6019b2c6df04ca66a4553cfcc40e1655b17664ecd2a34281c136e4f43fad81bd9fcb9e21d05c8adbef8839d58b7f15bca3b8783a63826336d13ec4520b20f2c8d429a9e1b2e053cc862541edf7ee378f73e3eefd2d8eb74febc4a6bf0c068a3af26327687539580e03886bdc70ab8a90fcf01daa9b4a80cbe2ac7cd3173b009ed6546ecbeea9e1f9a2e9518b22e10dba7eed7758819cab754944590c71848f20ef8a9ecd195ba32138774001c2187d979fa6b2ed269d4ef5b651c59a60e338838e1b97feaed92b90948bf8e07e0a706bf1e4b32f9e531b6d82eb9c4a221f41b4b1882bfe3dafac7c8ae9b9f7bcc85df7d3432c7f83619419b05fb15a7ecac61bb6292dc18490767075eb83e21d81462bf7da7223d5b6b7a790f85e6155bfc3c74fb71de9590b19754fb693045b3a4c13f5d2e58bcb40e056bbf222bface2b7a21d0779f4c589f29652a475dc393438e40f9d0fac74e02e906fc5fe161a0b84e546a3cbdaeff1e399182f0dcb5f29a65d79eceded7e22907204eb30b8ff8df8a24be2f993d22cfe9fcc014b902cad975215289391027ba4023412f1301a29b4b5ae153005093c717f0afa13a3eaa4a0365a87286f4d794b8437590848eb831d088984394c863f30d7b05f3222a98987407cad3f0ad8c3d4a5aa505b0698b9bf9c9955e796d75ac866a65ec1b1b93b63fbc3329ead9448dd43169a7ae77b60564ae3ded1f6724d6856109cf6b46e5e0ae44a9a2e1fc796ea427e856f6bfba385824a43bcb6889c167436ab3d9d1065fb1a5d7fa3a79ff24854db82463512988f2a4f53b20e189e290dcdda37477825b0922cb28bc87f7a23f4795d8c6bd70a6eaf48ceb73bd89c333574075efa456f6aa3b40c6cdefba7c8147277e11946c2db3c32bdc574e6c45f2f32cc17ec3c320edf3f963e42a65da1edb97c7583beeb3af629b344233aec812ede0c35857f527efa242f900afb6bf90dc419ad0a0bed252cb3b7469278dcbd1b3f867dde0be9993d3e4a912c1bd85beb29c58e7c586f6d55cd707adfa1a27743c0bc48ff64778a0d5ca429fa49314a5f583978a12b6372a3ea59103607cf114c37f1af10ec4faf8cd5a871a4a09c1e81889eefcee9e707d81a3d6fa10bbf1fffa94157ebc01dfac81a5adad888e764204cb7cb31c29181b16e581f1628c06541ffd1c3981c66339d9a50b726a5589c505db9252069d42f55f50819a8eb0f8a9d84f89afc8b37caa071f4d307848ec2d67d59ff45fb19134629df1d7cb8acc2e0271a473bbacbb91a4e5f4b5ed24631fa5bb65614fb15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
