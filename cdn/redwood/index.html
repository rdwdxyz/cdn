<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49de42e43ecb3c7558bbeb61384827111b106de7c8c3100ab2db5d7275e38030d968b84551509a324f2b7a885acffd36f9b8f13514ab41c422565999147a7579ee8a37996061f88dd57d19570c5971805dbf99863d378f526599f8e48a246f390f53f97a2955b4a7feb39f389cd2fcc06a4bcb2a7f7fbe7198cf6518bf1d5ce070ca12d4f42aa989eeffb373abbb6189c7ff9e971e2445c30ed0b6609b0cfec3fd5cc205998cb47fb9edf9c06d071e1ebc4ddcffc4f11c9791431fabbd298344a7608b9afce9bf882c19fb7141f72115669c51122fa55dc5e7cc92a73b583d351811471f934967885cdcc7ff3c4d0e530784b76f0e16eeb640c9e7adfb29c5d81d2e0e3f6f9d0ca00f94114425059f06825a4e782d8e847cf9826abdcceb5267dd067540d6d836da48ee3a4be2d256d8a9cb1249d397f679bee234a566e3b777e35f9300b8da772aa66a6b721717b2a488b1ffbef516a4fcd3dd6849db12c2b8fefaa370ff282f4f7c4d1f734636b81114ca217f67b37ce78ee387ec3aa3675e3b25cdc31e84432cb418024280a2ed5ca5a093bf678789d43bfe93fb81dc2d43def8bbf4deb46c5f46df1a3eef853f9c8f53036372a67f540c6e87266ada4d3d8e800e730abb3a56f9fd90d1bce6c4bf616434bbd8031db2fe85af73d386853512979e46413d668e335ebcc66b863c0acae0737264907d79db734ddc52edda3af2450099a0c7c91de960f639a2f7ada2db48f4812378b02a69dcec4b229d6ff46edf31fcf4d0ca61f364ee09f481acd56f77fbcf8cffaf13aaa6620fdb81b9231af46e68a7f4d7424584d6c9db8d5d7d942861aa3c83d42fc75c56ed61df633da3897a21e61215bdb7e2a44403da447c5423a2cfe3478fdaa09dc2a636d1f54b860329b1b6d4b2fedde9636dfe4ee90ef4a370b74a0d3c3fe27a8a5af37e351f1b66f926fdddaec155b4a02c1e1a4c9712fc25a30169f8d36327abdfee9cd10b01d12d1fe79fd0144e6fd2599ec1110f9be9d4dafcb71aa0f55cb92fb350427c822a9b4f65ec63ee7a01da1d67a57f133923fb7de703bdad24902a8f15cdd3630153144258fc4551b6d5705cdcca2b33f07c3f4ecb66cee30a66b5bfd5eac81240306c7a17e33567cef712c5119c630fdf722a37acd94f7a337a25d4369ad9c6dcea52dfa4431b75abcefeefa0b7d62a82800588c6eadf062e97da1cddb1453c470ba0604dc00a4999b92bdaa65d8ec9122cb2d3a73bbffd7f5edf2ba3c8fc6a5742907dc86c5bab240ec954ee81b96553751ba60b4bb75f1223aa7831e00129b962f8589c00ee94ef05c6026b15fe603c08a92b357c0f4d867a063cab2ed81042da40cd3815a8603d299ad62b2175192bb62ea666e70bd9a75d8df19c87bef0f51ab07560451955ab9faad5601f7cac97e926ae6553a62aaf639848b765dd642fe841bdd60a6a6540bbccb3d5e196ca9aca58dd8cb9ab239b61a81c4171e632a9933cd58fa3edf17c5ba6c6d16885359ac9518cfa002fc699bff2a2745a6d4fe73174f318b12fc8bbef806fc770a206b45259eb9d6d81c44bea30f057d42e54021e72e2d0ed2f6dc37a4e3645fb32295a815c7eebb62e7d0913a4a77cb6204920a86982ddc47275955362e0f37ae68200bfbb3461487c2027a8bd269e5d0d994c4e7addfe27bd39259a756d282f2394190cbff014533fd0934e90a70d18f4045ce352cebd1a9ec0a5cef8ac5e268a8d10c393287072c71704b6613dbee62b29be6ab91ad4d0aa8cbb76af6c2684ee77cae124d3709f908954f4080f0784dba2f6a359dc44e7b5cb0a2a0508e3eb273d30f83b3537abfea659321c342534d8af66af6f9cbc126f4ed56b64c000d224a1c9e42c525177d311bffebe90c1e36901dae54d69f6130e1c19f9a58a3f5ebcedefc44800a20be220155a064436acca5dbaf52651dbb319dec034ab01a1eaa6dcb2d4a3a0bc5df30a83c2cb5d5e7970e5ba923d9f65dd530a3740d27691ba5bf4eee45c0fb0705d5c978152b84f8259f954e63736ea77fb4e8e77c8dfe92dd18e955a82433e183449844f5341cbc070d51cdfbac2d2f5a8e18894dc2a5c6ef11ceb29bbe9d664c76b0ce77a305286f80d8f8602d021b407fe167dc329f3c0959075d8255843d786ab0ddabb46d1f5185d60617a326ed141a95649f256fb5897a7287e09af50f4b4a98953e528a454f69ec116b4a5c828a154546b7696efb4f503348744bff41220dab370748c0f02006406d415c61f89d237f94906f1e18941b8bb893d8643db108d28731e1ab3d8f246b9979eb95e3421c5a3033a8c6456b442e803ebc4c1cac727d87b9921a473708532ef2068a8fa862cfe17d6041d7fe9dd471abdfb96ceb8f516d45b9a9623efa8d749540fb472c869cbfc259b4b8b15fdaf1621da5b5975492e84c3d126ca2adeec5eaa6000575172fc854c89dcc76d580dee8680a0da406cd218c417a24d8330d772bb19e2b93d0f89f4c473ca0b1e906c5f937d721b8d7cdaaad735f250f07bdf95ce75555a768f064e37a00789665e95d9c0b6220fdbc586cf64a665ad2b2e59bd0644dd5efca48b9e6284e27e88ae9903dd4d9bfe2bafd1d01c5df45580656e3a044075346916feea627bcb0b9132aada96a672cfd5ec9db33fc7d1cf2a975b4967401a314283a6cfabcf657f64f04449f227f4e0dc017e69f24c4511f94df44767efeb41527f84196ed9a86ba0241b22dca97d108eea5b23d6e7ce64b292681cb1a145c53702831bd3a560d9fa007b288a5aad879f2ce81ad299bc660864bf6da07e2d1f311f0393e7b04024688d081a06a9c68a30b374d35380e75c3819bbc2ce65d8c1158902f0fd565fe0a37763f5a0e98c81083ea3a34a242c1b6d90beb097f39e070c6d861e535c752f71ac085e36f1bee7dd6da6a8e3734a496883a730b377f776bf435b26543aae120ef3fa46a8cd724004b931e574cf055e0573b0c3ab81a2c65f71ab5fd356ff87447fddafce68aff1244dbcb06ce14ec9c9477c7da11258355b81d917b961aa9097cc6700bc241f7ae554a6282b460f354e8236b04f6256afb953eb9c5434059cc95ee27b6db0d04bd8c7a57903208bd746b1dd84ee7b0684a9ca591a5122b95778e6bb86131b484c8711ded99044d9f2427f8c2d8cb8294cedf1890e6679593a7e1277ea53559810db628556c7d2de409c9a48453138355b7d810fce54a017f0bf3d055ea95f5657c868c24391cf6ce8f14813190cfefb4f4a1a20e275e6da5b4842c00783542f907bb8e1b0a0a363af32add113aba49ca2ecd1fb5dbceb2e57b22a9e837645d6a85e87599617e030ed37615cd75f33de55f23d41c5074cd83e742eeffb00b5f387f21c59f2d0346c134a96ae6f4ffffda8e44d03bc5b6905abcdbf33c39630f45371995adb1c42cb21fb236a6dffe2367b336d4fe03b026a146c279596f3a59b098a65ac58c9bfde2a9a66d3f9804f82597f285e1c8a2f7b3f7cf40141f6dc681c01572f5096a338bf153f99f20eabc886879456c7c233b3f0a64862739d7eefcd9735bbb0eef3094464ba84d644ef04a2b3fd31b742a2137b66df71230568f7728755078985b8869e175e75b448dabf1a4ed513c9a01ceacce9bf41d728663c103d4e028b8021cf0d1fb8051a138c9ab45f5735d607c7e53039fcc03293ad7dd16c907e135629df0b07b029d2809a5239540c9294937bd5437326667547fe4fb24cc122a71465ec4545a61cf42d9303ca902fe76b636e50e43251b3cc61a11cd25d80ed722c99f03fe044f853fa111b2fb27eb99e32dee6bda8c3ce93b18d01bf18c706eaa68e8cd053cf82a5ef04662771658718ff02978e3126d028c63f7f214581dc348defa25401986d974c231880768261b3312925be6d474f05a97f0008197865f0fe9641d136e47db26db234760ecb443f8605e1ef8604664372f95cf748572422e66f279365c5621aa3e069deed4d21076d17d899db395b1169ab5815612ae4a649abd07914c9b9805e1b6ba99e9906bfe3ddee916ae9e836cbac80ccf67fa917dbd5b1d12748ce2d31ae30ead809c53efb1febf09bfffc6687d9e4c24ffe791c060e564ce1f7ae3199f620b6e806c60d1a3de87036c929de2fed14438a2cd385dfd740c19de5d2a359210c0c768fa60ae626d0885c85a52b76c8dafe69a154861f82dfbef9f21788162b6576adaf6ef4fcb079d5af82c4565f8a90621a44df3cea4a80f3c4553b032b53f4a3e9fc0cd3d4e88540668a80413f3b024dd7ac552639f29249487e3e75641db51dd43850edb539b84bd38bdbbc37ef1d83bc6fccd8658b108e9c54622a3318e145b6cc450ea53bbf1c02619e59a750e0f9491eb1e05c7d7b42b03dfd7a04984b01bfbe967a19b3c17bb1065d88c498ecb1034fc0a6d0e0b03e61eb9767cd4f22d13e38e670f4cad553c49af847c19481174c3cbde408f9594e2f0f62589ea738666c091a9e3e3066d53b7514a79e28752b2935600875cb5edb2a93861e6bad6c75aabd62e323919488248345422a8499502db89905cdb1a527fa4c7cca78f4c9d2372001045908dbe5cd98199a49f1ef00b92e6e98b935f755a4c117535893344ccda8a4cdbbc28b08c83f2a34cab602e3bc21b25a34d9b0ae7039d91ab4924c00a29d5be67f2bf28f56831775b31903a501412b66e76cfc7f2f999d87f9ecc6b7c0a681a997f1ca8421bc44b829ffbe8d618cbe72998802d63047406121174f01bd0185ebc022bd5e55f661b50d156229a47bba60664bacad27166e796dfb653e6f3f9372eb0211a758691f66322399478552d7598ac7fe24a7129be077c298956cff4652d39c20eb0aff4d7f40ca667159bbdcab38be7366186ce8fc57b82da0458b591be3ff65beca9ce58d75bba79b618c68877fcb021cb8a7c57fe7e215797c2dd2ef832ce23b18da1a47b7d898fb8a398bd5a881ac8619b99bb4eb0674954afb1cd6d4a6b97e182a834d12ac00b6d459f5357a59b7eb4fa27395ff699fe54b3ebc595eb82cefd6b909a6038c325c3e2cc3b344f0cd690ef0afbd42ff972f9749ecb2e77b925714cfa18b9bf7826a911f6ebe51220538fe2fc2e1871f501ae5ccfe55f1d78bd6e40fa2ce83274e078797d9b6efdbe60f8e3c50bc377ffc3b8698f7cc084dc6e043340f281c29c98b323d4a58fdd76871deeae214a94e7ed433fc3dd9774e2d0abc16c582f71c8e3dd14fd889306de81cf78c4e543d87b217f926d7902bf3ccac9e47d7f8ea81663c3b80dec63eeba7715bdb8c6eb2ff7e7064980aa98a5e641b9400721c57dfb9998d6435387193030b20b9a8902baa6ecba02a0b1e8af577e82be08872620971704853a930d0b7f928cb55b2ae4a0d26cad4b887b8a511277685811dfac70c2cb00a006c70bd76feb02490d90d20256bd5288abfa5767fea03f552be52f8faddd7608d58fc3643ae494637775cb3052aeaff5637bfa4613c261cda8b5c6149427b5e811243139c7e353451137cb7321a8be82c70942e1056cab964c613629fbbe77ea22e0ea2a381c7ef5044a3885cd6f3e66bb0131027e775ff8d749fca29e00abf53ca314296b7ac64ed7861978b53decba6d0f26a7ba409303aceea6340e2c58502cf74a703b9b76fa3a5484668a5db2d1add44b3434457fb6f9e30cf64849eb7a2ba68d06d8398b0b32cea55a6778209d37bd809093ef84437f538fd449c9e210cf2abadef15aec3a8a79ad2135cacfd39465dbb95482381d5e32458ed9e7fce5b3f21688a5e4825eda87cb695d6063f23945330e50ac58aa4f8bcf1b99a2c43fc52d519e886e97b23aa7fa2f14af4935e4756d6aa8b40df8f46b8ec38d1fd7bb40dc09ac7c85d814b55c0b38f2da8e13debcb2abaefe64f55c639ef749601a161c01de90277deaf321b55d0ef5c4301898840ad984116e656497d67244aa2ce6fa1d97108c3c7d4bb58e8fca0e2e92e3b156f2618f132021c715b682f02fcb516ca4d5a7d5d091443692378886bc778bbc36fada060c26601caeb7a56ab18122026e83e4c8c766b811df264e8f25b9a552541b78641d66323a34de9d622fb29bca34b1a41ae295983aedd8cd53701c5a80667646ccc74da7f55aec2d99d5cf7744a6d8f2969b8de2564f1b6697119c4a87f1983351e00e7bfb9cb3ee574cc08228728e8e8023958fe5e297e2cfb4155c75cfa53e0aae06c1242c76c6d79d0c5714446da15e28188db652f15d00a406c94e339d424f2b2ff63ea84b521535c335b6e31f6d4b4105c32867745b6ee13d9912bf83fc7fe6f57ff498af5c54fc1cc16d3edfc5026a2041bb23d7569ede44add7da46be6689572ed03a9ec27cc563365862e61be5f1dd0f598d475d2542fd2cf3367e91ba42377eceaa7e0aae922e49c7c1a843e4c5d418813b3512d24186dcbc2a1cf27101c897c3d2bfecb4f236891263d1a4e77ea9ff7b0dbca46853239af721cbb416b04bd0532596b6bccb57e488a95179455fa41d2aa7776738f56cfdf1a48b739ee2386ce81d1aa2a6bc96ed58b5bda418eab0053494077484509499917fad3ca56ca1bb9ad8a704c2d3eb414de9656287d8846b835720215b377210a04822223169228059c24bd5d5c718ef65f1e457a4fb338313d88f786245bc0a843abfaf0b7b0cb4ff1fbe103d705613f4998aa83c618962ec08da38294d8cdba0a9038b4740aa996a7ae65c6c7743cee5756e81a0e4ee13e8361dbdaa90cb0d25a6c70510540a80792527d31ef8449706aadf5519a10173cf8f27a6073466a7b7c13d7d6a17bd56c10d6a67e894f7e2cc5e716b83f70f12bcb9658936bd27998b7c32a57849bc982ab14e9701957a6fc70f9478e67364da94b94654f6168108a9445454cbf8e243ff3bf92790439bc5c55d79544d6f721d156c01279483028994209d580b678dba17f019d061fe167cc3c4d2ba4b2b41dd41d976a11d32071911064668b41b0699ac651900e298a33d65edd59cecbf11f10d9629933b9f8f5a658ccd0d6fb44f39645994a4c93af3cea711674a6f68169972d86649c80dd61dc8bb654f4a55bed7292694c9cba02e22da4673fff3e289fcb9447eb14a35246f5a13f4ddd2cedd6d6dd6f659ad1ad5ed63ffb25ece1ee28b89ccf46705c49668115dee6e826eaa5f8f11a13fe9c12059070cad906cd42105a23c2061128d195f8de97438985e66bbac4c9bdeed79377b8b663a932aa6c64e3078d3b03e63d16291771f4773c6efacc76a5f1ad68c28ceb73133afd4eabd3d9ca864dcb920a62fc6536ca87c54d53002f40c2bdd2bcf4b8e4c7c9a34f0f456123e4ef6b04f30bc3cda1725382a258b1d1d7281657c31e349ca456aa6a155ad83dedfa3e00f61fe9d86012227e2e58ab7a599c7b0d611d6a74f890ed6e132570fde7ec1fb0ae8f2dea496ad78d17e51d002d8873ca40e7ade60d2b3b6910e89a7a94d19cf5ae0fcd694566584853d5c539c356c66a906d87c4af8561051a4e9cb601f696e53073df6882d33ec55bab784f9e44b5e34ec66a33a1f7487f7175adec99ee112c42f3b0846a1cde1b2c0668e8ffb5615cd3e6509b7dc55790bdeab317b0cc936c466b25aea8ce1f7ebec4d98b073783aded17b34ce0287257101ac7f0137e2b94e15c20fe9d3e2ae30c950929423f073ec71135f9e2dac8fa61abca395277c80d3d96ad3ae2a80ad8087612b0e225a9a7d4f73f79ea5ec7ecf4f3bf326894fcb02f8ac28fa2005cb076eeda54a4074bfb6dce43509f5c76c71196886ad63901d9c9540c4b25e687902085942f7a2a9028fcd2eacde9ced5edab7982e18ac3992817fef7ad0c4a965fd2e304dd7e746dc2d2ff68b27fe1665a32a389aaa2e4ef8f8c0ea964c15a405a4fdf50cca41aa6b24e64f602b2450c8aff1a82580382a4f5d0b72de70dccbd43c76e1eada181fd0a50adb1ee7541abfa073235906cf4ffd973926db57937d051f05fcfe8ed960110883fbb2589a093d37540771ca86f3cf1c45fa44dd903ae0b209fb4478ddbd1a32941dc38f06659efe559cc8e68485c1846006f0a6a103b06e8255377a0ae7f1661a0bf5cb082a27d833f7be5a53b49bae9c9f990bc70c3c053a06ccc5ce892f9b0e2c9808f952667aad99bcd904267535958876845a67396a4037b5933e4e8dc58e215188475d27c9742da555a3f4334712e6c63699fd22aafc16fec2add94c297239ed0cda42b696aa2ccd0afe268fca430b81553ae2acc9829363eedb4f1d9c6dbb58da15d88a6f48890c379d44676edb16e63da5cfb72c193e9c4a8f39fbffef60d0df362aec02d6ef704b71848b5ad7786d63ccb0703b5addfc7de83be0adf4060a14c839dd6a7f016bc3542c2c89de241c25323980449f8f955ccb16152d6f7f6f895e69be8b6dcd1deb01d9a3c12a43c75e7bb05190b29ae491cea6c9d17d1da5444e0a5452d930bd1b6f14b566df2f9cfb6e4d7e90ff9e7c0a8e5ec0dee125f1519d41d303230de862c330cc08f61195a3f8ba8efa0533e6fd68a88d35be3602a24f14aed19fbb20f7a70f64a7fd6639007bfb6fb4b8d75896d38ebb2cef67ede1fd2251a75ea2e2f73e8b9339c98ff1348f9c34df00a1231e1936f58648b5090988836b740932358870061444ea19547de3efb34e45d0df38dfc6b4322c01dca385137266698cb7fdaadcf5c105ec4881f741e19ba584c0847bcdd41f1cc7bafbe2ad2553649fac231edac546ce7f06e4d4235ae67047a587bc665d66dec0ccb1ee25249c14f13678fcb8a5a979b297940842422dc0daa392f9f133409f3add1a579fd9861572b51b3f3050314979729061e69d014de355138e9b8af3e6c194951375586b2003e5e2988414d2441dfeb58cab070786e67658b3a62f8718f6f3fa80e28e5f320c41bae9383b691568f63498de3cc87ee4e5adbdc148d56c4346d5ea05ccfefbeb7ff595fc112c498256c93b3f8ec3ff0fea7f8d9f69afafa2dda55c5312a84f1a142474e6bc42f0a652e326633956469f5e1764b81609b81e7f0a049c0b51eb48dbe8eb4f5ef958683fa132c96a0ca32ad7613e57541822210f9319da3e759597337cbbf1f2beb0550e5fb99f352348e41a282312d60b373a066a6dbebaa3c051ea36ece10214e59f1e98af2220b0cea11267b628bfa8d1c4443807a63df05d3cc36d2da336efcfcd21e626e00ef535f5c1130c21b7efc2e7a53c306c217cc46db36feb25d473993e53d4dd06414e49ca02a56ce746d6b6207fb6df1af7c863efb7f6f1813228cc2999f71a458950f55ab0f3da4e1ecae48c188967dcb64d21193d6e1cedbd34a6f373012ea80f0bce3637e287bd54f65eb1c971bd484ed598b5a1bd1a8a749013051281c98b3050bec817be2cf21cba66f672242df7b375bfa51a1c58e00deaca42f362d0515b34686d38ff54db318fe5f4e2ba881d5e0f77c82e0bb4ce67089e51c9a16bd95a9bd212b6a249c3491ec37fdad066e3f032532d2a0865b59bd090d22dc6d16e0ff8c9c27a78814a1154263210d9560d2055cfa89972272e84c65b6fe0840eb68ee07f7edb42b0ccd3cbc8f99ddc49b943e6e275288ff524fa0a008ddc7182a97af2a4a50f4c680f575515f123304e4d3133f0b85ec7068a0dd1e8fb140cb856f23d7cff0401db52f1f044b3995057178f643504cd30c08d204f1e6b9c32fd816c3e2370a48591c0f86a7f524b122c8afdce416309cef4902c99921d8491c2d20130cf86ef82fc4510cce969a17b64cfca5169b7a875e49186d49e366c8d0fd65aa212968d70a435d0c1118c22dc4cffd939a3fbeceb030276282484fcfba832aa1576596f8787692a79481c780d4a9b55f6996e70fdf3c86fa4275b8de23dae5f6c16171f698b6088eedcc30e019718798390cc4bbdcfb88c431e47b0ee765f7a8f1f06d203850888c21222af78bc1f46909b271829bcfbf5d83127a5f79e130ba6de91b3817d7d0a8a6edb8e2b996923448d2541dceae80584df0dae6e261993fd3496d9ba8919826b38b375f1f2ee138805454a88c5a58706b06d2bc14df7227ab1455d0ef0e419f0aefd1d967cf2bccf724fced409df1033ec87980b15beb3f59cd57b9350c652d588ecf28284c5f34ce5675ba91240c34846cd6271ce1be9c787e9bb655a4654c8fa95f75b5dd0b573640cd8aba152c8d3583e36bb505cc82c36ab8eb81b4d6a9b4537a31581859f6a2119259b061357cdaa1a57446620129e7cfa35ca945902d651ece1b474cb9a6dc8a7006f72a71ea3752a9616b4b91af9ec69aedf54b3e48ba3d8342e1dbca2e4d5c351c321975496fc26d13eb535be66aeb871d9a3334c5e93fa170a4defc6b1496f2c99186ee1ae3409e375d8a623261c88e458e1e1c22b3bae9797a8b7db28f4ed035bece4d9c18bf11088d5208966b7669d7c61321ebf7e7ddab4604e46ffba93643db00249c199b3d69a6fa8cf66c66de06d57d2c8dae44f5fb909e25e98fbc5ef6cb13297f8f2efab42e9a165876f89dfce8c2b7eeeef52eefb215c868bce84a5777c5855d0f91dbe45eda8e76b4ba8e8d54f816584f7b547a5b3d1b54681b6e628a0800b58be809feadb18ffb87786bb4cdbfe7f809c10c2ca6475904b719e9b390952e4c352da5be5ad7fda17e8c98095f8c1238d81bba6e1384178f1af172ca6b29fa4a5a8167eee97638c2aff02eeb1121d055d2bc6762bf249afcda19cb97cb6aafee97404ce999d8863f6971f05211d4d046a2bcd8e20d3853964df796511fb86f46c096150fbb9a99f471b3d24d51ec0f07f28f917c0c144bcf0eb73e0bd7b30decad71ef5ccf8df32a096284ac9e41fda01a005429df5a1cdc408ffcb771ff3ff1e99b6493eaca424233e8174e3901f593a2f3f2fd4fc27ce747781cf739973a067f8a2e024c5c98c3bafb134076cec0cc6cc961207b82d260c9742f17d60b084e12a1468a92ad1d951493178655a26c84e5402ccd3dd32b724de01fe9a21b5672d307289903fe6313b322af4551add2ef53b5453c1aff433f1cad87c29d039a7d3f31e81da8b7f9b1f07050a3b6882f8372439ebc353d302b0d2cbff1e2777de73961c2f1055525e52503fd11eafcef287908fc94b6f13721e5dbb9a9df0119ef571728364e3572266179a75f9cfa913e86a0519b7c06eaed967e6eed0ff25bc965bdb77ba55d07b756dbf039fa3bcbc97dc9117b3057ff5888f3b7df6d7e3a8a823af2bbd76af867580cbccad924d31b1ecf34b9f7de1ff57d562e6b2000d3027744db4504b41ae884250b97c5535c19746f1517ba7afa1f8bf480c167d90593bb4eb695f2a25262c09127fce6904dcc238d6f70e5d91467c5e8532ff09ffcbb205f3dc6134ebd16cd8c170052385429ff0151bb974d8c2122fdc470028be217004fca3e4be5e0414d730414b0d211ef8178fbdde6fa9ea26a5c574167842eb5fc2125bb4dca94ddcafb6027dc4ee3f9d1879ed872d8db4eddd4fc414e816065135e3347ea431f1670ed8ae24be371f90acbba812ce6c9e0b97b3955bf69f4b2ccba727f7591f7765d8ba941f0e2759567c2ff29b3d2faaf28c3c0341b2b4ce0f978e9631e2098880e205796f636fd7a21b283107946522aade6b916b2dadcd71e7d36d31431c00b08c3532f7fa157a272d159e8dee96f3cf494dc7b5a49239f2eee89b579a8f8c4019a51221056698a0554b13831c7df6c981ea45e7abc1153cd91e676e0d80892379d66ff895ac005c955aedeedb293b3df88319ae4426d8ae9bc2e4c1decb0b028fa02d6500793a74c99b14579ad86b9c4cdeb8607a118484c854d4e6ab4d417a5b1347c842c1fa549fc327251b9cebc3a8d63435b17ecc53ab13d985712bde2cb24e063f56933d3137f7fbb56bce7f920052c365d7ca1374983da90a048e6114d4d40b9d3eda7e9ea845e38497c1ca74a1659be130294273ae4904484108a80064653ba0724b4bb7a37fb686743e80eff04b33a7849e2b556b48fed0c2c14f59284223383f21c2f3d6fe0d5a8da3d98c2343571c000f149c50cacbc32a1b4f0c65f9ee0a3f46ab58c205508c504b31af20710e522235b77eb78be0f8ec4e973d27ba1f9f3b8d02278415cfd3f1c85a5d0fd4362d40386ec72ae5b864c8430a48b11d1388adcef463b8e9db68e6d283c34768b1808b826146b1cd903feb2ce86fa1a1855fb48e51e58d1340744dfb3cfb0d8b8d27d1e3c094545401916caee06cf2d497bac3738e840c16192759fc96fca6651ec6515cf2ace01660bb2866374ce0e8fcf6e088d3097a4b814aa0eb1e39cb5517da04ec49a1c6fc9625b832011f2acb2aeee99ad75a24ef384410df039a584cf39aedcd9e89791d8ac0f964aeccd0517c48bf45b29e1fa327c9dbcc449c81c7258e6adff4b30cd8a01fd2bce5ec3814392244a562d5e0b6d88785c0b81426dc71b52ebea41cc38e3c0e2cd901d2ecd72e7010995d801ab821725e9f0918867d3a6a1f9900da90792a2b35456d0dd252c9b04bc6b64b75ae1ef4c888c2fc68a73060dfcbe2b3c7d8c977ff0336dace267ed0d71601ec637874051f3dad785f909a612ee96718ae902133283cc21c06ef6a3eb49e936804b7c68c42d294615b52785fe94de1d77cc1a6522cb855eb5d15601a115a842e5a8fd1b9538867dc916efd684b686ed307382b451e3bf2dd68e097fb93e9f08f33137918ab32e8f42cf1f11feb20837ed2143ae5048c3c6e3a2a68be6d6e3d97712c0156433876d74e0e11f98f2a1ff0d85c657ca7d90c2465101852787d6f7df2f5e38c626a84f772768f03dc3f295614a34ffebe14af8038ad49f2a59144808d9180730baa035fd259d72aa1db2db363126a113aa2261ffd5d3d95ff682589eb5d9911b471f45c9f3cd78a47d9fea790aed299be373b492bde2e12b3d8a5bccac6bcf281c2de6b5ac0f7c52d3bdc7e524d4032ce733f3259f9150efc928a82dc0e2bfef3b9c3c2524ca20812448db7163fac74d83e320b31df4aa6d6cec3b56c4b9e771df6b8da0aa55901bbb111852223b31039835c881e741b45d086d0d6dbbf0f0982e3a7cd031d0e5d0299147c815d70bd88d37363c1c7972cffa92251fb6f0ce1ed0e2c7458596eb1175adae29ccc24cf93c32a95a055a5a32994cb9ace92f5fd4a109f1d7e53435759846b5af88185b13079cfc2d0ead9b9c28ec4a3650155b5ef46eb0ff03b2748314f1d189dff155a750f9c265f45fef5f1e93c0b7de19c6c53a4a68e63c1e4e71d86963e03efada34c37725e822d838e1b301f1587a925beaf5136cb50473309d791aa9f7d3f5019b053e01967451d041e4e3cc217d935debcdf5932feffca38e1ab690730b24300ab3fb12311bf2b0e723f06f12b598a256f29df0801c18e1f7758b76d573a745bc50f1ce002dba3508b30c7cc5d5339c0258f129291c8109ecd00ea84ba433c7bbbcadddf5a90d120a1309486f7343249e0077fdb0015eb7208ba7811e90f7f32491630490d1ac9c33f15012ae94eb23d722374b30f4de7956504321491118d279866d796dfa40f923033ca24a50cd1f05c9f29cea0fc2c87fbfa64c52f7002579818947c5f31facd35878dc4a272f3ac7838ca9d32f59088769c8cec9e40e71be3f5dcf88a0d97236a32b0089bafd17e122b4f2a642e4a55c1e1032b287cc95b4e0d37035f7697c59d359e5817620bd2ec699c619ff99fd388edacd1bb158f515ae5d4ad40bf78fcb539bfcd26e9e315a9e9cc6c62c256d71e3eff64ea2924db8a9e6954d50f31195a4de40e2cb534303018717334d041cda04566af2653f612996720f006908c86b92eac612d76727af62c0d5c1886b32e3ead46add2abc74e9e5a12b7669d0907536885b8b2cd9453e02490e7d49550e66c9cd7d99dd5183e290469b7587c2dcb0bc056c79e3effbcb0c1e0cf0fef611e4ad59ff8d0d53975a26cea185e4ee3a0bfe7edf2e77e90fc4fc4f9be55540c04f840db83e258c4b66d666668aedc55e1aa60081dfd18a5c1038f9f0f5c4c28db69a8d26bac38b21bdd64bc7594fe69ea35d39b9b19884017c31cb2b57466fb8ff9c37ff437cd6601715d5c8d0753bfbb129580cb7a41f7ec02f08fa09c271076c57f0bcfa1295e7cd65649233f59f0c6df874d880b5d7b18dfd713ab811f0f86bc724dbf060f7bcba05660f1033bdc01e2d754aa0d19010fde03f91071ccbebf53743a2f1e61e6f203543db4e5447024b3df000a193ff34587792d43dea8659828eb346e69c8f3842e71874a929c2e39253d337cd86ca291000d37538ae0faa05c4a23ba970fca2d5cb228a427866628fcd983872f074ece15580aa25f77a6a05091ba1f6a2cefe8bdd3e5685778a3681a94598bc63f2b9d2c05cdd898225cb7f834b73a661adf2ea7b1c3ea352b98b4bd4e932388eeeedda031eb4a83f2b8f77665700fb3aa5a8523169fedbc48cc3d4c2e41262df0ae7e3a29d55c9748e6bdc03e63672aafae6acd650af61d6d733ab0bb5a5e4591c447bc0268962c4331d1ec2d595ea9da2a780e49ea20c8c17e6199b2a1dedf56f543130d7c42e57de30cfd1b112167acf9d07a0ef835341113a2262faccb0a4821ab9a552b5d31f0b1078fc469e8c346b79e0f121b57e9a61c2f3e9b26922d954068983599b5e8ac32bebed45fcecee948512715ed07d83cdaaeb73f069c74f6a0bebb5cba3d4e3d225c9a962c37b69d8e38918700ba5cc2d29199f4a07b7c112a14a5107b4d868c86a40bffa866e6cc0de1d4988b1c96969970026aa30a23fdf8b5fb1a38b6428fccdd86c8d8309de29472307bac8288cdc8440875272db74aaaf644461a4e3d2993f195eb4bf3a43d01fc692848aa601666ad2b7f3c823305a5133716450c790ac122ad13000aee9849a54bea9353554b78c89666045271207f3b1eca3c3118778140fb2e00d0cf1f40494dca16355bf5f80c85319c85bdd48dbb99c5f28f36c95b6fb0442836ee541764253c16abc320e534d6b44e390323004aa374925aeb8c79ccabaf80a472c118712b26e7c4968ba963fb88e7e1d3f8aa6fd0f84d3e899206f10fd031a8ad27d98254594de7dea1a12dffc721088cd894d29c8cc0af214f8d3f4836a82f9ee2f6bdcecd69ee4ce10c20ad8697b59a42111304ae60b1199d416e17426e2789c0b11321e9e2a0ba470c542ee60e5b4ed978aebd156ef104a7c8ad3611f5768ef568909ab2f115c35e6aa7b4e896e649c150bb6e46067af115d038eb6887ebc742c4276474de50ff26295bbe277449f5085efc8fb81e1ac06995b37b15641c8e2d87f7ca895045ea030bb726c8384f76178487c4d2c3dc9f86fc874e93906f8f0c3a2a40f9c1b675434c0d4b89eb5f4c7fd48c945f3f7888bfea0ee91292383c6fcd389f5d796a12c1c34b9b8390cd5a6fde15736e4b2332537333d17678b21ac54d0e6fac98934b56db39d600bc2b4adf1cbe9d8d0119ef0a2b638bc9e7780a71c0c99f2cece5064b39c3bb070b28683df9218966205e52891e4881776adf9e53699de7e8b094a5a2282dfc79cb00b82474cd9358c9126312ff80cb9bedd2bce05e51a9273f51e1cc8fd6060e09b0e0d79d94a210585a212fafd19e085ae0526abef5438d024e80a1a17b2319c373838954c6ef2644ab69ec8cfbb520b75d91b499ee9167b349e75eb1c65f70f61c9362fe014b80a813becaf34c8a17e4da1785c590c8af86667b26c751612939888c7a54f51535197042b3de993cc4fa06470423d4a139f648d85675a2db7d36e05fd6301e3673deff9ad952cd43c7d6cf89c4ce39e112a707e022cb23f61a2043e7ca869de44e63b73c297282826344a666c308793ea168cc896fef144025e639abbb0f49e6730ab8218b35e6f7626c8a2dfe4e6492f2a74923fe6f75efe2b3554381d22e7381172ae0bf25314c18a9ec45443b521f8d24ebd3f743543415634827eb2260a414b125a5083995287ce851823854af89b14a5f290e5f90b9a36068338b68ad39631f4f156838bba9e5e97320de441a13fa06d8338c41c776af71c20b105c1ad75c473207088fb4bbbd1314d96461267fb86f2975d1b49ce63e05b697cb7531bf374d3389983a64033de10a5d0b98455a335546bb0e1279c29525a1ac5eb6bbdac738f377d25805e9c8b5fce138e37328d1d4e9d5accf03d5dbe1804683b31ec159d8a8e10e8ebee96f0d5cda327bb47387ef5d2a416367d0e003403ff6c678e3c13bf8f92a9775b5f474e606cd91e5ced3da6fab445f7d24fb51e731befab1df3eee69258dbeb289fbc5e6cc7c71fb760ee444142368521fc8d481feb34794aa7cb13ed78b9b87573be34be65ed99df10936723ab882d143e1095fe6b78d9e612b6942914c9cc247b99651c6095628b48ce63ff8f22f74444203b68b1421672f112b5f075c2a37b2266c912fb8fb843d8cfe528b6ba2690a4ab27def1ce49b4c5c2b30cb22fdbfdd72b12e441e97e2b52a46e140708a31ba93d13f22655cabbcb89c48f174573cbbd5378a01c6f9d05beb6909c2c20f0228ba30e15b27ffc2ecb1c94ec2a057191aa8624262754103245ff808bd0004786918eee628634b9c9c74d7392819ee396dc1c3394d27211a9c05d7a6b55f8d3eae712d854c274559c2fb1916c2e0e129149f686abb5ed1879b2b4f069589c2d249b4418452266f6da59973bc16158aa26da94d158b69de4f5f816b48a0a60502331ca95b549475b7f0bbd5adb9840d8acd145e375e5eb06e827bdcdf006db49e62c6bb426f11be7e1460f04bd2d305d49667b84cb9a81c63aaa5ac29bc82d93e04f04c40225fe21cabae070469fd9f279774987a0cc206599b64f75bc04baa7c7da968d57d23efa478b6e40c9943747639ad9ae587f30fbf9026e3621a9ed32328d9414fbdfe17d5826622a5c9e01d13e015110baf19176e42e62cf5fd5f48bbf31c71182d6f63f9b29c8b3cba7e5a707053f6179fed6c851c355c8113d654f0695c963576041e8d5bd3f5fe8edbc426c9d626c94c3d4eac6edf6557b3aedd077fa43ee048e5f766e476f2c5c7c3f6c0e8dbc88b0db64c8649710ca84f1f15aacd4e012117cc8d0202a2dba2efc79ed46235991fedc906ba64247fd471b9080b0c811fa0baff5101135c88c1558175c22b5122c8afb13b359c27f0606f916e7e4e47ec689ad134148da5d6e1405b618bc65cd030eaf97f0e3ef108087b39b9e99d40b8873711e511b3d1d99d576863f5ef64ef34e89e893704610d020f5ff3fcb772731ca9b94bffbd782c213c7290277548c140506b3ff984385095251eab0cfbb636235ec72346368e995a941ee38c2895562817a0803824e176de026f0cb93d6f0389296e01c7e721dcd960194f52377f12c02c9bfeba2216c348048b0c9df7069abc52f6a8ff4b8b622fae877b9a3ec0de636b3f4351d607dce081c2c83b13ddec7bd7772f7a46eb0cccb6d6f4c2a10af14f1e959e2ebcfc0ed692e2c67b8647eef65dd13c0ba88e1664647fccd3aab7eeb1d2f06e3d0af684956cdc94142bf1536991819512cd181520d41859cb3633a6fa2e28b3e44fe3e48ec3aba59d5b5285a592a528b55cecc7efcfdcea98e8a5b15ee8d39d9d314c460c9c0819a030b5d49631ce438a0b5fab6097dbfe19ed74543e3f828a34dec564262afd25c4144e53cb22bf110d8c7861a1d3234848ca61eaf8d12ae2ff40547fb6d7cf1cbea8a47bcb90fb6bcd278cbea0891b2b49a9a3a15a00e181ada63d2c899483597bd348237a362cda2d8012ce00e7e036a0db48241d5bb7a49f03da610ab0ba9853b60f49962a5d3ff1054aae98bdeb4b200a72382836688dd0cd3c857029dab84021a722a199777bf81a4116a83bba2de2e6cca5b4750d3f2b053d992558219ace1702081f3d58eb0aebd1152de1b1ffae62f5f5ba880fcefee0f2bcfb5a54da38df9bec1d7c9c753c9290c51bca08fedcc629844cf1df9d6e7dc7ab3be78249187a21f5f60372961134d4137e1b6e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
