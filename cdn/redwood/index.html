<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae661c921b5c4662efdafafacb6f6875e6aac0044078889869cc4c12cd34a04a8dec6ea8840d723be4b2cc0b30318a067485aaaa8ae983d78bf6940a903f782c25fbc1ce134197a3b4555cd19e58e2869eb88069595aa17d3de7ee4e2b66d837e8f9b0539cd36a02a635fc0b58f0c5708568e47a0fdef747e3ae8b5dc9380118496fbb90eef1036e951f09e249e4f513e1589580c54eef4aa7e789f94a42b547595d47fede61506ac7efe69330680bf53d40db270a66d7c0f489aeb4bd1910443f505e863044a1d72dc16b0dcbfbdcd470eee272d398333d4e63ce773b46359d34f0f8f9a9eb00bd1713c5b9a63aa909de6840ecc89259d85cca62819ac1ba1e860f65d17ba7338f0b4a07f1ae53db53a0ebf1b4bd2e54e584d2a88d6f450b50eab3cda0482095a04adcd3585aaeef2b7eb1ad390d77550d9b6242a34e3836bef9758fa1d8db220c23ac636999c5734ef1009afaff30104fdb823bf5e34f8972586031234771f956ce6ef317ab811c7ab6b24e0a1f72d0b4743ac88d952b64f74751ecc5473b26ff17c858546b5cbd6acfe330720c8651a01a0def3ed58087b7a704ad19eddda22af38aaf8f4f5246dd52bebd9a2511635ee8413ce234e56b5a2ac2e2c535df237fc58a3205407bc836fa9239819fb7f5529a790b8a917bd9feccabfd4a46ae76b3641edd9a4e7c20644f183f9f3502bebafa886814bd84f9b6131409564507a832cc870e80b7ffb269b10150af714bc863e6f9675952153c775d8d137398367cbed708993151ec2309b9ebb7faf70a7b3f233fbbc3e954f48793beafb41289bc4feeccb54471f5432862e275f81c32351770b1753d8c0b1a628e3c020b7b07ca0d69a442e632595929dad3b6348b9a6c270694477d399d687acc78b049e2d8977408c6e8b0455f0292e108a3d7117b94d716e3325c67372317ea01dfc83756685463f03c72181b39f745df057e78de5f7e5abc2bed38e9696040d2537c25de7bc48ba24834c3cfa31c86c6ae375970af1657760936e0bd2c080db58a0f38a9b5bb41c5ca7feeb6773404861387f188a6a8e1979af32d939184aeda07722bf8046df8718fbb6eaa0d9a94768a25adc5e5b4228da6b93c828ec1d6fe4de7c87ffc0880197de108bf4490040b6c61c169753ddab32b3e904fd369f3389c42e4f34d0b0d823d3514eb44e3c476f9056868b209557060c91f6385451f4263a1898ab8e4f7ec605ad327ccf4a0834651be467099a5c72ed5c5c8ffb67c47515a033cc5c092ad5620bc65278a1b913e64f530140174bc391dddf2971b2b5963550f4c5a50284d329f40832b2e6ae8ca8b58a4066851e10363d679f2c57c5c7824aa7b973645dadef9e66b5bf46c876ca6f455f7d496e7cc0bc87a5578c8adf1b497424a86eef909c11c8deb26f3823eb6ebbb9b3f00876d1da8fec5e3a6b461757681d06608eb41c03632fa648458faad2a22b002dab7cbd8e2037721025d1738cf529a33379de3be6db2bdefb9a7a9860916933d2768fce3b477c8fa9b722df7d5adf5e6b15007211f66462f9411dd50d7a89a531fbb2911835894ac8b3c455599c1399882467410372895107aac96788dfc81bf7fc69a717e636fc5b1516de57cab561165ff0985ed796f6cd39f9457108ca9ec1bc5e0545494556c2d6bc20fc6063f5f1ed03b9dbf16cd4abec03d9c0d16ba7f25771164572bcba29d525abdc3928f53026e6d29358019e1543d2ab760f8f9c3d3d311312e5266527e5bf507db39097790c7805a0b80cc2cf55408fd0d6b2efc292c39cb046385de03d48a8ca4960dcea04e7edc019b51fb9ffdec370220609e05e7b62a1d4483e7e1b703657cf1160a9a2075a74d34145ceb3b1b566b2f6f5eaf027ff8f4e3c2eb5ba02ea23b570c54318e871506e0de11498b54c425898e1861bde98dfac1920730b30e39223883a32740bc9fa164f2d15de7efa2ff355a298ccd532ae7a7ca0eb02bbe99a19295b5fb00e69d7a4d8bc80682c9f9a044f75056f06e670fd1bba14b4ac05fd4ceff9b5372b6c86c3212ba7addf72a38000e5776270817791478556f705f39c65fcfaacb2e84a5dde5354cdc80d13d23ff0c1c4ba8cc6215e82ab2df1c7115168a4dafcd7a1e74807896759b0426696e15e739b178cf373904804f757f061150810dec143cc9ea99de26314cf9d90df415db7f54ab4d55c22d7e72b7ded63900a5eac039ebada654258b4d18713eff6e0c0c5e8982abaad4e1d9bc080543681a9ca508fb4a9ed9f281ce688325c7b6fe860838496fd7f8bac8ec6bbafdd554cd91c5bb6f4daf2c88cb1a31387ed07cde63a5947662df16a51fadcbd58138762bca70d827b477bc01e568c1eae3337a68704aae9047f2df19ea548a03cd3ba7e2bcbed6b4e00109a7e8b8a36b5793ed86797cc33b9f1b1344082c111bb69c7a0717d420ce7be3fc7ed9f6922a8d1f4e41c1237de30c1b066582d590b189804e2cb1bb5bb6eb4ae3fe777f09dcadc6fc5096a8dfb40f31fa785ba7c50789ac9aa5649afeba931237fe23fd0658918f09c88450f639611d2151a1b6b19e755238323c0fbcb6d0a0fbae30d0b9de06b5951e9aa18ccde3c2dfaf8d45a722c0ac680a456ebc49a15579a59d3ccce33ab8799bbbdca5e91c6eeadb7492acd196bc5362f477815c94507a480867abc4534fba1e24cf343e9e1d1f96be4fae0cb6142f07e7c066770400c2390fcbf37c752d61746d55cebd1528fabfcdf481904ea3ac7400c28b220c573e842c5fe6e706d7f5d7a183e1bd69dce83b9abad0a0e19d15eec11e8d42fea8bf47304383c9e5f59e3e168a2afc3d72ac0276fe15dbee6ef0f36589ad176e4bdfb037327a3e755a671372edc6066dc85b310e23ec2e1887a5f1338d05d1dd1fa544ac0ac161585b7520dd9e66aaef5ff996f17a048015ec47f6366b9c5ca7a1a41a225167aad87591bd085acccd90109871a2ab1db02ad4f349965d3966689918678f2e84e0643b0fc7b89fb588d89d3d0a1f38c89723cfaeea0036af5ed05f5663a5981fa6d778f51d016162b1b4ddddebec3a948c1dde29475171a8f8f493c6f282e29824534b9e58cd410163b5d8b906e8e85ee2c2773fd1a901692924ece0c5bc16597fad9dadd3595b595a41e753e9fa653706002c9d02a8aedfb827d6627847a7d51e1a8f5d406dce0a415358d0887ea8a451dc69259b57ebb6bf9921a9bc12f99d38aecaf1b02cde7a5987fa7916b362c2cd0ef2752ac760a6d3c0cf8ea647b8a48e9c383a02eb3d9161ce593daa24f693daa591d8678d138d497ed125f4978703029ccebc6ac24598bf7a2c06f3e6e2f3e5fb386fd0c1f58bacadf1136d556911c2c6f1f1ce636a5b3f8ed0fbdb29eed7a9d585e88405706988e92ca6259c164b9b32a8a62a9e8ad3c6394987b68e97f3f22a129ca7ac201af60df7601c4b4c4ab3569dece4ba2da3f6fe2e9d1fde5ea2aa189710793669ddcd4350f36b11eb1a33165f41f7c7fffd095fb00d82de61208b3ab2244eeff170c185d128ae52e9ac172c8bc6c513eae857d5ef18f775798c00485b7b3dc4dc384e67bad4ca0fb7294ade438db433529680fb8178a4e3f5ca90ae84a51f8fdebdc1e0b150ee957c1af1ba408720414171f89207fac359ee9d69644a9992cb9e8a6f17753508d980e5116059f353816e0d1bd17a6c01ee41335e11548f9cd4644e4f57601e0a4768f6e934587ca0103ff353259ca1515b6c313d47142d9d65be1695e1b820782617949c1397e2f9df6bd3c12f761395cb300ef61230a42543c68675bc8453b045d0f198092f56bdc05fc39aadb4fa595dc567b4097345631cdf4b054219d59e8ae4a59a860fa40cf7fdfca893be786d1955ffa937264da0ea1aa2891a52d67e91e4e92c304c653dbba95773ca4f8ac667a1482a34ffa378b82ce456ae08405373c2cd5e7a36feaeeed907c1503b63aeffaca3bf7eaabfdd5400b2bac5a43009f5cb404cd4ef842508dd5bb0ae0c463e7a9f6faf7217a4afe61515999641ad953e15fea9ac55646707023351a235eff40f53221642496b847468c7de9da34a17ec4637722462312116d5203006ae93130f5d43230a6f53cd03e6656d795c22a98ec6456819efc58b87b577103ccf4695d2bd7adf0e6fe916de34e81e4de7d13e487584408c0f8e10da3aff8015dae3177be5e8fae57e8443b13a9df3a751f1fc9581756e758268ef23abce2f224ec11accbdcb3a73fba88372480d8f65630d6d58c0b4809ee792c6f2579a8d1dceb5e4917ed4ea218d96025956703238a5b4bb839fefd1e294b205da4010cf08987cd1df8bbcb1edb51738e7451946e24253d7fd0feff70bba65765270fac95c160fd2c88f2598f3b587f1e6850acb242d8d2fee25500af87a87e9b8b65f3faf7a2b4711a5dfaa3221da8e94072d7555ab1e429b8f91001ffa54a85980fa42c9661ff13fc25c036f5288562a1006c7761ce39cef9d369d3a463f189c64691b1ef9eba769897c40c1823df226446399df3d81edb9e905403a8aeed998776738afdf7c9d549d7c41bb8dec4e5b356c6e5aa91ce4f67ed38abf6006c06b018a854491df414bc44540ebeb6b278c79bfd2148fab3fef261b7bc65e9064628bef586f89b6f1677ffc2ab84d5ac027c7eec153916dd0b9ed18eb7be3a830742fa6cde9369369a301cefd9c4b8665b8efac7f5f7b5a4041d819d20fb31cfacf1542e78feecfe4ee11aee69cff8b22720ab70bb7cc6e527e9d939f7809aca1b0edef0a696a8fbe5a8ad06056586b2cb6f74b9340a73696b60c6ca7fce2ab443eae08071b2858feae66018a53417dc17bcb43bf74e3b633742265ac463ce6f7fd2a8283c2993ac019244f845d647d369ebbb9bc9089233b89a66ba4147cf7577d8f42d8240866981b3b0488640b4f400519956a76cc9d6f38352e3de48030715819aa817630ca28bd25948ed026c6df42b9b6270cb2c2b2323aaabe45ccbfba2f643c761314a73a35d7c74a4aad1bb926b842f5241c10576ddb20a5f31be3644a0c13893a94c6ad7c7122f8460dc4807ec9bd95bbf3a1bdf92c433bca7cd9256b6daedde47dc906556d282fe699cfb15b6cd0df9033d4f0ef7a6ffcd31f285fcdafbd6dde650bea3e5163ccba291365bd6c4a833cce8b560330aa2ca83f70526f933fb984a46e0734f579fdbfb9c94946e7538d860876d52a1eef3eabdb996a7d30f18b574a09edd5d12112136015cd764f0173295b64311fabeb4eaa0c65cb134508fb5bfc4af98b67b607c7d1ce567826de56b5c01e472b360f15d6817bf300758dce44c7db66ab892f92a692afac74b5e1391c38aaf6f3c6902ff280000834069d9b1a88232b6e1d1be26c31090fb6d5472c64adb042ac748cd82f3894f7aa83244272fcf2dd61ad59994bce72bf05bbccbb84ef59c5777d98dd4c322b01fbd4190b78af63a255b72b584679f6b9d266620ca2778e2394fcbe5342f2b74bd1e4ca50c85f0a963597597627041145ebd969a2ca307b2eb7d973ca9414fbb2fb8ee4b21fe37c5f85f08f11a38238408edfce9a0d2a250e6f88c4ef142db88b4bce7051ad750c66d045fe8efd277f559289a3fa3a00f783b1cd78c7a09686d30d471ea0083352dd8ead834c85971d548a00012bb13d7f6a990f7ddef7ebf1e02c939f0ef649d7608873143995c50985196cf44198a1f7fd34212a71ebe9ecb80d781daaa561e5db937e84f33db75198580ae400cafcdfc464777d3a0ed563012c3b5fc6e5b6a9a0ccfaac3d6c22929de4bf65dac34f8c49d51ce70ec7d909755312f281dda1b5956bdb1b1079d3e4a545afefeb7d8562b39d24cc06cae342f387cb9d8c9d92a8b6b0dc07eac50c5989e51d9cf5ea8c5aa907e6818fa3c48ee99d02745c96e384c84ab747efc169f0bdbe968ebad344123ad0220f9a0a9ad93e7fe9c28e1e118ba1b0c7894ebe9efe3e4258a1cf69919f2b2047b6727cf5ba811a7067dba07975661601ee1e9af4e64bef00d143b5b8196555b077393e404ac9370a6c0deb78a7f4ba651d8f2fd2bdb1909a1d60b8cb877dc8ebcfeb69619fad7a391bd1d2fb085e0c4311fb44715ad762e40ada59462f39150ef55ce0b638ce1631316b9ef27bc4f3d9523a768d8b707bcb35e33b9dd83eda43f0fa72acaa69babf98212259d6c2bf69feaa966c7771cb8bb60390ab0ce92848a970b1ff81be947eb38a8060929448abe5469244f08f9c3fefa4a88af7f6229cfb509ad408755cf4e617b77791f5c7b8b5449ae21c1785eb8decb46dfd2bb174bbb3c6e7b456225a8d61739663a32bfe1c6d632073b1a9f31bada2e36f3164bf5f7a4016a674f314e4a192c6fd75bded6795924d9c8db0a4b5354265f8f34bd2915d892046487f069b1095c321b92554ec84ea60c164652087c46db9ba825d86c50ff2b8eb7037333e6eb14955ba0c6dd018498d28cd68087961a0bc7b19e51de3677f61cc7317075d27753975802d073938afc34efdb82a5193659ddcf060fa362c3cded648ec4fee1bbc5aa39af18e373755287ea37865ca9f57218d52f388f8246393efe7f9134bcd3d14ba9385539c98ac3be1eda695d2cee0ce38a982848da9dea79c4e57fa7131ffeda6cba70c1617db65265e9e6fc4919e931fa780693264506b10942e2e0202812ec8d63999eba85c007a626ecc6a171e536c965036604944b446c0006481cc42306ce818c75b7a346b8fdea666e3c91d8838dc0a7374d06d252d00018330d64919cb8f1a97f724d92022c82c28fd8cd4d253f58b49f6fb21d979a7a6d06ea625cbda18dddd86ac0bc59a84f8350d6150fe7a6a52419e28b363196503ec8a1493dfa4389397a5d98a3b2de0be6aced5ceed9d4bd8e1f4a340dadf45182b2917590d606067c46920808e94f8fdbd31915f2be6c22a96dd9fcf9656ecf4b5c9470221f789fbe133a44f85ebbf2be4c299084bc3d659d7370b55eeb99b4529d76db0823cd9465a89eabf52e1bfd5eefca743eca46ff6f03a80edef49016a1b3c10bdd5f9de48cf7a8d4446c977e52796252a6ffbb148252db65c08190885e750a3bf8aa29ab47efa6b5fc1cc5648f8a85a26ed2e2153122227d73fcca70dd23c3781ad72b551cf9ee3e42771b58afffae32884c1c9bfec3bb26152790ab93ab784e5e7e0953f78dcb2b091cd92142a204d24faf3ed1729d0d2d52aecbafea55990c2170183270eb5953d9da05d656b51ed654808dec862bc45f2cb81bda737bf7b07eb526fb1a651f00599abd0c9facc9af9d0b56da5cc8408af9d95705f5a7b7b21da67776e6e67a7911a96891d090b1ec86acccb7b91d9ffee69557a096ebe32b7e28cf6c8e46e008fee052148800a66763630fc8a8146c30e2798f0d8087fef42e21133002057e924b5a63e4ce67fc8cc10a80c38fc18eddedd8c3da9445c4e2a13f2b7b2a48ff39200edcc8ee46f69b7834e0b7c1cdb1db9f20c5d8e46774641725c8039af2a55f2f89e1575b8db6a8ea7b416c7bb770b0addc5df54c4556d6b7062a8cd72428f5c2107255cf7805d3f670db15072e8e3ba8a79d74d23ad459e3a2e48384db042142fd6984d048115707e9469677de0c7b873bbc9df9b41f198ee54a778231805644959b303406e9589be4b7c8bf142681b765c951a9bfd6cc687afde6c1617de03b82c319eb219f381abc075a924b0a50313750c54c91ca54de3d02fbc937cd0223f060c8b84c48161be001b9ffed029fbf49a14f5aef65ae49a3917b47d18539e83b046ac0b877e153a351220b780086f935b5b30264f14866e27e2f86adf4d83ce501c07e9598eb79c91140149ed155ec1905c182f880fda6aa32f0d798e65902a2b606b6eff34738bf483e435d36f4c1f2a41ffc4a7fd3ccc43475cfe7c6e3d17f6c457662e4d70550590e59cce98856c894e2d121c42dfdbd8a717ecebc8c64e0dcbee0e9ba9ee4f1081508dc3c213f14dccd4447e89b590ea32accfd747e6b811318b0b01d47084ddb151e2aaa13645b601d6b3b2606cf5d13fa9595ed59dcc8e1192ec915958d88e7a747ecca67a6264b7f6e948db5df3b46b847bba684c34c7ae46e50d86483d021d75a5bfeb0e6a9e2b73722994cd55da655f536cb48edf18a101665d430955a9fc5e6d77c10fc37e4ac166a2084615cb5a123de83d645fe105f24cadec739487c4b449abd03d14acd52f9a04a31d0795a7fd66e5d998b00ff6caed0120f740e52d77b15b406d428602e5c1aec372651a5e9c56f4b932c32bea1aaf0ca6563b03d595363f6c856571a56286467c355a78c3ad00bc2ef778888f5f6ef5cd251e06c0fa208d6b9931ed397535e68165b3643e529dfd09f4af5a19950070a8662b27e924488d33e8298d512298d7ae545844a036f91363029d4ea2c8d8e9b069227a0975ed2eeed227f7f82fb1d6eeca3ce5ae066afb599cc7f6a90b1fb53fb494592dfad34375444a3a399e7a9e89add9ca1ad3b59a48b60fb4668fd22c1416fedff0ce1c494db27cae999815fdb98b90fae0d102581042b26511418d3eb96c095dda801bdb474d2d01ff318e50087d6cf91bb20ac9dd13bfbf0b03d47cb4e83e9253126706e8d693e0ca91e00337677baca12baaa9f30a456bb9aee6744436a7db13fb77580003b786fa1e3a64c88f5c43c311a122b1f9906d9af0b1f432401f80564a31e382cd92a9ebf3c31be1c315c35f81d077ffd827a962f75efead0f76a67aae94a43ef446fa0e3a5dbf6682ece690c0b3e6e11320c7859eed80c4bf77e816e488d4ae022e4ef12c989ce0cbbaa545fe244d2edd8cef6d2542329c718e26c7f4edf3efec74c1a41dafa4576578da6f1b5094a2f63eeed45510a71f7a813c0533372696e51d283348ea32ab8baf84857b6893665273f80bf250cab96582d7e348ac7cf46550184317ff344216648a184aebca8c1ff5f6964e079f97d7dee4051900760f7c68faa8d9b49a4f6f524896932ce4fb502095bbe754e4eae2d5d5823dadfc0c62901ad34e1e96b2a5e0954405ce55e7b6d3e8bc8673d2358c400510e745fe3c0b3cc19447d9e729ff57ddbd210f840e271acc9cecb81475c1051acc4025f21bf02d344a60dde0848b48bf202a66a7b5f25dbc066b0abb59bf0ef36218e7cc1d395c72f2dd75eb5a5db89ec2a1b94418ba588a6ddea084d63e0b278b5de53247c1821f97de67b4cd1db41e512bcee8448ddb1cd72761033e4354da754631f8b08f0cc37ff19630bea94b237289dcb6b5a658231ba67ef94829fa04c630d2603a317fedef57edd5d0fed73308a4eab8c156127ae106fd18b60ef531c19915663706052454e1c2c932d3d0370df938e65eff64e80e3fe15dfc7d6eff9f4f68adae1bffe0d84843522fbdc7d1c9996c13b9eab000ffafc251e67ce2c3ace56c0ed097e2416ecedd2d5521038eada9de76610dab5569bed7b4feb764fcf212d821ee47cba2b5325f94126b5105603847eb1a85e79cc837d655adeed6143a030f8b2571fb1314eb274576d75ea7285a74d3aa857d5d365e65da18f68f7f8acfde0509baf63cad548f1eb3bde5b6a27158da4a3e8378c11686e5caf1ad1ec20c0a13654bd95728082763d0d67f2aaab951569f84084de45a5190c93b4f74b7cd1b34162871a19c7fb16777d82a61a936dd8d5e6d923069205b30d25422e9d07039153b30f2f2dda062e26500f20ea4535f107371d2bf02e10b4b1f2b9f01ec1f2e24f188f43c674c81984a34a3c6ffa5c0c1704d2613204422d8c2f78e1eb787c8d35278123920956a1b5ea95518973da5827203ab02b130c4243a34f1cb3c530cc8d9039f1eb0e77977c01f87e72b335bbbdad5dbf4868d7e61845289af869457d2f81a88e3ee59157260b6b582d4919cc0949d18288ff25a90b28fb7684195453fac2ac48ab76d4aa8c5d573ae9c5e390735fc37a05d96d7b7a8cac18d802e4a53c908939b4c63bd6faffcefbcf61e02c56b8583cacb6f29d05ed6f1d30061c0e059f22c9a61b11696514a16df4749451032a50ba89540177aa26ab0ac14a5b2df4c23c878a701ac49013d6310bf49a71870f6532f90edd759039d6d998da65cc81c37205741cf7981f96a6dc5584eedf3a3ea1c361ed3ec412474dceef8838ceb6e00366e30ed5bc516fac875601b8851f39e0e9f3f8d4e583b5b1098ef96fe7a3f0f40970625ae694a17891308f20a313d8df5d93676c6eb1fb494bf71eb77f564743167866f5585a9d78f51fcd9b90637ae553eadabacbfd7606ecd051e304082fcb8a3889671a2f8922f4ab6e5ba621f37d95212f8d9956e07ca6e1fe51a5fb62ac5e3b7554fe798b489a2cf9e302d100b34298229501c911313124e0b9cd0f14ee570b5556a2ea4df29a11ea6e7105c48a22c562ce9ae5914c4c1a6c31ce3e70419f2f76f6f46d05e135a02a210d1b85f920d8ed453c233305576b5ed83ea0fa13b6c72c9a53417663744590bfe9e9e258755d49e6699efd98cf026e2b8c7deee200ffd263f2fba29025fb4e55c893522a0fa89fe3bd086a0b2759e9a6a60dd6a3e70a3adb98e419b9d7a6c4984ec3bf36b10d576e21a73847eca91c1bcc8fac24ecbffab094cfc4cff53ad139dec668ef5d49bc1bf0ea3f4637cc8b8fdead4040c50c54acbcbb49056d40e01bd4e06eb0e388e076253117bde537868ed060448587126b5d206603802612cb3f508eba295957df3cdb2d35f102becf65d703456483317b5d06feb2b7e678f8722ae8fba6dffda65e2da08396574b68dd3ef62e6e7e01937145c0157520dcb5fbdb7f2988e25f737a3a9a8aa702b6f7eb7e66cd39a6bd439c167f4e2b47ace3dd4ce3982a46cb0a7f5d6d15f766b332d9111af34c35ec9376b9d231c91c8683b5f138e855264382ff013976de0c64be925605319afbaa167029a21746322fadd266cd4030a61898ce8dc9f6f74eea51deb5afa1b3d9529be25e97b30fff46d5e3fc72d1b9187631091240ca1f2d73eae11bddd85f762411693edb214aacf8840fa958a4df8cf5733c6221a2a1e69552eed66df28d40d82d740c21e1eddb6318ef0c1d655031fe4144ac4d33df646ac2e2a083c513981219a9a23e216d03b94c993502a8faf70bd8c86ad7b57651e1fcbe3202692fea4b53a22718a924e18214807871eb3480fde42ebc45e7b47238e227a4401e37e6ca8748702335580e98f591251941e853559fdd8a9ac65bec27a029d3265742f7766ce12913198538e4cf88734648257ea6e7cb5bda136d02283199cb1f79690c2d6f7f003c4206ddb0905546a828a9532a85d1425cfaf6ea9533acc11f5cc07aca44f8240cc0b5230b55d2ef195ff437de6b8eaf63142356f9088f01b32d7a7caaafeffc233283a4d24b63cbe94653743520e21339acfb2c232ab348174e9fc9a6b0bac1356ff9bf81a4ddb380cb9afa78d4db1f7ded14058c835839b526b293222acbea4fd3d5c236c33ecf8b03518d3193e8635679c60dd5e266a4b1779bdaa08e7e1b51d04f19f84d1af013bdbcd826925d3631a16f6efc47d129a8efd178a49acb1c696e9e980228f7dd89a57e6e2995a99415c6d9de6b7c35e61ff430b539a3d5838cfbfd648762053bdfb36c273a5d646de1bc65544524974121d23444279fd5d19ab8a1478506d6e9d8492277b6d3107049307c3eb889b3221025054dc237e15fb5cb2a4989d38af12a31cae5fbd812e5b3e417fc01e16a317f22deb46d31953b81999b4e037ac40264ad0d92458d213f019aaac8865881954e51e187d943a19bda4c6427e583ac0523f1ac053eb15f21b136544b6b0dde11176baf0e263c5d243dfa265c91a4443bc3fe5c035796862e37c1278cde65f38957f67d7fbf64ca4a09fad3e28e3190a5a23335d7814874b6739f9517cb3a33cda00bb705ad9753a2917113cd04940f3715245d92b754187c1e84a3141038db4ce25ebeca7d456ffc4b6eedefaab2ac37e5f296d634ee5079b039ec5cad3f70294b1e8c8b49304660da1e25eb45f99e77d67cbe9e240f1ffd2170f63e5c537b90cc9508f2bd1696030a6358c97d7150c8593bdaa8fb24fe7186a8d1dd746e6844f4fe507151ba73ad21d3593a60e5e75e4edfc068101c39ae6b1d33a61a907f5191f5df3f9a80375acecd29466eb419a04b7e432b90aa7a22c786b62c6300dbaf2dfd6a2e3eac4cc10a89b6bdd62a7d0b87077e2d53e365db8add149b7f01b07cb4e144881e56de7bcaadf6504edf9db70413924e9935cd475b0840cd61a93c7aa0d6f5f34f452500426cb773687cde332c96dc6cb2aa49b36e94163cfe62ec7b8e5fd4a0e7914fa0b81dd86a350eb145c957fdeb18a0e760dc04c78e2b2fbe85806b56054f47d300a0bebe1d945d21feed0dc3cc178cf72d357230725c4ffd84dcbe3b50229daf50e1eba52f0ebf0646453551c937e73e4e5521c1417de9357bb1b2e00d8487cd595a4e4849ebbdd0a7cdffed6166e7618b01bf3c0425729327df335960529ff0271c2da4d7f2acfd9d9cfcda366770b75a877e3d96d7e74155c3b4579ae9b7fab45571d5f4eb9fdca1fa7f15d0535745c8c1d87c053ec7881b5309dba0520314c25abfc2a5fab96f611117c539106772bb42f61e7973cbb39cc0a455201c916b37e32013e3040e193f2969cff29aa0decec9a288de37e3ab21a73e396c98bf4d5f606784c535583d77aa6dff1d042c66ba61f929d50c348da2287d66a933b5c3665632b55d5d2fe757fe2ddf2149f3ffbd9081dbd858ff00ee43a49e53b5b8c2c59c2468055379cb774da77dda6f8470d42d79f30c74f01bc46992971ef38669c79faf2881bd9d3129bfcae8ca1c483b8e3225ce23c1f23d71ffcef363309301d866db41d664dfd0be882b752eb289a9f187e787eeec6cfe2f7553bed07b85cc0dab0bb5631003cd3321361f7a9feac76a8a7ba98b5ddfc1d88dc68658e99714f31c9ea94fb2bdffc66ff6da04338eda9555677a2cfd4b4a1c65a48e81d839966cd80e8b8b95522e9f2804d296ce7fcc45f78b1e3a094b33ff6aa2daa987318ff04e7e5a0661ccc82efded090e64dbc95ce6d0e6416be2125ddb9e9be079400ed93c5c762f91ae412dac2c733714c1ddb4dc1196fbe98e249a0d306bab6024e753ed280901001f91654dd14fd73510f89d762aab69e978f22946aa3fec22025cdc68f6390b3fd4dd39007b8923897b80003445d9a40991086d988bbd97410557d40c51fbd20e3f420a956e81267bcb3b6f19fe27762481d74fd567b905524833c0356144d48d92ea39dfdbebf4cb64fc519e4cdd5f69fd9ab45d7f181df9935520b3576a74b14cfdfaa19956039bc651ef9ee5a097285c72fef0c59be145642285b5ef8ff1f5f2f6b153c5fd680b552a4d0c52786de154c0eff23811e0245e4aa19b3894f18af09650b97e52b8ec008175076b7b220830ce816a03c00a5b5f675b94960dfceaa698db101d391efc67f9dc9aee3f21a38fa1a67816830502830b6a59b1930dcfe74f9b307765ef02d3ed2a6409710620dc7d43202cd9dc715b404decfc98e6e6e2af78f17bc7074175ff76ea3fdbb00929819846d9d57daede15fb97cb0697846959a2cb1a068fd4a7f16704d24174320c17364c17264a49ded45d9ae9cfb3d7d9496895684bf181f488942165a63dea67bf2433c48c0b819273333baab809703104cdc09ed80006ba434ff55855dc675cb495c7b318a5d424fd539c5a3f3ebd0eef941f8ce22652312d1fdbcfae3387a22d29f80782022be3fbcb09c44fce7fc6fe335cee3f49654c2d21e623630ab65a5416aec170f7476979c574731b841ec3430fc3f8cfac8b0441e0c896b2b728be40cdab6ef780d14e14422edc8a09ce763b807a5018d5e0f0e23c3b265e41bf92e16f771dc7068df921281203666fea16c82f7960d8129a1320a3359875a8a0fcedbbc1e853a30c66a004926a9a3df6d5d774d5172bd65d5e18c08099f2587279f912b4c64e6ca9500be72225688838456290c308dc316ac8e2776edab15fb5d43967b681e5cf3a087b9aea59d6c3fd71eb9a6d89093fee5e8b13cd31ccb9f178732fcb7c7a07530101b15da149182d9b4bf775b69500842f1a67ddfd14f9594bfe3030062a9ed90f8869629e403323038cfed7bb3f0c589d2de8d3cc85467ae5cd5d141bc4b4c7c2796d2ed98a23d60d4fd705b226cf6313e0cce78a39562a71ede401b7b3be1e870848cc07bb41b6e945b1f226a2c05353361ba69953f7f26fec4c2679888310c74e23f001767b9a67b5ff6cc59a23047da10e10ceec33f50a218c0f94390d979fe39c1926ead403dbc6b9bcf15814dbeaf3fe043829072e2ddfc588a619783716e43baac0b94ac579b7357405d79af79bfe4144f421c9821b2f938a93e61e10ffa5832d3d4b96ceda6570b285a5653e5673820d4a32b1ab0147f16d12609241413c89e2dc819e8051e59b08feb5922225fe450e555dabdca06a4ba3eb5b1cc054a5a3139d512cc119d51e474a4aa83afe29d5b5f6c342bb4438bdc23a3d7b0d417f98a63ebddb8a72d14c6b4679b41b380d427f25b6789457bf027eceeb04c59c2743df02e3ac8eb051fc03ffc96768d66c3befeca8ed84cfa1cac6f8eaf70f00d087f64ecca363b110aced7d76a0ba801216269eb68e6e29719b9a31f0bbf212a51fc05ece9d4ef94917896e33104a6419df6d6ea2b00cb383b01c66316b7b1b42dbe720ab312a95f83276a07a341b032ba7450f7e5bbe3588be7e2cb681323dca2b23a269c7693c7bf60d44160d83f5b266b70c058aba44991aa2e8dffe70b7001058574e1480f465df7eb8da671317d98ee337bd600e92fc4a20146c125dd3f29841ee76314e379598afcd38b9a7c83de8f0233ea015d622a4be32403a67799646027060b6a08a004da04ee6e18ab3d896b453d1beb505f38e58c68e4defc419887541bb993ffb3f2833f4dcb1f2eb7398d479f62e9f30dcc3a97c488a3086a1c8fa05f7ec593f68639dfb091d31381670da28dd0bb06ecac80e767f51b84002f62269677d281360111db225dcee710556720cfcce5ddbf5473b46436ac2633ad74c6564f04c96ac616","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
