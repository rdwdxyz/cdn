<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02bd7e37c2a17254b0b31340cc4def10d78f3a88885055dc0d75f36dc01aa82367df281b78c0a9c2aaf492a834c1781bf40545b01b0955cbb7efe38b9ee61e76a3f44a2e8f33847e5eeb939d5ea7e1dfb43f89585110641aa80e2cf1696037d7eed90cd8a8e7c576eba7c68a3a8c81519808e39eaa1ecc8b6fd2d4fd0e517d3443b204531191d688ba4748b251d15b9dd170ea850cf3abc0d59aa896d46941703cdbb60a41d7d2db5fddb70b7d1ec28d954436bebe75954b314cd1399a21139aa378e73a3633b3ab51639520a83d0b61d5bcbd964d2c0278e2007b18a671bf3f5cb1108914f3f807a4c03ac7f2d8063ddc5c9938c315ef7efce8d71af90bca26c34bb2cd00b9d491096d870480279ceb7e274c39f9005ac04a1fdb3b41ad0e7c93af7fb0a446f25b7ed0b89273af12d545a62b4294c838ee3c13f9e311e1afcb035334f243ecb7badd7513ec768e1245b3861701158da04a5e1509c3c580f9ef3f358d74473105f2bc019ae394c64cc18ac93c2fcaa1be7052f498ad9ccd2c78adaaaa603292f0e3f65814225f2c4bdbdb36fe93fbc068e96d30ea901a9503ca51c27843b1bbd0c0e691179af7f66572ae63f0065425784f01a16aad420416c7422742ba34bd897c923da65f6bce5da6db010efa2aaa2830eb64a1fe37cd0bc29223701072b143bbd17cd7d2577f45d8ce0be3bf60783e6d8b49dff7e549e5141f34d35711129a0c7b97077ad435932a6b595cdb2d05cf7fb90aff87125a900aff779c7508163ed3744f0523b4a4c97680269df4974aa2618b05717a543d2ab2f240e0c42cc128c607be2e81a5e41d95d3bb2467bfcd9984cd17ea24a6b42a67eb9691f042c9c6a9ece85f915dfc9d68b1e334f1d221918e1e79c34b61aaf5aff854810dac1ed070276a16df76d3458a51a7f7fdff633f54878201ac5f8b8dac5a264fdc591b7ac3927d9668269ca137ba4227a42972f458979b85664137bf859bd9989dd5ef1958871af2b8cbecb1221d31fdb60109da080428acacc776feb4042dfbd1f531ec4d67c6198da64cd6bb2657b712cc58d6169ba7e80bd3312b38a6079372c6960802c3414e8b86efdd78d734fbc26174d6360290ae5dd0202b56b038424fede9bde64e3c5456fd32e3fe5566d62c1f1f1c95a0eff6ab5693ada10941375fbd162efaa07bb83ca65d52885d9faba06a601cf58e7d2b0baaa3110fc24e7b311abe849e9948f38193e4440719d2171d2bda8cf1c30e8c1941925aba5777ae6c2517e105d750114f5ef9bb6f57a27864c772a422bb487193b7c6db635db2ee9be832d317507dbdf0141d4ae6a3a6dfc8c0970bd37e743a95918a0c8b3c81aa12cc79f11c6778d48d97428e4879fa90199c71efae01f2b4c9c5e7aacb09b2f8f774f38a69b7f038204086c10d1958ec1fad60834e8f9404703147ee38dd0f94f5a27ac847e6e7b1f1b133d167a2633dd0c70ba7b2b558f8e860e3313c47ea71ad134989c3f8a241a5b31099d470e513d08900c3d0d62cfa071e510e1bf52cc4bdc86e9c9aa635b8e44bb2bcda39fb35c94b70ad1e3df976381924109039d09fa2e0ca6fd8afa92537bca64ba66698e98cc4ea254fdf1f2376cdf63ec663e68c4bcb40a4304c2547dc7f2e0d8771ff9188e632de799375fa7c89e9888b6b0593bae03f0b2aa80fdabe0cab785e1b0c1eaf284f097a55c450db7bdab32e87e8d09419f8d1a38b8fe64e4dd216808b9cb7c695a51634c3524a4ae108a277a5b8c2014c2989de6f4e0e8187bb310fee07c95c170de49ebaf0b8b915811428fbd02e1fb4622103f97b93b0db019403ae67199e9f18abf0e1702d4d04f74a0eb5921ffc614246274c974e62d6d353dad2721f1186ae50051e715fbaa3618bb1fb71defe070976b1c640f8bffc7680ca94010986f39ef2d1549461a56b4a9159c4be14e70829ba281250460e8014d8ebc5caf4dbb1e3664bb4eefd3b6ef00ec6231a001ac47c461d065138e18330f8ee20fd93db1ae4f7146ea3a62874978f47c1c7beb4f08630909a9480ba774128dde650b455428c7ff5bb48e5e21119eaad1ce32954ba4eee89f04acf4f5b42fb0c93773d356c470858c8cee74542e723a5844133e361e672ddaad2d6c3d484e1608da5d4958fcddbc80c56f8f5722acaa2d7287d74c9a831899885e30f4d933bf3e6e505012e371e8adc736c5bee6f83beb29c399b950ce8f5b0de5914f4b122a1aab4a8a28b1f872526da6e1ed244ee693b438ac51575896a2a106d366909101599be699ca08c57886edf519968c2e87b142e713a0b8bb3a01cde5640faf62c156be158500c563115767bbf57b8d53033d4e09faf7b393926b7ad0cb46aa6eb51bd8f45e87816a7fd6d88be2ab3b97331a2703aafc0d436825cfaf3c7500a1c8939eeeccc49906b4474213962bdca373c4f8dd14ff4822d0e5d30cf9498d62fcd610e725919416f7605bdb6e2267b2a01e111b3429874adfa04ca3fdf40c64f44e1c5deb948eae507bb974c4bb3df08e2268318c5489cb598963870b402b60f5c29823bff1de01060bf2b970bdcd36334890a631d3c918d1b997e8ead70396e9ccfff22189f1ada3433ece9b89a70fcf862b4e4e1837a3a48e6f3ba74387061b30e2b22e2c345224184ff7222b0830f90eab4675a9a1a531865747ee2fa0d27c747c14943f55fe8edac391fc197442aeb7709e6c05d92b9123b129cc777832ea0efbb347e0004c7ffd5584068b12cc5c31cc35ac4c275def9b9d742eff65305f4adf739b388bc667c357701f7d3c9dddba084aed62aadf307c6c7af7f07c166646ddb1b29a64f966d17410c9ebca1c3563c92bffbeea205ba6f727877b8c0b0910856d86b5e4f6fbba610df062d9d8eb94bb99ebc6e2c38acbfae72f09703c734bd339d0c0409c4bee4aceac9451c4c04b08e130c9b49b2bfce043af3d030d8ea5b53e6a3f55b76dab6ca07c78703ae0964f35c62a85e9c99d616b6fc43ac8fb8badc673f6e3ae71bf6bc0a3b632a15df71689a23bf667604d0ad5ba1251e0d1b36c632783b8fe0e9c9bd4d6b3a920853d6859732adebe3a3e03b57b3ece3c2cf5bc3420c71bb0d336a5bde92ce557c064e7ad03c7986155448dca289b8b47ffafaf8ce2edaab23259b270a9d6c3f17899ab27cc4090b85d71442870f3d5501618c78df57762c4ba63440ae5f560075479d634f61cb53f5d6e2a9946fd4ed35686f2fa18e291e81a4babe3343b1e19d1107cc69ba9109b0e27d2c376a7fa24586814a4d4a6681579a2a8b708d896ba34a5c840f3654d6320e885c1015c9fae48dead068d6aa8329e927cfe8e04fc308357bc096822ffbf79a51f329add3594c2b83ba98e8dcad575d7d47a538cb18be72f6ac90056e7c6241b234bdbccc41ad6f99d6c98cdd59529f14036050945432f71dc6f78ac0d6cb7ad7518a6b934dc00f4ba207e5dbb7dc044d7f522f79c3b1447d144dbce6b770255e292d9ec8881c4ce12a341f2b4cfc8b67175451011590d1475e6cdb776d3861fadcc418a435ed6503e6ce39e08dcef975cd440abd122694e0f3084e2497aa013a5f4e307bb9cd4fb26d921f8e2550e983783feaf474ac1967ab7cb882e5c0daf7aa76c58d9709d6fb37437c18692e46fb4c8fe5a4aa138fd810217b172a39cac61f3004690759ad03827a595251e8415d113a74adc5f8259c4b0973ed03bc30f6a6f02b7a2bb42b1fac97e4a21daced13a963e1306465f0a2910b8647d4a4e2648debc11e3417d039d948bdc2097a1871d0a5583ce54e5108dc82d4271cd68cf47772e584a6c944a91843bedbc9162a1866bfb998b2bf19c592730af23d9638398e649ced1035eab8e8aec68596fba249096efefadedbcb10e88b468ea76b2248cb7c211d20bec9da333ecb11daecc816b52913c14233a08b99a55f105d6d08b9a0cf76bd71c1ae87a282f7accebc86d032dd22f05f94d17b74e3734184a5ce97195e752b818ddafb7573525dbefeef5c20a2011c4fceab06856a4e4ef2fb9e2323aa9519842ef3069e566993ba4b42c5707e1a36ece4c401586f5ddc3e18d79f264a5f696084e8f337f67e247a9be6971a9984407ae740ff8ddc31559ddf8fd8bc62ea6fefbd9b8766492269c90a7ff44fb7de4586fe01ba370c53c43e6580be46f8d00f7178e24f44f6609966bb75aafb857ceecb758ef906dc067f8e995c022a933ed81e8e60cd5f452b2fd27d15908e247ce97bac27a85cf2fa849426c7eeaf24f629230e9c0ce6dc416c0cd56a21a2a7d0d30191e329fc43ea38553a8c1d9d2553905212384f623c2e681221974382e2b8790892d65df4b3ca86a1a734da0f2ec0c247b20351941e307e1dee57e09d8a0278be03816141ba2b1dccb0c893b4f09b6f2752757bff5d6640aa3fda9c3928861d45cd7a8b7f2a456da15ed82ea356fe97b8521e0c676b25558bbd125d73d9a6878ca969e062c45e8b5bdb08ac8e3cba1601e3803be060437cc5a43a1996317153e86f391e6118cb7733aceac2cec8856cedfae0a3d7b6e3d46ca14153491bdb93ec81935043141c576d06ca5cbb44c62728f762e89df69d9c667c2f28cd96d164faa464c5ff1183df20631a08a9a3de6e4a79674defbdf37e876d1ccad22f285b8011896e4a192fc8bfd3984218b8063bf894aa1ecbf9d8fa9d858651c44e2aa166620f4573f36f253b074928d988cb7f23fefbe613eed4d4d5675674082b6e966bad6f8a1c16db5580786eac7abee87f22f2eb860c636327007ad93c02f15a4e007a5c27869760a55921f481c7f18ca91f6f1476356689d96d485ca0a3070ee62f145c629b2cd58f580a88d74381f190dab2ab6211335533417991c22c88d590857ba87598c9a7c203e431702f48483f2a1189b4f227ce3e3e6efa8e0f3194418104cf1cd52efefd3950223e62a105c2af8df25ae8effef6c03cd364b193f38e44fae1ffbc7c62e6695777f36cb60210df92376fd0878504d84df036f8c495023caa89b1ce32193424054b4664d6e400a364353ba1e474ac13db39302f456f3ec894da2b61835c3891c866057f11572daa82dc20fb834a7b63fdf9c4fb559c8e72f7cae65268d0b14cf43c4508d61bd6ce8003298bbece21fe1331638ed5eaf1d365b5526010e517a1db8905fa0f89db50441649f7c60826e9f11ce74c1179a02a4ea8dd3119751583cb3d195be836b59a2411bd286e9ea238ca22615be02cad9dcbf1e79ae03615c8bd90955a7e5364de2caa01d3890483fbf69372c0edf74d323f58d85da949e377f77d212bda0ee230d4a926be4f24a5445c9515e971094ed6b014e476ca8c9373d1cd2ec3f520082fb4f9d655247780c97bb8bfa82a1671c8c7e1ba2ef61bd0c9119f0be079f6339715b64c9d1db7859d7aa3b6843ab23e8db373dce669ede19416063a3896c6df61c957c07af20ebba18c12c1915c22887f6ac12c4f1b1ae4bb99cfeb05fb42f37bfe1d677fe018ecf55dafaf7ccfe48a9d7f8744bd483349acc0e1f79423b1ffea2b033593800a0c24819b473eb6ed0d2cccd1e87598b22c894b2c28a195de985d0084c5a4c74a03c7465db6633301dc3e505bb4823b74b596438cacc645abe38141b9c0e92b626d8e71a5fbac9be8b7cec27fc7b72b516c51529369b2486efdbd114ec894cfdb8c6681ec915e84d39d427175e02a68223a240578307dee96035247ea2e6efc9666586870fa54b5bb7d9823c489e76b059d8cb66a8fea8a4363ab09477ff5becdf3dcec8f85b070adc084cd386b6193913cab5bbfaa0eab1c4a18001ebbc2e9661e0fb6a81cfe59e5c58f03368c6c3cdfa085be4de2fe5fc1afa6f36cb1a9ef5f502ed228319a4751339c63d4e801b4dbfa687c2c0e047c42cee1b53f0a94d4b5a55c20db9ee47e409b342cdd58bbd280f1d667db403ee0292eac0c85c2cc69a477b9ed3c2a7aacecdc2366fabbe3d50de3ca3cb00584e3af38d4f76ec1669284c3924f8dcfbcc4945440ceff93d7b46cabe3d774fbac83b07bd88050c08341ad8b76c108691dee46ced43be4ee72c3eea7bdb74c9837ddfd727e3705933efd18e47063df25c85e75cb4bbf656cc02195a074c66b61f02a1cd9a793114386cf3e9fe0b8e2e9f04e75066975ae46d88e181e68e8fc6d42a6da43bfb24fcb807225f356c06b5afdd1aa203b5e8b47cb5f86a1c0186f347eca9e7a923119442b3c1dd8fae0e95c93e9da172122d11720eab21391f276fdf36f3adea87c9b30e137629b6bea580cc80fc4c2cd993fb991daa8ae0bce24f56498187fb9a875e775a27db4fb11b1fd4ec5b2e3cfa4424a375f842e566abc9d332d69650891d10c2448a305c4452a3325a46ea8396358a3c750d186f8b5f8f37e68cf86ddc86b8f70306e3eb4669cc0286856ca6122b6b7e3243033ace3cdeaf2e4d4b23ed5a8f2512e4a8273667b4c1d59ebbadfd70c1e430de242279015bff1c92b541373b8f5dac4ab9eb64f53a8c179fb9b12cdb679ece2dce62aa9a7f327b5e0bcd02b6cdd2ac6be144ba2a61be356b5b896e35128677755f71830cf93969facd675c964d9f113189cf058d24286431380c1b14d3ac53781b1d31fbc358a6d8a762d65ad109ebf95bf0bb0dcb8d24fd300a2df7e33b871b0d5857f7936a461a3e33387b95d9f4e44ffc8bcd77357ca77924ef48a76af8e57a19579086acbb23f81373756c689958247546b4a504f952533d0f6f3205eabc91753452e3ed11b4bc3abb3e4d42980247f29ebd603604ffac52f1cca60cf57bcefdaf0f874d07854a0015010626ff9cb4ef4e393d1243324e73419e851423e9369fd63ccdfb6437647437755b2d02bc48df7c7d7171682a5087392dc17881a1093d73295e99898ab97135bc7f75d64686c0d6c637e8ad71e1a6a6e88cbe876669407921886d74bbae0b4c8c403d7855958aedc5832d38559542c6365e8372d2a8f05436c6c0caae34449473c51688472f7d39d20754bda3124cb89c11d64cf744ee89849dd0e6444244914299c1b676d8e3cb546312dad148abf5717b1c7b1cd0ce02a65cdb3c1d6f665b8514be0acbc16626a79900a88b4dff87c5c1c02650dd9fe7c4547fa578a185b05ba651144ace4f3e7add15bdadc798029ed4ee36687d35fbc95ca16ed4ca29b672e3f6ffb50c5f77ecd032fd5e63713c228acd1e52b94477afd6a94b827276ed0c928bc934e9119c0901f9a17505f7028c45b80b17b254c8793bd255b5d2847d4f57e262cef044733183fa351cd484b53c2cf5d9afbdb78f8ce1b5ab6ba59088f0d27b09876ede3c5feabd0debcd08f3d79f513818d5a78294b482e97afcccc3af32575ca75779e51b627feee56945a44c7ea5b18c04ec9a4639324dba7dc40ce5fbf69ae9a0d074d1f393da9751c7e3c2e200f14d231c506e203751e3d0dfe727e135c1bb37806679d357f519fefff753e32a320dd619aa5fa55c4108a681313e82bb9cca71f85607f7dcebcdf1c4978a39e918c44dd3ba7ebfe403600e48a684a49d7e39df4d9cb26d72f8a0e22891581b5e7283687f55c2662655a987b878778aa7280488f6927c3c3329ade20cc089eaef1b1a7bac6516bb7df9512e8822597a068d9d65cc5e811d52951287338b6fd80a1249252040de9b7a59ad2009553d321ae44148bb9d11e39b42be35f33841e79ffd90e615a86abc9728fc4d9e52ca0936ee92abd5db716d666570008c7b575086d11de1e70a74a54c8ea89683954bbd807fc82de13d79822b545a78f23b69e2f33dd89568cce3233eca07595de690e9b5e6e2a1fc42e7344fb029a9b85b069383476dbbff620b941cbb293d895ac0705868f9cc7dbc2b1d6aae9c604b982ac81364978b996bc78e7e4191fffdb3a91edc4efcc74e266baa8a154e7f08f575ccb0423135345c8d5ac347760a53ac60136e9e41510a407a4db1e2acc103667bc3f08e5c7162c6c87289ed14fe2ba6f7ab56f53d3e3583a7f17a65a8bbeb586c249031a82857b2119a5360e4779ec4a7f6f0f4a1dc9a17704416ee43c2e9709a32366d71e59742d90c760eda923e3645527ec6c9245ff54ff32ed62bc44b9b98583679b5080a6a6555c5d2705b3e2d057febff2bf6e4f8efd76672b714757935664fb18ee7ba10fdd071fdf2fc8e877571a076453fd0ec1d1f2fe5503e0bbb182df5a789ab736e637d40956f83724f00eadc245d0b8cae48382c1eb17878597a3b6f7290e86171fdea3f13e9e90abc26c58d771cfc712b21d3a643730c5675ef78e95253314b029e646165f047a38efdf01f2d2d7e13838d593b61d48f7c9bd5544fb57b71acbc3d30a6b63e5dc5fcd8bf11754a2b1ef507c9efb19fdabe13b95c918ed1f341f7e9439339a37ac15b1f55d9d7dbf0222bf201c1d04daf64697c5962f05b549ed3529e3310fd62edfe6d6a473b7f056199444f02ab9bb82879743fa02de5a5ddcc48aaea12acee5f940e15216196c76a7816a092cdd904875557c7b32cd16b1eaf83d7662f3ac48cfd08562d094354fa5613c0ddb8100db65648ae6b45876d522bd7a3b69747306064ab666ab7a3774686e0170dd545c28c3d078ca5510a0be5166d55762e3b74e09c53daa802e4c7b6b51cba6d82565b2f8e61e56b3f8808077cf5e0601baad9b08f2c7df401ab09e5c0aaeef966ff0f279b160a00df762591d51ebfd941ea6fa2cac978bcccfebb52d01de23800eb8913f650e13a718361cc716f686bee4c59083d22e996648a9905d061856b9c29010efc7217414daec218c22984f246d6f73a0129a1f75b1a5c50ddfd40af63bcd572979544a09e95cc72d1663ef48cafe94f78405656ff59c4f385e9419798c1a9ba90bc7070bdd6b1b4c70eda8a50e9c1d63ca13ecc849f4ec1ea1eaf4492bdc9eb384e73256ae0b746601c24b500bf1df290fa6487b50e97f64fc524140d40410ca80c4f2716ba296214f0c7d8e5ddb0448456baf911dad64e6d27d4404ca765e6f9b08f7de4ec58bfcd0e336f205e8c7877fb3049d666b326e4a5dc57f4988dd7c2a6e8bced74543644153bbf3b42372b538ec8b989972fb35ac1323149a258f88e4490ed75e48444947d5b65d449893e3aaec228279e1756770dc8dbf834a47d2c1e9dc3d91a1f7576d673ca0c82218ac88cece44bf6b3d3d2bad92c00e801ed1a550161562c1600bc8c710b3f7ef790075b10726bcb4411c25085a3435d39cac2528d50976dbe6c9cf90ad167494c8997fd55bea1b8012c595cc994a34ba6ff9bc9f718f0f8fdb2eee3a84693740eb62edb47a31dfbd42687313a1d7c4b3e30400ebad7aa9dc1e57dd545b9f642828fb0f1e7b6fa85ad0f29154e8a55daa9fb1f6a84a2f15500b2554649aa6ffbc9756cfc558bb26e29d5376016cd9ec3772cdb349194b9a6d1d0d9bb44a24abf453d3848269be5fa47be01ef8eb66fb5609a6bea46e07e20ea0dce5fbdf7c4cdf746f828bbfc81b4ea2744b56125fba9c70039c1491b0f37e437c263543aef7c7b951225ddc897162559d3c1f4e5c55c05cbb2b34ff68e6136d9539ca534edce6ad2d917040677cb07c66e0b70a8ef98105f4ec7be522adec92129d5adce2daad0f718ff1e6b3ce025a92f0206000d319007f6151220e7f74b955553687e5994844d2532dd1add75aa90a5459a7542aa2f2af570c1aabfb416653c5f443b2f9f8229079aa637bbfbc34403bcfd1b8e3a0def26fdfc23137f0fa1f231cbb7e6ec8d3426faf148bcb654293fbec5395e527d8120a2446ee320a57cd3d3b13f16a1c1f715336900e2ad322a8b4cc364d9f29ec237040736a8a086e37dda1d8b1f0046c3b0dadd4dbc24e0f6b0df8b5553547f60aa9ad311f9ec874aa93b5e3d7d354f3f0c2f7887f54fa178fc6f164dc10729869e6519a0eb2be8d806ec709e8bef2ac354c6680eca77831d671fe6d8bd6b43f2821acd2be95d5fc8cdd9676513990b94756eb68e9de2cb1f362658155de699e1945c39c3ca1d6ea007a40b7712965ea7a9a1beba6a50e5e2e5850b954964e10fc6b410ddc8d9a0031fb5dbda67c101188ec0a827385113dce4f3b97feddb94d41006c6e9077e28a55c6a8263662e4687a8dac8f47918e16b14e2b7030e4b3d46f360e7ca7e8aa47f0c3345b98b2a364dd517865f379cd0595d7a6a179143f6e71de87f3dec567fb693cd3edb830380b810a728ba7404a62e15825b53265e6d1c071ecd1c2158f48b759ce83c6834b6eeea3b6fe4c94b1896431672521927e3a935fd38093eb092702f778451c5042b71f459af336be26995a3ae3d4dab90337699535e9aa0f21f0316549574278cee07300145f590ec6b6a61749e39673b0d1cbd09a8cbdba2bc14c582cc8d4b71f639fd199a3a493b2477bceb1d28257fe4d9323c5c0ad38f459371bd1976475b00fc32e2cba8505863daad7fd59d0e5648b370ab58dd6d070ba8571850a921b29eee76c93960c41e51bf264fbb6dfa3d4b979b5da3ed9d6dcda54b33e8baa6cb997b1f9366d4d74d837d5c34a8c09cbc0b37eb52d56b8082d4b57b642cb75b2b0cf1473275ff3b95db7e9025841871bec2ec64d7c6c6d32bc1e31790018f9489eada1f4a91485acdc34b045727cbaea223e584b565aec45e9fa00fd7d74db5d6d7a706b920147f0beb17c5fb01952d8e0561e50b20ec39216bfd419ed6ab375333064ca7ddc7e069f47e1bce67ddcccdd756ace0114d42cb3fb571848668f3499f59d6b3e79d07b68524e2029423abd7ceef8e514b302e111443ceac09ccecf9950501e25d40c6463d9d01330948681f8c32e7f7494f24031f789ad60dea9eb67d17c512d1068a264a245ee00a97f837e1c27f0bbe9d1955dba03d6ba15059d1dd6f0dffc79499a6f582dc4d60bfeffb13f71cc53ae374bb64453a5de759d90abe9fe5e84df6aeff86483d7765189cd28aec4f9bdd8e96b522de474314eb92f9da87414b5a3978d2da2731e224e2cba5a54f30103cbaaf5616f548f06a75a19534eca094cd1e516d9b6cae8e38bf92242527f0aa478e67e0944a3b51da4538fba5c042d9b08883aef605f5277bc059a98efad943766ff6778c65795654dbaaeb0fe4d21e0491d66af36f09f02aecd48ee70a5b93d1df79d8c7ee08d7e1f3a4130c54916f5f413985b0c0cad46b134bdb602840a7937ca8ae7efd05abd120b1b5bd448d3db7115a65793d5869f9fea0007ac7aa5c9bf8d64329dc591f4526da6bb3e1f70ca82c92fdc821cfd85204e6a80a821a745c93a4cef84caa67baa3b5259b0a1b1ec5fd463f6f0cdd397a22bc07d00031f68ea5c853d60f688a955a0e0876889dc696529fc2e7990137def4b55847720bcc6199f2f08cb9300d7b70dfcdcd4a3fcf224c9e25437dff352350eff55fba8e3ca618cfc529b1078a6f940e6a7d0269f4ea4c621728497e2af232adc869673f43cf3e7b22a905dcac53803bcc879bb2f527e29e97eaee69e07862e68ccdd5533561fc5f175bc92e5bd35bc9956dcc08a9f336e4038291d3eb192561cf350f1a73d766924fd669d0f4d05971fc72190067f0bd15b236d49d4f31ace6eb8293782e39c4f58bc60f43dbab6cfda09ee7e572f75a90c64d80443dea7e0a8aa96982e985002e344431d761491c72ee289d49b1f55505b343c353f231fafdef73eeae55c48d2277e0d815e6b77683f1df693b776244d8401c2b51d00630abb8bec8c751283be6b74b1dc06e0e79cf91c6d4e4e0f4fb55e5d3052e8dfb27f28c14b51edb0945abcb2b271bbe041dc4e821d8d8fea9e53b25bc6f3b3f72a7345400802c5e8d3d71af8712827bf32596313ebf1521eebad8ad1a5eeffd9311b827bc2c968efc73e11c4e8d2f78bd88175b456e2035e3c33467aeb1df45b0afe9a99eec6cbb8c8784cb51cf7961ac47d927cb694ec2ba8a9961b12f04bc1ea1db437135e34910d214861af21798ce689fc36c15db5483fc85fb283b9e1793c35f44a240dda0c649ed1e9c8283326f7663f0badbc03b5c7472b5b36a15539ee2ff37ff1af235faf0f3134231051da4258c7077b9de8a6c91a1daa6ef35073a0d8a9c085896fdef7f81809f7518b063dfa680e7eb900177a2964ed9911c11418bd2d62e984f109d4210b3f7c83b93c0fd4e149eca833e4e7324a122b2e651f1a5b612bbb7e2bdc556bc72f6f298784f3de273cd7dbc5029b2d73572f074c3e261b14295e272f9709ca1cd65fefebb418c945e36e5f86ec3f95cb22812a76b795308a7d5442dbd0a2a2590e9373509aa379a6f9deae32670c39aa9863a4605f8c7f9e134f7becdcc94772ba28b1ea5933ff5f6394090fc5b9e1de12822e1e8a22bfa0c9f49237ed71e63044a07e66e37f9d0e1a3bd94e12ae80992fb9143142139aa4374704e905e4a70b2dfee437f0e8c0066d90cace1c782ab9429a0f7e2aa5df1ea9b2fa9ae6a74947e53579286abe2790d2026aa4765bc25d29c89234d42f193b10ce7addab3bd97afa22611fcc789616652eb30ce76733c836c8a08be37c18485e780fc9f064163d9560852f519dd7c0819baee42f281d475a36f9d426d031f7b89b16da368af62e6ce9fc79c98351f0d95813fcb244381455cd0990cd2c21e0498681e9c6058e9471941ef7add671e7badd47c16efb779bbe2126744572afc7a624822306cc03c5a45a381c9701c220e7c8d5da5f170f7c907123a701aa641b3713e8d9529826da4583b30a7f2e2d041a9f4dcb3b87cc4924243551d18e285ce9048aa0944c7bf9616942f491938ada6d4e55b4772e14e7f18370bed3e5b408f6ac6d941a968f48dfc094adef3b34925c75165b354cd83042fb936a12ef62046eac8e51c26ef13d320162158f09f6d91470b202c0504d4f337b9261f36f69b88d7c4a54008293fc3b3bc083985b03472abd93418e595de7245c8486e471c4320ee1dc8103309aa09731763ae82359060517d34532763e8d90f19e88294c9345acf0b5bf0a6674adeb51d901787aa98ddb5401d55922169085a88d749e9f4fdaa6913a0f12693fadef61b31090017994ef6737e7477fb96c1decc283a063426627b1af28becdce0e4780fe3ec0d2f96d41026169751435aff3a558a57d775fc09b5196fef8e1c86180a10f7e5d6ba59c7d564a6c9ed1825c58a5b9cff094ec62b10a791fe584a68d60ae6bc02fb61c31ffbddd7500eb847dd2ab1585572c6feb778afe0f9adc849f88e77f9639ff9eb8dec25554a02a554cb4dfa564f489c0065759382316a2fbdf8fa86c76e7505059d75378187f838ad61582175672f3e34a5c6788f29040e55daad116a113f3dd7eefb5c18efeb3ea2167706659ea0d30324bd7e66a84fbf30f6bda711624e217c2229b0c204a0754c0d6fc53f7174b43f83441a151aeb9ecabc0b815c8ec053090ab1d47106977c485299702e0fc5d67565c799eccb5c6c85cd17f95fca3fec920be6bb1a9ba796a85b0b36ca9c3b33b19ffe727a065a590c4db8657020ce26c6c4a97a6e52190cc5b9b9c32ec750481e8bb8012c504c5b98b12ce4c701b01a2032ab79fca496ab05b70b75ce2e1be91d464960ec98bd5ea3253470111364b47453d14325b72e9727ee9043d899a245d516e7977c36cdc5f8bb56dbf12e89c293cd5855dbfdd06ed35e945747e2d78ac4afbf9c144814665d24575048eb462ae81880e53f4be5946d3dabe985b55deddddc94a83e06a3de933d28e3427c4d498c8cf9de9c7254bef0b0b20724fb7363e8fb19953845cb1204a238e903a7d3f873aef385f7977f91c26fd08051d848a0b5db3dfc978113a55d9f8e1dc330e51b59e3d5330075cd6bb7e701422d33de16ca6f6e90e46f0a1f7ad6cca5c0827fd9df1d1a7a52e8586847460382f73c3007c79a8b8194acee2a3ace48060bb4c19bdd9fd6aa6392d2e75d517c7c67bda2880b21014c0fcb97d21bc80f90e4392181d2516a1e4d9757e0eb6d0b5a640ec0abf280c3566d22669fb8096fdb7bf0739e0f2558c7b86b780e060121e9e28b0f55a56b56293940f83a1c229b506c3a2a88d06687cb059b9a9cbb866b4b5965932db63b2b2f4b5994ed0841738d83a16b37cf32e930029da10b42b37973cb3bf28f1bf0e9c265e510f78068ed06fa83d9ab9c0083c65dbcb8a561dfec54693c6bc2a0d3a34b23dae27930edc5a47f22fc11e13d3c4e0d00772dbc80ff6d6f54bcdf1826d0fe34efa5d9c254acf2ac2ed4c58eee7ce7e6860f28750d24472eac5e732a390c6287abb7ff9e23454fdc75a2717b8fba4761edbc5f718c878d3ebc984224cc39fff39ddc0aa80882a2735fbd6304a9ac008ca3bab0ee4552f6c4ff760edc87a46db3ca906b2c58335c7b03f70fb47a1a6da893c4f309a49bc903c3167dc8750084fe2d67855ac7eef8acdac710b1f24b743c6fe2157b5fc290af58c449a08112ffcbb19aa8420668b81e9da2ce2116d84bb5480a833b0edb6998d585edbc5fcc733333f5c2a095b7ac63a451b51d139b9647baa912f35cc38c88b7ae96f6aa50837b3cf15958dea3b63536e2a3e282f3bd468bd3752fe94ac811de41a8b5c36d9e2d78ecfce8973a00724f1baecc05327d86767d25a5ba47398e90bbff4389a2e0469976c54460f5b4804524f1960fad28a7b0c623d3ddbe6a9210fc69c152c425d6d101d26cdacc3cb1438f492639c55fc8f8363a9dd0caba123e9356ba4ffee6f5efe16f52719ae6c7fc81562e0cb807d8cd7018bb0c501214485a7533d80f65d2ae870ff6993fb018a145f2d5678aeadd026bbe9e9fdb939aec4d63f99827b2a321d9ffd28db0c4f9a0a1c66749ed8ca7e0de92ab2bac3504e93e720e71067cca7a3b89d89df760d01a5ddad90ac9b7c04fbc9af7e3c0bec76e76a30d4b31b19891a1ef557ba3a71c7413c8232a04f2e1cc0c93d00370b84f67fac410b7fd993ba40d10cfad454f15391658aa8e588eb962b8e105f1b152ee7b1c5b078c52da9ff13aca30a0135eb4be7284747a12fe991cc2d898dbe1b055b943351646517a6a509190b9ae6fea582042bd0bcd5601cfcc9ba56639aa061f1570d97f0c5e3284c5e1eebe943ffb89f597134fbd31eb3b4f1acd11dcd710b92dd28d97aed51a192816a4b542eb72dffee9f921676bb415975236b537db112d9fa1a0d6b7e424e3aee3b5c479e2ab9b635fe4b60efa77dedded9ff1d1887120b4dd5d42830576e7162d0bc341693d31864bb9501efd139bba3e7ba941fb65646883307b941413129e57aa3860932371e9348afe568e1279b974d31e26cf200ab18a89b4e0e516cf8681b64061c5a22a4e125be65de9373882c3d15177a5c486042a0e0319a777bfcc5dcaad7a0c7c24a8cbbd8f127d580ef1096b8f626da898be77e66f5c5ee9a0f2b0fb96bf7d7f40fe5ee6d25b1531c3db612e736917cd20c656f8da187ff0e7eca70ebcda0c457f5be9f4beec58b800ddaa769336710019eafe8f9c6f61283e5ad0ee979eb240a99e41f968ce5481342c065ed2da0388b95963dcc6610f17f9a8b487dd104d80c4b8dd888f72e6143d654315ee35e248c856fc249b676475ea0cc8338ce8ffb562b63cbbe73aeff4cd53da9c82d2d1a0445bb465686bd27057ccf61b0f77f45e9c75ae4b48984cb30d48869e065dcb02c7c3729c7c03aa7bc54afc0ed02fdef975712213f7b9d53dea31ca57a64feaf11a362469895d56a6cb88714d9b93817efaf46187f9741f05c2d0d83cdf14749007951fd2a48dce742009688bb81868a46a65c87898c079566009b71b8f29828749829c7f37eaf7eab6bcbee2542531bb1760b56390ef1ebd85331fa9ccdc5f14f6097ca02658621754e0e83d89756c4413ebcb0c88e0bc9f492486a94ca4a1eab3d23cd9ace4e4466e119dd241125ac6be4765a00eef8757217462a1a64f14788441b656d22cd4f35a9281481aa60f7f0eccb5a679934e04e0cd4952ff81e39034caef3d2d3480d7bdda90e22c2c437c24c6112d84cec5163a16277ac7159349f4a7fbc637b09dcd83bf7abf98451ec09ee261b65d094f35348ff241b2774a040ee363a05d763370a1e1400ec9cdaa8e621cae4889f201b118294afd5910d5b2d9777d4ffcf1d6fab04f6b6d12b4ac741b8090881ca8232e3499e5fbe3f610b40e197bcac183eda6e97eff0801c6a538ac469ffbc1f5b5a45bc671b31556d575bae71332dbc3a5836dcfc2065849986ab0aab20efabb5b20ef410e3e0f2d2a3fc29822368e1cef33e3ac3e95930ffca16fea31d6ad2e27e5ebc980f32627590a4f096a6a39cb5b179036cebd43e0e3fd9830aa8ca8d37962e9f765f70eb5bb31ff3ef2ebe72878042c4008e8d1a3bf8fade0396ffc5c08612a1e9761871296811ec3b57ef8f2a5273d871b89511024307294e079de3e818db536c407292e60db183016ece70f950fc90bf83bb0e1c5eea0c7504997d222af80be6ea097b3c3edd1aa5125d66cbf9937b863af9d19849121d679e0f98f89e98f6822d8c2e4a20397886306fae93bade4e619d98be9df70ba9ca6a6959bd54b9eb9fb3762881d64a066fc380dbe553034a6b4d6f8d29b21bf6328d1d84f97ecbc68baee5cbe6e0d8978b96b0b7b9633e2ce54f760750e0f02ef578d5c3f0ed66b37d51508a0a03bea56c2441f4c2b63797296c0cf5cc038f829a7f942efd58b8caf44990b8fbdbd4176d46823c1f46eaf74c9c136c3fedd80ccf4545452a27bf8575a399d525febdcc0fa404dd78980fc6717229256d56feb73b26019ebbe781de119df91a8562923cd3a5931b2d0e4dc879cdf0ecce762cc9819e390b7afc4aa5a3c0917cb12ae9b92499a72ca0cd2d606d70ef14995dbb18311db393eef655c5f6753c6df9a8cdf31b677ac61748bf2b23559837ef7749da79d78bfd3f4df4b60198a6dc5ae18736840d4f794c811f95dc5329dd56e20ee6ffd4867431887d5be2d28b18b274c497594745e113371323747b9a2a3c385128ef5a123477e442b0ac12fe1da9e41cc71ff70d4cd8100e5a59fffd44acccd0029d7e3248e6b043c11cdd986f8ed6a641f0893fb7615004da4d896f16a3dc7406bcdb4f6cc0344af2f76ccb7bfbc3571d2fff338c2e96bea0a5d775cc65639aa81c7e17798e3a067aa992bf0365748c2c322da1c77178c30f5d41c13b4dabcef477aa9e7b690a8e7ffd56016ffe3615472f12c7ff6066cf7e7a0ebef2ec46b0946eea2fcedc131213a5d17e2ae4c09e333d2e4fd017d5c21cb8e4d8fa9aa3ffdc23d86357072441ef3bcfc6a67dfcc7aa8d9579a50bbe7681f62a8d04936484be31dda30429b44b74cb050188fffb0de503df0f17dcaae6287d4abb514bde6025611c93dc75f77465f87d23dbc706bb64b186cc94f9238c26ffecc4bc59a7a460f44129399f6cedbdcb3b7151deeaeccf258ed121e0863d53f4ba5bd357790bbda7b3099d62e4c26c0c72ed0e9720d2b50d0ab7220f823e576f239bcac3f793d085ae063026044ea873a204eeac8063b50efb833b57dd6963455012ee379940ec6f3d509c0353df9bcf6e6ed3013e9ab89829e46518482b14bcbec4aa5d7db962970ff1eb9a96984fa06d50a06c8838688a440765d28399f09e83d9dde11787ccfc35bb1dd3d91a33a6479e884aa1c95a569574c9a115bea2e1cd452c7189db1e003dfd110f55bfeb2cd4f72caf7eb31ae89b4a2becc2ebc25444c5589045235fb9826cf480de8b64af6bfce6a7a549c76be9bce84e3663d57dfd471dc01fd485d5dba0b1431f2ffd68c9c53b071937e97209b34af1eca73d72c62c289f18f1f0f4cf1cc0c20f2ec49f24358c9019e41f5cffb34fba342390bc441cb0e25f4582229cf1148b2aeb10e85a44a9205ba6d17bc5ae2cbc4c80cdf297bef8f17df63378f3df4ba8b18effe6079fcae0583f3804073a78607b0860727118633b325e70bb87515ff2a8f7698d9267d55f435282aa40a4f7bbe456bea3ab58b35e7413dce3e1b9ca46e5043b49cef9f25f5ad7b272ffadfd2ec340c8d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
