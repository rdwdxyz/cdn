<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9f726aea0f96288ebdc62c3874209b3b657d26f6a53f53c407705dfe58c6165b82179b80c9c0f9ee73dfa1d2f4e001f2cfede1f06037f7eaeaa68ebe9f44200b4bb56caba93f18e7172b53ba48bd36cc0bb1846fae75fcfdd031d0136f53cd56a1e020f7847d536b2e6a5c7b8c68f055b1d8a8b685d1ec62e1e19794d9605eb191d9e0e305b1b9c2be3807a0ea66ddbc3c4d49697bd9b70449c5b5c2ace1b5c191279d2f2da50ff8231d0b76a1ed56335c1d8d5bc339983217e0e1aaf63f6c317870cc4d4087a3b5996487d1982781a97a2b8e98720ad30e4fa5730209f63e693c7978cb960d6a79cfd77c7f8157d348733bba1fe93016991ea2757c4f6a9f7db15819459f874bf43ffc49909a009afd1951724d57af8bae2ee708c43d06ae8829c16f9526094688857082f1fec46b67482eb5ce9bd8e28d84969b77c633d9bc5c4abe3265f481ee221a8b10cf478af9e5316a10f6a7b732940a2ca05b16c71b57ffe4ed05cfba1d1ca2d5ff0c905421e5789ff3e5af01fd039ac933c818cc8dcd0dd226c3e763e492d843dcda34bd28da6abdcc00afd7dce8e06bb69bf03cf813c9178d3441fdefd680fa4670337de1a97b0aca6fa86866e79f89ab13d7e76350f8e149f5c4764d565ef01f758b83dd1dc0682ff5f744a36f4d015209c2477e65f1f9bdd7bc8a059dc3de72024e168dd6bd6c64b9b6525d93283f203a6f354783b029645d9b8562bc0454a89cd7e25dafbc33f0261e62659d19b5700c23f7acc38cab923130ada692d4c62561ce6d295241d6af8f8d9f02180d5425e7e8a1a61c74b99a68e468bb91ba99934ac3e24a2935c4f912e6fb91fbca31406d630f83a97bd8f3b8ddcd3aa94bd1f55b4bfa3f4ac92fe025f06ab79c6d78ec3952e3115f700195d603b97b5d34682763b2c4918a960b694052eb3103d2a31b8331e563badb63cdd6d345e050e0e6d3f28531027d0de0bf8edea79b7314fae65cf7a88498b3f087fbf820a0b1be237656d72d21d5a4365e0626c29fdd415e02b073e167698a335fc61a44c7d182e115369473eddf43f629bc2db5da50e43766e020e993d8f317483eb2e08107c8e82f567cb1e80b4c8bb96fda30096ac243dc03b21b1af95391afcf22053ffeac7d73c5e3cb06441f64811a60121dcf72a0a31468000531af16dd74dca74615c82ab73240a08980db730fe125a5b0ffe4747d23c93d201c520b66c1636fe2f89cb0fe4e17245f1a7ab93f6a696cc811c91070c55ceb3a0bbf618af0b78e3af9ed0d9c2faa53bae5034a444ccf1197df5c03ca7ccf5ebf645e4d5cbf572f8ff972112267de075318d2076998b9cd62fe044b78ac26d74e9625a86198b1114961816b6ebf41df276b1b832c573f625b06d2865df9ddccd075934352f1031fbf5732d707110081a0a98a133ec38571350e9c910d3c95193700756cb2e6308d6b834d36c6542a3684be40182325a178acc4d46f4c2ea69282a1567cb3d50254aaa58be358767253e92a81f723ed4fb4164ad3a7d6d5994f550a1fd1a76f8edc7814180bdba240de68499d0e20e0ab7ea813a10ebe79e6333dad4f354c660991c8199cc03933b62614414a6977030498cae983927fb7dc2dc126eef784f16c47b3b89e4c0069fff72fb1d9178fe8fe212459ef7aa70d26d31e03539e73363ce66ebedfc994e5e0a8e373e972de9a724a04eb8102bb9c187862f22fc274765cdc8f792eeb61079e481c5be9419f0f61e02e8565b1b7d531fea31becb8ec74ac1a209111d994414f3b91c45910280a2d695a9ce4348d12556a3f56a66f4e60987a5ae11d8e046119a25ff8e5f571ab82246addda8f4bd91c20aeec831bd3ff3de6718c51e0c2ee9a93fa3c233989d31f84e7b82b85456ce217318129f4fd967b27256eb29b4e43f2769eb141b0a692bfe3911c5fbe954c055a3d4c88256d90dd53696286eff1f4290bf576f258f6bc05cd0b40e7ff23c68519f0556d2bb0066bd2dbd991735a4ab2009dcf452ba15ec6be127ba9528a7143a1a3613078b9c9b4385f3839917e030156041f30b9d3e0c9e0cdc5b7480259076b3f4a2e844bfd8387c3f5c5cd805f1ef05c751a1b10e68f40dbe995f9104aba8c648e3f85248c0773a87b39c1898dab4f3e722a6aa86e7f4f7183434f039f802fa6a52e2e6d05a8f58bc5d737666ade728b2bd05705886b793fac515bee2c479765683684430fffad2518def13dc883c9044f1fc83e86331abceafae32e0fef2cf7d60c739034078a06bff2c72f1d62c97b66ce51eebe682c4d1fa59514cdf873ee6c38760b690c66b3f32f9df8739f0748808ed64ee6ee173bbbac94f772ed84d2a82d57d95188512b63710ad6b26a3bbad7b76c542cb0e1cad0f1788f8ff0080e3411afacb1e075fe45b2c61dc2b3c10085362b9c912289e955f3c00303dbb33293a087640c211ffe60277f31c0721498e83a1e7c5a2a25aff870f9288b72bb9d40134704d4954f7ea9ea3f4c593b876d97842f6ef2ad0ab2215aed350619efa4e46db77bc1f7c5c507f23b14470608b2f475a2ec57e3977089019c56133d0109ba527df675022aabeb66ab649cfcfd638db8efc3c27180ad739a866b4c5dae99c0a6b5688828782f3629b41f895b5043204e689c4d4f04ccba03abeb653862fb33fe68cd7136bddf54f4a829f3407245b6e91ed305aedb671f0eda66c6f454cdf466e336c31a3a55e06cc9ed2d270c212ad37afd303562110febd709351d72321ef09d0946f0e8247f21020bfa5038d8af580271d257af81ae9c4124ccb44f59c52f97b4509dcc22039694c569c67cd348b68d704aff8d8f70c633692e70bb772490d3cc6b1ea94da2c0b0a96a71823ba4c59d5ec3802504503f8b7a168bd080e621476afffe7d0366521247a4b59d366770df200474c98c3940571a7b3b34546933ee8253d77671c62185640e31ceebb376d2d3034158fe0de999133352cadc56b527fcbfed78bdd24be201349ee9303abf8a1a77b82fcacc93f66d153bfb6b7e7366f789302add8486865f039ebfe90279805b079b786de2b31e6b54d9ef1d181aae7286e33732ad05c9f1841abcf1d84a0efdbdd5c3a10f78f1d31e5ddf5cbae6b717197f37b630d6194ba6baea799aab36955d1763f6773eeb2505bdede467181bfde7478ebf9ef6640bcfa7dbadea7c5ec7e8317fa47fd73a3c8e4ea6467d525c6e7756c171791739112d4cae1b883c3d6f276f16fce97037fbb9f19b56732b6369260cb21910d4e8684ec33923b49aa01f6a8e49550abc1b4a039dd4bb7946fe33565218a9da3ef1d276e41244c74023cb8f544298a293162e441176130cb60563d2e877359281f1ec6c6cc94a33cdbb08404f9422c1efa34fd310810de60aa69eb1af850b8fcc509a954398b63da46254d05f81334a9ac2790e374b938bfbdc85eeb175988ecce645dde82e0d16604b0e1cffd46a0152b095164c4b8140975430e12bc6e039c4a0d8595eb32b650122b901bb029612e88aaee2ad0f8768211dc1a50b415452a5585b78f9b46bc2d30e66235b7304f303d5373cc0031c9daf724da22c4c84ad1c0ab2353fe28f0f933d2108324689949aeaee020bae8ece8930e6470c08781418210228fc089fb9249accab8e938689726061f65b0d634f8aa667b44a002a19a912c57211a82ccbf6d7d0da37a0e60f255e9406246d5872f85bd5a3c2b866e377eb32bfa69fce4c2df5ff5c13a3ebf26716718b7544634e8e8a22874a26cef1e1b06b9e869701b39e1d7fae52e646c026291fde9b850fd1e00963d5cdbf488bcbd0394c5eeff4d424ac1f3a94944c8287f56df808ce77b8755b0c6998a2abaccdc23bb0324c0e6aa47adacadd8f2d5c3604b26f2b5f66c74afc717888fa3bd37620876f53a2b78fe5af9734c9144d27496fb0781896137c43d41e106aa0c3490c088fc3de9fe363d4cbf13dee88555a8874af4a9fb631d4f92ffcf04ae3121a27d5d9a94cebf731ab5a06284f785b3ac9b64f1c581fd601edb4e0dcffe019c8b93a6406e2f6dbf7c74fdfb25de82815f006e29cf26746aec03354d120feb132a3097228060313e3ad554af195aac80f003938bdc559b490be4bb4b47c819aae0c4cae235586f84332d6ee0143db3254f74992a87dc87ad1a7076abe0fabb1da72b7f62a91ed82cef8296d322cb65c9f32473fdc380187bcc4ea6c0a97e3f60824fc18e7f493d16757be860352f7d6306cbcbb733f6e3393f3694c142db4a78e11d49db5bea9956987b4e87637634900266d13fbe143f36639f522e2319ce92f656fd2464a82ddc24164ca85306062dd0e166442838f438aa84e976eeb5dffa1bd3b01fdc6767db07819618f2d3c9fd9a0f437667f1a59bc7c34dea640118fe56628dd585d7747bf762a2dbd75475f07329ed022de5dd6531415b953373142062ab0cf414616390dd0544b3cb89c0fe3c2560efae999b6c0462f3b4b4b73b84a32b3585425cea0c3e524614cbe32b8466a9ef376884dc38975a1e1324f4241e48fe29d885fab4c50c825a5cc137991b7d5be4afc59426b3e4a999945148e8a0e51fe339d8a00e07eedcd59acd595c21f931350c67f363a2e2450e666740973e20ff827f18d306d3b192e3cd1445fcd561dfdca36ab120efe17d1af907ad524ad73ac8491983dfe5cf792479fd9ecfba85d946cfffec533de606d34ff0c7092066303a34530c34270c0c70821cb5f6e38c6fa2c776e08f6f1322ca43c7ccf4d0aa744b1221a3d6a5c4ecbe2ca79eb55f3d1dcce6c542ef33d53c7ae1684981f81bd55067277614f51975c775dcde75b8d084d4dbe918fb365a654ce43c5c2aba5a541e485cb7bef7bcd0a46e0ec0be9c349d8fc8aa5e128a83668e8b37fc89ee2a50224afd6cfe0b5c863aab6585d8382104e5fc6616ab08901d12211414ff1e6594c8665972df20ab505fba46f3b1e373fc651b384559b70dc1ded212cbb16324d5613d949066f5719cb82c3f921b3d8164b56e0695d49f222adb9029fedc11e333ef96caef3e0452b3504d54365224cf4ded9684b6e9a4334b5041c871489edb1be61dce988fca20efefde561576b17a5b57670403d04895223f857c7f6ce9e81ff2b643dedc07c00c8b001a38db6e9f4e96ee9c69c564615aea8d84dbb00e5f62c18d0d44abf5073cb1b3c0d80cac51878a7df676b315c7a55d5c9d463b93b02836ce8ab39ec3e41a5dc07e11d538438e36fc4e4b5f835d0965168c4ef54fdaf08eb46ade2fe01b353db5b69cdb463bb7afd19982507a0dcbf851741722fd0818aa9adb5001e3ef9acf952eea88b8699f094720437bb802c7ad8c9370e90ddd042366659c36818b6ea79b65aea0ac236293f9e24ef2c4539c6d2eb28ecd138ad4f6102dc7ff5c6a4de33418dd8dea086f5c5a92a4d65d758771460d704551a3e91484a5d550eb4819435223fb8c3bfac555943b1d48f6b3e130f126fb39550c9d238da40fa06c623dd194de721bfa461ca8a21ac296e07c7cfa681e7694873dea69712313b9dc33bc6ede0dac1d2e3e979f7e09978889e68628ff58c8d617d987a762563809af24c14fe34b70d712c172f0bf77d91e203beab44a4e7cca5bb7af4e123d70adae400e40c020903c21e4cc6e94b60509e9e647b86a026a524e646fbf7777e57f9ba5b20f7082d79f0e2ac36789da68987e848a9bd47b3e3767b33f013c72f70f6b38cd990ee28406667db282df8c20b11362116f20c2b174d5d69ae4a85fa08e4d31c3431ce834b76cfad8f2e00e15919acfe9a5df80a37e3ddc6880f163caaa10a50736e8ce33c7d45959c3c59db77e602ef5e15cc823cf246d3e1268e72de6159fbd69824deff8fee2733d87adb621300d67fe51ae0d45f54631d3dc11ef23be194a06a8fcfc68415f209bacdeabc1e2afe786cb30461d0a479710070bdff24450d994e07e86e1db9d8a560e95a5aeab6f419d1225c8d210b1d5eddb9622181b407463d6ccdc2229e27a747850afe3ae63855a498d2a8b5d52b173245b16e103e657a712cd4aa5eb4aa5f12bcec49568f275bbe1d5fedb472ac72d96950c138aea164927c83764ebd804269a5b91c71451339a48453c92f8e30a082f4de6febe1e96436cdc90fe6a4dfc3b57731deff5bcf129bfae42248a446bb32e8660fecc10873feade7e44feff46acc3e4174c66d93e6ead0d6d2753302dc34869b8740206f466ee1536fd1e8a69df47b2c729db61f3f646e7044cc7faea66e559afbbf2f289c33ad3262b48106e7d84dfd5a449a8c5b45c2861326e862a12c05d0967362c746e825d3832345c108ed578761eaf359e5158dc799015df4644ce1771307c292162113fef247d8459dc6a8b393f6232fb3eeb8a5772ac15753aa4527e65f94b2df49c13a08e31b4f14727a31176f423ef109bb43b63750f493a1d0f340d3b622127023e379e54ab65c7afeb2991068cbbb76d0cbb6dfcbf49819bcfcf3645d3b932dffaaab9bd6bec9466409c5e7616be9edd2fedef01fd8f5600eea0e1671f130f213179a0b8212970338d255a563798fb869e88d7169767babc2d5a07e237af1243f141923ee2cd828be7c6bee719d134c8bdfe52384fdd0396017953a56d936181e48223e38ca455a125db7da64a068df6c97f3bab97642a421919935dd055a8199d0bc7542853759f5117c22db39fabf59b81ae65929b18701229edbc8df69fd530cdd8b7313b7b9bcf7eea3d3371374b4cd59147f88e4bf4918876885aec5dce2f39dd940e1d43e4bdafb4d869d3421f548bfe5af00cf7c4bf3338e046691c48f2d8d8d7eb633c1f112c30e0f2e4fc0ca31a2e33e1ae8a90e2739aca1c436a6b6b4dcb4617237a7f3743aae3de960e790947a33ee0d6fadba996f3b3937037165a209ca2a3cbaeebaacc8080ad8d4a01e6e2f85fa64976f8174ef39e084251b6e368b26004b734af6ebdad6b7ea81425e6cf96887f78d72c1cccf243822207aa3635ced47ff8119d028d194deb4db4926b67bb4481ded9e18e5d9557808bbce74fdadac7e568b9346fd36d5ff5e39e68347bb787511334699b07295263a3d6fb913124e0aa14ca503850470cce104ec31e3b835d5feb16f89274e96a5a6f301e68f2348c7660a8084868e70bb5f09798435f95507e7fdc5145b65d924431f97eb1de991b915aea68b73c57b132063a3cf56f91301055c08a4c2b9b8dc934d8ada3168c8881a9e20ecca7f6d4a096a2bdb0e40c679eeae23dd1b3937f65f6a896897c4bda2c257d7c4bd7e70baa78ccc9903d72dd5b210dc018aaccc7152965d5deaaea4ecdd2ba47ed5fdee2d24de5ebb996e691240d9f8bf00e2a176daf42ffca49d5d8bbae2f394d0ebd05e6ab2107255e526123c267306328d180e0b6e2329732c8609750460e73c5c772a7d4c4e3a32a8abf8f5ce40cac3e80b045c5c18f2047a37912162f5b263670249c2328900611f6653512578df7c27245b11cc78eebe77780d582a24dfbe4d71edb27e2b8605cd2dcfcd32f5522bd8d0098556f82853ef9089a358a78190f08141491f839faa81b9eb6a1ffc191e8afdb9493e73451ccf32c8d00d38bfaa492d0ca9819b2dd3ffa1634431cdb1a6f78912f10dd4ab42654c5058f8ebf5f561f31beedf8ba2e5015005e6c4c5951116847f0a0b6837fd31d140f1bf2019e32333cf3c19b8e6adc95f41d5421c88774e357d4662294550e464f2f0003516d2dffd786516009f48acb0029b8a38502b7d2c2cc744094c0858d77322ab28994cf8d4f22268bdde7aab03ff306a90f369177b6786a64d3388dc1606b3d7d1acc93ccd1a621509f43b1f1c5dfd2fee137102486532ee5b7932255b1e4ef3eaaebfc3dc5588828c341397b0633d0ebeca13f7fc0f17cadeef34aadbf5d2e3a58e8f95e006f6322159882707eb508a6f01c9c002f94ad6322e7494ff16274a63054be130eedbaaa7fbf1d66e639a2791cbeb3c945d0be9d1a10b55d18a6f30bce5dd1ea6b513f2df80e6cdc0bdc7f9ac71a4b46e6ab57e834da97ac33c3d5bcf9688e2fc71451f4b74883caa0bde54c5824670bea57b95beece78535a8405b57c27d6e6cec446d47e5cd9ee0d8a22643822f36dd81c9bf1c1017cf1288bee23cf73a8a8f77915b48b475c25350d1852d7bd079b40d10d95d78997b66a75517b1d5c873d306e9e2204a9b3545cb84acc66f7766924043293ead4bdc8419786397d603dc7238ac32cdfd8f9563296c716e9f994c19bf568d8bac21861bfa47db855e0defe869af5e6652ae90fb7ba7f0d4febe8ad262c8f0e701189ca228be5c9aebe1102f5386cfacdd8a4e0775d2132c1b0c190a9bf00972219a8a8b9d3967b79193018715836fb9145cbff14d60f8c0fb6c52e19ca53aef79205987cf8a1a422a9ab4b4db1a899674643bb56d591fe7c3b9496db5f4cd17343f242c5963aca99ecbe09f621aec24d293cb414d51198712e0c37d6e62757563e87dab4d927c4057002e6b13a0832d0868bff911622cd52d58286c0fe0466d7ed57043509f876b9522297ae1997ef8d929e080437c88839799023bde921dc31b6a384fd9c2091b480dadfc683ff3448754be7e0980c6952e330aa9293d2ff5f8ecc5df181065b0d63f4451cffc7739507413cd5234d7133e0b992ad05f048fe14258dd4705fd73fcb3d37c718e8286ce239d85f4c9305c5795efc6eb52aca70cf4d3546372067c82b93738d78762bcad5c4c322d755f969cc1eb6bfe5a13ea94c630dec53c5580a0e54286c35207798124ad7e0be1e5100208a0c41e0abc1120e86d3181cd33f9c735cb9fcb3ddd968cfd0a1f55f3101190955de0d03ba532c22d15b888f03af7586b0e79db1e2c9c92e3e30a6da0ebe7b8a81c912efee91bd7ae7620fc2a763baa879c71578653e855f96fc9215ce1b7c39a6763c1667b42efe3d51587a0a4299300e166ebaaa1eb2f96f3c9c53c054f7c9d169b07ffe02a4a5e3c69bae0e133de8dc6fe7c8f820785f9c3df61f975d3f93b90cd03c534f6f1b26ba40cc1a089b36b18e5f843b3853af1316903bbb035945879168078999f52d8bd03c2af2e2a6252bdcfcfd658c19b974ec0717e08d07accb0be1c633eec6d4f5fab02cb40446f631e27b1ff1c7a688312beee6d6eb0e4632f73059561f2cad5ef8de7cdf2a6a769dd938aed3da589d1e83110e2c455f5ddf70316f7cf05cd287bbd498a59e0943edf39b5fa172b05f94f58e15dd5cd74a99feae43fa2c0d91e7ad5170f894449e08e3b027d56aca8784ef7ca4b896f13d2c6eb375a762681653507f64e71e90157b3efe15ef27c60c5cc0f40618505344ccfc75dcf6e491551f25382c7268b3a036214d343823dda4ab6f60459a31f268a71cd2e98500669af1ee3160927fd641b75f8edc04e09bc926e0c08b5c5d192ec417b694e643da7548ff666f587a663bafaaa33ec7d39cb1fec0581360d3a1a7aba0a6762d10a96bb514ba7fb5d9c712baa4f0e2e95198ca7010f5dddfeedaa89886e124f610421b5655f73296b065094638b8f2e91efa35b9e60502389a114b4bffac575d3f549439369c3b45d9cd959246181cc9c2ef0303ff5f3710462bb3acebd29f2f251b995a2609f211cbc5778e1914ff2a6b66f85fd5a6d8cacfa61c84563eae24e2a655daa662a304c03db24ecc733f90b33286e3d5602de5e61b96fbabca8ea089aa352867cbecfca6c7f482a44e19624a56d6992eb7d852ec9491616b9d0e6ea267490f32e5c91f04f5ea4591d13492abeac8d1a6c98b9763cb23e90b899f2d9ee80866eee3dd579db8661db7697927b9d3ec00a0518e12d4a2cb5cea1481fb003077ec78743e2e8b01526a215713de6fe7bc2f69b2918ded8d77844977201c135d88905e1629ba7bb2f54933b52d9a769744cecc8909873045dbd571b007211a8917fed7c5bffd033669b3ca83bb95d05174ccaa855533c0e65b8dfc3aac759810c5dcda4d8ae5c98521fc6472f49590378fa7c227a0a5a2547098e6d4cc64773b1270c035a17df0a2f8263b9fd1e6ba62a0a09179b9810d5be726997c71a769241746c060f2d5090e48400cbad62c80388a6237cd5c0ac569af6175f3cbc479c1bbd382dae77f4c47cd2b9ad0b455ce57a1718a9a89c97538309418af47d296e2d9bd489acc31b2d54a3f74ca3fcc6b1cb517def48ed486e0057569f94529351ef30bbc68d968fe8d4361b12090839c7d0376e1f996f4f7553183919a9285976f628eee2a0395763602db719659e82333f1152c5fc300767d23681028204547b96bc2972e9f5b1b58a41b6ac3872515775a99cdbeb7e34283bd1cdb54d44441a9c5b55d9c81d25acbc8376206589d08613779832fa9a8928920904be361dd108eea3c594f9fe54de939f9242a0aad128d0db94ab889a9ddd7d486f952993874437c718f67da61f7a9511d8572daa6819033d1829f6025f12985a5159d52335d30ab8fca449ada77a54f0491edd34988b7d6f2a9239bcd67363264d757fb493e5d726e7d6b9828fc12d23ba01206c88b17672240e89d231779431c3886439cbf3f0f54996bda73859d519538ae486845117392fa0cb44ce532ceec8227679b8d56706bf5a2375489590709fb4b0b32b398162e5bbb2888362222cd117f243ac018abed8c581da0541d67b4d10414a986a9a3c8ee9adad50e37f4af3fa53f742e1fa2eaf34b50e10465c4588d88df690d3fb492e85d3dd50b6e45aec916e66d6cd639b10ee2c824df4bfe2a5cc6ed2af9f95d58acd996d17c7e40e458efe68f627ddd4b7399c70a2a315e6c02f1c9c9875179a8fa8cfbcc62020d9dc89948911b8dace47b47d82659daec4d4473cc9a053d6c0600350f7e410aee53967948d0fe16f56c545e9012030f5444b2db039eba786d26b415be972bd41b418130bd3e7a17260071f4c467a3cef62c1610e8795d28812b19641b0c279083787fb37ebba6bc03d860ea2752cc0000febd2eb15fdc4b8a786ff3a0a63c24ebe6dc33c1dc0d10a0c93db01741878ecca11f229e3421b914d7859742f2060f3333628c107928f7a225553f029fd7fedcf07fe1763c5e625043857b9e851ddfd2f4c55e70d0783bd8cfad30160669fafe2be916b059ef22013903ad8d7430abf3cb561e3bff9c670ca2c5cef089199b34eb163bcf9dbe7b6f23831f90c9271f9dc9753396ebfe279b0865c820c7511a219f926dcf729da507ae6a2e4250621abb3d35daa4f0fe228bcd561be497bd650e5957dbda354ca78537a8a5bcc957df3392274f73fb46f1a9d0a626b04b094b92f5740888a48d8f69cbd4ad53c6d512cd9064d1492e1e267e07da1d07c801771e02bff801b61a22bbe9543d66d184580a275574ecddaec53a62a13b0bf860eee69336e5e2bc0c9f49fd5c6d119b45c7f317690054366c55f18b8afa68c11fcb8f17ee9d82c443e500d84b8a4f7c8f64d1dabd53a67e012de0c4ec73b4cd275af88fa1deda5509f69772046ffeb31b256dae8b148a2e560fb6ec649196f4ec34342af35222f588169403017361759abdcfb6e0f4878e457ef7b9380d53cea1c1f99efba8b2f317bf94f2cd35a79ce1f6f8b1ebbd887ecb721f3a4e85d0357b5568663c1d5e546a80e621e0fd8e461ee8d3c69f06b849233b5e136d40dc8b48c0aded8847828ef4bbefa537bc665b9bdcde3ca8a3d57d28e0b66be6213c2167fb455b16bcde799d87dcee9c832c53a208642ee200d85064288594a93674e669688d908e96e60eef7a0e70f6f2b4e8c44051daef43b670a5322baf381cb61590f90e503a08c0445fee456b8bf527e89e69ac88d7e4e25c4af1de8d2ffd7990c2a6d7c8fdf6266785a5389876583a1d6f375fb031f0e5692ff1b328ddcfe6df8c2aa42e00e57f720842c08be4e6db7930d9b72e61ce8fbf0f990ef0127c190891beb995a3af3e8cfb6569afb5ebc0c01a859f67e74708c66df2d16594bcd4227d11b21dbe3c0f613f780bd23b4d9e07d2c634287ab7381646af16e1cf6b66d5645b1baa5151f0437741c71b5bc944ccc433ee960e5850a21c06d076b02a8d221bc2ec588c32644835303f9dac4d6b32cd265cbdf9a2adbca1d5cdae161490bca4b5f449d4aec67bdf550e8dede952dd6989928c81bde28ae5a3f2be09d776dfbb4a78365bba02c023c7040dc3b07aeb007c8f747b37d4a43fb35e411e987e916dda895ec4c6201557d974d8f85d6e0662dffc2ae6ae7662a4b2dae58f675343ea13c0fdbecf99be8b854fb5ccc4dedb52b305415142f5b5fd3bb61e07633a69741a715eb33bcd43570e94f6b19d5587c5ac56a35c3f03963c8383965a9f1d17fe0844fa20906ca65b28b6ba47ff9ff91ed9133624872e6d35730183924e3bf2903311938fc4857efb03141968670fd74f3c7fa84ca85c9ed545d3c21b78ff0a5cd32bfe5f25264c0938d5a66462157d33fdb24e186e000531ec46feec0216ec0c7b681d5508daa3ae423f566c9eda72d0458d36d09b0799b36cb6af87c390f5dd12e4fc4e3e5c39f3ef12dd26ec3022c56975fbfc9f3c9e4c84aad2242b62b8c92070f2ff710e90634ade65302d45bacf423a34e356ad79a0fde17bc671f9f83de822431cc06480d585bc02f3e49dd25df6139ffcd9f1ffec486be8840e2b842e64be11d714dc061a66a91594debc08f11a496cd07f9ef22402d0c7cc3dd3d3bd020a9c401273153b5b6989f53aae3fec89f885e92ed9f33eecc0ba2ff73a8b4f8e8d2617f3cc021ab72d67a03875f8ab8cd05489110929c3930a45fd409540b37e76eaf97a9f8b52bb4be046a8840162292a5f9ed92575d201e632cf60baafd15800d99b81277b4c40b5ec0dbb19439f4d9856c9ce2e3b814539521bde4576fcb399df8027f7b6b2f073e94a30d5861c34d8e45eb9db783d14e6a226a4af7b5fcb702d5cc807ff63ec9250222313cb5d915f58d0e1970ee87cb206bcfff7aa19746ea24379aaf418b8507c404d1dc69854b197b23eb4e0ffc400f5ba9154283a9918c18d964e8a850d2817c81bf466376a3a19e38f00d7fe087a20157fd2b6f3d857396b52eaaae04f0064bf01a4a48ffd6c69ec0464f917eab5e681e09c783c3c5f7c2b99ff7bf1f765e5e85f4a456690509111c9a73619db13525d71ddad45bd31584052eeda366bdaf54a598ae3fe14dddec5080e4ba22f38633775917d1ecd110a0267c5ea27df7c16e1643e5104b13f687eed9a02b14d774d8a68ec69ebb6699b4eebffaac2467dafe61d8f38d1c48b58bde1bf1dfb1dfbc36724e6f39a32d12429fd2d95b01571965908facc9ea97355183ad9ca176a38edafa7b994376ac3e5049917fcba58f843c037fe4cef18cf0fb371403e6f963766e35d98d1a36cdd66bb386c7be87aa89d018a8bd0f674c74d6345b6f74b2be4ebf8a3d83b148deac95abf930b5ee4bb9a75069c20b677dd9d33726133f5381a00ca48437f4169b7fe0aca9a345cfec0f9b0d2cbb7dde2be9b3efbedd6d10207b1f2d218b056403a8843226f5a28b0fc2ec57e05e2ac1ac0f0865b40e4fba254e08ae27d965a787b762a8fc6d52b98374639c5e36a2c202d28b6bfa81bad10d54613000390c9ac929dc432e49f30b3f35e1b296410b313a91734a5aed93ea217d7b4dca1a4f1f605d6fa256b2c1be24fa0e4b5bb3f7570e328a157dce6951d1e7ec4d1a4b791642d9df459d43f22f5a5ae23d997dacb672192b1c2354e9f7f3062a682a6895c4e6da3c85cf2912c5a18a98c948efceb7b083cbf95b1e332a24c635e5ad663673b09d7e13d55aada9deef186a75c14fab60ccd5cd0202a06f2f6f765c168c9e32cd77d40b9d73b367afa8b6301edfcecc0c15b18f2be1bafc1adb316afe93b5010bdd243ee4166005e9abb334cfb00ee6d8eef1d2da739c4fd5cff4b9cc7b0514ee411ae8be9383e5567f3865230a515bf6901b46001c03d4cd0c363465812abf139c56e6994a50b52ae48188faa86746e1e5a154ac3e248f89ab4d1e52a807dd8f790623d3549bd600da61a09a28b070d6dca3715389131e2f5193968924dc49d0f9fe357190dd1fb10ece59028d891ee6c83a2e389600741f47f6892b58336238b3e666efab052de7a527af1af4995d4f4557ab41ae54e593dfd32bb8e1c962494661080ee79bb64f7a304e4d09ddb79361f1b5a39d6b9db7b72814b2fdfa553e2bb2a64de088bcb03902b19ebad49c289bf79d9d5f5b96b3ac28d6581ad77297e228cb0c57dd775d991a82aedcf992336f8784248915313abe001828175d2ca82832f62567e5552fd4db2fab0f410aef1f65950058d084b102e1184d49ab439c4141d25af626208328e5948dddb009e496048a6a42b536a360cd2caff142c8a0451f29bb49152e80f9a8eab560e5698497737d0794f8dca1f206aa4bf58d7cbc2ddc0532d90cd3dd166218175b70df0ec04573f7edd6be19f2662a6ca6cd47cc343691bfa5ee564321c55f006c2552aa2111fd601684bfe6ea1d1aec14cbf97b487f5a5a194cabfadf6f47f4df258b6709f5baca488d4579bfb479e2ae05129951765fba6ff7fb66fa396bd75a872b51fb98671550e1006df6f7938b4ce199463aad315a44351d1c361242e00dcf816142ac1ef2eec7e152218a63f9f2c146607551b9b2d25c70d1d92b173a7cfd11cfd8646c78eb710aae2bed0965c8d63aef4239b9a29c178c07845cf7757621d83bc9c3c6364116717ebcb08ca48117d158fb92d3a19ab37d51d6a560ad43ef20158977932c2bd707ca593316ed7464b584ab3832eeee5e997632599a232a793414dac5634b8a8e39a3daf979784413933874c556b49e974f5e984480cc8d47fc3c35696a28efc5743322fdd43ae296c975e40b2769d51802a184a32a23b393ccf7efc345db3bace36ab96c86dbda572e5eb7a06a167cd3f3fceab3aed0c9c17e6dad936cf2f0573410eec5ff85258ec25889ca4c567140596dcbe9872f352c303fe6e2f4cf0ee3949dd378feb0386e8ffc6b0744ca33f1607e17e22c75cb1c734a028d72fa57aad0439eb9e5b8945d02b3362a769f49beb23fe182958f79b9b5054b266906f8a8e81208a3ae6e648d670c7f2045dbd245e09cd6c148e76b0a4a2a5942fceeadac86161e9c12719574a7fd3cac9755fa56655797c77b16412af4a1d3ca8a4fb7bc6dc4e83f636f4ec19e70e2be5ad5333177bb8cb03a7a07a358f1c5f8ff6264f906162b7990ffc526df6686b8fb15bd4ba48321b3a7b97eda1f3ebb9a7fbcbd51794660ec1b7b92098d32b4f18c3f8e6560109fb4e3a931b2a1f2380cb53ab3753a8b9f3392e1e164e4a64ab9f35ce8078458b6dbf94d057f144f6a538f8f8b73e2fbd61040589bd9d9122e5d7e177f4bcb78b41944fde4945df676c87dc08c50d5b5b23d1d6a92c80ad6648c4beb98415503828bf786be356228e949a9d8f208238aa23e3915e40453a9dd6d6ffa4e687b5bf6d756d31f87d16da18c87b04a3dba79a420566eba27ef5a5020dc9584861ebfc1e9365a718b57783c4fbef77e80c2f581d7ef4332f934cad4a35699bd630450467e8688228f36d8cfcb5d120b137b1806f8401d8c14e8350c136777319abc5c602261f78a6067ad7f59c35a360feff4d14bfd6527cfef33e8fa2d974080b474444f8d55804662b45c6a1b811df0e47ab61fcd35ff7a69c149a85bd4d12849f86747c8379f6ec4f6ebf9ec11f11f7b322594a76f92929eeba6effe26f3ec1a2b10f8b27c8d961a20849ae634a89e9094226d1eb372d369e38b9c5e727fa41906e3ee6621c85ff151933b8c1416db28b60b16591be08fe9ea623e1391d0932132cd7e3875fa85ac1d3df2a8cfe810acb913e3db80eded2054376b87a99b7df2ffcc0bee0673ba635b41f55548fb17d7a8a5c1a89b895c52a7eead86286bc22497c0380a412f6018d9db82861c72c3f47d12bb111d741fed304bcf2f84f76bd877a6b3813a773ab74553f089882f469cad25759b78213a19218040c15168679c3a0be551080c8dc2c9ea39c10c6c9e3321ee7f9f7db684f0a8dd54eae8389912e3722932248ac1a231d47eb10acd57b6c3707a6a99a9d16fab19854d0b612bb3ecd6351e80e8636b3cc858dc5e7c5e820186c5e2654dc865db54499d8a56350dd1489d8f90885f947ddef4bd3358b196ac00227ab3545d6ea26aee4f3ee9108a47a0ebd080e439d4e3e3f9f05c0646068f511c5f4aabf7d994c04f9c662bb4e004b12e55cc1a5517bc26410088775a4a61fdec75a9675187e41cdec12a7cc6215ac665e8d13449551fa7198effc3b94c74827bb5bb5e7826638fa51f332d23701e4f25ceb7af9005570ecf111644edb8500284333d6e40a05efe33cf22d39df0ce5aa4fd359668620b429741a68c9f9e31ebb34be9589f38043a9f847ae6999f99180f85d23e208771621d4b744dec3806da6e33cae7dec4e1934eb5199ea83198d8754c37710d51171e43c1aac45cbb261a35523d3dddad7784291a2ee4ce734433254b133bd08a71c3f9e3e3a7d3c07cf1b9b8a3b953e9686ee12355162876797a55780e822e615a7cdb50bd86034542a36970e6153e7d7f1a9cee3d33e2929ca5ee891d554bcdc6b85fbff72b742df96c1361b8aca62d7360c1e17f239c29165f958ce6526bc2b14dc2632774e164c61d9bbe54b303188ab1f2c17792a215218461605f3762f855adf40473dc93a688c0407d68aa6cae52224cfa09b05610dd5c63d97254b7d2e43a36c5a0a5538fbf2350879fa14fefbd075f5cfffaf02e615ebc77bb2b2ab3f6293ec9191e0d4005e7ccf212b74e738240d95bbee2653e62dd62cb6ae8e5c9176b6a4b6ae4487d7f0eeb501990bae0ed421e4ff10b7bc4f8e01bbbf155fe49d61335ab3d77371e43610c895e834efc52614ad16ae345d963f5f9d5ea0b742b91f8d9dc464f7358c7eb13fadd071bf0a7c00b40a35577dec27894101a767d3da051ec6f62b6fb922f50e756b797c3cf8a4f1bc515173be9b10f3016fa616c41586f48982b8b99e830c909721079251b3f6753a9aa44cda42a4455a0b8afde343aff1878a193d78ce6747e9df3277a615de02d697610ea3a56d3361c6c743453187ed87e488712c4e7088554847d0b151777f523fd5eb05f7db6fe20bdc564394b693be67d8159454bdc3de7e7566a2fc97c7853b0c6fa644c3b33eed0639fc28fe70f0a1e6442260baa0ad565428904bbf405dab8d5a03f93770826bf1502831061b158edf171628c21eeb6860dcce39353ffc49d968fd655c4eae1c698d598c7cc13eef28638680accb731e7e7139cd7ab85fad5fbd9ee1f0d2f1ce34a823aa4c75cd46b2e6d3457e8ca7b80c447594b92962882e2ca39f6e719b4a70389e9abbc4e23d21b3593898caf559fa6bfe18edcd64b0ddc2a701ca46b8e564abe5f289bb8861fe7f82e7a0f8c8ee10059bd6cfc6a9d6397adde64e63ca7e81ae4ac68353c78231f94e6785b944d0ef0c0cae261eeb7c726fab87635bb7f5eedac04b097949b1acebfeef924ad62f9717c1771837150f364a4554c7c5027328eb0df56e8f03c632f9f11128969138aec730fd80312df48c3f33994cd1e7589cc67055da8c96f2cf6c5362e5bb6bc3c123205b2faf5bfa419c161d8e8120851e07c7c0649ec6d48e25aeea3d8295fdb270231c0a7656e8d66932dcc27b1dca68b8080f6fca8e7960ef650e2a8d8aef6d718e740496f2d5bc0d70146ba99c0c24874ada8d42da5a6cf3654d137f60cf8cbc0d1d98af50f48595ab0622a8dc8bcae03c601b2953d5fa8064d132d20de4757f0a1a887e4d9beb2e21b6f7271f97d52146f9bb7c777b287680bfc11614c00f5a171a81bd814330a6508e74294707ba5c8c6f0add7499a1042d9e851b65232e08e2b0ddd98a1240173e3f8b69d53bd018a2f30fd519e8a929b2ffa6b6292e8915b1564404e346656fcf4cac893f6ab77f9453194d7f71eafd6daae3cdb77b1890233986f9df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
