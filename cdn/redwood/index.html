<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9954e598ef2a08c952552f52a35d6b9501c06deb5189f160736db109c43ef862552b98d86057dc0ae7f8c1585ee8b8032f2b35e062018a9379fbcffa90e9d20f4e9a898da3afdd2182daa949023f07ea5a77312c66845bd3685f643d3d779c4cb208b3831629fa62c29621bd2d53c1a55accac9f1a05da7ea5b3309434e946d61eb7d4b7c3701108db95eaf3076c104c0695bcb9eaa2521be17fd52bd006c9e9186ecfff85768ca4d4d50ddaf172e3a5eb3ad70095aa057d1bc7297a8be149687e4e49ec39d77c9f2fae23a1904285e05a2878b1fed1ef8ef37b762a092dc4f658f0c2cf3a40b8fc140f34c892f46a7a421932b71c15b94ad7e19c4d08698ef9bf160a1c90e8181bd84e6bf12ed77633ec6f99a0426fc2b133033a02543ac737ac014c810ed343d5ff406a3182d69c578a9f29884e8f92031453388916909544fe3041abd2ec45812e566857fa896fa20b28a6b318128ed0619584fe84e9ee53cf11f15478c6863324deee102f96e1be324bd304cf53b55af10e4ddb617e016c8a4456a5ac6ce1d33e3a0596078d8ece2500e5b3c62081c12bdae713094a44a72694a2452cab2f91c5531b330fb46fafa4482b920ff3753f913a4570bae6fa23728410adcba609e9d681839d64522edba554c5b2ae8b4dd0798a32b2a6c4fa734600a24d70a90c2edef94e4ab6d945e4b1cf1aa85a985ef751183a6ba012a2d5b5b54010dbe4a5aaf2a87470d349db139363e049dd7bdbb480ef90d3906983a104ae1a72396a117a25d2819fa449b1c1ee51ba79ab68c0ed8e789ae444af10dac0dd697f85fe641848d45b9147f6a268906cdd51e00d2c7325565c576b796a89fa0af1f8eaa1bf8fc0c694559c66a6d48c5a6f3bcd787dd3fe03c40881b121ab3f1e6da446c61b1467bb349cb5678931021c57ad11e36fe5a6ee1aeaa09f3464f341bf2ff9bdfba43f650251127175bb24950bba1215d1a6c6bbadfa2943898115a540cd9697e98bdd248573d84965cff702ce687604bffc9637b779dc8ad6200a51cbd25213f30e18e120d221e81b7b0ec4260ae0e1604c2a1840b31596af3fb43f44741c88bac271abceff8a357d64fe7fc26e556ac144f49249fb44fe6487ea1ca2e9b49262a5200394298507bbdebcf8705c59c6fcd7bb85d303f55c598ba9832cc04a41e9e8c656fa08136169b0f85667552aae2a85b3a45f25e72903aa61708a7488b20b07eb24e19086ecd61f82cd361784b4bc6fe18d896a3be6cdae3947e7e61108901c19a6d54b07be4ce834cee62345b64835082e18a8107d1f197aaf8228d133138beb9f6b5691cf1e2eaa64eabf53ce77ee2ebe23c0a1ed3fde85d7648362a9ea35e2c1e5c543537706bc0429b9be3298702e30d399e4d77efaad765855d434b0204ba2d64f3b6cfb1e82b6fe2ad7c7d512834665d091ead44a73a344edb8c5e87fefb707f23f97f6178421ec8238b2e01a335e2eb3c224ec6f7422ddf1d9930e8f83b7ec03c37b2b2c731c6a2228d28cce1740bb9892a5de0954c8cdbeedc36c9a804030031ec0841c303fe82a833071d52f105297dfdb7306b00332c17a229943412eb304e5c4830351fabd05ff395fada3161650b502aed0bc49541c2fb7a11f41d6e7f8db90d18ee6218318eb146e3b6da37fec8055d68adc9c2be2341bd163c00aac02772d1ca73ca79bab12a29af91eb4422d53a73fc9b9907e1f409559cb11dc0ff6fafaecccc278e8c05d432deb822d67c5478a1f02dfaac96bca9a5aa9390d5ff2a653f60de44678775bf2400da8d6a86ee417381716fd364c35057640f25f69fae46a17c4d2d7f4c5aadd5c5fc218c4e6f9291470044df3cb461257d0de46b1c3eb4b491657f41ddab7053978e2e3fc5ae7e0cba9c7f411bdb50f90ec719aacfa0c7037424e33c91e1e1bd4c398ab3058db070b06eead75ad3325e03c68229d96f8c64d0079c416af9bdcbbc840c73b19555c619fdfe82efd49560047fbdea26383a87fd5af8e41dca0a894bf18247a8d3b21dacefeb5bc5db6522ccf835d77e6cf63a30974dbd20a405be858470847575a3569d96b9385eb049e29ff606757891cff9902730140203ecc52749ca707efb187d04626f69fb0b53ffcc646f5633dc535940bf2bb91e23ed7f426f1b0fbe23ffdcf306c7b4be92c6840efb539bcfc91d22eb4b92c6a67c063c93e98341c2e43c141dc3683adb2e551904dd668a8dc6f250ff493f0688b052b5b7d1ef6406476b6c4b16bb513331d57b4abf14854abe32fdbbe038a87477ee422230aaf61dc93571a8cc31dee6159648f496b51f7ad8b6f607a68f637c72f5976c6f523288438774ca50f911f00ae6f9f06685ce62d6724eb859bbc28b87d40bd405d69890287843faed96a4eec448c66fe57566e417773fd15f0fc44ab8c00cfcd32555f7bc98f811cfeaba60ad387cb7c51d787cb99fb51f5a1c2748cffa73f0a469302108db032df2496e1c4f4e0dadbd0dcdc4c7f7fd4580f3f9d12b8a465e5680a058463fe16f4d7eb60d7bf965768093e824b949912a0a0e79b0363a6ea8485010346cca73a771e209e536483a80b9ae5c11b64b6947a25cc7169f9438181c1959a56f6f77f47b57007b61504381fefae12975258d44e9417009641c9b2314a6dc5394cc9fcbd9146f12e5d462999aa53b1128785812d83d0063e1d0236ef3d918e2b09efe764bbcc2aaba0926e7c059b9f5bc14ac1e37f54ff434e096d1b46842e808bb11261f4736ca727b531738289612c32f8f3e7a84b9af82f1665f3e92b1bb0743bc03efc7ee5e77f15f580873a9fd1f1b601ff0953854a75404c37980ef7297cadebfb49c32f52cf5a2fac266e3b730561e7bebcc5dff070728105b767c7e5179be0032e9d0baedd0db2f57f58b38ab28aaf0db10d1de2458c65543fb28bb5744ef2c8454801a0413fa18110a8cf07a8ef0ff87843920aa75cb36e5219947c2a539b250241ace8628e6bdc28d3f199a6fad309c6f54cc91d3380c465b0588b3a206e3ecc7372308226f4dbd9b174fe1ed550e83d1e04fd84d2518dfe660657e621962b161c121d4764ed9c4325a241bbc8787317f5dadffa60a5980346b840e5b896918e4eaf25b8636c5565a36d129bb5d36a029778a9793cb74055290f43a719f05e5bf58b45b5fb71e5b050fa38d4470d9653b9d09d5e224e041526c82a88c7ebc62fe176c21218baf1d1e98c2af52b155a620a4b296c46d5e4d427179d417fe2a1a6907c2faa0d7bf9c2537e1e316acdb4b2e249961b96daa7fc76cd8e16609e579d70f0d0666a72a5255d17a695e6b34bf226e4ee334f8d23fae7dd2285e1c8c9ab6a66bf7727a6fa2358d142adcd346e1b6f2274130e01772245467ac80571a5485d411a8f56ac1ed65974b90b2626d361fa05f7cde8c007711e515b7c5d326cc0465cadaedad0c138bc298237377b700e4ba7035d2b979e5654c3f8b8087544fd8cf0ddccb8ebd5bf4fddc7284b9a11a3cb01cf7ae838e1d5962c4be869cb46aa54819e4844132b3cde11236a0df59fecf5af6bba33c5e20faa3b33b4f2d3f01801b154aa067dfe7e8126e6f317bd4cc733db2bc32f6e3c982713470ed8b0890930d0aeebb6a8d9b9d6054fe19d8f940886c718f3596f0a91f405a7569c31f777182bf06afeb713239de99bf83a837a498ff7bfcd9955516f7ccecbd7714c7e91634870badce616610923f0041a75f7f9259c697749f7bad0092619b0ef633754ae30c55bc5735c0c26a2e325d6d1ecfc764618c92732b4c0b903909ec72af3acde37807ef94ed4eed8e05cebead2010d29607a3dc4dfb12108112f07d860a1538d199df895ebfa816448d84a3895356e9dbc37c5c9aed9f9d456a321a09bebaca1868f9dfc0e0396bb1623426699bc7836329a1e87b9e8b2e2f66098daff89690d5a9a4cc7e48b22cbb125d4c615a44688d8d3bbadc9b00cf33d7b0ca542d3b1db8de8fd8892783bd709869371bcc3700e3da15b82e89695b43296b6e1022550441174cbf8354eb6272e41ae8a097124ed655da468a9c50dcd81d80f33ef81b01fe450ec0e223855b3027fe321089e82a549c33f4e2a4f26b1a79035b124cf3c2594ee592c843590b21b372e6da5be656ffb344c4618b10521c4f211f69b3e1ed45459d8b297c77e23fe8660fea2bf69d8a822a5b0a5d491fa6bbcfcd954f551d57ca06d7a4bc042e82eefbe305a8da28e66f4afdb1253458e8679cdb32aac31e53c0adcb1df7dafc245828693516a0a1d42e7a66ce1e24496490ff230bc64f8c1c11832fc77645b8f813f9d42529716d1c87b74c2ed2f629b0f67a2eee64e5167f6d04ede0096e52bdee6615ffb586b61483aee305dd1ac2f6fdfa119ca08bbde1a2c26b675a57f8babc17ad638ba211a6de682e42c92a88c619f6ba913a1b72eb8d13a321868510865b6ec1eb9abb6d9fd610c6b737fc9a711e631c827aec0e239e868b54ecdd82d0136b23e11edd4cd6599c604607043eb6610aded9f65c0a02f114319391b3cb6d4a65f8f39d67e450417b2fedf31d54055e5061744fc32d393cde9927389bf9986cd4e09980813629244f4bfc475997dcf3a46b4e2f32be71e57d3cdf046c0315f388a9bbcadecad61bd720d0877ee5ab7715437357b914c4ad73e14839124d858b2eab56072da0de805d4616356d693214f8759c7e31b3213aa8bbc3a81888f978e52745e2d63981e3ca6df378440cd73e5f34c74f3dbb98ebf16ffe575c0401a91bf06e4513c53af09710ad023c9bf2cee13b2fcf1faead56f054713c75b9449c8ecb3f18e7d3173b21a47df19fee0dfa624517485434a22f8980fbfe51f42b60826ebb4f678bd1fd324324f94e52c2109392a88424539dbe5a7914d9ffd337d9ba56263c035d2477f014db1ace3b3e08ad795cc31819d94fb200ca4c51b951cc7d991000b9f9bea70ebd33f01ac372e1f5be39af868eef74bb69ffd4a00a26f5ba6b5f4bc8b9953f6490d0cf32546b1488931eda2d4c021a543a39145480d0a8d738247478248025cb94ce4740a733fe6d06e53ad5007f94f2ec5cfbd9f5651cbca2d909e2c985e2d34c268e98acc7c82f7a2d02cacfdca0adeaba8b493f0947f95e61bfd63264e358c44afe0cb632277a008324c0ef063f2fd9d9364801a3ca3af275e5a59e8f06602c7a2362cd7eb13a8b180515b1d1d0fa41c5431f787469ec1fc54b7dc48cca6cb6151d0b24e1d729a699cfa39a38a466d598675fbb9a942e498c2af75d20aee52fef70f7978482afdf9a33dcd1f6e4a79252e45cdef610cdfdf4c798ddb9649ebc6c724dc2c64f9b6d5ad196b74d0a16649244079e1c74fc0265468c7c9d9eff5b1f4cad9c742fd38296c755b142b9ce0e3f52de2326e6b474d020cdd0b053504cff106f50aefd87e6df8b36d8e0e2b3ae6239384904c2c872a19c462038a1a140ed671403b9bdc9cb21eb93ee20ec35308d0b4a7972008b0213fe012d24a211cc3bc60fd6c1a4c7a68bd36da217c155ea407456814e84474d4df968a43ad54c1d2401f6a164711e45d437213048f1bba9bbf098cde7363635cdc81c02cdb7a1044fa40b189801dbe04667344b9ef57c3fa8964b53bc022c650f21f6f2bfb1c05dfae7b8dcb4714e8c85b857c32fc7c1a1e441503dc39f8517d7f5e1991b1597935007167ae12eeb34d255d0c98a6e330bcfd8fbd9a0dc0e0f0fd2c08026d5ba0e3ca1aaa08c17d8d0dcba25fedd3fb8767a6f05c08321cea39c69aedfa9ff80cba9ec6c26992f283bc19fbfac97936d4d0f7560d3de39fb04fba517b7724765b411ca981cc582496b1ac1771dd639af309a57222b8951697a55a19fff508d540bfe8f4cb8f33d42ebe142413c2de91802b1d4394055cbd680a8128573463fca15f17ca863e6bcb6cc8f1f1e4383c4db19d4eb6e88907ec9bc710b8ec1f9daa5aba690437f22daf79c5f9227d9bb4c05261cd807ec23964e0c04b15dda141ca0d22fe60baba9d2724edc1c313a0d638436317ae93c3beb4df5b8e9afae32d68a7d33d189e0af11032d029d983f66ed1413fafe3fc35057ef52af1f8205a3721edc5f659966b90404317ed59755672d1b9fa6b2c96e750b65aec00820589dc3effcbbb2fb6869a0a613bb07b93685b643c8132c3fc9daa5d6673ef3949b97c49e991c62b8525b2ec367c6672cc3f814e281b2e5e7cba1167eb1433e13f26d5059d5ed4485cf0cce3db928a606c556c185b4ec636f0122b5bb94ac7de3aa68d8aeee798ee9399f84ddebe7d012b0c4357071b201a553f5a18a1161f7578e80bc511f17008f8672c9693cc4c61f60ed89941c08be2e27ea997ffb22f57ca8bec33283356e65884ede946d80a5331ee65ac9de5ca43eb47478f331a33294c9b67c0b99a4ba879c7a97139a56dda7bf669eadf868158a6c828d5d5ad605a9c066a6f665ec02e03be7afd62f948c03630aee42ac4527da04ab7ebcbb6d243140bbe31e35ea1a6263b08878ac8e538ea71318c3c832b53cf9f7fd9c7c39239b85a65c0e54ab61c70f5f40276407d7c085dc4867a2f68686025a36251f779e38e99745c52fdeadc56febf5e92de26c59193f1b774c5a4d3a8441d88dff92e4cf900b6eabaade2348b6e6b20e7afe571520d30839c49ad9c2fde67a163ab5ad9f9f4c77568847582dc01820a78a8d552cfd0d6f65b96eee0041827ec29ac11247a0eb50256d143136da76f317bb1f8c60ba6ffb09aa782811f55ef437076c11d1a228d8e61aa3f0c45ccb7882f89dfb8ea3d8ab1823d8230678319930017c7225331911d4c5d4c7b647832f67bc764438b42db8c4351f0914d1ee0f211f8de70d60627c60bbf2e99eadb587b2846abceb367bf2ec914a04c218f93b81d69fe4031d6bf7a395463e3f68e4c68eb388fc726daa06cf4abe6b0787dc8cd85794bdc82fab783170efd5a95eb8322c0abdb3cb5d744200116915bd96373f62b098c94b0621e75ab3f17f7248dc0e3e66b4f3097fbcdfe2f25492b9bf6da58275e0e802fc5b7ca78568cbf6615de838b62b702dd0d35460d8ae955a07ddc8b622117648e5675cda48a4e544922b601853b5942c2fddf721f91ee80abf873cf34368c4b9fa846939beee13c8fb83335d6e803b57a0a3af23744dd7b2660368706a60d8144c24e643c0c8fd78c370b586ab93d94e067b3ca02572afccdce7a34b64528025d3945f0ef45dd2a956e7f6c034e1410b1961b30f8effa5382ca2d95076b197c33375dc54b703a5933cad220ed7c50f9670d3c3aacf7fe691fe28d0958fba16e3a780dfcbe1435de3e97b0e20630ee7e28e25eb7c96eb6728b81643a7efd817f011c568a061b84589a7dca2f5ebb1e8ff4e7cc8fdce51981e856e8709cd7b93e78390dfe8185caedf65608dfda5c62a1d8c0d236e04c085783d87f7a739fcfac6d95fc63b3e3752b6fca3d2cd0c76f3b4c1df14c9077bb7d82a4091bf95f07386450b7434635aceada00bb690d523ffeb1b4628c864a72e6333df485bd5d5ffd3c1ed36e23bb0e0e084041f25f6e2dbfa45b119bb683883689e44b29d5dbbec59b8266f9a552a6920291501b226913fb3cf8d3e477f4eb3907c6193598d5ed908fb2e3f84672ffff4a66e7a0f0687c7d20d8837c181a5ec041b4d88f1d2c4db31e0b05bb110a89a20483b6a9f8f6e839c8bef5d59da55cdb5349dc6e000a8fdf7205e5537dc76830c4c6e9c40dea62611c6d59771457d231e21e2252179f08ec85f4c44392b735ab5726a7b46599a5d4e115bea2bc9091a2497396c36c91097792d7d5e945d0cbfa5e88a7675d5380d5ebd37a9d7bd8de6d350ce784572fb6c24a37eb5db789ad5b98395becc8e33155debca4cbcf6d86ff9f5ccc325262435a5df9d00c97fc1997fec4ea525af21f3445987663dd3660faf91cab4c1d63cf77ace47003a071ebdeb36aa93e9110440341492ed2c352704965de24fae891054d910b1517a0bc9562eb5194accac27e34a2cfd709e98a0ab35bc6652d73cde3051567c0f6c957fe58906d0b55fe6fd778a963c68d7038aadacbca8e1c66cdd3c7d5ac751c53810659a12198d6e460a0dd54898403deec1cdc848a6e6032ab34ead0c1cf7c802b581f636fccf98c5e42a1713b40944642feda5ec9e6d907697dc78992ca6c9eefa69fa98247969798a34ebb2fc8fff7c5f086fe6a4c789cc1d9a5587e4819c1d6de7a60744c6d06a6478499bd27de3cbd5915caee8a69a48499ecaf0cf142dd8cf82cfb1c996213ae8ad818188cf1ad0798daa674f67b9f74a52ca9e19b76ed009ef145117fb7c1b3f2c2666dadf36096a3502c41129c1b930141c2381ad77c136d0835c5cc993efd4a07ab97c321301506e2b2810339533a885b9818edd83d777fc94b16dfa5c66715d73ceeca7b02a59ce7eb7ac982b6fead0fc55934604ec9cdfe19e335d33f5577482a0c5574a5719a837617f06e0c4801a6d94307a793e0b166649a397ca04c99074fbc1e7c8a133b1de62c21a8afd842d82d7b0746b6ac4c01dc4dcd0c11174f934368492f4db8ddabcb576e3c96bec5873a81d12c878d82f2c9641ac8df739b3dbf2d3dbbd9f1abc07031518adb871904a93f1ef46c7a601aa8c1e27af91ced950fa29621ef2e5ac578e15c1e43e611afc677aec4faf23256624c13ab778fa4656dcd87dbb3700dd198f54b1458046785dbf4e9fe758543ed44b2910668c5f22836f1e571b11ba1c41dc574caea3121bb42afe23f513286d69af871c4e00db6256e27a1008ab69a91733466f977470e04ea4fe77b337030a72bd4aacb238f638cf91cdea4aac3d84ce50497d853fd010c9864d3e9c474ad503930de035fce4c5379026d664a7568dde4a08766591aa46f4481d8f76a123f00c1319e54bf649dfb4ad2c98336ea66bc8baaf5fa733910a495a13cfd05a51bc25fd6b5e3947d1aa919bcd7b4e3d9982e19a1d8b29d97757908d2ea6472d2ccc990d60ae52b08c46a1e59c14fa14509a7b561a46a4e922f83dd107eda7943c82c5908f79f231a52339b5404c43443b6e504bcb74d17a5227381f37fa5d77bdbe5209feec8bd70e171d4c10e886e939a14047ff29e4cac184ab51012bc0b10cd56d45343f697f9347333d8df5451a58b5fbd892f4becf13a02425a0dc1a121633c139315e6565c497ea0fffee54fa5e0afcfa67f0a21876fa6e56bee835093d72cf7ab1dea897ad985dbdc0f3791ad76a668045fa5e59f923054daff7e1ed07a377567b95471acebdf3473463292bb4366a21c9bf491ee42c9385bd8a726f46d4635c0085d03e11630ec7fb0c42008a14e1e5b0eece1378ebc64c1dbf61a553dbf84c46069fe798359ac8b5932732a712ac69d1699236bf285a9058fb26cf47b80483c6ee14cae7b4f4c4cf3e85a25f7780c0c1076f0a575ce67586f101c4f9b9cf74f61ac1d06f4fc5197501143064b88f9825ae4199533f2d86145f0b9146970a6cdd93bc23333b249e52dbd3a7c30e625a6614cfec20122a12d30efbf0a1fe1b435affb7aa01439cb193a5cb67c62097360a884afc0adbe4c702b230519fbc5eafd57a99bed9b4a1e4950274d203a8fd622f1d78e282f4d98a098c46e72d6127234e6640bbd968c476d2965e8e8f4719482769841aa5db1dfa4c2b3e77dac132afc9e4e5e19129f4a4d975e1db8994d5000552531c94fed488092cf2739d29213d4ed7d2992b4dcbdda37c4b7030c4e224be46f0102ad605a455bba981c9c2bc27a994b54e8cf138b580fd128fb76cc32e00774ff5de67871190b9ab34497b5c048841f2e83ad9d11170d38a0fa3fcf5994a278e31e3d612d8bd443fc873e49e1244a80d4664e0ed0461869b722e355d70040e721c76b9cd685c5cd2bb8c0a6d6fe7653207cb6c3893d451145194ffb7b00639193ee842143a1e9036ff4ff77667587078e7fd30f7048999697f0dd1b3e0e3fb2157533f2df67215cb0330ef2b329777d5d4b2565d838b49872a157b96c7373247b061dadc14729650da08daf62739eb0e08837abb2464707c8bb61790b21012ce0123a096fc5b8f798afc258706be101ddc1b325d21a3668619003aad176473b43468eb603b62ea37b55c95f0470d5348e979eecb01ff19bcba822a327de0e2e64a569ed9e247c96f691b4fdb6b91c52a8b26f0c9bf0b173d86f43c439cc510a36fbba1cb98fbccedf3d309514da312add81ec32ed938b53b8cdf0e299fc955463b0801b19778bc390a79437e53dab7ace2442f0d4045d03f2a629bb85d2f1d62e5b82c454595b0e06a3e3f7a8efe6eb75afbbdac172299616cf8c0b5de4817485c7b0b9850579281a8b12c9b841d1b7f408b6a2c02b09ce7eae8716ad1bf5000f6817271183d62265a94745d533e5725693835d5aed831cabf01838e3705282afcbea71b0cb849b9f9b89971c4b239bac4b34e842dd80cfc94def2fbf7516e594404b1d2f237f8c83c80a89dff30887cc79d8a0b7e7e59124d36a4246f479e561cdc42deb10d2bb8918ebe295231e730af62b3ab1e124f4caa21f859d66147a0e6142e4675658774d9bb027418e0fc1be0bc6252515f4e0b7e1dbc930000f79ff446f6c2db1d11d76bb8b4920538887abf4fd068d1df2030f54be4649880ef444fe4ea1c61858b278a79a5f6d14f0a76be134186c873e656e0680b35171a3e5d9fb6eed3a0b3dc4eb551550295460c2dcd2addb167c304e582f42ad64c27524bd9e1de335d554d661e2adf9e6311c3438f793992d5424a3909e1e7f0a9c5e0a71b9925275560dff8928d18eaf00d072f4f4d0f748ece3831f25fb165a67571393988701e1497bfb6654cf507735eba0c86957f03a11744ff2772842f1131bf842b6fb2526e21cdd2e9bea1e1ce4e19be3a752c616d9cd6df06c13d8e00d4356452564412a711c3329474e5edf86e1c01e4fcb4e7ab4b4967a26f84126ac50a29919007d6f7081865e1fb8c23466f94384e48fce5caff2194f12ab3780e9faf9e7f376888425c7fe7a140f188353aed90c90833aeec8ba6b5a5583427507c92a9aecd92194b4de50b3530031337349a0ad738c963f876e36d6876cce5b698ddb8c735fff36dac3be661b4c2c63b97f176e237ec6cf052ca005d8d202c57fe00feaa0b7a4a511abc5ba746b2c19278aa36ff10208b7636c06fe55b66088f86e37d21433e596815b2e2bcd2ac004a06f2591711b6f6092b0f8d723c31a66490b9ca412286a2a48945682e147ea82b7cc3c69da561601ff25076293bc6933cd6c0c720b5766ab26b9656cbeab06baf1e5710c319f060ac0bdf5e02f1464574a60ee370693dd2e42e1c97f1c7c6757d88af31ffdcc1b85cd1c46e7016d2f2c1aba86a63225556f77f7740922b32dcdab7f2a08656ff20f2e0cba505e38c50734d82157fc8e5df7b56de67af2c037b3cd355bfd636a13bd7534b241cacbe24c6abe13674ef0853ea303dc9177d628e6b48ba97f9d2cc4ecbcf41ef56001e6afd7d1738e1ac178d1c39bda8ab5837eea236ddd937b365f15abf2945e638a86e88a6919ba6f401cc3394e69e5f2e34921ec18d0b10276fda5ed2e9c1548fa518059c8e1404b8225f6bfc785d41976428ef52de62b500322d3f3cfab1258c41f6d965f000fa60f2a599c93cb54e72fb80f2b8b5fc7285d2b83bac062d7eb9784815ec49b9b9cd43c811e01d8ebde71cb484726360ff48feb8ef7e3ee4ba0fb85ee261e8e1849f41f3eae6dff811893c464f9fb728a583a7985c112d2defdbcab590317369179caaeb9b783097a46b9450f7f9971a27051efbd9b95ae58b9d9ae37c64c37713441a5b45043cea52f60b931d2eaf60d7c2b3f0e4e84907b535145b2e1d9bc18c821a0651583322785af9e118115fa91ec00f5d07f1ba43dba6568265e7410bd88d498d43be9b7ac20ab75f056a4999ec1abe5bea27e3e0f7d09fcc0a1075c7f891e5067d71ccd910db2dc39e502bf0553e07b6d62a4c676fdb4a69fae0692b7bf4eac2e3a6a2f51ceb3349cb89556ac486a4aa860d2ef2c5c6cbe61446972de076160299792a667aac531e124f09931e89fbde56c65c2fa8decb56893f8e259cd2416c1e16b07797ceaf9f269cbb1ddc6b247d03d40c8a80bf0fc95969dd6e6688e78b840ac4615220598bd503b7a2b5a2b16ad65aad12263759e15a8260f436dd02fb88d38679b688928c7cc18842b1f0f59539c51aa456b9554c55c8416baa568976bf8b47657a8162400c351ab177fba16db410dde90936b52530c4dbe0fb43c748b8818398cb05d3e06969341a526c9600a9a3bdcd34254f75a2e6d0e4ea8a0fca560a91a442e6fe002d2b7d9575bee3902e66772ef96e2f07c96788622e484e2884fa929836cfa1168ad6b45ed07a8a4e69717fd6028ded678b1d90c8e774e98bfc31bee81da190d7203d705e9b313b6f20d35fdd20fecca027c1e4b02ce69925b4a177693ea2f34322cf987c88847cfdf1a5ec7aad3236ed68eb32e04d1b422f56f68647f52d6ed26f73d9e6c102b74fec52e639d927ae354c46dadb70a4020dd663f4446a042d6eb87131916454f2c29d7ef07c786f2dce6e294cd22ab18993cf1856827a7066e5f89f72743fb86075671d2cc2fff4c998a1844c97c3060a5a26c65637c2d2c6ba6aa398b044e36c64ef65230f2881b00664c1ce803fb708df38a76272f81a4e1aac13c8df1fce10362acd7ec5d48f71a47ac6e06faa877d80e804298317c20a2cc5e01df749c854091331e88957163ab896ce7ba7cbdd8e0ff502e5a3d012c079d53ad64a8c14dd422df67b5df0da0b92d6febe830381cec1f96626463aa483c94c715191958560302be1d53217681afafad94371bf1c0cc2d60afc665986ae442700c048839230d97bcd1aa81500fb7393560e6a3ed1ca9f591b3b43dcb79ecc1284a2bfc67f6aefe80b786d260aadbae9de3112bf4d1a6897083ea0d0762d28d53d7088ce420c01389ad027f56322b891a6595299836c6882316a3bd1a02327b5c6b7a431d069a099939cff9ead1bd1229e1ae0d2c6487321efff0ccc80e5c87fbf9a19d5561d323b25670dd9541e7769355ff00fcbffec0e9c8899d115e25c65359ef87c63c047696e9a00e546ab53c8aeef27d291c67f4a1d6f74f379957d321d7e0fca7b7b470451da2c71695eb08a267f6bfd8d4f3dcf1947af6b9dbd8ab1aeeedfb193cb5531556b204947774846341d8a7e8076421d79476a9abc09ce56da2eda0552c1dd428217ae40cba68bd977698e586f2124c8fbc9517287f555cd78783587363ea82a9aa90dcd171a76a341c40c05723015cf2c46762ca1a4bc272af181cd6a299178af55bd3b94b82e730e4cfe754b1001400665f7df1e75d97a60397033120e885ffb27778bece0af20c7856195acad32690bceb865d3fcfac03af33d57b019fe1197f5e26797c0ac9d75a3bc605099c158c704f179ffc365d748935bcfaee6984067edcfd0f64e5d9fa488543311e17c42419401b67f37697acd5bfdce36d86c45580244705f9ad7ab6cae2890f3c6bbbeda9babb7fff564812ac1ca01660db934fbc71f3408e33f65ad2cf9d011c93e0f6278365f7544a4eea939e03fd20400569294c1de04ddcb08a56f0675fb0c61b65280738f7650b677d6230ea9081339255807d6e994a170827f446c152aa47e5ae2b7187b4c4b9f7ba4ad3be82ad840f8408d633c37e6c6d8d855812c7c4b7c00c6e0d2f6f03063a918c4a50a090da558ae86886365e25e545936bc85b5978a95e47c6e4ae451ed5560a823df5ab1cd619df66a5d83bc53e11d52b87b0f61c0200b64d2938dbf3b294fb72b6e8a19b855d71f5db717e72518a0c005c36c711e98a13a897c61d0e540aace0225a1358f133dab8f2284c5cbb81b5e79bd8b8f50f3621c745cdaa1ff5f50a1db31a4b268fc072efcf88bf88c07e803ec457f9a4ad5d0de04fa9cd7c5239aa06179c7c6de977e9c878515aaf755baf933fc176e7b8aa18e3808ea52f99dc31bec389b27e33abb62e6f66930395d3032b8d2de265db9dff89701bcd114a3c454d3036f11c328ec86eac719f25030345e20cbc1231245956cd169ec488fc67ebdc78d75b161f2f162c0b5ff337f35a7c1b2f569ab6319c22d1e524bcebea1b5eaa7bf3d76a6109bb712a561b9904919d2c70fff0eb0508391ffadec8c77efe98e9e5d5379f204bdeec7694815542bd09c7a1994c183f115bdc573fc982f41a9bf1f95b4aecb47a05e33cf2d429a11368df4ae72715d8c1d36a6477033f3e54f6030d0ce6c42fae786e9953123d9f01ffad4be96a5d0240bf38f705c96af08661ff009868d69fa53c55eee3ad3efdccbf4fc468a2a4b29ba547d3c78f576ada02bbbd5a55ad9d201746013eea6c46262e44f369e33cc4096a3d9c7408c91215b422b3473ed29113c3d89f737dbe3a286f467db864ee1650f98fa20ac3dfb1673d9172a8738e3fe5d705c8ccee3a538c103908286cf183da2133970e9040d11efaef33a30df9c8821c7f7759f8168a645656ca3841563d1145ad44d744a7ed81397c64717aad42e3ce14d9af94b4ca20db6220b61f96c0aa141c4c6e0c0476967b3ddfc8f4e852dbf00265fff15e202a54538a455d282d5952c7ac297b0085fa6501a797dd212485e0831a6be7a838bb4f4bede7b54a1b1bea1e47735c40b7b20c3a440613fde136030e0cd83855f48ef15b49284d98512e418a44544b04900e83815bf0f79b7b716ffbb5f675a3582be27d94cbbd35a6e58bb8ed333270c021aacba3d5aec0977ad4982f0e024210d651b61c3ce7f9bf019cb48fb4b767504d71678f811a65a315c70143953533e5326129ce79196d59f441e3cf4738d445880bc28b530ef5f485a2c8c7f25a0422b80f32e283501c0042d7cbe2b5d5988bcb848d4b00d4cf8d776a18cf6719a96c1036adae16a6dcd0e4ce83b4be67dd76e9d9c8cb42540c01317c9e02579ed74b8102912e3580797cd5fd54a6793f886fd358df9353d000e07b9d2a64311ceaa1e92c1444df4fe01b8a0c4c880021a0e696b6bbe79a65e9e5c101a9d07adf29992ffa9ee13f3bd30e097e3de2134f1cb72e62d1eed0c64a28bfb067e3cabbb857a8d07cc2fdc06acf88f444f960256eb08b0a2b92213e2b6544849c2cf743dcacecce35a687aed30fb69f16cd9ee7bef640624dd079be7d929d6d2b128320e62fcc089c64cbda1d73100cc14066d210e75a84f51ec9d431236e6a234d9d0dfb89caee4af189c82531fe87d323c22e18a5e67a4c01611b9f19a98adb654c95e1f6631b95c7d9c5db8c878e148f22197c0d2b4a8a14dfd7dcf9548435e930516a210a1782f1749925c2546f2982214823096bafd8e80242b74195cacdf94102aa6e4fe8999cb48049b6e4ade79e539841ddf2b01a6a31edccdc72103bbb9359bdbfdad94c726f07d04c6405bf6a3f100f4095d9c5a98c7346a914548a2e8b77506089306fff415009c8ec734d9c1f60d99614d7153de1cea20c09fb3e0fe494a70c73a13b1633e4c8a20ac54266a4462c5f5f96e603b877b4ec5c0f0c498123ccaa592acad236bf5b1b4d56d0a76bd49ee851722c745bc39fc4b239ff8e9b8aabdd4719b1ac9d27af11a20a1ed35ad2b5d99f9ce528052d4557183da5d164707c1e8756aef5162cb450b0e12be9cff70775f54339b4113001ac22712b36202e0c8ee210b80e68fcf208c0131363d719916dfa38daff89d0f13280582b2ec19fc3198acb0214df14b248dd538bc5f5d98548527f104c514e0a22db7c42b5b7f41b5a6b5964071c2f2754b2e87b92bfad07402c4dc3da6ee5111de0f1a5926ad9f0041611c5e29126445a7468060ac746f104ebd37597faef6a9f2ca2ac6cabb7f70eb5bee0dbb4204213171f498e09861e871fdadc607f43d838f2fd994412f1a2140ed60a0bd935694c80ec11d4f0df9659aca4ea8b4891116615778c0f3c7373678a6cc17a0a2237693527fee97cc1ce211b709a407dec689f21aa8cb21910314a46fe7dbdf75bb01e19b4d02746cc7d5a7199992cccce9794b28308995551d8f4991d31e7fa09cf1f5c35d2315e683c9f186324813e210315d20319fdea2fe3cf594c24b163a8a6ad137f7035f2147df79cb840d0c5db90bc2487125d7abb2b9b7847cc592e5f51205aee664ca8fa26bf83826d847c4874dab88e0193aa8dfc441ce71c58f7356b79d0760beffaf969a784dbb098f7dfa99a0c5f97c113ff211c26e4e5b3cbb70cb43bcc400142b974ffbb537347948ea82d48682d2295a4af9de17e38df9ad3a85e5a5e1ae8fc4a4062c67ddd5d417e82b2687a733a8c913f230069a4836b2194a86bbce1250884540f5ef9bdde4c52126bc6eb679ed2d8dd37c6fd16004b3e405d01a868101bb83da99ebb2e35a5a68dd4b6fd92c7e04ad2c96820ccff09c6dacabc65c5c4128996ba9e7076d8bf402d4ff680ed7c0b45b6f02fd5d19487bcd41408c14ffef44d2f685e97841655d23cb791f92680e5332b9fdd323861d2d07bbe7d1c404ef89e4499610e43a3a28bc66e36f2d1b19176566c4115ca010a4ae6b4d6482d2eefddd7fd1c194de56bad93c07faf99f551645b2187c6a699093f45b1363eac8e36db7f7b69e50a3451290fbc2a7f54e6fe2e6e93dfde2044184bc183d19708848c108b6bd70e938e27abeff03ca64489cf645268d7f4b8466e30e5a1ddc004d96cc4820e39b03cbaa49e4a914476b0656d3f0240a4149c01dd3d73c90c670432419cd7b4ee4e1a10e3f19ae259f7de0cb31b7bba9d8a8c1ee7e768e60f0a098662d4f04a800a581751b009ca744d3afcfe97fad138a483a4d6355fcaf2eb0b922c0e8232f3d9415d9c34aa5bbbf1d0a600c76d368bde180e238e0a29aa6eeb91b6605369df8d999099db63f5b90c4f98d9144f96261c5c3a335b8f8f72787c75b19e983ce61751a18e089b8abbed7389e70df02342341cf8b4d1daff7f35c583167ca9439a2505325a6ef4d6333450ae455ad6860cb8539ad166ca1ce8aca75b022859c43640b1a446bb6290c705894236fdec2367528c15f62cba77511f5762e96be727089fc2a7f1fe4c21e111571afc258453c0192d1bf5ce383b23768aca274415e27817c88963d29a201acd0185f89cb586aa6cb4375820f3a3b2b68e145a64bd119328bd3b61f8bec3ed7754614265aa3727cfb47ae75eb3a6a833b9a0dfee9f364423a8c85e79c09e340f170de858edc6e529a41e8e781d5229781f593daf9b8483d477956d011a6a48a140c409cfff9798fe1843d275dd92669b6cb28e8518bb52534bd9b27a33e1e6d64fd41e1bc30c267689a9d4f09d10895b646ae281cb89231e69f06a0fb38957ae5ce6df32b4bf70cf95610ae884269f378638c8bac9c49dc17c3b91a6e0f4bfb7113f313951553cbd505e444d9e7c52ad57463fcbcf9a03d3de1adb0d845f44a96a98245dba2fe7c5cd5d09449f9bb73281b8f7062984f09b5af2e4f3abc8157dca26aacad7be47bba3a3a43600dda6e97ab3ce11b4d93c1750879f32614cff8b50e95492a9a15ba86260c73427c9668016211bd592de32418cce8bf4063317a261c5d20383503003b5207f42068781d45500a32beae5ac8dd449ed90c96b05fd41207f539f920e02dff56987e2432bf2d67dd4eca0e672c87d71c5d8dc58d651ce7ca70301ddaec76e63709bd16a53effbd88a2d82e3ff6f7d21094f2106959ae9cd7e5a85d47f823a509602ec5fa70dd651489b7fc0d72a46eecc9796e52aee545f2073a71cdb64b47204f299f44e0631c5f5946072a878a14ada3fec895914af6d501aecb38b5cda8453b8143f3725fc53612fa931038028fbfdfbb828453afda66e9f0f0547d0c422d165a8951398e4f7c12aed0e1f1feeebfb871452a59da4c3dec0ddebfcd778a55db5488408d97b4365fe742efb129d45187c27a5b58549e33c5aadd0b58f41407c447d14e0a76219f1804a4f3e92b222087a95","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
