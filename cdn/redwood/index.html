<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a90e5865ae24a33b27e64706429cfeea0b8b2467b7b721254ecac19e5d868c34cd4dad31ff5a34b5fedc2ba706643acbe44aeda6d9bce1683a75ffb3581c097347e77f9383b08e3727916ba4543d08b007a5635534a8ae505b2fadd2d1cc44ef3b51f4ac2657f3c6c29e7ac6efd85ec15417b97429260ce5ec485a9cac9ef0a60bef79818a28df7210d67935fef93a2d5e44ae293026693fb3c2f7506aaa6386fc777d2ab8df1fd4bd54dc9a87dc902b6f8d341e73a86bc2a5576c0d3c04d9cb234acafa60f6082d393ca38a7dfc5ae2ead28fbab85113b1f22c77d9b47c737f5cf793f1ffd86431ffa874245aad08cf4398057feb4177e820888cab5f4f212efcbdabeafa7604b18e5dd505d49108139b7bc916e22365298251919a1e13f1b151f9507cbe7b4064caf731f94d084bbd50694421e9ed4f86a8443d2d586b7430fb7252fd203533e8bd6164b3ac8ca57e596c2285fda99d71077e4d9cec6e69fa22994ef78e35c98de01dcdd5a6d69d4f175a16bbaa9b47cd3a92419a06ac602a5594af3a2adcb0a09289fccc3e482e0d7633ebc9e319e163c5e3122beff75445db4f98b5e1e0991c4dfa9fa020ef077839cc0dec4e5df4d02cd278df1a9ce642b9d0ffb95b95c62a8d79c23f27072e2d8a99710e30c9abbf5e291873e1ce9b096d8a77c4b29c926f7575155b93065347a4a085171034c7d44acf753463c085956479008176c5691dd9272f17f0b9de0132348d979abb753551266afeadeca6d05f2d09d7dc417ee9f61d3f22a011d5ec010f41c87f5b8d22ee35d630a43637e23e4e23a54b7de4084d24d7c582945bcdc51762cef92deaff9540e7ae6d5c338f5dd073583c8f020aab579f8025dfc32ece0e405ce6128acf51f5e139eb9eee588960782138573f2fa168653a096b8d5001648cb9ef54a2a006497e2230d8ded4d9ce4871d8fe302e6241d29aa820bf1cd159c3a43e02ab738b6f0468631c70be1f2cd7b4d3e41bb57afe3f0a2d4de54085f0c5fb2a39d705e3ac61292894b4270332bf34fdf74bd7919188d5960fb2eaa27a5e438409d30bc493f8f27434302e4bacd99dd1f08678d550d0fab519f5392837fb840ed1c18270eda1dbbff02ad388c4aec8b05b6c22bc9fbcd447e1cddaf6cd03b701433ec8c3e55dcd793fe837f0a8dc36759c2164aa6ef9a7a00dc11ffcc4de0a21d1e1df33cac40340e195728e56c9b435d486b2786f8d6cb426619da27ff4fb0c8c5d193bfd6bc28e1f7903d7530aa3aaf913791111e6017639c25c49252642b548df3aa370c2570b15435e63a6a08cf814804c8ca688f2db5d3dbcf99fe58654a6803807f304199d52baa6c449ad5820890bdc91d82ff1cba2c8d3c0bab321ebf712d266b79b45c92b24d3cef8b06f4248a592590ad677955ce085f741e44da86a39beac7bcd2727387e5deec2e015cb47c729bd6702e01f932503dd4265fb3795e0df2ac1df9d92a5e501411631bed52b3655b784c83391fe301bb9faa0c3c7c59b1ff326e8cdfa4cbdfa37550c9305d4ff6388ad32e9c70165e231833db66e73e2d713b3a189003c0ba569cef7ca8bb99d97ebed3be00c9d963c53497794292a6d7c2fe843b0f94fce35033ee3c9bd5541e4bacc2e5548b892a15c4f0f7bc3da2b0a6fe90f0289c4cc775b3797daab2b1741dc7c8ae41df89b0756bf7555801b65cf94ce70f04188dfb147a8fd4abefc98696ab99738584dbfede4deef08fe7a134ef3895c4e3c46236ff2e3f9c8730d434009b393638e9dbd3f41f2bceca7e2a13af423c63a58d2eb35e68ff93dfe0def97e95d0e5eeedd991820322f5b16ea92ab80642d43071e48ac23e0e452d5c01d7ba46b9d6cfaad0a545dc231e8413b5fcc462df90402fceff2a74e92a2f2d800c186b117d86e1b37fd97a0e8d812e0fede9a100a0eb8c1c69746e6bb61c3cf3345116526986f8695aeaaeb8e632b83cb95b42ad977a0dc4af8c7a290a5e749eda189b95d3269cb03033168e4c200f98cfd40d10c9c984650876e3451011b85745cd1d9bad6a6d937304d8d419767fa364a08411cae44a1c74a305c12571687be08002911b121e014eac6523b2db27d96e394220d75032f1c02b37a4e672f724f8bb290d4ed839edbc11d7927a4f2c166c6dcfdf07a3ee44cec67bae09f585617b827345950f9741599f197dee2fd499f6e2b16864b04f0fd45d2c118a160ec377000a79d4b19007b99243d05f417f32205c505aa3345fe188e9a95be333e2132dde7d9f96e2dc2586cea90aba9746683f044dc4e38fe8924d5b71c9bdde3b2779405087a3a507024761bed9d1982220aab4a1bf0faba7d67cc974913ca5d2903a5df194800a7303f4ab58c290cda61cf5ee33e5b6a36029d48151b4eff665e6fd624f2d5079bc28e94561f7d29a2efa56f45f717fba3ce635b07d1f3325c49ba8adb69c40f1568460ab7e2daf356fb2d795d29be2bfd0f1a7c1282ac057ad69f99f0192bdd6f7136d651c28b904bce2c7d31edc7ec33aab4f968fb06e63ae981c96a72aaa34d59a3d14f55b745ca4046e19821280906dcd531604887db2e6f7d30b16d8dcfb9a62079882e38c3caec37ddc7d38036b55fb136788f647240d8c28f186f945da0e137f11e0eaa5990fd0577b62b2faa322dba8f00169a88d42ebb39a3eb57cdd7fde07f6a673a6dc0c39cdfb7ab3ddb0a2df95b02f78d1b56ff0b1a4e3b33e9d455efae17d9a1235c8e14982e7228cc5ddb8c8aee2393676a218d4aac65f763ef6953b3f4700b06fb4c8660baa48848b1380e4833246f008175a4c1bd44536879c3634dce2ad324e99cda201640f49009b77da3e93a52bc5abcc0856115dcc013a5afdc9f3eb437dd2fbb2ece7ff7fbd742c38b43571960b779eb2927e541ac816a677fd1dc9e998b17a2beff50aeac310030b071465ba3abe21b808743c84f0f672f662676542c9f770bbfedb4230f3bc354770821dddc5db0d9313f278948740844f903315ac3a5f3691b2dadeec0a58e793f406036e77f333955d39e7b2dcf9edf742dedf8f11c2096112d15fafe4d75f9579076c0c3721824963ba568843aa8057e8babb8b3c5fa0f7c3cd0a194d6f78df033cb4fc4a64cd960d7729340330772c861c2ccef56a337dbe323a58ec42a5292f7de8d73e673f2c9d13510788e03788ec09503eeaf6e70bd148e9f45fba830ca67e51b7ce6f232a2dd9872a6c321a305e942043f45da4b237078ecb6e3c8480d5a2cae99c12b6e14936ac506dea2c93dc355fabb1894ccc6937c0413ab17e7ea086f7d7ae0b470744d21b9ac439cb4780217615b9608945af2f9a7689f2a1214ba77feaff3d6c526bd375ba73bb6a65c356694ddc15c5a877cee4ce5ca3acf318c0a23e77ed8582bd8a81faa8cca39a30d2591512181433898ac6ee26a81f9ae6a3ec7f6a2da825a93e6bf9db1a3a774961290049e520792529ccd69670371d1d510e7a0d9a09dc1c9322aba544e99a2037c4553c97293ea82c03e23b12b698e2ea2a335cbd31224d99d02a2d8a29074de1ed1136b27fd9bb39f6e2b5ed428da5c0a5f268649d27852b78f989f168e4a5163619274a1998a065a02c64c803a97dc7c643892a2ceb305c0f19147156788b79e4e23d15a873d94d1d22bb4de9f50a3fbce34756b2c0de1ed1d9d95a33615b8bdf4f776c612f866878db98a1a6bea84cc8e2763954bf000d3c26a5668bda41ad8d3d56de88a60980002e533f38edb79fba52d7a69f997e081b2b1e4724b1f9f1a810e788b1d5c77c3eadce2375559820d2c83d2cad035da9d0971b8c529022e2ff34074364755e2635b0ce2d75c5fc446db86af6b5ad8fc6d232c6b7f1c43e71c7ee0a87c123fb0c76f7b6adb8f20e36f1727df317015ccaed1b603a85a6b611623f8f46dff4e473529af2a13e55deba34e2066284bc4bed147d527216c04e486f3e51e77e37620f624193512c887655f1853eee829c7d89ec028b60fdd75cc156e10a36b8b5d7e5fe94da418dcb3a0d2429217f77f00dd955ed462389f1af61fe5b95eb9ba8af9e8124b47a6471141444d5c26131a7cd403f483f479920a90f7292c8ae746fa51b85789242ea8297d3516546b9a8a0b2b6774ae91974ceffeb552e9f0a5cf1992e8b3a33016dd5e981dfb861a98fa61c1f1f6fb283b0d6361cffbaf6b39a83cb806972cab6670fe8cb72f4b6689dab839272c3eea5a51ace041ceaef1090b280cfc99da1dad69637fe54f4d1df0dfc396d1180100d5bb3dfd133325e2302c9124ff80c0cdc245fb2f2cb3b07a14bb4db208cf79c9144e850fbf921c7a9fa9daf3100019442d766ef5f96d3e548a0d8e54aee75e188b5351616d789b2d71426dea58001c99ab1eb25fb4975d9bc2654fc7c3c072081f5faa5992d1d1153e3493e783c9b3a5c9f4175df0ee3ef48f05961bc04d3ab3d10329281dd79d1f4a93f3110a726e3566589fba9abdad792d69ae25496b2fe62e7362051ff8a2021b04be1959e8f9293d290d4c64cc2285c52aacc25132e1aef108cb37feb0853f27b30d4a6383e840211695c7c638e149e20da67be9e3364a8e76f157d347c12e0ca2c49946b90f976afeb72960612908febe885149465a8ef8b9e06493e0c07b7b85d3d396c5df24a997e76cd9f175535c463596653eaa54a9a2a1d5e10e7d402ab738156d47e197c3878801f13ce68d8df00151496e2392adac294df2aa06d28eee912bb3a6e7b6ef61f57df6ffa84348c422c2af812241ac6b7f32b2e556bbde3f22318a1dfe54db4fd05f2ba39e6f140f02ac406c52ea35a5f548b0115ab7506b88843f8eb0405d1846174d5f84196c443cd0a651845bd65b54e099d225ef18648dc78339e8e5570a98a7722c1b0e77c291f8a52abbea37da5f0a7890c05ccb1b45d164ab197b798e5376b0c07be27893956e9824d125efd89825321cf23eb50bed1379d76ef6e9df01dc17271ace49aff160ee98a0afbe90667fa2281be7759f2b9f52ffdc833b1fdd7c128fe25e42d2bbe5d98e31d65d98c09c0417ab2c49bbf2f6ca0d971e4ab50d04f29a5c95e28623931faa5a5217a7bbb903de98294f1854dbf1f3e33d87454a67e1e08cda9c5d575e2d3eaa9c30f2b1bbee876c13fb51d7c76988e1d206f2d65ade19147f2d196fcaeeb8ec6b4dc49f60dd06823fde82d428c07dd84dbac59c39d0672ef46809f41082b096cf8ae68f96aee3575c378899bcc89e44f4681fce9893cba6734dedeae4603dc56da93b2e86a745edd2955095d387ab27949f50e5846168725a5ae4c676cf8a4a010f1fb0f9fa8ad85e578734623681461a5efb348225a0580db4ca48e90e30850205a4f8319a1ec44e58ef560ac59ce328edcaf8bbcc0246a7460913bc1470183294db09606c1131b4a3046d22ab017cd51c96abbb4e132a46e8f3bebff61663c15c4352b705e49fb46a0a7e3a950c7f8c7a19b211731f6ff2062644f00ac36e8b871fa095a51e283ddd4e8b28854b7b205ca0bd82c47963c4173bf06b82878c64b3f164ca64ef852e2259ff782a00d7b0e096a1b83b74059d43f142a006db76f40c9b980fbcb99ba46af9c001bb986c1fb383c124979582635064436278f431ce2099ef52fc6295d1777a4603d9bf5d6a730c0c59fef0220347bd0873b382cfde5df9c9f955b9ee969b256f798d134a4c2cff9aa801ab07279e6f1284bcf61afbed73cdccfecca1c0058c1894e7a441d55bdf46756db484110a90947139cf90951705e391b0ce4518a1e7c56b9f9cdfbd0a23fe940f2fde1e762380130174c96cf19dc0878d1b64f08f5859b5fcf2bbf6538248aeb46e5b7f59104c3c25a5d1ebcf4bb3cb6148e5b68ee527c23714b130619f1b1094984f754ed67c01d888ce5ad09a0610c9e1956e6785eb86dc3f231f595e493221876dc1089bb7a22e3ab28d293cfc075916f41e7cfa9b38231842fac62f5e76b9e8e6a0e2971d775f194300c8d6c04485154b192c35ba3c4b43d5544de827133b96346c507806fffacac614280666144ac17aa6ffded75d07d8506af128f44543f0193fff121eae4436182b8f34687a967359af0b26f82f9130889f3c4e23878a691023d7f8edaec5c34ace50a986a35c7bec55d41fdd6d88359ffb7baa48ff2bb8d9fcd5e550e0b4c6384fe547c238244b9593a2685432ffcc615d8c380eeec8e3dd6def7db1658616c2fdd417f0fe2f3fbb3761e728fe7250cfc5933dcd1434b12b359312936347b1aa70fb01f2b03a11afa73f8fcfe1dfbaa402b9922f06ae188e5c83ebde5763c1f43c99247330514db413c00b0962a1422cec3c4ef16eb4d49bc8c71cd65abd6fd779923384c626619b6c27980b10fae679c91365f5daf2ca876480d3399b9d9ad00d3e9d8a0fd92aae433e41ff570e2615c10c9e3d33a446d72b67378ece0e2970aa0e2af519046c8e517af4a03717d1f6de4bd3576651b40bbc4ac605ed7bb58156f706bb786d830c1724b467712c72435d80b6245206f63681bb01c30dcc475392f61e7687429011b34659ab3ecc01bc9c91c71b639d2167a10ca6176916da87ab9038c355f26b8c3f91a79bd37b913c108168f626c25aca22c5663194e5fa1bb4ff1a10b0599cfeb13e626708674088aa3d2b184050be70509c767b9e7abcf555dc7679e9b6ae35b11e78a1e573b441f5cd55149b4343a205f89c227e8cc3df14d1a78e591262556070edcdc3df47ebaf2f032697dba89d41ffcf686c112584d19840a22eca5017b496f0cb75434cf702f94e9ec10979f467c710f6d8e8f8fcdb54ff1a63998147199ae2b1854c7bbe90782c1c03d6045778d15ee51f913998d7b61be25b063a488b09803450c8caf406a252d781166e752a9e87c90bc6c40474fce8cf96ce8c97c79f83536484a02418d65f40a1cf4ba7603b36155aaa073a0e0f2ba760b820969eadcb4c067be50c7cc094f90d32f666378fbd3e5068f5f2125ebf202add1d0436c5e47f10fe480becd3c766c7ae81b39f7ff82fe16b092c658973c6233e6276c9a44f019443df2dc32ffd20f88d0819b31e69e4377633d30512b2f171d52cccb1617bfc0c37b45f399a5015175a0e092cd2203144bb81db368eb1eb1f8c40ee125178c48b120fe5fc7eb50e64754cd4c46a6d0c5b7b2bd30b7c467370f719a9c933f299e3594521588de9c60eb08da04cd08044f45d3b3b4fee9fb4af03c72de528f7cacd6daa7c151f92801b0f23d994a79ecc7f34d054dee801891e2b6a8b7292f5feaa3e37a2a12dd326ccc75e6f171c5fdf94140e7c895e19c49d82e56caa863b9123118468a4aa52fdeeb7f2cf6a2c2fabaaf246b404ea648c7d62a992c406e552b273b980ab8294c5cab573859dcc05e010c3880742c5cc5d9c8e7b4e1d7aaa58bffe83de8db70c92e14308a143f9c9f14f5ab29decd26abbf5fb143df6effdb2a67a3897fa37ba4b9e606e3f9ceb13a79a6d83d0e85102bd4a289a972cc78a9509d894ec55e2f16085c78902dbdf34b433629435ecdad5790c9ac7f2b33128b1ca94351ec71791d6ca96dea36944c37231d2ab42f44ab484e1424b637116c68e3b1c5e1581ef75faa524904780f0f05b5e60ad8b9d4cc7f5f0027e80c05f094c30ee1aeffc79249d14c1c3db7d04cdd730c6f4a2193af8f5c3ed3f564d176074ff977d0b118ec11e77b67ffac0aab986436d3d33b7388002c463789822bcb8605b82f9b970842eaeab5dbb75935b840bfbb1422881bdb2d545ef736daab0623c9ed0cffca2c5b5a1e181482d3bec20b407f00353da0136463a38450b685a0add513d80548b0fa57350b2970330fb5577955386f6bac294966a97d9fecf6b7319eb4066e96ff8fa983c0ea1c6e36f1312e31d2c5028ad86dd712449d43f1c5f226bf6a0039cb2318736fee10992acec0b0111479a506a3df00e6c9b9484eb81c71addf642bbb3247a4c53185e4abc77a3eb6aacfe8a73f0475213f58f97603784c124a97568a24870e01d142dbb9013310e362a3c94c428d2d664b1808d7b30952b43ab1b3dcb403fed46a514ab8ae7118ca34fa5a3301927889ce45de2ea418c7b7c5e36a0906f443b677df68ce8188cf07f48467c2bf72e814c01a7451a45fa1d8cd93f22be2b5c649672f828ae7ced5fbda7be313537e0977cd349223d3b5550d076082eb2e56caeb14b9ada035359ee202aa8c45420cdb191d341de9a96295a6bbeae4281559abbb450a53ccf1bdc9241105699e34eff658a1aa90b39d307f968dc4c2abd71ac0d4c17f44bfaccb6ede436e4e7f3d7fc23583da887db8edef7d0892c0ff8083417e5fd0b39041617e6a4148bf3b426479e923af3dbff33c82018c3a18a59e9dd0676168d0ad893cbb3774fa0443f38cb8fce16a6a4fe5184051b0cccd132cc7606da2558469a1cd2851b11e9cd69cf0dffb84788246963d7353aa7e88f22d44d12bdc5d8fa7e5f5216c3191e2aeb0e621295f9a51b848a0c6250844c7c35a3cb77d1cff6f0dc954434e8bf6222be822a5ae96b018fdb0f9590e79d55b95033451707625a73390dcc9fbd9c31783acff3566a9636af3e5b760acf5756ea01d128b979e69001b2c94e00bf13862633f140bc5a2e35c5cb5c353c2303113558b2ba3c1f2a411a93fa3ddc67e43c507d5f0f1146353b62f512c49c51730968cbe8985e566788a2e409227608ddaf0cbe7e3ada46933c357a77d6342c8fcc55fd1fe670c409e750bf9b727cde88e7370034cb428eccc31ba1fca01afeee7d2839a32b5280a6d50c45caaac7305c042ad58a6d9602211c321def04aa3c55b8d050142536174fddc68084264fae496a3a9e3ed0496ef2be3fec38dd21336ef339eb321dc01f17af674f0bcd841fa4bab3646308c64486133fa5f79668f286a0af761509af3069debe5d1339241175e88478afb5e91972d4bd85b62f2ae9f9d8fb376c8525e8705175511a6f4cf8349ca9971d8dd3efd056c3ba2d1f7182e2b4f64b4d7edd794a358083c3a12606864d37de22bf4ceccfc38bad2ed34e7a3fb86e40cea1fa3eb553893c12dc3d48ec182d4a23b05799c6202c795ebd8654f84763fd4b227e4116049229f9dbee996a29a5cac065ce0d4d41859cc444856bde38dd63fe42b40447c3b4a216cc1713396c9a8d8b64df260b99e45f112fd0b0178940d614079980be7fc1550c2f15369c687e31cc81127eb23830d0d148ba841947d3413e63d4d977a2f019d3ffb70266f84a447a636eaea9b41106d76e6fb9765dddb020e7e09ded0f5d5f75893607582f29f7780107ef98c81b60be7ddbcc33ce66baef38b81aa6518fdb629c94f051271d81b50bc6ce4273a40c6454c51d4e972875c340bf7049795f929ca71bf84f66b21ea72f3829bb6dce778e764b36930e9fcf029a09bc7e0945948341c0838809a791085f67ed4a2b90be74a9023d77ebb7d290403daa3f9ff9d357e73b805639e004a221e56dddcce9c2c0a8b43a8abf042e333bc3889c9cc75916051112a6de7f53e1f9190f76147b02a715b845a8070a80e94b72ccd50157afdc6d92b8cc07a9a3d98747a42edfcab86f4b7e3776564435428e24167e5b6e92d509c4d47455f8f8d4fbf8d84ef732f5de3ad7da06d44b81d340e6d02cc3629db542e5483bf4652110f7b89827a3305fc1acee0c45cd583a2dd0cc0db6fd22c397551b2fafd3622d406517c85f19599220469727cf6ece528681ffd019085a4afa0321460497774ec2c9c0ebaffb5a75abf4312ce5806fed96c206c62f61543f863383e94124a94990627f0c265d3385ff0cd9aff5719d153d87015988d090501d57ba1bb9af55a8525d4cbe9e23422ec15e71195dfcdbd8014e10b301e0f3d0cc5117553ab19c5fb174f1675a0287a344dacb29c024925ca55cb7fc34de6f19db26c797299adb5f138035efcca83a812c4f9eb1f651c547584b59b232e54a0cdb9e5456ceb2a2a3d6f76100141e35e4900e419d3b8e165151b37a001c117d3003c607b30bf0151f6715fd2579d8e9ea33df7fa4e5a9c7b79cb6d125ed0a96cb538a97c924e2abe0f322be8d2e2082acf68579f41f637dfc78b5d2d0eb7e3c2354617573bd32658fa21b1fc50ab90fd31794656f6bc7a052e22b9685143d56ad6c1624a127dafb7a3244efd003833710f770cf34a0177d758386b3821227eff7ce7c37d558559e0ee4dca81db97955853bc74b4bb4bc492b9b4e7b919b900ff2cfdbb15f6ac99399a63f8d940ad633004700792a17b1d09600d908045c01e6f7978f0b936e1e7c1386cb4585310b76d5cf4d8e46a7f2768ec82c5d987f0b4efbe99ac7a9125e080e92c7b80f9c5b2c39f902ba3cc0eeb701bf09a06e11bfbcf069b0e33ab1c5b11a446f4e6e4be49c9a9340e1404fd126534eb151eb193823b2264df43871fc2f831f4108461dc03c137c37e635ef58ea6600323b1806325beb7692aa1dbbfedddeb38a82c843356f3e93b926c9e24ae35cf252f2e0ab8bcc3749e8f54dccafd57855c4af17f0f4bc8d13b900e612059894c4a72a69703334bac7573642ce7e69a7b46b1bec8eae12e65665c6ddf10380bb86c76bbb70ec1aa4396188882a8a2f8c2b76d1f1e56b8f9eaad432431d8551f2e6cd86a955173755f07ad927235cbc2ee4ccac30d330a70ffecb447eaaa24582fc65ca05f990e110aeeaf140aa46a28bc909c1e3a914a3ba8acf701f64dc430609c079822746a9d1663db4d1fa30d5046731b3159d1288d448aca50cd8ab8375a3e78845e5f7c6deca2ced5bdab607ee90436c369801c0c4bed6853372bfd80107ed498ce0786d799f9a1246dc11739652a7b4f4ae16e4db6efd5ec4852c30d7823a03da1dc94a6cbbb89c58d58851f4983838054e814713cb2c4460a926c4faa44ffb2ca1a909e075ea047f2db7aab70b495351b5c58d735c2b8c327452378c73f18fec07acf65ec9f2ebde35a66d589eea69c812abe2dcb559be2fb0684b16cc5d51cdf69251fcf63cdbfc18a71497ceb5bf7e81b235b32a941dd3d8f5941a2c232be77a58e84cb9e08b351c8a2c6935f0ddb80eace2be835024dab308efd40ddc8e0ad7fc6a4912333624f486babc6b8530f99a39656c4bfc03501d22a4e1df610dbfa421ecb72c5c060184ce3a4d9f86275134b90f8d9027f9057393504bc8084f2a46be5ad80b7276ee6accce860b3732469831d6c5bda77697b96ba38813daeb91597402c4faad0581bacfd200fbc4dbeaeb00ed4a1568279e5d024ca859d0865754480ec7ec5347175d52b93df4f00e2f717458d89e69e000768ab96d781f860e72e1603a8b4b5746f86a342758645ad33e247775d702f02932f76d5391e762e6c65be1305d3a011dbbcc828194d069a09613bc94d5abd9c980a46eb7f26cdd42f57cd1d8506ee4073692aa7ac16855eba42d4879577a8c123a14415c11eaac6b6b6c47bc72ccd2a8c699fe678ca1a6a947ff7c9d158d63ea80c16d672abc87ab5795402d4849adf7a29c6753130fcb6605fef756c424bb65daef1255d190407935bfb660fbf11dd866c1552ed9e6e1386355e85542428891180cf3602f03cce88223883c3947a1958143132378021d3d357d94e9d3c2eb758a2ea08870a2975169588e22a35980d59d090699023634d6b700f32e00411de549cccbb7bb27f2af82ab82a873b94e1427198265f4f106569bbe38c758e356edf9f8abe18dbda398a81c6769addca31be11a054ccf741348c4ad7e7dda0418e1bd1297ec79ac1254bb3b86df69bf9908867909ceabf3e4a43df1332e112846ec8a760007f12793952e466f194cf59b5842eaf58a59b6d49cb67d2d3a8cb73ce35b06e29fb4d8641c1136d2b2b3d3e80fa68d98dab7a217da8069e6bec87bae8146161808839b95938d9088dafa1fd1fa5a212c12ead0e98f5ee38e356144116df5dd9b7ee4e1e2bd4a77811d2a43c05da0fb6b1a454cd055611d4ab17a8304c0a2c6b7b45ef873c0d90feac01ad1110bf414561d89648b2f297b28108149c0d97699a9025283b8fc07bc123cb7f9f5df27eabaf36e8bd068242b60d4e7fa2067093f63d0510ca113cac97f17ff4c5ad52af227b51bfb4936449b2543796611b2fc8fe7a1c7f76338cbd50c9d90815aa199788913f7e817944ee30384468e72da4e7660b12a52bc9378a8e894924b211073e8e759b3eac76d1509d3bde165554769ea7b9dd2563e576c604a737fcf2cb68d7ca9ee34462105b6a23e9ea4d3e66738d870bf41943b4eeea1dd1e5ccd5d2092de4d75f3a349417246a22c8f23c28570df4e7352d1b2a84088d5ff81221885656b2a75ecc79289d18cbff7f1c4d4cc853e414b022277c7a301c71a321775573c5c776b3233b88db0d07a577ba1a03531654e94ffe96737591f4c4880245368786ac4dde6cb7452b41b965490d44482aa197b205cf77257e6b77f2449df6b003e77e7107227f08d5f266c947fd0a00dd50af7d8d6da35fc1fbd8a311e956f69a17bca5760af42d8f55a32556a950452b8459a1493b490382cb46feba3c1ded5232388d90a4b33905139726e87afebb4e6e178f86133f9789761f5caddf024b7a84b6b80c99d0d9b7f5c4923cdca1cbe99cf597d5b43c3f50aa6ee7b0886ac862a7bc61b17151c3886537d03da5d64f55b756d949194f1bec7f3f461ad1a2134f79b28d16fd3d67ea237ebbf5695e4af1822b8d58ab68a64736f9ee5f73b4cae716c3502ca0a92e6e5784d08b9f309b51d9e363676d7e4fed2d9b62b66cdd8080e272762ecf680104198a2579980493754d273197ee854f1aac5add2ef52711786dac2eb7a48a18c43f31ed5ce4d2adff9ea8c951a1cfb74c8cd5dcbd97d4f7773956f34b918dbfa83fa02bc6c7906d056154a42534d5b42c0da471be06a720a1fcfba2a49c04a7ea036e5b937de694281f7749dd1cd4561ea804197bfd1e23717f4991642381b275f938097d07b9345732b9fa90c6681492bea241c3bea813ee880041e4b73be70ed1987d73d8c1578441cbe6cbc61faa2f91473b223a152cd6a76d2c38305e6cde264c43672c5ed82aab6b34b79fba72cce3d89a4e4222d9a71cd18b95df9f429623d11420949d30a6307e22c8150d99eb826656aa6345df4857a3a16671880fd231495821aab17c806ece95fa5feff0ca190584c6829b9357f78399e17d01f9cf25a561960b78bad9867ab7874fbe002bdca7c55e7bf2a62b7fe5013106b133e31d06d147443094c66fce9f60805478edef9bbcc8ddf81147818f3556af9abadf080f55b7aa4795c8c3b83fe23785dcfc24646bf748fd6534046dfd7c7965d3cd0adfc8ba86a318db09c89bb1b28d77d9962bfc67febe5ffcb62fd7838d16a446f8ad49872ed149e5da9faf5a67d02a9a05a8eeb56a62411a01df919cf55a1124c2f55f4a59e29b707b1294c6e1df3a0dc45e95232640ac78361791a7991275a859c26f5afc31a9d02e15f5d57b074963ae9474e000265fd04812e0647e11ae659040b7dff96e8c22a9b12ec0038dcd132c302cf30406709b77251e255ecfa7278e9dc1e4417ee4e59473d226729b051c7dc55ddb03cc9954bb5257e908ff8d8a72f5eb96d033f55491a18e7397985e1f0faccfd6229aabb2a2e65bf86ea342afeee4dafcf192023e61f5585770b5f223db7029e7a71a891671d430ad435e07910e817931ba5317ab6de8aa9eb40eb3d51258060ae65cd03ed0ab2d1e7790305c7f5691016ac6236447957622ceb553b56d8c81dd0628dbb06f641e31dbd811e44b3649d28cccfdc154cd4a87e64868c10b664cf0a861e6bf134af3e8b3ab015f8940c6b41fd1ff4abd7d2927d0ec9eb811bec79de3a71f22f85ab3568b19fe9f657bcc8f9db8e3fafad9bb667d9f5851a19660bdc03ce63a6bd1bd263d8898694d768a415adb6b8f3f53e65e05adaf990b32434e69ef964fae2a1ea4f8f67c2705b061837b91984667befdc81a55136d6d3a19d823abb24d334d857e3aa70bc47e3df7bf511879afbf45a70a9610cd376aa6d89464674e1989808ab8ce5dc63eb02d53e9b80cc3e7edcfe941958649971afd2a5fd3f561fee2973374b3832836a2e68199711342eb7cfa45f33d18356dbdfe7daaa9abae436dc6cc839661b8f3ebc8ed5965d9344128bbabb2a8479d33ae9dc7285c29df0bfa23cec462b2cb97db25e9ab8a66e9fc925ac68a44deb8d79c310f82e0f90fe9d07022b6d8c6cad45c414fe03ae33b390ef742734a858a86fba666f76124e679061c84207117d69895b7d09da35d031cfb8d3aaab3e4b7bb7edc0a3366555acd157b413a71d54e62f6269ba11683fa6cb11e1a09b53ef71f5b23f9efc4ff133216a30602343b160c2b061d7706a8cb28a23b9f44f9e292d17d057374df2bc13c7ec705c906351e0016eb7516e11a8e1d5a2a42e17fa7b929015c17471eef7015237abbbb9da3e6480f1251f918f6e31a4ce13c8176059ded83e273f259f7e7bc2e5aa87016cd22c6a77524022c1c28257c64d75fe51ed875f48dac7d462c86cf2c22df5b60102056ec808b34aef4ccd0e80073bdd279320940f5f52488bb5c072d93a1e7ede7da0c2e171b90503ee7db29ad56c4299184ebc42fe07c9212ab69d9d5c297ca13bdbae7430f42c11018b874dd50ad49e2699303449caa4c81e66f2eca83bca5e9bc7c6e3f83fd0ee1807dee32503222b10cec6889e2c14eee7a1d65d560384e04879911dc5bf011cf5dad09d31b51c7253e377da59043df326a230210a80bbb2ad32d135cf5b663226ff247c66e316f00e25d08bb4faf82861de561eb87c2222f46dfd833e4be59b1bd4d7b2ff5b5d4b07d8fe2ba8bc151fd3cefa03f60492f745ed8a3528ee09c05f0389ca7936e023f3afc53bb163a79fed87aad0de359193ab9d25e2bd980e567605056dae67e13c578cb07005f854cda21748c020b6de1d6ef0cff68469e5852906d72cb35e890fbc662f23425bef39636e25f181733ab9b8d320bb158e2bd37b04f6b4bb145cca664ff6bb4cea869a33b7f9e74dea8be29f4b72f14331093658ed638f9cfb39675649572dce876fb764e2d3f43b623ab2c768f3dd95ac0b25360dce7333ee884","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
