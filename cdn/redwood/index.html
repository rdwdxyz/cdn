<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23b744967d61a13a0b5938cb005aa94f49dd27c7dd2c43a62f40e6593fbf1fcc88ef6677d9b017cd2b048c66ddf3186c9bcb64bc0dccad13bac8013d2880ee3bbd9a8ed6384d62ed35f7e403bd5c2eea8447113de291cbd4a88ceac14128f7d5af1b9898a2d3ab8e98adc56d1b71c5f36ca2b0121b5219fc63d0ed0af679a0f025ad1de9e0558ec0fb6b123406c6845d6d53c2a5b6796fe7f1730eed29e662e781cb0bdc2e822ca3828af2fd383e35f0fb987fc3a8033d48332388dbf01b088f54d18e086942dc8eb1b0916c9dc020fc786bed64bbe2561804685dfe24d911474caaf49eee41dc16c15ff23bae6be37aebfb34a99183909a6e4c97000f278b8d2e5a149acc7edf81671aabcee5d651dce106cd6558557018d8beeabe462fd744e1bf45ea9c03a772f6dbc0ab8c1c8333a1f98eead1c812774b2ee5b73d261575686634ab4ca5619c066625259bf8ff59a4a8d28dc18e0cb5e3554e123dde79ed7e07858a55140a8b063b4e7e6ad9cd3238e4cc698655486849d2d37798116e960f5d6b6d90ebd3c9ee24b4935e01f81908498be496490b173aea3de21aae5509dbcf5a55df031e3be11974349ca7f3aebd806aadb519bffa1d5f5e998729040c47a158ceb91254c88d0f2ed2cd45711d909447d01a96d1c05ba767d57775cc4321f1e1f8f49cc316788ef3eb36879b39039d2a43ab6e72573b8b9fa49fc02a57be838813bf4a517b3794e4aca54b300be7a2bc4f7e2a3c52cef9ae20f390a7f22fe1e67a9cb2a6d3a0fc010adb9cb702cd1a0adcf220eab28e838fb74467587ca4b366050b8cd647de883c1940cc2d302610a4244e4f40ce9a19c3fe0e561286689ac215ef9eb33f03d9224c4e60110f6484d4d7dcc2e519ff78ba81b2a2ef5086e68314f94523fdac9cebe4a10f07f13049d0c83d71594709db239531ac3625752b00bfaa939f7c67eaff01e1c1831ed1195e59252c1c94857777c1a961e4346ac2ac795e9459b942bd6e9182302fb8ae0bf91ecead5832ccb429bbbaa35a89764e722e38272095184615cab4181912431f725207e7ed99e0afb93be605b5c411bf08ac6c6a1b75ffe224825f71b477de0f905e5bcede1a185fcb7221d499504588cedddce5565dbcca9cb75b2f093d0d1355d9874ed3c818f5484deb5c1676cb0d68dac8f741a3281552f4ac931d2825ef15124d29e81ef978c65ad4ed2c87a1fbe589ded289ebe5d4cb6b01d17cc02a128b76577358e83ac69d753940a00897f6a375c2aafc7a079b5a4c064971ee9c9a5bd3f8df99b3bc76f5e479763e0f39f39e355a046be33e455280726d90c07b76c7074eb9605dd8de2e7606c219c7bff606bb81786d9dd42b61c390557c3b985b7b88023eb3afb21f9ee3f187ec5e1b2e715d1072bc02310dc5cb6979d6fd8acafee453ac8b8988cdc50a86c5320d540aa57b3931946fbbf639368c27e631582619fbd04cb108ee34bdcc9307bcb9d7b0ac9ba223a57a7033573c11facbd5abe8e05aa960a66850a178b22bcf1042b93cb46f126360455ccb7704e2ca61931a8cc9a28e90385ec37576ac028a5986dfd23ff4a3eb0c38454088102dd98d3f4fd11cd8dd80058935f01d39736fa6368ad8a212490c57737122cbd9bd062fc4fd0f104e8052152dc294663433b0be21b514078d96204a242f68a432718db7734478f53fa42de0946f194d3a21b641ef8894d453d0c7777e19433765ac4104db5647569089e6a25c022f573b1bf23e36aa9616d9e9bd2fafbfa059e92c1fc054b74cfcd9c4f8a70cbcae409d0121666c395016794aa87efa00b59370fd9d706dfb6f8f89d595c021e0bcb969c58234d4d09595790456c5ea04f95495f4e5a69d2cd3aa7c23d1ff14929fd4d29168728d6f6bc62bd56d375b2af88a716afa10bb58091c93e1203b8b373cb18f1dbd29357aa96fff50484d94a1bf42f53c7fa6db33c3cf2f781674617b951f529e74b4ef3031a4d04ed0cca192c6268bb43f983ca5fee75376e93429635e9a8a6766869fd1a0b565b01ce93340b85bbea829edc964f24dd81bdb3207b51ba4a53ad77cbbb4c83d0d8f28c78f020d18f72b8aa44e99e2d7997081635cd1539bd651336bcfeeb7bade4dc68cdac53c348459a5e153e4d80ae1c1a6661ea2f0d1bd6f752c51fbcae84c4738d0c5307dafc785a12f40f9fdab38b27696b8fdb17dd34fbc7b52982e0cb8a4e800d13743a8601f3c18d107abb94c20e2990d6d55bc526c11778c639522aafa7c8822e80290a7bb8084f7ead75cec4ae52c270e33f090639dba6b2e4e5136caf20d950864616979004ccfd4bd2379f628277f9aa8c8f5d3970e6d880b1ab4ecec4ab41fa9298fc1278dd73e4b124d93d48a9777d6f0cbb5c636aa1ca17c0307be3c334ba8f547c4eadee92bbd20538ce75d0b387e421bfa63d79da11fef6ad49c350262b9cc5a30a20a9fe74e88e6829f8c91e1747416ec7704e39cf19a8260606c5722aaed9b4a031c0966fd7837f5b11c594f93231b87b2794e716555c506b4623172c57d6b1d0df3ba5cdef88ea3ec829462024b1f783347ceb73ef25aa3e763a9c2b51918e7b521053983693af374bc3b6a83fe02c945426f80a120f190bcb22991f01ba2be401164a19cb8ae8cafb5b79ab7684f2945010d2a11a6c8413603852a0e027588f7873c6257a96cbddb82c0ede663239fe1583c7dccfa40909c48511bb01509b090f30f86a4b0b58558bf15039286b840ebc3665c8066a6d49fc7e4afd05ebffc8ec6615363805753078bfb4027c7112d44c21e33ec84d679704c839939f74f7ff589c7f7b24eb28e91af5daf0734a5782a5554ebf163e6b1bde0e6ba9378e299a25402a507a3d8e27222b6396a39ee021ccf787f40999a516e36c5c4cb7adbb3bcae6438ae2f24ccea61f0ce4d1d63c1ee03b7cddd6b018153294e287d7dd29d101d361036c86d1a5af9a2c020e20d3785e72bc3fd6c4d9551c9f2a61d6f4ed35bc83c02a14d9526c6c3bf3009c442bc43150ee5380d42a2853da52ce59b64dc821e7c67d2cbd160b03a23937124e2ed9cd2f30f7d1647db7e51254fc5a0348869c97d20679ba4b0f2ea2a4c878f3988bbf40f5603d7660eef77dc61921c902cda5ded6eb9772de917fac60eb74b34352896b0367059e9f819f8743753e8c5ba04a9deaba91f83e3efc1fef4249b880328340836a18c567a8a95d7795560d9402718e71bbe02fb84e90a704299235592bf4f12797d4cdbacc3a60f50873b9eb1e79305d5a79a5949b50755ee3de2a53880db8628932b97b52833f7389a0026abd26e96c70ca358b56faa8133983743a9b253ff9b4b169245faf63fa52b85702c18449ca59e9407e41a2a421d86907aac8a279cbc8770a7e977ff0a255cf4a1ad545a7db31a70c547a2b7354af7eb656fb9c11503bc9cc77125d5deb62df416ec9bc1c39a03a3a041e417029ed91c4f8a31e06363c4e43f181f2997412a78e8d5bc0dc71d4e9bb6a78292627cfb1c350969c3ab43fd6fe2b14ed442861a0ad25025ab319a900212cfe6ae45a514b03cf625fe4b412fb903278aec668f00b48b3e2b24d24822d7836fe831627c8a77998105f767829f8c722af7331eb11e4a775b5ec6dfbf0cc2f64a44d3d93eb0935008b953a77da42c185b93e01ddd2418d23a8d48a8d63696ce67c2b87622b34f33c779616471ca5d0516d0f06ca5995b151d422c128f6959cf91f7dd9dd85e3575b18381a4bd03388a6f7fc8ff52162dbe2365a712e37accd28e3d92aa3c6bf03856caefe31c3a146f50cf7d45ec896834b7120917e952e890a9ee7a0a99179e6121a0f936306f7a7900c805dd926833b94a7236a22c40b6e24290653b387d7ef91764c9e7ac47f38050e4a4263056ce32bb0aacfcaea762bee5a3864fd51fd715334c0a6137420bd528fd458dd79e30fd4bae576a288f13f04d614480f968ee15ebb45d1cb2db2f66b5861f2b08a77399d08cd6d63e52164e15ddc3b81ca6e772689717ab6a1f919de407977f5e50112965c9937527babeadcca565f7c3722b128fac0ce4c3d2fc404a625dc5564e0e93cd4355d301bc674caa7c924d82bfb6fb8ff156b2e874ff6de5f6e0242f0e49fd82ca88d197e614e2290e555239f8be10f81b7a2962351b742b993199ecff90e04ceb71211ee0ac67942a33b7653de7843081a49f4a338690b6dae622975181a2d868d72ddaa80adf752e7f7a223b489adc6b042906f6569be9d10f3bdd332327abadf462e6f800f279eaf9f39449a7d7459981e24d0eeef34034f3de1ff9e0cc61af070fe862550ae26533be4e14d2645b84376f91be1d1c1cf318b4e7cfe6229a890831b489e8f978e2b53421d6d923d692e3c15c9516e1348230a58c0ea163a786ad8882cb4313dc7c26cc92a07a53d02af1ada73fc9d3fb04956189d77c1274f810085ee7ff98a65179d529dde1096294ef0f5cea79c9b2e6b89eae0f84fbca7c3b946ae79a59d491c619115c2416ba7a3a916fbe29b13442712b4c8580e45b03bfc585c0f749d955da3107474b8ab57bf2b5e85ddee388526fdce70f040cb49076e0e7c31f932d06c18b67874b547c297dce02e92e18dc6d546b5acd9c46cb66442a9138fe1b6f58f60a1d375f360c267fc58497c2b60ddf950522ebdc47121fd971a71614b33ef74d7cd242dbcccc5c49f42da494b454301c794b0c57673c46c980ef66bd71107939b07c527510cd1c8669312d1680d054f1cf051ca939213a6ccfddb0cfdf893f36b643df62751ec344bb0810e1c29ba0ae11234133fed06f370b14f8a8b0fce703f0d3d19c01e46f86f40c0105f83d13adea7eadd04da909b41f7a0bc41007fea5838ab4e09f665b21224526a3230c8b6660ad2a21132687be87e265905c348d3308b5888f56a68ddaa67407fe65a950939a008ce14e1f261029a09442640839b5547ad22ea446a5a5409bd10b9e38f91e98d73c2af6d1dfa211919eac079371eaf64b8661f53991027f9e9c3161f502c56967f943d05b0db101894ddbe2c1332c3e30fc1b7884cb7d01fdd4c531d9bab651600a757e7595a4576fa2eed2d87d8e766c6e2771f276be414c546d93f1c90ec029625cea8763ede7fa833618e2836176d97e5ef2a220040050c149e5cbc656d6a8198700a905a6d6718dc081cbae7238c90fd7a0c41788585c041f41ea237a24d39f5d3a066c38bf7cd88b578cd01c13e9ba19ff0c20db2c850d817e88563ddb0aaaa69bb135b34be583f090c7836463d98b7bab35d9bd3eaace444245fe06216943b811ff2e33f26166b634df7955ba7e73900c677d0b221cd2b490cba1633c05e4edfc4d1a3fd3d9214b81381682375efd2d7c6bce3d8686233ab7f0fae0b2f2b0ae8fc78e241c8a1f4a7a7b316736c3a3756c577077bdfa57ed5a001ace6206f2bddfa6f6ee676fa591f07191d0337931246ac9fa3847ef379c4440d42ec02258a6cdb49d229c42e8f1f0413c7c7dba0e4faf8f3dbd3a41c2ac3b568a623574184657570dcc21a046f0534aee8bad80d6908f6f2289d98e56bed660d43e14c1116bdf4e9098697c970c183882fd457d2d03d44179e01ff1acb69e014c650def01716e03464fecf8647103359024f7d3567e7d47d0c5330223a0ea9c161e1b34582d9cba74af0d0512d24de8e7a1868f7a8f7ee13e08faefebcb898580752a67de415bb7df44e2b4bad5f5622de488c39feb377ccdd68731632753a8a5e21b11c3b7ab8f45d859071ed724e7f213f4695b81319bd47bcdf6883927a65587d49bd50e07f36863a8b5a28132aeef3dd7f2d07e8475baa1d18eeb4baf19d3f5c8b357f97a02a36f1ec1a6ad1430ba2bc9bdd1fa6822416173edaf6d067c5f28dc962aab7e8972c2ddd58250d1756e2cf0011b2bbf6fe622181232af5cf5125834eab397c69f59bc000a27252e79d2a7080f1797c1af9d644fc7b0b2a7f61143a02be9287ad4f4e0508546f445a010bd06e39f05a322b18353a64dea31bbb47113cd1fcb711f690049929f4d348d30271d414686aa33084f688d21ba79bc69c8d3ac2df4bc86b592b9271632ed2a33aa4acb6e3360bfe28ddeae9ed4b2a772667534032a33960cef2bc80b0895a45160a55042529cb099076070ab1493b2d07ca580cfb1d4c3ac24c68e5a81c91d26f4751c83e98c01d27b850ecac37e99f3263ba534f9cd879e153fd9fce3345b97c0947f673b2c47f06f5b02b3cddc0e7ac26f3571396edc76eb7a793868005f39de5265163802fbbf5c2e6a556750ae3f23f82ac323bc11ec113bf4902e3fe74b8710908f6c233eec4d5f80afa2ae1b7afde3b289c0948187949f1e11c36af5737b8b1adf312f6101d9f6b94b874dda370fefecab9ce5f08d8c9d591041f87e9d243935bb41120ec88e5c5027aca872499721dd3c7f68cc6346a71a4e4c5f6595c0975561f8063489e3ba3dd5e5fd1f9ad67a1b8e191b2ae4bc0894f90671a18a90ef99732bc2d2695ddf1b7bc57dc4918cc1af2c5da33bcd593252b6717f76b10611dd7031d7a40755b9c5b61760bddb1f3468a84e3b553a5ac02247587c726fec86c4de54439f2ab7aa4ccd30c985a7c07cb1374da5c6e37d757eb236736153d60553346d37695a7c66d9e3a0032e5affa1fc38d63ecb6d4cbfb5d30dab59bf53d294b46db50c203ad23a8682b40dc75c73d45eaa3247347660934a7a2655b779f42e1941546ba565a54de6faf12186fd77442247b997a5b2c7bb35a54313ec725ce1636809e47ca654f643a303ef17bcb2d2730173be6d6cb752ac8517611187c1825dba9a97b7a0cc973c74f7cf7d0549076daea0380852ef5f888f181386aad33e7d9e1d4e2ab4ecd26be28ad9d19508b4b9d4f59144dbd967d24863fa489b8378c833d7eb40e901c428974456f0cc72113f0d6a3fc27403c48d397d56554b2cd1e2ca943ebd8de037734bc942e0f5149f04b8fe0dad46dd9d51128e29b39c6acbb5bdd47418ba61bb16843df045ec85fedc3b2bcc9319241054b83fba63a22de37de71125ad994d11235c43345c58c2c951f21da28bf9a9b664a94f35221211f4bce78c487763396967d36bd80e95a2f2c8c4beeedeaf92f4fc01afd611fa4681a9191f09cf13294e6c4bc1a7f511ad29e3067f040d348b25cb4ff12e9096b05b2e73ec6969e66c0d3e944f11fd209c50842c66d65f4f18b574026fda72fa610dba0f397808408eeaa47956d45c78dcc0c5c071f7fb1fb23d41b06cd27fcb7efaa9b8c273688113abed4b2f2e174e19b9246fa1510be28deca6558fe9d7be1ea4691d80773666d0c5abde1cdcaef9750bf347f7f9d00ef2f874576d779be06119ce98b37dfc172375b3eb485b2c993e242ca221fe555081bc379496c7310f2f6c15fd4eb987ee438213669a79ec028f943d720f7fe9448cbe340a9be2fbb87cb013cc235f7952dc15df921807565657195109287a047775968f3af5120627b1d64062aa9609f03bd5a028dd726c190069f4d0285a85c542766f2de064ef701f39f41e159613d1c75e47182da9479f17c3bbc85f950cbcf2f338a7e689a0aa0f8cf6bb3def91c48d9a70540722ef7b9124a5c526a0590ab2c37c0068c5a2dd4bd7d596f63dfb8d7e41429a80afa74b53ccbd1b553c6c6e46bc662cfe8f49a4cc94adf10985c2767545b37f81e9d6aac5483937cb2525ecb050696d36d2588da54d1a4c8e10db564e587707d97da67e6167b915f2a1784cf639b29059d9998d9e01829481f76c99268830dcc573afe6dea76a554263bdfc95c9a7a6c5eba0a571547cfc27c27073a35097eac442abbab53b2b286b22bb84f895fb6fe65f2a3119c5add1d3517989baefad846d4e548952302cc1cac555fc57e8367b33200c47b206c683c8375930c6962e417e207e0bee27f3f65c1400489e91844cc22eaf7ff7b1e95f49047d92dcf31094fc8baa7c85b8a323ac60ec86b3b29c5678a4263913c9724e7840e4902b9011df112f5838f80f421da82170174db5daa53a25dd5b6258c2275eb356bcf83b8765378bc898c65aaf9efdd23e2ed6bf45b86e11d6ee88a42070279e52a8f5a541fa3715205287f292a12c20333b7f9c2a07143ee42b58440a87ac26ffa7b5ed5866280e9f55913427a07db631840f3bfb290b4e4b13d231d80acfcb2c10742b903459d7884e0067c75c1a4cf3b36ac51523eec414ac8014d76f280ba0438b5c2092b88991f9838a1efe309acdb1fdca8282c94d1853f41e977a7fd3b6d6ea08921b9e972612b9d1423dd43fed12e63ec9470fdd0fed3250822e990ea94fee5846fe3b93ec4c777abac540edd6ab03bbbd12d5fd3b2180ef2fbe2e03f837dd6cee18159bca9ea342a8542624d74cafc3b395a034f58bb25a3940fa0d75dfbcd2420539a73cf5eecb1581693f151bb036823deb6dc875b4450bb1138f713791a75f525a0ce002bdb341d9cb180647c9fff63b7f67525e49ffb0b5e7d61c6cbe1ccdf878763792c560a7f783e6b29adb37d942eeab5bf2c8b60e85eef4f019023d1fc1861afbd1ff4ee68a8df38f35d2c99b9ad060dbb76b874ccca41e57b33107650de8b752cda68ca83443bdee5df3ea8cec275e5305cabf614bfa1deb25c5caedd708fd424b331d75e0ac183ead998761fc918e8a12baa1b0396a94065df85cdbf77931c7061c24607d0f28f6f6ad4a52ceee71c6be7adab4be5118e9026850191d63456ab09d445726b242ea7b371995d9ae6646b3caf412ecb51b9b206727a7f29c5713eb63945285ebece23fe6113c980f59862e559bb9bc11384fc42ef721ef686073a3d4dd4a66b9187d9f70b1f7886bcc0c42c13507b310ed96867cc16de17cd093eb0888a28304147cf0c5580970b2019c315ee0c802c3b73c3957a4c7a9f77a82d8e7eda44723c328173d8ecc6066085d3f23cbe7f63ac8383a0c93842bcc1155fc1f6aaa93272b0c54cb0ce49b9dfddcafde03201504d71538828edb045ff05905f8decd81a7c2743b56eb87d4229e71c770b48c8f0bc479c3b73f64cba099481b6897538803a5cea83d762561a75f6413313b7860c36f680c959054c5e52c24dc02f68202fe9e1d500ba5602054e8eba9bf151fbb5e55f95f00064c96741596d44dbeb1da82153f483347ba02515110c4e2eed0c407ff026a6ba69caf45ecc36798f056be18c2c145719b7233f71e9dbb6d70b9a882bcd27ecf64cc7d4d9eb78b7141528063ef6e4c5c60872d08e748acae69c5d723d9b1be99f327f15c31a80fc78d1f51f23767779b433fbc501ff049bffa482f9621db8aa432c0242fb55acc9103bb3568eba70e29fa321c451357b7fc87a87f3a2c2bcb6ef9c11a0fdafbccb6da6fb680e8002e9bcc9d46051f09a2ea2f2560277ceaee97726173daaff5b9c9c6e597bd7f133ac5af26cdd5e43131369dace4c30aa659e22fcc791a46a4029db82c12fce343c73469d62a47327c0ec083ee9455c04cef3ae29818831cf12f6560c4ba6a1324deb9c515e5b22f0e34ddb7053efe71ae1cf46d0ee5f8798b8d7f5e31bfa02eeb7b93dc174805e241b729fc26c74e389346ecabd1aad07b464b78862f772d4066117a23b2646883ea52d8a7801c51474774906aaf75056a6bbbe6e4b3cffe32e0fd959f24281dbfd3ba4ed5ea34a88ec13bf16d3b2dfddbc81ebdaa19aeb166803b7188edbef643d53c9749602ff1f89685d3fafdbbc47a7fd6b0f11255d20c567fc74b4f1991b835150e752d6dc07a814bae00d8574181556caabfb28157ab2800f50b991bc2909c704be1eb7d10d68886e07f52fc2fc4625b3908a05a1da9ae89591cdc8908cedded59ae2ee939d2016622db2b9ff87d785ad75aa5fae0c8fa7b62a6f054029b0ee5320a7019d248cf1618fb0694a89cd44faf8deb41a23c863b89cdcd686ff86cecfce5585b9b7378cee1fdbc3045bb3385c5ab48da9487500008da4a8164c784fbc863d36df14f9e5100eb8fe6defe25281b4cac2dc10d1537804bc698e995a78f392a43c05d11676a37c7e82f44aad6e67b0e13e46ff5876a9b398ab3f1463a9afcc70829f541a3c68439aeb918cbfb82b0ad21dd34033ff6ff31df6bc664306845d5e97232e47ddcde07015da9caaa1897c9375cf8b3bf002cbacb6e42819e8130043dce196156ab26bcf6b4e171edaccfe4acc65d3b81a42899349ca72708c6f1b7585f6482fc665f7a6b439671cd7d2ff4f750bc9b42f097fdf93c7b83653b2a0fd40f6f1887257e7fd6f086df8f3917d6229ab6ec6cbef4089b021dfbde64089e8fcd8684f1ca68e8685ba898f026ba2a5f8934178b6e54921068ea53ed86c8ebb2f5fb67ad963d033a0b8a8afddf4e90b9573e9444631dad12ca72d078b5867b2e263d7b1b950bafd4dfd9f263498fc657fb5df15dbfe3ceeb5d88b6c4796fb9e7459bdec86ee468a9a3e14f8f69e2d75f418b45cc7f49c4e263db01bbc138d65e13daca74cfcb3a361b5e0a3495c63fc5690d76d8f4a0b3bf80c906eb27a65d3d13f7638cc57a9f45867de4bb82b6f87b49c9c22f438c646c423d8c3f5d6d87af067bd00f8d5fbb911a9b6381b817ac053cb3b681da34c49f190994b323c8ae0fbfff01cd3ae7bc268d2cbad1f93dc8cc03fbc6f637e8ab0731624ac1faa1da3adfa66d486d76c6e7fdf5e033846425bf9e63c514fb07566b0ae61025ddb750700fcc8eb9ccb93f5b90dc0e1d48a5f9fda8f139307c132d758590ff6f988e2c4ad2002f574da448a0cebf890f8a29d9a31c16c8213eaf3d70fc5eed7e0c8597c07d7d3490ca66e5b8b4d57a14087e2958c4bdbebfbc8463de760b86a236df49ffccdc5ab841392dc7967032ce05821e457dfa2162440ed69b9ba95f2003ce0fc55faffbc06a9126d37a464b452265b759fb1e93127b59bfa70c21efbf514b36f525eda025f6fec2e59c7156f6d0337383fa5fabc340184484566c9b2f8386dfc9c12e92c1e05958582be1378b174d404d5a34b9728dfc6ed1010a8a9e09f22aad9dee4414fbac7dced1853950e8d8bb4185a5c59b0743295318de2b39231b8aad17ef1f9a54f7a08887634cfda880f5fc61f7048c4180d1b2a28e7f7b7f0a6d079ea040e2bd63c5d02d8a180be0c8c3527b43c1e9eadc280a8d8e80815b9e817d73e1d28b18c72581276946db51e04178f16a5018ca1fbc8c9841751826d35b94d49e48a12f42d3dcbc4ab50c3b0b8cdcb6f5cdaf283d99c0b6935aea34108667c92f4f35e3c849ef4e07d44e6879a3df75cab3e0597da40243bcaa731c14ffb354e36b1709484b6c5c041e61932086462775db5e4739cf949702c13cc827d7a6e33611855214dc02b3f4fff7836aabce08da6d7be9510ca41747218ae5532b9aa95481971e23101d34415a41cfb40101b9d4a87caba1c9ff9983e40214d2ce76f45c7b5608bd780b5da35062d44fccb98e207871976a358050bb0f5a55d53f1168f425c37a21874d289f6c69110e6a1a56e1350eb638e084dc5d14ade86bfe68449a21a83c5d42d1033a44c25e065d56e4389f20ab38395ade97323d2bbe4ccb449842f22c0ecc94aa71df1e844a075009b3f0f06449a1bb490472c48d964b7b81a9e5d47657b16c62e8a24eb27c53c997c3b59dad6753a58d84e4a905bc7ff3fde4dffc13f30b538204eedd782519f887c175db99c5ed3434bf184ecbaaa5685662d644ff5b8ffbde980fe987cf4375be276012d2fe54d3f0ca59505fbd0e3a50e5ee34f1d226c56f004fa12e864b5cac37a7fc7aee6ba3eccaa17794f8c215b72f4c511d214c9532193d8bcaba40330c1de8ae8c227ecd2f48fa654b65fa4f363f79484a94162cadddcd3069e6202b1488073fcf74968341bc507f73686b63ee6f59096ee00d433222f0025b58adbd702c4ff2224876841a623aa371663f8bda99cba3549f59b5994ad65bc7e87f1c807fb2524df42abec26eadda977506592371ef499ddd12ae453dff292e118cda191ae64c8f058ea1164ac4a8dea60ea70336fc33d126879e5c4f297200921e3653a2ed739dc427ddf1018038ffff35553a50f109fbd46a6230041adb296c673293b5441aa6b3b3e73942f27a018dbbac6e70d9b24d014ee13185b67b18f5e9ef8a91336b8c50333e9727e5405ec772f8b99eb25b04c47801c7ad588e0958f20734787a26c1a01884bb20dd41afe6d6b834eddaa12b517df1259bf4dfcb89f48a4bc6ab65318658ef993e190e85d311a2c3b6568cde4894a1c52e51ad9c018b8167a1579d850637b682ee09583347094e4f49f5212cb0513d49ffaa8f91e627183199213430f2d5ced5d00790d8e2c8584e63ef345bf7309838fa0d604b7b32564ecc3546c4af82c265ac1853ba3434362f4b8a3d339944e5b80234148f7d84c92f866179302dd5ce537252c9725d5b2d531756498d2e75f6aad4913cf78b64fd2df77584b251125e800fa4268d7715e022343d879eb4180c8a982b70d5ed3787ba41514615fecf3cfd75d27df25f25187ce685cd8a673ba252240c55361feaa3fceef347f0f99d63d6326b55826846b5d15a52111fb3456156344c9efcdc975d76e35af7ab5b6897771f26a7c87253e61dd16fc1e00f2a2aa0dc0b8feda94fc81d51fdac4bf4067be656339da4e28eb96c23b9c79f52cc5bb831405ba2f77a713dd8538512b9b8f2fe05f4f02cbb161ea4732d830dea0615edfa617c37f532ba3aae836df8167f2787800892bbcd3985957a9df91c4e74a8a327002bb1674fe607d4f934c59fe609054ff80bcca9ebc66302bef5025cddd2fc0b5435059000302fe3eb2da5f4383c6d41fe81f9a9b36a36a38580b5c76361b2bffb832725aa152381cc7d85a3fcc8bd8eb94cad4079a8bbc750fc9faeb66e6b16b83beee83ced3d76d1de167cd2e0131c61a9747210bc0c105900ad911e401b8fc66119b513438686ba92b32cfec297337a9edf7cec2cd5c5e41f2c6793897de4e0afdb49716fe8304313fe75cfc10ab28fa9f9b5e713d3e27f68d3e0553363e961d12c8c1db182e03bd6635c863b1efc12119c1d925a05a9c353386bac42703c49852e1f5a95018585c7a6605660e8669ba4cfa5aa62ee16fbfe9b68caf24107a120b1b4bf0ed5bfed3ce944fedcf5232dd8810cc96d72592aed2a7b8e037215ce2d80500d60e77dbbdfbc175d629614554841e92c028d78390d45c7559d3bf072fe3b44160f979a59238aac650d664a58d7746a8c961d6ef2ee4a967fc26cf92a6a69ec82c41ae7680b2f188b2caa2842601046fedde12a9df4f0363e79a1df47e56d49b243bac480da415c84bfdea9173337fde788a39cb28ed99a52e88b156c3ae3db41d5f25b1f593c6ce64076dcaefbd20bbb7cb173a48a71540a92e40107a090c4274d792f5b8e4c1328c2f4f57b00f4cd8f03093685b1ad0fe3a0022fe28e777e806c4fbf08824f87e7e9c141a91fb3964d42705da679fa8e4d5987f1c5c8a9d3e6d6e301fe7044233addbb4902c6baab295779949862b7ad1d973effd85e4f21bbd5d147ba3572fc802b5e8ec2113479cd8ae6e4535a2360c7d68d01081c554c9d9b1b644be2b90f4f836b40e6a97ee798b0421c46087260eec6d61e92e0565bd795ebcca5887e29bec68eed73c598424bce8d0bf5a629e660433c4835300b856344cfb9d44289131b2b5b1b1a731dcb64768877e09dd4a88ca4d34bd59e2120f6cf331073191b2a09a8850d6d23de7b8963c7db20b491739e459dbd6d39aaf2a8a772d809037c21f64562ac55c090e1a2c3f46a3015fcd5828801bbc7cd4f290ab02e09ae4edb7688510adc0e3daedd5cd489866884939e0d85fad6ad07e29abaf144600d3e2968e757f1387edb11e93a2bbc3792539b44070e0df950040cf41d271f4d80ff3d08c4337a65cb31ded80c9c6a38d38019b7d9e29b058a1f8affd8567425d9e4632d06845e26c87dd1f83c674e4c9be0cd20f83b46f36ab739a255f9e4adb36eada8150ddce13793a810808b65bda1fbf118eb3c8055ff10ad09c012f0ad88086de599a3ea23fc7fe3ddc24603c40017d7732812d2cd4f998e5f84a82f667e6d064e2f2aed6cb805991e24dc441d8920b8701693cb3fb4e4a7d77c466dd47f12db3967a0f5a0644398bab416c74d4392c917e0c6401ee9021e2f4c577e271b6df281f9d48cde0ef4efedd3b5d919405347af1ead0e757899a6e5063ee17b7715637430014e452f754d0456a773094743ebdd66512e087d5183d6e9a118db1a5da6f8251b0b41e2bedc7deefa9ce2229da49a94d5ab2ffe142b45206b510abf01fd75a45ed22310fb9b38fe246b7a9e269102752bdd8eb4fa401f4299e05375e31df61d21948c2dbbae6af1482c51f3ec8126468c1d6f6db9968d310587bacffc88a1e6886f298619ed3465993a1a35c8e5d10117066b1535e2c3204bcb09eb87251b087fe2379815f3f21523dc10f56715963102a077b4f8d8c10534bdd90749646565549b45b734b901ce811b8b0d2c070fc5e62976fccfecd4dc7d24b2a3cff40dbcba917923d1514cfe0833c606e6e835df84732d3037236acf9a5077a913e45b4e1d41fe6e2a641dc4132380f84cd9e54f4227a8aad10d15d50326c5f0fdd9f6453c2059c5911070cd1cfb0243bb0c8d7cdc4e5c777839427eaffdf64ace2e31b17b08b8b917b79907dcf9494aecc654123b4381f8c4383f0a0d5b90dd97fb9e6ef92456ebc9f88be057d4ed765496a9e94ae59aec84528862ba460db9633dd23e709732409f56372e6c2444f71836d30af2192c7c242e3510c0dc3898fd5f1b1992630b4edbad1cbc4561b6531e19ec4c9d9571160d4f2075b25a4999dc3a3b0bfc97f2ccc962abbc639c4361dd0740eaf97597baf6e9fb3be58a2431712c089774fa3e0bf20de3f0022bc8253e1d3561e9d9a6f7279dbd4cd6e44aafa90a7805763e0cbfad609ba9084c96bfe367604b7829d57e44f1e5ad95a041661dba97bed529dd3d824326a2dc17e76e94f6a6d7724118dac00ec3850f5f0132c2ab7d0387df4af464c9e14eb61fe527e87f155d33ca2243464f9fb77b5aae71db4f0ab877f04a8191aed4eaeed64967f7767b7d3762ad2b6753fadbcdb9976dafe5c6de5c012c3c236cf9da002677c807d078ea8eed641657f2c39caa6003d94838f3444f94c9351f4860c366cccf2baedf9121e3a478f5d4f0c7cf592395d6ee78111ac2861f06e13ee31e5733d7f2364718068b5f07bc5ca36ce5afa7d95489fc4421ac25b12c642f15c313a6b35fec4bde88f56d5aa472c50a23449ceb2aed3942f41669c0ac8c19f71d98a771c6e0f67badde9a7a23e5cf7f8d64c1a601eb87a5a4075d888288924a1139038eb738280adff218196a1b985dd1333543cba00484790da6f89f460a8e27f710fa24407eb834eee8c9577b8ef7a8d7b59516ca8f7e937413ec2d56485c8b5dac913e6c8086c79dc93d8e41cc77f09131de5c064066321e40af94ff58265503cd26b37fefa519c5124af16ee999bdf448deb96a7196c54b32b78bac3251c05d44e0d3e921745c737e037d486457736a83180b20268965a65abe6b42619af668e9a52ce0b1bff252984491499e7d7d9dd364e39b3b89201e0cf0ee70035a86d34354ddd40d49eb1fa0531c865f58c857307b3e0cc5c6f0db42475438f4d5a7caee2da8ada575beb76171b5391d8b52b7e72af52a92b10f3c9832ec609036c40f9e843f164947f23b08f3204ee5fbba2dd7950909a83833f89b2a214284d4e916d80e25a9eedeadbc652e80af57a6be042ac98232a1f8010df6b5f1d8fbbd3f41e147c0a936ab24159d46aeee7ddc1406628ebb6cc494df8c650e3ac74913f96b82db3380145063e3475b2c8969ccd68272634e795c9072d721a9947d206b6ab471622ff242191d75617f4ff51864f444296d91bc304de745196d0155f6d12158dc20feda0743d4ed6bf79a91d6a6eab77af58ef92645065764f0df490bff2432aeee2b2858dd010961ae067bb9c68d141a4e5e4200c79ea58e58e4cf21a552949460668bb95a3af870210c0fd17a3e8ddb73ca4cd7ecf213c322f06480b86be8b5a94b60738a07a25539ff6e3f3a902f35b8a1deddabfe20d286e3bf8229d9aa14d1bf24040e1c07e991157df6310fd9d5f4af276059c6edb89008b5906e7f9fcda5e49d536b08cdefb84b33f960c0ba16aa34fd3bea1ed91a696fe803d7d9ba1eb2acf8628960503dd738e5c44137fbbef4ba7cbf19bbf5156b78d677da508bed27314a2969648905d3e431869b2c5ecdda42d6e456f86009141e34556335196763bb019a248ccdff71097f25f4f90772e18bec7a120d4ddb0689eac702eb280620778b74fed7232f3c9ee4d809987039b4b10b8afdd5c216978e4a2ce8aa69cb20ded13b195c15691bf9d7115531176aea3b9380f9cbfd3d99bc65c4c247c5f9d66b8d11922210e7fc3081079d75b5c03813c3335d00eb1bc83ed360406cd1c140ec638599e1a4ab0957f4484bfdb3dcb67a66e255d997eb4f64e9e6283cfa2ba6a2e6376470de7ac119939334e4df0231488d36c84fb46c7e85fa7e8f685b236d85a7573ca021a5121d410cfe3b631892c11959fff80045302277665f1a8cb55560d535fda950bc78828a292600fabc53f449e8067d421eab94bfc441557027ad4955fa278b4f8f919b0d2b2dc8d536e8ea584a343073caea5cc9b76f648830c16d44c8a32da6f6304662c1aada4f11038006cd8e6c70765a981a8aa59c28b8479634ef3ddb0ced385b259965ca003efb56f0886665263f4d58ffe6db13dfcc4ab6fc958b3dfd6c56c8a6ae4862db9af2e7023d0ffbd7aa6822e1f72452d9e11005945ff8370bdf2acf7aab8aa1373a9582fa7de5e4e7dd7f17d5baad6854d5bd8d40e7c50e36f8937ae97c26d416708fa576deaa555ba336647ed6ab7d85e6273a3c6308174190b7243596bd5b18618d64ea9e570a9cb5910a61ae2ddbec47f6569e8c5f90b8611597dacdb45af08b95460c896333575508fbd1560d95c9ed82e35975beec9d82568a6105b9e1bab116d8cc28e23cd7ee1c2a35c541e02af80ea0e24f7032203acbd4e8aa93f42621c0f16f05d6c7c41250510e0cda436556c6147599cc5fad5348f5afd17e89a8f7b8e423335b66cb601b4a09091c8792aff2bdce64ae1af81c364df1a2c3d17fd884fcd086bc8b923a59c45a7900f0a59a110be1e673493718c4bc9255fe8a5c684f52887d140fc6d5275491cec4af13e8be23264cc224edd3ad1cdac86c84ca8bc2828eabd4d9710cf1e44dbfa3fa33ff34cf42b992bb318d6503cc153296666c000ba445ef6922f9bed34e1f9f82215d9c2e7d17ccdf79f67d2b29e23e2cf31d70cf1eddc66f9000ec6bbd761bb43e253a840ac283c1e876021f69349bd6aa81a70206dfaaed2ea84befbd90e03289c56ec0b407a00d2a064f25f1f02595af995c3de2a33af9c88b22e16cc92194d00e536ed1eec719658bdc78013eee5f65fa8dd505ce7689407891e4b8b73d8ed6b44055e7d9c5142713313d216d0b2529ca1c591fea201180758016bebb0114b7190613dcc17663b34e932b57fb3c0f4b39eec13e17ef1dc3b8c5c997540f28a558046476bb31bc88d1a627d43b8200678f2a0982606a4a9c597e6f9612c22545f48dc633d1a0dedc2df1cc113d9ebe00839f7f57801dcd12da7fef14a0b2671699b41cae69edf3dffafbfa3464070489c08396fb6c47304ed53c6fbce942a8461fa102eb5779210b3bae27b35a19565484639621f0b1807020aa46827beaede66767dbe903376690597bfd554b4431bd9f54885c2b2d224a69ae2a72eddd68382c94dc51772c9b22a0f07275cb6b4a7352149efda23fde20fdc2136de0b33c6e1994a597162035b368afea8de82ea97d543890eeda899b3994297c5feec069c2a4964a4ae0c61048b7b73330c0a5fbc3dce1e66fd7fed3c9b8154d2b05130a63f2fbeeb56492","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
