<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83ab90d5ee4a1d424a85aa766b545e2f3a424b8a6d427c60973cc4d8ae48f7b6ea31a0e3617c4ea96558b1f8c721887cdf9cbbf278193db79ea548d7d248f9c19c120c78df91256f31c4d43e8c827a2712db3f03891107dbb17a80f1cbb1a85f0ad9cb651d073f05e47022a9f52bdd3a3956e00156e7c17ea7903de06f3bccac7362c43e869c2ff80ab7042642d162052d5ba13d824766827b459b33aeee11138b7cbf04ba4704e15f63268d12cfa6354d2b545728962430ceec552e997111adb638b2869069dab44a8eac89d54e66f1cb34c8a18bf78ccda2964a7fe75775bc52799d3b68f118a920452fa2eed5fe59e7c4a170dc4b0a727e10d8a894ea555469f1a609dc215f2537c05fda372b1be390bf4120dc5a907fd5ff285a6ed3ad2a4caaeebda7dc41b29eecd38549e926e1c6036420afdd0f9447a356db5306d1cbcd256538166626e140da68bdfadbff7819ac6fe6ee2300d41b5bab35fb67be8be266a8a44daff875324c7e795add52653e70425a8ccff0d57b586d49c712232926a1cf464928125a1b1a49d7dc3b2453f076ad3dbeef95dabd74c88d43113bd3ca78a1b8942e34f1ed32b01bc02cd7b8ed402e067968bdf0b0a09218b4dd988174cb557df5ff83c67c410ea2a129f2a9f5b7577ef96430b4214f5fd8ade40f228c7883447a23b05a86561838471071b6371d59fb57236f24e5d1ba36d76625be3e2bef52b97d30c8483447c26aa88c03e3e002dc9c660007fd220869d9084fc202b3ebb57078612907e2e8aaa316c1e73c78ef52a1ce5d9316526dfb6584e5aa55d26fbca009b2e1a982f028f0e7f0fde694689362139811565d2eb4349dede025a7cd284a402a98da9845ac422647f206de4452701b9a0ce6d75179365fce97c1d254dffdab4ac645fafb9a7249dad1e46f8a090f3ca63c6edb435baf0a3ad3b6350fa46c4c42b520868d322b51783ccb76c6e1cf476138904d4d8f3788fe0b232b549ad4797e52355f4641f67473c7c8dc08a7f93d44682470b8fcfcdc364c4cede576e63e73899b5d63ce179cd1335d2738e116f097609fd3e894e90b4fed20a60cc844cdc2102289c9ad3126beff895e9ee57551086dba9f403c0c359403d266d56e08c27ac85e645fedb0a59ae7e26fd81f71a4d5f7d81e7663ce83c9caa8ea12b8e7def1080677d1cd791e6ad566d21b34700d354a492b131586a31390cb4e3f6ac2b672f1ed944f5b781c1814c72cde50b8c1528943c8cfb17bbf401594f19c74b475aef7eed6ef9835feb184bbd1ac7c5f15a5c2733ba56415839e6120a87816e6da01ceb76553e56d1e0c13cf62007d9f408a893c5fb4908f477402f0484c405fbaa22561f0fc461d47de35a7d1a5c724527d56ee599bc6a5ef8fa2a14511c0f9ddc219160f13764f7599b386e9505b8fd45a61fa96d7e77adf1b95126e11e166fa496725695631c258b58bc34989e73d78a88273b3e60e4c3ce548a2055de148b868b1464fc7c61ffefe2b83d48a6765bb3a38d0cdc8091e89c9f0bcee468827c3fdb1a994ace18fd6ff85394de7584b92b65a5a7c661048aceeb537e6b595def1b606f48c2605b045aa4fd94ff47d6c125cdbdf8645b9cb60c48ac17c3dbccf44dcc74f4572ac2783496da15d980b8460832dd8cc6ec78444e81319254646af5caec3114cd87a4aef17d10297c5eb3c37b9b1f809ef9285a7b84c54c2133febdda8d6784d99741b20047eceeab79095a4919620b1254923b8e16f4f3b01582f9a095dc1e644d75d68925a43f9a9cf31ad8d11f38c740dfe6c0431b36903bb83d897e0b184531454a13372ec723e8aec8322864550415417138e2edf80a5c10f461a15646478f89a1005485d86e25fb45595980dedc7b0c1748466b801e76f7c3750137154fb2c7ea6858f624f17b24287d007af00a4725f54f082a6f2f4bc4fa1fb4f8f08f9dd133c5e9350fa312d1fb089dd9dec537cf1eaec1ef0cf47fe3c504dda11af8bdef77fa2a7343e5ae157827d975f375b8200b4d449709e97dcf5cfa801fab51d285e6be0cbd7cd72ec6606210957eac7a4d226f7c1f14214b612ec5647c3ebaab7c7479ad32d8cf81137fa56f2084d8f78887860bab40e80edb9dcb9979e5ea7eb5f0253305c65eac88367d7da2b145578418fbc3af6efb5580f8eec41f150004583428e3cd67acd92550a12f25848190063599677600b6a8aed6652a58713255e6e40814acdac7f6d16a33aebf73faa844437bdf9c544346e15d80ddacddeac16609a10aeb3f8de953e377834a856db6f6e28c27db7ec08d9b7fc2fecc06c543ecbbfbba6cc850215fb2a525ec00df88905e551e449a520858b3892efaef56000fe049973f0e3e3783a624e5e004fb6adff9d98c29936a7856db389bf52eb10075d84bfc815248614f0b00e83d9aee23aa809a04e3fd0d46c95c854525072c358e129251453d9e83e0d5137e73db778ad52e14094e8fa42809d5164991dab7c1cf5d3cf2833bb95bf3b372f2e54181b5bf9e68fdadac500e5f85fb13c0b80464461f044ccef74cb9e55bcfe3db4c1ea3984a7e960c94ddcfcfebc295e17249245953f511e902340f0b59adae807554b525444dc1dd54688f235253934c33da9d917dab42dc8c95006f55f781c346a412c8ec0d770f80f822201e559519c55895ae2b2356e4d5b0808859eb243a76bf9965d4e474e4d2558f0094380ef1b8040ce811695aed2ca9d66bd29cec9237a70bc7357308eaf6b2720b1692b9d155e0e018d360ef4fd78a1ec3502d7f283e898684c48334b5d6898d3983f8424571ee2675fb1e50ba5d5c540abf33760eb6c06a06ea2f348d334b8d9ea6b4bba7a4a1ba7c551508dabf8d646488526e11f8d9439b6f13995db116a1caabe35d27d4feeaee1afcd97f68f4f2e5ab752643e8a4df134a572a735ac2d867239d2939a9992dd91f08cf3ebb9e376930e6d12f7fc8b23b752f327f3b07b88a3f442408d25a2aa28cff0606d6c4b449460e4364fbc178a816bf415f68c8011910366fa8c6ba1c40e306362f526ecd39c6ac7bc1d8859aae455b70ec326c9525e1fa91e23705c13f9d9ecc0b29a776363f62974d2effecff5c15cfdccdbf41ad699afde09ad67304fefccccc5772830d99fd63d4cd7701377fb692e96986411c61e09aa62f3a9defc4206e6820c13dafb6c0794ea3f9338b2a47822dbd948edf097fab342db443c438142956e0516ca3792e79af73f16045c47a8de4b6afd950fe56e3e5f9209537289df8767dbd65b0f5683b55f27f6128aa70b992acbfffaa26a773b5d791a328f6d5f6bff4ecb074c6c11a18e31b03a0fd54193ab568cbaa724bf483ae4402bc1112a64c251f09757e50529825161e627b2a7ac12aac05250e9705e70be9dced769f19924937df21626933f155feba9e11e1c035dd8deab9369a6529f05ca2f77e7486d4dadf175af34c9c12a2177c89204718dbe751f2691a90de14c83cf27646970b012b5390ad356ece2137a76b9eac68a14bfb1d7c201b4e35829ce6005d044f866a9a62df3981fcad4052647229ac1c1f3c20a9c94b849e56d464d27b722a22e0c87b105098056bfa45a5dceb70ab013c2055a23a70c6fb2a0e2876a4af2bbf3bf14dbd94f6dfafcc74a88e8969181eb6108fd53efd048702fdcce9a85254ccd7caabfcf10c909016806ce70b05b0128114066c3e9fdde5cb9775f2a685b5a6d6e4ecf079ba77c0eb9f51b8ef83c0e23a510acb942e7a396e35da4c83497bc30b62e498d6ea6be12e34307c1b1207e87a9dc2c7324d275ff3a470e5d6d2b1a34c9e715f01adfb743f5ea3af67df7648ef3ccab4f19d7244066f29950d1088259b09db82315ff8b5d73be63957701d2aafa82a314eba722bf5a27f17c374f174a783e6e6490951368ed782caeb6c5431af26ae7c25ede9b16e3db61db81223d63f3e82dc3800b6969a21131da5bd458c5d94bddc52558fdf3aae25ed222369dd34c065f1b9a7880a39833278c23761c1dee7269decb2fda18a0edcb59912da5ba8097022194f4830484e7da28fa2f1fab87fdddb7e47b188bf706be5ac2186f3072f24f10fc24c650af89e4ffb3adac8f254e84d049d2545763dd3a025b1989fddafeaee3e99fffd562b8c52d17e6412c5defc2d376f76c911886887575732a443382c00fb260e394b6cbf2461cb37958f5dae1f0ff520a033375384d94487bfa46d097123c0030247871682d13adf720ab123ab118b54b57d3f196a774b58fdde4140032b3bb184d348db06ead1d330383538b5dd308341fb2292be5739eab994b5c95f72d4389e8f1abd0d5b30aa5c9abe5c91802f778344410aaa3f18ba9cf4f5ab094b6ce34b130a6b5a3c5395c300ca1e6b2ba07957b0a440c96f50e0042db89a3ef196fcfee1b044e03384b08dc1cac7b399f0a930106793ffd33c9780b2a4b39efe6fb527d9cd2d7916f4748356844cb9ba3280fc822a4843ea4a2ad3b801278146acc7d773629785716d98097b9af27ce092d4c8d57d7e0d8f4335dff75c2bf62819a6dbddffeb0e9c1703420674e58116e8dd4ff2eb47413e82df6e9e35ffd4cc32de130dc6c7a9cc58c081dc375b8695348bb1b8c5fc28904b97599f466ba627157091dbd3f8af1a5925a48370e1524580152d09c7a381bf871ac85aa77873839ca5b911dbcd42d5f18fc432671201c3a537269fd8466e079fe88eea32f97bff55b91337a4ef6122b060805f60fb7e641a42b3f19410fb1a551e795f94dad29c7aaa110b599812f14b032c6af98fca3690a17fb5c1f38630088401123786c8008a271dc8873f7c7b825950a6751036910efe28a1fe2f43760d0410cd77c260a321027516ac2e83f88c9c5b840ecc42aec4e3dc06af43f8053267692d7806c787cd3ca70af6da0ef4f4faf40d0017388be8e60f6529441a159ae4363a2a149d2b689b11a17c8c044339ecdbcc54eec120b5ffc1c6b1b4201d01efa02dd4305f43511870eddc4688395bdea4596ec43084c1e71b99ba3bc0776f7e99fe97e2bf1efa2fd0b3887a15d177b979568568a34ea19c067b8ce525e32d5e6577bbacef04e93a38780d9107afc1aefb5c794c40589ee02e698bd0bc346830d7880450a8dce85e7d19dd7d123930d88d8bf6813c4be3245a79488da4b215a509cde9969ad53f75bdcbb4fe2e44726180322c07d726ae6ce7d6fcd72eb3b1e7c93d6085992fe14a1be3f0bdeb4fead8576b01625fd5ca147ad1e3dbea4bfa50c45d0592165b59c7fa876073c11255d5c0e049d6ec68aaf7b5bdaa26a33ed1be23be106cdbb40d166e87b243687536a930bb6f8522f5035901fa1a4426c39b5c4711a160b63aa44c4d9f90ad299a7b62fc42b716c83505c77a85bf670f4899eaeb6866b7a9a3d32289c86fa2c2468d8fd75fa64f56a1e1f92458f26308e9a79e8febbb9f5b03c4ddf94fabe771ad5ff8f3d564b2727cd2e1860381aa28b837c3162744ace1bfd1f976c46aff62dfe989c9bcd6ea9cf1ecb476111a759acda834847710c9b9b95aad77d25d3ac415df13f4ec52122a8ff0d5f84943b60899ae1dd39cafda8c654519021b64892a6d1b9fcdea81038b263b12bcf65941397e4b3ae59a3546a59cd81f20322a0182050217e7c9aff72b6066a818f495ff3287c9c6c994f080adeffff4e286210bbff5c93888d4fb5d6881f23090c4135d03f69acdce3eb7813d21a162d4db8b8d0fea0643077506ed9196368fdf59452ac14c3da036c997b05fd3f6dd86e1579651eb7ef48d30fa595ac28f744121ed10be3d1fcd0f21c9dcf01f3c67665d57ad5de460c0732a160aef03e1e97bb27e41545e8c1ddfc7b73004fdb1a033df256ce46ca57b579de5c04a440e281ec00eca0072baee341a730b32b65832537b7f14c604ddf3463405b4eb66ae3facba7d1ae43e908bb00c6ebd75ba472fc26fe5ac1e1e641b0e7eeae62b5a678bee15eb35b9c846439dd9a839f7755aa605e4e96d70ff60a9000bf60ff3ce20c1b60f0a38c9ca900c725b48ff791e3c1ec3b8e0ad3731472e57f25c0615949c5f29adf61e9c9394a5034228dbd963a1ad2afdc5e40bb1114ac6005ce9715f84a088fc010b3646a542dd8ea40f3d4cb8e4aa39e029a297566f4095e1fc802649719f31a95a518d4c14deebcfbf77aa47cbf7011b030b6bb2af1252031d8cec58849299de3aee058ac098935604e93e63b3c45e5b6cffefb1fc215fa6255c5c9b8721207d6d1edb45f61695023e3ef595735f79e8ec9513a695ded0b6ec02018828c2fd09dba434b4e5df1fd120cdd1bd6e4d79816cf142527effaa4146c29fdf0de1e4df4a5ae04c1398aa1b10fdc73617adea1b54449a8ed4fa103a4903570297d3f551344eeb3d5bfc15a848be8de6883cb71f8139be1290c68a4ed7b8c0bbd7ede797de0ea2a6fb325e60aa47f7f70bd316a4c8af8df1311ce3f858d8ef018d7e6f2c9bd6b94b34b80afe95088f33cba03eae1d0bf0ff2b0a427b1b2e90da77775f6b048b4c53250f62635d706de4d1a1b1a4fdf694e88e1ae0d46a45814d6b099b61cf060701e58e03adeef97d15ca23ef56f8794e79bf196f5a76fc4a628c007853907f7616bd12f09020cf4b339e57fd33043aecf980a2788376ef5cdd594ca2867d3e6b5922a34f886cd71b5caa2dcc2d71dae360fd97583fc1f4317d395916a7d18c494a27571d04d3d5d72ffa08225c46469dd9fab0643c4e4d007724908b294ffbfdd7b1d4f9accbed4f910484b5abb9ef4a9f86f87b48e0af6544a01affdb74dc2f4c2f880550d598b917856dd64be8a16e737bd75c74add6bfdb226e21886cc283d37ff8b81d08293e1e09c100fc90b9ae3e8ef119927375873486bbd4159cce2eafd114824030d3def2a137eaf8bd28dbff33f1253ce14c95bfba9086891ebf9040e025894b442b1b006a746a7cfc78a239e561eabb34ff70196fceb9e82777734215938f34d9060ac23e1d06337c947e4e87e5f7a98e51ab18ddd666dd5ef618fdf7408f0dfe19180a0f3642d50d8958f438b8ee028234c60a82492c147d0c742f339a80a03c4644932311a7b333b7f443c9bf219e63b6747cfc0e55b8dd93c06395e85a6cba95ee64adfbc2f547fbf5b50882744bba53cec7261bcc8f62cbd2ce862508311b7fd3f437b12139ba52c127a17cdd6c91625f37b775d77d7d8c57c3f171474db32d5997b379a34fdb951caa48840ae42f78405103d063289fe808413af756ed2e3c114dc6170771dad48c9690afa23c900e29247c61992d7aceebe8777068dab5717434ee36b6d97af6f9dbc3d2bfc260b603877398f81b21ffd5ebaf4e69acb3829a26fb53235ac4779649a38248023355dae6b0a1fd182b82ded6d57140d82702e7bd7bddd66886a0179182f6ced54db1f1a40b14ef9190066e2ec78cc91293a76d09d5aa459cb1f7fdc7ac890f984f2a68a6ab35e577f7c61d43f9fa334163442701ffd1df3c941d047024bf648a27c4a77c3bce40d0b6621cfbdc9e10f1b402b4c399fbe112a7c8ebdfd7126d1fcaaa65436c313e8e46136f031df6b71efcfec9493b772be23235f1a74ea900b53eabef0f344edf9298249907a0400f81c47fa439e4fe14f744a390f99a1c2191ffad2b0299c41ca990c10e23bf3121a4bcb5fb9d7c7a710e586fb80596ebcaf54ef21e782a346382f84e8100f2b073e47085e39c82d6d509a32eb306c29b6be277f2da515e6e03d480a9c5627c0332619fe19f4f6014aabf98a57f6dac2d3fd68c8382d840d1717e90b4f45766cdf7f3de30050e48ff4fbe324d4de3ad13f8c3a5def378bad8dacfb97ac234e43cfcdd3c09cae11a8924e6949f28b648b7f25393e5f1b89b5c63889f0d6c80d010881c59e5472d7156f9f47562490a014728587bf14d1c974a6fbbba2a1d8c3fc30e35919b4799c0f84eebcdc640ce0feb3e741d3e9875bfb02d4af83f198592c8ed95dee2debc80dc3244ed677370b58a9774e206e3934b9007163f69b4b570efd3e6c27751f5fbc766f6cbba3715cd7833ac253a87389e9c5773d5055991ad5efa44b3452edcd487479b9e12037e19089f76da0ce45404100b50b75e70789954122bc21719b9323bdd28d3b9343e13f9df7449357a30532f8af12476c2707dfc44aeb65ebaa4f6a5760c09bd453aa27c23f1fe0a614e33741d8851885d6c160c12dc133e7480f866968eac0044fce38c2289f16f419d36a2a83c63f19ac534d976b302588e1e2f759ca343a91a7258c720cfd65fe7912d16d877c07f08e185a2177271f6c8b47ac85621760dd2684640b1cf260ee913109ec97dfe1dc461782cbd8155d1d5f1bd5eae6c565c9437b5dc8617012e191da61c5b816ba15de6e90907a05525bbf35073d83780ea1f5bb0de2d4fe04a2b706d4b24389313ad158d3d1d9b95701fa3dfa15e9a0a5da9b94bb1886068f45a9f047bd4c3b073078f7bdbfd006a545fed9d075b69c6f8bc3d969e7f0942be7b9d8224ad8b9a28a4af4ada9e22df1c57dc0ed8fdb24a2076f9691f48d078bc8a182020fe4f2bbfd5716f9df461a765c965c2a7118ae0784099c6603cb27e0f314fc81f6f2373a91afd22cdff331484b1281b0afd6c2ddcc48183d633e9c32571b9b31c990df3b11aef65ecb6a5235cc7c92e529b6bd346e83b739c60523f6f850fdd9e0599ce0da50790a5ce9d73030210f4bfbf3efc3abdf49211083fd3e9ace23c7dfdfa2fda3fc64c68eae1b2e50f882d83733fc2f08a679b94f68f4cf9d6983f374c5d961d69407c13b537b398626002456c27c4a8fb69dd71e171ea19bad808261cc221840fb44106a823a8e573bbf9ba30b377248bdf1a68e21a6d895f30e1a77b56737946b41f04c05f131667f8fb5eaf553c4b86dffc1a5e4bf9aeeac528afc074c0839be896f8cff0b0c5f45d93eda6236d5f0299c0c9c830f170066779b8922d7f1ddd3cb49d5ad31157ca09ad0f90f7a72287d048b937f420e16516a7a620145c671bbe67e0606d2dd33f26e4d5ad4144707b8f2f46537d1ee79a7c2b15e34efeb45179a05100257b75cf0dbe3c814063d5c4c56e3cdc6e268e1dc27da092c675601b613daa55a95fe16001423057344dd1bf16266851bfad46d8739eb5a9236ecadc8e8bca3114558336467f65e1a66b2bc2025b4f7d4f6bdba72cb6079943f35d1148d0c1c8f74abc0c00e96dc5fba6975f3147f5421ebd3307193c4a929b10f4b5a136f139335e48bcf04e6db540e86fc6ab28b3449dc21bfa163b89fe4e6ab61f53e5babfd7c583e744b6ca3013ceb2ad6906a616a283f9a71f05d72299fc99dfd7f0cdc3f2af44980de490e95cc4cec9cb5074ea065aa8895bcb93d8c5652b54539a998e81a18d70d73130feb15f2d08cda90df25a909239f5755778bfb99ca572ee4c97a62ab1d8dd37a99edf7975b0989b822458c12e114d355795a8d8e730a229c8114fd76f89045dfd9a74ec29cd3f9e6e56a59b9717d0461cd411459f2334adaf680d95c5a7398cd5a2c8e9174cdc9d10877e819d5de1ad233df21d3ac7a62a25731853cfcc49b19a8ea9a293e53a52f1b292c65939c8b99315f07da49e4e3404ba37d7bb6c746297f7e14969b4913979733d1d0ddb614b00d4e4ac35e2b6342297936f16c7818083a5e4521ee95c7b4d36717afea0f2a70f70ee2f486183ca069b20a1b5635cb6c9b5e77bb4455b59c3937cfd340aa4d25da0a524c46a919c2999fdc84b0c0fb3b3ab7f9901b4ae9cec81b23436e6838c734c7b2c1e845d60372491a6ab09da7548dd8dff55da71a4e9f55f9134556fec1656d6cd1253f7bb30627d7f30733c3ec3adf38f46109dc746379fe06c31fa2de3bea2345bbd2e37e0a157652dbf39a9ca44756e734d3452f3988c72f8c15b76cb495814b8cc81ae4aec9eac1b4400a1246ad8f26c626f9dcd40643998ac995916904abc4f68631a6055685721dada4268e477407b83549b39c285ed1bad3890ad2523a559da8d8e83b9342e408e952abfec93ee4b1cb0e19d43bdefe282e515537070bb7e463fae195986fed4f2fe946e094c30a7f6a9b8d0b6ca66f703fe72b7cf6e606f5ae5b6bf1bdd0436ee628bf19b5e091508b5ec2742c0ec9969ad359ab40fc82a684fe4707311cc69521e12280469a65eff056a5c4d2b7255c5ef5d15da9b42f73ebdaac9e782bf86bdf309e71c5bf1b81078cc06768cfe78515642b711ec15ad17715ddbdb2474c4965eed9cb088d989c5fed9db88505621e02055e8a64a8fe018f0d46e6067c4a18994acaff672dc1d439f1e34ec3cf16b8f5cc2a0f746eb1a6fc83c9abe9119dc76441a78853a9c7a992fdddbd218cc4477398221cc72bb8874b0412c38c6597a831655aa05d31c6eea3a629e5e1e4c5ca7150dd673ed43ffeb42d5cd36394abf0f90e12edfc16a160568a08d65efc04e9b8d16e626f53f2489d5244d863cfdc67c5e1b19d021f4fd11171fec8c1d4b1e1657f795638c52b25776740cdcf1de55d56614abe57355a17ded9e287bd9c5fb344e892f717d40cbcdf20403dab973859131ad698becb79979162f5b4d764818a8e3d323edd5e3fe3f52db5f8ee221f59bbbc92ece9e7458cc56e9de8074e96ff931a9630c298bf64ba1c8a15a189e883d762c6191c6e419045b618888de1bd19af980cdc82d68d58a210572f0ad976e67da9901241f5db5c3e7e7a34af48a0f18872b0efcad59c5d682cc946044300869fb41693cf4a155a8c64120a15a05b20d313c793e10b0eee949e96cf7c81155638286c9b12cfcafad310d73d8d63dfa2751c685765d7dbfaf87b0305f8548963cea968883d8b49ff722e82d99fa74770ad5386e6e8636662661cc2c7885dd670b8ebf60b198667aad5c6cc389544b50ea255bb7cfad27821d3a3f860a8b64ed0786e7db18182740b71d10cb3a45bfd93ba54cd67cab2fdb94f65633569ebf0281fcea110618dc13bdf6a15abf0fc56942b3beec11e5342319d5a5d51c90896f8b6b606ae35404bec08db43fe522cf379a32bf29de5c3a998efe5a675f756953ec747a64ea0567619fda6e017b93351fc20cf36af42770cafc40c0ce969a0f1b97a50a25ed36606cd163f351888b6f9d417bdd5cbf8a5e43d966a0e70e6e4410cc888f656182174155db9e3800537a4ba8d4f7f2575522d8600891fad3ef9e0a857f189e4ede12fa659a0f266d5c5aec84cd538cdc5d35cdb26d24c6faba0f00fe744a741bf07bff2ffd054e5b6110a1e2bf7385b79dc2e799b6864b643405edd06600ef292a0f974f879c55075bfcf97dcfa89d4623b129c2176fc0f1815a5bcfb4a62c009b6f131293ced3b89b5b84af745763f266b1f76e53f24f4ab815b9e828d5d1b7fd231dcd850815675e7c395e764ca24d5f57ab2e78a6b159352b8d5d7546f48f32b1160652035e2e1f632f2aba7fbb9ba2f8993a58cdd83de4dc43beb853f058613fa57888aae1dfc9fb60231e4c082bc07f77f49306c1e86884379c2ad44090a4b28dd4d920d45b106f52f00da1456877f18190d06f5ee8e5f8dc95342ca312e75659cb8c1edd8237bfd2890414fd61d1a1a28a4fcd2d7b02a53a76e83b0036093215343974b8924fa36e580ed3fd08382df9a9e9b31de3bb9b78300658e4ee134b4d1492989f7b3ebba37f4e67b671dd7b082dd19cf06a409ac050c59705aa5a9fe978caeba3dcfe34c6866dee9e7a0e6489a220a4b9b04a5d4f15c90d2edc27fc863150e8503847e0006ca5a5bb59d2fd5275e7418e10d2089432ee3179537d1e5741d91f8ae458ba694329a6513b9984a7c07e842f9d4ea3292a9585b30e6f00ddad6b71911e241afcdff9e23acab4af7a7f48324c3d45712a9f4e5b28e64b33c8b2dc3877601760131008c9227a5dd40d7f17bb1975f178351d1c4604a54b09dd272e0d684ce2a94e0c459f4d33bb6f30bfda3349bb9bf7c27b993827bd328fa85a323fe5d4e546777ea15a7b3ff857a7671dec3460a83655da9e1be35db610f616d65d3aab5b23fe6279ecb2d4b615a9e88a7c4e7d08d14d3c0900f9ac86a5063f6337f4adb0af61b5de8b99849d9fe47726b2bfbaf15536dcc1782cb7cdfdcc261fa3c14a5faf3d604e75e7af72626f5b11b2fb2f173eea42804e92454711620c82956dd1cf0cddb98d5646e77f25fa2145430136d65836633e267e1c7d6c832c9d942fe7c4049a322fb8a900394dc1760813a6f2be16ab72aea34261073f025201e431a0d8ae3a325d7b456180c28e9e44b94322ec8a5c2befdd2282d46dbb212dae38fe64a1c6a819f3ed3375c08efbbb8c98e9c711a9ad63adab34cb6292350daaab0e146c05a26c0853374de1679ef8d9cef3c49a844a98d4d898977433384afb31f8a70ba3037e50e69e08b286a297da2130dff8d2c2491debb5c5a9f0b6e100854c8ed3de4e13fa49e8726b98f2900c0fcd2de84d23c61ee5cb9c97db76e3542d0a5127897c6bace4ce5fda326799fbce2ff1442dd1983181c48f9478d81e17a6659a7f727642cab27612afdad6f5d69f5e102d61e30de048930349f6e81510c12a349072e6f024aa6cc34a92e063b175a126158690762747d8aadccf1c2e13b45175d87dddb926a9f7fe53f97005650e79b636d66d5d6bad195feb0c554783f1a3c60f0dc118c181324f70ed0c19de4c8c193cd0f89b8b7c049b596fcb9275aff048c449f5b1ae893f45c0b094331ae8973d9be6b531ef37b5353f271e38d8123f1561201d5cf2c1448fbb798863d648516ee2c3439feb251902003f45e7221701ff88113816aa64d0505f28cf087786f235c62d0ef67973331100170f2f4d2f0a27b61adb6ca2661de83829b9631f5222c844cae57299ee68faf9509f7d1f05ab1f484c39a624fc50bdd4919ea158f073aa674dc19ec19b2ef966f8c5279c9a01dcf626acfafbfc88a75057946a12a2f46585c47a8cf73cca695cff16e8fe86bfff2df0563ec0265b5c6c7be4a41f1bacf6d5f1d978d611591424186fd57aaa178964c35241d351919e76e9c7ee99949f2ae4fdb4b565846673d53ea733b711f0bb37ccc68827b3d148701ced845ba51c0ba847041555eddeeba5f09647b6e3f470beaf4e558a2dbbe8bd69e8bfd18c9c39977a2128cc24376c685303f22abf0ba5391e40980bb9b2892f423ef98f214849186ba08beffa4326ffc97eb6df77fc57e5351298352603c3de569786efc1a1e4a60640b1c713750bd7ab9faf37d5f5fb0f1ee5f5d82daea95fb1dc7383c214e629bc20835c82ba0aabdb4ec8da7821cab8e75fe2c10463428340ffbfed94018400387f51d16988a3ae85b9f83096a8a85142643dc0b02d75c8f8eeb37249ee8f367e0951368b94be8422fb61ae1efac28290df4f6bd5f2b8058874eb4c1f7e19c9fc2c888b85ea39d26eeb45883adb092394bbccc423bf592076adb7be349ec4dceb304395ee49025c93fdc409b4b4f1412473c0c5896dd3c06d6b93a37eea90d71cfa0a6d19a604fbf052aad4ee5e53cab54c3277ce295cc8974300b56b573d23dfb72ff72c2bd36a2e8c6fe8ae46279c24b20878eadc36761edc0239bae719b96afab4a1cb766e1cd02ef5b3084e3cafc2dd8ce285e8620d95047180a05b9345d9d18b69609af2cf498726dc7b0a90ee9f2239efd7c78552ccec84a080def393fe83396cd5a9f1adbc43a5b4d97f1a3c4fe23f3e9e38df0e6355f6e47d23402150204316b1e15360aba61f4b7d8cff2f692286dc5fc2929a3f88336ad5939b8afe72cbeedd033b93e2cffe0e4b57c64a4928766dc42a5ace3efaf93b59d5b98f58972eeb62e76ccad67367de928ddfc2a9b4c2254cb1cdecf9df4375ebd1c3fafed22c8851382ab6e837779b1c22b7b269a4e7402ba5ee240d7f520944bced07f6fc8456e9dc113380d0c0547fef7ef11bb70608e14cadaaf003d803a3722b97d84e13d0ce6983a7c10b718681d040aef6dc24fbf44e6a4ecf0ee0bb14300764e1721d58e1f23cd9d493c97b4db9c1469633ec6457229e26d2fb162fdde81ea0ad900b08d33a10b9db69f3446a9e9602e452ba32a40749ea29c53347539889f2f3e2b903500e91eacbf426e742c60fe3616918bdc34fa4936356be0e17a3c9dabae687b9055cb1a2a76a5744195407f47b3832bf9b05868417e5f39561a8f5a766c33963cd68f6f79cc93db157775a5ec4fdd5cb07f1a285ee33af2d6a1b50734b1fee5b24592de42e62fbe60c80a7465c2e50ce07b4ed875e03efaa134615dd04278e0b6f47d9befe11625bc57879142939c21bb3f08f0f2cae16c42cfb3d3c2f3b6811becdababbee18a36bfe6b475f684558577d875bd47a3d14fd634982761ccd93d511ee5c06262e230cb56beb29f73f71ff69f961014667784381effec4a119f3312481b0b6f12425d57c96dcc2f986cb35313db45233be878ea7cdc15d9e98113cac0e6e8b06e1a55289e261212e7ed1c8e2016d64b18710b4a2f9501c7abe52ce4ea985cd5d6be5bda11098c8054cfaa30b06eb356605e2e5976d2f472777ce647250ec5dc1c94b7df0566358e0692e8a679a454cffbaab471de97c6f1c93826692a473fc0ce695fc76bcb367f14fcdf1b73dba106a2b2618985c8c9d8278fe63363267961161be624d7778aee2f2b0ce35c0f715be56a44ba8d51915e4f9c0a5b2a53f134c9e904cdb1326a2a9a322eccfb6e30b6525494c572ecb6e2e34d7c546e5e2a434f8176216e98009683681caf2ad71dc821f2be609578126850e8f17c266ec93971eb42a7eba3adff67e8959dfa05f101db5da81112ed8bc1e5d90e0adcda1962e90c1facf38b7b025f269bc8f54a03b7de637551886ddb41644ccaa5d29bed9fa08c501f11e68bd9c9393840a7832044b23388c900df3f59bf2c813fc99904754574ce2fe87c18d01f22bbc81cb61d0ff2694d175f3743f084405edef68bc1abc962a3921bda2ffa50a4672b05027f99baa46948e79edb7f2b1a328fc13e76a7065662941632db3abf64e307e7cbe8f4406e5f9411fd89940d9d6f73e65becbcf51651668d4282e53783840098a978b705e966a92b62e75afb7c4448103a47cda12d627446f6d1c0d60d645f8035aefdf3ebbe6164d54c5dea5a7933f6ab5d3ed96a15ddffd17f7caed3e3a6f06c6f2e0d7dba6cfbfe58af4a9209db4e09be2f8853e3a9a5c56069390728cd616aba3315ecb5dddfde22449e4e72e14e8f995fa1d9941fb7cc1ff22d33fa23e10d84f7d844af35c07ab5af5904a4cc109af7d646c957fb3e342ce9125f911f4d274659efca3b96f48f05efbce4d89ed43bd3a7403b568c012ee34b0e5648603f4c84f7aa7d122513ccd3e9e7828d5244f50e50db05119b9fd63707c0a4a537169ab9c91946b21648c0dba470068a4c1eeeca670b18c31c3cf8d183189326b8dd0088079722ccdcf8dacdaebd6bb979b7af688edd434356c89df5582cc6725fed33923ce2abee9fe65da5ae6b56629c54a2811eb304e869414e0bb04addb78d885d76610a511b44f6c95500d4bab21d6e972578c8646d1b1e6f4c894c60186fb86fb772b6eef6ca6475c558a693432049e02ad5f5e10c3bf30031bed0f7805352986a9efc486abda81073614a0ef51584cc3ec18047eec2b576a62fe8729995232af86c2798183025f0d10ce174762ac966d28009858fb1ae1d6e9e28adf0af26dd0d5ba18e14c43774b3e949893cc39041c31ccd70029e29417630c9f056778bb96ce7fa8c555e242437e124825d701040927bca7c158da2fff5cc26fbd1f46ab2c879868c060b268d8432d2f17cec2dd35c653d307861326d5777a77f3ca66ae2ed74cecc67bc8a3e015eff688dbde74840aded2038ca23c0aa97bb95ef78bb1923ac29c85d89c93233942e03e45fc3744069c3463a6e4582050375d5198db18a19504eb98a559c1a0fa89e21393e1363734355b45c5c7ac6fdf24f4b59ec120af81d629cc09d0d0e3c67140a84fe97921a6ae9b6ae9d6d107f1ca9789640e131b30676185fbd9846efd7af8cac61f2861f78fd284570d3bb6cd1517ff220ba617caedff27b5dd988dc68eab52f5a20cdee9571d1adfda014f694d4096ebce56f3cd9528985122709eebc2fdc2c6ce40a7f896a1cc3e3fb9ae38bef5bd937ae5924e19917d2d474bc3a07bee9211a998a0ba6f923064a2fcc24e247db580a680efcec031e726ea9171d03dc20c90c9beb032782da9a4e074e2f837a2097bb5f8c91333f9c6c973bac4df857a538a78070e4e50f8d9e7efe9f907cdc4c4c5df786a1e98e8521e825422b6c2a0a707ac734383c52d3c26a412995b1e97faf544cef48e8eadfe3c17d443120832b0cfa5e69f3870a14cebd50e00186765b05b04aad4e6eac17ca91d5a7103ff003f3402a1e220461b470b3e3f68d311384ed8ee76b965f72fb42d12b1d66f810c03dc59595e39ed8a78c7d5dfb5cedaf602d9cb98c82fdf262151f04d0c63879f842b7300699b11f13731f59e59ae2ea77bbf1cc3c118251352fcf83a0d7cc1195c140175378cebf3d9f91ee3279cbfa4b59060e04cf648236db47593dbcb68b8c29ec588fce1dc522ff1287bf6950948be06b7ee7a544f1f63b90d92be041a9261cb01da53d63dfe78e8815f35b85d704321af4a6d7b8a16db17bae5ccba8535b4ca3dda041ea902100b8b0b94297206140360a63dd75c502316f1a3f3cbc995bb2d73c9ac88e511ecb20d7fd88b224b4e313cd9c8c90c9187dface9adc25adc715e612c45d2a62f5e9f14500419b23108232aea42ac43c85bb99a56e03c152fc5f6445b2ac04e906923835d3af3de6d76ed784f4c13e9174e5cce27d097864e83930f399a7317ff9ad020135e1b618c854f6837338af2cf0ee9a96c8e059533ca8a1ebb430031c1c0bb1f00b92f9afd2a6b9e3296f29732a1cbc0a4cf63770d5d342023c009de8a48eb3810e4ce96dee590bbcf69093c4af170e0ae251993eb0cdeb1d954dbbe3fd8333966230d255d849eba5591990585c38048ce34b40d9017482c54b238b67945639f0376bb2a22d7643653b6b9abb8ae6dba25a455d16450881212389f4988d224dd8ff3e58f18817cc0234e5cddcd151b538950d3d89d0812f51fc2f3cf1256bc97efead8b50c260f49fc076c1671dd75d3f6fbe0f71164ceee18a9906a39d90219f56956015173570cfd0618eb1e7fbd68dde3c3a0a568319f50e622a14ebd5f3f8cf2c433addc95f21f47383eb05cf2e06424667e7fbf9e430ae0e14ca84772cbdb88a2920a8f1da576e5a50876dc690033e77d84f3cd6f1ec838fc28caa9f7f6eb26adb2f3eeb7f51614e2f0a1bd59353adaf967336ab70656734feb8c1cad1b31b952ee8120b046a0179c0b18100df3d9f0b13631d82f23cfb300042bec958663a47c88ac1e1e369652d6e8e75006f47c46107b4ede36e91d283d312bd2c4708bdcb0b49bca084ded5fb419b08695debecc99475a8655e6f26fa02dfe11d8b99ccc28a3995c0d85a91e18d5736f2fcb767ba5ec2ce03cb57043b9f7b2ea7cbe89a154e107163e05c90386e37857ebc7190ee62716f3bc5cfc3af01518340deda36a4d13fd1fe980eaeeedb70d3336f7fc786f6f14b6e914b2a0426022adee7759f7856323a2f86be48b85ec4c814a5acf10bf6f92777b38758a332893294fecc48bbdaedb9f6b29ab25dd8d18c9cbc40ba5881caec1d630878e4656dc2fbec6285ef69b70b7257b87a4d78240e370dece05bf8a9df1df5a1e8f663ba7aec25040177823300736fbf2e6570e32e971a7d07315bfabcd564f0eaa2845aeed32b8b300d51c7b74a9c2b4f7e12a5258afd638fe2d13422cd8a0577b2ce44ddea2ea40225c6bd978f9a004d537b8f45f3442d24d8c5c1ea9240aa77e3767bebfa9aa0a83afd5277bfdcd7551d27ce4bca68046bd9555a383c816a90fe522b99282fed46ca8e764cafdaa151dbf92ab626b2badaab0d3d551cbd1de4fcfa4dcd400b5cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
