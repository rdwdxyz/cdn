<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"792a6ad395fe37aa8736c5c4d972ffa12af4a16a33c6c1e760440c2118e5468782d7d5b6b276f4f7dbd4af49472d9b6d756639c00559b6f4a7da0101b8ce9a21a9cf994c216946beb919c6a0e02251e1fbebe982f76b00588ee8a5de274a0afd099e47154e165c4c802d9065b9d8a18f1225fb6ceba42a62e0fc1d211dddcdba80c82ce49ec0b4345c6ebaffc9fdc42eba26d548c3903dca117848268a5070390d2d1d3b769fa3c7a8311d849426921e1933e95120dd8babe8b5200870c37c2b089349b0424ab7005f58ecc227b406d49fa3483dd8c029a98666030cd8d811b21ee5f71d0f7dd668eb970aa930b60570061d56069e346287179db3a25b5523d8c1c6bea555e1faad86ec91f81eb3425e33ff75c5b9a825a2676862a8ca8181e2c3b4a68a064cd84e8414cc49723b5d3fb855bbc39a648cb7096b2ca8495671d1017598d6588a35df9f18f1ca65ffbefbabc51669b1061999731ba210713d2984e29e0a53c73d8b43a7fa22790d7d3f68b03d784e11b64626a98dbe4360cf25667b8322fed8ad14cdbafaedfae14104676ff1591444b619cb581cd6da26e5a4252a48b0e2f74c6ab1fb413b62c86419aeeebe845eac93c7c5122ffcebfa43dbee7016c7bd8eb3f8dd3d5ebf592e8a962c2699f0c1ac39d4c6006a8e9923f57b31ad9ad96f4c1f4d9018529dc9fc1de5888ea5af15a265c744beb126bbb0d5b206991d99a7b4f2ea0b9469678dc5bd650c774b307ebd299931bc2f72ff3caa4aff206be7ac4e1d780fa6be24ac8d9056d631b945f679ffadc9010f6549186196ed44243ed0927727b0767abfc35a77fdb729957f8cf582af2572c90f8d4884b7769ba8d024551626a712838d9f98fb2c28b02427d7f476f2766e3178f50cd8dbeeeaadb8b8409ac529109bacacd5b6bbb9f6110675030e32a51552626dd5d0f1ce5140d30063d2221cfea684efa5c5ccd55ff2eff68a0aafdd5e4fb1a565af2754904232f622211d8374d4a9df126d0c621363b5cdccfbf7e9bd9fe7f3ed353092bd0b338bec3653bc572b8e4d4186ebea6f0c37b3c6cc552149ec87e21552ccf2ae681cd294c616c4691be9e372723ff547282f714cf636f06d7f13552fdfceebff9dae7843a9f73ab30c76a1484e018eb821b8ea1fde0374c50b56e06ca3bb0c27e807c863beda96f17e3aecd91db35e868a3374a253be4e757ddb8382881815b1c769b4062ce0db17eb9a592485699acc24e4b167a3854a4dea424df2bd55adb48e120a39b0b32ca924475385680eb88a8f0b1d8f57d7f5aaa993cb607fe65ed86095160a5176471fcc0e9d94d29122a73253a6c098c6ace01c3c41945c1952bc0c38ba85e84a7c90954e6d6958a50ba6579e64da28a9a2fdf27a4d29f248ce461d3932d26d3e6d610de1c9fbd0cb30de37d9dc9d2634a4f6e83db02fe6c817ebf12db9a02e430804328882564b4b7e0ac979239cc48933081e8b341ab23fc0b49826cb03c1ad9ada3fcd9ef10a722b0af61f84836b9fd79c162d0d877690ffac67809a1fe8361a6ae6df6097c4e890f9c7f1e2f83b371e17e22602299659410c11302c7be94e52384f6eb74601a4ae93b4bcfb633165b12c7faa20eb2237d5f9c1b1620c3b11747358222876f96fdefac75b2d8c6aa3886c97de4f18b4a2b1d899c025c1fa8ae6d9545029ad4cbdcfcee6dcfdcc6b9d0d575c4ddf249fb2240caf0b73dea2cbf09e07b35b64a2a217357594cefa734ba46751ecb3741c1ca9eca96593266e7158f74e4648cf60572830d01d69ccf8a2ee578625c353c11c5c7da3957f8c90e55d99cf6e99b30c9008eca625448494a158a9f2b362ad775dc81f13ee8ed469c260c984a30670a9c1a8aa81e4800a686dcfdc624461dc27b460859225b6bb43cb9e41016bc61750fca271bd8487e9560a034185c3e0b56551e7c68bacddc550e76df29e4765c2386314f35326a5fb7b8d0ed1c625dc8c4b9a0b1bd1d3d254a558ebc3edfffd1ad9752b65a0268f77589f22e872edc67066d866ca426e9d496b4d4c8b77c968900be37bf9b36d685cee327a27bc29d85efbd6b63aeab1045cea28141c436efe498d35b40b5434b0906dff61bd97e4a797c0c0999644883a26714ad90a0e75c8c20361ae02851448d9075702ba6f1b80a4da8cbeb8ecf91119d98710d18d91892a2b663aa8f39ca9ee5de72b79e07d5543061fa9bbe02ec516b8b36ca8a0b97b80dcc77c7370f8da48b47992d86982e64f195e5a8f133374ca542ca3f2bdb5e7c3ecc76de5719f3f4782e1eb326c977ae5430c902a34d0820aa0a0d78aa506b3b5b52a23a1279a80813370f693a05747e05686527981dbe54369a02063b298cc6a5722793cfaf3701e836b94102862fe829c9557110dc6a5695e7bf37556acf3f324418714998cb0ed984644feb23fc4eca176b4cd18e7df0ea83acc91e6bd23b73e8ebb24b5ffee462c90a46a48576d40ed202bcfef5282dfade1dbe3f93cd904df1b5db9365240b0b035fd305f5cd86934348b56beee1e4a4a7292b49ea842ed54a56a7bea6e38150dd83b880974422d841c6d892e92ccfb5d2d33f36098c94b480412d458142652fed2b5eb7e877606c8555d42bb31adc3ad5766f0f66a0798f0fda4ebd050c094169fa11d27391cd490ee19b3ded30d9043ee983ab8ca859944438e2551bb963fff05aab97a2932e12aa00d301a6dd3b90e2864fc34c09713a76a0242d7f488dbaf7743cac0ca1122ba2eac8f9068d1011ea00ffa4206062b8c1f27f25fc5158e607c7f8ac3c3c265aaaaa90c985b90f50ed209ce0d18b03fd892e33f83c43dac83341e63de155253ec28103b332af0ab2af6839b885ffe81ff9bd2f17d754da36c6660305b339e0ae4253da39e6c098da953464fb6545f603595deb465d655106326680ec8f4bdaaabda78feed76651ae2e816f6a2f8d3fde540c9b29a14a9f40ce4ec9726d08946f9bc31190c84e4f08f9cb420e1b9fa0e64a22dc0d230f18230de691d214bc7c6b010d32e1e3f4f77289d923ace7a02be07e816e8d78725bafbbba14f6263ca69007b45b8a256ac79e324b94220b7a6ebae2b901299d9ed6921ac8cbaeba5b5fee5e876901660f377ba6c046e19e09edd6ae4fd12be7f22118a9c702abe41e5c1118e42cb8bbf69324954ba54c7350daf009542de5ac3db20027f15daa9492fda97dc3a0f43bbd497b87b3036d70d982479b0040a935e685bdd1d3a369a2449bb7b410166d5815e3b9b5ddd8a5d4fbda8b667bdb36c58165b9607e7bbd5f5fc684f13d4848ffa4d391c111fd368c2cb5bde04e1dc378579dfd1d44d67f84376106f6187a8be5633aa7bfe446d92408fee7eaab63be74885d10faa6d73592074c602170957cb58f61fa16ca9a2f79cf6fd3db0b2c0a1285870faa3da5329f074bed5109d596ec9713d3d6ab21d128947abeb425acb597de9e0f876571ace3ee0c030eef3e5f80ca608fdac9a9dc4d40e670b750e64aa2d8537e6185e65a2a41cd43e705a53742bc9b01c905493f36fd00696db6552fb549a293d1f18ba7e740470d5c343606311244f65ec5fea9e623525ee3de50863c03aed005b2ffca947afb03988d7351c73a84e67ee371ced3990c5fe7c9ead49d982198e753f4ae54acd74d2cee77d3cb0adc58565155968611896966f642c9c6d761b3cc2608c830d1167cc25118c302ab9fe379b1f7f1d950866e6f25bcada72b833a4f95caa84266bcb3fe0bbf70395da1be2e25519c5c4c25d2977117134e8131dea13a066c610bfd767005493761e6edab04790b9bd3eb20ba98012848790daf885caca7621aadb8e995ed95d25e3bea90ecb33c671c8a970263ad2ea510c43f99bedf3f332d4260ba73af694d080968c032694ac43a4988ae70b0d459cf0187e97730c5232a02bc80b4aa634d84c53b1ecbd069a2c8e0e4eb506d86ccd52e884fe4b53cfdbf451dc06ebc68dac5c92fe3ddd3f53c2d6484f5963e5192dc0358e4cb5f9453d461f7c39685facbe5bc5e6ec6e1e2339f6de7b1d6aea23fe418f5c1f5eaafd1fe26aae87dcbb77e62e0d88c5f70ae50074fb60c6c064a78932435613f7b34009e1465c603c3d0356d9495a156ee56f8055426c7825dd2ec0c9e70fb39c7412c7681667689b23686c109402417d4f4dcef5352d15a6f861eadf499422e1baa95ab7b72809e23c820b1d0c5a75efd5f82b7cf97bed428b355d7007ba3f0ae2d3a5b22adb31dfabb3883a37c035d5c461d27f4bfe32c436fed79931aedc57551dd11c9e3596f8cc3b3ff2e2c0c043492ae6c9f4b1a06a42a2ec4f19a90ac081a0b335cdedcd96bd6418c4bfd52a738a2e529af205a7297d0d9beb3ab94a5ea2b5f93d73eb17c5eb2c188dc516e4932a3e855068c3e67c955274e07378352555c740052c367fe955a4dc5c28c946b7ae231db30fc02840de1bd4703f7947a83cda2e824ad83162352914690c6b4ff717336e94e87aff7e720f9b8045f2a1b5d43d1be2f0b3bb947fbc6ab0928f1c3fc561e7fe068d07be59428809deb006a121ac2b86b9374afcb12037164fb2fbd2ba65346fa8870cd324c6436d611c86fd3f7a71fbf8e30387ea4936327c09c85c12ec10ea30302f8052d22dedbd1cb83cdf9844a360c3c48293b3b88b5ca36a47291b66f60fd99ef02f12a25a1dc562edec405854695458335ab1e5b3d739b8d914b2dabf73eb3b738dbf3ff67f6ca24da378e8d668d4e839024a371f17af4e77aa18cabe1c5d6f58201c7c2dde0a54a188986b8fe60ef9e9350c4163ec8fc39562941c076687bb85632ac98882b93a6c3f460f51b35015314b43a16f5f3bb3f634b054260b221f7a07a6ec9f3dceb5a98832b03ead8cc8753a01e8fe363350e5aad0089c37b214e43b9cec7a13a2e693dbf921aa563b3f58187734d4c58a9fff30cbb9e72102621edd7bfc3bb0bc530d1a93300ec34fd16f388928d139bd9c27011d4152f87f89f7c9af00dac379699d8eb16c1f379b1ab67cae756edc271177c4c1dd73e2f6534364e2e96f005ef5d61572ddf1b07f80b7d0d8eea4d2ff7d3db59ccc554e50547d41f561cd3f96e6fbcacafb6439b088e6ddd2730d663febfba99a473bd3e9bf39b30100b8acd789f3a973d633ac9ed61e9f79c9bae222a8319e618ed0b35d87637e9020222bdf901df2154f649ca966de550692b58fb7a98dfdffa5bfaa2e03dc827a9bf0314db2cf64c825587b79774d68208b76f54bea4dbd47659cffe9278d5aad6e9cefa8987cfa0086c23487efc5c49a1ea5453e866f8be8b5a79178af8c6267024851577af72059222dadc54e01c3616884dfb06ed6ee2122669390277d7267894d162ddc8f1afdbcd8c9e8b6e9d79c4feff0a39b76d768bf0e46f196961abd32225121b18b822fa9724d967e6d060d692996c0de590b2b73a167e41ee4050693098a91a14085fa55c9fac52e48d8e61480fdf82a486934a69f7020fd7a48bdb8e42a95a94c885c72047d7b3c8cab197b0afdcc7daafc38824873af7ffef2b450e1be743fe8bac18d54c076051cac0f689e962e9cb3a94ed4ed3b09d4792142759616c9cfc0dcfa63b5f431da07631812ee393c83b5ab118ecbe9dfa05cacef2ff95215738ae9f5911b05fa1f348f2091a3927d7d338e9a0621505dd285de7d5ace8514959dbc7e6e37cf03c47bc27bc2b24f5dd6e6e7e96d67064871930e114aaf1fc2896933c0da7878f1f9d85a78dbb47b824a6e92bcf51bc5640383855317dfadc51bde2b7c9d350f5695998ebef1c8e642b2f51d278c63feed247ec3aa5d67d63156b21c84b5a2c942656744542825d49d8c3817a17546e4ead3e43dcd9bc5a623f79f7f240c171f1eb76557f79f9ead3b883e327d9b7fd12711cc699cbf33ff9e986b36072edf57e8749f50796ce473767693fb3712ffafb07a3b7c2a023c82675eb82e2db9dbd103fced6bfc7f3e52c0917f8deac4e92823c1bcbe7f2766e2a7377548ccb27e9fc4727746fd8571f9940655c7799aaaee7bebf4b4e5b4363272508ff60bdf07fa374aa268b491a47e96b0763e80bf3d86596ff755a640476aa03c8e10750eda108a35b4fce687c0c9abed8a28a1c536e203cedbc554beddd3c41ece141c1053441bf84d5bbeb93edea9548ba0f4ee4ce32537ec1ee9bab5725b6bd32b5824ae42a5cd173f50efa2f14aa939f305dd8b07082d4a2fe4d1fefb193b2a39e4d9699124b5c004dd9ca5209cc924b1da55ebda5da926185a493a5a149dca64daaf48bf21cd8baf49bc5bd2bab7703214ef4ca6d965b47aab77f9f44f9dc97988b49d8f96070cf42b96d656a72d0b09e2057b74eb35d29f813e8ea906390bc8960ea0bb2b966d4d2dc7e6f7d91a484ba3fcf5a75a49b157acd2743d67744c3f0a3de30e04547f10bd25af0b14f194f9f131c57ccb40132f6ebffb152bc3dc5de6f5dd357e9216c62727f9da020d9b17fe42f17bb4882f4394383a50a7d337318ef845ad0beb2358a6430748a4a11bee73a0e07e6a7129cc77fdcba077fd43adf467dc9a7656eb7b3ba63ce58d62f80758b36bee16b6c52913c4efeaf22a148b60f56c27e26705ad8c2d230b3e6d91483b064c5e59da525b444e6fb7e3a9159e2b76e90143a65b5deb38e18e37312ce40fcb8b9ae5b2d199176ef56605ebbae150abdc4e5777a8b88217ae666e8a0ccd315321372ffe31e73f69678924520a06fef8227363bde966b3e4fdc9be6552e5e50478bbd30d885d081b63cdc0df083e9811431fa147f1de619c9e5f54c67e58490486a905880909d34deb0bf0449a6fb3ba079ec015081258166db199eb221e803ef1960a6c107d73f07b26f7d5feab62f76b5f76248111cf6a07b257efbfc5de97362b62dd20b26932ff04647b3e96837fa20ffb725d2d7992c305125ca3d836a902f5e048fd6fbeae1ccf031e884734ff6c3fe539400a8e93b1494b076ed2a2f9da2a6b9c9386ea81c5d7b09926a844163956493eba6d419773dfa08005a5361f14c892041b45eabd12d1490e0d05038d3dbc8505fd33c4a3146b016cb660f0b081a2a1f30b1497b97900c5b80bf44d77ca0d3ba6fd2f6764c30c6ed08dd707d6c01cfca02744bcccc2f376bd4b5232f8a5b506a602fd87c6caa8693351f6905fb5497aaa99454b688f4879e76c8d6385ce9052784839877b84cabf42903e2027fb9ca54f3aa51ee9720dcc98bb4fa3097a1255f0ae7141c617aff00875ee6d5d21796941d4afec943f913b36b310f2ade46bcb8839a651dcef1be1199a87139aa04b943ac2cbbd4cc22626069c172fb0091f6c08760a5ee960311124ad98dd158441a2cb13ac395507091c0994c63d24e4e6346cafd499c10b1319afb10e276ec2cd7274d4fec2ef81aa192bb71ecbc571a875327626dad018940d747fdcacbaa479e89d3460e504398535cb6541c1916673ee33b1638b0726748a8646d34a7e968899e22110545085145e09f08924abff2b3fab23d9a56cf11194b23862d36e433ec402e60d9cc603368b8a145799b06b048a4e65d023369aa271049a6870e0b34244e7033952088b9d5bf88c38b77a30d3bd89ee55f07a758d7942408e9651abdcefd73215a5e8ea7247469f2164dcc75a49db9d7757ae786344e600d2b34f0b9a8313d12e22f923ea0295090ec8b1e8d9c4174517d8aaa6a36513a0674465b3ea65f0725de945a740345a078737965d76ac718154e429a2596c05f7343deda00e1a64792b66352803b5af4e16f063ab246df4aad751856b32e4bafc87f87af99e3a5bac428f7828a64235fc20a3de0813e0a87e6f91547701d8d0cfc82e373cea01cee03c6acd9e8d3acc890b13e694647ac4014dc5160c06f9ee5c5e1e1b368d381bd33acf59518366169077a763dc20a18c4a87b31ee48c72395a858a074caa654e6f9a75803f4f15b7dfbcdb4fdffca6ff1eabd89ad2074d2d625454d3352819322a8b2328f12df4e1c01fcb6e33140c584cc240b3c60c06ccf622823c035fd35681d253a711225f2624c266205977d4837e0e08400e2826a0683637954ed002ae9774009581ed309438be3fef1b5dcca0141148481a566340dbebc414261241f66c9dba5d92d582750fb3f5ca6b04ad7650bf83e965d981b004cc89597ccb926cd9db2deab62d74457197648732b15250e7399f07b509d6defbe0bef56c21e1a55088033b066c3ad179f2826ae23841e39ec1bf83fb504b9b83d1dcd33caa31e99013c1a1ff30ffe491ba0a04519ae48a05a3454b40ebe458b10a20fff6fe21dd44d94ba1cfdd2c21859c17cb6ec72f05a7925b91246fa4dc178f13f795a4b8b94ac19dcfd4eb077d7f8f2443db54e2262a88941af7530dd188e580b5d08dde8daabef217cce007684c09d2e5404d3a983f12aafa239cc3ab25fae94c686fac2378de0ef14760ad2eb6b7fc086d14ab14f425ea5017b9134ba78f3a1cf6a05d8ca1d453dfc0ac215691813e2c47c8b8fba17165c1530720be670624804db0fa1a331756b787b5a8b9fded9faccd420e41de1a8c85cb0df209869bd04c409fb599d313d918523ad5e992f29f8e8ae5e9803cd83b99eea4f72f02993d9a2f418c25cbb07c4ac80efcfab421397ed033f91626c15c144eb4a940a332e5c9491866d4428123099dfd0815e68cda5fdc77b7ac919ca6c5bdc954c6af03ad2371251c3f8671234a861a7f0a5e7597af79b88b12a514d4b53bdf358955fa85a5db180e256fc81f3f98f8b42d24e7a556cbd424f4ba2cf14837716759d4db369ce4eccf96116339500bd57b954551e9b817749acf5af9f47d6861bcc4948f30e945d29138e53352b0bb755e766a7571cf2c4aba7feb1884dea6ff444742bf697273f6ee2cc3aa16ef4cddf373f36777c7941cd456c8d654503447f3e3421661c3b1e2f18915a1779ed45d28b3caad3b90fcf18dc18577dfa3e433260eb44e8b0ee9b6e739841caa6669c8f8acd16a6a4bf606b3679cafdc2dc60bf828ee4e0c9cf4eabd882b699917700d92cf269cdfcbc1ac3f8a592db8a930b0cd5cdae84609e20a153b10498dd83207b4e84e806183da6f1cb1bd75228e59916c198fdb8aeb4452e895b0cb7bf57f0322b2d839c5936a0e2c368d76c076923ba1f50f62104c781e9d95aafce601d222d11ff731e2572fbd382dbc6137d37c37058748ad67c7b01d32cb1c28656e9967673d86f118be42758a30fcddb0bf5dc412b8c88080907fa1144dc928446c0cb3844e516bda3f9d57aab2c3a2bb1d31fc087f2484f359ab1360dc20a676d4b301e48f46493988b4f9c825cf3b2ab64e115c53abcc08a4dd6183246a5d410405c0810a58a3268ad8a9df06135b3fba738974d6603a61c6b7129ecb17bc06b4678ae095d5ef4529f64e105747da1ac97e5b7300e4f021a6143ad36ebc32cd2a79fc0b890319f411ba2fc66f9345707be6e377ce211c2cdbf865c4536d17e2f275177d97e609e11c08dc995d9c881307d5eb3730a849c971a2be1d985907259d1ce9eb7b4b60200704fdfcc5bc2234efcaae263a76d6b0be3410d362f7403c0dddcd232eeacd9dd8b5f5d20e9c57d2fd757bfd7894bd05c96fad6a3f50eb072815e8a4e5fe619c16437889aa2f48121c6422015f09d7dad949d6d983bb8dcd4254a3371d19c4a6c35062ffbddb1b229b44722e4eeea061a4b53b2f1187c1f778779707537c305bc2f4c48476bd49f14d36c2f8c6df6813b01ee913549f0a0ab471cf997cd591112d58c25fd478127785ae169e8901b1879b6066d38f4d9b407eeb3a00ce58431edf65de63855f5ee1e5b28765fb1d287d2d9f7e6cb61f53fc3030bb9f727454ecdf830f27b6463383a2d8c1ca8fc5ae9d254b8814818725875ab9cf82bcb4aab56a5c7ddb6672cdccf776da14fa1339fe5fc80b9bd6146afdf3acc5995820d80d23170f715799f79fc2db445ff842fae11d26100d2319c0eff5008a6d57ed1603356cf83b1eb31bf876708b3a77144fe753ff3eeef046343a82f7b26e2a6e74397c79310b4370ce80c5c811ea41ffa45625141d44e4440228570060ba9dbb056a8ed5445c9f4d92df83cf112cf670a2368a46115712f90b19d7b979114a9a80a0f81ed7eb6523dc819ea86926adbedaaccd8f5a1267524599fc6607efd694ef62b33d0c3494c226e739e7994ffe62e2c1096df899379d4f612fb81cfa54e5e51baf8ca7cf941e2f7d2483cb9bf1a12249c39b58210e8751267c861039da50614ab20626114ebdc5df2ef2392934dad8e02236335a1fa96683aa85d66b32ee88b7948477eda8bf0dd9dea811957b260e1b2b94814fc222115b738cbaf1f5245c880ed3c39fb467741f0189dba2d980129c29bcb2739811b37941ba51d4a1785fb1b009a1599aefb37496b51562cde206f07373160962a7368742251a9edd1b1982ef111c8523a0fef66f26b9af0b55c6813c9fefa55d6ef113cfe5a4113ab378a8a0075c1a592c1e09fa000ab3105d0eb1f55558489b7837df13d5716fc56b44d8c4731c1d06ac946720a447462bbf47988e60cfc738a2beaaa3bab4a386f193d12183783b1168284aa0da4b82552f73b2b1677174c409921d1321a8eca8aae8062524a25ec0d12ca7a0606f816a115cdaeb21dd553a4f003be763da60937d70e04bd07e8493e68ca14e704f19caa93d3da3d5e4ba985a4c177415916648ff023b7c2a55478814504b07777ea73e7d4e7a7aafc8ff93f5c93665f890aad70982e9a1ea4d633292b411b6826b942974cf3fc5c77a5bbd4bc04d08154d942ed63bcfd14438103128cadf4fd17e14e60634db7074ab1a441b100df7980b54e49e4c655923fa0329bb0c1378488b1830e57c7aed1eb10e765b00f598615b3024502ef6b728dbd1c3dc76c093c9b3bad48420e42f753bf786699a0cfe44dd1a66f4a1de6344de474ca53e8993ba4d9319950adf7d2a3c6d1860f469fe467d0cbf1a2f31973aa8cdfbc164083bb79e580186e1c941a5f52efdb7e5b63b3d02aeecb2d3e428fe18341f5433723d4801bb6bfc383e655cedf71d2fa26566579dfba5ac8ff05eccd702f77884e3d4cb32e0a7f04ec1cf65e6c8b17af3ad4c0178afdb8ecfe96287676cb1ed038bde8192727bb44f53d616edee68f1a8eb148a3f52abd6f70bb3656d486082b318410db9d4b46a1e89fd4eb7313fce33f15e4db6cd47113acf4c9e7b9048ffc7235830c8a66f671cee76fe47a5c52c99092e2d20b0b65edebbdd7d2f4776aeeb5cd58341112f5f240ac8ba87c00fb322ed4e2b6690371fafc30ee3d6ea28ba776212ac4ef486b175f8e3da8e98016ca76d95f33982b76bf6d3ab5f67d50784c8298c116142058a432782694aea01408c75f8a27b270c1152dd67605bc3088c98b11ae06ef0cf08cc27e859304e8c97681dfbdbd4da21a932d1ee64c1d69a6a82694a26bb384a607cb52e317de085e32a4246bf5bd934c0d879bf33511c898e5a16aa47f5fc9423b9c012338ac2d426a9e08a032805ea31f7e1857b9716dbb6ffb1ddafc662716ab9e783239b237792e58405e31252687708fa58b01a022a98d81f6452365d23055b195c82fdeff72a7ccb74ca16bfc3e39c48430d43d4b3bd3d8b60800b955de06907c4465cedfad10d824dd4591dae2726e504ff5654500dc602fe5482f4e5a7f6997a7d2dad499e1b90f17d7c383c38dd2425c57455a7d240d93302e8a33c87d7f44238004c27ceb82fd56458a21323f321ac8193860e7235a33a756f63cb0aea1aa7738ed589568f2dd10d02ecf897093bbba3ff567ae082146e89cca25b6fd42c0858bc824b8839b49851057c5b1f1c5deda7779d6ce71da404b965d446d7744bf7e5323726248958543db77f0214eef483d83c89f6cddb189f23fd8d69cb320023e9b8dfe4b94eb6f327f577129ba724745c83c6e0058be82e71850cc0d4d4472918df26aa70f179dd5ecd4cbfa00600179c12fc9e16f03967df75fec3c84920e328624813a890386f890132ccdb63aab7bc326c1eda06b7f4f7b6ce3192ce3954a588bd1970b07a381268397beb9b3120eb9b30bb716efd9657f93898e11eb1e31e1a15c0787f8cb3fd6ecd8fa705f2d8f31626453bdc7c3b042d2b6865e8e679eb7e342eaa3067c965e6de77da42618c2e390b28f70a14f4035d71f9afa260589dc32297b528ab1c94f433745c0c7956976f43947418ced7c1325738c52f111ff544460b8ae58927c9f232668a844867d624e16bdf9b7dbee82c95f83594a37cae1e9318a99cd797b3cde1e5a0e2c872d493ac4f852d7f41a9fa390547c6402aceb8df151dff6c39f1f2c4b65e0cdc338a70086dc7db3e600d93ac89c5331db2476e755822f3e51c13ac4cd9cfde1a7dda5fc50204ed7a5492d189a36ddf2aca1d1f0ed591a6a6fd8156d29443780e95da15457f268bd9f8eecd443d6290672d9af21829e223aff6e3783a5bde916ce51f04b4a1cc97cf4ab02a282d65cf9f446b660d46b75596dcc414482cb828d9a43bce48dd7db2a8c5851491928be5bf43fdfcb18b790a20e2f5de1ea1747e71afc1114f9c63bbb24723e8aa1fdcb4fe343b405f3056d904947841e72f88897703acf64803e0029c4760cf94d22f70d86beb4c7657e3432230ad41de6edd2c9dd14cf5dad6332c869b5c50522f12e1e557495dbcdad32356d71a6224069cdfd7a1bec4399aa996e5eb01cc75ebec3439956e0641fe52ea7be171c81dbeb7c3afecbfa65af46dc20652d44990907e4d2087df4ec0bf3554fa59ba8aea598cb3d6a4b6125425f47f55f329180e5e4a2f4d640fd79a42db9aaf3bc0e093b29bbaab4039e195e109beebc825700dd0319153a6aa71e45ae8e9168f21b824946b962dfed1bf8e638e79a6f9f6da52e49c683cdb00affcfe1e916ec04f7bad5d14264a2dbee62332cc86970727062106028446275dafdb80f93bc11a3ccfad89d20cd5a19f4544d86677cfa1a5ff93575b9d6f8d574bc2b3cee501ea78ecf5b84936640ef19b523f9e9ff7d8681f643477692053d83bafdadf101037f28373bcb75401489aff5c45bc79ad3cb34b5978734ec0b7d5b3ebdeb0c8ce95b909aa3f6ea18dcefdb157d9c49ac670b9a2bcdecdbcbb9415d98f4a8da7384717107b70f2b4f06204f35279c7c87c75a53d2a0bbb332529c0bf96ed9c800af435bf1f5f8b730ddf6d4168e8cb2d8a044acc1fd42bb6965a0fdf8219b37bd3218c50f3e1b6f1dba7a4c050bec131a3c4eea1d0f69b615c678284fefb1ec8dc233f7d842ca2cbcdcb26aea248dc5b3c0f645f3b5b6b0d4cdff4577591056c55e7fe40fa4a3b9027f13e7884d67980ec79ec35ef9dce35b145a2e5412f870807b5cccdd70b140de23a400d530e797def06e667054aa3a6cec7ac64beb93a304bbe6882b56ae1332bcec6367a34a4b58fab3a30de4707da182f2e9c9db6ed56e75ff5ad3f72647ed1ecb1a256a11e9d8a8656e1131f03f74efaf6b8061888a584565e5319afca946463a7988ab15970e1eaf177e00ec57ab0bc0de7e029c244fe381744901c02c0af8ea6ddae8dc20accf71efec830e72e3b2e3b056a5d27478f5d42b926854832f7be51f70d47eb201df87a66b344cd22a558c7ed186401f2dff7e4fde95991a1a1ef4c09ee4283524a8c06edda8005774d96efa604408b8b3143cb9a4848ae8e2caa1f35bc1ace4879c0875f6a5f48e4681c62acaaafc5c1c6262f9b2092009ef01b5bd732a823e365364bbd0c4835be13afdccc38c4372bfb0b3c87313e33fd6361eb58601332d4fb80f9c8cca5316229f68458b7871c2388806f494a54aef0e253053b9f611d298039ce7b6cadfea7b7d12be4425ef6f62819c06ec6004db2c3625bb7322c64119c5ff824977771e16058d2b7a34cb8cfcde4bdfc42d6f3847c668b9d2598b8fdc2846233b91418b722d1b353bd5a55c14919a58fafce5c56162da6dc58ede73dbc665f982ee03d2815909aa74fa768708ffa923322f33cbff6b5dd43534b3ab233572c03f68141f2f865a6086d4d3118685b00c2bab003b58ca4b1c7ecd4105f5481c340d7bd0c1a8769a7ace4ec3d7e65f2f40fcfb982cde7b53793064846075678dcfeb3fcd65474e58bf12aaf10f411d31a8a109840f1e89d5f6164fba4dc32f1c7d6f625ce676384e8e1e6d3a10c81c6a28d51e34c2735d0baa320b3a1b07838952e1c8d06c79f7d06b4b212593799692381eecdd298a0e2cdb8a80beb4caaff54eedafcdf57fc75519bd6ce4e3c14fc0ce9b3652b89ce3b5b432713bfdde8e1ebd9d69c60ec63de99f4efbb83f7b4577f97816331e9e13c80f0bc290fb5de63ab4c2f21c13f20e4f4d09cb88d9cd0c8b4cd9b5b0625105f03e4bdff32ca899e7053a6f8ddc1c08faaf7d9753c20d39e0a7c557304ca4ace46516a470dda22499a04d93bc5bcb25fb2bd6be1276b65e2a96943d6b8ec56db7c3c397832a11813b853914d06fad3049e256a9d26fd1a55ff990bfa83f5f1420ef001efb3df4c808ba54b889a0cdd3d94c49b246a574c56647019066aadd04343599f25b54e06f19e018ad4c58133690c3b25cea1379d8a0a12cb7ea6e0167110a49af6bfa4b1297eaeaca5fb673ab7037b1251faef7d78bd373dd0d079aa4d05dbce5e1895adf80b03ce6a1316071ea1925feec5d8b538c73ea427d5dd7069849384eaac0a9cd8194bd56c35e5b4c3c12afd9d767c4d3a11851d0222435ea0fb32cf66a7c722426fa70ec026dcd5a26212b7b76e31d5833e3216e8b903db7f8ebbdb264ef38885b8b736c56863b602f5586a2666cbfba38165a9a338c994df36826dbf312dba5fc875b04c59669b55ca66598f2c82f73b71d2ac061d70eb4971278e0e549d63366dfbb29eab88d4a26a34edc4c09b3ecc8d1c64a86b780bbc4c26e7bbdfb1c5e9a4e5cfdabbfff2a4af18cd9e3d3e205cb0385e2d07a4c700573f6249d71ea25a9bdd606f027f1adc9e327008801b5fbc7aef543d1ca8ae3ccb22e545fe80dc3c76ce3ddb8aa97e9a1aab0ecf273efa55c199e7bdf6ab21623eff3c1f6fad91302172d2fee8aa245ce98e435effec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
