<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8611e12874cccb41f054af0712a2c3643774a3b7450dcdc8c00534219318f44e42c939e60ed42256a0adce396871e95f0c7b48dbc28d5e3d67fc41f033ee30e50f82088ea989e4f5f4adfc513382b973ca5f7c2d0ccde48201285d6d4a420d79705ac182266de0dd793a808b036f8104b8f400bab690786aa4f39f39b6dfac7628c00587551e798e8cb0760cc30c3dd7f8f71f22b8b774f9829af530a670753c040e9814b743ac1c1d73ae4ef7de6599e087c5f6db423182834feda9bfec85b7ef128e010183be9245eb0043ad542df67431fa51cc6befe0f2ff501f371b33c01f1be67c36fc5392311500982c4dc2b6e992da41a6f0a51837caeda2fe026f0afaf4372227e7a84715fe915affa60099233acadaa1b18b0b6118b92636ca9354dae1521c7f3a0f19d32202154207f0ff32213bfe66712a1bea15e13777cc8b36493cd7ac13ae0189d47865af988fc5de4f38cebf998a93a73b7f704a6f633758ee54e384af6a20c7185c7c6eb21af1870e0b7d10fe231197532b544b18a7ee9d485e73139a507a8f4fb88a2b3a56fc88a8abfb746fbeafca55eaa45a301a6895ee879b7a1c2740616887a5c82f81edf5f6005cbd0ea49c406d1ed5a44b49ffb7b14580dd0607123fa6ea82f2b3ccb315d67bc3598020b94a6189203e1e4a3cd5fb483804f943f4017540e547c0620763d3906edf1a92b828f8805daba4a096e94e150a75b44ce5c2d4f4cc9ed7cc7ab475ae85ce70e25ccd652f831ea0b88b1b3d1d9e342b7d3b660fc9506986fe9f3ef97f2fe243240ad22ce745bdd7a57745c442377ee306a5b1b6ec6ad8267adbcd9f310720919531dc9ce9b474a548f0593569a09baf791dfa666fe21f8cb33e10d83a786e2340968eaa716e70c0c4e81a9559b75a5d2d029b77caedc5c4da1f40c9b46b881580009a231b5c53f4e7796f1fa42b3880ac75bfcb471c2ce7e5b070f848f9cbaab4dfdb15d54eda312aacc2e73cff62d1c5d5bb92f3458442da70ac1f7f014c7d2b1b2aa2af25a6687bd3304c6f559b97e39d3ad6721269585937aa8cf5876d985e103ae16c907964467f47f8de0880f23704cd8115ce8830734895e3b511e137e5428536fe62576fb0db17b8ecc29b61bc916820796c876f179b8fc4a94277eb6718f8997e9472416b23602fe1186d14e2ef0436f13c0c1ca413b2dd9e43987efdf077a332ca32c0e0ce50471147919cdb31a041ad2e043df1ca1183e69485d1ae8f35bfdc4675be543354e3bd7107743635bee9417f819e3099c5deee0973ea87b6c5205f1d9cd926a0d2b48de0e8c08e10536c6083d2c35322fb669b7e285ca3cb25105948e54550e4b1604881b05b0fdb76614b450f1778c9176077c7100f3c6802ddef46aa082e69a4b3bcfc36123570402e59b297e7b06f9cb9952ac0c7025a622022f2651669b4fe20a80d0a26341cd5105b7d02f7f85c2203b8e38f92a54779f04273858a3bfaa64cb0e80ac98a950b09c74b7aef4417420eecfd5bb8e5541a02bfefc8c5fe887103d2ee72e262a2b77f8b4fe76ab282384eed3c3b767deb3198617687bdeb63c6bd13c8e7f199a49ac990fbe46bd715b581aab004640e2ccd8e522b4a65b7bb1ec092d2edbbcab3e1af0574fd1ac112aca58b361e831252505beaaed58c401cc0c57ffebc4481bf2bfc800c31eff76196d9226a2e5c7723544c2acef68677b5570153f6afeaeb48dad341e2019711664f6829fd5d6fb4f8c67b36dff855b0d17275633faa966efa04867a22fb673babb24997b64c6aa77e7d0524aebcd76d2b398c4df881ed5ba4b4fe84b10bd0784bf8b46f6d6fc3a12116bc7911908ef6374f4521fc226b759ff27745fc38f520ff8dc9ebe04fd22c9b48b95b4c4d9934c019cefff84148c51c123bfbf0fa2807d51372b888735d0c84f2ee4fc224ce87441c06110b39caac74c486dcbd90e5cf99c3d87cdc9d03c8d9433201f4335953b6b480a35122569e052532dc6a54bdb8802564dc85a60436b0468ae269162f62f39eda408d9070ddd00e0a4ddd10e7ac8f992c966d033214df4a225fea44c1272e76711dbceee21abf5998c09f3a3b621f4684249c53a2dc0fce437f64106a348e138753637c1d4aac28fac9a05a141edd6834a99024b92df12569d5e4ce1e77f8e52eb95a17ac96ca18eb59aec682a74463c6f0ab2cc2a6123317ef09de7536858d7dc6f6abccbabbb9b0c7d394259f57cd4779a6c2c0db8303de09157ae540bb452bf0f4a4e72bdab01a3f0c4b1627a1723fb709eabb31ceda154d1131a310b2756fa3b74a343c6da4766825b381efbcfb6da5dd816c81150bc3474cb832860955c9e27475c6a9acd1e5b9dbd932f0b0c91c6b567e9790b446f40175a91fdfefd414bc4688b7170a0a1269443a116b4597f32951ef1e2eced53cfa855989485b08bc86f13743c6eee4efae3b4974af17eaa171286b1bc805206efc091c9e7fab633a876855495f3ffa45f44083db2635bd6bf8e662806c3526c847c70623eb2927a9aa839a31da2e3b34bf8d82210a9a33cd23b794cb5c209d56d85f9af415052a8c0f8ad86e53c7fe2918fb0524f2b90c4529b14b4304eef8203ae84dea59dfd050dde8bdbff3aba309a4c61e7bc04d2d7bf4804ebdba83ae55f6464289158d1503b9595727a0c5ba7d5ac5a4a7d8876c771b556e79bbe140d34bcd55e60e0229b52a5e4c72ae48fbdb7599659211827d52c3d91d2c4f8a531d8b8df55fbedb30825d62a849d08fbc4c51776dc0c4443969a5a5c5cbaa1b91c0e0df9a1328332d33e5d65062cb4eea2316de27a64011cfd61906385b152b8f719eb71b2d530b940bbd045ae9f20a3e5e0c7414d0cf606df3d131c34ed0c1f5afc48d3e4ee54509dbed41b02a812f7459a9c4d3f02935f0021eff92eb8d9d4900d08805e53a0c386eb6879d78523fbea311df6b8c0133ae15daec97b428c245372bdaa5c4c45b7a4a479439ce5158b24334fed35d3b45b8dc6dea4b4fcec9432a10eaa10b4d8420fecb5ac19c300bf83e10dda1ddad9635afd360c1f37033a8b4a37f4c028d480284ce8e65ec4b41588a41ac8b785d869a29b2962d9134626323b3469e3a9d76439606f8fc9e39a8f4d386cec73a58df9254f48b4bd8bce4caa604529c5b0be8d545382d7ff5def24fb64185c88d16ddd3f7ac957b86ab34d71122c04b71aea78775c6732aa0ef4545ab87f11610305a56df453e72e43d67c3693346f8bd72e9caef979ca0ede8d69dee82451e9f7e114b9f9d0d424971e001b859ac9c3696afd3b376a9d05253e7d4bfd964d1aa2bfee948a9cf01aeed445e3bbd2c2f44fa0af6919a5bf081c9a27a428535c3598e6b87b6bbfce76fd47a1e1eb8ba843da76e49ebf7f606533d5d052922ec14d8882b8d77096af97d4bb4ea7f31d657d656d5a50b32e7d3cd9fce5a036de47251af80b538ffaecfa2de9494af302957bb17bca8c203abf6bd628a805a9c1f7fa699f58669e41e0060c41f06dee0db94b52a2a930dcc660aee760263b89c9cb2cf324389a402825ac5cd0af6161a47ce9fab1fb24e93c5b5c1151de1ca665756b447764b1a044e00f92d75356017b22978aada920d485d475e6122b49a4965caeccc64bf27da665c0de9491309b22011db0db5e7436a5752cf6a75da0253f038b0c82885a8ad6f987da961bc7486c328b1a76defb2849cdb6c81afe424e9c42c8894f593c3efaaab48c2334772acb87ce6cdc582fe012c87a16258a2bd44baae0dc4dafdd2c074b4669e0f98b105e0a7b84eee97a8bdb590e16ae2e460c99231ed4e827e5aa6c7ed22d0d78f1e98facda8ee18201caae916eddf31f642cbcc87e5e70dbd92c3b9d6d88fba6f82885d8eea0ca49bc77bfd306dbe5912a808e399a9bc100c7afe9ef73553853958ef9f846155f06c272276ec860fa82baaa71528fa81a3d54b40f8e5abdd5a4f1ed7309256adb4a7e40072f8a74cbb54235496b963db14b7c64b686e31fe233c680889adac656a40efac444247134a8b4a7edbb2d0bb29a55bd89aa018a7ce41de20ba74f7ce77505b1034b9c0b1026ec72c6ad8114c7a41fdb2a428d68c96fca58dda3001bf7dd4f594b5b2fe685b547d8702c08fe28d2f80b6a07870e125b14d08d6f27a249754788c59ad3a3d3f2022665206dc350d7b4004de6ce03b2012f5eeb587d825b26cca67dcad8c2275677552ec81764c6ae960d3bbef895fe6c9296275dcd1047696ad7d218ed6c2b1698818f144ff09ec6006019b4b7901d1b580d2283d2016722af3ec9bb1f69c709465419233f6a1080a9e61c636417ede01a199971f29a1f4fa78a8817023238d80622eda2b484e8259ae7f9069fa510799ebd490953ed35c4b2966ae833f5fc75346dae91bfd6c02c1e14914d075010e84fc3e68315f8089b22841be54e48257b16ad1528d8d5fd07251bf4f304c52774f8fe268932f2308d5e3fb32dcd7723bb01089dad5492459827eb7bdfd686420fc810aba9186f12ccf026a363d2e35f79f6e3c80fe3f765a6c02ef68128649ea147edf166f25290e9d1cdf8115be013f082817c572ec8996db30ee818a6911bacd0516951771d74083d124bf93fbef796b05e7c2d92cd4ba12836f54a580c1deea9d9f348b1ea23a32112a518170307e0d6a356371ba72f496e261a6311c3f91a712303ad6a3838f92c278546817878bbe90fe1bd705175f169289b91c8510be807bf37d3efb9bcd76ff095303e411a5386816383bfb887d9a85eb96d8aebcd3c8fec42772da20f71f3642e9a7baa5665ea98384d444326d402bd5bb4ef7241219bfa12ca13bc9ca069cc061d86ac57668b9ac819417aad139aa3d9beac958f973924732c3a65d0dc6b053f7e09304f571c5e82df4cc2a11fad2ccd17cf041d18b215678f30e86a076dc91301607ccc2cbca83a2e0f6f61c03009e863a7b4078ed236493174d6ab27d1c211e62686b921365b63fa7b12577bd9e9ab3008894f15b740392f314211a5302838289da2bb20f9b8c84c070d6922f217219c238cd3ba3878f5930ad26f5a9284a76e4e3475c2d76e8d0bd3940e9b704d16209c69d32bfc525f96bffe6b03d8df296ba9f52a695a72d2b3b2d2154cf4888d0435eef61f276cbbb036042241974213f66c457cbcc41214d0cdcc6966ca6618a0864c6cec480e0970a02a945de115fc3d8c1674393533dc7aaef017247c756903ca37d5401efe8bdabaf592b9422dc842079027a525f7c81efd830749982d81574b01d64059683b2650fc85bf5cce54ac9269ac9495e69a1fb9a1e7a6aee36b1981639c27219e9b7f0a6a1f780a46109210de91e41c7073d6138735daca9151fe87a0ce6ec8c2b733981205488d0d1c94f19f1d69751fd1128475fb35e9d7b8e63f62322303aff0d6e2815ff0916fc7356b8457c65425aa422c9ee6641cad008c81517ee3c7b5678ace66b5ab5fe051a741e4c19fd9774f0378aeaa5f573f467ac5c2532b7aff02fd253f27a914738679233ef4a48c0935b6b0fdb4fadd7b16a8bf5e097f7c91b2103d9880b518f7362753c99ca540f38d9b0a44f51c82dad6574e3b30b107ac02a5f087a984804c1bd6e0db68aae0c7a133a404e24d2d742239b454c2441c18f23d5952708d51e7f3e10e768e790d90762fa9fa58a2ff1b7dd0a44beff984e03208ee435aad154a8b90ca54a3bf8ba59fedc2b4810b6a0f1d8bda16305db13a9c0d8689a1972aeddc58ac52795fa20ca869b2007a3aabf3238c59f406a10054a74617caf646c1d128d793bf1c60ae2006a0c52d9e7fbf0be2963c68d80645dbeed87f939f36d5edb43ec27e4df66ccbe8951c342e1c30ebd9396b5ff050d6faefcafa76232dba1478c07c1970986d03ddfcad87b27f7180c0d228632633f5042e9473053524e8178f1d4ac88a38ac69911168721c5dbc803d1adf75d7355486fc1d3638480d88cb64e6192c7fbd803830d78b24bd47793b795ddbec3f77550c2794b72b11aaa4fc3b663caab2d7ccfea78e5257634501a344a16f2d90ca37771d1d55b4a895053219ef045a793b7e90d8440e82b134d27085b02b000fcee158088d9331a4bbd08a3ccbd306650cfa68a1f65ff5effa1e3bb5a6bc7afbff6ff92ed92ec7de314f89096d751e07d7bacbecf5c134328f86925393d1a3b524ef15d3ed7918cf75ae09fb735e354605ead83a7807a6ec36b9b39bd8f5dcdc349c510f2fc2617167f1549238aebe25b003c4390c8e4563e4089b5b437c3ffd60853f8ffc11bbfd09b5624c60399f50c59dac95e952d512c4ce8b43323901922735a8e3ff9ae835ae1639ef35ec8d8cdf238edf615c8a91bbad149acc6598973c2697f1b10679762881aa2a1cf874ad497fa911a3aa976bfbcd0d224f59f80215e7d1a4cd586a37b934304c5c531854170b00149052ba18d480cd31fcb4535d7f97444a9899590c70e418cb6b554019c624242f24affe20818860d7f85348a5c53c9a6d221a23eab074d70876d0a2847188659c7d6e712fb4644425c0e6ddc1181d8b6037a8c9c8dd31eff0bd36b4ee1fd7cee8452c1a441c8c80e5042c41673f6edb610bbea1b0e30c48fbd782c13b60cd482f5d3c7831be2bc85f7eda2bbdd168e0facb124fda6d34b6d0fb6e7a45c5ee9f34d7aa2e91ad294456a869388bc7de7a0de3efe7882160d8668a4870f38c785093dff1bd5a564ba786be8dc1aad847a5a9e1c5feb07cfc6d42ee5d639d529e71bd5e1366f28dc51674c8e6e17724f6307c1a0ec3648af976a617e07f6507df93f6da8028552f4efddd3ae560d622856a483007fb714f28fb19b373eaa8f81b05b43da474406a7931408cd9104f57a4b787f256b0a91a43f90ace0b5095a7a5c85d398e6b64bfd8f6b7f7e409a3b870f3b82c69c07dbbde04dd08a3f92028963e26dd7403e4506795602bc09899759f8d8d46862e2e68408ba0e190fddd973beb959bd970af99aa5735017d1ec38a0604b0aedb3d7bb01f6259b82cd78d4a7da5dd1f1c2ad82e4787a1b3f7593b0b549f0be7011f0074c75c69b190b21b5bec6b704ead97745ca338cff939de22df67c62c81d22667c2e0d00c7e8615ad771e578b8a378fd8142aaae8db3b6c7a93dc1e73ef93501638a99e13e2a3c110a62a2517db3c5705c3ad851c1b329221e176da7b7e6d919aafefc8cf3be13410b45723ef4970b1667be290142fa6461f56bf136617154f670f914b8d5c8c39a72c3fe5553e7770e8a22ab6b129240f54e472f4963f6460b3211dea6854f7b81a49c3dee87ac61f568ec80caa4c30b58b8e7eb67fa1fe7edfb2cae46d72f97455aee052b2a7635d516934fe230633f6e077c3e8850ac9fc84e2877c1ed198b7c1d525b305577f6885f4809039b954e9dd5a412214f2b4cc7adf950c28672e629c1b43f930e890f56451f57ac3ae0430f9a0341e2b05bb78c85a13647e5a86be9db321f62aaece1dd5424387a1293177c197f6f919935546a580a8b9018c5e8543803947dee12b572ade40562f6c76e31f8433045e87269c00cb5b5d9b54c8174c887b7d0e288c4af3a12644b78e5abb923e1d1b426f95db3ce3315bfd4bce911638d96b5875123a03bdb54410041813d0c993e331e177c5ae4a2fe2c69008cc08277c34f9adbc14ef030e213c3b74d7e352eaeeee115fdab69f947f935fe0439ba560437fa732f37cb4462ce9c4eaf846893d0562c4755ffe319de0412ddacf634192be7bc607f2c997cbc6bfda8b0af4f5f1986e132a419b9e07b334892e3bdb03b3ff3bc9d1f98c4a303c2042b431baa45296e25db4891001f102fc82f23bd9e6a4630e041fdaca7c0936b918db05a7bcba825697895e5ced77f15426e12684516041f63aaddc90f52cb1d2d397b7f88af5b2f33f8658d8192c9224279694373056575a383c724a5e73efca1ecc4c91dd20b262c86be23d8d816cc169031f7b85ff91b38de57f17211d234296b308d0e15841e80fc9a922347a5f48d861790621a455c2adfe423893383b126d94674ad17ce6882ba226b8fb96aa5ab17b1f7e90acb568e6e26996cd89c784fd68e2a58bb458f1266475a50398d0fe21c615e8ddc1179bdb51444b94b78fbe19c3e8fa8e7c746f97edef03b29c1114dd40e40066219ac2b0dd201cba99d3f086833a347473edf8b60bc9a89c68a93275a758363530f807237bc14131d960e7420d9045fd4e2874cf460542af3f97e02a273bb87339392f3a4a3645cd0105498627ca70904bf68086e3fa93e15ff62951e703c89e5bdd23c7ec6fedfc89450899c83388b003bb8e8862940bb4f11e8998f9d7dfbc4e9c7a1e0e90e0a2d01a112fda123278c518b46e7796ae1019c9cb9bd5fb08a8a19cff59f279a127ff76b3ee0493636355556fb40ab3a224a5025bf10c1fa819b4cfcfa5889d8756b0ccd4997e4163d3afdbba4e414fa88284bcd5ec8c05a9f79d8e394ea848ada6254d1a6689b9024b73a08837ef2162e325b943cc86fefb8dcaf1dbc5d8a5181756218067593d4c9231aa2029cd4bdcf457515551ee4618f2abb48598cc3e203815bd3b72743aeac031d32276ff9ea66106d3d5c9d9c89e0c37979350b4d99d9b9c457766bedc2269fa217a0d1a860e959cbb73609a3277f5bea3d7829e918b07489ba77becd28b5750acdf8a8d0217f2db362268c306bafd11a2c90649e18c5235e2bd264dc4d61cc6937a2ee132e7ea964eaaebbbbff4829a911fb13871171011e8231adaf6cb3527b1674e797bd67f400b3589246ddfa4236a316cd443442a8a38dedd3d6c65658c447f9bf3ff4312dde759f6e7ced8ded8189223330ebb89d887bb26a9e4bfae32ac059446735a00de450bf0eb66a57eb619aa54f3bbc61fa20165a5d58b4b1d9938ac1ea194483d5175afb091fb309090ff72aa7fb291f3d0b59aa8108c06f211d7ea28d314df6b934326fcca670b406da35ace684948daae912ab905e35a9190ef1e537b77c36082a71b0508aa3d64d9fb61ebd190822d8769b07d55458e1b31bfa064ae2a023b7c7cf8d61d4bd1c5eb7cb9a854faaa090674b947a4deea23776feae2fd717fa686f695602076fa261c9e8c951637c2ff95adb49deb9169d8be24ec0b820d5b5286807ea1362c3c2874b9cb3d98f34922b14484efc685f63235e99a733d7aa44e5421ef6721bfdcc2862e33760601408efa6c5d7758bfe1e0e4a3e5505cfe912df31d8f46fdec9a3b775cd1189d979078cecd3b6e90418b970607270d48ccc99c7eed864718cf202acf4f4d507679ec61532fcc79c54e2c218c73b857b35ce6ccc271bfd9b42eacf510158c3e0e309d75b9f6eba8dba47d041fa8602ce19600b59c9f63d73a3863e6c6050c68acf1397cd6320b65124670d79cbea423c0677039843ee774644e97d6669c2213b229f73a156efe93468eca9cd1022465c6d6fbe720a49d2a1c43f7a4f24f3a5882455810a40076dbdc0322f054c2deceac633a254bddbd71b480092629055012fdda26a80a9c8d02a51a94b6614bbba3a8e330f75f2e34276b69b84ba8f524b61915c1fb62cd08a73e8989ec3b447bbdf31e0419ea295eebf246578e466b626327d3f6afb909847180f9b6c093fbcad5d1c3bb67791f869a7d3a616179ba3624c9be51986d5e958ba2e0d64e6e6435082ba81b7bc5245b7723690aa6b5b7b0a67fbd8f4a9f39c32b2267f67993c492daba773a0405e0d93b7cc66fb9dd932e311c743a08ac3e44e954064c2ec5d60018e884fe7d82b5252561aa80243378d0db412e06b31f9a3100ad2ae0c472a97ca4dc7ddff16ad990e16b1b250d57a916a2368f513b1ccd5e14311b961188af6c6e7bb2f23fc630058e1e10e06b03bdacfb8294e828cb2e9f09baf83cdc0915760fd00e70d06781ec8d384c58fa18ee97fb1c3799c6dbdd0862b393cbcca54db437e67fdfc73026f1dd2309c1d21f5f45c87e0dead4a5d2f241905224d2b4da3f3bb17fc377ba05968d8652cbcdeec18fff2cc181fe0a94a35543eafd8e2d3a14c175c5e60a368d75fe71f2b9699fce1b322f99dcd0734c2bbb355b988a2eb96fb444dcd64450b3584d25e86cf4b9efc4782c77f9adec2f106979bf60ac01346584ee2087321c096bfb3d2bc11b846d5de118f67486aa2dc13c24f3fca89c9a033b69b816d35e4dc1ddfdc02e1cd189605b2cab1a2259b0aae4966ccfe13facd44dd16c603172855a24c67afecf89fecd6a2b89b902ddbf2676848f261e6f36d87936b83a685d7ae20df85fabb500bf3ead3e63429f2afa8779f6d2dd6bd33a07afe1abfda3d9b25281b7ec2a2bed223f455216a913fd4bf5e6c14e2ba949baf61865ac5991f40a21c625500076da30aa80efdedac342063994d9e20ce351aab47bc728664ba2180fb9199d4ff8fb1d44af16a4f7df0a170607774d0586f573f6a76c63de1acd26505bc7cf23b526bba3a0d1d0af793e83b148da5f3033fa0e5a4dc743cdfa37addc867b2ee095c6b30835133173cdfa3366938c1239122c6c22051b3f3847d0bf2b58e51c8988fb5809209b5500bbf91270489b4487a2793bc6c4a74b8783df8610d837e7be6cfa4d00be46cc90c9d22c1512ba7700b9c39ef232012a8e3c31de6eafdd000280c57f77d0d0d1c10f57240b7deb37fbede65e07da33f0bab8b6ac16b361521d36143ac3ee6c010588cac7a660f9a38031ff6e56a086cced8f2da4f1059d1f5c03454426a0352491e9af104bb17d8375597d03422339e3be3e75bbeac1a9f0c93c96075c212eaf732dfc325c902d9599188fc347b6c58c9aa8153989db9918ec6056c892650d08c2a6df05230e31d89f3de65a59d3feefc295280afcb4f324540fe49a95c3744428af8434b826239537a6ee29669d4d5df857d03999d739a14adb77e993a3b8a36b7762cf45e0fce0a52709b1eb1e61756558f6a84d4962e3b2a5c1c533e841c085bb1ffca36c63666e64afbc3ceabae5f5d13e2873b64a9c6f2290f13e745d97e248ef19252d54aa297b6fe5bb347fd62bc2865589c06eeb64239178f82ed76d36fd03375a4487cd583e061e6e1f6b7c9a373c9afad9b36b615fd373e3622c229c34a16c833bc5cbc4cdeb579c5fd98ff6bf1c94d679334678d157e3f0cf5946abd1639b093f0f1aedc28b18c248527019741a8f8e58766bf49489b6ab2fb062732b4ad5ab506f7610f77821f88ae538e67a3608426d49815ea8ad2bdf1604da390266a484efffbfb6e86770bd954aa49b78e256e1771af84ade70d72fb091653a8f457733ccce5746664b1b1fbb5d7683a1632f22a36e3c843724ee12e95a63759a9ec20ffaf343cc25128d76d81ad2789dc3668428165be74d7f06984b003f5d3084abfec5fdfc5b030c453bd813b9a486f4ccfd74858b52ef97cc3660e559260fc59324f8f2cdfcbf5767d5c3fc85bb2170aa498bc22809d8627b7841d18d1aade73af69a84f08c658e6a19c223bac16a9b16447e2d6ab2a112306e04f436dd06aec774627c6709d0460f3b6fc29cb379a460ec0373ded84126ea1a16218ee316ae2b182026ca4cfe255995f5cb30cef2114ac685745a87c6e216aa3f55272765cab14dbca6b6367aaa4c5f37b8481610dae0a68e1788959e961b2cf48e068530d3342c5fe02e48b98e0fa67e27c04617664ae266c76e7829f0eeac78a1b274e20dd5c95b879b39cc2ee35d8961613462ec580382b9033b59c6db261403de23ec30f2180958100e79cf4da55db629fb3ff12f0b9c7b800d3d1ee55bd74325561df7655d3ae9eb66eb120652233e0c85455b3d6a9034cf2ed72d84eed3e66552f77d776131f57f14786e5232cb184ce0cce7f35c684dbab0e28ff4b6fce7a60a330c01890a78054ce719b5d211827c2699032b77ad2f676d9497470a149df6665905c7663a84866b839c36b0de99f60e83cbc7b93df65518eac755bc5ef70a62c38481f638a25adf3dfd03d7294862c09ee44cf774ba1ed7908541524609a8b719155aa624e3842187f04126128f2eb3af3ea80edc357dc240a7c4ef926a76070ba761f6fc3f3b5cd0a2b8e49dc2163a67fd4e60e519471f502b92e8f98430436d52d6d62e8824762fb1be09eb489a099c4a2375fd8cc86c99ccc6406fabef929d2ffe6501650abea53ce36cff9d854ad288ffdf9e9b472acd2ac7d9625ae6d029833437adec9dabf399dc65f8b6bd111aab33a9e2e1ca8ab1222708837ba33a4764a1fbc71b627e816e24e9d08a9f33277899ec7e5ca7824ef21d0cfe63d7c1514b2f26e88f248bca043b71003fd2247b632a07da70516a1b27743f7d835022b0348be5e726c9e95c2d363862ee61475971fe027552bca41cdf40c7ff486b915c1fcc58482812fd72e4602bd791c9aa4d347d27ae79c402d730fb51cdd8404af92c708670b9f6a904aa41e219c14ee55563e0e18cfddeabce63413a7a0140bca2448f1ceebec442dc2f7e8991f0500c9a1488dcd54b0f8c8b2be028d7cc255dee535d36667f4d138a8a51ab8c9a4588f17298ab5f73d639ce5a0d7ee03367e6c1481516aee8f952417d500dc48ef84364b87bb5da45c27ba2d3b0af0456fc08511e6df7141fed23927a20bf4929394db9b4347d30d3af7d9feacf5161fc9dadeb78933a3c731362227ec9db4e2d40d11fa7aa33d94df9cbb49c30d21e3ffa5474ea147101e8333cef9b63b38ad46ba3c45cbe4ecde008cfc7fae2135814aa79087eba9f994922eb168d74dbcdb9fb7c967ba24897c99e0957aa2e2d0d816e9dae8b69365ba03cc90bca95b9c6813da4a3192cd5b646a393dd84e6ab6688db855caed2a7830e43cfcab0594d77cd471321ef6de4087d80d0635b037b1e5b040f52a0a25f1f23455ac82b136cf44b69c570fd44efb5df1383da02300656d5e359d9f0668cd119f452c0c8db15bb5c246d793168510d30cc7e7694154b2e6152338b81f7b5ac4ec380ef75647125b120f2322ae9d2c8d0ec92ccad4ca91cbef2d69ea28cf4a8b21fa7c3ea48dbdaf4890e4ddd15a35422377f06eb39cb05cc1d348e35c7125c340b8d442710aaf21c1eff003a844838e26776e8f46ae5328c688c586e0c03982c4ae2295a6f1e0ab2aa11511c611cbbfdba74eb4dbe88b9b074157281701a44278d853e51ee73d1a5d40b05fd027d7a1e706b8ec1d2915b5efbbcb73725fc4c2200c063927b9e29b852601d29a6671f961ac6659365a141cbb1c72ca65830ec9f3626a3c9402740e6baa24ab627eea75252d9ce8eaf7e30675d1b82f7c06c6c2ea6e074703a351525ae47b10cd776d75d58bf1f89c655e3481a3af4fcbdf4746031d6217bdc1148391a04bcb5c040a28cb5dc514f35f3947061c6800bed351320e759003574d4c41813385f4a923b2f74275ef7102660368033f2ef5f882d2e13fcd2ceb414c27d9960deb336d1a6b1362ea3fe822ae05a5e5419db6221740e6a076b9e8aba71e3e87bb069e2d74d4fe79fe89657ec4abfa2a0329f75ed4a071eef7d67721e0d7f56846d5f3c79408570122f7e36bd3953bfdc615279e14cc30656bf0bd6b6e3c0431c8085e2b61ce9d319086c987dac668acc1886b07ada711e0d8902c6586f4ea35cef0165327422d2e3be0bdbec468d57960868c525cd306d7ff1ea72a65e44a41b49d7e6b268bd3846b95b2642584eb8d7c38d5a46f1f992063290c616de59ba36592082b7062880409cdb44e6c8ba83aa50ff19df968c776a1152feec9926e835b59a9754baca7ee02831879a7442f2712797d5bcdefed7b81f7d4063073d9e6181ffd4a2bdf578a632550eb1829510636084c5e2db293f4f3ba5cff35610b54609534fd664635d9a7c073a8ca45ac34650decc5cc638302c65b0b8f6c0ef9526aa5b980c52c62fc388f8103d3c08df9b0c8eb28c439c1c2bfffa2580310b9ea895751c02f97dff19b1a0c82f4424b54cf5fad621018324557b3bade4d57db04a3b54f3eda147539de3215511407c5c5de97aee8ec1c6d08cb5fb3d45e1e95552da0777089cee24c30231b513b0e693f2c746cb96d78a28825ee8332235d0fc6904aac765a2ccaa540789abcc2d4d87283b2c88797672ff797f33cee6b8392956ff4c98dfa7ffda58e7350d460fbc6299b4e24a6f8dd8c9e692e304ce695f77e16ab1ac2e6cbfd06810a780e7916dbe24a13d0245acffd0fcbc72686b2d9560595ce74c7db040b3e7425742cfb76dfbf7ec38f9528d07af68f23230c5a509071b2dbd2c892b7922582406e23eeaca47d121317f841c188f2795d0c242900a2068ea5c77ad34293c25192d973d22599674d04a9e560287362d6a2ae060c5b6c7ec30a9b5a79dcd1c2e1d3379fa08073de407a834da7f6523b81f445a762efa6a0cab395aadeb103468a42defebceabaf966e22a4b265c11691ddb2fede8cfe52a2864872bdae650843190b23648520cb300408c01b5b61c76237333c898cca3cfe19e46069863105cc93677f03e9b5c12ece37c9a028c691f44b398034afbae2948073ae968439edfd13004458145438f5b48ab4477fbe280610b143a0f4f478172372e198623c8bf4d5c3a7450a56faf111e3e1764b79e6b301691052613ac1c0f2409e37062c44bf222de1d5c2fcfeb01c94d8f90b154a6f39a9ab57b9a05d98f9c914a18a7d586bf0011439eea162c4618a7f7244b58fd8dd1ff7518a031342f6b9d1db1d4d920c957bf0a090631c1adea91a98eaa14ed46eaf574d8fdb11d5eb5a06c5589f68668e061b9144571850fe635d27af84dc9ccafaa25eee613c4bfe5d26f195e6502fb0664a67fdfb330e4cd254825e89f88340acbac65bf45d295a7dacf7ac035e1b0d68bef2595b67272cfa942ccba39e435e41de3b7bcd97d9046d767cfe7d1dc9387b30c0e4c60c00fadf9ed001d030dc73e852827ddac876e53f6436038f5bd32d1ae0a9fbfd00918eba6b4565f621f65ae905878e021c4d2eff01726873b9ca644cf3614248ee0a94f2ec9e555e96e024a52d1e4b3ff4d2a4ac4002388ef640ea77e5fa703874b449028e7859c92f1506432c4f6a59d4b3ebd3ac90831637102b3cdad6601e0e9729fb591b2c182fd270eb5587dfd0b0c92b099528b1a86160964cc1865f3b3115eeb14720baa57d414ddce7045b20bb8713a1a98952a60abbfcdb201822a28db1db5598d76c25c8d0a11af3f1bd658e1b516988181eb97558389089b97a88423f383e615ba1189b4305f0f2e08c7079c8bcb3bbc65a92ef623c8cb10091ad32dbf0bb11fb7ac459bb9e44902ca7aed54ccfc110f046d0e052d663b4b412b4290085aa327d0c658778842f164b1fa6e57ab9219573e2d46b62b72b3ef5a3084dd2c2b2daff0ec0542cba58e67a35e0aa5026990e188c64f908ca310861cee5d7161e3def679af969bdfe87cbe6b57c06d90bc80bf6af5a8f2e9997a8d6c65ea6cfc072a5b629aae44acc893fd31adb950ce2f6b219428a1fcef21bda20d714568b04a5eb9a75c958a18758b979f3b103fdf2fced5b3117bc58fdc1be7f42887e4bc798d5169a02c087677d45f08152efa953633b5b0da1ccafeb574460442f690a4bd2e8eec5d016472295a076a22ab1ace34fa88f34097e043d2fee8af98a0de07768427a9f719a01f84ad35f9f6a66e697d9335a6dffcbbe57a7595a6562a6bdb42c0c8469e0ef323caeb64d36de8b2f852c878a243d15ca2d2bbfed8f799e561613654fb3ddd50028106c4210a13b2c48ee2f7c1502405a628c67544ee1d2b6512dffb008aa9e2f41055e948eee50f60f36c05f9f8a0145aebd54c283999f994e3a75e09d494c058af9d69d202cac282b70a3f6f417859856c39178cbed7861514a5daa0e7ea443874aa0313cbb91fc20301bde0e880906d1f7951dba6cead71ffbcbb613877a65bcbac1f7b88d152fdd6a59b5d4b761300ffbc60e89d46157c5d1e0e829bc85aea3d3d0c551f8e2c2f13886d32c69fb16464e9e0850c2294ca7e3c8ec44698dbe28cba0c96f44e6595244ae8d2ef26b6aaa0d10350bfc5b9c4ff07ea0af94ce40ccf6522b0bc1605309d50e8001c93013952a83afaed54487e6cb99bffd2e7dee655733f0bf69f0f777063b44dc3709b9800c2a361bba8b8e28be7c7d09e83be40a4dfc61123839a9ba86006390fb33e0c9ee935b7f59d9b68c6137ef35a36479ebecfa72fa93a6909f194399c26bcbe53227cea243795e286a6b9ec1ea07b121923c4ee2881cb55fbaaa2df571d8a6307085213812e6b8a5a9b9e94d2e0d74c1febea31ace78655e7e8c9e810f68037c27c3bf32410f8d02c1d9883f3cc6d1ef3059d7e25bc4413a5b51ed74d9aa3e81bd4d185b0ae50592e910361c013a83a93b98bc3a6fdcd89769ad21a58a59591bbcdfcb66fe5899b65d2f80b6697ce754d2d5b1050157621bc90ed3a729c3364d1dd58bf35594a4a07ab5b2c09a650a425511297be9c5143c3a07bdb4242f21c9d21a13bf0503a006637f39f03266975ef0e1b05d111982224aefa0ea2703496a4ecc66bd6a3812e02dcfff1c6a07cbbd5f09843bda0b53a52915e42a78b7f7f6ab6717adfde5b880e15f30b6172f5f80418a29d2422c03020d76d2d1a78cfbcd394c0ee4c0403629e0238bd263eba91a0488deb027d2e34812f0412c3aa92fef2917af6f394d19ce42f90d955760ddde5a64802ef3922c3b579bc9604e782970c5a5cbb1123932e806e390f70c324e617d2eda33e8d0be15ab51e95dc60884e125b2dec85b363fb2c94040c17453a2dfebd74244e66ca23b6e103b5e707b3a7e0174e6ccbbb3361c7b776f58b93a4c2697004b04b17c67bb9bf70d9f316e436efab64567b97c641256548b7f95f694666a30d30ff035aa3a061f038e985c9610b86490ac678958b75a977ed5ff768e7d5614c9485c06ac938cbe3a887a5818de0d2c65e5a600a9ab6d348b97ddd2295902aef9d4f02bf2a78428bf9a0f4c7ef13c7311ddcd8859e2a5050bb8d7cd2f22de617ac9c3144d0129671c2b827df2cfb39b682cef612458ba6a58ebeab50d5ee52266187632840d6001b73bd6c4da25ae2cbd4e52318d24724bcf40ed486d1a4a490b2b485f0c6218ef3a4767df3913f8408ea6cb8e31234112cd8eae647ce25e986eee65c15401f2c2dd0a9e693228e65eb006612a7908d5a3f9df19ba52e5cff97dbc3da6d1b3ec58a904d72b603e4d63561d2db7fa7952f4b454616a071e540ed952e7f5010d6efcc1e4d0a57b8e87614aff3939d25fa15b7444cb8e7fde33946c62a377f9dd266ad61edf00ecfdb79aa310e9afb8000d9099112a793facf5a20a47e9780cb1f4a94663b0c11f05d6a8c822b4d8430a41824ac0307efb0588ccfe652fa90c734da492a2fdf53e65c3454a7a9e79adf7e1c8be0441d3217d50bfe102c2ae7fbc4cd6fa28b6187a830e434babc3acfdc53e6c9e0b956ddfdf998a3d53c3b187980dfb9937f02b832340f94763c78dea17a6df2c6de4467663232160e9adaf0ac8b6eebbaf746300fa15b8ce9a9f336ee36d88e323741d29b85b6c1c3392f8b24132298f4d3e0ed290c4fa4af362a3e700ab60887486f0f627452cb8d9e4585a6cfe4f0c1e7422fae4d916a6f8d7fa786b61d646f1f333f69087dbf8a8b369310a249dc395eae54d2a90837080e15de641373a53db7df9a14750529cc10aae207ca07e01bc9e9d82c8de5edc2d8565b3bef9b1332db6913ef0b89475a962fa9f828eb49dfefaf50f3e017694ccb597f989651fde763a34f7a586ce73fe6e05543d7a98dc3de338d6ec723d51d72f18cf3485839933da1fe57176c92fc963230cee341f6b549f621c465b4e84dc0e1f71eb3cdf0390f41174ceec55d48f2cd7c16bd81f98941b5cb9e7a0272d48402517e1ea02210efa0e825a9bb3873ac72aea7f000237f6b3483be645ce794f9484502f221fbe56a68f3aeb68fc3262acba009106fb5e1c852ab503178de2fe7474d652ecd9ece4bb44c61eabd382168f4f37cdda83b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
