<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c35034ecbe5554ada619903e605eaab7222ced46db97f7c16bf04cc7c277c5b60e82c2c5b9bda5eabf277945485d742aeb94d8e0550c2460024dda9c4077f31659eab6241facb795245e9809fbcfdb21997b7246020073a9eb3ffa4b8cf8a0cb13d9ead520731d4b71e0f51028862bd8ac57672f0fec326bd8676ff7ef2572e0b12bc06876e183db80e248200f513e7ceae41fc3a8225d9ebd9b85f1f6cb365245ccc0bbc472fd6f8c111ceb2569e6da0011429929ae4c2e0f27faa0ddcb390726225410f7a342c153b800c258c4b868ffb643531f846e4b012a73a09fa818a4343f2df4c5357cb8959a3775c944aa406d92b9756dc113685ca55a9e324ab71c8b23b8e78b7df2fcf6d20665dcc1db9afb776cd59216eb7e8360cb3c2980d99f2a4e8c53d0217f12894480bdbfee4d2ffaf10f588dda500639328c4436698919a4d7d46bc0e6962d14bedcaf3a228b3381c86e4bb455f6ae642fd41f845be4b50e3742e54deb92f03dcddf119ea1671597dda1d99cbc50322fc8ded2a8b1032861f0a83ab8eda54300c4c7b126faac3db45aaeb83347724f1734241f2f32195a39261d241f55837cf3874d4a0b6c156caa62f8a035c8d61349e66fc0e9f281056833ecd011339310ecb9946cd58ef0509bf50d74879e94d91aa8bc921fcddeb5dbb858600ce49e4fe3bb06e0d8842d7655fe0c9fc7f9bb28c9d7636237eeae75ae9111021e417a9af0c67e0960c9ed019a4edd9e08311db803b59e1ebf5919a6e32e81d04b936ab5cc1978ed2ae93053c9bb71177022577e00a925e9de41030cf25a00148374430e0e880554dd1e6eebb1ca57144539f8534df7611671a9763232582577b695cae553e3edec7e49df0f14caad82eda0efe3b10dfe528bb721c3363913942c9ad46ee8c03e2ef8580fce33a0328b11c4e182d34099de9113c20d21fdc63ac26b8408eaffeb04060e987b59aba707fbbcc6c7f12a70e4b47d1e669469e7265a0042e4aaef10ec5dbe0de8d05984e4529f3c83dd92ae37e8d860f713f780c19e99fc6dac0a39663814b1746f68ef6d8a4788c4eb3610f05e96d9fc993bae28edf383a98a0d4387178c83996ab6a9ba48ee56173ab7e26aebe6966140b112deca1ed51509f23e8348766791d37e558c43cf0638da382628454d95a47f92e9761259cd618f4a61a25861b065b0c0fcde5a5cc0d46dfb0f7b9fcae35f678eead72cf72aa84bb059b29a1fe3c04b6d2299a4301e7b1649e61f2eb4983930ef272141533a7c8746cd6b6b7907a03d2e7f1e13de9148e41613b9640f4e32dba89d1c3041895a5f91011643e1cb996a1350d00cd0fc7f742f2b7882168983e249745c4bd7a83d969c73715532485430b32eeb56ee9eb03760fdb479330005a242be142bfc32fc3b739ff764dab5f84e3cd4751612b3d420b44f26a5613df06e7fe281b3da04dfa2381a78868560c72752b27ab95228a93def3368f768979bec8609691310f2cbcf8624df677f30f6805294cc2c52ffa8fc0e7b11f7ed8c3d7ef1b709880a30dcc5e24e9f62b71eaf4a0cbf48b3a7d24652051abc4e2e7cfdd77c525fd34b4302912680050d3ae13be973558408429ee4e156aca54acd9662452ab80c8dff68ea0a751617e70ce97ea7552711d374a3c7ace2322ba3b308d055fe99782f1c7b1555cd10036ed66d9c96d5d35ec3e8b253d2abdce74a43c84ea873da2948ee7a44368268cd2f9a5ccb6f7cdde02c920687f7f34b601edef41a3b1ce1ee2d29e2585b6c9274e3dd089e7e6847d24e020ed6200f7e77153f045efe68cef0f0d9089675c60ed8518bc072ea26e53532998a8c787bb838bf131445218aadb094d16a778ec968471be069e1cbc3e4caf461c255e89333781625e27f557ae85381194ec0d038974621ac6060e3fb8d0ea383d5b6a75070386ee8071d680967ec64948cb72386dc611056bae89fc7eb05e461d93cc6dac5b277d97ccd13f9adec3a54cbd0bebcc1d7aa8d011430642d2daee18c21e5ce160981860e381f7c9ce7585f505b684f8b436066f786200f3d2d45c82d45453cfeffe5143ec0bc44009db364bfb2f37962324cc715eacfaa311e48a1f91868f888812747623b3177001a0f29cb28e4d99c821bda211068feb8b75857676b4579964a9a9aef9f22cb50b21d816db3b076ac001ca021fdbb036848ae4ec8ff70da644d52b1975920d08dae2c7a4a5cb6e7300620fc9c9fd7626bce43ed900015376e51b2fde7e901d5d2beaf3283f53582ea11338e780edf52208f302eecf793b2cfd306d4fd1cd5c37d2b62b67cb989fe21b3b3bf405e54ca248baa0f44bfa0cea1b7275476ce57aea1f07fa696770bc475a00f55011c0a6faa621455b99a767fc363175f98ac47ae27c3b113285886103c0e87faed15907d0bdfd734bc36e7449c83271e52e986615d266bb060123fbcba6d714ef1260eb33f60778638781d8b295968f2674c4c1306b1a5e4bb2d4eb0b0a284203598b5075acdf2ce54697826013aa58865c5d5326fb3deaf1e5645b119c05ab7bb0991261ef7d8a2a0a24b3d2ff6254b50316809ce29a05512f41ec682c42f32e0c5c39f5287008c585e8a277e14f71fd99b2bd42bbf9729a6a022cc60f4e98102112fedd1cd056c7bc825cabeaedacc5b6d858d812a346d911b9600cd41b0c1f2c70f5abdf746ed00b89700d2f1a52eede26a0fe3044753bea42318811713f27173e16622f3b2b1383e6e4ef50a7e523f62b8eeb440b6f10a23333e902fb8735a4e4ced1d208e28decf2c438b85b96da78c28e072d6982b47ac05c54bbc9ac925348515f3aca2b417974ccb5c460a30b3c4b5d65201eacbc667705942dfab70f11b4d5b57501e534f296a193ae2829b3dce2445feb438a045a66861f46a5c81f7afc2c5112ad394aae58b84f993743c82d43004d1e34c7af1180db6f00662d057fc0e228bcbc6522c908207daf04348f70c1e6ee1e7ff4c734ca6aa864b5547ae3135182c10372442266c5addbe38a1f413a4f8e3e50e892e6a7451a42a962638627badcb29c851e217cdfd0ef9fddbb5c25cfa44332a89ca02de7f0c9762f92de1305ec4153d1051f5a746187f1c94a69003f0f31903d777083dbefd417c9bf5fb42b499b7b5f4bff65e49b2ae5c6fa7b959aebc8b1846b1768d15a8a4e295b64d7633506f6bf7d3f86202dd9c931315d848e27a99a6beefffce84d475687afae4e5ed99152500f7a8a1acea8045dc0030a11016f2b4010b59322d2a8547fc442c6bc1377bb47c52058c2e851860b2a7bb5641f60498d2b4b3837156b8186455e2e623eefc933d2a548ae51049405a2973cb448d09371234723b9aabf3d60a4fbaa24ffc98ecaa1de0ca1fd350b64c5e7762c9a3c2bce800f41b3fc6e09f3eee1a2bf6d025756141464d151973c5e5d9605ec0a583bc7bed67c93c593561e4e6dd3128cb38fad3810b8f17929d7398c9573b33a7033c36e4b9e3aff3d14a38b26ae22a345190a4197456109d6541c6b3f5a6b8be49488a82645d7ec385fd74144a87254f58ca99c5dd6948e875e2ebdc69889bc9428fa9d91c4efa85847a3b96c9786512cd6ec6442697dec5587bb201c4bc6c3c98bb2b0114378b169cbf1a8ecaa10ecdef4f028e14d75bb50d537c9e6f3eb486b87b498cb592befb5b9de7e938696ecf7613036ded8ad932891524e548edb9b9f63d2da64bd68727d39199c7317e1a88d8e301de53372912387d1e0af6b412448c3ad19b331115a4e20bfdcdaf911e920cea8f21184198212dbc7042c4b1690df22a9593b8ff73646a29471be78a73d90d3f50a157cd8e17a963bf1404af5fd33e06e87cf7f2e05a10dc7147e101c60e3a6f3edf8a8755b21f2970ccdecdd8ff45db92cd2f8446eac3ac3727ee86087194f4117b8ceb913a33b250b097aa9d1c380358909be7a102ea807ac4206c158eca42998ac317575eabfebc4930f7531f5ef2c48f640dfb9fb3e909dbf498c4dfa7183ed42062e564dec28856904df399b77dfb1fa9ce8ca2799b2e0a126457fed04ed9b2e1d71c96abf023a9e2d08f852d8aad44fce86b2720592af40685063aa3c7ae355d125708ca4d321177e58af994e9664c68dc73dca391ce5afbaed378a9db4d9585e67a4e450936a1aba50e1a4610992f8d0ba7ff25da7fd462deb5e743552ae7b277d3878313634a5f28d3e20550063383cc437a8855b6d564b8c4acffc5c4af5501e526df1696f9f87780cf4d70e8273801df21dc51fc0261907eb049a94866a18b37c659f762b4cf1a607f2aa34f82c611bb94b6feb5505178d94214960a94a579acc72acf945379b63d98bce2bd56082a791f257b7143574e6fc2af1d776a9a2095e8918cf2b999dfaebcd4c16cad48600b6790a2521004b13e1ff1095702099fd1025148a901183134633797acbc7c78ae6f4d861bffe0a98b00ade210ad8ef6375e2a8c132dcf4371dceadb1c51b35aefb5afd6285abce9cc0947cb7a48937dde1069654165572da242d60cdd583bb1bc2fb705e13d406c5f038d2892b4f71d0ca7d0d397c4782f3d5a7b3b60e629897df46d15fb4351af1b083f9fa4be25c4a4f8398edbe75702cc7b406ff17c0eec38710e2cba16dde86202b77a065dfc3b445104b0f1f22c05c2b806cfa4f090c41931eb1e11d5f2c3b9624a4a9a04441da8bd8d892ab8f6e1ade68b66f99845f2179d17cf45a1a866a1c5dbb33e21c2c79aa17b3073695fdb1cf5391276be2f1be9ed1eaa6b4aeabffdcf3cbbd36ee7a82d0575f52cdb16ec51781d8f11e1e845a4bd4ecd75cd4021bcb03da242a6e6ff8b613df0e3a2951878958ee6a3c262a9fb11f95e6ee9000f5809413b03c49f786290ef404938fff0ada804f2da30c9e741a3403422d2fc131122c634714e5b6c7995d84275cd31ea2975f7ab93075c45798cdf7635d0abca43e2c690b2f364e9856835b39d4b8dd88da33ab95faa130bd7d7600c4b948056376e5787b48ab7f890fccd0e1a612cd79613555bb1305f368ef5fe4f87ceaa1d1270ff4046b4afb6b59afc0207c47686aee7245a26029c78dc95319ee45506921ff1f388997c5a726d5c70c27ee884e82bb9978b06dfa85a33eda9139e26746ef4c82e7b61430aad8f0ccf0bcefa922ceb4ccaa271e28302559eaa53cb1804d8bc89146d35126e39d3215be797a99e95bf2589ede6729cc2e528d848dbe5388f1a6a27aeb500c47afd970581b863d7152261bad6cf75d2d3b71faf088681e4ad2fb487a9b435d936c42d8f3edf3b0c8bd3d49f598234e1c9cf7a7dc49a23dba059a162b6a2d5c269091624a75072c5a69f23cf45908f13f39f6511552720125670aed130057f4cff2d6aae82acb84f00a8ac493f85ae43713ab88900a3fc044e2be62d5fd7ee9fc547474edac9ff3dbe5e7c504c2b38a788dc69692edcea8c55af48bf82e07d4053088e5633b7a5332c50d680d82987e8596bbc6d97aa390e99968bb8e899ee482ee302d368690aae52a6217184d10ace2a3d9dc47b56839c1e51199b05c5a52b3b8c427656cff919e588840be20ef3c85b2ed0b97605db70b9fb3ea2408b416c228acdf8fa1c46525eaa3875dacc2f22bc02bbbc55dcedc8585a398b66816129de5beeb126546a2d512f63ea4a3137f98a683d7636c3953da95c0c90cb19eee8606478c5f5708d779a0aa267b4a4f292efcb850a4ac4cd53c6d5b3a5f66ca43a1eb4b95b995f13af76924c54511c04a119af12723f7e1babc0fedd5e37675baa67382eaa6a25838f5ad92daf920045615c4839213c7c10cddeba7603e50c478728f8bcdc703b536187f97026a52777cc7cbde1671a9a0aa71d34b222b5ae6b86ce911ef062f9d3ac38de81ad50277bb0120ecca1475762b39b3d42ccb71a70e93340cd12eba2d526a5f4cfeb6b3c74b3f88ef6974b2d378c1d6102e73514f587b84db606419d014e20b4af01458ebdea435e3c8ad9ad55bcb3b0cb6673d2011746ebf6b9328b18962082c9ce5edcf65b313df0d8819ad4c9e8ff9a9336e872060245e6f6c99f93d9bbfa040b553d3e87f9e820ae3dc2d8c38fcb97266171b0e4a5f5acb972c9416fdde6daf2ee33fc3255d7a0f590249805ca369d4d03a1e59aac56842bb4720a778430dded7c1a23decc188d794f6039705dff4edd95183fdeb5fe44f43fc7e77b223db92cc70ee9a96f575ba6bd807d809de1f51d3ec0172316f1bc26ce694a067ae869a5aae9aab10aa1be374b7b8aa261f69c9d3aa51afa81c972b526c94d4d05b1355efa3329a330e8bf0a1e5bfe09becf5531e7acf95e7dfb72fbf0740c0639871d5e60a6b610b45d5c2ef738597ff97d4fed5439820b6fc6934b2f8b5980e98cb6848ad02980c69f81fbefed398c7efa7a14deb80f9f9e43bd80e83cdb443c7763c66aef053a887dbe21b1e1bb105bfa22104de084273a1824721656e0f9755046d68f811f9a4186ee035c4bb4822254ceb11d90ccb9ffc422d8138f4dbd3edcff093b0c485c749e9896a430c0be7dbe86c48dc54c435f340a8452a2ea83219caf3a21d3e66f300f2d487ab798a17441cd28b3994ce9d95b1e102bdc6c1dd39fd877408e2dd2681d3bcf356a3e36a5d3e33ba9b716277a1477a06201748cc65ddcac047643e528ede5d0278cbd41b58358c3823efc64ba58178dff03af9ce49087cb2f25aaa8ca12da5e25f479a5314f28d1e46c7da3a5855ae183088edf625d4776c302a61ed57df73f94e3321a3ef299ca12c1055948a1ef9d36d9e6d40b31e0aa07c78ae47f41d973fcf0a9db5071a8cee91d9ddae8eac596508b91dc97cd0ec10ec6491dcb89309c4851518718311d03105b653ee16bf1df46773c5636aac0cb67786069acd46d07f012a79854f93938123383e8527eee7a5e8982d2148de95d5f362e0be992f6079955ad8eabe7a113487f1cdd283f2c43037d5546cf59283c315c5a3051e8d81f76445d885925a14d8f01d046287690b8a6d10b15f9b4dc853d1c03f7443855acfcce87f922f7f75e84f07546defd135a098c2adc9ff4815b3eb433f167a83a6d761c83214cadeefb3b8e6ac92368e32fae6218c7443cff178343023a0f519af8fb8e76c7c4458a25218d498f1bc53c933646bb03e4653871d6ab5ff54b968898bc327817a53e027c70c0ddfa70d3b95d2732f4bd491aabf980e03c11a68c1bb930d0c92084eb55904a80158c1e5b0671faddfe92c76f2497c01c99cacc6afc8801bc55b2afa0ee47211b3041d02ab9f0005845123135fe3ae923283a066f57f1e83d628f0212538ed33fff79686d9f8e1a86f7b99283a06cfc51bb0dce0ff7e7733a0ee1c1964183b618eedd089f907b0a145d0a33a6d715f67c090771228994f07f1b97b14ab6c3cc4563c35c94126d59b45be4293164819e49bb041eacac367ca9b7a159749f41c4faed8d6739a13da7b95d886147beaf15b81bcdd5f03a99f0777f854a871c7ebc28c7e1fcebe213a16622398d20572b5a8ef68ceebdd5cc6fde2c22fb0f709f8e6209f67ba30df7c3efe7dbd099bf19ba97c6a147feec745f87370fe06cc301a0a20d70a9b27a9fdf79b606dd5ce25ed02fabeb035f6c6078cf1cd725c884205dae53a9f941f51bd05cf23c6d4ddaa5eb7e210cc28ceb509a85b38c51f4f52b0177c34b9a1ed5224c0931f6d9d7c52e36c78d65228d9d795577beb2569471981114173e8216d7f92704ca899558676a687722c6cb25aa83e83c7a5abd39de13c3b4e0295de45ad845984a0cb98673042ab585dad6b4b59aeb3c9692d2910b2866da8ec8a673354c517456e2d53b49ead01591db8822b6249be6d6818e13bd56af5d4a73676fc338cf930293f97c65e989615554665a4814ae13321babc49ee88c6396cc07dfe150c346d5ee303c86941708f127ea7aeb09cafe1aaa6d570c5d022e3e3b60382af24d3106b9c0a0c4b1b617305d98931606e169cafcff4b3d81e1513f5eda34060713bf7da01ee8675dd4736cb26c43bdc6a62c2ab064433a52707c56dda08df1b21dbf3a4bd3bc8d504c780e8b1d3a42c0f9f26828838bdbeeeb811d4c4819f4f71df79b4c2e449e1636c81d6e293adee7569856c4777bc39b0dd6d9bc63d600fdbe570a29fccd3affd931f45a604f6d9ec334f841f36a629020f3d93d6341bd9b1f3b1458db8b85fa11a8a430c788f42d997c07f3c589be2d28957ef9181d51c4fcc7730310f83767c3b802828e51e1363c22b288e5f6334e7b81bcf97ec1c823c78d08f87ee06d152d32ae994a0ebd6a483cf15ec15c1a57ed790d023516f579239563a23d4aab955e4e6223c76631f1984dbb0aade35ffaeb0a9497dadd06c53a3f33f7828e166eccc93bcbb6c63771c52cbf3371648853e84b9ad185c91c20f61860f3019fdf1393a9cd5ec94a87a97de39d24c2f51e8eafa3249e6ceca3e839787d77c430932c3f5b27135f7db3c7e9c5f8dbe069166d880fc0434e8da71a3b2b61b654388a783d1ac59e36fe8ebf26b2ef58583606e13aef21f6a36218494138dc60372379568cdaaec92e43be1bed66dc48014dc7af9811f2ac14085a5d4ca788edbe7489db4800b766df0f85d101295b206b6a05fb0b29dbae9cbce2236d5d5070b59cd3b7cc58e1fec24b451fe4a22403accfbd75dda55a4ff4674606a3127639055ae282e3ea0eef028a0d1cfd8ee0bdbef1260b58e1ce17d7dec907036c17ea5e481b1f381796771b227093dcf6705566e552d2fb421b89ebad0a9bcf5080ac8dc8f462d030607374e89d293a309ccfe371be3e295badcc6578746573593e0d765918886bf11994c24613e9fba961e2736d9968c2333f521caa49ade06b9551a54b0b548444b6934deb42ecbbbf70ff847c47fcd543820f91dbe9c70ac215e9405f3f2620ca709a07c8aaff142498abdcbe1e2b51662fcbc5052ab336cab965702610fc47ba66fad9e18f9cf7e5332ca2c8df7077c6762f55cce894ce68a450be0110f27287cbf2f02282708f4b2483b7485071ecbaeda5eb073d6432f56bdc38498ed268b69cdc5497f56add51eb00593532312af6693f7f077a38ab163b70c2e19e27c6b518fb0a2b1c48bb959399cd261f1408bd6898ac1bb7547d13f96dc8e37391c46cec180d916102743707e5900bd56ef1292a95054757e70efaf40f1f343d06339098ef5b3c09f53c9e1ad65bf0d0b61e6c2779f4e15dc473078fa4f5b3fd57eced2f7dd49fe3c7f820401c96f093ae28ad44534aa3741b91ec764622246fc91a1edb7a8826caa535dd855be4cf2f01cd986feb8f2585783c4135f440e0b6fa28ab1afd21f7430afe3cabaca80b555d9866fe93bac9653cfbda0e50db36e21fa20920b0a554b98ecc976964771c280296dd225ff0cebdc6e8185d216f76b0bafb70b446202afe5453c8ca172898f1ce49be44b542c286d500740f7afd74d6bd19766ccc223ac10aa1c6dc184f7f0e5b83e5fe2cb1652f1c4acf73e86da0eba1c7b5b5c8267071e4d4a815c068410df025a7f317e21860a18ff3f1b5536f03c1c0a1a996fc91a9545a92b12cd66631b789a5f7adc58172284fa7f04ac790c85dfafcad922bc7b8697df17c6ee600b8690820c64c7cc7e10b4920ed92a30422e8b83727d0371d00259e7357839b662f85b6862924bb6e324c42649dce6b01b9d064b1404c7abc8090f32456a21ac980bc5532df61299c462466fe2c4eacbc3133659894119fa7cdf24c55ee5da52df510e615808e007015150925bf456600eca8a1fde09a1dda3eeae2ae62fc4f779c6f05c1434a049abc4abf5458d3352f1eb6ce1cab93b48ddaaa21c4d923eab1901a86d5b1ee4092167d54ce4e2103607359945658ea6386c1704f8573171cafb56da30ba5a09bcbeb08d22c5c0632ad0aa306bc0445c90cadc676c94551883e6a849abbbb75e1823b68881df8d97bec1173de0b796e10760fdcf7b81f493b686c88ca9f89c32039aaa19b323b17407f9ecdd8914f7a3d79eb3aa3a9673fd0ef93ef265d3d5aeb4f223fae04446435d5c5872ebde3846c5908f11c80bdfe3936b99e770c2770f3bb7cb1e81db4cea19cd6f5d8aafb0ec5dcfae6d2b8c81ce53816bd606d109002c1a43830585c35c563f060c1a7a258a6d71ce0ee97996ff4c63c1a0cd6c4ce7739a0a5f092de33cb776e3f15ea972e1ee239cb92aed6e63946189e898e5fee97cacf125f6f282acd2cb4b803601debca12605fa0263da35c20e9a7c39f91bd963528889fa81dd814d159ca1f11d1fe6262d89e7d98c1a397c103f36cd693348cf8cb1bbdba10af5e82d00d979f68013db549b6650e7bfc78e3b5bef2403081574e3cd2670648c2f545f32c017e02642a250c385a167f3dbdb917433647dbf2b3b9b8d32e0662d26b6f4588207459fdb05ccd9a2024dc0110fb4aecf3cbddcb55147bd0d97b9ead682f9b56b77fa6df62b2221e3b7ad6404d8de2fed99cc3a0e873fac7a050d1a0c998d391cc0b876cbb12284d9e440ee8c9125883c08e954c2ff04562d48f6d31b52260397b0a4c0c62a0ce01e4680c38c6490601264274091abdaa23a1af8338bfc8037770443beceb0c6ef7e03276e579466c1bf0491526508bbb62b68f7ac689582663b6bc28fd443d7505eadf92b049ad5847b6c2d08a0101a667b89e7373b809ff6f928b5e52e3ae8f87b33661a308bdd0b15ed6efc20ebcce16f961bc6eabcb141d8b082f2d4466f4d1bebfc71d63ab54977dfcbef2352d2800168fda7e7db6461d7f221aa53847d3fcddf83fbb49a319532deff2c5d895c8fdc3e5fcb202e3dd84fee73141e32dbf3d37055f4396421e47cb0aefb7a3dedf345157d5262b0e1d6331ba9812c2beb4c914778650ec9a9912b0f1d7d3762656c6d00c376a965e39f4cba9abb67a34026f1f3624b5a5ec9747e03f53a97be9ef0dfcb459557bbb8d236278ac0cf67afb755283f5073d6248906c200e839ebbe6e4d97c196ac1f4ca723170f31c8d7ba59d3b661c20c8978856063a2f4d33daa1c70c1f557307f8923e1e81a57ee5f33b02d5c3add33461bb5d15a9908529d8028203750e63a8737e76eaaff0744a174053135285c646e1cf313b839ee6b43b2324e306803211de11daa7c929db82735c65fb52a8e3f9dfd61754589de4ddc2f73fd1cfb18157ca61d1ac3819bfa362de832ef2f200e82b5eaaa481ebd181644f8918c157c12ccb888b076571407cb76f2db2b61c6fd87e7c588ba16b54c06e041b1ad118bf1a52a431b2d96ca1248e09d44299e4e6ac5d39835134d16a5500da5d98ab05afd1409959136821b42273b39b23173c5cbcaae4e99aac3cd3d9cc6b284b4d4dd2c99e4d5ebdbf9dc12d14d8ac71dac2a8268c35fe171a7bef99e0bc5b4b5513df3594c758d75829ffaa05043f99418e4ed5d35d1624c9a336236f81d5baa38bcee014e9028056db2b00309174d79101975e3269c6b60f434da55bad6f396ea4cee01180f484a0afdafcce63c59188498874377d1cac33302f81db2206dac14055653a79a006c8a0cd091e67e0f691de96427e3df99c62a7444d8c4e4fda2e586cf50cf29c3dab848ecf0886c17c52150b95983914b7fbc17a9e9467d00236be5d22addfcdc6bbbc1b5f7536496b6995dbe3e97b31ce5a57ba23aba423ad0078640d6be0601904405710cf5d32d67c80512437fe4c8bd341c6c40d9f5c41ae92ec1b47c0da493f34d02bdb3f560c70bd25ae177417a534341924dab950982bcb3b4e82fd0360b3ce120334f3e1f0d9475e77c2f6edc079a1507f1eda5a57e93cf69058bb7336907f4b1be89e79770e586875fd3b216255eae02829ed7c77645ff4b1e71c9a4b5a400ca5d55040d91026d7250ea738cafa38fc3cd967aa7b2bf046392fcabf6512549a8453f480653310287d7026f0e868401817d869648431b357d9e362e2bab0fd36b6d7cb2d295bff7532491267ab3f91abc7cd69fffe4e50cee38cd7ac316774cc82606e94668b8cd77395adac39974e097ae8ba5652e9a74dfb07404f0a827778e4aa1e496d1c2e95b90a78f368a6eb72449b9c72a7a332602b3bd8bb28ae7045d8b35db9a20e7495989217fdc0b9e7a17e0feb24c89f150adfb2530ae0f8b21658cbfcd412976fcf8a5d110cc5b636e3b671aa92c6e27702ac3122d3ae9bde59a1b65155d471358bd79a0d7020e2ac97c62b485ce3ad2e3fc7002bcf3b424290f75dbf3ef2f27484be4efd73ab9d10ca23c648570ed0cc1a58b943f2ac91f33518285a1842ecd80556967b2e4fd908073ddbc296c042a65beb3dfee18c99b7f69beb0598340f5491d0ca05218a02695f5c178a0ecf43fc776415411fdba0dd1eaeda1056754294ca5d0115918393dc785722af894ab520d4c317843fbab13d56e1890a18c9751dcadebec39b6c27027eefccf3fba25dabd4ebc545d50f74f8e786c13bddf16bc899024bee4a49db38a8bc6ee0349f69159649fc8b03dbac25fbe39e359cf4649f15d6db12d6c7422ca01d60fadc6df5d4eab491c82577730446ad67e005456984cd616f15274b554fe1946cb24a0198668ceab2b67e9459029a396bb1af3718af690013060938bda831073168582a035e9dd8acc3aefd94dcd370975c51b1904437d8bc56a4b1341c6402ac02cdeffb228e2854e0256cc173583694da1cf33f95e374aba8ef5852440e61130d85e19dec8c803a2deade3a4c32edfc19883085d541526e89b030b89b1a7012aed66d77f207d82661db1267afcbaf39f75b51267099702097f6656eb48837cee39682acba3315a86e18a3596cb1c2767d47d461a2dd709b7bf970ab98425ce9bb04bf376cc7df107821b96ec1a35eeefbdb28e6397cd07025e868100263d60e0ee7a472109be5627cf1adeed8a8d5b0b97a6efefa121cb266308804d904f9aa9b36ba2457081cfa98685a23bffd20ce8a3a5ec0e7423cd642df24c6c0e1ad17772d252175e6180843bd1727d3afa0d15b9fe2b6f25e72fc40c5ef3ed5c7c110394141f6f6c4e48a2a5ef430c94c990ce5cabd04fa05453a4e4d3b49c952852a7f3a83a056b1b8963f6740a9f31b7b68913d064f55887024dcb91139ef7e4fe229f0df90dfe7eab13a868efc06f3905d6532eb08bd7a5675adc9bcb109e37f51b8770f0eaebb04adb534884a53b08572bcdc2537c1d9ab67d2f63d644ed96bcbcd9596d433bd9037da6ef3d8b83484532a966300b31989f453ef399d89f8833961ff17b51f2836e64347e959cc52f32fd06f41164558075c99e203f68726b8f2344f993585c4eb9bbbdbbc721cffda26e1c4e26c30c5cec3a0bb108bad725f8f4ec56835a4a67826784a2cf75cdc033c73cb487248de2cdf3775879c7299a4969978fdfdab5eb1df43a76027e1668b862b1d000f7b919f54ac698e11ca2f552c3ea86b6f431311d20cad26f61577b1ab00fde706b5cdb1e43aa95737c640615db90ceb57a89ed386477e58d900e714b2a79d2a9dc0359aa7807bf0d473c684ba151c953cd9f80f999e7f8c12072ea9c592f57d39ec1ff4692d228bda9f5d41464aaefb0a865a488fa75af0aaf7b243de18155c35e4eef97e8ca107330aaea3977814d7e62cd50941c6c3c501d6967f6caa51185d546c90e84ed1a19f400f74d88b50637c4a3b316bec894bbce8c37ba2669d4d0ec07c02dd373172414ac04a0a405f6168b2dd19006896337d217dcdd37fd0852339c0734f33bb20e76e45a5c043eead9a94a075f4179e7752e21bcaea330391a043843e22cd9094fbc05ba672a1dd1e6dc0ae30dded7b3dcd98fb48608d7a000961f94f0c8d6d5991c22a9e62488521853f35709f851723d0f43027a007fa865eaf26b22b9d5e761738fcb7e047690272fd33d609eec74c0dd691d95dce28680956c3362c7d029f5ea8923084d43ccbf3908b14181c0f094af7b3c2dd7af5850cac47fac962fc9bac9902539cb4993bac097dd5da47604bcaa24e4c736ab13e15b198a52105129a9a36aa69516deeda79840a8772ed0c08fa9720b30c0beb713b468286490cf936876a7dd79e03ce75996afb864be81919c8765380dd852b8cb92008276e0723f55b4066ad09254ecfd17be7a5f13b08dbf18c0f3c3980298f957fa7b54324bffee3ea69783f70a8f85bdca66093ed1460635771f722a18cfed9a40b451c2437dad4ae7dae714dfba5a268c11393781a0684e3ad87ecc828da4d1ab51135ea72785662205f7202c23882af3d9c83992baec0348d0413e1259a2dec2c33eb4cb1af0fbb7d4e4d4016753ff2ecb8560112b5c1b5696ddfa961eff215ce7c17b01b34f144ab844a39f0f861106ac4de86b8c0b94d791def08e67be8d1a689e1e56c7d5c3d652a7d4759244f1538b622f60cc2421efbf90532d1d236fc3385a2474505d2f15aef0a119ed3c6070ba884b29d717a8572679ca95d734cdd8583f326f925b9ef2513df1cdd7ac86495f270883e8e4f768f99cee2764a4424c254dde9cd58d754f6d97e448733c132192f1ce39a7b5f0861f347fc68e5fd5b2cc2d643cf57ea9df546016755be59ea2774c7600006f74a3419ab780d0a38a93d93662ec38d781c25a0f210f5dcc2eb719d7a0fcb15bea700fa059feb0aea98d3502b1b0139c85e2e06c8b8be5cb8d68daebbf5105f74fcf1b75985f2ed558d7efaa18f9af30ec86e697ace0a74b8c1d2caacea45e688b341d671dc43a34a78deb18c918aad3d6cd44c249ee07fdc4731c386e9d4146537b6c02e136be0199054bd9a39c646b1bb679cedd208aae7e3dfcc658167fa4ac0606982f496677060129b2562888d10d6bf865af82beb01d50e39f9eabee427b48f260732956321995537e494a4595d5fab88fe3fea3f4f6c6cbe080103e813d0fbc2b91ed3edadcd730c519d7070ce5de10e40f9b430cc64774e04a1941f9b4f90dcc4f2b484367f9d0e413882313658f882fd570f04bd7850fa16634a555c36bd5ea3e691f299f90cae81a9c4ee75117e4f11d24039d7d0f91b09fc02d6db9beba67bef643ef559199e3fb09916728b13a099d416f6110f2955321035f85e74d7d0e532a79e3834d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
