<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f30352d3cc05762bbfda522f4faafd9c1688e04a2ea6be4590679f1205f65b4b70678bd9d1571befe61cd453273549c1de665c4cad2b3e3427011c014c567b2d8dc529ee30bd3fbffa3e47b90c57af22e4a809a15fda6da1221ba23b5bc91cdd94b56506375cf22827a0de9d932b1640609ec1c27e346dc1bb8039d59ade57726dd6a1332efd4474e39461e67375bbc8ea9d96048c431b5a0faf38fac63f1011d68dd60017218b3f93c4638c1cbbdb75528ff68920f25e3786fb4dd353e01d144280a7bd341855de34d3a9a49ba24084412fbb0c6e11fe404644f8654ee032849b349ca2f106d3f9854470b89de89934f8bdbc311b46a4f47179e6c2da8f52c00228bf0a87471fc968b38fe6ec558b27a8a6cd3e34153af4625ab3d1b7870cb14cc2dbc3397f043b4a0b6f5ea5079897e0c9abdb4ebc022764bc9dcc0adc9b757f7e4b538ab01ea755f909bdaddb3154271cba452e96ce1471990f5afb25d317a92692a906e532a0b8338b476fcb9014cfaa273fd5737bde7520a94e7e3b89b936e685bba50ffbb5a0ab95de116a83fe3a4cca0e20c4d54a06303c4aa35ad7be7a17c7507b16109e5c1a02e58fe4d777d92e808f32d5c9d9ae7618756b82bba1a5b5739006631f6c1ba204f0ae235f234dd1c715dcc5e935cb3a03e37c9fedc7900cd7cc669c973ef7a49d1cb7c5514642a832c28ae734cf7f53b1575aa90fcf74b814b8ffb82c04e02ac7961deb4f670981d27ad02f4bdc175bbd5c86a4ec6ca7e29910fc5d12ad7466310e5fc35bc551b3e153fefe978a854b44735c9942ad872739f42a9a30428692c4e1450b006ab50aa121574bb49426230738c762b8a9a3dccf828f54185715e9b67e045a5d870a31c42cf3aea49a05e838e82c2a6ce45e008216434768d249ed7620ec096d03ba8cad5aee5a15f7d5aa32430792963b8ddef929e560d17c5d1c259f9ba5e8a5279bdab51b35b2a2ac617583db7aeabd921ba0d6a561d43c8b7840168bb5e0f96c035f2184d9ead1da6c92ec9b4d1f95238744a7bb9f547ae3599337146f439ffa32635a7004dc48f990ce3231827192535efe93a937a60314d03f476018f6d8fcf20de3493238e967d1e7a39101d47147a273b9a900e4d9e2aa72ef97068b6a1829185bd49ed69035fa289e1b0b582a35e121f642502e8d24ff59e08e6a9bc3da4556756d63047c57798ce8ef53bd380c943b3765e177be8f9de50daf01d25c3c35f2e3e6b8d0834585adb9f3aa9ef05786e3b4aaf88c670ab4b85bc6a549bae2a41d3418f4cb665e32da9eb99d6bd0e3bf41483bdfa062b807e670e4fcdbd90b8faf5645e3d0fad1f96600fe1a0ab3a5a3cf8326a28e89e9261caf65ca016db1079e39095e98a50b6d6c2c9148729605ba09b4551957e5b171aecfb23279b48d65c53986b113be2accce1625e048dce84a094bd43b0a8be5c7ebae85f8510a4e33b96b3386446f2ed1b4c0aeb5efefd1874f34fd34a8d1794dc6f66d8fb4752a986136e5f9efa685e69f8d1f73f0d8da24a788b26af62eb4ed4ea61197f334f719f401c3f01914d4ba6d67a5fd1db387e47c7163a35b8c471e0d460a2c283b1668ac7e58dab6a2bfc3da6d1b7716a133759508805925a7cc645c90e34b371be796fdd7411b5bccdcb7b22b5da1d1513baa09416999efa211ab07c7c1dc32691b54c091f2e4f857fad70f4c8475435e7fb18b0ffd8a258762b630c8d02ffda479094cac9313e62c8720a15a4baab4d8bc66f1e361e2f1d908bf2412d6b4513cd8ef81b6b02deafb058e23a7fc4d44a07d4fe6fe105c169563457964a5cf28b0ebbf5423c5efb3822f33430b58da7396bd35aeaee7acda132f444d73408f4e261abe71cdf35e68ee6d77be641636139e3102c0afe76add80f27c1626fcf90ed937f8648fd2371fa2a91ca7d0f8bf4b4b7bc1973534505cc44e8ad2c6ede2b1aebb280c553a7f22e4d2630e880a86bb35582d7fdf42bbd288acda5cef9ea5b6ed896d9cc1a4ed01e779c3a33e36fd208297d3ccf6beb756b49c5aee905b6b7c8335a6d167aa3c6a18c4e913cbc79253f212b25063b34eb670d2dcfcdb828d85fc5abd4114d9a523c93d2bfcdcbba469fb7ff3ebacd6cd3f009b77adea253e37a643fc140e9298ec354e0c0944803f39ed5f5111666c12f029abfdc71bd9545a6c2d86d531f63281d2fdb2e9ddcdd8acb6903859652caa7a37a6deb24d7bf66341148e3fcfbb101d0abff10a1681948db3fc709f9539b952ce482356d229bae793d68755069c00b5dfbda4dbbabd6963ee8f7889d577d5ff6c13e1da1c8a77e699d73c526668a795ed0a28200d56971e915f5f54bb16066e8a054f532a0957ba0740a7830f9b25d444c866a56d5b71c51e03eb7fa4bb4ad50a75add6e15573faee473f7e5404823d3871dbf4d953bb5653a238334738d9c35535423052fdc1b25cd3dbc220233df29b61a3d709b6502f1c9cbf9e135c35c5cd63ab89c9068560ced3e3d4994bb8c079a582e6972cd2cf1f4ac3e584f82b6b8e3a7bb4e04c78b8b6573d275ccdacf15db40d4cf416875af0d51e43cf5972d399255151e27a360e4a8283ca58121cdb6ab5b63d4840f51470f4c2cabbf036bcee3f6828a9c5ba8228ecc7b767234625e8a32114f11024e5d35a45490cb642db771d4e3f6e993d7efe7882b6953e458a617fd62499b79840b3a3a4acdbac6f64805b73b3b304c3bba843b51355610f1537adc8b07c02e97a7bd80d877dd35734887e01e5baab74bed8b22847c402beeceb36180d7e34c4d071f42245cf4a27e1475d3c6065940affa51e2ee11a9b10953da287920a787c708ae147215ec86154dc02153a9793fddad7d4dab330142d04a9e6a7c2dee89eeac26157f57a49d0b2808155bb8ebcd6f9cea57bd7d772b8835040e2a132920023621007857ed795359574ce97b9e5b0d1a2943218ed3d3a8075adfa4c75a5f67f6b109543e2f317b092596d7f9a3f1879c0844b6d3ec2eef644bdb34e315e9fb1e37e7c80914ff6483096be46f3fe940075409244c3e5ebd19a90379ef65155f2fe9feb6355e542412eedb457e196b85b996ce6b5c2dcfeed44064f2589f6eb69d12b4b6d563463d376e6d8918a320d0caa3e9303b880878d2d4acd3ba1c135accc36aad5d4eac065fef0cbd78de0f752d5ef9ce386414d69a3f432964515224cc7a14f6cefb920b42816fea4c58645dfaad1fc2f846eabcfc6a4f5245c338ea0d644dd8e8a2f495dc88aa9b5d48c664c118e3014c94421393745d6f1c5d1c807a8fd78bd902cad8d10d7eb28c6711dee1d0304c644db69105a3c221841b5f75c096fdb8245360d2432294b0468338bdbe5d08397f5eb1960c3f14269c263031ebeacd9cb8b3d78f28c9291e7a05fd7db71b4aa2313f69d71209b479d56d6a6cd7ccc990facedaa5a3e80a552bee43ac3889e6a764f5ea48a446c6dc441b702a1b4fbb8785c5b68de6d09a9605130e527454a9d3d8e92ceb852ba23e1d707ee1a5f17a5477c2ff313ade2e06556cb4bb88e261d224d71dc352619a34cfabcd09b701f64d7a73e87d3c02b3002792523b4d7846c272dc2453dc7893645dfd9c2932e07e5b19a02ca7b9961dce12586bd4df19a26c131587486aa71c99e065bd1c1e7f9b9689df69f6d2411d84be973fda379152a6c407166f4f935c51cd110697d3b0771e5bbf56e353f4e0e443961682b84794ba2c91de427827632224dad50d1c321fd94be38609aa2099a70b9f01f632a5c7e1d61dd262680e68390eebfbae1b5a5df9765c389ffe854c63a06a62a62c01bd1421c4d3bc6ce92361899c38b9115e5b761ba2cc99d76382df8792ee694fde03fbccb0a75ec982d36ba681880b3dda46a699cec64f81a6c145a5ab0eeb3fcd6ef8a28fbad440ecb2f71357e81e41d0035084f47204013f979062e47c263d4346c2a3e5f5e7823f715bba260b0c64566b8ad0112a05b62cca0afe838f72b9ed91feb2b38ab9c9ede7e4a6d77a8e57dbb62f3c6313c47c88e5bca5f10d01d635b78d3ee2e998d05d9dc6d38019a02608f3aab0051110a81d8b43367da3d780b32cee12d59dc098f34f05874b5f81d596f147332873a1b4c45d79afc7f00db5bd0d11f814cc0c84eeb95cd80f7f236b3c71348939c0d9883f88c32b514d3783769a4897bf500e6eeef790d5fd77e9f66db937a44ea83b9b05caf3e2e438c81613b5255333fd0ce0db1686bcbaff9e7daabed1aae4687f8e7f277762963fa80bf92c8244fe6a07a76356ebe5c9de6ec9b19f56e7d9f5422e6c2f2e30d298f4ce9b927d52a02507cee8f948e8440bc250cb8319c72160e97a58b04371cba7c0afa74340b75755f663f7d8c9f3638a6b2a9f01af5ed278a32b8fba800db319ff03e2eb805cdd9c15381ee45e6b21cc1d30a6a9dd3cdf89aa15a16332d392643a771c7cfe7c6d083b3e1c200d6ebde4c035cbf6eee0332681ffe0d5e4d831383c8e04d2f8d2c41c78bea442a2bf204043cbabb1429ceeae6fccf7de5d86bb6feb751d4ae41bcdc90e8daaf15fc37853c509c7b5850be56d76123c60a60ff0077f91a64a3b54de79afaacb30065a2654522a9421b2333357647222a5c98f6f618f4a8b9ce616dff94b711667a6bd19ffa00bf21ba6c285f3ea73240ed382bf51cf6a07e78e7b2371f79f86e4107939c3a1a58be21a7ebf1e10cbe88b0f1e767581cf32621a42aaa7bf1c29dfd9bc78f796016d496f6764092d4adab59032b1cc04ebce38de7d30823c24df4c292579d36222978266f9d9b38c8c7a7da71f2ceb40bd1461b86aaf8e7c14577f24dd95a850edc59c54b9dda2b60324fa59033e5de69f86155f7f8596632c71333b8f1882f56ae9d6252fb548d222f9ba6162ec206b312a2968e1f836c193b2d87df273f848a009c1d1dc42e3275761735a5e24d5fe0009858518fabef033f21e60d7e5ee98a5b6a1ed0cfe6d2a561f81d950c6205a25f04319b6a26c8743be69d1a3ae6af8ab77d5bada23e43b194e444b7e23215c0c1741d590d315b22b582be901f9c513386c98de73c0c2ac092df1bf6349cfb67f320ce4f76d031667413a24d6df58fa84c9a65e04a324cefaf0db3edb69a66e51ff96083339a4a11510af1b6ab321c51bbbed4b21f2959cede8bcdbeab18348c39ec628cf21b65a963551001a9ff97a1ad96650335693f333dff1b4ff59679eed14930afba97d24417a8337e1cb1843863bbcdabf336433e80b64a504645e80f7f648f65bd9f9f60cf721f95333999d92f56a96a928b34452119fe581d47f3d89ba31df3a85582c9266177a55c566439c754855138ffd7d757477d602c5dd84de3f5f2eb293b40115a17f9d07d8645b9c3c1cafbd02477e852b0db120d30126ee1d69819821889d5a4a7aadaaf9d021ce8a5f759ba0788eed33db111d976aa8340df26b0f0ed07b473b6e255a43c3956758c178f0eff4cf4e584e682a6682c28cb852f3352d42667fbbe47c2334064b5f2f8816de54bb454a35cb9d0b2646380af528fedb92507a79badb9ca9c17642b79e3776cde81f59fa9e9262bb5dba819152462ceda6974962aadd320ed8e65c9d0f263cd32da62b8a670db0b6950588d4212d681d42ef476297045a9a7654630dc2216d57d4d3e4a319dfcd1d696afdcda5435fa62fb479017817359a8045e63453c13e0b08dfbaca0f4a18b2f3811b7075b6044c8b21c294d108e380322c60c528e9ff328cf53970091a205b86ae468059d446e2f500b627b9e76e2ada859e68216003e26d3765d0cc7c015d2a90bb9898eb702f65c9278263ea3741146474dbb822f6dd1e6cd6cc5326c004bdc0f4fd25bbe72755d7b20b587f6f30f09ec9040e2d7a8431b988ac7c73ffc16a67f07305782005b1bc912985727afa2e43a7f6a60830d425334e22b01c54dc097124785da8d3cf894578ba6e22f3eb04096c2d4f2aa88e8dfecdc2466313e3c2d6aeeb61d1ab3d132b7715b7d196bd2045b2047f306791631ae05385860cec0ba89cd54b8e349bf9cbc0bf271b4aae32cc00327058ade17bf6d2da3a969069bc0bddf3392097c92bb241dd7cb67fc8b7ba2369b7eef3f77219d73edd540582ab03fabd182c229e901bef92d43c6ff77deaca732a73c76576772774af4361a163f0ee98486c16f13f59efb9cd1db2830f26f1b4c892c385be070f1a9b0ffeefcfdfcbb67bb8a60a001d927c928e70bb48cecc55687d042eba7cd27d2e09171eace36ddca25bf81826998c5dcc5be548eed7163b4fe69953ddad45ada4b79282d67ba2d403857a8dfdd17e2f7f0a8ed3094a5b34b005bb674f3ca88ac714e963c72b670a819b9907ba6de284597d6cf31c1006034085dc5fe46946942aa0e8aac3b24b13dcc67f3a856153189bc010802ad4dfc48494927e841f3f4abe62a9c23103aa93055ab12af5f7445b450466399076a8af941f0550bdb6693a99184fc7303eb7805e40cf3047aa01420b0651522c3ce8e60281320001d944fe593d3368c94d443536afe8e0a2fbb9eeffcd35121320787a84d667bf7cf898416f33197ee5e286c6b2eb8958d43bbde1fc9261631b1d35e0d57fa96792532b37c6678dcffb00db6ebe32f4e21acf5067b1660617c80496183302fc114cdf0a13512bd1f2cb8217fd39f8995d0210c954df0aae54c9fddbc755840489f72d51ef7fb83195e9e5d97c9683d9ad8c0e7a177f937be994905ca40f9983c5bf877e83a95cb690f012e5f99f5726eab0f5a5042c2efb06d69189e49eab23e744c03bb6e28172363f33ad36acfeeef2ddc546f9c626f0a256042f89b1d0d37025994ed7200069350c2d064d8136109fd5d4b58aa43e8e2d8ea7660db65f19f18ae505431f1034cf615be42d9a8f5a05f18022f54f9c6d5428621fbf155bd84385a0854b4072e163296dd4a94b0e9a8e191003745f70491dcff8b67accae31a29ed83cd4e38a1e4235f6ade543525e1d454bbdd6896022893ec5e386da077f53f1e0e0695cd493b7d827302a713692bb756453ec701fa127276e45c678dfaa9e220e252e5a3e8f6a2f073fccd84d527a2c5e358ecb10d70c0c6a9195fea7315992bf470b69b92c4370b51cfd84626e0962249a1e12a523fabc555126705bda0260aca5cd4ae48eedc7d5f48be682341af2ca2667934c19d13bef81a5893de90a41dc33a58f442e2b8e6a2e0aa74adf7fca3396c11a983082bd53c5df2ec5cbc3620d79fc4f1c82148c5a547360d48a0be36fcad316572d22090020de61e0a6276596b402f7bed3503d249061e15d1b6ddab8fd83786212d8ddf0b87e64b79ddcab8bf75c953cd7d45cd91fb96823d2aed5f1cf247363917b501c89740781fb6f61c63bbe310d5b641ab74a4db58f2367b23165f768c406ed9cb90f02f57ed158a82f08203aa84cd1d686f071c1a54b30eb18551dbf78f3d046a8fe8f91f92f05a8bd5a2c2765c5c8cef7a96d80601e8ed684ca2825d97ff69951c02ba6e2f2db833ddcd846c64d74c7d04b3c023216a7a10e80d548e369b3c19bb66911a2afb5b1776a3e8de230a6f36393803e2824e31ab367fb3c7438ed2ffb6110bc3aa95df1ee7a0184da224ca8588a9ab6872bf993c00f9a7bf1c3d8897d80cf268336006fc72dfe1f86646d11e1873aa6c6fe060be2e0fba0760769da1a2b930cf1d7f78d59dd3358371fa4451f0ceecf3294012cc9fcf5f6c6e865fa3e9a1853e09107c312e8c2f7aa7ed017d0e48f0ac45ad17a79429ea224f8445462976e942360dd7924b5e11290ad2be5c007d320df3b49ba12664a1165aafcf6ce071e92c6f896a7219e3791cabed98ff28e363d1307642a8b1cc5d3d5f8a17920c9d430b6a530817580baf1c6c819b7653b7b560ef0768d648c75105ebc0f1fbd06f580b58418d2f283ff5a9934e1bcfb79d9622d96958b9608694b821003381ec6ebf477e4f658f69ba927251213af950e152fcc0ef18929e553e7ad859f326096cbdb97b01c906761de6f9694e215ae0b8278e7b5d76ce79f0b44ad560249825f5a93eed1a9478d28291a760d905c86c5f81a47c8cadcbfcae159efebdaa9efdab2cb8e7120fc02fb13e4653a2096437a853e472ec033b0ed54b5d160b3d91e2a330fbfa59dd7e50cda2a23a3cb14495615dc179f3bde6d52939f32e248f6e3f561775e80931a7af07d664e273e3bb4bbf9c4c020b531b3d796622dd58bc96b5d0b4522eccd144b994e251e5a05618d8e542b09bee009122ec8b2498bcfa1537fd35be0d86a76c8324dcd0e33babaef9b1d33e336e76af9705d7496d8254c369f81bef09420e6c4f32dd2f8648e02bf475ddb892640f86c116a8eaf847a84193805030e73afddbf2e1e3e3ad8e791b12298d739cc2dd7a45af6f1061a8dc8543c5b2783057de89dcc643156f3e4d9665a4ae92de3cbbcb4b404af9c4c8936ae611185b092f91b84077de47da42b6bb0ff0c98f9613760e562876b2841f322ffa1c53d8a844d8f26cd5dfb7df88ae5bbe8eb2fd3543b399e0e83d06ad0aeaf0a4259c1c32a71373a586848f8896316d12b5522ce3a8550cd72f0031a7bee3917b9f4b14152fd342a4716a440b5d534ee1f69935acdba7c0c82a7655775d232bf87a31d3280ca37cf827601f5c856ba0b799bcc8d79e27b266092b20483ffda43ae6c4589c035493bdbf1b70bebd52516c967b8b9c4e07a5409aa8cee01e0d91c88ac2d60493d067ac642f8159f241eabc75ef1f1529162ac1de0251c73adc19f47b3b50d1a6b7161e97b3cae9032fd6e50ba9b309f3e61bf35d5b19e5d012545b1d2cac3729235c7d88b59fce04d05613ebfddc4698ef2c26ebb19db0e17dd3189515e662189d9d92a7271bbbdf4277462ab1475a4cf3978020bcf94299e6fd89cbf9e029827b2e1c6855e33156f43129c45e621097d0f13a700d5eb8bd2d22973901c43158967f63bbfbf36973771d27b15887298a73ebb9890bba01cd9589885f5d53196eb17b9f115ec6fc8a2c21d1424085eb820fb68ac751018a53764c5288288c22dd4cc1b999dfb8613ca4f6a1cd5450a4ff7b24c00a2b43f9ddaaea01e8e5737299fd54c0c76ab87795cc21f076ab5d83d95eef57caa48dc045ba5ee74997987bf5dfe2aec392b24c10ddbb74e7f3351ff3b1c6b5ad573c2165daea01808c871620342ad828762da6e800029b4a79285a7e9e13186653c8a0e97d12eec388c6b3d6cf2e0a8d1f0730497e76322d58ab8acc624479b929db9c1aeb3b4b559588a10403cb2c519b4016d863c442e8048fb83b219161ec8d04a6227bd5a6f0caa1e4e0624eee1659d81631620188924883da7702b54417de0f343f8f99d2894abd9afbb5389c32cee4cd26d2c144073c766718ad48f6d0cf7df3441c780379f9e85a41336adfd9b1018b290aa3e326a6be50b3976f0a46fb184473d07748de90513fa28343f694b6590e3d4327e9346370c512d67378e9edfe5551245c5ad4c9d99872cef84ae8874ee6a05f8180693c5b9da3e2d30a24aea104ca023d2154d408702dd784cf4ef13db1b8928250e92b2134da292bca2a6d05fd986a362c956e62a3b914043da2cb89f3867570ee3d16dd3f54e07069b570e89c6d7663b7e9b16accb9300a67a92b9335b699f70142941dfa6b25f3ede298cb9603aa22ec1396341a093765447623eb1e188e7208aefe78ca23ef903a420b90f5e8a8991aaf69b045cf7189db4d6eb12da188b8d353ce0ef9677f49b04f4c2f352cb3407cc7fd0fe13c63ef0c898a7c6952a443f7b8c8064230b23599fc36484c47008b5bc21630c7c46c67104463232488308faaf2edb8e4299b64a72d38aceaff62edf36faac7fc11aa2d59859848eebf1a7acf771c2193dbe92ba56e842e91af1b2da663bd33161348037a8eaad41039b956a543287458f51591634d1ff6e378a221a5b93215e32c24b5f6a05ed5289ac983d92e7711dc372d8171e3067138bafed5799dac2bec5efd51bfbf8079976c769e2e5caa9fc7a66e1130faa68ff8deedf73a58491280ce849b19a3cc1bc193f422ea45bdf4bec848c3a1a448956d6400f3a2bbee1b233f6df4a9e54931c30822f605de25f0497f3a6ebba5ef76f3d032822ec6618d25cb0b38c099c663de41950724797ea970994fd1b0818c78242bf7826d23db37a1f44b60e6f10a12e743a1177a2d6c19747b6e55c6b2bf8e9e9460625c9d9aaa56a1627f56b1161f91db6759dac93ce421977a8b88c01c98ac636ca367a332767f8a85a488d2ac055c11df832be94ea2199825b96083d1f8bcdd4569c7d4ebafba5cecf866b1d7c6565fc99e044dede287a1bfd9855518f2aaa9ddafa85e6527d96ff35ae9ce6f0027d7e065e22f3735ced978a5e90b5ead494f6a55816b9b65d0df65717a46ce89a0749b7670cdeeb85d803b3e433cc6251971c8384efcd651a3f235a5a65692719cd23a7401351fd45559127067ba444569742a60c32e36704a8f073262d41b2fca3337761c212c927bb6ab8dfde30f478917c70258b314366b82970f6879f7760704749f72d9e8524dde80e96651bd5f588336aac393de8ca9896857f7b1446aa4347a2f7166288779fabbd53e406b9ce6301c034c6164495fe90a925a229f564f6d635700471620221db352af08725a1dcafdeea815a0e4093645a5416289657d6ea8fb3748c1c375b1b769dfd52e1b738ebb16059baf1fb34c205959800e9b0c28ef7fd127a5775465fdd32831743a666aca57f1efae4e24c90ac3226cb7960c2be0f3ef49a4cd4206b8c7691c55bb1f1e41ce9059a8e0304b09bb8844e530493cb5b5a4384bd835e30941e4073e127e0565b69fcf13fb580853eba7e2648c4879710c06ec13a942e92ce3d55c62fe5ef739be05b4a04feadf8e27c22ce7cd2adc470ed6876ae76b5347b22be5a41626747ef370c611f730f5268d23ce5fb8d1697a5d742963ac80664db204024068418d5528323e225d887bb0e6a7e5e53e80a2d1333e79eb17ddb91a24c28d83c8266aa8a0d17e8efa5d7df19d301ee57291a94ffe94ce912a245c7a013695e6981c3a02c0ea6496362c4cf34e5f3f7d3e3d26b4af00085ba36075618ae25bede92751585b1769e000ff6bd58ebf9438ee358cc5440ebf046dbd4929434fc57bf2b8e251e009b428a809b86e004488f265623a1881f61aee70b0e3d96501e1f6e40a93cbee7b223bb7565a2f779151b83051b37be4ae227782d7a68ee81e56cd376db013388ec2ef2f0c88f76fb53fde18f4dacb36312b2cebf6aa5a33c0730ed0071e27cf5193ca3f57d24741a6f30094f31884dd38736e90ea250967b67884a78f50e37ae351b33bdf2fe5e4b342470b9936468ecb12d95264c70670a2df6134483533676722e0771f72631b6842cc4c1a7256e36a1bfb76a7a61183358529e8c05a11740fdfb9d28dd6e22ac9db836212dc8fe2d21c30e18e3fc9ddf123f3844e8b478a76ed64ce3602e1fb9eeb61b984cddfac3b889708774903ba08fcc790ae8d5a54d9b7c3d671a95001afbc3fe7a3370c1aaba214da05abdc43b259b77c357f172db488d13bd922f8615c6773411cbbd768135565e5f8c24c9a6f11559d35bcef5ff1f8d987da6cfc26298ee6eaf89d053a06d039c22a01bfd2e049c83265057074707b3738d0fe8178f89ba61f1d5bad10ce48a8eb2dda46dbd9c12c93a4cdab6042f6295424ffc7d3e66505167f5a18e0c6a460dbeb9a56469b76046c32ed8d17979e146839d938872d9a2c17e0f18c81b5fc9b43bfdb6f7aea1f705727eff52ff6a5222fbcadb8a8a12ff74cba07e0ed7b2b284bb80d06df2a74614d76abf1a502fb37084e13f37b2520a6fac240245a4919fa5980e34e26af1d445757495feea03e538097ef7d3b035e60ab374414c0e70a727e63f059e3f07bd387e75c47efd8f0c38403b31ed3bb5488a06ed9e99dd169662e6f855e67729c82c8d784458e973d62efb14150e0c8bd9c4eb272a1dd8de127654c620649bd7b545dbbce586ac1c882e023006ef655256887eba2e9aba4b00fe99008ba1f85294a58b1e40535d348ade65d6ca3ccdd86b1d17abff098368f0df8312528e572a10d13f6e7357e8cff59e1befbe4bf055a1a59e1453b02a9a3d68aa09f8cfca05cebc4782bf2b32737cbf40b8b3bb726c76635d5caecdd489acaf7388e1b115a78177d75ea6bc3c416d47b3dddd266144c21340f83b86408abd02be70c22f3269c957929f06aa24b92a9b183a074bd41c6a9259f0d0786271426c1099ed43d32f6fa8fc6336be107d060eb619a84830fefe3b012c22ec4f4b66fa82a19427f14f8d7241d69104b9cc86e852279f71b648e6aa8ff86ca0ace3bd08f79623cad47279c3396d27855239578647f2d3fe05b75123a1ed407a8b5a0bf3af83361bae9f219c2cb3eda00aea67078ca7c184620ad1ca3eea6bc73c4f0cedf01ab7c376675f29c2c515a054ff1e0d701488ba4df3c54e1ac1ddb8e28291d47ff1e14a9457f342808e742064d5cfaa75f5f7141f0dc20d06d6f906edfc71102568ddaf03ef3d34385adc70e1578f775f56ba10bf9a56959b0ae1567511c339f57194bd672b0d4925f9d36bed4f518c4499b287876493c799cf5efc87b97d334c1a8c708c0624924228950936426c2f16bfe91e3f018e67549ca97d90e25f40d5a0199ca9420c8731c26fb7bb45a4363a8f58d3adfee52202c6c1cad1b75cf6c3a339d9dceaea8c4d6914cba2e6e002e32b5ecee25ad4d0f38e35290655a3f971c80b61bcfe0b39126b3dd7322f3a40dbcf3dc047301296d387847be3f1d8d373ef8e33b7d15b86fa2f8dd4cf48676f84bc2ded684bf1b6ff2c1a2c93ce7936fbc5543f51d7e6478268fbad2c766c7af2f0e560b38d5a5d996f8fb9921ba57fcdb2ef9c4e10c6523001de83107d46580673eaae98ce5a7373ea8d02abce5fa6c235447cd26f42af948820ae5433ea34b1762eeddaf926f09d291f3deeffc5c439c0682fe2a2fb712b2812445bd28ab6aa85da7132e850f0a3236f86bdf4e9ebaa21b2620e4d15722b53c826a79e12d802ef7f0dc1c95723a4cce5ee37b3af756c355ea81333fb5deebae67e970d0d481a8d165027340e4e3822a11606351f29c6faa9bba6a153b556a7c04afd91e47115e820a4c4835a5ff6f324be5a8bfa4b5d422e860ceee5118119bd0bf48b54341cd76eb3d79ce44abf82d998a010f0106901274866820b8b07952653e2007d0d627ae697df7ee866805c53a1289af9e36c08b3cbe5e4099d6b1dc4ef9738f411051cf209b937b252d4148868673943050300bd2f989670d1365de848b45afed0129123cc3672da25fa5927953549d7ce6feed0ac84040fa5daf2297dd361b444c91cb87a25ddb9c7e9ab73368b0cfb49461a729a66a9e93473c00c1bcfdb0d502c9707ff3665be977dacf67535b892768144c2db8bf6a7a8e3d48826240e6ba9f2bc609f258f07209b325fa9bc4c1e024ac4fa4cc68c87da646b2ac3250a298260afaeb8aacbe7f98d43952439e05399c56d403b1431007820eae280c86db1bbfebdf4bdacd6f63badbd2b614d842f44b3a80e736ca01aae4e05523a914674d637689535f8d2ddaa16175a829657fedaf99688caca913c9b8966495cbb7502b10a617eb5226e0b0a0f8ec708206fad16fe1763e0c5ae25d9b975bacbdbdc39287c46c9d825ec596f86beb5c07e1355dc966135ff4c120f84472f7827894e49bf5fa65f1f7efd7446194bf9fd1db479964189681a9f5d74293d56474eddbe04ad2aa268e864a58ec07971696ea54e8883e2e0b4a9f1da9ef14869a0ee645a39249d67f4e92a6a68046626af00daf743afb50715576f58bf6c12a048a3310baaad61d858c3056d9be58b020112ea7d643adc6dda1f680a638d33956cb91cb9deab3b04f4890e284c97c49f520c3512c6377b0f8c1a1fb06db12ba70afb392bad7b5d275da34cccfdc49bf1670e361ebb6021cb46d2d7db3eb083987bdf5c28e896855bb014c28afa6add7ad0a3b254d794aba4015cb55696428739b63c5ff1c25d081af15bb2141a4538fc49af3d1542394152fe129f14e0914991c26614005a704c7df291e04f4d6eb4d4cafab99bf92e966af9a57bbd3869881afa7077f3ca8fb8f77095b1e7d297b0960db3d3ad5829d93db22e92af2cc23baee61556edea6713320cbc393f11d63081baedd075a2b223d27a8fa14172665d147c2017fad89220dde99fd6e9fa94403fe67590db65e2a60c8c9a7b795fa1cb7ee69183d8dbc76a4950777faa5f89c05a9b625bccb41353718517699734389740fdc71b11bafa0d24ce4465b4b6c5edb6a562ee600a7d60671651cf14b866dbb6bf033d7da140c3a41a1975ef19b9271f2c94c48431564119f1eacd831255234ff1bc776ee3ad1cc17170ff141706c55f4599b18ca33bf91ebbe5c482ae504bcbfdc8c1742fbb7df2294ec40fccb63927ed3720def9cf6f4ab661e0fd1aa4b4b9a97803479c6f30e1b428c1a1d369429135a299c0f63d3853e4ecdbf5631c531f3f38f85efa0c31867dd484d0430fb0a215c4854caf7e538eae35237f51ee2f9cf704062aaaa8892dd4a64b562ab6f0d5ed52ddf821376bd4578bd746610796931415a58146259715e29430e51aaa634ef07bceba5bc414ca8af81cf227e99150664d69ba4c532be0eb54494cab66bd0906f7e12d47918e2ad29493154f0ba4c8165e5f9b84d1678d74cba4cf3e8ee99431f9bb84cf4530dff0be7b254374f345bbc1d41ea3b5a32383abe7cf2ca5a05d307805d854853db27f24283d91f782142195733bdac32a609e092a6aa5070f15033970718bebdc045415091b746cd66cf39052ee4520036d42216b0a96b6754fa0f211f265b5f5c8ff7002bc3597239a30b596a4467b7d6979991f21b5616848abe61d49077f835f8b52bab778eec4e5412db942aa5bd046c96442dadbcf89efdb33bc0bead09b18a3d4a90ae61e551d41cc1a902a6b785602a4037a3f5d8f68f779cfc21eda4d9c0404fc45ffa2e31d7e6c3102f18c317c37228fd4b2dfef3146fa875946e798be65d847090ef61ea9b529e2322724830d9afc25e164620f61cf0f93893d68d2fae5a967622b597d0aecc17ee328baa8ad176bbaf8481267061808a32c766e15440c8f5c50bf511d48fe552d95396f427acf1f8946c9343c24057525b964f94b4edd0ecb9e02af572c5c8159e329f4e3138e18063aed270735be31a06c0fd896171bc8df511bbd28a2e021527311ccb1503630c76df6473e8de4b3b5153d8f8ba33045703a3e37dcc6305e2cb79a6db5dc8635571071c2ea6ca4294ea6113696197f7a51eb261a634b1d443adf5091b4193615a5ba91e617cf6509e024122638009841f8ef0813b972cc9062bc3e7c7df7d44565e4b4c3d3ff4ad5c6e695c46f82abfc0c0c9f7fd64ada2bab738f414344ea305ba7a79e7419e42449e3b8d80e77f8eba380bfd51c3dd62877060dc0d5116e55eeacc717f6ad04f989526412a55c64f5cc3bcb0f7e8072fde261c11ef9fb5e29a53ba1a3a2fb3f255c64e9fb3c4082c38413879df2c79a424a9ddbda4755de9e49cc328d0777c592ed0d8b123d748ab324e6f954dec8fb4fe79f31f5890837672d103ad6943a25de12ab1821b874ac2f77d53247358343b3a9796a84ae21264a530ea409654c3cddd43d201a92e2d9b362cb21a8553ce9ffcee28968b05733be51cd0b157e5eaeb6fb0a21e4b651d798454144833d7342e923d1f8d83157c710e6278a62f111a7ca93fd919c9bf46701a2a4087d3338f1a11ab8eef2da68df5ba239f4fc20489c0a0c870279c42fec117f7b74c47a1c44ea2006492b82f4756af6ec7f0a1c6d49db613f8395fadea74f2ad85a334a6ad1f9762b96f63e6362c58cadce61cfc92cf0d0fa4ef3a1bfdd9f85dbb7b698c24458d8b75b3c9cadc1454f590d3d58c85a5f6ca57049b3614894b06c3a8725b2021d786b1bafdaa00ff3bd7283661e70dd00db809c6c959675876ee1ceab7336fe61d7ce2fd8f830617922645c4d909422cb55ca406cbf2070cc3c4ffcdc0c02439611fec270dd82c259ea290044f5e1b3773cb1d995db5120d3427b65c44ed4a462737278fdc17c0cef388f05455bbd1ed516fbba061b1abbf56dd45dac5849652216c783cafa2a8f0b2236596b80250e0a29df4459cb83c019d3724c6706c10f4974a0a72693fb81c5337fe5d25151d0060a69f30e9340b33f205184101ff94155fe4f8c873cb93c5bfca81a4713921342a1959ecceb0d0ae4ce5def64a536fb434cb0382a392a06c095f6fd21c06b3c6be948332d335695d305c76a11565ed3697b8707a564c1d2815196565654ddf63f1db472008b5be3f683fcfc030285a1883e0f1ca2584e87600110bf3475a0bee8053aee2fa6b878249add58f53ba13c4d17638f2ee472ec0f25f77369f37cf733f1daafe0adf5f1f715fac0968b811d5e4e2f946fcc92fcbe5cf0cdca77342c5ebfe2e857b93fc42da886a6868fa6452c182c10021d0f260421507d031a351b636154be927963f11365d81553643219ca063e1b6b314866bf23b0901c13ae9d6b1c3b6f4c4a06d118415d2ae617360bd121e15c3c4dfe36af5927bec8cc1da4d19c94a2eb1f59fa483cca5fef22ce0c5555c5721aa192af88d5f08296afd75746d922c1c037d0384e312babbfa972d87198b7ae8ec162679894845e4b80705d6bc7d49d0960fd7a721c9a00608b19a9ec249a99eed580a16c01c010bfa96cf2a9f5ed747aa6b076b928c433f44832acc5cafc75f48102e32f107cccbb82dd7bee9699eb5a1b4f1fe3e231abcbb38d657eb2f900dd66af2ae4a9b7e13cc6897758e32fe6fe82a8a354655af4bf64fc936201032cdabc5fae11be1bbda26866fd9b74c71b52ff3acd26c5bf64cf06ca4e25f0e95e83e83c605090557031877befe202a4b991293867912c90e7bd1294d8bd53a8c5bb441f3803260cf30d8638d9da90d1ab598486fc427255d8f1ad928a05b0465e76340c09063487d68c7510173a3c9576313cd112f0c9a6a2217fce16f2bc37ff2c093f3ff62347fd4e2df9b9d5ac2e66bf970d2ee8ea7e4433f4480d7a09626d8525ab8dcf3ffb9d94adc5e60ba3aef79f90a2b4384a49187457b575fa2e40379d94258806ecbc6bfa06a2e6c9d263394f2fb2f0b6a22e5b2ab3d6e91263193e5effeb6aea73a6114f4acd9dfa0bd60fa409b43d65605390905368254a7a12f3f3e12d68c3f15da6599a80ca070b5ee1104167ba8eecc7e52422f27de96e89fc2b63f2b06adfebfac927cb1d763acdf1b43060b323d0a342ee8bd1444e4ad7ba3bea88e031fe22bf8a853c5d79c6c66c6b4bcb6a761c729b099c1345c092611c234015a0c81262839fc4f42b0c4531cf43164502dce5418b9f72cae5967075282420f4ce189251ec9f7bf0b7c4ff05cb554828a6e7c1f745b96e0d10c922d7d7b8acb4e9e2ea99db31acc49e340584dd4a0ec43ea433b2f44b11d216ec9a196662f59706fc356e9278609a810bbbc7e02a8b023af971049c72d25b3da0d9ca87f3fc0258b853aef1988b460b8ffbc8a7231acbf11bd9537fcaf5b9a48eb097d1b3e7c2ef76e032c1b3b9a7eabe1ba78cd0da8b7b2ce0b62684b175afcbd37ca887eae7ad45ad98c38cb9b174203a8dc7447ae323bb2673e8e7001795dfef3c3763e78908ca92984d068e23b1a4dd4814aa1d7514805bb9e9cca2518501927bf22af6645a29f37f00f6f78cac4edd4f92cbd2de719c05f5798203c24083260db21fe2812798cfcf86aa437a433d51747d68d75f306e32555acf1ad2ef3cf8cabdd14a88bf1b439b9db6566aed57227f54710ad45662cf3c7ed94acaaaf1672fa8a1cb98c124b57271d56cb26f640a50d538d9bc100356e18021359194a82a3b5fb337fe0b5bf88bf12be7aad24725e186be2a7d6125368f3ff1768ff48c2820d7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
