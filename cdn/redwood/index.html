<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a905ee784d38ccdf1e7fcb6dbbe6550e90e24ac00c0bed54a73a15c5606735e6101ad0a476e0dcdeab661ba69b54f3ad1c0df80317914b8eb0fb14134df66d65cfcf775e551b663e9120e7dcf009c36000b15f895c6956a8b15171a24cb93b551d740420c9a07b7c76bbb312ed5ca972b2806b03da8d924bb7e729cb92ff50bd9184ac7987af9768f080ae9f69e978d33a5cfac276eb1377394c716644023c9c83f1bc1fc4833ce0ae2e9f438fdf322cc317b9804b22b2c01dd17312c2ab5ae6539f1efa7ee2430c0e437dda0664670d44166b0da72d25c99b4b0816e6d05ae875ae7eb1bd412f92e6907764a4b01097aaa3a449c202b6cae425a11e360e3c373cbb6c1179b1f765093bb6c0c1e81270feff9c8e58694b7f71131187b2a1508ebc9d4a7115a908d8ec08fb6cba9380fadd16e7d28591b79f4d0fa5f1361b77518824f9ad044ea7ee611b98058c39ab14fbdc10eedbf6befbdd9172d248bddd4142a98bf89dce2974636f46ef5d676e8592cfc150323484efb472f96ab3a013b6bcf2a5c0a09ee712be9a3543f5af8d46a2401c9af4dd79ce8d5cc4a52637a9e3629dad676a6a45d02ebd1102db3bb06c9180e7a0ca699b89e600da7f5ee99d9af63af1f2b02360e9a32b6637c1be526666cf73838ec5e4b10a445450888e2f738c2a1fb83e0902f2b6a1acfb6622cd4c7e05af6614bdc8f4e512d0fed28216e983a131e356ed068f87aefeaa9b28558a0bf4768265aa548b45f79254db720feaabd9b3c555c8c8672fc6172ff529e3187ae57ad2b995988b6d63dfe6989833edfd3eb91f0d5f87dce33b672e09d169fc657a9126fec1ed6b06dc399fa7558b0dffd5b01ed884ce89fe534846b7cfc01f59208097f9e259943b7a0c0ba9f1ab88480ecdf60827808e9d7437edb6311cb175c9ef159016d3c002fb574279dcf3cc50a8f06b9f10e4b8692965300902b03e412cc0e2004723a9f2fb200eda03da9185f38e9ba2da4cf8fc4673c478c98efcc6f3957c5479270152a58fd6cd9381b87dac8046b94fec259fa7c7b2af04f80a990b13566d066da3e53519520f24c82a0b23131fe44411740847cfbaee7346c2105914fa22a74a08d501214fc0015dadd504bffdf5722e3be32a40eccb3fd42f9134ebead5d543bdd34fc9180df2d05094d80eb06e34d97db5c2e6afeeaeaa6e17b039a7db561bd3251a390a3ba9030096429ff32edadfecb5827a86d8db0336f188d2dceb80fdd1c8a5f4b918bcebb4564fa52046f2917ad2704449b90e82afd6701026381628ce8be401ea50ac1f760893a661e416a8cc79f1f96f5b6a189d5a70367222e3cacceb0f3845d9076ee5a3f9544f8a954674265ef03da088301c5f3491dcfe42f0346815cf6f2dafa3f766cb267782dedcfa87d96ad7c73f4a822a3e3eeeb10a96da81f352e506516c507ef5ae6cccf31832bd358f2fff668cd99a5438a43f5fff43000870ecbf76181b588ab3bce08d72e2a221236fff955fed18fa0d90e62cf3fff1110553d650f70def846884761ff4972e769c0a01b284304aca4b791f269bbd943e8ae3873d14252e01880a38bb5ba6e727d787e896d70dd67feaff3b5e86ad14ab9b262046901f540fb4198863ba887c4f7d5c2207712071baf0683d89bd96cd7240cba65c15ba174a9f4fcddb87bba135c2f7ffe1b103d16455b7419b13748a285040ae8445f579b25fa1c936df95be648ba57bc06c4a84b8231e8dd3f494b7f9e75e9c01a0386d7e99e510d20cb199e1ff31b67e65d4ab1f7139a995d7dded97b17d057cabb9388e0d9bbfc6483e629beb101e4ccec077267ad63322132ddc46f9c13c03ba427bd21a9ffbd9437f7237c62407546f1bc41c3053080f0dcd0e920d5e6d6a64b7ba1e57323c766b4d3f5b1c09082995580830f5fe0ec445a73bb2d234af7fff25e5f31f561a547a7866c82727db6f207603182591fc64eeb32e0695a848b8598facb6ba0e70d3c283a8abc7681ea37cb5cc032ec4ad19ccd85e1a1d23464b9c891f26f078b9423c52b839861edf06baab61ccb40ecbcafb001643c5072c9d86f807df38189be6a6b146452026d7f3a2470590d9e4d56635adfecc5c35c71d470c39ef35c00638e23a94233ea18384ed2908c00be5ff492a9f34023f0af81ee4049c688bd57e1b8eb135315ea47b4a11f38dc58eeb7cd7723a5766bba25dd7788d8cee6744cb5a9f4d55594995f6fa63350162df4bb93f10f686c19c52ea83b055d531c5a57bf548c1aea6e6f1725ba6293b5e7d5d2ce71a303c3509aa54b99633fd05fe021c71df3d8758e8f3420c9a81f09462c6ffe648d8ab67e351c4332291bb1bed44fef7cd4aea314bed1ee7d15021a3598809e2322581724f67f9501ce459de34ba199abb0e59ac317c7468a69e36fea737de18a0b5f472067a3d4329090ff78e441f8e24ec96415c5198422a9b1285bba8934be206bbd435f6d54e0624dea8554cf24730bfc27f52f22546aa45520d6a259ea1294b5a74af1e4675668385da1403207d0777b4e2c217c10ce424770191c97107f398fe28665f06268cd950d19fd6698fbba4cf38d4827da9200e17e80801367f367da910acba94424f09f58b77d9a07f6e8e69b18bc9dd5919dfc9556bb7a3973c736c01a29f9a98197df7c7fe60b683812a2a204eab42855c2a2162e5c9c79b59640c1a1303f4dabc342d6f7bbd62e0393d3a9790ffee71d333aedbafec1db3db434cdfdddc9062308f31f9c896526bc00cf1a173554f7cdd9d41b237880e777f31f00c3276cca80f4d68bb58a158c64ea46c9ad39e86f26beed032970dc1cf1644c4c8510daec42c90a1cb9fe226a31777c399e9bb55fef930e272872b9d8129dac5afe6cc1430e17d928163606bc1538e6bd63ec174e353ce383bf7618b54cd1164c7ae3f6e2c09d2940d49aff57e0743529df7111bb397fa3d66a285f86386bc8df611fd421a2df5616ded752e60e15c611e8a107b4297a1b46105ca968c7add1e8030a8f827c6dede7a360ad3128e0d8deab050b59de3df33761f0647568ea1054e08d445c176c87ad4c05f3437275d4cb69f7520cc366e7ea4e1a3b8daf07751296b644cc2f58ef6316e7e162fcf7180e7b187c01d80041d28c1e2423f483bf4f495be2488b8b71eec5ea2ab821f7c4964f67cac95d9f2317efad0579f3f631c45d173f0434cd25e2cfaf6e2d9ea540cf017e2bf78d65f52e82c1651876b27f504adbf4f679d6b592e34a85efd33357dd4cf50ba18da68a011d063770b136b8bee1c41fea05e2328f673e02dd0fca4e478d71e99520ea6af79a639e83596fe2ee3af57e7b09f0640bc0844f67ad356362c10c8275e6ee05d9992541aae734d7de6933896ec4154afba73564e21e04b4739634600ef18640312aa55e5117f632838056448f9472c978d6af2311b13f9c92cfbcc4389ea7a4118923cb8efd84b53a34f0cf352f84fd7f4ed32187e530758f6f08ce93bd427d58d821dfcb923678c1667a07b4439304d1f5d09fe8d9d9214971190c328afdd62e8e773ed9f0fb026f956a410b97057bb4f3be69ac28ceb4ba75957eeb673c30eb13c9f04bec1a6f179d70122c14d90982acc64caf2e3f54b34f6f7645bd2865cf4d78cfa98fbac8dd6662eb66cd4dbd2721ebdc618e790776661a6dc4bc8a304a965078d8b871065074b17334a8ed53d3833f83ad5f834cca503a3fe093d01e7bd12532dc205da7064de1197573c1de5d26273c570c6bc1021e77d4a6a7ebd1593523be9c8b37fb206b3672ba0df50543a243adf1424d6a28ab251ddba9b861505ced7ba8bbb4cb8d07be74903975f67524a0b4929b40adb0214ca174198f38bf6b4065523ba19e047086b4f989fea7714098f52daf569de40cd6f0760bf769ce27f9217803713882d7e7145de75a314d254a59c08f4599fda6ecd705dd179b2dcf088a915dbbb582f320aaefda0223d129418708d0e319d313a048063ff88c728a0ab4a3605ff45b66ee16d1b57e4d9f686a362bd9665a27f7d022181f9b796c562a666ec0e1da8082112e8eb05c01fd58740a49e6ef882cd562fb7c6d9a8f8219e891140e8a7b16b421ebdb78737e8c3e2dc6faae89ade69e02b0607a881e1b914b9cadf605aaa4e196e9ee854ca9e1efccad15c7b75dcd0c6879e81b7a92029e1abdf0edff1dec6d82161844530ebdc5b57ecbc414636716b52495c0dd2083ac3e393a9f38508a4215274c2de4b55db0553efab4fed6aacc3640525363ee018b4de8db2a0b8fa1ab9e27f2ed991a914f7a1fb2fa1ffb43971c7604e2f6e03a753b963994507a432a263c7440b3525a17698279e684971b45ae2c8b3f422da42585d928e611452631ca73da99ef50ffcd730649885a49afaeba3d7f6acbda42f4a124cbabfda7519b8beea8705d7b66337422606dc683002eaed34a9416a5b7dabfe0b0e8663c896869d557649169b7a046ef8618850e9e11be232172612103dbed0e9b612e4b32ff776d2217d159a7e903d3ac5a44500cbb02fbf4c2e9bf6cbb3cac9f625f0fc49562e8025fa7da7134d58f662ab7e40c0d49fb64b777f6e043ec3d9bc90676b22fe8a676e913563814f5238e39d4684a8b4d2221039094e9eae75613c9a8ae039a0d3441f166e0cf924c731a36da865fecf3932b006b0aa401ca60085a38cc94e2c9ee057f46b833100b98d539654196f506d9911beee34c6ba23a5b763136065e52e98fadb0c48176b8215478dcec9c377a264c086bee70aa8357dc9fc81720f533127d565b4b9e88e1f34ecde708bb7a664f6c5e2646448ac056ddb15c5a9dcca5f63a2a846d9234dfc5969a64b4a899bbd224bb6dcb7f172da27174c9eca4fddef5e550fd7a5ea6340a6b6e03e12204fae1bae276c8a4d6ef5881d953755b4caec1ad1eccfdf4a1a9b9b1dcb1f596a96b22791e073bd4f4f4bd2eceae208b78d765a1b98f0659c649c0f7c185f61a9e46f5e342183ab9e28d155016b90d1350c9283e6987f3e367529a531ca96d6d9f961892c81374dc653fbe1edd5a373a7eb22d2ab3b8aefff058a7e6a638702c97ce96bed739ccf82fd5b861c2508bebe28bdcccfe789c443102a3c06075d7d01dba74e43b9f50b40f80602807795ea6aac9b6cb4ce31fe2a2c37ddefa6aea28e7ae88ead122c0fe914fcf84fc5ba733b16f352cccc81841b3db62a7e8cce9cb4ce89b33d2c48baf3c43fd247c1301937b8eee8f180818b21579cfd408375358594787fc9a5ecb61d2d2dfb6ebd47b2a446e15d10dcb37c50b44a8de37ac394684b3a1cf7c754e87bb93a0bb434b78a721577ef728f33076a303bf419fab03e0a6f69457e3f0a57438a2bcc3f93bd384675dbdc2a1fd379148846af25de1d2ae01ff85c1a90f2e8486381d7adfcf316870f02785072abe7c45ae11708070d5d6068d42c5e7d07e67883fb02aa7f78d1c87480102bc7c569d80f43e17f912786785ce931b9df0dc4e4f66b85ffdc134e9ee30e43b37c404a90f5ee016f03c202d01adfde21e59a74acf2edc30d1ac8be3ca3f2977148a769709744a483765e7ceac91d4c3d7f4eaf1ba03e3dbc5d0ca1aaf48ced49323746cab20ba3384de252f949328610aaf31dcc1ac78f971cbcaf7738b4f9567043feec806e6d6e40877865c39cfbffb087515c174381950d28198d9895374131e801b0ed66a52c60d6060627ce37128cb6bd7d5bda61dbd32a736152d2701d38d7e1ef8340010859ae134416f90ce89db8056857b0c309dfa50075490bad6dcf392a9296ca1538a916f6c2ac6121ad1763ab479adf86b64b8dd1e789e974102b987bb4664b6d6aaba92ca23afb7678748ca32037eee13d79a7fbf6e527689cd48a3342f2d35c665245ac2fb7b067c281774b93070ebd73b713d9321b573cba4fd2b5e954b79e775d00dae1265233d6a7669d6967e794697141519598463bc5cfac5761b291c9bc880ec608d6f76fed0b889d5811a370446b1e29dd8de2e3c8d6b599f4ce1581a8d76125b6f0bbe713ae9d34619572b89d202c00c237d68a3366ab3d4fb13a7b6c04f60ce5259a8b3013ed4608f8a7cede0fdd3f63597e95c625acf910f7c75933833d088ac0f2f25a6040507f531cae2f5af931d71930a00e3b1f635c497d9a2df5cc3f8dcddeb4b058e4ef13e0d30595482444613fe25d1ad048131f53745b47a5fafa14eabf6767d2d35b091fc841f6c02e82069695a5834ad118fbfc5bd0318bf32730d536a1618aa9cdd174cd5a6c89d2016588acb3091180ad16094542162ed799776b56f5426fd591b92cf12c8b786587f351114167c5026028786e26b5e9ce7156faeff56ecbb75ed90e11d9f80407423855f6ec3dc7d364b4f42497c88e9583fb71ebe4009638cdedf3bc11ffa6467d3a48c87cf9a941a436d303313086eaf0295f8837973fc377d42e9a6d821c2d5892e02be4304f641a7aaf2a572d735212360eb5686d457d2a50911bc4f87a944557dd02ffc24668f1421d9a12c4c4f7e727bd2f68555adac58418479d099297c367278b7415b46cde683fe88026283c3b876a0e90813c23c211a017c90dbd967c045e5e8e30f881da842b1f945a081ad9713617aa8183f09d6c66b201fee9fb2925d1744bdcd392b928b9e734aac04cc1623220649e3910098543f4431192d59bbe1ac7b3b4aae9b13024630e99ba65ec725cf8c8a6e326c95a1355877d273ba9dfafe96e9bfb34c69fda753379082b010391ddb5da4a7ce5d80e14e27dbb8f16573d477d2f12436e2dd2e8a17d7bcd9566697266fe3a2a155176444e58610ad283ecf067c43ce0eb1d56d4550d7f7bccfa5cc2caeee468ff1dc5d2ebbbaaa1048b4a0b67bba47181b4afe90c8c379b8689efd10293df0b2b62021f14825c53c97113c86654e1e951a3b967ef61d45f3505e7d87edb934e78d79d054159319d389a9ab93cfcc44defa702aeab947eaa45d2e8773fbf57a13e3555bacf561f66933981633cfb243957758b2c9058fcf41e0fab5253f0739276e0153612aa9f084aefe89c72b14b566f58292126f308afc6dfb540d37eb66756f4a2c62a6782ffb95e3335666f313f4db68927f9b62993b8f811e7c14b84f5bde7ecbbc52c19adc669002ad422913e856e08adf95f75b2b49da2f2df572b81b818c63bd82134aca3ce20744d8e6deda733422142e8352da8508e608afbf16064255156ad528c357cbfac6dd36a5a3fb0e4dd47f838ec6d0ae31fbec0e77e8f7d7cffe19b4291df46093de34dea37f0707607688dbe8d932e0353ec99cbd48d37fc4fadfde58b26c3805804904f5351c8bfc32b0fcd5e54d4eb1b9c53e43c6170a72fa0e28ea9eed382e0319c34715b40ee4ab7567a8a243ddfe85eb76c874f916bc571b297c9bfb0a757d891fe61388a54781b982dc87f342aec3ac11111d0122288a153689927affeb509bb464e73843588cd212b6ffdc3c98d0b6c9b4eded1948d05c2b2cd0e28969fc3c9aaa406c88287ef889ce09c7daa11d8ddf11b612f5ee4d63117927868ed0ea77b8298270594e1cd5d5f3d0b437d7570b48134ce5b74f041197a03acdf683741eb7dc0387032f193c487752b1f91ae401f01802f0a2066568945d385ac02dd71440a710125b60192f76990c287ebcdc46739103bf35349b4ef87128222edc506a95f029a1db8351319b7acb2e305c996498b3f6b94e8c82d1493d723597e2028c7785248ff1c036f5e5d315d1c1866601a5e7754b92d92da25d8002e5e6b234e8c2ea96fa923d5f37c82989d6f293cae28c902e6b5f070f32adc3af247bdb4bb1d285acba41a8a373c7dc4459ff46e3d47c3dd149046d634142c9415e1284572beb63b2b8dd6cdf6de5e214d25609f28c6f07e29ff1b94f21200aba49593ca68be836129ae6a274b986ce8c3d9fa9d69130438ac4e8b0a18e5daf5cad20be45c816fc3d0f2a7970d40a940314fa67dbcc2fbe4ec0b81055c53fb776bc23d6cbaabfba6a14a0c6d01e5af5f3edcd2f826bf911d9f37830a2532aa5784d51027264c600f3df164d5a1faed0ef1d2280a3a8a06e2540ae5a18bc06bb4ed9e407127fdcba1a67cb09fabc2f9cbd8c083d75930453cc6b55287674c94925211cfbc749ce3bcfe128c2c6614d1c5348233dd30c7985436c5a1d9389df56c7fee7882c665a7635f323509d761df49957aba4aad4b2739b45a32dafaeee48b017a1feca83a49e6e0e7fdf3b12f173ba340c2f46100185a626d3fd43653e51160810af63ca3df158776930570c6f6720c85145b4ca946f2ff39cb1fccbd97703c271d7ecf19d892f42413efb737d6fdf3c247fd57e9bddfc08913aea48c15cdfbdb0d932bd14274da464c906c7fadeab6f10fb7457d6d0f2b5cdfc9b1eac11e4e91ede502be6ae6813b96a13d4b62e588e0378bf65e680dd6b2280b2738696a55969e5d28b970d620d1cb676b3654ea461a5df285831c0a48a91c0b24759c47f1391dd5b6f6a774746ee5a73fdec554064a391ecfe1ab53bf1b592c60bdd0abb9159d8a834742b76a626f70dca3735bc744289d8c456fa9f0c341085793203582b5db4a06803e8db7bf046570967c45dd37e6a2a135b884d0a0d740bb3caef39e2744e70604838a5b5d20e257fad9b86cf129d5709fb8c106c10ac55e5f7955b5195bdcab2979708a42dae3fa92821cf4f872ca562cbf84054ececd2f395b98db884a7a050f19a2ce6f77c98b611b3358eeaaf727c0579e913431374f6a7732bb7c595fbed95c94cb8780471f19749fd493becf8b32c886a1870c2d62d11a396c6f7aaaf6d7b70ce1796a245b97a8372356fbd0180e9ad9b332c47fb8c4973eb9531811b21b02da11685d2fd473d5807b7df973400922bee0e21e9060502d45128a892a15061d1910e6805bfcf3937df5a94ee4e3928e8eba14a9216c652e9235e7600ad72f1e1091d718d0a12001939118e849ea2fe6131e652a89fd37e5a189e308fc663b65d5807e34616d59b674b30faf4b46fc0a0b2efc974ba0e5fc629fdf9bf09b06b25354c4b41aab078705df356aabc34f1ebd7e82978e7ca36b516262ee2ab8f0b5db2cdf23ed2d6f60651600e6833f9b55b7061cda19696d56bc38ca01f1103abfd6bcdf710aecb2ec2ac35e4debb5d0a57d22659254bdb778239cd0d26018bcf47ca019c0de5fc807b23f351dbea9cb64367c7b0af1733401f803e7d272afbf57e85ab1fc1ed3146467d7b699f442d6c9d70102ceffde349a89cb25cfc17ac969ee504d3909dbd9a83f6d10b46f14b71d0ac4a2faa5ea0fddaa3f9f5560799f1ad9a2f7bf9a420d27c5a32d4c675bdd7c2f5afff3169f3e3bcd7964dda0a97b40da109bdd8834f7628633ce4088888747dc40fb09fe0c1363897927abcca0c841d98b77a9cfee3ff81d08ac993c2ef3f267ea1b73d2ad302c9dd3d4823dc0129b23fdd0158142946511899604725825f7a07a6ffd4b9ab904a5c2ff47fbc3a9dccc5270cfbd15d278b8d840f5c3683ea521858a595fa5220cad36c76330946a6cf201570f715f8ebad1157142ca38ac37b0848c9b0e8028ff2b355e0b3c6a3912db6ab6dc937fb7b6c4b7854c65d53777a75aaec368edc139ace34fa1a27abda82e42b3dfca72a0ab70516bc3e21f35f93f4d0506e186f4f9d704f1466493dd3758ef6cc1426984c73d837c271c661806e830649e753b978a4341adbdd57c2e1b4e77d2219a4ccb5e5005811f5f3ff76463432750761465d48bc8277f9b17f658c2f63380b966aabd855e138e05d9e1a101156977810bf14303f8478f29ddcbacd057c7b813bde0b6694e11a5bde3268315d08168685d30e6b5c21200b43426ae502d64117e14df46ea1949952aceb8443e4b677d53edfa6954da02049b9fc1cab737eb1ee46629f772bafedde1dd0d8e8f88488959020f2c73f8f1686a14a9298fcb1012d267071b1b3648b0f1b44659ded57b14f2bb5ab900aba7d8600ca2ffe8f4e9275d29de212e302116c841472aab92f3e5dd61a7b9d69a42188a66672a536f757b97bbbe085b0b7a0ef11ce88ef462734557d5f407abebf2e43f49f38c1939d4effeed06e399e615439df0ade9d38c444a634a01d5ac3938c6cf92dc85dbf97043a170e0da699917958d889f4609d4888c8dd6380a023011225e895ab02d015c5d885fa4c9641f053e2edfdcc6fcd43b2245d2262a79effab344d122e69e2a4f008b5fa6011f04c556df96f4e02cfc1ad77d44b7535400d721c7f01deb05e057dec408437ea9380496d9f5841bbb7388013c4012a5a3199bbd6368b5bd317ed20b4c4f93af996d52b45ab276bbe1d8c42b9e700005cfc5b6d4a6f494670407d4015a2565ecf02afe07cb5937004a35961aa16dec26d420d086f4ff13617bf29696bab225df1dfaf49afc7afdee4c4db8a476f09ca2dd5cc81228d1d05fb2f80e697031bb75a3f79e838adfd749762a2a50cd616b45b8685b26202ed4bebe44da84c64eda4d26e868c5ba141e40f81aaa8bb1c8d65e62aea45354ff3a5422cb9119d92c85947a71b5508ad69a35728df1a5e09ebb75d20296f005b669bd0292ebf16220849be8e1777b715f945713837b66d40da1a658fedf36b08b32ea32f5aa8b3823cca8ef4b43df20e9a362ccc037955771d5a793be18ea3212221401a5a918b1db45ed643b8b084b1ca00bb53f6deb13d418f7a43fc1691df0a492f4fa2bf6525fb449878b80fb54a75a3bddaf4449e0c4ef2c17aa0c68918791e9f86a3a3851bbbd7443e17a3a64f738fdd6183a134ff4e180a3bd6e93fc6c044a456161cde4b73d3d3719bd71e128cc31adc658848cb57ebeccfd05505acea9c56bc9b3cb43b80fd2f4bc9360aa3105ff135b2ad0a6be90ad235f27a12db98cc8b22fc42191e24dcf915c45212568d19b4de16b3737657ebad3b04c9ef05199f45e1add6c92bf8bec07749ec75fcc31b05fd93d9427996cd9565cbf1c6240641c4bfc409b1ac33bc61d95fc82c998988339c62fe2f80d59cde26c8e5215ba4d3d8d88bd90440be52c75d3183a77473b8e1b53c601a006c15a1a38bc27c9ff0de423aa67b933a0b1f538dfbdf9198e7a24747d102c1dff381784e8b95dfd18d550132461299e7a5e7ef39480abe240da8a2ded3fe083f8cf0fefe66906bd029f48751e34390850082cf937121ad1d42f5f3814637d59bb7e99afdf1db6a05052fd9c0279a4db03324c2dd20db31f8dce34e629f0880fb6ac1b7397e4de234c47f220caefd10824ed2c2246d79439a406903e5f79944fd823a9fddea185531414bb80cfa80202523ffd5e55a15fbafac4aef7236af369bcfd144334eaaf133f5e0209a56526b8f6bb14f001001d0db56563e8d740c3b7e2edbf6f3e270997a87d6b4387b7cfa2350c73f653883184fca80ddd64feb4c7e7c6451d9adfdcf8df8fc0904016de2e9b5ac5c0a30cd27954fbc24e88f947479cf89058ab7933cf418c4457fc66ad435d4da5250acbb5ad180657e42f749bcd3857af969fbf886eec5c513b6a74a1877ac9984af2d6f229a8a4269f58fd7e3b0dc7bd368779c67f1598129ecc45b6e37189597b3cd3756b1f557230a7122cf49b5886920dbc74bde04c2010fca78acac13b83f752326e9c0c707b9edae6d800547e86afae8d55659c38079c10dba5827461bc166f0a93555b09e65c1be291cb02e80ebd7b47f7d0c33d18ee7203c3f67f99ffa3fac4f939033f10f98985d82ed5ca61ed930b0287f82aae3e7038b4c26bc943440ec88df2890bc54006bb81238895962051a3c6ff51a6197c5293a950bb17ed2fb49e8e76a9b5297a0d891d9fe08e30da634875c6169a5d8e50d00723c5398e7358a9bc581e4b32901dae5b2f961024db6d727b8c66a4470cbefa2f143135f8fbb06c969cdb4122797e142c3ea97017c074c17ff649f208bff1393fb27900ff52e81e64ed31c7ccd48f5912b67bf677162f84a7b95423e992a6816422cd850dba116533b50c7e85e5375fc98037e254d3e0c369b4be8d90b664a4cf06bde4898921b19507771269816204e1cdc3d82053162e26b2d67e054c72fce7c95ff2a003af421a4c423c457b02553483d952ee87e6f651567fae1f2fe5f53109f647af794d20da4b92eb7d0b22e0b99846c76092617de83ad71eab959428d4df9d02009cff4c033328fb0cc37917a46192e622e00a768e30bbad1a9d56bc579005db49371bf6a73c2b039984c6eaa04262da35d92770a3fbd3f2889c28a25c5497368ed0658a3b13ff9de11351516d747f38274d0d8e948cf3a23e502c045102c7c3be3e2c5ae3c4e55cbe10b189ac8ea379a46ebc815a634dedd24fcae76c3dd99401a7d6a58b4aac777bfcfb9032064c2b4cccd292cc09403ab39cd71e2496e4dd39bb6c0f7d2b2e6bd7c86158ad947df3b5007a3845c61ae66bb59360e31a344c1a06c7c5bb74531ef3d481e19c15fd7845852bb213f9c6ebc2d64b1c4d279b3244a17baadb976685c9dc6d7dd3bc2ee632aab73ef2bdcbf2261fd56d2625f1d606e6f2cd1fbc67dc1aeba5a6c8dd329e663df9abeb55e55e813bd5e394e62a79f3d64f9b86b041bc131033125ae6e95c38a248f81ddc0c700eab5efd21363c6ef682702029b75d4a489249118f7d52ca109397d31de058740461c096d181b5f12ef289c29fd7fc1e79b302230bb1ec503fb9800783fa87bd987d42b8540278f32127690fe70d5f82e059ab946e5e606e05c38f937fb005f51e35292ec6dda0276317c7caa6c6e496c3a00ee251303bf9260f804cd27a760e1a0f415e2404364e09a7fc56e785b1690aa54a0611abeed48a2e25b30c1ee12f122491ee32e27e92581f51be5c31c67d3e315200c2b0827cfaa7cea392434c713f9c8ce18ac77197842a5a9d29efb6f487a75613443e793c1a779e6f52dc76695e2cc16292c5dfbc1f5a6e1ca068e15dbec5cc5111f20d4a192091701a58ebf31afbddc727d3c132706c41427f831dd7790a05fc007d6ad4343446a272cdb588ba305e7501ea092104a028fb4cbf8c2bc5ee6807602890a222ac01df96af5d706b9194b7e32918b092ba68341e5b1bc1c5c888a77306ce7adea9ce93f2cb96c541c3c2d1a9db80d84aeb8ac970c9c2cab60900b7c529c8898e80133fbcf78a8eeafd4ffafc7bd13c29513c9d2d127c3517f6600109b5e56b5f0254456064ccb3820ba1befa2d99d670f2442d3630fa7b9ed43bfa00f08ad87b86daefd539cbe22d296603dea8240f36837c67dfa62cd35759c607d6bc866f0fe46ae9cc0733e8b47e6afdff60a4b80d7d5d56cd32a4a6198f06921fff3d2e6bea91773f9bfc297f2136857ecc8b5177e40633a3809f78ba3abe75226e8a4200d68e1eca537157985ae822ac22145b0313bbbb2f46bf96a88a6a8c33b6bb0959ba3aa1a38bf608c8f28ec1451851709ed6e709aaea49b6bc2406741893235dbb044051927f1fc87ba18200735650eaeeb1579316162bfcba3c5039560863f99cdc8749d39e8681a5c4cd752b94f61d4f847d0ec876fdd2f2b749d34c4d9f7aaee5c63731e5ba3e34f4b172b959ede58e510a1fc701215d162d6c691168bd91afa02444f80135f8a13ebe9167fef0a0bc4a9aaa6e868613777bc9c238c208c27b44e46b19c31de3a0b15a2a578442291e5fd254416693496b19f0a614d86a50fe696eb05024907a4ccebe9e80802a3e9b923affcbe661037fadb05a51e1e6617835f855b03509c5069026bc55fb913cdd34899abd3d1b79b023581d6af6f2d9b45c6f830115d6d82ab858ccca76cd1e014dd505d51ad0ce3c0f90f441abfd09ce52c30fad730d92ca64c9e37db7a5f047e347f5854cd723da43ced1d269439f5a36918703ee8aeb817b1801c8b360bfd8688770d77b1c4a56e63c536f3f60d1802f7160341f6e4d4b611167476bce3e621d75c87ebe24006bb2f51358ee6ad72c91919f14db8e3c1817fd58ee2cd7ba327e05f863b307ee69d5496934959724a54d51d3a42837af711dd4373de6ef248661932ecc3fc37a797e11d9e358137afdae8bc8d27aabf491da01b40cdc1a30e56f3c788e870303f1d5c7338748587d3161d3379ad1b85d616e318d4f6fa9cb83aaff035137da7969192fd65f5d96441d86b680b40f03f658394c8edb6b375c2b75e31104dd5a1abfe7340b39386cf371b3498914a0055d6e19ee19478fec61606eeb00239ac83073e9295b689b14ca64895fd3ebd2ce8c6afc168d0dddbf3681381527ab5c1c69fd7ce7e160ce252b472b7632ea1461b99a88cb14211b539db6481af1bccfd383ef4348733eba540b26b03b48f0fb3768538e363da57d0fc5e651d2ec20ca3c7a0228840376004943e684c5b0f179b4f0d99427bbc21873eaf9b3e748a7c981174cdfd9d9c0b5d4c3cfc11debf30242210ed243d8dbde869659d4496f7914ff551697b73ed9b7627b4921f084b4e2b796a993a932050bda14d1e84c65787fddc871d0aa4895c3b69b4e4cb0473c6ceebc5f2aed781ce90f73f941073f1ad230a031940d5dcc99eae21042d1200617a26f0cc7da39f08870dda9089f25b736dcf922e0461c7b0ca38db38d39115a5a3f0a31ef4adee1fa24613ddea76dafeb88a912a90f136391d1e47aa9e75c4017a5e8e22a3a1b33728bf90a86298430855368bf6f59635d2d534d791384d2cf4068ccff69ab6588da09974fe06ba33f188512cf4792d55a3cb4537bebef7c88b6e2f109c3a67809be432e23c6924dd080d58e74b3b6b99d968a5d6bf9a2bf4b2d249275db5ebdc16afd1691116c17ef141f4fc7ee4420dfa60511380efff632ad8e0a5f4ce94b3367a0463a03a02ef5354c2961182b2989481968666d172a26a4b459a755a9be1e004246905a85015f3f20fba613f66848371c03862c24f6b4f488a3ae0c90c594084683f50b723a1e9a9c7becaa41baa760d4948503a2c8364ee07bba22b26df1e2bc1dc1ba0db23488f4eb50b660c254d804bfb919034ad461b218fe67f14cb88ca8c9b4be2e069bec7927be9aa24b50068d862a3a011e77b0a473cbde181fb6c6f99ed99159f69dac7b909f1400e27d8b3fc6fdf0b8798968799b52f80da788438c95c8b7473126f4df433843977f84e611a3b539f18cf15dde3b53e719f3e6e72c816a9e02ef7e168828e71c719ed589f33e93408b03f771d5187fa18ae8bc1ec1ca0561a02bed30b8c4c04354ee289524a591251c58a0d48b07ff708c943181299c31eb3d6f39c0ebfffae44bee141b7ade093eea4d20f71ab53f816acd15b886cd4ad5945073abafd3a33f93063edfc7dcd29e8e90230b8aad4922eb86cfe51aefc0af1a60359ed69bfbda4e5fc4d4b0b2e3482e1b456ac7bd3ab212068198f997eb165288b3e06c345d54c388372bd349cbc48ce681b3f5f6ccdd1d2c0b4fa9cb0422efa5dc0abe7cda47c6830aedfcbf49a3f64e09bb3f637560886508349bff9c224140fc86c6fe53413d7652f4009695affffa044857050aa245c82b03139e259b4257be8790b7a030381ffe407ed31283e2974802362165b7801cebf0c981d9d5788e1a89e0d9f47fb1434c8c695eef50123ef0f588044c32a469272e66666723f88802e9b55d7820a7423775e2e93052f35af6e56e10c3809bcc9ce2f84d869de30e1bec2b5bf757f0dbb0e4cb72baa7bce543b0dc93aca7f65f03fb43471bddd0338338dda7585201cf2f459c72c50bc580cc1bf628832742f7ecf85f556823228e40a8cf4e20bfd0892820b86c777ce9f3452dbee024be55d83a32c8ea6dc3edbe610f9869ddb95896f6788e364a049f85b3e077d7fdf146480a0ee648f8a6e702579c80366f76ceb161d15a442c408c78c780e4c407805acbb4a37702bff50e482fc92b853d956546e9acf975f9388bc1c687b1ae29b18a1246bb349d37ab6d46f3cd3322138db54fffb2f790ab280fab30861b79f3b201aef11996e920e8177a431710ab2a5c0f7bff4fe695d7ae65d702dcb41079e6453bf5d2145bcb79d3c1b70cd1fd54631c8b449e6afd36a74bf9e020edf43d88f79b0cc837c6dd485e5bc45cd5e6e0085fb9315f0d999dd5ccbf22e5e0b7a1c35df7592fb8e14536f35b5a53769c166d7d74a3251d0ea55b76cdc2776d74d8a0a840c788bc48c31afc471327411c5b02c131c608c289ee9f36e698ec4b6045774b64b154007dec650253fa1fde8880334c57d888ed94a1ffcce7fe980bd594590f8a84f130f0962b16d3b9b0a67f28d31d8d031d4c4156607ce177ee2d13d579f54b74a96a92c854a1ae0c4c88b47329e155e5f839df495baeabf10f015c72bdc3b3a4c6a753f3649808ddc0f84569e6bd3b86b5386e7243b3e5a7f525dd1ab298e171e349cd5b9558169b188f7e5d40f7b1bcf0fefdf375c0c02fc0c01c24282d2d1778ffe82cb215f1b8c6c470c7f2ff8ed67d47b3eed730edfadfe62ccf965bf772c22774cdffc6167b24e9e01b32045f3f9ebd1d49c379362ac6660ef4d346e25a7d96b097580044c94430d94d202839ee70b33457f5c7257da77e4483096e49e2f3c18f925f5fb33da29b4a43d9d3ebdeb7bd2c1e514cf8f8ce131263b6cface290239e818d2533458fdbb6283d3d5664c94f048aeeab9d7e113e604115b15aff447151179d2608489c9addc98ac0d4cb996b40978cbb027b9b8ce9c6aee7562b7eb5ed54296b08edefa45c2fc4944a97e501f1ce47db741e7d9578c73c52bc454ee345fa29028e927e101d0993edaffbf851a63e6643a81578f20329b03b83e099640f2ebd812929c242c00750025503190e1d921f02ad51329f9e45707a44a848ced1b8f8aeb5275f814ca34eb7d595963d200ff871d03ed9c9c22a8a4c7a1b28fcc396ef38e146f9ebcac3ed929bd199556f2d864c97458d20f9e74ebc363abb37052d50e69b940a3a2c1a4ca476c5f4c285da371093039c2b80402d8767e40c6441221113edf514c5c66a0a00a86fce2af67c7a999688bd39a8916c5717a32413ceb12e23e709942400e9d5c0dc7929cb28bbd24b3ead57202241a7a965879cfd41df5fc707a50f1a6a7c7891119c1bfd61dddd35edd81034cfb3616fda68ce7d1355a81d3c589c07e8e3db1947840bf8b75ad54156f0f26307288e3546873e9f7a870f1b673c1ebb82036596112a4cf518f961141add53bd355620d92e2c8faa864b2ec90f8eb507ff6ff2e2b958b115dd4d3ab1774471fdc374e485c06f0d2cd5aba9d48f8cda1b8c4c67448799df1cfd28680908c7a4399d71d65fbba3824448ff74cbf4a7676500e2f7487b76c9ba61514ba0194113a74e166bb1cdaf9ec9448d5f204e8fe655a40080089fae020d0cdf00dff6053538d578eafbb115a940d116216044b7af6253059835d31702880409c5ada5b213a978294746dd785c92f8b7cdc0c1611fa970f36c6b322945301f5fac37e960342695c9982359c6ffbafa59041411b35d120457d0c88386fc17fb41953fb4c95d5a09e37af18f578ba2787f2e2db67e2a31ac70dfc222f3d70c9586d4998522df84084792609d92a0424212ec69ee5bf8fefbd47daca8ad3dc13731887a02049bef0f94a1d8c81b4f37d3554bd6874d5921f63f2ab62c5ebe0384944a03b509074644b3540f83e1f5c3a85a1552b47235d23c148b5ad1d8ef928db7b2d19966b36ec20cb93b80fc9274e0c973211b1fa95e7aa1fd0cd980150f978e002fce346c8697f769bc192e6a41d18dc6f8d0a851eaa2867891d63b860c3907b66948f83bc5cde39dead8da3a55eebd54bdcf2fa612622f754a63c3f7d9f1127369a8ce310dab6d837e056a4faba2471a30f4b437afebd5b3908e7827974115e8c123a22d774337edc5f536bbfe72e018bc96c2a4469ff402a152f3a49996949eccdec064afc7548ac6dd3fdd88f026214c4ecae85aefb57654ac9d349e2fe57b53d045e1feea60710c0cd196afc11411bce5402526abd3f7416de0c0acce074514eb2f40bc35e7edb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
