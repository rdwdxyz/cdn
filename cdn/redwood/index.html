<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4de9e2351ebd0001b8d9778645e7e29a616d48fa3337e7d29555ae2db2c25a306185313458ea4556b25b561df9b44d57638d9ccb56ea383e44ce5c5d1ad765ab2291c49b3381a4adf8d5c2a5b8bdc8d49450e3fe23ec510980aa1ead437deff66234ee2d00592a8389574a0b018deecf22f515a949f2117004edfab92b460862fc349a23744404a842d2f2d11aa25cccbc0a9e81488a82c1e603f1e7b1585f61d509f0300afdc663ab58ccdd3f9fdf94e26f2f802cf9503d32dd9d35e3052e45c2587dd46b31ac9103b235b2a281707482ad1a735699cfa6f9ce43242f13d8b52f613a5cc56d98ec1e27f75e48fcda607302e192c0de4c2d176036a642a82953fb25bf829069d3ace8781078a27ff290709b723e89d52f972b5f32d53bf65601a68c01388b48d9bd75d711c7b7cf3c84b80a8712c9f8b9eee916343ab46947b4b14147a99d73f2ea70a93b0ebe962d600302bf2458ca5e0a3ebd491bb067529ff4249dd1d91d4bafd1b996ee7b7970c211ccee786e9953a0b68606d05ada397cc4a81a81a8d99809be2ceada496e7d73ca45db5dd6238c9ff2e4c292267d0dca2f78684ab350596d4e4b7c35abd25cfcab647052bde47568f591950abe3d3a0acfbc4d5dc46bfae03afd2248aebe1998b1da2aaeda2127b5ec9334096eb5acaed98da00e56df9bf3adc3d7c75f246190b196b4f5a080462edb8dfb518ac73c067f5437a8349da17b8009166e4d6b58cc671b25d924a2b9d4b83d69115d8932c2c30735f2838f120fa9808ddc127b255aa7f24cc9c78671013fb6b961b0b44a9a55c28ceddc98d0fc24b2c4c5d586a23fed4d263b8fa88db6d8c5fd715a261fe1d319a2f2a141ca77663f7f950e2b5dde2f40ae08fd669acea3bd775432ce61f3a508c32b88b90fd4c9019a629e89737418123e88b59300d93d82fe8815924417647645d18078566a15c2ef0964926a1f8e04387acdc1a647a5d0951fbc69628517ad9c5cc05f2f739759e839f3025951fb951a1f1e7c351fc12c095c3c969a1f1c5ede09e483aa7e1f7d2e980e3f25bc8081e1af7f74e2f8cd1ffa18b459fdb38f062c6ddcc5de8a1a658e4582247fff8e97a8bf900dbb5df4e90cd81ca6d403146c8d6fa5de2bcd73421c510a1f6eafe484014f6048b7ea1bcfb9009a776d28f527c947bd43e0f9b5d7336da6b3ebf8d77bc49ce4b277ff094f2f18ed90482295233f86c48cb173b53fc9f4239c5368ec37e51e0ee675110c006883086f76563daba7b350b9847a8cf08b94306659dfb1920746e70c6f76af52bf9bef61b46107a2cbefbb74144f256b6fedd56139a0f6ce5002ff925b418f96e30cfb71e968a78a0cca02f3d9205d790f285165c5f755315e20a34eaacee3a8c8129e8eb9954162df9e877a8731bf094607dc618ccca85a7ff2a2bc383c0fce3b490fa6a25275caf122062e462c00116b62d8516dc314d211c5358f408a4644120cf39c6a10f5d20bec4ed7f037e03fc0c822c7db88bd4debe78612b512aabe9d99480a17d77b8d8cbaaa1d7e0f7d465a044c38ec7aeb32e6ede0e726e41b63d05a7430bde5eae083ee405a0237f9b7413890bc7c4ddcac5d5dcc7340a778c8f65726b8c323796af0c5f327d6d81862c022da72e0a482a944941df664ab4746d9f60b99e63b6d6c5319445827424c4b73b20a32eb788275f787b49615edf9ccada7d92786afaf6ff64482befaf1a41ce9e7b6c8798382c7ed8226294fd7de049dd5943066c37bc49aa0738a33c8ea3891402e66838f3321f4927fc53fe6c48ba06245d1e6daf8d8a5c365f7f2732746faf6ee691514e1ecd70da230a4f9d7d1020404438b0709a6771ac3c5a6e896de0f74831d6ca823e792e0802d7e0d3d023a44efa5c1a83890623a2c4045e8026eb3dd5ef7ad7bbf43f09e2478236b2d9b7ed041e9e7ff48464394ffec63794d157c47ae0d1879a7f37c6c9b5ddf908c47020c176a74037130186391661ec49b00ecaa5067435c9d9938f211518e32d8e8d836b71941769a17a27acbb564a587406f9a54590e195734915d097567b8010c8dfe30c786e2996655281ce2859b7083d92df02b3a0b887a1872407fd5ea92972366ec4f278dc82efccda794d10047fb849f9c78c992e1d53f0983cf0fa1cfb2ebf881cd01f7a05e9b6d03153c8d1e0ce54baf8e840f70d32eda6965fcfd15a55d874c0bfa3b0565cccb10f5a0f50127b0b56465d1e77aa60dd676931428b43a36847f6b0930c5ce0f795501c335b6818387b49ccd9d0e5172986ba18ba7f276cceb31489cc9f10880c03fb8ccc9bb694121c696b1c682d81dff071b3245e4b4ec44253cb673ae650aed6b7f82e4b9244a3f04785cfbfd72b97fa20e38da6b62ee9871be5e138e2c1573f9eff756a9e72015789773e7ce8ecbbb960391ae47cb07a76db5daf9ada2198e620a6a1181b118270e9c1935c6126a1642e2d56ab75e2c95e70767a4f84d47be9c0aec89242832d76e9df30b4c165e3e087a41f5f1083762f493ed476996899696b64988a722982024da7e9454063822a0418ccc411b22bfc39e092c8fba347d7e21ea76f26433be4fc93c6be50c6d27a161347c3872966093c353b0f5f67d031fba04aff96c32cc0421e98839164265983bf886be778f838fc5c404f4e71e7d4bbc66a7022b4ab3a159e8cd84bda13b757e40dbf641ffb1c5afe5ee88fde4e8d340aa0218ef1871906c0f347d763771a523b90016a034d2f0fde0adba5cebb881fff244b8494f42814ea48671650ea8bfdbda9eb6bb8d42fd0e675493f47ff629f32bed3f6d9b7213de6800757f5414206c3efdd17b70114ed6d238ca586f7147761e3f327ea4ff1d14d4a40e67767312f658d23eb6d6560f4fa4351b715ccc4843a064c543605660b7ec41e3c716334c103d23e9c8df7c49cfda191b07930ad78d92587efbdb99f884fa9bdbb4966ab317d91e16611179e01f847dd371c30d987ad69df60682dd71efe3b9807ca09d5af5da8448c201fcc0bc96689aba0210049e2b4bf879b0b8f6bc8603beff654bdf98e820b0a128d89398be5481671b72b39dd5328ac4802e7d983e3b272ccadbb0e0582867fe6401700d0e3f7b7531aa22f05b06440b862c793d7a0d3f204a5f0499a725572e6f538b4fa47bf7a503fb1c8a4e4f92545a5c9d5470143d5a68a6951b0e64b73fecb1ac0cd600bd3b77cf1bb27e09077735e0dd147a2f2227b44f7a7c557f5ee799bf2d9722bb8cf82e3dcc4d714dc721712a41bc80e8398c449c48aa6844ed340c7fad3d5ee1274d96e34016333c6fe4925d71c67385d5a2135f9adf9bc2a169db67d6df5276d4ab1b5858f7c14cd93fb64340512a1f6ea8f58e157b6fd830abcc28c9f0e1fb5ca3ed2ba238a4ecb32218c988fe8a6079df108fa5a5b3252d2f76cf66706c0aef48c720fdec7f92d457aad673b5a358d14525b18d7c7e3b22517995ce3d1994a368c038c9f85de2f2f3e35d7020a6ccb72e859fe7fdc5f033ff76e2d37872c5e48ef5bf01225218346c43a79de863675258c6a735ed7ff5ac7be7324af08e7c56807392685b80f5f20572990639cd69e2d300c701a0149ae1266d9a890512824f8ad9dc54f2fd603cb38ab586e0fd8ceaf47acf84b722a3bc09e73532324691d8119e898e74425f4f804d29aa55d494cd53fcaace15d4aa1e00437e7a238be6cb0c139fa88ee6845ebaa22d792e7715a648cd75031ada909b7719612ad93bc1e41b95c76315ea3c50a1e1bf141308e2faabde610301cf5fe33c7804642fe73bf3520a45e96c236e5c7bf29a88d8cff3ad07771bf5ab2326fe91b533353721064186dba0577774f98b5fbec27e232454cbdeed44899f3c1dcdd3483896ffc7c0658614bd441268ff2dfd0edf971a2abd98dcc5c21a5699c98b3b9117e44b13bc2c2d1a2c5ae9f0fac681e7b41582c7dbaab104a606e4f2420def878d11b7491dca260d7eb063aeeb919f0ea21cb837e3d0c31b2c853647ac6f96e9795fb25e65f617844e1c068fcb53ed828a031067a25cd51e4a6701a70926c31574b24d882d880c4fe6aabbd503996bad5a0fe5586a504325e2697f9098e1318185fb02ec6fd187112a3e626169da6de1f704feaab56c3361bb59f6baee12a0a3a5458bac3c389faeb5f7ef29354e439d44a8c067f2ce87133f281b5684f640673474c5b7695e047a050dd003cffc890155f6b475950980b7adb44e9213aae8dd11c1f45c31357298ad9ede082f58f3907ee226a5f828a1279fbcbc89f90f7f863659118f1cdd02e378fa52c2e79c4ad8a6981f4dacec0ec0d9633622892ad34564381fe41077b0320d0aab5167cbe125c5d9e3229c507df053dcee5ea2f4ae8991a35b9a1365e5b7bb82592896723646b487194d37262a770d8f958d4ed5deda2593fffd19d4366067e24498a1f55cd94aa9778eb4b81fa19b137c1a8b9b026e9714ee97b482308f07fc2224ac9694bce4870b434029d73b22ec3f771c64a4c3f173261952835868481f97e945ad0d660696aeba2979f9492a389953dc856bd46c1a968366f90899e32366dd68fe6e4f971bbc8b45c5dd75013b32c8b2da6c9e6beb9f8f2df79117bb9512cd1f7b7fe955e4e830ee9db442f209a03ea510bfcff9c39bc0e4819d20f45b85edeb02abdd9a81d0c2ecd23146dc3c53e516fa8bee6cd95ab6d1d27ae09b1e8267c80fa3f4ff4192d9d4b7156afbf77c62ff3a6b996643e937eef57914c56e9ab003f38d6491eecb78181781fac761f987917e713c337f6a4ff61818df35222745f2a1217b8c8ab8ee6ca416445e636841b1d0d4ab2d43b37761104790097eae290ee046cdd3dc3c333bf07ad08969e4edef55c6dc224560913f17ab0b690b8bce21adaee319540a8645193fffc2c8abc3cc6f21fff6dbe9822b8d98b3b8988b00b7842f88828773142c114621dc941e62e3eb5206631296bc0677d3b80bbd952ae723dae5cb10c04e7e73e2e77612775cbed9dc49dfb307ff6da812ce216c2c1faa6ab0272c51823449e6d2fc67b28a24efd462b75b39c80f14554d0cbe6ba3a54ed25a2d24d8f368a9fd4c5992f5cbfd69e17b65cacd67971ca3023bd7f1b94f26b5754a74f1355812d2ba29bc1405173c03d5fc31ec272e7e2fa3d9501fe68719d9582932f2cdbcb8881453dc0288c2d23a0ec893527b08722d842118a8fb31a1ef56679fa84047b72690fc58086e66488acddd59e8684fc2367099aa6330d3e1cc6e3cbed0ba7d4200508d389ffc22fa3faa470a1c3cc541a94c8638aa3bad8b091953f76213ae838dde0e3c39bebee941edd2d8137dbe579b7d075fcf3731f5871a509faaa7e1c48b484c702103339eb9ca4bc5b91316973d59a8c58665bc3f7591a3a13b96a690240f6c9ae0b96fdec113e3981b785c0816a3fb3e29d0eb07fc32e942815e0c99e407bcaaf549004158436b47f1160eb13997b1e720ad31130309cbdb300ab756228af30f1709bcf5bdfe15cdb4c00db0da89d537f96a540b1623128283429ecd2a0d46ebcbc568a3a8f0a066905c11d802f727b0fd570b89a70250c9c896aa92b9329d5fadaf5f4b9af502d27a33e45d3887fdb9c6ee0663cac2046c33e3c9fec5789cfdf3e70143ee91dc5a7b9a03efd9dbd7571c4f524a0caff20f76c9a433b75d09c73da7cccfde9cc2c45baee7649802115d48616cb8c9847162a97b874f00f560bba027df2263d123cc06a4bd540ee408c3a406e4e9fd8d734722d47c1c995ca95f4c16520290c94a2c59948b57cc96b8d0690053c9a449b7375675d5b2a3b8f6b336b35128e7d164caddf184794fc7cf663411ab16681f66f5605b3b2bc8d2d1e4f3d6b8b2a0cbbcbd86f6cb0e551f0a82249381a9f63ca25421728e7b04e992310a27eaae22119d1d9420be527a52c8760f9ee929baecf322631f973b47aae1c87af35fb791dca6345f22dac2553afb0fd47ca2dff2adcc1a51430405d5489d0400d1c67d606e3cce8fc660682afdce09cfdc22f6cec8c2c2a5678a305d4a24cddae59a907017bdd3e62a39b7123d996e625b4d781f9dfb79452b19ba5af233b30c607a5fa7a8261439892e974592032cede01cfe474c41b06dba96127a255bc346b737e81ca1264188efcbdd58ee7999c463266c26ce49272463bedeb628ee45d00cd14f08d815fa5fb17b07bd58ef6fdf8e95b793f0067ddf6e4ac20b55ab9dc48de113e99677d55eb63d5ed3593c538de1d2d76b50898011ade231ba82ccf279d6070435b60d503bcc4b1ec276baacea9f557980beb2e2dfc192af5f25376ee606d3a988b507484c39386d48166f8a10e8e360dd41bb1867d400b656bcdde6ae7f88e68818f319444af2423f56a8efcedf1709acfce0790d3802ad1bbcb8829b283af09a6a7276d7ba377db57106c4870e498655335348b0a84ce1acacd7f03bd9f6244ef168b5120015d341e826a01714c7184557be7996b1a2c9f245fa21c7536a304e5a435e1b71ef6979d11b0f4fc776fee16d2e9e70b9dc723ef3355879882734ff8d803b098a13be1ba74648da9be0cee5ab02a2b50b4181276d7fd800bc32a0ea93f0b075b948342741735d4dfafee0cdd06541a24d4a70fe16d35541f038d40661032b6d7f37cfbf47a268f8b3a1ac9920f13985e8260be0615b1e24bfa55e2d5b67d0be90c0b81819eb19831243cedc69efa7b976aa90af46d1dce90d1e894d16a06354fc0dc19303b0e994e01df81278042a93e9970fb556cb6db3d3cf71926412fcfb904ada6120fd7418ca8a99401bb39db1a9055b9a5300ba426b91663dd3f41e00b0c18d04aa9e21c15bf0b3ce06b4222766009908641b157b8b5cf476a1b92aee4d8387f6b44cec72a5c44f8ae6f803b22f368187d5f49c140463179dbc17828e0b50bd6622a1773499df7351b0cc5e3cd7adc70d556b674566d8b96ecac9d7fafb99791c0c54b4d5b10900923d5ad64addc47ce7850b47a56050dd99912ea8332cf800a55a2de0d94e5cbcb7e0019ad707c9f03272acd2b199a72316ad567d61f1366b93eb54be74f346793e51e9c776970d3e453f789697272fab9e0d488cb5200c3cb1a8b83f208f68b6cae5732408d68a3fd2c8204ccc9f4b9e54f92e318211765791587d5f12f011bb570d83140f3d515b58e19a2b7302bb2a8c67afc7866e4e63c73ca2230f88c55106f58a9c0729b5c424683ce873f03d34fead54f6862e43479d886528bd871e0feefdb09f85693bd1d258e9f4065c10ae4f7b7d655113b87f84e2e88e0448b4ab8040f01bc88379637cc6c241dcfffa14afa9f4b5058c5a8858e44306239fb1b32b672788b21d11e687e05094d913f26d70af902ef53c0e978745bc37d6ae83820a2e582ffeb89f6ade0c4dfeaf506de24e9f443a84e67245ddfb57d60a2714b83b8eb38d06fec599145cd38f8b5aed38a586b85f80c07a60562cdd58a8a5b92cd8794f898bfb69e07ee5d6c39ab478bf55703cc13726cab4ca45402a5baf1488c1bb7201cdea236f25548e4f18a2a9333b98da29eeac0ccd1fb3f45d0e79af83ab69c363c4eee570a061d7222ef0b05dd09c5e99542479e638fe4d7441c37ab932068097f4c8f20c5d3791f28e415f5b160c74f60ee6662c9799fc757822f688dd9efd1721e0376a76a57cffba76b0f0128d3e94fac74a3d927df5939a08ea10de9ebdd4203ea9fe3528f4967f14dd82726317136a7e5484f4b38ee1a082056f1ddad36f71805e8c0294f17c225b3ea92fba12298771641ca906bf89c3ad126fa0c51e8aaa8354c4b4b516dc5d33aa904cfe98f62fd2966c0a5bcb69f5440256d024e1aeec90085c2cd7b64e9db1c16d6da9b20d8edeed69ba8f3ccee24539961c0c2dcb9da2e235b7767d94b97b44a49a42118b4e0526f2c938a69ba54801d8a834f2aec815e55a06a9251961dd736e00f18e1271bd81ea4336584ae4a34070117030c1ee6830136ecdf6b3ab81f961566b73986f958f77eedcf6e0182cea8f29db63378b25594387953ef4879c80ec938f69b2555e2a9068495e7bd9395b17a9ceeb7c7c18daf09e61dd449440a77b0d602cbd124b7438e24643822228a1e47182b26ceb2b84353c6006b3c528f846660a254987ecf844b20bbcbca83f3c8171f7af6d723546ead91ba52407481f012431d548309b244cad503f31b2dae8b45273432f3a7edcadd5e8bac8481fc22a0c41bb1cbcfb6ec638d8257136e16c0273f3a43e00d793b48293a7fba8d37c86620aeb32b41fb02ac424fcb36c11018bebc3f8b9da7e84b3d643073b8740162b6c240298b4652062c54145d8fb2463ebdf0a2c291d39bfd2ccd01203035c2927c8bb503eb9c77fc3f21c924c1139889dc7f5a5e1e1c751728a4a13b915c980792dcc3e16e1f854301a3dff129a6da1df2d2c36b01852b51e63e9b6b132bd9f7700858bbd96c5c5acf3f6e02f3379a6b81ea3029d2c4d3644f353d4565008ca6c97f81e42c9dc9ee4cc1f6c9ee2e566ac75713b79a4f4a55ce8ce64d6de777ebdedd5efac7449438391d69be6ce045eafe2a6384bc85c34694a7f6141b972977bf4755b5fda995e1cf12c3d297143805d5236b747ce391c5aeac862301269a631f6825de991920f0a77a772d84299fd40f96e751c7f57d172863dcfc8eed0631a169aca9c6f31eb4115ba0686f774a5f548898f9b05ea456b16cf287f09ea2d48079afcc93c3fa46ff257a35018b747da1eeec83c688d03a132d8954673e03818cf979ff45559cd3b762c750520ceab07f680d986d4999d5e59d68f70813867dedcdb79f39eed54d76a08de234c361456f63f79ace27ee2e4152d656cecbd9b16e7de8f062900da1aba4b51507786f99009aca905f7b3b3b23ba9443730afc9617334322eaf4830768da8000fb21bd12471234be69279c56e89c64a070ac6336e0a4db0778df6c166d66fc316d0c9eedb09fb5179cc5278162f33bfee5403e1d489ef248d75fa9f6acf8f827ece46012a930060428f4e927ef95205eb243b54d54fb4eab4b66d2b8911eee0ade97c9a25d34685f4749d67500f8dbead63e7c08ce943a0c13efef3e5f57e8d16cf6951f353149213da17f79af4d85abbf9ada724ec33ac2cc96a0759826c8a49d88e2d3102b300163f76e3266a8f9cb4a2d4b0a5fb961a737cd8a2ff69e0c8637a35f9d4ce0cfe1a8b088ad227c7d1272b6a7b7fff58612d98ce210d96eebfeda7fed232c859f3ffbbd4a79b29565df6a3ea6356a05fad7298c267762f7c29b03cf13a5ec016e9f63dc480e54f611df798a8fbf0a831cc6fb6aafe0c1a2ab1b974623f0d02f0f78417024f1247f2261ef3b13d71dacf06ae7087ebd8edbbbd41d75bcbe957d188492261f1d6b8f3b5ced67a1e4479b035ddf63aa484c1c4be3835dd04074aaed073c187c4aa35e92520ca6b25645c3db2255c245e5cc349886dea3008187cc3e21f35eb0c9ce61535180c7c5421b7723cfd8a0c18eac2b5fdf6c17f72c9a0edde3b79acddcc27524a21f6085aeedd60eebde33faf8a0d1ac93b363036b6d1eba8b0b95a0bd3485ddc650cdb347f5fe463c015b70dad4298fd45bae32364ad3468963d449445cb14062b45fed5fc7b563980a6f468bf15468dac864062092e4559ba05e7204ac0f0df2c3d16135dec3c6a3a2a30e2a07cffd1664db0096c26fe733e51a9eb8f49e6e9df98122aded35fa346a1d469afdb9909c7acf9709d855f91ee832ace54559173216b45257f3873506e6e44a9b4a6f21746f4183c042ca1727d9aea3a8238b90c9cc4a47d89fc56364b58237384927933f4c55b540d2e5915b53f6ae6db84cc97a52f89f0e0d7cc0b89765af962e9653306845b758b80edfae386007eedbbef85768d36e9d80138d2e01be311863dd6fc7488beda5c1ecf9deb6adb30fffc63ce1a2d524d4ccb1fb814d6131b68ded5bd28cb8449590ac56db12c2777e0e14ae671fd5cf815ecde33fc5ba36957ba9f279f11b748cc53516529b1bc50689a7d939de99463f758dc185813845f47b5eda946d39adf8ed6740cad3d87f89344546ca3bf3f1f528d392b01d01914453a782cc3e5717aa955cf399d92790afe44c7d2b01fd26672a4d9f61ca0d1319dd2e1c54fb75a53a07e4749dc0c6e97960e706b43484bea4898d93aa04f04f098f6bb679c53f9a9130ec083fbe544c2490bfdfa178f996c0514ce1e0a60c82771b7391d9c1da6f63cf0308a76214e92f448b2e2a9aabcc30e700bbb82307850c3319c360f1d047e06ab109af361f9353a9273b73d158a83a5dbe4aa7475ca256c02911f94f8610ff8b52a8a0427323911e431fee9c80c690e4160c2788d1d78bd87ebabaee9c4470ebecb4b591785896901060ff2944be7bdf18e2986269205930713c004d222eab734e4a7c29676e5f3f33d2e6a5c62fb5356bf9d7d432500cd5c407a65a8cd713f63027ec3d39e25d56b5395e3ebec7b7b38b65653d25ad577a98cafb50af395a78f6cedbbcf27dd3853a028f4a68e7d409093c13b534a82b0a4d80046c229a7b1aa273a03f74387f22dec4d306eb4f4dd030f174020f7ca1b05e43a3709691e6f802a65b068aa60545c23c1dd1d6738032efc999533e4f09f7784bcbe44feae3690998ca20f547554fcd79902e4c8acc2c649d3cd65fb134911c3add5229108055845039de9325ce0bb1be14421dedefc8f6c5257d44d783a984578a7b6e3ee3c7098facee5254f7276330f80a550f7deff961fb01c4bc16fc9552f90d5c1aa1a9361fbfe82ec857ce59f2a76c653c9d9b4c92e370da23a01409b344287a94e31357f05613cb2413a2b3dc300456d0f006dbc4da78e95302a9041a50a0ce0346d4193492ace2756065e553e2ea2c23b742d58056ecb82b9dc0be633829017834b7c4ddef9d408c6c216ca5cefa5a32a6b05f11aba44c54a4dee764aba4ea09121dc311ae913b645dade48878df4976e67f1abf5a2f55804a5dd0b5491db846c969b8ea848f816c37162d167301f6e9cb2fd3e6a2a461df3437b2c9c5730d8d0df138f47c417b56f9927f12ce8fb1a166905de5bcb43f7a524efddb78d4ea0dce066d81914497f2500269fcab6abb2518157b96ffbb4902d47a9b08d855482482f15b264fddef6dbf577cbc1ce29bad7c6036b5fb6ae712314e78b127766c181f39508b2b2817023adedc6beb1cc1977b601c448e623ba9105c9050899019bfe17396c70c5121b95cdc0f36d20c625576a26422b8597c7175f0e59cbeeeba7b9f34d74a8f6c10b43f9c04561a06d17fc9ff1299e8f98d8592a9d8cf7f34237ce68d57d4ab4229a86de1b6de05bcfde13175f1f3d1cf1d948b42afbbf69ef6ef603947609f0a6d8dc8fb41799f0c4da9adb088d973227672d9c5e77fed4bf331a97598e59cddbb7e72c795b060041960a291b7e13e91fd82ac2b2dd75fe51830f184175dc7edda748405fcee59323060a1764b3be9237b23d6cb03e5b13cba55de763cc991ddb18d9cdcd67ddd9d20f3054b48ead7918b87fc5279222651ab8c6334571d8db0292dfc20906de161a86f6ccde705064cf8e3d5daa7863f5131afca1aad05f26ba7ca763f066591194c06ff5e35bbe5f8bafeea83f662604b35ac936c26f17a7f59d0ca08e5c8993b36cfe05f520a2822ff327df41f7a0a939ccbafa3beb2fd5cca104b82f161bc56c0a2fb608f62003783a1e1fefee7e502b6b22a4ef3da1bdd14d1dacd51e33309b22d485ff2824f569fc49be2ff4aef6e7a01faa85f9916d0bb90882004d8709fd756e9f9d4a038f29e148400bcb19cf5bb125ee2b3827658c6796d0440bb07b6649fabef65b195a4db138d891b3bc29a0945148cafaa11003af899e3cbd39dc967210eb3f8284fc699d25cf5060e6e60185e90e04d80c4ff37fc132d4619037aefe2b2cbd34273d4cb75ac49b3d25a34a0a7a0b872c15763adad8cdb7c39ae040cb4fe6d96a875310aa8b5436cdde400d008d05c4bc7c6798ab629a827cca4d7f735609a77f7c21b19affe391d741b6e7a36ce4ec69e94b8023a64e154842681ced0fa3307a2f5600b25d70b0a3b8f2f5f508f84d906d53c18de4f34d24911318f193459904e3af77f7fc57745370e4e02e5c68f7e7b0fbd6058ecebec836151996676ff04227de7f892192b0a4494b36108b3def2035861bd581f2e0c93a6acbda36cb1f0dadce3db039a831187d24cd690a80ab5b73249b1824c31d58696812c93d72590cf21760849b31304f8cb5faee52860cbd5d325fbdbfc5e38b67a6c594557cf93886d0a5209244e98b537bd2953fa992ae1fde2cb147f576a0ed756941fd75f57fd5ba90a3a61579391985bbdc957eaed02471ee8b177034e6c91f79d73a04eda7c5b558b9b453c74983503a8afbb3709ea77ebcd6503cd3c55f5fb7aa5771b41163110a882c6cec62807508d6c940458abf7f7e0a702e101c520d12e4b1997a556387940ab23a3a71186b60f681fa780e35aa6ec37f1775966bec0ad706e5ee40c94d03b8576db82020f26d21805f31bab1c930b36d1d16c3086a5285a9230847a7cb3ff8a3bc4b8c62123552603d04d8530ca39dae95992d7c18de16aabf5c92c117fc804ff4274aa0babb5b3f64711f66ce38fc5590447adb8e9518c39afcbd3d8c2aa5e53d1635dadf8350cc0215cc4a509c4cbbe7921f4c321bcc8314ac7816cb684c14db652faf430856f8588769d5b6476f6c9860b50d3ed125947c333a15e2173b7fdb10d443f4a09ef2550f89afbd6b8ce9f4af9571ec163a876997ca610ac2e2dab5471b74f210d068b699ee84d0ee0d262a290329c223cc95482425d09945332b46d8281b668f024f344466a1800e721681e7c3be231cc3112d21405b11337dbb12a126c1924d667adc9b60dff6b67c2cbc51c192e823549325953a1d70afde34f871d5ccae1a35925821c30d95e22713c256fbf58be0b61a0b0135253155641429c1ac145a256ec2a28b432118db8df1b3ea7b0ecc2b79eba010f4320646cc551f20eb3b9fe159e401ca400ddeb3ec85897f82d28f06cf61e94cd5e77f2b746c2465be6ae643498ea3d33d62c2b842081ad40f92b3c033551c470d7dfb3bc843ad4fb29b0f1ce3f57729e3d9beadde20cbf77046fa293267af4ee66eba3a4b51c4f4dd873b27464a79a0b625a859e79064195bb65c0b8498cced441f37fa216ddb15b94fbcc2f65f50183a9fb74a94d181411ad1f21e91dc505f4ba1341a3a7265594a0a5e6f4889537cd7399eb0e26634b1779b2a665a6d4e1051adf12ccc2c4896ff640983c5294ace0247c1b43c65fd9c5f2c1424e4313a454f6260c1375c0c1e43385691860b028805bcb5fbff025a56f4d4371407220de78bfc758f412a3dae247a7399339686204710580cea17e9992da46a68e346b0fd9843823765cf15dcafd597f5fe3a8d96861f93d98c4159a4074a2c741dde28c4f1ea488e1a346d1d313f39a175ad86bb09b93cd286f38f9a946bd60c5995a65079e593fae18f39934f47ad8996a430a5e069ba034a77b0f20acc678c54c3091f885c7b92bab3a6272301e988273014a2ef4b4556c9a7467069f67875fc334e4aa08f47db437acea738fa483956cdfbed5409444e520099ea663f318d3a3ed0b4b5653cfb9bba1c2e1aa3cfb70533988b7ceb534ee5b2f03a2bcfc2ec33d0c16a46979bafaeb8607feac46adde9a0bf37c185c1e94f2ad5117b798d1a36639bf620922ac63b0bfca7dee9063c3ba13525766d897fb2dda3b516b6878f99d4b94b92bbebac46c83b399049943511ff013d7b58edd3c9969d57fd35cff5be9880704f52362418f9a22ce04e84f7af71838ce95563d1750d0f78737f9d4db9c45414d7df564e427dca1f2b28d5cf406d2ba7570d70ea2dd0e3568cefa5d0b0a4055110a1afa0ef2173728d67293582b1b72de63eb4c0f205a063f3e192eb060bfbd397555d025f78789bf43b4c6426ded5808f9373d1a955e48e8242928e6d8c17d99f89f7c1ccaf1bdd999cd500e024f771eb26e717f57c064a23ba57a1d416936739312f00f29d60bf65297b419dea851469add2346dfe002d5ca92476fc155a459439fc391d22d6b32f5b2e27e3b7692abb0c00cbd122ab2df622ca8716aea865296bf4d005b73dc743808597ac44c0e70c51142f31116b308bb024f98ba2874d776db17e98f503b6893fa5115ff2b2ce5fdf8f1240fda92c4e84c274bce56009e77b5f294b34877494ac4240b8d93e9647efda3e8d0aaf16dca1f1a559eec0bca965d1ca37b86e2d4fb28444b5bf96857e36a3e40685d2aebf6e9844e981d2ded590a830016145c63fda0c4101518253ce5bac6a2eef96410e00e9e2b4245b26c8b5973ab1db9799ec6bbc2dc2982d7a5ec673022776c8fc6b4c275e02cd6937876368f19882c718b48bae636549f9ead579e0f2f83b50343d9ccb6daf35c1fc0f6c8428ed80c9539d6bd1ec573bedb42d51d48194c2a9f947279acb77208817512c7d650cd134e15df24a02c4d25903bb8cf9c15fba0807ee13e6605270eedacdfb341206a9d5879dbaf4e0a14f4784d388254595dd1849c8cd1f08f879453d06160cd88618f0ecc93fdc7b8d15d9c9905d871707df9eaea0a6ca4b5bfb791f78a6f471a211640ea4174961b11d68532a2fa2c13a3ca72a41125252ed12b8243ef83744aba497c1b9ca34f8c43598c59af63d231eb432a662b869534ac681be96a270589c74eb2fff0a32cd980359f36b4ea98ba2997b3e8cf2933e1a880f44e735dd54016803934816b5d49ee86cfaed112871de837a56c1b66cac4013359096e88c986c59648495d1dd605a223031b64be4585023b86552b2ac66d6d5efbb8188fb1fe8d3a69e0c8ea497ba4e1438855f7841f0a5afb5bc26d23df11181b8c25d1581922658255cdc3f192675689447b7442bb0eb23e07552e62a29dbf85f15d703b0214835d4e4d309bcbd4910a437c796096bfcef24d37cb835607d5de0cb8e8a8612439af2b5ff48d77ca4e732c7b8486850302b6a7ef0c5dde1522876f278550eb3dd3486e3af2b892e0af17f702a47aa5b0c723fa762ee46bf39c60c0e1e7a707d744d399d13d9b1c88a64feced0e4034946c583f26dace62759042653e04ac2d2850829fa778a00e87819c030ebbc86eb77bbd2a4a35d691a58be2be0452f5cb40c722de1321f0096f06fe6379a50db090eb2d4bbacacd00730bb8f93b776549647c22daf2fd1cec5427d38c5fc044956aeccc4295b68af8939a5867e9bd50a0ec14be64c93b0d81ac0401cea8e71d9d9a7c7e4c13efcb165c7b25fb2d6b0d9c77f4ec29bab311144dc025eb33db69cb06b661c4a4bcc502521d302013ce5d3d709aec3825901f1a17e70268723de91a6d672d032c6ec6a68c111dd1a4ca34b97edbfc9b03d9c1ba1ca4ef27028ae627c7a652c1fe24acc5725c591ea8be1488a20a4f8c63347619320ff01aaa99ee26b2aea39f46d0e59a823195d9a43005f07f6b974653b3c9b1b32be1679adcc8b03ab1658434078a0a49837e8bd425ed470d40c1ddf38e55828699a51c790ae2fb57a4403bf59dfb171af5dcce8d47073800a9f3545d92fbd288a79b926c1539e98513ecfd7a4f4f19badf4efa3ea6c3e5c396575dc927296ebf2c37402521126965e0f414b76b0c14a76d127ec11eae3d793c5284f3d5b61fafe5feefd405a0890a680b2d9d6c17ab511080f321f33960afdf5c7d312183d7c23984c5c656b244e0a2238464f2ca8b4126a40a608cb2babf0557bed7bb9d08080b5d230b64cbd7fee89752958e78b1aa9f97691f588183f16d45b215fa16683c75d93f9a05776234ebbf23650887550938edc84f98a1e6a4f7c6b6bceebf32bfe31fc427d8afa0c3bb51ae6767c6af6aab479586cde82e30a843b2ed1350abf8504aa72e862cc60bb5f8225e587a05f1b2ea47792b19686b1e8b331dd5422111ca4b1919b5e42ddfaf161b084cd411441baaf6fc1b669c9d6f67396a6629cd5359ea59967a5b6260b80d697c53072ed1b819272c3634d8ccc5066c47e96313505bbdc760f8f7aff2514ebd5a27b8e04deb8de6edea12539b7438fc2e3f0f0fd563f80bb4f6345360f61e1cef406fb74ac94bbb75b9a966ceaa739f2b4d015247d0d5ae978d9603ec3228f46455782b04687e680a2d45de96dc3b7fe1e73d86b23e1b76c5463a013bcac54826fb54d1919d78f358cfcb2816db35b01c737ece00be23c3a6a4f810095956cc102fb448b66b087989a75dd2551c8e43112d9a42d33873ae5dbbc4f9712388fc7fd5d0ac6902c7916ab4f2867e7db10d66505bd1caf49a3a4b9a5019d0491e8bdda51b994804bc5a6a87fd2538d02772214c059080a48ecb6044b7c5e5c93b30d5018dbfcf492e557089bbaff0621c40fe3e220ccd38c14d4ac592ce9c828b3053f6a80dedf8bed66ae46d70efdfdc1a459acbf8000b600251112662171c498a6f4b090c482f2f6910e76ea28eaba999f726137793cf2d503e5aa2914b5979386a29cce607d4af47e04c5f74477c8bc143b8c21e3f6386478a51469743e2e1ccf7d95d85c2a68d094812e37c5de2b95a3841de6b9863dd1175324888aecd4e981cb30cc866104dc8c6c21cd3b00516b873cc29834c206d94e9697e5dbb3aa172087bffc58c48fe72a213d0bc110bd710a18de55400b71e2c5f95e7b3468c01cb19a5de9a466c7c138b2e5bdf16eb648f9404ae512fc9666627739f68142b4f34b4174597cab545dbad6c40b57feacd1d1bcf59546559bff491bb35b566aceef852245904cbd67e729e6c0299d6d67fe2f07ae8c39c6c4db76623ca830c9aefe43ad48a12830f4f56b5c80617d5f47ae272eb17b81b7e9cc370bcac5729c6f77e08ee79aa5bba00fa1e67e41e7c4386d4d30720244c75d9bccdc4834a567e45b113bd63bc10c30e00b0ce9920b377b253d48c08148bd54ed3fa4aff4c8c1a8f6c112665bf62a2b6c3389a9300e4e36476d4a40bd7c0d83d4742fb7f1c2f2db8e294308f54895c7d2e9ab1eb6bdf4fb2ad0db16bd99e274d340773047f154d629d42f202e5b483e850788ae98dcd112d317cc7b81a9968365c64c52a47f0a4895515ca088c4e64e2b0a6cfb1b021cdb04b5391916cb357bc539deedf7d518a41258dbcbd19fb47d41d1607a1a54b7287a5ffa6b1c6ab89a8b0394b37bc6b2141973ade05009fa3562542c8291913ff18f1241fc238e486576a3b4b1bd82129e0048e7170543a6b1895cc2b2f3d889dfc2cc0874d6f3da37dd5a2fca66b95f6e78a91b150fcad45ae72f347590bc8b95d151e770a20d3b86b11e285081b981da24c4665efdc9b9ebf12faac893ac2334d17b89bc89514fb87aab6fb626651603b40f15665852d8464dc333c175ba0298107ee6d318bb0af8095dec165d9a70f0b5e9353097161b0529012952d99c2655d6ae2ac7c27589307b4f91ab2da2dd539bda253cf8a4b954992447d28d2ed3718f413e7f6b0d8fba95e005212ab0f58d9452272ffafd31eed4507b531cd4d7483414cf6be28511cb62c0f0481319d60d4872426c6e90826ac83a16bbfa6ebe5dca9a8a330a4c3b0a5962a706944121e4b124421467d929e071816e79e56d47ef208c7afb9155e0ee1b25059c10d04abd42ee98f672cc468478646de0ae1eb6dd8742a5f516c1febfe39b4d7adedd6d159e6bb3ac08aa4f29bc9905aead2594513b1b675e4021971987d3758aafcbb1ce845f9cd1dea99787bf5ff14d0ea25586cfacccf76b0fa71c45157dd56faaa426e3de60f7c36826906fc8c56c583a6f66b6ef5c4c234bd22de5e0106fe2043214a51c243b67bb2ba317dd07786650a5919ae710062d76891f9b27f5fc063479d22089cb2152c164aca9f604289700000c85e3bb9647f148a4b7fe8f2be6ff1677b6450827dbcc0a537b7d3fcb08fd3b4dffbcb9d346e0e8b8aeb3323aeaf9597ae67173f598f5c48b61ed1ad79fa08b55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
