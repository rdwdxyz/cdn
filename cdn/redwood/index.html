<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4a24ecb87d4dbc77b95c1f0ce238fc941b3eb76715cb7b2a53ed0af9e13974a0e39e7337fb59e49414bdbe37677608f5624da8296ff965d7c3f6db8baebb5485e18faa2dbe3e98bb74ca15e732661eebc481b5ea80b20e78acd8c27c26e1596e7c9f9210c50bf26390230bd51c114f143606333db3208f15b673e98e81acb7df3bb747f57b39f27f3ac219ab3686fa2291392d322e646789793cede87683307105cb2487dfe69140d8d55f467a577fa6dfeb84ebefa671f4fbf237aa5b2c6f2a541628a63cb0251f93c1f3e6faf3b3d8a5a17d7bac022a45621eda869a375fc6143cf0d4ae30dca44941df2e823a00314635fc74f4ee51017680ee11b55e495b505028b634dc62893f50528bb31a9c4ff3d16287bd40d5cdc5fbc53a948cfa7a2f223e6a9a765e45fa20844640f828650860d23659556a25ec32a50bf20f5bc3e65f8fd978082394fde403020d8b7f8544fc67cab52a75653f90ce9810716519fabc9cbd963805d3ea9a3008ed0b1ec9f746a0484de2c4f10fab97a6a645ad1db9597891dda3b8e2617b1a5e52a297307da36acccc9c758c5085dd7955476b14a9fee32f2685371f0838196037de0539bc2ee633095d5226a37e3341ccdf0a91d1ebe7c82f40acd82c2862cda7679f29cd3916e63c73a6c36775df96b4107961cc64191f416d979ceb6d9a0706c8678662c9330c61db4288307f77468f99963ae2a257270bc1d7c7089ffaae5b9132e3f77577e241eff275ea0ec33c00941c20e79f40ca53b2b5e19941169455a82970a14bcbdffecf0793d5ad5f0a7b5cf257c1543fcbf6109467291485968f57915518ee52c6b6ff373c9e3cbb58fc7fdc9d3efcfba54d37868c41979603a9a4d1acf824898188778a1296cb1febfffbdbe059f0e9a1679afb206e55e10d5c881a0c20239cdabecc61999fd564635827af22cf6d5236b9be47d9c003007c02e1eb995d7e1ebf7085f9015e823ed04b197ef8553f07f1422ccdaa457c87c4102f9968b223eac4f1dd40cc50846aca1c926b9f5bfec86f019fa7ca2b7307b189ca522db927b597c812029b79cf0c6617dc26b016424370ea8646a8518d7ed326bf9662a932814c85493e48bbf694c9afd6f04cba9570f239921cf4d3b6d724c1822cfdc4f321687e9d0513fd3ca76cdfa2c72275429919d03fc58bcd0b0522c4924422fb3d4f99600d7b59e7160d3afee43bb71dcaed17b4f5193aa95df6f95bae161e71f632455c0c408b92613ddb96d0fb63fee8e06c34ca85c0a95ca6ddf7091d5b90a4ab79f8ab5f70e8e4de81a7c515c659be2c6de3f110d22a83562dcc0cc33d174b9c47bd014826b80a994ca1b6a4c8e9c12a9bdb3319090b2e0bed658f893d44e9a1b47728a82a7ba8d469e6b1a519c95335b28fa2f49ac4ef8fc37d88d267412b5c44ddd06dd5cc7a7ab9b141afd8e6a9c8109ba7d18c3c6ddd13bc605f60ea33d769d152bfeb5c6635a961f79d54f86052f3d0c5377716c35026324c3cd91956cbe0011a27d84cea35f32995d7d9a34211efecf789adeacc0119dfa35397066af324823af0f056b83bc7843b07f7b5348691c8ff78679c5f640bff7b92db25d46b6de4d863b8e457f182f50729f94c36c99b184fde46441b6e39fe1ffb803015447188b6ce1c5dc44bba52d3f6c40826b6469c46dfc6b204adae55cca7431065595dd1e2d6d2065527ab3e9d316a3841503ae835a35beda4a05dc1c255ab30ab2cf68a60d7e94a91ee6e1f12e01f6334923cb5d5c3770fe5a5094fad15423acbbeff0614e3334182257a6bded3a7583c5ec9117e85022aae0be4956aecde2443ba29dd0e5445904679e4c54598d62ad151d44b750423b58710094fb52781fbb895f6dcc2d1b847ce6ac82c2e4a91b01f4cc1fcf7d228e8cfa9eff07619cd8eb796729eb05c82ca78562e884ae31303116ef514c707775ecba65d93a69c9ce19f7cd600cc965ab16874a13f11dbdd7f3e59f646300364a3ef2429945ee293c7f8b460568860d06c2dea12ac3ca34e018120f8cf5bcf2807b8c8ddd41777c7aec58d7912e7557622bb55f9676a19166aae8282129040a7f88d714db747d6b6b6d9714f0c7989b31d0c6d29ab68a9b40cb08e1efd91bd580e38e77302cfcfecd624c91e55ac86f9fbee79e57f80eff137992adf74bb21c16a410962fa647f16dbae590d6b9a7fd190db64d66d7e88e0e19ed1d260ebe8e789dcfea1363f5d60c153ee91bdf52f7143277c1a488f1d8be24985f2c93504617e4eba79c1f2365e9e3a68adaa718b01cd059d816189610042bfa1f176d6050edad8566ed6fed3787c8a54762c2d09253a7818e1a17b677d54b128998427f21cae4cf9c7fea04d09db8f55af32caccbadfd8d0409a2570e7da8188bbab987984fb150d18bde2bee792287f5a9c71e0e8387858f10a36441386de8576f2cf841d15189b21177e62a83b77513a5e23c978fdbd61f1e4e4271f7cfd071a86fcac772ebc20d4cc0a53e65b2567857d33773448b8ea843726022bfa90f41a32e4dc6e2b62a5dd5a2c7121493b53f0112d361709db5d53ed7cee182f8e309d9d3efac6fbb355a9bfb402ec08de09b5831f8abd3c4c755cda984252b41d510cfccb461165ffa83e7adc5f17e335ea152b00910561f1b197715bd3582e5b09de5016e22a42b940a263101dad22550f0d97031c76bf9a572d4a9a8eb0076d96c930552b0a33873f7384a710af6533d89b171c06e13a93c0990d015bea5c8455b24c99b974334ab9cbec963e5ea089571437f247203f00983a0014711bdc524ce02f38063d3d99cbd8195fcea83394d57fbcc40d92a9ef2bbc0dd36bba95ba6ed1f4677b6815e1fc436f96304fca846d7c01d0cc515f7d689480e3a8ff18e002a6c3a249d62b10956aaaf4cbc4a4d99ff404c783e7b2c3c44681368b84068b443d100a4fbc7510d70f868b2ee5b7c513ea7d403610382c316bd9912798f94638ac0abd279509a9f4a6a79d87b4fe98e6b3576597d15ccb4933a5bdebe65748637d45c5f7c1ce935a0b13c108e9fe60e63686e43f343bb75c9cc1718df339bc539f4bc16c55c655e60d86ccb63d274907d3431b37b90a90fa97e9c01e60f6ad17bb40fee2782268e44c34dfeb50de81460c86e83828dae44666e77d72ebb7600c703b543f44abbc72f8443dcbb73f8ad9ef47fa22edc8540697c454be6cb6cfc422e733dd046bf8b4d97c6cad4162125f09b7b7e7debdb1aa41402fd619b7fd91c0781ea7ca85189133a59459d51ef6b36ce79dc0e6f90abf568fbe51ebc9c2416859d2eaec47ba8e21dbc3bb726d914e522ac2c1759521293531adb69e78aa82f767f24f3db1a36a9fdfddb864df56f18e22afc8caaac7f9bc17c2879fdb06ac2d5b6b067b8cc02a0bb119e0f1ffcbda349d636893ec4fde6745fe3b756111c904fd16e2ba855f13c868c5098a250a19f261ad137974c243780727854ef51070c114a8d7a3293dea63f9fddc41029a76328042a1bb8618366cdfceaa20da176fd431fcc9d7ca2dd7836b41e4b5e3ff995c41eba3596b046f190b750e2fe26d77b87180e9acb122f8eff58c100ce95bb1a2cca414234be30a1f919ad5a1d2af0faf10442dfe7934792df5a89d6414dba3bf278821625d25a7947bc264fa76277498e4ec7c41edb246eb796453f6b40d8ce5594cdbb7e53d8231cca2cf59d3055ecd38efd7870b13e538492f3878ee400ed3a8e118dc1d8e7780e2488d74eebf497d7acc0add16c4bb97c27f58053dc3be7c23a4ce054761410d9f84ff78ffa208f666d451cac3acdffb9730e111fc232802edcf44a4656a48e13cf4e8503cbe8613c285327075e8f77791196bc8352d56f93f2542150903da984569b37781b98d880fd188009f3b22dc36f1577e0e8068714141bd8098033a0ea0c3dd1978960dc4f1757fa1a7ff7b6420913f031c66148ab45075ab1eaa97f6ad6a71c2a6fe1a0119e28539338304e2e568a3b80428b3b8e10833046512d2313d4c829556de7ac1bce7aca1e11508910c6725835bf9ff093da29a4c7b0c9d91eac2d76cbf10924232cd51d2072365af34fb730452025d8dcfd41101d1ef46d19c3a36c85e8dd12077d75a288deea88fd3da1061008b57f8333a5032cd6ebc04e721620dc216c526ae7b2e4fcda355d4ddecf6ddf36015255d91b626f90f0508868f86cab1b2199fc15d2dde6fa8fca67d7f80f68592f8ac2add25fb6245ddad081fd69e548803e303fb5d1b6ba442b8fec51fa436ec3d60279a3cf9e9881a49cf7a7423c359a150da9f65ea79001a6289740a8649f112d2159cfd5c25e149f4d9c25c394ee6ff65b234f807f55d8be4bd09984f71357d34820d7b011c5a4cee760d1531e218dc653d6bc5af0a5a2d06d97562db51f18b7d226c73cf7993335a5f1100352d884737f60c6389c32befd001f924fd79e671fe7d10aa60263d207df5f923235bab4c43a968aae0690a2d72dbe455f4b88cd5336d93f4baf6b40ca161d5ce88183604222db165fe3e86e797987b235658ad9abcf7e9af1eeed9264665bc4392950dfd48ce01eee9c2ff9b2f23d2f92c8bbc02d19b1e0ffa38f051bb5e8a39eefcf6334b5561de06773e88ade7728369f267db7f17dd416722bb589e9c7bb88dddcf5eba436083b6262a4789b7acacc85dea26393c04fd1489422b876b1c84d5fc636cd3aa897750db2e2d3b3145d6c11efa35ff3b9a4a9c37901273f907c3c8f23b0bc0261ebf579a0d279d692b18dbe3cb1fda57e8ea453aa756036471f8edff62ccb4bdc22e966c08eda73c95a361c2d23c273d57f3ea013d7ec2f504d5e2bfaf65f25c7e018d229ec174a4232b166f682942402b73a0009e6eb1e4fc0d0bd99cae4ebe878d6c9f6f0317df785dbb7a738dd54c8447c8222ce7a3372706d9d0f142e1e790b76198d9f01faf47a4f74647a45fe6d19ccc984f0588d160fea9798b4490a10dc39212157832f21d775338335a4c5113b9a7b43dea8f96400e2a681cfe87c4666b0a077aec2567246388ce22b956ae085c83caf91d6825c097fd58be92943e7350ef9bd642216631a06bbdf7b7487f830bb4a368c2945ae66875f05c817797667c3a9b8aee809ff28ebab7deb2c011cfd0ca883650a505201f94f142db2bb75521ff05a716ff7a3712c28ba0a2e54a1d8ec84b943a12e19afa67608508fe445e0f8e46f6bb4c17cec0efaea6746cf448ccf22a944726fbdc91da4769f745e836f255b69f732e49f2c4071f67b8781befb5c4107e9d4b60350e2cb98364626626dd912edb4e0b8ad2a8ea15c9a2d4cba6d6980b1680d25d92accd25b5f1aba94d391e5ed3099ad32d6abfa55f406540959a9fa80d5fca4e22268b1b26bbebcb0c240713823be898fbb9de974ee436606bd1ede7decaec81cad873f02f925b3b37b80db3eac6768e628b5da512a72acb56b83e0b410771d9fd720b4ec89ebe803d5b5de324ae7c1ad761e103b54a69ab083c5eeb5c5a2b5cdb905d35fcef814d05c0d415544cd9eb291087d2cddc78cd7724d22b8add78d29e70746d333c3525c79c01bf8ca65d2a878323a08a300ab57a40a94a63c8099197b87a00bc598d65db56f7a6f519890e72272228f5c6e0eea8d7311366ced7fce2ede7c04dd2e701b1472c4d10aa9edeedd3e60f2113c95049de09c3efae4ba677c1d68a6e1b00b410bde73df3578c29d9b99d77d73aec585ad89a73a9522dfa9c62f667d678e76505a038fdb7dc6def1a1d946f4d56df81d288fee24b58d51e2770b2c01c6c65e85806ffc2661aa3dfc682ac791c6a689d607be918dc6197e25528ac67f8718a6802d1dbbe5972f25e4762dfb7a664461583d6914d24b4df654c3ff3ef0c26f76d9cbda87df4a6430cae272323da0986b4c29355915925e1c173071d3665b235e3cec40b736aefa20a8bd6cff73289d11bf3244608997c8a31ad17f98a2045a3cf4f3ca857fed9f42c395647faee29c25133a914c352d882d40fa302006a24378200d3d55f46d752bab0be5e0c16f1d1ca9d38d3836ceb4cf273ea82cb5f52490e1e79bf65df9e5a32369db55bc88003a8a59a4f00cf007e05434db2be708bf14f202a8656fe9d21d070ff4b8a8d293b22fb6214178f00cb67b75d3e538453aada4275c5a85a1bb3c80e20defcdcad62ae33ac575eb96dc678801fcbbb3a20e52fa12e34212be0cc9c6e9d70f3e6327dd138ef368e5381226eff4367d1ada788498f207e391601d59668110c9ea68a86479da7dcd0d9d5d7d8536da4915ac81b6dcfa266a90a12eea324b52e9cbf329ee2161fa3eddb2228fab752a267129d7741f912b1bad8ea183cb4e74262994a729a9f495a23d1c0de1792b0943d60f62c20e4942758b2b498a472e43e3074ecbd96b05301b0546f5f6155a6ee10f4bc4266835285dd989e2cbcd12f9cce7794810302865bf300dd900873b677386f0479cdd934ef3e97ccdfdfd652e8977f9e24c048f2bef9031e1ea97a5b192f06652d70077b3cd1fe136a8fd374bd8d558cf814f79ec553d267f6cff966317c7898908da0b8bb751ef9c8b5cc8a07904c2691f59c02abc6cc3f9ee7777926d717a0d26fec39890c2b4e99ea5f09cf3e047f91234ff5ba24cc18df838612111bd0a66da833bdfdc40a9baea531c12f8e682f63eee2746f81e5ab20c64181362b0ce5005c5a20799ae3da4a0d984c95bf705417561b10a3d20657c075a8cadbb92c8d81745f33f728790903d9b8a944fc4bffc5122dd78c43c806d019b25c91e3c9b17fa13b826111ff6333045c683fff8cba528df84c1011a0136e5f0a60931fe1256d0506cd48deb1320a5eab6ac049f7a69c20da46bfb90b8bd8c6105429598f98d1d225522f37f548598332a05e6090050d1b75f4383bc3530607444d89ba40e3d7c1e46dfadb7ef84608beba8a9dc9a30cc2824c8afb300c867c93fb00bda204a6ddda16e606c95a7a80991adc4f1a2a7a3b3c38eece4bac9f9ee6ca99bc9a6a13a09539eaa596d9d569bdb87cf6ea95232047beb9750c5e53cb1757db7cccaccefebdb769b7643f450b29e095e1bb81a9db7542ad482f440139ca03533fea409a39cf2a3cfd50f6a289f96bc35711623ceb6c0468f3127f4736d54bfe81db72630250e6c5d408a3482c1fca3182025df90d1a23dac2b6bea87c10becda029385c9cd1199ed6c71735127018536f25c8a3a4a955a72a3b8819f290b7b2425ebe88f65ba2fe31383a9b39fab2fa7b5f8741a617b560bb2e6c25120cfdf3a4c4ec4ad25d1ecdba4c48bbc716aeea69d94fc054e396605e4eefeb7a2ef506960cb512af3ceed95489ec7d5e076854f9caa89134530b94f829af59a4af701eab75dfe354ccfda9a1f1142cd6f62229e244b3f9ab1e6d15e00171de894a727be6e1a81c30f32e085152816f9c47bbbd81b281b7521749d24fafa1e1be787e2304b1272848d8837f2cef01daf5b8e5f20a655d03c5e8f9c8284ef4ad59f883f7a7b0c111b9f18c60944f490eef3174d83c2515a693bf1ab80f7272d0b1492ac1f60ae1ef819fe3de8499ab479888b851c87e565553bde74e37ffc5ab2a4f02cf5d964384876254f25f5be3c2b0382c47924e7a983561cc98d0e4f38189e4610693bb4a01cfe8018ecd3ea36c6221b28fd619649a52902ca375b71772eaf6bedea8426dd63675fc211f187a248c6b4bd4b93dda3a9f2108b6a3de7754d238d2ee80c376157409618b3f052415e339deecc716fc1ebd857597780a8a87aa04d157a2ed3ed864bc8e5712e9fc606c23bbd68a9a254c0183e7cf58f24dcbbc009bbdb3d377bbc7d6b9aa505a4cb6b9adcd1603ba9f164a67421d08829047179407ff260f138207c1e99633426227510d21b564533812e6e6f1f0713d05978d5e32ff4043ec9d455d6750920ec0a38111957d0021b42e99b3ca9acdfce73e8148bfa59039190f7b92ff66bf858ce5da5679c489be13da4d4b894b5cd327392d45e334c5fdffc87d5a05d63c7bdc1407b7a590b987a2df5440b79ec73f1640933383e8820b7f447830ad5ef57321b53a60e6853630e85f44f28b263187b96704d06e0a8b53ce1d84948ad8f2d4693a1224e72f546bed18a93c659d928673e99833a69c2349d4bd23202382bf5e70fe45842eadb86b04275762c86b2b12400af85710625375446fc58f06099056200671938ace14a741f3b07fe6fa28b10c8588e49915ede0fb9a71b620952d6423940ff8c770ae0dce339e7a75deb8bf1c62314f2ee1013c6e144859d3c4b24b3489e451495b52501fad4ec50b3cb84dc0dcbc379cc7399b179256bb901c779c8e8e899d9179528375262cda613ec54dfbf8a1a292e1858239eb2245e89de57b29ab9eaf2b3165a65dcfb517ede786d92e1a220fbcf9fe2f2bb07c537032b1a8901c1b73b2e9be5a4580b121b61807ca904e634e8d4b2fc82dc88c1235b266e7c9ffb47b928dc7ca6bf79e0544f96d911204058c71ee19730054224d2158d8961e83032b5e0410623013e1023374541eaa1f52b79bf397d29e11164aa319e279eb46bc2608462265686822553baabdfe8ef06cf796cbe3b8585875f2667287f4e00fa71a827d506f6d5bc20120316e728de7a5ee062df4b1235f0c8fc5d64b1f86a57eff901b0d9dd416593a7f8a030088b6b83ff666aedd72fe7f928ae053fb742709efdb142c37040f9b8cfe61ef0c52dcb935541def4f5bd12947cf53742fa47cf9b0e79922bf157b7073fe4bddf28db1dd229190d44e4955bd2e63ae79542b203025216025cedef4edfd56d5cc9974e6592e4c9a27849be18c7d456356592f0efede9026c4c8975ad17699e11afbad72b841452e27141350dfa208335ea4be4a172a731c9eed8e944727b14447c5b42b5b29a8a2f81d08a7c001efb173f02e9c3511f2a91302d142efea7687f942d09ac002739a527c60952b2417849647960b5b9a7c620fe7946386b7ce459ccdfceb6e3f137e1754ddf3a014a8e5bcf5c0a47d5ee26d798e6baf19f2c1a4554b8586076efb815b2730a47f6253cc1fa638533f2e4d8d30b6c6610186cf59d93aaf891af1e976305f0322e9ce09c1c5d48a7501c3798aeaa9893775fdcc20c7278e655b0d458658140f13ea263a230334334bf1b857a333ea6dc371fbae11196a3874a1b995b8ee087b3875c33f392c9ebb63ecc21bbb50db1315152ed7b3039a957c2af51438a6f7d6b82de108d2fd815260753ad80343d9523f61cada5e070536d38748d15ea31ad9d3205536b6f30c1adedd6fe96bb55980c6cd1e26ba84f76042e2ae3b1d4bdedaeacf7fc05ef4ecae8ee4d2bff6b9ab5a2e87f0712f0f941f00033f8ea03e6de570e41fcc8127982dfebf96b5f7b3c4b6cad558a3386b12d49578ced5e00441b61a66e376312a03cd6e759066ac53f079957d10773d279525234aa5d96abd96d1ec1f6cb8edeb3abef777b854271fa9f083d8ca9ec26dd31b5b7853e8ebdac7e7c8aed25ea5f2b0948c2fb5fa7be656b01dd2f80acf626cb2b15cdd89d97bad92efd22205ffbf1568c134a6b77a1669710d675e5b8de77f5dc0e168565c7f39f4e6e3c2da0662a40546c3888fa1372d986fe184408835b5202b20d92e9e7654d6048bba17c73b832796d14330b6c6ce94746c25d5e7229b777d04b2f533eeb0998a20a917eefcdcfccd37942905bf37fff7b27069506928b1c8337cbc1ccdbebbbd9b9413ccc624dc552017b69672c16ab4458e565dd27039fd4f3bd0f3110b6075ada06494f0916600b4ae26ddef7916db290f5a18d86be075661a943714dbb94d1dcf6e595fdc7ae14fc367a82be6d89948b3caaf08bac2e8d5b5c50df9694a0f28cc3f4bce9b127a6dd4b63cd6d92e47531c5df98b2196a1fffa711caf56e1bc3ed60b23022616bda52bbbb7704cf4b609c87f19a332cd86c908a363dc83ad1f678c00a1cfee26e84289085aa963ca360f688ab7f0e239c93576f61f03e1dbfa1d87b994df685bd28c3520144cbf632b0aa68e5bfb63b5ce62e039242f8cc30d73ef768444e19ce6006c5b3b443837b2219e845ef4c59689463c6cc636f4b1903e65b36b98f860ae37adb8d6a7c368f8d18f53ede42420e6612428b261e2621e443c1348ad4c07621ecdf83d50f0106d6b757af360856f8334c5ecf10c48f234f52a205429f21480afb32edffb61bb198459b3cc236e180ed57edfb8df8d38b1ed0076f67d6d7b162e9fb842d5c9e30817dde7637374ed19c84d7f0b3d8630c8c7b032c7929ad48770b3274651cbfe9bfdaa933119975385b11b80c1fb4f631e0f01acd14a4271d335d8815ee493a97b3bf4ba59963212324313b5cb61d636088773cc53b9ede5cdeeaadd2f6f5f73cea8c27cfdba90ba2266d9efd9bdcf7854f07845783fa89be8ff18c89bc5acecb3604a61161c224417606a94b5f791e8a150cf5f9d232a82462d54d4cc60bd1dc35a88f74d5d7df28dd66e3a81c241e1be094e360c26eb82de13e3a9c22ce2f037556224fe9328ffe1d23df269f09be170aea8da5baf57305885f07bb6dd39157e9871ce2c07e10779096289adac9584bff54595905037f5cb7b5224f0d1f8552852c4e0971b998e87fe380799229adb3bc6c47b4106df901205483293e44dea6b1dd35f921e6a5ccb610e5e74affc1ce7c7f9acd9d18bbec97e26011d64a8b92210bbf6c208b73d0a4de9039c0c6ff187a203d66cc622816032fd2b6aec1283cf1a522fe64ee53a63b0564e08efc197b26b6399f3e2a8bbb109711f0d804cb244a7f6bd4af20fdabd1bd41ff34bac9dd1d7c98607f56470969edb94c79afc3746c666d73f712e8da1b12fea0ae04e8e6542f396ecbf4838747285b594de5144bb4044d32fe23d8ed3880853ed9e73f20a272502612a22455243ad1e41a93c951043b46ca12fe6429fb5ce676f0076d35ac4c98248356a17eb6183dfd589e4f7f046f81b5253a29cb03ed3831852f3b2941c56f809152c3c1f91034c07a175c3d642c790374cd47b811514b6c67976d7fe5689d93e2572b7b2190d3f50c0e77c6ba9f9617d6fb9d59c754d2f24c6e8ad84899ceee2f90ed6e0ab7815acbf8ccf57828331f8b5912a31c572a2edb2ee3469964f04047335228501e1cdbfbc34b4f8cf0e83a4f498748894f1c7e8dc97499ae23f14bf3fffc2f60953e52103b962d55b4daa348ee8a4d2484b83fea2d3adf27d2b5d4c6ff4a24cb99bb419e8a736167310f8ada3d852d753cc5a99f1e523e158b4387eb80d67b815ce86059fdb4995e06d989c324aef99d07e5febe20c082ec552f858d2d6cf1bc56ff0d1e1253c7318deb89d89e31d98d63dfc9a265e85e5e35a0e9f8e3a3f9ab971e3a99dcd86803ea426c7b16ed9cb37b66583c6ba5c01a6136cd7107b545b89a900bb0a7f8e83f9714558212beb66ec49eb861c7a3512831743fe7e82ef2a49344a33e8fc24ba95232519f622f57caf828e091779be5d64183b0c9b2d88c89716695547c30bfe294a4b4db93603d7a19c3226b31c93a9e7b8d03dfc8e807eac337168ab7c9924fe0d970d8aa19a77fc4074973a22b5c1a316dfb09d253ce766741e402ba32798c1aebd7ece63e3d37a154ce94f8ac64188abcd7b43214c6bd5d3d5cd10381ee3b7682dbc2071cc136778411e119450932e4fc66f59adbd75df7fd8c83353e4f8101d097c77e8fcc411ab3daf2f5c1bd8fc04264521c52d08b54b7c431e739c694f8540fa72036e2053ef8ac1de7867cc394c2cd34765fe8681ad2e4b5316047819f05d655e6fb9ecf0aeb4a54b95dff77d55eeb7fb6143ef9a716c8f4c974f9d8a32f1401accc065b500256c39bf44440994289025c50997b03f13fae035a3da99516eb5ebe78a0c6058ecc182b2b8858ec5d1d4e131880255827f619fe6f47a0d5709ef69a3bcecee9a664145c26ec6ae131d0b682a611b39dd94b69ce6b21e6a7c428dfb960ae09fc821bd08a71db2bab292459217241fc049025680cd0d5524c57f4f33528fe9849b5c4278e3cbe19e3baa5c7eef5700bdb1a13862aea5577983cb3ba4774a39a880e64cd7d0adeb66d016ef4500d2f2b1f74ceee7c515ea293ad38719505cee3147753f85ea17b467bd3f62e872fa4258fb6745596f88a33586b6ab84204f503728171024c1909199e1003197525153fc83c9b1ffafc48a1e53e47b7e4bde4ca81bcbdeae222904a36dab8df016cae138eb5bbffd45122477b5babd42ba79301cf101f783713d18351572b4d3bbf95657b3ac827553735cfa59c0b6d1c3679decea0b02fd20ee746b5d1c77cd9c3aad1a5d448758c24dadfe63c83342a2406392aa3161b70e24d7ee755dd5c72f875893d72b6fe8d2e59837f4505a2be30ec7b510f0c79aea97f9151177eeb85ec8b50391db4fed199674380c0aa7e44ab63ae405e81d2310f0472ddc9d230c1b8409da9a4f4eb51f2da07e96d2eac676ffba7d93e87e4fba1b5bd9cbd651a53a60e441dacd8b76b1f4cf48094d22bacadaf1534a0790c9048a8ec0217340ad540977afc6c3b8741814bdf8790c20b3f60e2f49c244ae313216a917e86ece530da656b420c363aa8fec7eb811871a7122728c493a0b3897320f004d6f7e68a61e5b2e5833388cb74c5008ebcf0adea2597b920b79004884c27832c480c4f9c64918f3b77e2b30bff50aaf75581de0343c4f7d66f62104685cb27486cd1308850a14bbf2e19826a9eb04a711e325de82af9d11d5881f4c5c4920102918ce23d7dc1e1124386e82343d62f478ade7121e7e28e91bc1f4e22004449db39e62059fa6a9393ca70378c1ee8e87db170ba959f5b1cb8548e7324ac9c4c8052ff3f89942b06f3f33c95b9d576edbb93fa56704b8e06fb298e88b7f757d1d65183973e26737208786fa86e85cfb7d6c742835c599f281e63e5b4e90a042c7fc30b1e9abd51bad1b60595eabb96e93e6c2300d725f73e54bcbde5ed2d4afadce0038087fec71c3435e59825e2e912add5cdfaecca9011f6984ad33a547cfa0632e8811c6ae78629234041068e16a21fafb775e2522ce0f918f9ad7efbb18e1e509f80fbb2a554db6805330a2a7eec55878f8f2d045334448a129db4d4d115ed2a47d2e95ac098b5b87a23257c3bf5c444e58150107311d5b2fe313d73bf5cb2df80f45f515ae59addaa7d9850bc6daeda1dd889b521ec01364e874ce6b8851fbd7edb310faa514e229199adc460b4c1cd72b3a1065bc76c47535be3f8486cf62e0c4128eb5e536eea4945e9b4d0f7428bd0f44c6d1ea1485da2efd10130f818d400a1e29fa5ce094857753873b60cf4a6a4edf0263a31ed1699f86ca76b0775966a582f417fda49420fa527885b924df5a8ea37634c095d3aba0f04cedbb83e44b887da24730ebd878e6420786d3e807994870f7f453ade6e1147d284e840c306ed50cc490d87aa507f516b041c709c206b0614e58e47e490392e54a1ad3cbabd07665abb766b6a972d49f6d166e2cefd48f0ff54f34e7aab1a9f52a1b18a4b9a7c28d85fa07a1770bcf562cc86a8219ad466421f099a2ca4e9861c8c6594ef00b7a6eb3265bb53b4c15c946412a9a0b7a4eb95091b1931cfbc9a1b2f1b86615c5f89a6ba9c70aa40d520b82219b9c74d357c507a122e7aa5a0dbc97220599261a2329b25f330f10357a9507879809f16d156e0e60b858a55d75b2f29b78d6004e9ffeb44d3eeeaba6c91230ea3b75f5eb96934b3b9113a236f176155aa6ab2b6e0acc606aa17c1c7473c80cdf9ebe4f0e711f40300ca6d69ba51afb5481c1fc3c215404688ef570caff870e9453ee2670442bc5aba18322869b2f9ed6cf611e741ae8b0145feb86befe04b1b6789acd66ec53a9717e1e2b6ad27e30e479c0d2538ed5f967305451dc68c1a2132e8374a82dd8f178f4f7b4be550d164e2f1068ae1345184afff037a2b312620b05c342ceb1709c76864b95ed02c60385ad3173e8d8cd3d5cf3981a538b430f350daa1da525a9cb41f88b4d5ad19e80d4126daa32636e4c2585845efe2b7835aaecebf4d5223f0b29f6211a2b4172dbde68ca04ab105057d2dbb1fb5c0ea0784cb1974edc0f77fdac00cce506a9da3ca9501a1b0f147d385737d8f92d66971b39265ae2d922073b3ace001b16b4987d258ebfe7dae8b3463b3144e694a78cb4638f0cad92f8864bacc71bbf0cc5bbb6d56fe825c68386a2031738aa5d542adf51e62c162c22f945b4c6f795298555cdec1dbb691456c684a7d85c01e832f96acd52305e999704b9d2cf3032a3119ae61ea2920cd9e6500a3414169c9cd87b584dcc31f49de76f8b777fd1c91c7517a151bbf2c233edaeb744ce934fd3ba0c85389748f501d662f47b0c35e960a2776cdb45e278faee80077839dfde632ea5e18e27ea5d2017cc438f519eeb8cd2f284e0edf9c05b5d4d773bb4b1535562c906e0c75e366123dffdee5e7d23698a6916f11f60fd17a5ef9b2acf391cb3a8ba5455a7ba8cb74a6b800bdb52a105828cd365ac404275d6ef7c34ccf5c2c58e01d1d5b016164b55629e507f30c5e25af55ed94ea40b48ceb1dec91945fec8d32f838ac717c46052ef573e0ad20750117590f39ba4b1c294384fad1be9b6019cb1e94b27f23dde74fc5a526a8b681b86111434d0a602cfc6f85d36ea2da634e49e58d7e6975dd00bf2856d291a19b191cee5048e67c6ea7b37e8870f34776109a7beff223ebcb4cb774942e0539e12ccf287bdf7bb6bbad8789336ca9037479797457546b1223f1894f235bd87f104fcb6b4c0126d04b42cb9090d39ea12e34555922082b69d7c2be02517638f1fb739e9e9e803a3070721a61e791de3531b3596bca2804e036b75c53ab22b2aec10c952c5874d67c9cdc0442b077971cdcc05cec3d31a1831139cefa949a1ac2e4b5cde21c3928cae22987b7ec01ad6a4bc52537f6a2197fa09d8f7f9ef57c21b795bbe6e9ddfa9eab669481f9ae193c220746a823c7706a8ae16952a13fbfc9b5465ec182ad8548371fc2791f7da0acb792eabc457ee079a6e7a20a2d9aa416fbf366d53ab3c6d74adb5f116563308631b5a421c6cc3345725db12f5f5720103b5df6a8e4703a57742cc6de68743cd8c43eab1439f4d4bd78ee4d6b55eee6d7c2c30cb5e20af1367a73b61a2a930e45825fb51ea3946c54aaa5ba2e2ecbfd73c901c2cb160c71e799678437436b17ef83e4e0f9e9ed28b40b96edf6c5532aec8cad08c0da369d4e306dce06e9eafd33cd8b13d9895df838c5843ce8fb091957a7fb3eb553d5e635d952d04ea030fa47ef9b23497ec7f30d8648984887ca4a479cf8c521a20fc84c025531fa2811ca009a4d9bc56d8f531d9d3912225a1dcf2140635c8472208a635422ab2b6d6ca3c7cd10118d474db994884fd2f1d606b8e53851f0253cbe087a2886c6e89228bec0b5e640e9bab58559f67034bb4f4c728f4730376c6bc7e1a638b67d494930992536632b9947cb82c02bf20dbce09f6fb9f6e4634df2d0212fa074eeb1991db39e81503457e241307eb59b338847f5ee9347eafc28fcf8dc0599cfbcbc81bb1345e2ec42fbef9845406ad11edfbfcf8d4e77c7a863403d97f5cacc48a3fe21db1ffbf25c37802d45a37a3152832db791add117f1281d2c7fd8e3a3e9a19f1479394545d4093fc35fe1ac125f95f78c937b0d43b7b498bb4d7da74e608e1d452007600c2c6e45dc32d8195bfcf124a8a94f4ad7e971fd21a0777081273903ad6495170c29f53a6079690e5fad67ac97d5f7923ba874407b25b5496a1c54cafec88bf9fbfdf7cb7a119273a57473d1aeba329e4560c2f352157530e0e4a6cc09b908c2837513d65626c52fe1c5911ab6688768fa0a2f9f0770b3defb6c412d48c7e313e3182ce91babe609fa1afb112fe632f33f6e4b4bffd74e17ea9fde0c02114721453ec859183351d96c27fa20cbefa0af617d7f07988dc161028412066742d3966612e260d9136534423351d57dacdb87b9906a49ba539989ce284eeaafcc6a720b4bc1363071cb3400de2c14b0532d9db217cc5e69f21eb418b973948ebebe13458785101d24b87899d34c7fe7e87bbf0c9f6e7427afd0422fad53ef53544882dca4fd2c50efee7ff65cc7759905bc5e4741cbc29f4c16d75f4c59cfe761e5cb717d31e27c42bc6844bc90471ce168f734be5b43acb85cb1d0f287b0fe65a9aecb714b232789a25499dc6d6223c56b574fe9dba8f7782e72daa3feace302da06992e959372a6ada65f01a029831600efbb8af3c4c34105a54dab8fc3ea55d094f327b4d7c49409b17a32d159871b64909b2fd0cc4ac0afc38d043153579e37c5e185c2ec917dcd9472f59678e262f64554e3759183b74fe36939000e1adff5987a8e35fc80b8dcfc493d3a781491b89c5e2c14f2260cdea4c91ab4b5d3b905e6b9de3c7afa5168e4f0d42d9c0b362febc50ced75cf84964e4e21999ef8f3fbf48069cd4694f88299f2e1b5b74282075e9ffbe6000c44a3a4fb95f7dc810e2b808a2e66685652b6d2be2a870bc7863c86015c1fe1794edf7fea06b2fa288daf43d77dc9c5a677023cb72bbf624273dd5a2e4bad294907d6253f598451027c91d188e91ac044ae686ac67a10090ec1ffd707ff1cd6ae2cb55d06d710f3a2688f6ee446b1902370b95d2da675fc00635e4ca8167aee64bdd2b492da883852040dfaebecaf42e05e179fe9c666d46fe4b6127f083d778da854ad7b4a6da15fb9ced65d873a92a86a8ef418487f834b3650adf5fa06eaf9b54c4d93d60ad3f02dc6cdc7fd961dd12fb7c01f7d3315468ecd1a63af40e9e696c708b07e58234f86c9e7efd9f302fc0cd4773bf61c349024e0043760db2fb827a956994673bf18ef0fe97e203150b22a82ca193f2a6cd82f874f3d323411b33c0c4fa633235e6b504a4e8b559da9d7d749c004d660911425b911d2fb5cf77f302b09319321de9a87f4278839e7d3b415a774a88d8c3406aaea5d6b74aba8848f212cf4a2d368a06099906186c5eb6691ee6a46645daf9062743256ac85c743a77e9f2c94925e4b50b00bc9b0ef4182f4ee2b8105dc0fbc0b04559cef67060a8ee4a36331987d3d37cc974d11a664184a7532e70b5e6b307e239403f09ad54c58ad32d5b2b4df2f014560b6f8cf38d7fc202e37d88ab9352150051d5d336b04984d1895648a21760ce5d527d4e7185c7d5ae6a42f206149b596ed10340945487e4dcdff8a1cba0d3cd3f9ac5b8039537fff5a79641352eb5f5a6e3789229250a6231a73a109fee6d30da02ad300f98330999863a5b2867784e10bb8de972ac33a452eee7ba32b864fae8a3fe6e2dd41eb8563e56ea5504aa7024abad64bae4a5b075a7c04653a562547e8392dd19a54c1d2c6d8ba9f046ef43bc9f24479bd8b26e966ec78ebb89cda1f6080a5a0bd4a58bbc8ad005023eb1b746f2f2983cb04a3bf5913f72f5c42c6cb95789766dcdf7929ff70dbea0d009bc2e4f20f35137aaca97dbf6ef69fa3008f0614b095cde305e8a02cc9e7a6f1e2608fb9fc111087b1688dbca8b2725e4b6845acbe4ae8362694acbbcea459c1d5610b45578f2ca86aa39192828466855bd58381f4f84ec05c1ea946b5229a5dee4c161b01f30ccae8bdf79c353d2e9f11d7308df78584ff99cf665c69d4b58f31a15049d2b7dd1b1adf6df1e3606a618ee275e247e7b845b8f44b6ed8c555a09db92b8785678c14b2a9a77a104a7958ab7cde3328b71dd057c16f19f2bad41c36779d1b767c896a6990e0231af0ce0ff07d758ca1b8aeba36fd36ee51a3cb75d461c0babaad37720e91953101715ee59ce0727b5ffca26a407a93c4e25ef6545de613e3813b0c67c852da03998003ec1d778ef5f429c44e8275a32b7b915f46d5afb9498e1830db89e9c4b0b2e3bb97b324822a22f9126f371841569e4310af0445960429f6db7c0a7ac6d24bcac69cb0c2432b9d7c72054004215b84912fb0a896690205","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
