<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e19c0cdba90b84119931fd3d01e251aacbaef72a40b2dfec22981e545f9bf21cba05149b3fc65463d6a9321d102332bf43b2335e7cfcd875df841543136d70614d05fb9e8d8ca34aaac13b95c8c0205814919f37c6b080402177955839bfe6d22b6488bb98277cb70c61fe8cc16c2821a3e90e277ae469c7b03196a16ec6b77df383531ceb51d55b0e8986f12649c853cd45cdf58378f635b975bff19efc80f58b9fc0295820aa20e62f138c8469427aa951df51542c462b40c0f17a116027230e8c6b8333e918b686ee6adeace74d70593d6189d77fc8fdbe7a33a8c1eafbf918b6aa30e7a66ea5e184701a6eefcaf654e032a384f7cb9948027841ec23b6ecbac0860893b3196d2f0aaa2623412cc80314f3840ce1329db790db5f531cf0f117c7cbece033fa840c75703b66d15b95b165450be6c68d54d1422eecf3fee360dffb0f92c6385da05608f00ca7e341fb7678fad2e35593dc9fccb353897a07225e0786c44eaf771220b4b821c40717bb7efa8335fc4f3dea5b0086dcbe0c2586a3ece23a0216e75f93395abae232ddb762bd63079e582226731a6c2642d99ee43e642f24aee57522712242f4805577e2f90aad02cf62c9e463d347af27d3a98ed926d238fe0fb3e570da3a088a36806ac7da17e03f62e93e04d805f25b066d9124f473372542fd7178e1a47081976e9839ed991b0b0a1aa903964a8bf0c2b3dc287d7e76e35a8e8b0028ecd83e05babf07e3d097490348e8b1929abc9d28211a50a5bff90faf4e1cad50d98e20ee416c6b25933c5b7eaee5d9caec61f89796e4fc6a450f8015ff5ec837a0aa3f29a2b219faa2ba8658de46dddb38227f2b2f7fae1e5377a6d4273f77caa292f761c781d85db0d2d3bfb0e40adde7797c00209a49b82ef4564c2f1981a78c5346e6f326c000bf0e2b45af3eb249719153fbe9ef2b6ebc44f91b8592cbbc47b2dca0bb1ab0934a60378280dfd9637459ed7fd37211729686f66c1d49ecfcdf024b9f2a324347abee7c29de90668336a10dec18745d219dbe38793effc71e04e1590f57f00a7bfedefffd4bbe8693d194049a0596ca5a287e1347084d6a455c10b3fd9b9381f06b829ee3df54ae853435d4f51a503f44131ff0cf2c144da37cf26bcff169d54b9d916d38721f990bb4bc4db66ea25ada27dccf1b4a7b07f007ddb61f854c3fd346f1f5bd000d8847dbc44345f0aada91e7e9cd0be292521abb1f57e38708f525fbd936e93a6f89575a77aed7311b202cad6ca17cb7d799461f38c38bd4456d58c1824daaa2bb9004e117667eb3a0089397c757cc567d07df1ee66bfbe9cef2d32fcf5b7560f9b7c64da8107dfb96b6cc15f1cf8af6012df04b418a8b68fe35e0db438eeb21fd7b30812ab03938d1a2e3098c9ed5a37e3d0f2cb3d6e3051b0d058756717ad4134bd176b5db874a181a89a570454a7190c705633b4f0950ede6e9db0d1d195501400dcf9d48fcafdfd46c7bae7f635a4c82d418d90807a46ad7e14bc46907f4e07ded1f0b62310a3f075e51f74a58124227707324d398d8be559a76d3090ded464ecdb1c3c6c756a32182f2d793b4ddf8d39d2698714edbcc2b8597893a44b5fd7002b1cead4eb7454c7216854fc197c618825bb1e81d8af1bf56fb5617c99d8d8d02b1398e2839835885b3aff4090b1f9011188adb1803495f338e91f98d0e620126efe14f45407cdd7edc2cd2e8f9264f427f86eb7d8c1e6fba33a5e43997e49d18cd30a471e113c90f6c21ed8b76c86ec7a38b75ebc972bc697c311961bb91ce07aae0b5e1a47f71681f1970132893deae014a28fa2552d1ac9124e49dd887a5c4c2ef8935deeadf10c3d2586fa0c5d3180ad7e4a0271f720f08f7e2f377c4cad84ee5c3e18690b4d2747c56ebb8b99ce6bd51fcaf94173108e31882e4d945798fb5bf4209d007eb5821b86604e90556a799201358d1a8668f32beaecb6a5c32dbbbbda99211626ec2d6bf43d7058f9ac07cf932e9fd4a6eb70abbfd0ae51ca13fa6d14b47da98726315dbe0bfa123d750e340f51c1051c9444da751750c22f252a5bee1aca1c4403371383d0f84b881a4be3fcce04ef7d427be05401c59d1763d0a129ac9d2d9b0767db19577ecb4c93f46072d69f5c3903cac9e0ead9d88c38d4b42e524c2d0133c19f85749939a4abd86a4e5532e1ab356602168753f28d72ad6ac12620ca897fb70de8f6cf2537a1658a20f24d60b4f8f96a6f102b941246915961dcb24d86eb1a4695d3e7cda492a2f465a7ce4493f141239fd6b10b0844294623c296144639e05d7cde12ca90c51bf55b5fcb4d91e9a0a0e138ac9125483d5e1c47535bd6d1260c5a1526e17c61930af9fbe760e3fdd852abf3ec50c50fbd3ef1d80e751a2a71b03e6b772850dddab95dd09573d1f298e3f02a6fd6417f86dc4eae3f6db4dc47558dca8c52d9f96f2c001cc9af9fe66ec51b261d0f413d752fc236eec62cc7e6895d8fcb1f37679b6a41f25d24d1e5a4ab5c2d72f905c3e8c10ab06b25332b906865e9def74e2e9fff7043f2aa7bb3e5fc51d18dfb07c9fdf88f96b53a10b1941c5759d3ebc141ab68963bdf3c3eed60bb9e9abb651b943cae852274d2163d6d6d2d1147938f7e14f4382c02bef525c626b58b03de1fdb2315d0b020821d31ca18879b24b48caeba8e5d51e9381e8268a39dfc4a77a554a8b4688dfa93dbf9135535c32dad6be7e15303e4293d2934820fec608ee35ff9ae6da89d7e6d4603aa846241ad84379c17801d5d6b865a158e9a2635a769844dda10fd9518ea4344390a79758ebeec57f40063b1238497f8f50480dfb9eb642b25e6b510d6d8cf603fee638973b70f46a86725362f735dbcf372057176305742b958f20b7b572e9e695fcaecdcb5586c1a31d0acc4548439e2ae07b8a59d0871b77e98266b11ebbbc4ada827fc123d0d82abff463699b47289d3d798bfce3ec132b37737fe91742beecd7d3309c1161895ce344b4db346748ec1ed8eb0a35e13f62815cc8b43e0ffcb77b21b03eb039d293d6c2a0f1f9714df99a97f7c900b0120a022701a5246e111df4ebe80264d52a2e4778b52827cb196bbaf587c78f3f705968ee3a454fea6f0793139df1539e6e5c3e60aa0eccef1381f7df1efbf42dc51df912e040e9ed5c85ca6154d912b4a47eae93a3eeeccb5278590e6c381b080295c005c52b7059d2b3c061955ca700a102c959e4e60853b7524b686c483f162a5e064c985c30dc659e6dc2f880ce63eccac3ac2b2fc5bc0ba8408bd39347d20d50ed3fbfc38be94efdaca297755f001913b763716dab482a4114446687588fe6475c4ff14220816c2ac5ea39a3bac5922425aab71fa488e740cd4dfafa259277a9daba858f6646babc6e965da95dfcfc7d8e72466f4047e28e7313f03397a929a0a0b86d498bdc432369b8d4ee1822d408042817646ef9dc8b1da9565258c55cc1bba981407a2600e202a81b2a45ce288707f644ef25ca9b6daa7ebd1b5cacff9e4da1c2f6bb050ef6347e80e051138986232cedf32e7694e6bc671f2a12c27527051ba4f037ea187e05e0eb613073db44e3c6dc27abd85f1f63b2cbc0cfb75f7fbfb611bba6eb7db3afe594627e78c4867f4244c44cfbfb579fd2f11358cbcc424be53b2f72d4c3d041a02f281c52d01d46e7dad62d0f9d2f628e19396cbcd2e56099df0cf353828e9e94931409d1aee511b1c14110094fc9eebe2039648ec0fbd83a0638fbf8f85ae5ba0611054525a4ec790c77f96026e2aedbf15584c185f7e89ce645c088e879233f2007eccd826216effe758538cb67105b14a5772fee718612d9fd74c94490ce820534e8840dca02159b512e443fa666b6bb7fda2d3f0043da5f044a5b9d9cee17e87e586144e762d6c92230b7a7868811f3765f8227baf005fcbbf934fda101750721b1fcdbe2bf834b19aa39574683042380f9410abd31a2e988902c120631624637ee891809e1d64431ea3ce8592296b1803397e841bb91f84f70e8449beb0e2cb0b7f5f4860b908dbbad50a7f2a1fd3d5124b617e3062324941a748ed37ce81d4d310d2235a3c2d82715bbde0333bb0fd9b8a5f9d88299627614d0dc26a1fce6ae039bae109ed5352258ee511e94f4f5800182591f4a085260ef42480539ce18eb81b7f96575eb2db280e3b887ab26b3b0672fbab7d69aa9f600e004e6406a877828a040130823ec58d548dd5ec999822b7096a4f99e31fb90802af99a2dd7ed387a7097e7bfca8c17796bc7887b2f7b5baec51faf5601acc283dad3a97662532d2978b3e52151222ccbe646bbb1c091666502d6cfb99110ed27e0fb6e8ff2251c5c9fe8582c115a67fd99a9e7f422d2abf615d2a862059826518b5544f2b51e4d81c04562a8bcc8a8fddb56654e3e56298cf74ee8287f6dd1268a8f04a785e4c8db51b120d6f4ede9ad1af48a1e8a9c86e187c6d9824cb842909fbd22d6d3044cfcd093ed2253c1eea56c956d665b54af5cb6716fe88fa57f5f1813f593f106915269792ab1ec40c5e0df50c989809755caa66dbdd4ff5c5dd5fb6f3e6a5a50e9df82ceb963efc77684bb71fab8452b56203fb3292d193a1add4d02666e622feecfed511938c7f007710a511c54eff0005db3d683b56fc8db58a888a630d71a9c4bb1592a3bbd63b2dec5e03c70577c79727007feeb979c84ae661cb02e7d455a0fedfc8e24c77b4e24b186d3dc2c75c602b3b05cf23da3a4526c8a39862a128c0480eb2d170b7a1e6784eed6d54fd262545cd7257fe365696f3a0755d489308fe3a260d7f8ac5b7212af24490c0112cb36771e20db33c351f3db92cb2029a0402b16bc1360a98ffa066eefe707710280cd922b4a95c8c45f8bbb521e53d41b913e665cdfb3f34100f986d010a3b5969e67011275acc72b316f55ce65c0b122bac02a41fbb62c6619aa15aa23f843b1901d650036ea688ad8572131905fd4b323a8a325eda730f6e76c1c607839b4f79bb6844dc29c4e32168dc103403f4f5f3143683fde76503ddba4fdad807eb673e47bcc5b3e2d01dadc55c503d92d0e806235b13a26472f3251adcc1f8720ffad426b1c700459f438f848171207c64940cad6e2aaa630ce4eb172c6ce46006bff98c149de9efc48bbaf97dcf88e18331c7c31a2f398a61f058ec982cff7766f70661046ec0101b84ee9a60b1b9ebd0173b9a459da765a367d261283763ff71dcdace1c1f2ab33a06b11db5f71085e330a12c6d2154e5bf1475d92e0529ea7f9d05cd1e54fe8a9e0bafab38c8ee8073e5079848293ef6628def17395632322e5dfccbe47de0a50248f7ac9751000c2f0195084c6aa69d0c494a937fc25d95cd7cc9c7cfa6a619939f3dc2498fe1b5874ef8ff64324009527b14b2f3dcfa54cf3ae0f44fefaca2e73d5d10da89c2c3304926da4ab6b6d384900c64e3e71a41a65511136ce319d692eefc975bf291620a570318e535b31be0ecc2ff1f6fa902679dab543c6b8781e9a5f3dc420dd0e52072989206b38aa09f31a449405a3338d449b63de7c028953b7fc79f1f9ca296e8612a51fb2dbd8b40228c727d7e71031773bf50b1430339d3f42f23fdd8f77a0dc8538087d2da7fafe1893c60d1f75b9c9b3843325fd96f0aed84bd9a434625ef7fa73cbf73fe7d8a71d1ecc8638e123f16a7762b71ee662b28412e8bdff30765575b56727ae9f4e1afd64cfad11f4c22151a69fcb2c605da5c6abf0068286f58d982b37daef4d13ec0f1952877afb1acd64d83d4232fe66a5dbe4a94bb22ca6d8f0fe75be3e759bcd51cc1d15fb64f9151e1f6dcb4fb5ddc30a5d16c5ae0a1d9acd8b3231f2f1d8c6c00d4ef62f24b479a9819ad46a802bbc8395740d711dd9b49cd2f9a2f23a7b5b7fae56b06038045b4553cb869943dea5f3b280b4a2facd9e1b86e9f89f3173d19a35f7ca5e75ff9f232c62ec0b46b5bd02fbc9e9e17c6596956223abd32eca76c57e2275c3f0619ccc846b6f82bfcc7d5b1db01cd306c4f65c8409e040c9f60a2f667d53d16cc028b1312c5760359b098b4258c5123e8c6d99f1317df2a942377c59cd69bd10eb30a210b84b6a28f0163bfacf644d8af36123fa136c52630b0b95044b3a1fcbd8a61c583b574a0ffb437f650d4a11b5a550b19bb5a66ac27b146534f99f0cc2add6e2cd5fb503b7bcbb480849c8512d859e0ebd6ffc15cb63a36e29a26179e1d748228c85f53bc808eaccdf021a8390c2777c9a6821338a295bcf351aa842402f12b5632dcd8114196470e1ce74ff2da99c3ca585621ad72426439ea729304c89497fb9ac19a959716cc6b5deff0190dc45b1aba0828ca92a79ce1d7fa663653dff872f97d9a2e9f1f51cdcfb7725502560334ed1f6a6c1894224879045163ae7354f0fddf9d522bc6d002acb92800b6734362cdbfdaddff03591fdca55b70ae5cbdba466c7e69ea98068a75573a4f8cae4c758485721a1a27c4349f2efe4056002d3f61256d292184ef8bed255245c8ba2e1a85b846657bae78448cdb5db6454c085d2f3df382ebb43f05d3d8e335f4fc5f4ef2834d583c4b790cc5746c63739eb99d685dcac234f1168a8da7567c84d792ab759490cdb9a9cdb0a5b78bae0f36dd49e8d890d6fc77ca7f5ca7e3926d561fe8ae76d61f1bc361b0f405d2b2184447a5f38f98908a9e0ed899bc707be3a7c25940bb60584852b83e049631d9108b3c3214acec4992dde1a70fffceeb79044dba760ae8880f9cc0fe59bc801c089fe135a8c3c97cc119c8af892223726b1a8ecb79b9c0a53f2fd35dc1e69bdeb39b95dbc83197bc32077ad8b0f37646ce0af603cc698aaaeddd1f0c2b611a210c8899291d17b1aa7f00d42420522fccb7ea5ed26f795d1cf8fcfa15fb60f2857d7dd2d31ed1c1d070f982b389cb4f898f532f2189744d94af1c064a5b69dcc3539ace77fc830f3b72525d0f7ad45618b44958202ac760e67ad1ce18e339219ee84a03cbcc2deb8af8bec7582837c7ba2474e096074f2595a442d2c13ef90baca5da35f34dc08c5265cb1548e64392765abfe96de2913a2407f06247b00ea4ed6ffabd5234948067cdd27ceb53fe3e8c0e3b4ac98563ded3df3321c9962b7f5e9ae33c8102912ac94bb4d0d26973f395ee45580082c1c058431984740b2333834206d6bbfe6a12b449fbc6086da9779ba21189195679a47a0d8a0ec9574f0b697e7092e7ec3ef8afc6e1d752818035a1d54db9d6e80fc0f3d0d58a224ae94eaa66bf5b5d488076916883f4021da857a0ce2b11a273b84a6d54f514c294eb6dc1793b6ce28c02b80c5c386edd09d5e965488e5f66c97e163b03c126b77fada136e85724bc11c853e9f7f4e30d356d6c91e70c04e01ccebb3a349b8f439a8d5eeca1277d0d112c260d59346ac032c2bc473aa20cde5857df7b5205eceac30fd6247d1f062325c946865462fad4e41cf101cbd561b709ac31a0b1290eaff19710f10d2800b21de556b209408d81f1bbb726d27edfb53534a9042d838adc30ba2f0f6cc6a7c21b794a3941c4a98b7da7f208bc32d7ace6eb4a06c35aeae5d3fe732d9b256b4dc94aaec8678145fcf9f3be04485c98383588d62644b00b502699a3f054e7dca65dd569ceb40f707c5aae9eef9176006e9f899a1890588dc9ccc6643530b5ec7e04a6b35f744daf88b44761e14057e8ef25426a0e0effa587506e3c9156a8949ca14f44a6fd78c9e1d1b4d6499bacb537601119c975567e00e6a9578f9fca782aa9080965256cf66ae25645ff4c8fee98af8b7b0e56b493b6a8ef23c83c066427ce4ae60d800057d3c676fd8f05202ed1d5db0d7a6ecda237255011e72368bb5a2b1dd65fd609cbd3d94ab7e70e2d331ecccb88d7be95aea05bdc8bf19cee2e4b13faa45e2cc5b1256e69669b7dfcc2745d6ef610467f193a9f4471c93f6c4ec01cd92e0accd6adf2736e97e5ad437108caacc8eda343bc9322ab1ff09b64e0ed915a89dcc2e6c00a1950b82bbcc42e6486514abf24c8f209ad3e57356a7b43587981feb0ede2c87091cbea9f08132323fad1d5442849c68d11df31f51ade4561d79ea4158f4bad247afc8a171936bfb26f61a3989eb661ac2b6f2eda11c8721a6411124bb665e144ec9415c1b56ba1960676d8e4b1d17511b007ade12cd4bf823b05a8f4cd13b58cdca381662094e564d9a322451ba3ac54639b2991112fbf9a65e7948d60c1fc18778d4060e04240e3a105d8f7132c76d2051f24f2e78d0082d07c7a7ade767cd6e5ee2c407d042474f957b92c72e303269a0030693165ca72981738cb97f9cb0282040516bdb205cbd5fde93427d9ee48fc425d7131e23fb16db68a954721c6b4075f5e0a3e63eb13fd70f197224a03006b62e709f20602caf96a5db496b3d572e8184ee199c20003ebf276aa2e3b203ce81881b17fb15be238a7cc97e46c2fc19819ed7e9644bf88498a508ade0f596d18675fbea2e2f481d7492e0a0757856ecb48d43cf402fa2ae53649732c60de720967b1bfcec1a9eed380566547b2f81f95c530ae9269e9826cc33743c94249bf19811db3b67d0600600c1b15b6ab1bc83bd32da25185f0b77302e93a3a0319e4a3cb25d6936f6f28f0250903a0fb0607c7a88f7c59cb4244db3cde23680effb05667cf0cb3ae065ee36c26e4136db6f23bc1117598abb01c89dcc9c4c7d154565d1ab8d0f2aa06fe1036ca94c65d79fb21a36baf774a8bc1b4cf6b69244ce80694226c2cd24a405505a01c79747cb22e51502f23217a8eb0d1de014cb1c4b67ddedd919b6bfce62175b89e5b48434d70c90a3943a195733195ed12aed372ed011bfe9516ee75549ee28a71ba5aff2aeb592b1819a139d177ba72cf9c799d6811d19c683d5c77a6a01a8baa83e5db6e5a1b586200bcaea73181c18ae29b80fa691b65a7873f29366aa13ad2338ec64008d44240015085cb01eb235e2cdffca7942bdd9121b5d390b1ddee367789ac704186ee62736a48258f8cbc5e1dc2fe31a6e03785cbb910c6f54beec4efddf169cadaa7ac0ed67418e258d47343d13c2c0bc826a179b94d68daad5bd7ae0ddf5f1ea7e7a0c7fd536806f044a6976d603035d6b99e512c2b014b01eaab8e5b59933d0ef1003c912c4d43e6afb2b2a0e57e158a75e3c3b6e39fe36e8170c83813c4b63c7928f4611e2afa5a73009b2892b627fb8111ecb449bcf69598575598592d2768c452c01289a4a376d90fd2b14f87a966825bc6969b3093788842dcfd810ca5e134b29d330e7b745996c2023848139e56a99df481a774434fa624922e5c1f6e800616a17aa5f60c6fc9c08c3735cea53d063dbb3a2cdfb682c2126c38f6ab4dc74e8507b8e379b9b87a1b5c6cc681b2a9c6dd435f9471c53df4dc1368c1abd513c2877b6a67550b4880d86e851ca6244eb7a714c9a9a265f126f1348c9e49d09efe5d0bb0116a2e24b5c0993acb7802d83e0841af8278a9b07aa8c35fc7c6e38b0583ff5c5b862fa54868756d7c223492158f49ad3d9f4b27b1b1656b1dc2fc3e4b1fae4420fedbdda52901740e54ca575b39860f6c176ff42037d676124ba1e39c44bf983b608b44dc0923b6a298e30922942628fb28937f059c822e76ad69c3f7310c934c08c6537b0485bc817888b1d3ed17dd8186d31f12232c221f592d79099050ff799bc301166272d8b5fe9d3187818ea8cc708738e98a2f308bba59c44fc6e1dd1ccd8035ad99e161ca95e0ae6ef660ad9ca44cd7b964b39fcee6258d81b480fe8280aedde2f3b94d25fe90c8eda5dc947450a362b60ca498106043ed8a0d98523c4e48d3b04bf9f1f083fda4ba8145e6022545e37a8fa56699c4fd463f0255fc3ba8abc84a50f9657accd4fd745d1411ec430dc4f6ae9ffb3fc7ad8ddee83cd2e2d3151765b6b2e4f97e4522d260d75786945c3113d53ac8e693bde7a79eefecb1297967d603cc6fccac3358172f29df69dc74f34dd2e0d2c3867d0b0ec7661747b95e84f86206e3b229a0246d50670158233312a512832c1dfedffc0326c6f4c6add6264752ded0f4ac24c55d042cbca8a54b7b254791b884b0300992325db97522cbf1070a4b383fefd040eed1281469651ee8cc513b3d1804294fbcdfb0f391fbf2b47eb2e93dfa8d2645205cb7f144dd1fbae1a26081447209a5f1dc13453d56bb5b9bc5692461f8a313b1d531b4605f12379fb3c5c4004fe4cee3005706e6e3e7eb311c9f64b40e417248feb4fc383eec3b941e7deb06241b8bcc5c4848ded5f51e1d7a4ac9ff14c36073fb44a6c09165a12908aece367644778f91ec58dc95b17479f0e9ec188e69f8f9a7eda250c096c34fd2387ba76743e55ec090e16350a1f4a3b6520fcfd45b1d0bc7b3b205dbd9c6cb806263a41658d8dddea19298bc81d8bfac94be5b3601aa730c2dc3e6520f78e08f6c1c6f38adaa83042a37ab3ab85e91ef75f344eb18fe21b51607ccdcfca8619b0408ed7122767cf8c0552ab60627cc8d08d9108f8f4efca9b7dcd15fbec970fd49099d14066d649c95dc6fb87315103dd5538d19b47a7c89d711b5e6aad2c6b427b078457d0f5b675efdbf76dfb8c3fabe67b3564f0b5037a1a62b335a2c27067a7e4b0a7461234a50f42ea62b8f453be91f84b1222d50909822cb9ba500c8dfa20f39ca6df17016f7db785ee0b9fc2ef2b6ffe78d624f55463e45cc816ebb8e2016ac60f06ae9cab05fbf32f9f1428bdaf0adc550919b1eb16e74f112ddb18d5366a0242bb8429a12270a5159010bfa3497808892587df5f1dfd72c3b04c490d66920ab1a098e44b59ca6eaad1ed5fec029002e723e83acfb6734fa849c36c01d2e7b8d6270191dc2f775d7e554306483285c10363091d095da4a97c9fc097dfb9c912106806171ec2337975d81eb326437739a150dd5466eb55167a915a5cfd40f01b30cbb5ac03a00f4adc789e96fe75380447aa0b44aae531f6fa974f3e5cc665f690a94694d0ae20841e1702224427ac2c33de98d0f86706e71039dd801c53bd8dc4511cda82e7c5c01672455ecb7bec7cff2d09939188e80e46daa512ccee54fb08028bb0e24426ccbe293ae5507eaa22b4c63dee3d41ef14df56e307e341be2a7192eac0de844d320ce053aacde822df81587000dc51d336a7f666f3315fafa27858815de65d2f8d10c311e5969d1f6c83fe6f14ef6e8087282d73cc9e587fe7d08093523758ed500b9ad070de9059b92a3d815357962c38441d043350f76bc0931225ed3ea816674f9fb04d7f43c3444f7c8f21b695d8c5828e3f51b037bd36b70ebcda367b576c57a7914679890a30df76cad037f7ddef4c8f52b6281e71307ca1d3032ed39f131b736a17b9d630b4058c73830a167a03a18a9449372fbd1053e02d63c50fbb733373419d1fe4c0a42f07de49a2a835f35569c3408e8f31e72c854cc2ca093da2eae48394c431b33373c7605cd6c821a964368a1e08932f74654dfe2dabc03aeb0892e70104902eb154d6cea72fc46d4eb0c5cca1205444b979d18a1249377422e06bd54536766fbe652892dfd153539ecc8109ebdd068874b2956d3d670d72624bbf8eda49ab4b696c39e552c0d01a199533e91d906f3e7436024ac866a2d5d566c3590ca6e8a291950c3623e5c0ec994ddddcb46bf584643c1c94dc2ff48a2013e76e2d237e2da81839d619d3755750d943c71465980883f4846212bc310bc7118248b9c962d688b7d255ea0cd0f30001ac566f70e6ff939ceb52c012a7a0000f86c5faee3a2097511a71690541b40c9d98b1584b262bb8ec44ae5b1c4cdd799240c0bf0dc48629529cb6ee8f2144238735e7510bb0a0a50dc69fa7779a64c413be96d5b2a8c88313cadc56cc54ac5e95c35fc70fa50519a17386e14d175a1e64c11a550ba90c58865235d5f8a54c7c9d36fa41fc79d4ef7649f933161c59c3d326e1ecc5d2fe0104c6c1595a1301a632d7d2b0b275be075bd3b638d4b75aa4faf4fa5bb0c53926bd6b84f161a31b3a58433fe541e594a6ae88b6c21800d3ce7bbca7531fc184de2983c6057b72901e7cce7a6e5b15d1ab0e89d085ff8b7028052e8010c91204ecfdd57f5f1b91980b575ac070c777bf813588605072f308a8d54b41ec937b98631be8b79f8f9f0be8c19d1c6aba5390046a01ce262cffd2a01be880810ebd3f31d8a2502e3891c84c04253873a6d515bfd099f701b92f043fc66cf02ac8c18da15097f37dc3aba3dbf0c80be74045e9a7f76b23b10d4d838d0129bc758c214217149ebd8c0111bd8faab0a639440eea2afe4c8bc8e84a1aab39d66104e34b1c28c03051373847cd58b4120ded8c668d3b9f5c75ebefd32777385f7707b5fa510c8c472f659311c598f7f1af2c625f76697c122f5d521b28cd4f5d1721f15210698b929c2e3d63e19fa852910129c1d9bb08374b34dfa0e41aef6a203c13e92eca0b107439f108f541a589034ae19f526d436df8d37fb11e1f5b3802a0206ae6a6dfc53c689d097ac231f0de6ca69319a2655af516d0e09484f3e69f8fc66d7d92009ff4c14fd6efcff073e5aaa4e85bd43a8240572128e5394780771f4d9813ad7b118daec0eaa6dcbd9c8646092c93662315b9f67e8dfee567c10e98f10a7965b8fe3c86566e51ed10a8943e7ad378a4650b9bfed0c5e5c46b4222e91cc5443905a5da772470decdf56c217b305d6ee081516bdd5b712065124fffbfe92581c86de45fa08139b8d16b77bcc9e24bc454b4949858e4e34383c29c4b524a0b8222914cf97139cc4c6f980be2d4b1656052e44bd3364614986ca068039fad6ad98a1e48a61128c18eb23aafb453583605770bb720528ce4e42277379679ddc477cc6cc3d4554793790dc049426f123c72ec3aeaa056d5599101b0a1264db8672afb0403a8599866940ff8710a77fd508b64418543803ad5d99d0a489d837fe8faa4203fede75a14c0c97213bbdb84a86056296ee2404b34f7b47d667dc22780ce5f68bee87b02beafaae63fc59e88b773b33957dbde16d4a11ea8d6e2904a3029edc2bb5f8a4222f0417a631877f46f0381ba6af1a4b9d95deed439af3dad34763c909f3e9bcdc96ce030b96d4007396c6b401cfb7a6b8a3ff8b6eb06e033589a41871514b05e5249858e44cdbeeed9ef670ccd63b7efed380f87300d4868bb84241bd3f4fcab63203afbd532815bcfc750521c674747b22754004791ecfda17e2ea3978301d844e4b13908666266fde96e3c3093f4f22213deb83c25a66b5cadadc789e2047f3681f7a48de9dc868570c2db32cbbb8ed800252d042ad0908a4344fb4f7434045f6dbc3e2cf27849f56631afef5f6a86e3124e201609a53c17249cf213a0eba32ea81eee69afe0173dac961d83ed11f3686443aedf722d44bf56396edbe83f7317100fe483f08ff60a198bed70f60c8b621493a0a00bcd0c5c80eec52d0744eaf2be9c05e5778b4b7c7a3f8b4ae63722bc4a79000cb81d64a4bc8af56ea43bd2f7251c7086365d1cf96f71fe2ed58f45a21d9ff8c4be5a9ebd4da7ec7e37bbdfcf50d8079dff98db103bf13188ddc3ec0ac4d9193506be4d702714a0c527200b4a15e83859a2bb3f39bce25baad2a852d7499880adc5897bdc616a716f393e04dc0a1b66ddc24f9ac7466ce0bde533fec383125752502e015083ed418153b98bbf2516c73124a450de8ba2ddf806cbf4ee530b6a5c755a6ef673bd3e3a494cdf1b7bb73f46b46b5c0275a41dd04b0c0a4e212d084c3b989be20145a9e3c64fd4d3183005b0b5fa7a46dca30cc48395a40336081ae302ab93d8265de21419d8cdbf64687bef6ea7d938952bbfe55d8f3eec29fff2585b40799cf9bc9fe3e320b28b35cb63020a40824ca74df3d4972fdf5206437a34edeefc78df50a611ee501f196a454c99700196c30ee60b516652b26d2fa6eb494c91fa674a71b11c7ba30e67957e6e61b1d878aae1998b120cfdec81af6eb7d5c67dde91ceb25e23c123cf1a290d914a15535c988f90e605fc03f5b70272aaef3ca0d098af0652eed04e9242bcf3fbfada29e27ade638fa5f72dbdcc69758d0d14e44663fab2eefc48e093fbb5e14833efced9fc541ad5e174132926851c9decb5ffd62690280ede29ec320bdc487bb1bd0dc89ce8bb34daa69af3a2a6e39ce2f7e90182bd6854d30e3762ca35e9d454e99f803d807a86b3f673996d28ea500d88c24231fe4f112c121926548af0faa374b565605f8799460cffa588fa8d6bb3d531d36584eb31a02bf77b9fa01b3ac2eceead98aa40e3bc6c424c652763ba399b79e86fbf10feb6643bc8bd08074b17ab1aa8c79a9a542b639905e33290251e6a4e1ce7dffa4a4485796c569f86eedea2bc190c60da9086ad938379284fdf25203e0324d3a1cc1544265742bda2ebccf6fa7f7295d0b531deb2ab7aab83c4d03ec8c3c3c9d5384f29fb91bb7916076fff3c9415f14ae26a3515390ce2f2b69c1212f8aab5d4b368b0c25361c9f8e3be44e3339005c774b53db3b6565344a9aa1baa9ae4d3183c408bed04c20c27773e35135b7691dd36acd016efe87e06ad0de310d42b15f1195fa55becdbe5533f4a3928bb4c3abb720e6f7498a7288fb652e2c934393358bb9d1428ecb4067b727dd19149cc60719d8e866809bfaf69237abe2d28837565add2942cbad508a0558152598ebeea7ffc77c2a7f1330eb0b8d2b76d3fa1f57007f9a5d32915a9f3d4f7b229594170f9f387912ba30911a856d33b9fb38a389991af8008c0294f46e3b60a452bebd818d8b14b2b7a162a87ccb038bdd233d127aec24ed76f319255c58ebbf2d3a2eeade9e8bb4bae27fc6cc2f55933eaddc2f939fa55fc9214b324984e1488704a1877c2f3d20aaa1880a38bbe3c2db12d843d895dcbb4f7de9b8bd94900b9403d0968e3d9b17df36dcc0df6ff7e0f7fdcc0531b3f248e90ba4fbbd7314d4e41be7035eb2d24607c5eb08b55ab25557c21f1fb9fcb73f3e0e6ce2f6b48b50089f9c0658a478234998ea96e8a7694d0e33dfad1a41f51d28ae4df01769dae9edf274e129fb8d4de036b7e851388aa40fbc2f02a4e17f43d3d61a88bd76a7e60cddbe436e47f09dcaaa3a1fe12ec3ee0df9492e4f55cd00687f1d8148c20657b7f44c9ffd63b425ba1495cd275b1c16f44189a3f82a1631b54e19f16231bb73d279e2762282376347dc1f2e8d5ec735adec8d49efaf02f73f4eca433cc9248b40c5637dbd4e7d8af6dbfdad352eb934483cdc3b6bbd0e8487d36e9cd6f2d831ab018aa3e9dba04167ca62aef403ca7b6956d9d9645e9cad49b0cb3bbe9a2aeb2b7aa46a1e2c9b3bac2330b62fc310634d15d8a785e7d6497454e3c8b7e343beb7e4dd632d5eda37cccdb1762a207771a76e50f8237bb160ac9f9856c5966b96e2fd883063034e9e59df6d432a94219629e4e82f4a88815f3913651f986e1fd78b00dae4e22f44f91985a99643846d01febf878c63a9dc8f484390b03db74e57ed8285bfadeaba63ca4e372cd1056e963c30fe77d62aeed05d98b405a0f84b1806f4ff7a5ff150ef6014b88fbd2574b7e4dce41b4b46a2e23b8a1c2b9a265107b4a3f0ba1c5dad06d029e1d1c25ecbb9ab0af594e2648c0c4b41fc0a6fecab3bc3f6a9a899f41ac0fb618f119b627fdbb41b61db75ef4a733730ac884ab21a5a0229d86848e9c54536938cf6ff5f96b394b2d456d87446515b8ca344986c5f68665c34f1a81c8b672de6c1558cc6aab7483349bffe42a88166a2a1b46f7987b081113bfdb60ce64baf997d438bbd0eb592a590df4387f5053997518d2966336011aff75a5fd084304eb01b3693fb49571d4bb574be0d6621119b729cbd5d2b336e1d1678fd081796f571b4311844be7448fda8ba8d62adab3483e5fb3beac9c66df9f161d9362cf4eeb63137a893128f68c3d162954ca630dc8a03ddc6037e549f5ddddbc92dbfbc15a0945aad98511dd3595cf02dcccc1f0f3a26f1e2a23837c20b509076f3f86f9a4f7be7b30ced0537bd794dcb69877500d6cdb7cd685b7ff6e03229a4a01bb7afa313e63b0a2a82b3769f601fe5223be96a9762550c4158918cc01aa291fb8c428cfed6b6fb225c01c0b172bd9b0e1f1057e88290f60de6c70675cf45dc75dc2e3c27635bd9e7949a697a0bcb280472b1f2091c74f916ae11ff09cf2cc7b065074c89a364c684302faf0f53f726587b367d2096adbec40a308c1aed0749e83adec51780de471e9483673d04b10cfc947dfa4918663dd01da199590bf0f75cdd4e3c8e46f2db2ff8c7865dd5a64d5f0487941187a6155865eed1bfa59ad7316dd53de0454aacc87e0f80252708b56bbe82b68caa2f667e612ac5a88023a83e05924b9c3675dbfcf0a0de3e6db741c953d7f6e75e7cb0683f62fbc5edd48f17e2c3125f81070f07e6715d698748c56a9a7f62063cde5c037fa09910507983251b0b872a2c0f951e25b9b63d5cc9da43e7fbb4fa7c821f2543c6fcdf35b9bca00ac4397fa3c0a20fb3867ca2c424a6a548f34bf26c93056a971efd123413f0c62909570734319e6102a08b3f5e465f0f43c3284c08522e17564a8079048ed52c46edc34e6fc1ccfe7e643ff2a5c7f4c9320731381706fa163ac2ab70315a83f85f7655155e5966934cc9844ee3fec24b6a0c580a6a2de8a93da25d7e935c9360c9544984916f7b30eabc591ec64afd70cc8c123a9db6ba42c412ec47c8ffd9b6f3ee773e0703bde744c0e21f5cc17ab239de273e16b498a41c04b6b31d25b055924fb910f5b03920ce55f65d81831326503e3ec0ae70c0d46ed81446a13388c8db9723deca5c621a06b626f60c73d13beaee7aec8eb0c91743e8fb44b0413d10552efd26babe53a98454964fde3c4f53bfab3a215d889be0313c00e782688643c00414e98fc390a658f2683a1aa578810b0dc54ddf12641c2c451f7929af4bdd1cb9306455c04db0466badb0cd44420e464d74e5e58d57ec91c407ab36bf2b8299dd86cce2b7aa4e52df722feb6893eeb91f894a715d8bd5fd8233544a620a97245bb05c788cb274ef50b9f0359d2ada13d9a9659f26a21cdfd4681e927ec37482f01300bc6ddcf29dd6f0f2717634b00c704eb28feda53141ac20ff95ab470bda4d6cc363ac60e0fef5a3ffcfd4313020829d30e8b1e025d99a92ca66ba3f335f9ab64e2b29850c900bdb91aaeff72008483b135a62682c2fb912164fdd05d6be069910794cdf8dd2e0f143ee0d1645cfe0a2eeda34ad7efe6ea8bfc616ea4b1000afca435c2f00dab729c2712ae56c1c00afeda12dd9f1bb2b247b6c3b6e2f56a84ec3fc790a00f81b5154bcda5095159c2e577a9f7707621c643ee9cb0fdc49732f18a21820ae001a380cb464c28e2a73c2644f8f799dee89d803e278f11572216dfb5aebf08d70e7a757950899539d8a05ae5ae3eba32d72a17e0743f318e0fd72a9cfc1403f89481024f48996657219cb40a158dc5792d1cdafa392dd39828f6d51bc9eaac680f502cf47eac9145da9b9953274c09e664eed0cdcf1a9f9d380213b877dd110077a1293878224dc8d0daef4dd91409721ce312d5174e922604d21dc4a6aea68025587c3d84e8a9147d112efd369c4eb65adac559916a7620b523614e8b319505517c9d2db944d011866b243220a53d274ab3696020ebfa57256922c0614ffca7992f93c78a8b41a5981826fc0ba917ea3b6f5d5a4f0e3d7a2bc5546b5930d5c7fa4b7173a853f1e7f509163821348e52fa8052396179fafd54ac69746bb67ed00b9feccf8e5a25568b45355e5620624e6d8b901ad57cfcd235cb6ff3f67d2429a6a9ca5ad863b68d1a3549f6a27bf4eaa95c37bcc79cde2f095704330947e13f0539f0123d6536edaa91a1e70eb8656dc223fb79651f21728569fc4b9929a03423d3605231ab5bda09ca12db0c817ab334ba313efc2e8c9203c50888a7f0796cf3294d95a2863ab513a81cc1f54a3d4b345892d605b3acd6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
