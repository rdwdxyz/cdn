<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18fcf69fcefa685b895676e2e94fdc93665c361f60ecc73202f648418bb1a523b4196b5144d848ddcc4085ce28694198985189edea6e91cd026fd3c04a04b3ba3cf46aea4ed7da9020529d1e436ab917558d0464d8eb25297ba87283ed8c02ee7ae3f71442b36f8e3fb56fc6348a9487f86153f678e3c1d92d1c76d132db9ef1c9db0dc290a3b0e41ac3ba8a80f8a87c979ba9c57397c289fe03c81a71dcc5a23d541d5314fddfe82e0e89c15b2be899415671cca015dbc759b91bca1da3f8506263536edee6ce78f818b414a0abc6d723aa82af9cc98981ce32c72e7acf135f926b93c47d183a04bb0885cdd8caba05f590e7e6eca5e9a1d5e952a282253ca0d6123df70f4fc3219ec601955e76f649d60884e058a383769df0dd0876461c1fcbe7b0b3e355fe1f79ba1fa371541bdec0377952d08b312a371ea57652206aeca099c44c0f47ecbb986dbae53d77b2b295868e62ea5783f25bd8962605b83e9067ade3756554cb906da160d4eeaf47e462ad1bd3c7cad5ec91284a01a84a6f2ea4d72ce3529158f5263d009f9ee0954d3f9fc20bec4b02496f841786ff8929cb7d981fe6c117594662fd123a974baa523fa3a0e70354b69ce2435f84868a700fadc260ad5e0612f4802fab4ca7135a079ab33e9755ffa3f970ea794e9f5aed365467b0c536eac29516984a33199864728ed198a1f83360a5432f384982134f87c71ebd9b6f70a923f4c5314496e998255b3bcd18e74b0bcf22c1301c97e3edc2feedcaf40b8e81c1d9f534e3a7f75053eabf779ab43b62d4f36ba27ee4f746c8099889931ec1385253d50a3402fd0f2bf2f3ea6a1e75947ba58f45c8170771ebff2dd55c2b1f2be86d674c6272b0b3f1f0b2e72d4bd1378a2093844a93eb86fcf72927234000235571ad642cb6dd7d5be4cf2d6a5f640bfc1c3c9cba1acff6d79faa65279c375b552427b26f68deef4ddb83a30b0d4a8878aee93e361cde16c24737d5f37049c8c8ab3be312bf62bbaf837e693811384e9fbfd22eed836222d4ace63b8161321cdd8dff337d1ca08e2566c867334723b4ccc7aabd343acbd5b399b57685297f64881868118af02aa9290536dc928e4a5305fc0fd751c136f8e7e24aeb4774afc1d288b303844e98e6ca7dd8cbb4a810a36be343e32f51d8f6ffe4b1f7d3adbb63e89938e77138e6cfe9f75b699c2209576ef8117493e0386492d6a43d6a4f53c526b336299b826670c7e4c64e327f217211e8586b866ef6b9894d5bde72cb0aabdbed25bbdc3d31488b2b964251d9581f35a5c1ab8ab9d47d24919a7647ebe4768c80ad7df159e7ca69d011a2c43633c18f68343e20a51ae8c45146b432d2db66eef7834f1170b7406284a4c4906dea592cd661feff4e466cb30f86fd5fd38fe8d1237e0ba867d407b31f10e6c34c4512e304ba462e008483b4c842ed0acbf9d15916b9513410820fb99a7d0d6235814910756f4f19d492f6e883afc0bd0aceb2d6c829dc514fb1ae12574d6b929f2f5ca19ab6b1e0251e2510745504fec9c9f8f1e506e2797a3039c9798a19ab78ac2c1b04918d0cacac245b1ee1f0a29d20ceed3cd8b93d490457a5d94fb1559c628823d4fa225973bb1931c6dfff93b77990ccfa30042a424103abac083d029ee85423a90837b6adc2c493c3fdddab56d56510320b2f413bd47e16db0bc838e4306eceecc8c85615465fcbf1e4b666ce7b6441048c6b880f4f6427268c92b26019c3472f55a02001a105df7daaa7ddba6eee1797cfcc5ae1975b136e22651f6b52ab224b5b594adfed736a3533ba8985c862e80a6b474649ffcffb5721a9ee7c89d34edef06b1d76ad2f1b092029c35d38ec606d7af2d3c75aac4bbc1de8fa4ea50968a065f97c976fbeae0be3845a2728fdec660a346a76a353a7f816025395199b7cb4883433a4626e0abb3f07f60e5f587fc4898d829e3bf8e3fe84af2dfe9cfee9635ada1a8e842444171f0eec82368b97825eb3ddf09b69b42566ffdb1cf1dd85e36c077f193d68209b8392b640942e92155e804ce4ca3df90e5efd1555f0f25b489f33f1452c863ecfadb1e44ec339591357cfd42e55f894d27cc06785a19fbf6d140a4f1c3523494a24e60c3a1c605f0ae59211e01aa5a418945c63e0ee2c781e88a03c120bd8d4edb4bb6ea556df8e1511d8c48b016802464f3568798a44560c8cfacc806f1d075a511f12bca1bcd1b2b85e7012a8b575c06ccd667e6d85123d56f121f5f543c5ca94f2156bafe931d6cee78f87a1e302bd0d4691daf6cb79bb383d14dea70402c6931278fb822d3bb81fd80f67fe7975d79282fa0a27b3924627948754832d8e53cf6e1b7c4262c9f685e7667034050818639314abb42f5eb16ed2922c8a1529caaaa6dc2b3dacf6122d78629f8e5d525944c82653142b44131adb2ed6f9eef5711fd4053fbdda9e3b5df0ee782985ad73bf12662e334be2f324b59fd0756f91fa451aa8c7f56a4ea94c38c38b737601b0fe1036b3fcad026d1d06fd1de67604767b28edd2a53c171fe6236731761d408a0e29eacb4664babd8c658dc0a4f406ca82549a32013fa6f66f350eda6ee85159eb1c48db917d9075f4e292f2efaba9b39cf8e380a90528c48e4c18d7873836060a37987254e21a0ad3f7b583252a112a0cf50e988c7d44b55d25a542b86e4003c6cca32725d477372357a658f0d8ee6ed2f39e3a9fd4a4e311566447c97b54a1719a255b3fe4a3238c72da1157e70a16ecf66eee58ad6a17664e5f9107747de0465f8ae2f9f3a13f253d93c140e50771648fd774810d0def6f68818d452ea34e58cada48e97301df6541626c21b06d30c0c0cdaf27d018e8a95187b614d9661580e7aea42a0b3355883c7f8aa7167cfd4c3e8273e86935e1123b1d12e1ee78e36361d608c3a2b035394f916140dbd713dfb50872247a824cfa5b72e0f1c7871c1547c9c2ba6efd6d77075af7c90bd08723d45e58248e030b214287602e370c2bb3f41e36c406c4e3796a8c2f292bdd2057972c63ccf58bc0f443521eef2fb024d52b9e41e7bdd4fb2b5b0013c026d500b55d709f5cea2533d301eb1ecdc3be23b090af4b4e0323c553ecbf6212c276c1b7253c30d73698686016f3c40c6cbdf8d080369c9a4fbff6b6b2e3f512c3c2dced1addb90feeb159c261dcf4beacbaec4d5d421401ce21d9bc6a63dee87a8fa078b70caf94bb00f9b91bd9fb4bc0742eb3bf2c5e6f4527f3b4af7d7afac950bc9ca75b1e5f4e4036077aabaeafcb4210e7b2569d2cfa63431a1ac516d83f6b402d62d3fb3e7490d581292b63a966fe6efa450b17968dd8c4e83a68f4f604ee8d1d55623eb0d57c53536d5e6a8deab18a9f331feb25df662ddd4640f15cb30647447b9deda8118a2a2009af2c761f03d9dabcf8435267d573e759dd1a1aa05f34d4ab5167cf31c9086d4140b7d1d1b0843f5e9015410827a4e4bc348e32fd32700e1436d02fafb56b9b5473a75c8a57f55677dcf90b32f7fcfe6f3966914f9461f99e28fef8f4e91283d8c6af42519a124cc9f63a30e9e917f9bcb05b28dec9943353fcb7816ae0bf51723d1c3ee8f829389216bdf0226a7a9fe1786eb8381bbbce8b7e1731d9351bd4a9cd2e989ad0cab67e5ae2b4db7cbafe9026db48e7fdb8b6bf91190cbf79e8640e5d10d4664290ae2f11e5fd98eb2938f4f97ef92406c7de301ea0f7cc8ad48fca5d369be79f749e97b7c407d10c85acb914fbe9d2ae24098b5ea7295d3513288f68a04727847a50f04ef0449009c6a413acfe3687a11b4dbcbfc174da4122000e0281978da14e1a3e6bfcce846697441863d209e31bf28b2b1120b626a390c0dc9531835366cd9b6834a6df0101f447ce90a3f9c22f10aacc542831617b526b8414f9416973d0131f7d45607c7469c0b3dd52289c678a111fac206d5b903d30ec69af5f5a23a6d400190e581ae56863edbf29942d22e134de4cffe30ca289f103ed0642eb46756a7111eda7fa29c20800ca3d306550347297027772fced48d93d8212d31c9c26eac6188929225857a029f39375db23d64ee2a09a5fae3723dc65b7f27b62298bc279dc54b465f2a4d74017d8c4291822f0ce230aefe4d7ed2b6f46fbfed7bfdf6ea45d5f5875574b1bd5fec44b4ecf6fedf131985b62400f30d18e42996ae74cffa16e96169f4352b332db110b9a5dc4027b94ef783a15562117ad6a595ccae8aa42bb0a4813c470687806206699712454c33f8bcde055db1d2d7313e1dde53be1a695c6dc0f3505204a180cc2c3217c9f69a78e225124203da15d57fb0cc70c83631a019559f1c15c25972e7f8285267b2526b3e76cd5d5c963dc75192b26e3646d8bd311612d4c3e20f3feadaf5e82642722569e451e659e4344bf7ee31ad51cc52438b91d0a47c7f2de1f6987e648aa3f6818ec65fb9a8f70bdad20784f461657e6de874aab9266bc107b9d2a33d03b4501795a970b03a8ed0742c48c121e094eb5db91327ad0f873f7ffa9582e843437f6f240539c2649f9c0b36da94e1f1e6c75062c460863633ee1561d8c1e049c05c8c11775886eec0c0eff20c058ff5e1d86c246117939f1d8cac5047e530de0c8a809be44372e76e82f990f25764ef71192b2976d5884373c2fd6d9e117ef262ebe44990131fe6b5a2def8f256ce97f51901a3f16194220d5cc16fea8519cd829c062f7aa8c2c91fe74cb1b068f6a2fd72edd346d74608edd74a9f72054070b423775f6f3ecfc82f20ad9f4f3fdcb91ebaa820fd7481db91c5ab0d24d7111c7aabe324eb63a5d44611ac5cbe728c9a9006a205f0af8b692121816e89ad8b1e93e6b11ccf8863c302493ce01fd207bc8ca024c5e5204889d260b4cd4fbdb1731ef39aa48afaf1ec83b37288c64d182a29fc7d016144a13ac984acdf1e1cd9c9ba97769fbcd600cf46843e7b982e27ff231974fa60e4d1bd3a19af059eecb0674c43f3a80aaae238442b8255aefd784fbc5db25cadd47cb46b65112cf701971d6ad4c1650b988aaa3b7a39c35efc44135e541d375e5d2422d7aae8480c5aa952fb5dd87ecef80b48db266b905b9ee0f975d722185db501f2c0b1502e1b8d0f25c8e956d2d0703201df9768fa7202d0db3bfdab61cbe256c74f67d577be3d4a42c5285b08514d416c7688b7aed9bb667e64cb45c43d9f18b024610e5a76de21740002947220675d476d71246060233901a21880e8c03bbdaf47b92d1b8cb2ed24d31329894438772785766db3f0ca42f4ff4784da2afc9b3a351946b2749eb48f69a11cec5c956ca7cde23c40dd045a3c448f136d2f0c7d568526ef98ff4e9b18e211f2230c9f9f4294338d51ab169f1262a1cdcf8b7206419e75b8d0e887f37fbe825314dde32647974218827c5831705d0a71de7315a672739941554831fa132cffa7501b784947accc476cacefc3dd7b066e73e0e924a87933d5eccad18d900eaa70c9b0081119ada24fb71972fd93cff2f1e1df76e6bf8188caed312004fdbe6e8c70457c6e90fd29c4830ed6524482dcf925a75ecbbe061ad5835595bfe15ba7bbd9bca8d08358b8a3d5bc193ed1445a5658a6fd90e5f3adcdd93c5e4c26e2b3e221b0a74aee9377d22940b073dacae92109bdedcb37706d1d56713accfca49801cc6caf602a918c7a6d50e978b44d743879015696d73aa93663a730312db38671b5aab287c1092e9252753a5790f225624f115967c6b7c03cee9b70ac07c3225b1f2e07d765113479ec0ca6511afe8a4e78deb23d428ac9c4e40548bef4f6d26a308e1ef502d128156f91c780d772c0c8ec2c3535d33088295af512d5553b74b0ce899840809ade9cc9d693ca33462c9d0debf5e5bb0dee506f8adc3a29d34f959726271dce7399384e5fe70d98fcea1728155f667a2c2725a62d3ae0fcc3f51d14e5a9c7662a719a14e09726bbbc062cd89b7d6d8903e2812e9c5903e780be2704928eb298ed215cc163eb1b5bbfbbeab1093a9bbadd7955177ac25774bb2f2514d2a79941fa0ce2587a3977158e41d74a505e3911ffc6c1e85397c2e198349c086b49024a74a895da4db5e915f508e50fb9010ef463a6bb3acd6506e67edb1a04dfb58199df56b4fe0cd729c6ae5dcee4e7fded7a800a754500e112277cb68450b619648abf6090b7ff16521a6d4afc29b876414aebab0a627e294a8c2300df3ca7be35b2de376c466dc7ae939b9a58ec48c7a5c6ab6e50bffd5bc3eb9a90846189deb8d88e0c8e9a3518a032bf7c6ea59fc0238f470b457f344096447e4e401d216e7d636196cd1b0350cdefe66767ff4e0e4ae735220b8898b0d7787df3650c98de70981f0a764de9fa800ed6d196dcb6fadf03583d59ba1f36ee4291e9181a4a231bb860ce5bfe9c5d097bdcabed25b9e80a63c414b6c483ddb0bb9ccb1ee86f58d43450785007875aada89be1a00625830c3f923c3db267fee93ad1372f1b981a44e11559da3ea9dfacf35ea5f98765d7720fb98f7268abb072468d95b6f03670b26d5166e83be6c3e752f2ab28650ee99867ea1d5c8f58eba478b253acd202fc02890c31798c32b801c5ae5b4ab07a9577b6d536016438abde13ea56103554bd20a92a84c3e39ee61a3ddf6a83974917b72dabbec09b66e5474aa8621078894f1ba2a7832c9fada93c429ed496f6be5205e783c5afc180346be6454a7e4dc982384a9a4ac1217ade8373d3dab337cc18e9e7f2145a6cb2dd29b1623ae6501747857d62aa6eb78d83d03d69f5ef6966a88a1ea6766fc9b53617e819332926f0c6c0ee08e07f3f8adc310decb9cb0fd7ccd3f4bfa68359c0d7896787d3d447c42b75920bcf479a04afd2a5f7ea1fb470398ef47c700cd0e5f45c2deab6ec2dfa6e1cac8cd9ee2dfc53f61e3daf59696b3c987fb38c4e77835ab359369cddbb4250e1d520824e09bdc2ea7a99dc0925f2a795e350c3784d4558eceb84ceea18caa9a148a78aa0d087f80bc5d9423d5632d7459af8c549b8f1f383e96f6e5586969962afa97310e2920b171491069990eebc32b11ad6141feb515cbeab2c915bd2dc755878c62b3bafa5b5338efe234ce193caaaf4f0382068048571070fa14763d33f32aac596200c8fcdf7aefba93e155e6832eabaa7bc2799166e15d933de7f9422727a45240a396375885c61a87f63d92101a52c88dd1807a8f7f4151d8dd7e8d2202079865b8d91ec62abf1c01a147e7cd47259ac19447e4e8b56cd2bfd7191c1f2cc5c97c59c755f2ab48206f92d505f91b722ba88b32706b9b7e6520aedfa84378d08f892671669466db63c731bdb873b135d3c75439ccb70c9b3b8ca7c97d6caf53e83f14f7af09fc7e57011d6990213b61d6c2c363cb87cf8d0a5d39c0fc48a1c1ba1d829e2fa647b4e6785b77ce8c7b6fc9b5cbda2d7aac64c35fb2882a8222cdc31b889a2876446d8e9be68f7532dda81ba672219ab496a3afd30663a6cb3fe5c27b3523e9d072b51d3efe85130037e66371ecd57c4b5069c805581d43755a8345187e25bd06a172928053330ed25013e5b8eb848b6f00437d237478136b1a6c09514245f5546a21b4f6f7d23686e26005e961d2490158d9488ff966ce01fbb477d18a66f3e4a09090499e977a3dced3735ebf4e93c656fe2c1badcd6a3202c74fea8ab0443eb7894454a31e946917a316389c62c426986e73e5dac074d69c906ada45f1cc20a002b60a3803eda8bcb552e907b1c1125ceac3fb9cb02382f8ae6a48dbf2d467546bcb3d8ebd45313d4375220df86aeb3e407570a4e6d0d64429786ab61051614e5563f6d6e4784a52254d103daf1dca1e6e6f5306b90301ddf6deeee944c0521c15466929dbf8c2e0f119e5b4ed55ff4b33c9e242e1b0e633d39a29309f20c610f751e1eaa0bd7a2dd3bd919fd63f29a0b294d74e3cb633598b6be3030db7586b58372ab73df364005da99b35a1ae4a1c6fcb8f8ba3c934c9492841b333e9ecb45b21661f31ee430b12007fc656b2c3ac7a7f3129c6ae3db2bb5570fbe420dfa39317c8a8e0a84da28d6b844086b35582ee4a145bd4d19dd192d9ef1b007c6a97c3e37d2959856d284dc77e4524e4de9352b773be83031dbda5958010e007e8c6dae640b5b8957a642b13de1169a23c9847e871f3cb5e9d2f6d3182ea9eedeb54cef3fbf3aaba5055c59ac5e21d6d6e18b4b082d7a66273e3fc23fa99e82107aa1f4d3c308372c937a27ff539c881f98dc1b82bd8b013ad60f5bdfb97968943533361f390d49cf9996f03699812220d73f44acd24438b66861179f23f55102bc826ddaeab0feb3ddb382a2572e83982595264c4213ef737cbb330963f8554a12065ec7425845bb62f8d84fdd0cac9f26cd910fd48adcbada9d5f6ba7ece38f97dacfcff89ec34627cdd1b709fd02d129c9bb32d50f804219104f4c2fca435181ffd1c00ae8607250eecd4f01ace465d52685c977d2bb37c236e15e92ad34462a48e6ca07a4ea3baacc082d81de11742729083067f6fe86969a0fb4f878504ad254932482bf4c2fbc85c1a9de313aec0e53230a25d40635cc711a8068b95cd3d84eecdef291275d1e7f7f3c297138f3009b7ea1cb254d8d0f4a9d81e61a99f695862c921f8b0923c7f6ab465ce47c32cf118a6c09c40e02989204af66be4b35bcb883d0182dc7770082c25b259153f80494c56326162343ea4505af00ae67d9ad2d861795a84e0b9691047bb352af3f20e68a7a286769cef65ec2d4dd00acb9afe80ff16bf8f1b8ce4caa55604dc25e9c5ba88cae834da9f9d7943d655a3053900ff336f15f33e99f56351be90584522fb23d591ceff08c281e528006b50d89821738c10a33096cbb181d2afe81739d254ca243c719b49c3b2b13eab6b333612cb0052f1e5f91422b8d3d5eaeeeea20caf1ee755dd1b8ea6ddbeebb7f36639ca3d6e2a503ddec50d2d74ebb9252d53b3605d90e4dfd7557a24bdd4b9021ae4ced08675dbe9ee07bb8943b6c4ac8b8d38312838edd50753e649ff91550b700de8a08ab074e827f0a77094e762b0a3f0e5cab74a3d80aa876910ea4d666143443a9c4c3a6c19d00be9a819bfe6c8a4015936251b3ed1fccaae81a192e8b439287715af05ea71c800c4b20cedcb6c70566b76326e19736b08d47f9b4c602d746c94f71b9a6b55627679ac4fe5bae1cb61fbd7fb9cb5b0f0458a3709f1bc8fc25b52e353f9bf5ad83d1ba882a94eecc16a11d7da9472818736ede08b8b416ad705a1f56cf0a61c844a3f4c4a2e895323e3d8153eb643f79582c1b296d0265202557775611110a6ed1c1b8efb23804830ac0a0cec410b86ec0e8e81e4e2eb93b210dcdd0794127fe1278848258cb2204a731acc134e2764ee82bb246ef1309756bc3c55d683b22eb52067d27a1562f43a16aaa3981b7b6b908680f389c85b40f8fad3604ddfe2a756d7579c47a670f00da1ff0059f6a3148e43d7bcbfd69a2e93b5676957725ff56bf4d14dea6df855d97c7d3c5d74120fea298099c42146f8dfd38eea88538203d258d0e5434540fbccbff409f3d3fefd0d607de883d6acb3bad16bd08be7892c4e93434446f99430cece7a906dbe3ffc7fd0b8f01ef5619b862be0b9e0b9e8567ea430330c932a9f86b75ad2e4df531a933e481c68efdc0f53c51ad80e9141448510595626edf02b08f6bf97c3f0c7609c44cca5b41582531276a4345c933c732b854df4d28580a9943e92eb5391e48182b63a5eb0b7c9ec55d239d7fc4422899b9bd71db885aa6d4730ae92baa5f2e220e06dfc174527c8191e30143d3eb13f4423d85efb839b88abb6879fffacca022fc3289f0561f138a4999e0d267f20be3793db8af7060da6f9d5688dbeffe39d7779ab45833c9a140854d9051f6f59f84429358898e8c042ffc5465ae9e6c43d05c7e6eac0bb955bbfdd1f7b0cb5f735942dbb80bd9ca867d648693a1cf61b402c9b629faacb5c494f2002cc60d688f4d9f11d2b07425a7929e5450431a2d06710cb7e50f5fa7822fbf1acb4b4945d072a573738669ed86107ba8a044e6385a3a5954614d0c654c7065fab0b5a0407683d4e4fc1bf53d8db9a850220ffbd9ab11955da29181abb5e5a1170109c7eca0a247f6679db4ee78cf3533d6b39f6431a32749ba65a7a64fb073a9ec8686b4426ddbd7018dfc25bf16948e18bed05f8e99040a75c8df48880d825309b25ac23aa52b8e5968c578e34b0dd6d81e5fcd66b03649fdf6a197d6abe99ccdb8a3de87e7fdb29e81176fd6f79c2dbfc14c69d1f87247a49c4f184300f53a1efd4bf2f346d2ecdc4f33b060df2849a3c97605f3f55c2bda9860ddbf9d464aa568e250fd2873f77be804f70fd2d8cd0efdf8fc9f946c4946fc7f38aa35e232bc08c7b6fb369221708b97424f14fb429c0fd7e261d2a874b81d24875a8662cb828ba80a4293275b107891f45a3aaa2f70331d1e7e9c5ade8ec2ac3a025f91972ba0b5afebab2e52eed450057671203d768116a7775a140496f1d49ad2eb3cef59a2bcdc7f625ce1891e40dd127c30e7a4b2b2a0aa4accb3e024e0e8ae2108351d26236b4260cee680e41bf2e8b4f5ff17a3c814019859cad37ebc7ff4bb52390c39b2534c5874cdfe66dcefaf1225bed26db3ba2bad7689635d30d0b13d7039cc869d349e90976039506a36be109201244dc63a4ca849028c16ee0eeda39a384919f9b70424a33a40831025257fdbfdc56f9ba3e1256fb51420087c998e77048219e53d995ce0ea6465b29ca7c0358b6a14c65216e160c305782f60af05010bc64d99728d16b4a2deb55d8e04e49fc343eca8eab474f89e35bfb17600d46fd2c95dc2ebdcdeefaf650bec5819f0386b9f2b0cfc86353e2b725d443a7a7b5ae597295119bdd650940107ca4d547fe30a9406be32ca6bb41928dfe7c23cc9deebecdee9a6f3ff8ef64d8fd52c792f2ae5cfd8672c700c5ac672c4f0586afe1594657c78a2c82e2e8ddc9a0eac04095263a8b81ad8acdc4eb2748062041fa022a28d7fc54550eee46def9d81e1b8bc7419128d65b35c0255f8978816e0ff3817a8e48d0f6aeeb35f6b0d2dd91410f1d7f2e75176ef85e3aec406ce020136172e0b42b0b162af05b78fa26876f1b760956c515446cefd68660e28a83104fa58fd39428a5ee5342d0129160e35ecc89b74d1574f8ef255998120042efd5d87e79c182343fbb84b75e2dc5e547cc9b25c34f5c8d2a4d7c29b96002067f07d9635915a3fd24c34a37a24f9280650d68682735f6bda299084f6242a733ae28069601b021eb930fffb44ec8b6fd473a586644a84bc7def801f07e2489bf4df5d506283cdac25c7d522a301aa6c18b3d971eaf014178667df7efb27469f63b95495a0e7724f1a0358ec9c992bbe32b3777dcda70401da13d4a7223f8a4a7ff0ab0aa2b2693c00d0c3ef59a06093ff8102177f2c30ccfb20012d5e09f7c3ccea7784fb4a46ec1568453136ad92c04b13a6ceb0620a4c966a424afce918d69c29bb4a78f1f8a3b9368a710e36e04b88e9b06bed33c160bf4e3f222be6b8ba7a41c0ba91178838f52dab9b4dc2901445485851e5ba11bbc388f859d422cbdafca7b26b60b3c8d14f3c0d024a95feff6509e38a8ba5323fc7be292ad29de291394ac2139038dbc3957ab9e49c3ec109160beeb001a40a05856177ba9d6559bfbddca755eac289577c98620e5df86691c03deb4f3da8bf8b3db57b59f8b4e09bc29260a6aa038988d7f37797577c9fd5ba508cf552bc7b322804bbab81c0b42901cba19b407e161ccfde42c58fb2acc15de0f9e9988d1b1bd5b9e759fff72026f5f10492e72634df03c86a60459978413f0c4d28cd574f944c3a4b981d805830bf38e5487ecbd62c3a8e77fad505d0070d7f04745068df0a1672f24e5108d25cca6bf19788ec9e6432e327f4bfaf75aad5b63b66ca386c5409f2b29f6b06f7828a514aa8507f6fc045f1b749522b31063c086430bca9f96a272f1e0a421e5a995dc1acaa7e8c9b8953883d29cb16b2b9147f40daeb448d915c75cdef4b223d955e85d585273977a881717ca4dc92c9a2a51ab2ff3de846b623913eca9e24ef8e77d0935ecc4d660ed2045669f2e6d76271a06c8f0e63abb4e41dfa46e265f516458461176289a0f86df9edef3488514bf0af89f4e76a4d5d71baa58cee849a5a94ea16ee3a024004c08dc51454cc15ace2cb5d5dae4c2bd8ef388b7fff39b98a16d7bf2516ade03e4d012216dbb784c70ba322fa4bda08b4c82f81e8bb5da7733f5663e66f394b07c057a2985bddc8524fe4ed488eb73f6541d5d537b5ac0756720f57bc2c4b4284ae5e5abd5946905dc10cb8246acc79a5cbd007c813bbf5442315a45a58277fcf12d38b26fbcb9fba707562e3115324f66a0e76dcb3325dcfcf3b409b9944142e17a3303e8e5e8f2c520318237e134bdb14cdfb73f1cfe5205808fc1dd3822535b62f8334905e7d41a4c3c1c888884fe492df1b97939a8f0250e22d6c6b115eb6076825c45d177c1442e43dddc8fca03e55d7c225a9f965da7fe6611754e4eefed9a7f4ea7f8b2113ce527d75e3afa90da9154bb18af6733eccd942872f1733db86d1e2d032b0f92b20839963d68bee67e679615afef2205064ebf455f0ee6b690851839261682e3d9d8117a3f7b7dbaff3f887d5cebb8656eb9b4e613d2c5d534266a377992a87e5bb0efe316a20af6ce23303e5fb9fa2e225fdcd96ea36f586056b707083ef490ac66c7c980d94a96e8b9211e37b89b8d5aaf3f2cfbd11b3f180d6f5bd6779a94d3beb26bb29ad1457bd2340941a977c6c3bb8b276a086d8bb3faaf801b23ea502eea0272b1b266eb88ab2e710b572239089493e8fcd297fb7c151c4375d4dbb218e9f6bd3c3625d02f588d1553a7781d914c276320b150176488c0d51b27721b5b9ae0584d61cd23ede6fa1bbbb922757e7d47e981b6839d62702076340925c9bb60fc575599be5f646b08ed6b8252d61bf72a5439a74470e1b80b1bd8bff0eb6359c56e27ed9c8f42db6d54c5f7e0a752759f603488c965c6c7a158a0ceb8153cbd60363d99e03ef12038a774715e59ea8373dfaa9fa0d728cdc2c73c1b2944a008abe7969e6ad81719c38f6dce727b45b83c28c36d37223765397f906c8e001a1ffb86a3261981a24bd89fd520a1d60519d003d090c9466a3b7e69eaebb428827224dcd6654171a3c36128e68f213729b226329ace4a640c91d98773ba3f19a36c78c1c5fa010fc2be26695091b41fda43a8028849ff0192244b5f9503c9556759a003a1577650c558c22f7ab43b49bac31bdb7c528acce5902a627611920d8af673848882e8944a5f9b84f2c1dc393948cd7efb0a67c3ae53e101c1330ed776265be271f266ae52b6a94f04d39fa25fa4f55a36a981b1bbda8e54b99188f28d9e6ed2e189d20944e0239f3953e17d9b907d5a52b96e67ac016bdcb45e69d9323e004f3da825c755cedbb1297a312eb421ae124d3935a8b495826a1a7eaea5080ebed65013442f989cd6bb813e66e3b07cd100bbc46a480a7b54a9a7ec4a45e2848ba7b8c0f127ae4fb64a3edacaf95cad3127f37b98acf24875e3374f18b90c2e6438d9df0ff43dfdf76b4864fc0711cb0b9c3dc8f51819516031fb154b92cfd6f3567d6947a77d3ce5f9081b5c30f2ed63206d1903a63077518bfd13dfbb2247976044ca8afe7bea54be682cb8a43b12bcc0890d7e9ff0bbede875d512e72f09366a750479edd6050b2ffd88bb895920b649c66d3aa8f5e8715655b091d5f4fadf9f71fc2eb2f98dce701a265873c4b24f94f8df93f95b01ea184b495600847735e9163cae3586d0f5b019108225713fbe2fd8152c7d2da0b37702efcc175c3f44386f1ed61af5ed760c1274f4b3f821ec6c36fcf62f7ce6c34107b993241904353de43282be96350bfee39d5925493f29302800467255dbe0931ead36e7089b7bad587dc1cf7f3b4c49f09aebcdb964d7167e7c7093b2787811386bbb57003af3ac9a8da3dc0c752594f564ea1c49446d9cd04f41c675ad4e8949f89e0052a0b4574cfadaecad20b873d653118d73fc22aa40e5ac4b162f5afae5803f4b0e862c4f7e21136a9c2397a9eea5d54f4570982b5b13e00bb5374a4e8153b2a2a8f81de68298477acc4fae4ff90760783d6e95957a03bc2c3a4fb2205aae85b9c44b0151f9005238fa00d754f3fdab86f67414c3d8872346f3e6ee0164d06eefeb733c90406e45f9514ecdb3abb3304d5aefa63b70adaea3e98a02ed2273cc6e2a68fe490a06125e7c4cd8ec17fd3f9542dead5d3e53e5b9c54fb72a486acba486aa6efa4646d1bf77de33f8cf4d76180fe97f14c4905c9edae5b6264aa66f60cb679e06aa7d989dd48355ce9f5198f5dcab2db2a7e9cfe5178ec5be1eff12fd4960e4199b092e7ef224d4ee567c212c6f04b9f4211b9db9dfa4cf59ae0cbe4dc2aa95b8c886c8a69e6456edf5c9116fe9d9e53bdbdd8b36a375a9b988b3c9bbf1298602051be031e1598390110c5831743e6a14f991e31699029e1174b77702041b46e4a2825468f078088ac5f229dd3742f160e92b64dcb70190965a0f272c9ed6a0025ccdf11acc9c6e188b5bff9e1e6e61a67f24fb3f0b24bc85ec61eea4801b508466702af3ef342adca60178e0c9ca739a95eff69cfb33e97b841c98c7fea66ddd597f651ffc6146adec8e47db820c30d3357fb5ab21614fae3ce3ca8646ea781d238bacd282299b174416e16984a539aec5af2a0c2e42cb4e008010da4f0df6f3503867e7b8fd2323538679b0fdecf560e798291193394fe629bad6ac551d4d76c91cc05ead0b5a5a12220b906fa507031f4cc5d9556ffef275700a41d1dde0ef279a45e1a48837039db2895ba1867a576236bcde764dba76b0e743f32fcb5fc9f9cac01543a7548969352f63af2f35bc5e1c22b5c2b3698208808b8e93df0674008de18805dc7d472e5b787cb0cec446bf6a843af243ab7a91e74fc74922eb3f375c7e4d4b0d629bd2db37eccaf94b1cbe7996b804f7e8163501143604fedbe7fa62da487e37723cc11dcb9ee220027b06f63c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
