<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a73da6db243d50ea628ccd274467f952bce69a6e6ca7d87c8e27d020dbd0369f6aa816f79476861fa7f22eaf86bbd6896099b395fdebed56a4e2345c626e877ea2f11066e40822124f762bcc6d356e4eb87069194dc79dc2dea09e5cdf86f5354b5956bac2f3869bbc378974ddb1c8456baa45304f0cac75407493c011ea1b7143820258ab1c6dc522a2d0458180fcff8d703590f47ad3daa4aa79d207573aa63863a51d2dd838b9d35bff58d58c9691092e4d3bc5afdbd3afef3bbb76987919f90359d45627500ae8c81885680dbb6caceb166ed8da82a8ff36fe56d44b2e0392f1348429a1272b92d4c98d9d1f7b13d4429c88007d5b02b4bbf0eb6d60b83098a48f5b58469e813c4a8ff052d5896d66bc1431001349787dac201a946eabe2f961f713271b1ff2197e5c06fc3d5b2908d5533585213b07df279e14e9832b02859f391942ed972b78fbf48a121ad73c334c506fbfd1d5f491a1b5dd08d3fbd07d2bcfbf62ff07b14020c3206f3d22e1d97d51349cde9da6b1c005f0505d8e3a3c41ee9adad6cfd605bd6d9c07aeabec3cca5cc479b1defa2dd7bc037e380093ca3be66cf493d67a565611b4e3ff150c998fe41858ba00d8a961e5a83e8ddec651cd656f327c85a4cc6401c910a565a85e509efa059abe0ac0c8c6b30c4b5cd525caa45a754b76ae70a2c8476cb8af2fa2fe214dc2d08d729b13ef3a26f7a2d82987b606dd0a4d9d11fac80019820cbc331f0ef62c6abb0e6d21a3271d9376c722f5652e4a17d2b272a23429863b1aad7243c5d2d498470d8c35a4210ed5b0e0972f36561c0e0e0cde9f81bcee0bd5050656e8964bea8937d1b60347350014c198cdabf9ac356455e9326cb6006bf1596bc4771d441df3fdeb1a99f7bc92ae2f5dcbd6948fdbaf5f368b10d9564539dab06c6e1f3ffacb6feca471c02de9217f95e259e01225b8f91f83479dd32b4bbab4fe24e87c4df265fd4eada831fbcacb82d7a6343a129269349b4973f90926cc8d6a4b3f3991a83afb941e40233bcc1356179bc3fa45e0500562a6a96e90097ef48c29eaba32d908d8cdd4e6f1e1c1752c910d79ac2c6bb2210e899970a153e8373995a535d5e1bf9da851e3da9a539bb6d5aadda434fdc6db32410ee0031582e3029c8a92b6f89a0acf8e97b725cc9eb5c2d7137f8c7b83d76523b2de1745a4a3b5cca17a1210d649bd3c8233266d23f2b689972ad82fae1a3698a8cdc48ee3c6e339a1bc3377b8ce1b07fc54e07fb4166b0e1c22fd442a836dcca158d0fa8bbc9619538e599a2c964098076a362e1ef888091506edc9fb33481086f0037feeb8a7fc88fc2bd32ade136ca64e75b67f0e42f359e52ef31cdec04dda1b55b9e702d2397d06fe890a9f82ba3b2e5bfaf11cad7db267c86f9dc043b4854c784d97f101b20679781d6f62072593c78fc03742260355bbefc8e5f0f368b320b1b598250cbb49a39b878a9b9b8d6db68cc84e47efa896e6e3ad7ab3c6d201598149ca6756b197ddaf27e386f598cf72876df9e16d27901633dad59dfbd26e8c29370740b66f7051555f83f320148ca46fc770b765523cf9cdba93762f3f961b3d5cd8ce1988d8d9be2a73488eaf3ed0160142ef5bf98225263c204adc4d2dda6199b97e37929281c84aef9c238d48d4bce9916fd00b63b860eedb49373bc3b6476f5f1d467f270cbab50614630e2bbd84122d834096b749712c792003971115d359d924bf0d772257b535bb60550355474764385c84e1493682d91e71f3a9b0b234ecab9a2ca29d3cb58964831c4a8b373658b0604c477479dd4d0ead670a4d31f16de74825ba64fc5b7c0fb2e287bac7f6c9c84b81753414bfd264079170ca8b28f9f7626658b90b91dcb7e475447d1379c93f24fd8bf589b38f2fb168c882ce58dac131a419d4a457b5063e7447813666820fe6e30cb44c6606c4b364b354421182c19b821ccf1eb538beeed306c0d8f97cefe505efb14b5312176d11f1c010db8ea39dd57860d067856c66f516798ebad5550abdc6e4f7f6f31908c55298cf1e23b68e884ca7127414baa43232f272068d937a3995459f89edf92bb0cb5e8637aecfbb2b0f25bc5387d2acf5489d12888ea7c9b53984e4a4def3f7e2ca12448f4d5e454af636f006ba49ebe2433d41d7df41b020e646385fd56e1d1a565ca2058027377b8c0fbad7fa52a44d51c8b8b9c33438ebdb0f4e0024675922e5a18b6759e8d4977d4678b3ffba4a0b3d410994a5c807ece02e32289b507018b32f1dd927c7ddc7e7dda31e0e3318dfc668d5ed69360314e48b2c49f37b77b62dd5652902ac65edfbbf5d205168fbf03a7f2785c373ad58cec3af0b9ef0596ee1d3acb614a548a5df9f7f940936043f3997979643d0ad2a96628134d3f13b5a4b0bbd5803b01abfa048890b97b5d7f696628b763a3e990d3d82940d29faf9803fdc5bb9d4214ae35fa8fb7de67a29dba4e9cc4216d71271e9f18b4992aed764815055ff8897dac160da10360eb2ca04cdc02e5284262fe4b216b7a034ab592cb4ae151b60e692cefbcb0811a3d9fcf12023f1cbf98fa6df45612c7c52d4331d06bbdb12f2f2b6f6f93448ec1952bbebae9da391d0116548801a489e364b8bad7f1dbc9b17a9534fda4c12b063c70dad9a735eb980d8e9f996eed0d1eaf917cec6cb1944398d738dfc6053e5dc71cf32cd3aa213bbdda65b8789a80859a43091bc7806dd19deedbd36281e9ef1a7688129126aca8a5e51656f8578c4d8181f348c535cb44fb147cf4594fc30dadeb7931242a60468eb33b026a6e8da70f70e1b93e1652464dda3d282f1c1ee12cbfca33718b33fd69ffb5c22716fe792e1ef802341deffaa615e53df9d75c3ade26e0375ff66e5e533380d6f51a01f2e3e71abae62fd15ad38f1b0d8c0c39b0fe8389b608fada11db762b0b5438a6c3ed4e7bb883ae6dbab779654aceabb5edbe1a3ce21360c5712a9ce4ea3350c2781c06d896b306e428995eede176136d67468aed17441c97f7918d7a23e1df61c95d7c0fee9693a2bd6552c376f2d9d6a36d56b269edc644289887e4981cd8b19f909520adfc7cc4f82856ef997dc9694fab437386c898cc420139d8d0c5a68759fcc0d0c0ad06b57b55af76f9afe193e76441bcc20da38059a6f9a3dff60abc11027148ebdd96d1fa6d18653cbd019c84df7a3d10d7cd77560e56a5b07c3f06f53c39d7bfa691a337df382b0318e150dc546d6bbe5947f05bd31cabf57bc80768a2173b341869ef9c352f93076df89237faa027b406e1630a32213374e1f4c38fda7e29879866cf8f0fa221c1297792a1ef4498bf8a9de94c2124d923aea63714808e19e18b8c7ffc4e02b918a18c360e22744130eeeaf4a8c2558507666403138954683090646b4ef01688baade45fa4b97baf6b0258a8133cb5f717672278efcdf3c5c8b27eec3a5bb79f2e6872d6081ada0c4383716ac87d018d1ce9bc219ab95e46657c5b4a1689d144f43a5db5302734c97210f4da629779f7002a5da535ee363a8e253bab0f5871dc13504af2485bb84b329ab805db489381de1ac15b06151336a2e33b4d4198128426f485614c25a190e3c61990f5afa752cfb2e3810d2ecae310ebff8c6b5205c4109959bb44eb38ab65083b1ff0c28935dbc9ae5f71c99a82bbabbad5dbe821d07534b72c1cb924e3ddb46924298c3def190fd486a390a7ec22d46eb866e7fb58d00fda2b76c9e22190627b7a8edfae4c53d4e684eb4e62a3b5b277c93ae60a694887dc2d9793a7bb2dc10e7ae19521d837c0233424735c0175b67a5d4adac20be699cea5e2b6c5db02140345f8a938a523039f8807e645412d79319f1d90bb09ec62f03a966d413674edc86dcb3ad673e010a284565ecb84cdc08d1ff4c6069fc2f314a2a72af7f5210c1136a8eae40eb414afb9c00401b1ced4201f943d5721874f65f06b6a903be8a5618ce006d8139a606bfe174501c0a502a14ad608f4396c7fd3ae3cebc69a93db13681238c4c710b0befc6eb1e3563aa438078d72a2822570471990c1ae6e5ca6713f62800936d11abcd335fd9b3814f97eceaf97aff2634bd874fc38d84beb5809f62c4e6d069497cf10b25ce1b4b335d6982ccafebd27ddb2be6f0dd3dad469bc8d017bd5abd1323a83ccd4174d5f8ddb7daefe315a8e4cb763e9b62129a5cae8f9e5838daa4aa60ed80706e236c154c9c3bbb31918cfbbb2673ed698eb4ccd0d86c07032ea4cdf8856b2a7d6384a79fc1a25984311248682ce3026a913259df75fa13ea5aa184084e59db17a413c6321d9ea2858fe114adc9c50cb02a824578199447f0e9b82fa5704b59d0332d3ec6b486fd3b69b9a7b74f7ea79c51c6fd62d6cf27496858c5787232d78b8ed9020c97fc3fdf678e062e1f35bbe1c1abebeb26b1d8601779631bb394f71d45f238659eedc34efd14540bc8737ee1ea9c3af723be4e0b8ae9fe9de918bc7189f676f83ece76d7cecb086a8343e47c62b637139c79002a9a042bacdaa9c943ac7d9a4fcf013f91c06bf7f297f0a678a62aed61e7dc5e5a6858995ee658740d392b0357fac0943b6869fac2ec85d2e25ae6fb5e5545e8a55a11c4f06d5ad27e43cb6c74188a8f86b48aa532e9ccb8a34528a716b169978ee5fe6278480b4f7face90eb1428ac22b1ec8177109beff07963f7729b1035a19148333651f0ccdd0e89dd7762644907393094d85b99ea0dbbcddaba91c8306c346742e52a5b5ff1deabc2ddcc47df03c6a731cee71425ed975ca31920083235dc4eb726d4e87a20af14f3839aba1611719f3e7eaf1607f3484a7554d29ecb1435f78f05ff1232e806c79291eec8238e644a542f4e28201e78dd864b76558a1c075fd4ed34533f921ee7d9289a75eb0262889624c26158bc89d1fa309dead828f818e0a37c3d13e55cd2f572bdcc23435b23d38d068c2c4ff3fbe88a0338ad34ec7a34feae558e0004f25a3bd463c2d59c00569337b7240366eeca4e9396137e07598cab88aa6d1f7fbac18019ea748a065a7d2fff05154d7ccdadc824dd6534b90998dd6ff5e713a73c61fb613c1f3aeef65f0fda9a01916667e7c430f207d4af29eea6e4d913988633b75b2870459ffc10c54c667ad58094fdfb8896a9d1195453617fd83656e25f05ac0f6345e58cec7ca6abbc2dcf476e61cb773e39338de5b5a3d57dea4dce3444117c783f89b77d064b57c92e0e8da506daaadc4a6abdfaf88df95a3c18db03487195bab6c484a7aabf107f72853813994119c1d0e3a260f9dedc50af51d55d8e12591e6614c7dde569e042f43e37adf8c1508fc5b449f3b767196d36a031ea488c7710e91d142762a49419cdb0939511d38ae2068402560fb474166a76c1558a3bed5d2e5b89e4fb9d60b632286f03fbd176435fc4b8c1e8bd5aadcf9f2687937d187077ddf707c2102fff5699aeec119d340388014de85c6c2c3c72c6112b1581dac23e10718df05355cde9a6edeb3e213c6a31244c1702780b4365033fb4d1d035e10ddfcc4b3695d2f0b368d17e3f188b05b99908d76a02eab80eeda5e1624ab2b0f6b9aeeef5590c5d0361f7adb84684333ad68e395519f7e36a83bf7a87a7c13c8a780ee544786ee298740758f1e71b04aab309a7e80797234190aa83dc2c1b5cc50699f02da1ed2fe58b9ecd2431d34d23f5da3417641c347e9e747038c409a92cfa996ff4f927191ad1dfd0c9a12667bbaa2cd51074877bcc548846b358a438c8c23f703eb70010051289248e9a411e4406e737b590f1dc7cf641846e9ea405cc52275e0abf8ef2008a36bc848776efaabb30c12a98d2872c6e9933a70d854e5b2d8db09020e0632d67c8c251661959497cb479f4a6d5b4ed7e234372ad30411a40c186bb9b83ed9f908948290a31e8ab1428a8956894a9812ce6c8317098dff0d8851f6262f717855ca55f8e7d4fd9bc61cd3868f7dd3a08161ed2932de4fc86e717eaa6f0b5e8ca5f7b137de7bc830d78783a8f68fea95a3a7e537cdcb56b67b8b8d1b4c8f7be882558788309e8afbc17c327baa5cab60887b904fb6a190322495aa7fa6eb7425cc3381d70daeeb76e8e52ec3cb23318c149b3ea9b102f1fa4b98f0f99782e9d4793ae4085cd1e1e498aa03c1d070acadc5168d2c3123c6a1bda74f8e23bd885869f0c46f2ff3f6a0be5afcea4bb82b88b7ab07abb07c8751dd8f6e04c458834e05e7c3c00e737a38a1e924d6fdb5ed38b8aff9916e8625ab8f66cae8da993ee8196697aa3454d278bb363c617dfb42fa5b0659b606595bbdff3a4df4d0d18ef7db3ecab5c4e6596cd9b5302e9868ce1910e79020c60601725ee1c1bbb78706927359080f75795ba2218fd82891084b2d7f8c1da50c30c633726f71695fc7c6c1f4e7ef48bc34f59a5aa8d5a88eafd2192f1b5fd4300cb15abe2189a5a1e9829b87936003b4a0303d3f4988d27ae6007423d94a1b05937c64cd869e355b29028f3ff487ddfd64f5edc9503f9bf4fc1b32cc42ea0064654c26c32f7b5b9972c09c5b155f4f2a52910ce96cf81ac712ee11adf420e7009ac4db2d4f985fc377f9d738c8903fe483c235b58c2bbf06553b14170bea48cea9ef6ec843a2b4162c03a241e1a584fd3e8f6e980568adacb25900cffb8df92a702e9d947b38db5d04b268bf94e9dfed19b822320e2a0d74f1a212126a706fc02008213af0fb1387a530f526aa71da7a30f9fab51c0820ad203a2decf0101e8658e0857746ac0dd11b8a5dd91c92030fb546e8e1e92ecb18ee22eaa7d6aa23a99ee6056fb0c09609156555bb1be5d8161d8e087b6479904af19b7a15bcaf25b7d215b652e6bd00241e7b300f78d12575ae5ee8ee01949b44701c23504843de43115103d9baab55fa6d56d82f833c984f3b487bb45c479df7ad0ffe8dc96f5ec701ce31b6a42930f0b859a91fded8a472bc066281c01cef624b789d8a8b876e9abc6a972144184cdb086b100010e094c86ad2accf00233167afb5cc668ece86a398bad206ae1ba0d2538ead1710b6902b5e74399e99679240c95f9fee5c88d9c285cf1648139dc0f1bdecb658847fd38c5cbe940971d0a429e9807ff0fe9610c7091ad4a8b81d96b5983a4349f025f2d934d2f12e2777717034ee234f3615ad3342021ca3de34144c8415fe6bd35e1e271987ac33aed6ac863687b63c2f53ab36bbc5aae12b3e54df3800bf2017d84a7d038f09eda0331085e8420e9069d9205a42852bf01a0af1abcbc9c0a6996283073eb448648b60302161480de4483901d764676a306273d7ef25685d964b823642d5d8912e6a70b8b9d3e17e1e933b9b94cfffdacff27b7fb13a71209b02a1e620dda60b5e47d17a4ff4e59e602391fd3bf97509390475c890ce661131e63fbc2994bb0be495d38df8cc93b146ff34ccb61522e5aadcd84a8ae564351bc468edea561e6efa27b81e3c24f4a57277f8322c3a7373ef1f2bb37012cae37687eabd575c35213c6b490aefe75110829b7cda981d8856900b342d5dc1fdf2469fcaa352b5cfb9744967287b1ea2e0601928a62d34def69d72bcf0868da4ba9069e0d539f6c3a30f125cbfbaebc3bb7b1d89a210846cab9e68a4326b728f1d9dd9f1990b66a5bdefc67585d80bcfb7d3c0a34ff9dc3bd217e6a5a8786effc720b709d0668a5410f8f8e056d811ce6d73a3be8f282790736a23769e790d478f21d1f4f4f55ddc4266107919e4ada693a2d1cd22ac742d65b08712a25fef04b3ed33613400d99f27461e3bc4dd35bd7cf9bd765be804708ae1d0c202556b8715f3cc9a465e454f0d459c1dbb691c35701202ebdf02f193825e56eb76752586f6ece9924b1e27eee746efa3a4d296d34e5db27edcc2f9bb4e987dd82c128cf2b0aac907b68eb0f3cc6e1173cb5a97cbba17868c3abb965ca3692e5d550523f113d70f5396782ecb69d360b8fe7e1e6feaf522d5e7edaa6ab76a40f672f9817ce91196650c41451b69515a912a1ca8038c907365096e626f34565a6b37e12c265c2f0baafa5fd1f7eecd89edada24dddd6f646c7ee38ae45637e9cd09f54a22dd538f5d084fc8fb820230668f1368af03fc5506fe98d9250beab0efa38e9ed0cc9d020becdd80e85adf46c772b7170c27f7b26cc24d37437499517fe35331b9e9f89af2efbac38578f04621d4fa39f601e8f7a0921ba25522112a370d4f97c29b43c4fd5f5af104a6fae01fce701e3f5f5d51f3feacab2012214f3df54cedbaf1fd11f6bf11959f8268031c11bc57dcf08ec7f83426e9f1180f432b286170431419ef16732c35efe0bf60a6ffc477687d5ab932f531b74cfd4bcd5bbb2dc070df641ccbf216c4ffb83565d46def21d130aa5424e11cb5264a796cd1965a34851a3e9c0ba4c22a58c336f3af542b05d877ce34a76858d0039c0e751c6036edd05357d5125f3e99bbd02b4cead8a18cb5b2393a9884e642e901826a875ecbcf29bcc582746c3ff56409f1063a4ad8520c16e13add70ab5108630e8ae0ede41c3920546708f971284ddfac1190b419e54ebca72faf1402ff5dd4578be5c3a91e49b0d3d172d53848f9c7802510e49b0b5b49a3ab53b4c7d160ac9d9e8585ad3aa40da3c48b531d13d67d2fd8aa2293491ca9f068ac1f06e0d62a19383a4897443d41b5b575c87229494dd828b9eb79e8fe324b5b96320eea443fa5334986623aaacccf0ee9fb237ac50b77d6def3954dca09254b8c5212a49038efcb1d1c2769e23fde2164715699f0b464f83e1375c51726940944ac1d19ab729703c9f43ce3d1e3e79f4452e0855fa49b3b5605e08b347937a9fdd9ca3c030e0910bd912c97d753579d77240c1b6f38711253ea47e6390b9d0f9ef1813e54a6f07fd7a80dcd06f8146aa83d264310a384fd72205e1cd0435021c8fb346ce880728c63199e51bf2ff10b7793ff781020a02ea686c9ab2aa6c47bb966f9046bde4d66b127d86748665d35347df346616d6ee156b948ec2bdfd86ae0dbaeb67692cce2a4f9e3d1ba51b1386bea16f21f7123025739627066d89b76f1b0be3fbbfb506b050138aa00aa0b1975e24654c2d698f1a27d2194ba0956f3e5ba0baeac0d86a4896490c5c177b976e6c0e1f96608e308cfc9806ddf1d0e4c35fec80bc299430b318587d31e63ec767da520fd0fe6e35c1ab943d9f74562dcad8a78988f02bdb4cd4c0605b03678321855adf03c5a98e3bd9f7950e7d38f3fd59ee94b8741bf76989ba27cd725570352065380b1bbeb9e9df4b648c69146897038e1c9e3bdbe1d803ae3a4f882659bb8ed2adf52ce375f5eaa70b0881f07c638197f0bf5514b3740973f82d4e7f708a9eda29a7b65e7ea9e711310f1a5bc0565a1f3d32dd468e81ae801784a6d10ec3b17b9a114c0ad53dca30eb21b270aaafce1ab828a047546934a6564a49508a84de970db28640e744267a3ebe96eebb40cb6e8cdf41cef7a904aa0c2d4e5269d1119e3e0c178318e1db9c2fa97ef295a14546987ad18936e488d65a0698cefb448eaade4620490cb12e5869d7569067ff4e3d722e0f084582f1f2fee8476c8663fcd8777a843720e1a0ffd766ba12243623512741dfa4b3415c9ed5b7ce0e1e87b663490c0fa8cf7a9b89b99024ed925d80a71c0a36de63d52ed5095cd5de535e69f81b8a0dea29e3bdcd9ce5928d10f05881fe84aafb2c648550b6498470291036f8808d89667a2582a7d9c1677fd5cf40b3655d182f5a13acae70d6adfe245384a237c79026ae56a136e90dd71e22576bf5294bb993ea70f968121634d1182b7924d7c7bf71c8928ebe24303744886300059685081722cd837e30d54f955d6af677d9cf4ed1a8dc53e46b191b904cf125f4ab38bbedec25ff57eb75d756afb6cc3348c1fad04f4885e9035992843ed80b7f70b219d6c47a0b6c4e3f0f0eb083f73e570e212e04694eaebd0dbc1e6a5d4ccc538b2a72bed24cebe9d267aafd8fb9179636ebc56a208e82d73f671333c33c88802414a222d6ab5eb99dd3bef38913bb11dbb30d65968c32d77d3b0f362b0a9944ec5e56f4da6fd18a63f902189a1ff29df404752c6b9f95980640b207db7d961f5853e9f7f9462bae58dbe2b801fcb6feb4bc0fc8a358cdeb8d36abfde02c35afa374832e4a162eb0e40c0f75996a4249f334488df3f6187a889ba37cd4a8acdc715411de20559f9751aba55139dcf436271ec59721200d2752d7e273e01725c8209562ac2d0bf0fd50d5a4f3dbc19b20aec470141a7efd67b89b844e6aa5bea25df576b12ba026f259088531bf46a18e2eb1434855a18192f17fd2f04d918be610af9e15922090b892a75ec2c8d9f3809f5d8bd4e7b7368034a2d7c6119a6041e971fd726dda4f6b951663c3ce902f610db1edeb2b433f79b2e8ad89eadb6df1deaf5d0323296b129f4c019fffd7d838a39e5c238af7b203ce766040db178001c3b22afb4d0864393e7b273acda578898c37270d07e9e54d90f23d090004d587b0bf08caba2e0a62148794cb1cf36996d7dfb85235c91c19cf8203fd85219d1601f18ce7346bc69ffa400aba33d2ae2975f4afaeff28674cdceb7f98b083878284560a41154c2015e98744688bb59e9c9074cfa3ba1dacdeb5f0c6fd896ae1f386bd46a51c6c3e10a5a3b86f266365dcdbffbd6dbfb080b7ce88aae85db592ed0a72473c4a77a35ca7d6a3fffa9afa5d89291dce002217604f1be70c623e6bcc72408aea91ea3063375806c7b0be241020aa77ed0520bd540a51fd6967d6845dfc654798281483612fc71728757974a8e6377a9a07b733fb3f465b73b22c8c3caff321a1a5d59f9381e07546088d6a8c076eb2c557dffa41e5f042f54305c63f8ca8162c075db2a84339f7fb9c634bbd0862e1aeed63e5a2aa34ddc280a93e93937a82e3a2f2b9a8e413408cfd3cb87a9957239b49ab333245df02a8574f25a17f7b70d914661fd072af3f763a1b53620274fd56b2f0fd73f6249bd0f9dc2ca14afb76e5a2ee533444ba2a7e2c300b7fe94f140cd6f9cc0fba141b48b8d7752776754b3d8de6ea4ccfc053fe070f5c5221a683e2063307d44ab122aab5ae68f49cd562a0b341f3281358886e113a148c2d8895d37c1d021952b8eafbfee4a5430b82c0073b342b17e30f8dcac8cd1bcd90ea3af5eba988c416217a155e79ae0135ba27899bcfc3d2f335ebebc612fd8f1f2e0c7ce9a905703e8fe57801e44506e8d3d13f203076ba4d562451d961dd50fde6905aa5fcf46fbe7792cd00cb10289c1922aa7e8ec1bd2bb081090251a90604872ad1e4d2c9f644aa0065b3675e80f0ffc45fb6c2fe0ea1380c3e6e925fec0e4b8855b1322e0f1e3dfaaeb393d66975c0499ace597a750056ff1fb945c43228ee8806b73fe36c5783d82f448a9880be7cc7d300c9abc62c8640ed2d8b35b596a5346d488fc2dcc64ac4efc42d8e3398dca56d85eb6645d1184fab47e19c77cc5ed2addcbf2181876390a48c33a770f447fcc9b930c072a7beca7595d4bc8ce452c3eee84f0151e8cd47954c7201ecbf8079f748ead97292201c8ae901387d5c9df6d198b250c87a20f0616ac5943d4ca37111cbc940cc6d1e853ea2cafcddd155bdf0e6a4b426be93662aac595b49812288508709be9c64531a80d42b4f7ade29f1a461e78ac0db56779836f37379137bd634d9ba06bd6d71788f17867cc83e8f791a2049f7c9412c6e00a9d1155e1000f2de08ee1ee77b6bcfdbdff22c71d5e79e23d4d9a11916e54ee53c1a1d7bc78c5be45ce43e4f7efd62f421457e6f9df415389291ac9b4eaa9e427d8f597bc6bdfb5b7d9997c8aa938794a1606c61590a15c88bd556dba2807a7a1e8f4d30838cbe2d884769710fb403d515004c65233d21d1cdc2e12d2b79f2808886248107fca00d2cb2122b95c8b12a7dce565e30a083c08e2041859467a2108b4f4e5ad5e3b1edeb92481fdad315be0e145ea500f42f7d6170ce8760c7d1826b2012202b7c284d34015b82308763aa14b29c6c7c5e81e4fd595e4726934856598b59554ef3fd69911fee66817d17b9559869e8c2ad698d935a18855b833ff215e86b563e93d49b0638a7d9ab0519716df47fb12c37a3f94ddc18046b40e68a337bd13385df722e50a860d5457a6181cc29921d7273611ffe91efbff9a9041abab9137a987488a45d9852b610d8086ef6a6e7715c967982eaf2b7dbc16ff11da473c371136808a3bcc073caaa9f4da4ac2c5348db1f26d1877e23c5a2f534a524206f6c3ca6941b3b89d866189e9b98427bc4145f109179f1772afbd69653073c8efa4cd79647da063cfe96571b3998ccc32d584863dbd4e7a310a45e244bd9c2eaa11770fb59eb92cfc5c87e40562ea704d61e350cdd2606e8c6ffa896c9cd13319b46109c84079e17441812e640822561559c22705975eed1b3a1a6e14ecc98b16e45cdd413725d048a04cc71b05c60f571596123e19cc6e3020e1d81f9fffd347a0f539cc42595c3c767a19f90f634335aaba1c9c0f72e63ab9e19d074a9d0622a10793487ca7f121a998a69e8cb4d647944f2e69e0cee91e0125d6fe15758f4a6d78f7e492ba759e74964026ac3d8419cad5d53a9152e5798c7fe7af4f85d950abd95d39868428c3ea997b91fbe9658e44929b1e41284c2adbefd58b97d7cf93065a57fa7af3eed9634160074adfea6490fcba0b69bda1deb857cb5b7213c15ec007fe09a8595eb35d5cf832c51f9777e047d46a1ef6755747c1dc5ab9b909abe363374c35b5e25d9e5b227d6de0c137608578d3317d59c4ce14c5a3b4399fa773e1c443376f25a658c52adc1d9169088ee70a1aedfa8d1b0210db26a91e8362be26bd341c70270a6dc43a927a6c4d5bfe4cf3a1069284d7cf43cd247eb6c69e2e32381132e782092b5ad1b59f2341bcbef11e311e768d2dfbaa181356e67a0ae14efbd26f06de6f54d32ccef2df10f175ab752c8a8c3862a5ace32bc8e182833be6cb0a32a1a2a91abf5d62e87cef00c693cebcef8c032d7a395be863b079e393449db86913d816fa3c88d8f15709f11e45330b2f073e5fe9789d141c0f29f41c0f62b3d76a9fb3052dc73a4a1e60d76d97ce52a9106e23a9a9ba89e74ff8e2c7077ae43beb43de680b826369be19b213e1f1c73e283221587246c38f71b1688f50ff8de921642cb43637992cac7e19b9cff3c14db4f4966f28cffc875e5921075369c5784c302258c8617971abe2e22473cdde97bb98a62c054f610e5511620db2626be3ad6525be5ffde21b8d36c8a3fd8124d25084fc71897dd81cf026fe890bf595911089077b63347117f4693379ca4de3615d8035a58cb0c92970516de68312718ce7607fa771eda7ab80f37808f84f17be9444d83daa070166cc8c77258da23b13a2d4c821d981cdde680a09b40a723ebfe3d8bb78c14b3fb59862e593aaa082f85bb0f7149d49383bc5b4ab5ac2039ad37a8ad7e25711e8d80c8f3d56cf5d7de79b48b917da9659e99aafa802924683d6d139ed2156bb42bedf8807cd81c90b668d1f28f8b9178227a2b1f11ed30f5fe1c3defc9b4de1b6d6cced063be23edd4dc1d885f0ac479b3c4e115e4af750d17741145887c8970de0236de525a436e6e436657252b52605580bb651c4d92ec2b03b6dbcbf6a231d03cc8a7cff001b68bc34db3846f770e14613a2e69f339e25573e1a5927afb24c53d5b5680c22c19a714794721a276488123c779a43ab1d7f8fb05adf3ae937f159f0f8bccbaf00cf093a0cee4f156e763d443777ddd4b1a5c229ce88e9e6e77ec945f7f707a8f0451ad1ad7ce10666ae00aaa497193c1b97e9b5991098a399abfecb71263e04b03de69b0bf95b4d2d5cca39039f18024d9f2301e57207133fda2755031065a71ba6e2f5ef733d467b90d8497a9c3a16b561d12d1b245e700db78ede18bc245c706bc7aae961bc5093efdc47738ab640c475b4950bbdc608872c48da9d9e13083b6c5a6d7d4f0d738aea144ead4fc0dd29ad52bbbe5bd92fe21cf3c80fc715f4784b5ff51701a3187aa2030c0c33d62d4c8ba3c83d970084140f1b0f67138d4ceb5b10faf5c7207f62c3cfe5fb694b06cb40b9dee7297f9df8077c3c51dba3840a60f333f769ed4d92a3d9a5954e466bc1e921f52174a9ece3dcfc1b2e9e5557103650d5103b1c9f5fce53ef3e2d2a2c49989bc302d9602698fdfd267861a8225aaf144786352da0592c4bba1442238de684a78fcdd538a5295f9c3cd807b3322b65da2d5854192c7cec4061461b7d94aeb04239355ac2b5b1faa5b8d98ae23d2cb3ae7eb5974abad19779ad5999efc40654a37f46f2e26cbce61217f2938961376842cd3ef3abbda4fe44eca04ecc8313bce947f1413d69d86fb2aa14b6c39c6195bdfde2a299763162a21f886f3a38e7926b29972d8d8696ea33bed80a8a91ee4fd341c5d720ba30acf90938f38aef6222e823f5f704a40ef2c22d31cdf3f6e3c9896fce20f601421a962f251bfacf895d994d8a2513e19db6bb7fef5ca3600ecf29e0d293c55a34f7449d014054ec3e6cb7c70df5a52755fba15bf5c26789a63feede971abba3f5a28fd36fbf339f83957f1382315afd447b52ee38c93e67e5a20fcffce426aabd91ca317bdf8960ec7a785245f3a35e3ba761d8875143c3764035cecaf404417c7dbf9c1431c1a20f00e5742caccd11026350882119011ddae51bf1aabda74b5fa32f381f3f3e85c10ccfe6ffbb47c3d7315e81d60cf7c737e7537f9a83d5d4a56e94d7dbe7bed823741296302cb05c573f4b724ea53e4ad644ebdf28b591a539c89a36aee80915fd62e6250a707e8f7f213056d23172921d12ccb5a2ed9786a90947dd895280fc02c683c52f9178c015ee26acdf31c032e6155edea0ab0665aeeaef66dad2baeacd00f627d1cc70f69fc5809a6811c8545bb19b008650361380710d9bc5c52599c42282b6c250b97fdbbb0dc38232735a7f490b8f338f466df8e688e586f23c155e568d6ee0d650b79e7411478f77074dd6db8b04f249a91125dea44165a3611444f210e136b0197d65f193078dde75f4774dfd8adcb525ec87496fd4a0460bee97fa605d8f8e3284c385b40db90bf8bddfa0414c03f5ca10682e2714cf4b08da31dbcd6012cc4bccf90530eec8804cd6ec28fc50c1f42b0d4e172c34ff501bbf9647a13b990102be304ecf8c6104ffb4872737ec4865cd7f359e7986354cc2276e2ebf83b98e5b601872caf05f54799376c097d97afcd1614bd433f2d2e00401f719c8ea987d24452085f3f9a1e63162c9527698e26dd24bee19e2d9f77143f54a09cca1e7835d8022c8ee5f1729de4d22b51477f1e1e4c72615e518e8272a9dfc28fa220607037d056a348fddef6a04f70efbb0ab2449797aac67809e3dd08777a2d8af2de8cffeb955bcdd07de4b732243ac91b2472387c738e7c8d01aa3ee713ca59ead59f518eeca568771009fb63255a42a340086b57be31f239c7195a0568e3c87346c7c9a88f0a65d9868a52640cdb818addf932ea286cfb2bfa29e807be09f5a61dfc351e86f850d261594f948f5a950d5536188e3b05dbb10d611fa05a383f7aea33c56386bee6fb77e7042b69eb908bb5c0019cad18d239fa6b8d8468a52509a6010b82745482c4b6754ce711aa151b06d6404062b255d613fd0c18a7934c73d4712f55d5b3a09047d48abd2a256a52b7014d2852e4bcacfae010cf2def76df204d8b2dd4c30b8bd9074077d86b50adc8bfad4a1634272cac8b32fbd160330d6ddef2613abf7ed471ce6fbc12b727b27c8f6096d1e1d93b90f9f1d40ce52be59421023d261c6ab247209fa7cafb4c0f7e2988f330e5747c7a335ef9714a73cdd44305d13c54ea166283574388e49c9b0aacc00c169a31680f98e3925b1199adc41f86b831fd54a018d170e5a5faef07bf4fc4a9e43c67642f26f83e3961030911b1ea871746c82c8a6b8d2614842d10c22abadac37b60a88d2d3e07a194a9bf428735f00f23c5a8714bca4ddea3e5dd1bec8d947cd24c80f4aecaa3746e6db47c73348ed36f350773aea9dc839cb60b826bb05ef9ed75b18ccb5dc6161879bb7e3d8c1df4e3ebe93a791d32a8e8f7522b5dd2e0eab6b1e355bebe33554700505fa518053fd3fff6375526e6495b34be7863d00db0a63afd6f6bca535b438053fb5b2a647a14cd70bb48949d6b882a0acdc053a354d2478fe76019ddb4bdca1b76c043ff194c5d4cb04a10068954f30d109129dfe72f5cb75c04479d54f7fa2990998eacb339b2e3acc439caf4b8a02c6676545868b25a8e120a432b770d6f5f8a5d75a79fdf48916944ea414c5f116b2b23f78f5cdd1e3ff5f1f95120de0096011bb607afa14a282789164ed8f55383e0c515d41468140b9bca6aeeb177877334c951e0481e4169200a9a5c06f7afb060fa1bfae15b9ec8546e759d4871889600a055d65bdc701a7dca740c8dd89066b54a345b10dd10633456edd2dded482e3e8cc03252a6c72ed6aa19ccd112235dac77b9bbfe39611b4b24d1f30f11dfc1f3f7be0ae6ae0e3401f67d54a2cadbabe68e03fa9de07de8740bc9624cfb855b527ebe7713e4c4bf9df6bda6e0b199c435a7d6b5ea668c18ac8f606db484cbf1317b94483e6f381248b9924ece7479efbc1a98e1bb1dd5037e0a377dabfd0d31458969360d891887bd093079f94bd1bf59101dc58d8603c7d06229055a92229edb31a370375723407a0c9b4e61cd73ff5414ace33642cc1cb8a4633d01f9a11d234ba0b7bd615db72f3a1db941b969fd9beac224788a721f1ca5b4f081459b8d64d5f57431faff1220891fc778e38372904d7ab7536693af80fbf7402e7b74d14e96b2dbd342b8eebeec8a9769fa8e67052766cf5a3108a925082cfcfd413b5d61299fcec15786805d99279f80d964b868ecbc5fb746a3608eab9b064a9324c5fda2b032fdeee1709508806b77e49da0a85db1e08ee761263a2903be579d2540281757a5f50855d526ce919ad66b236c61887b9af96e7815eaf611e58182df32f283f00edc02bbdf4e28d393618e5c2263a8bd4b81b2640c5835c1cbdccf9a41c0b96c863c6b426ec143eab67f91c669e82feb12882086fcfe4a05cd247fbaf1f6d29d93df6eb2dba0cdd502ef32c44b049b9e8017eead2a8e23b833699ad37b735619e7cbfcf8e7c5e1c839da9a8f9a0a137e1a76a49d4268421b2a5ff38bb2eaecb4de7070d68b2799b52dc2d9ed273e1dfe1e7f10f2a2d4cd5637a509ca1caed4bb98c34c4997d23900063a1d593d8b9fb3cbbd2dc418bffbade286ef28718c7ee0698b02233f221b58ff4a0ef8be6c3a32b31b13c9704e6076959ede8c69f8aaf94228c026465d24aacfd83bbce86772f4503a87c9b669d8590ccde7a4668822681bc0d4d65a41211cbd2f07b382e5ee02c5d6e4a1403934d0366e7aa37bcf8bac8949a1ccbf011537eac4585a47fe40d79a35ca6c4291fc2bbd0a31341ca2ebcd772b75d3ebac176617f3e45965283d2188709f585a0f65c6bf56cb1258faf0cf0b20af448956a70be163d62f9f74a45245630ee6d6bb366788eb2312965efb49e91486c17d95520271acea5c4edcc739c018fd3cd4b6efea383120d5545d22a98b43b9b68b34cfe95dd2492faf0b17290bda8d30df946d94b342167057d7830b74cfe9bee3c9a82624ad2ef3284e3cdc1aa33ce59bfe456c3ffc806845ad7c791be5311b308d734f400b03ae3a6a8152d2a1e655a177748bcf6820175629eae7bef17071919e9cdafc7a30ee083e8b51d00bae4320a2f3cad6feec37471e984536ab55917ed5bb105d87daea6d638083a68b7c41ce163047b1cf7d60640804a1f60aed684541b27f3b25c5071c0dec4b874a816922cf8534e575b3b246ff68bf7e28a8d46e041d931bef092c118af5eafa1da73c577cecc1ccb31c7d9843d250a5434cdf7034d3c8444b21b727b3693e18b10fe09b3dad6b400aa83008","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
