<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b12fabebb8c3025df8f13e8a31983918b175f8e12717a36b34d8672a861f7f5ee520bae6f3752bafbbb1581048f29db2ca12ef53bbfceeefd8b8530f003d13af8a74936d4f15f110b82eed31be4feecea0b90b88b5a3a1013411e7a1ba6ed167cade1e970b85ed2deec182defe63931ce459b2ad1e6bd7fb9dc8d744c916e42503081b381e58edb900e872823a7c8acedf3296fc062c4037cc84cca9cccb88c995ca6822fb1d6c608bf53246f543eb3bf12fc862fa51aa4efa2f1f1db92ccdc5f6f1ee4dcf1f9d2c35ef915f1bfb5ff57292288029971eadad447fd7ad299b673bc1562d0d61f96c2fa2881c34b0a3b474ee980fa5f512fa6279a12b566934d2499fa8e96248266cd95adb7e68d3621233b07ae7c89bf80d77179608409746c99feedf8a27bb391ab4991410b9ac82005450e3739d8ecc97603d61e43ea88bed2aa263a6d0bc3f10695a08d1a8f68128a9f79cbba1606467c91628871bb3530ae0d1c817dbd83c46b48d8e2f10ee5cc33974cdc56cb19022ce0ded94cbe32424c54a1750c3596892efc390fd64db7d2c43784e540a20ba9c16f7e58e0084c9d9a8bfb0d3ea55a9c0523b84b4baa460e2a160d0cc8530adf048c953b0afaf534ef9518357d1f928c56fe3110a0f9dd1223a8e562b6a7bee10df6a7b6bbcdd176900ff538b4cff8b91a81d7084ec32cffb825700af9299edeefd8d5805a55626c7c94d274e70cad20469a775cd98b65fc8c3c416ce44d507d3e57b1fc0472e8ca26a6fbf4ea5867d7d6f4d3733a1a8f3479cb9a770846b8416342d691ae909e5bcd67d395a92118bea8e79ea9bddbcd62053a7bb7350072ef91bc61bd8f8f478d0fb62bab4a938cd1100f40eb8b5bea5e3b2d0dd5e95b7d9bd6f2cfac867cfc13a6fb30573862d46cea7fa1f286d17d0c7b1a08e89c7a4c78062d09ff8e269ddff9021508f7560d897d31c98cacd26aeb3f522975006414049bcd021529baa26cdb993b43d145eeda80a8555474cebd6dde4420e6f15f1dfc870b74e5c342f2dabfbe0b71d847dd60fca57ca8090a6470cecfafc2df39e4af648793fb8fa63b1b97ec3c3bd85d7b1ace96006a53f3cb364a637b83827e03d70e7ac7d0dce8ee20b48d7d17e4b69c79fc89ff9360cbea354875feace4e9d451b86a3982132bd2cd597988e574c5a50f6b81f0e8467a98ea27681bd566a1187936041a569077911b632486738fba32864fe73699a277b07b24f12cf0e9676ce53623751b1d03d4f9f86680f1016bc855cdd861e789b663b3eff0188d5fd06dd8c64eae9d0acdc8cdc7f8f9da255f479f4ba95d3f907145bee92537a16140479063e8cbef9296bdb9f03f1571aca40b374b0d44bb05bd397f3637dae190f1e656f08a7cb25b2c666b0506830ed4db4f43e3ec9c05f225544b350a4d6073516c5a958efcccadb23ffc7a20898542a667c9e813a31f4898c08ea2b019eae0a524aa025be9e5ce6978729104ca67c1e5f4322d44abf75935575a0b24d86b6f188af5cb4bb1c00c42ba5745333b7f9ee05859c5f88652788a33c0ed484274c4c1d804936117b1f2f4a7ae0c0e60285317fb3b8ceee2be9a85b4890201d6504cbf48069bcaa857215dbadae3d89f643b5e7a3c105f3966af77f990f2408fa416b639213fccdc835c7f8d5435864032577a190688cb6a081377638d3866a21a1b2bd57967bc4b284f4a221172a0090db9975a53c63d1da08f110ae6224baa6f6af9a91da9196bb5e54ba4cf7bd51715c21b9c36bbfff1117723df24afd2a65b2ba4ae22f449d697297d9470fd5a4f6cdd69eb6c9dc7c7d874a612386ac6968a763fe6178ac37b32021598901ac936f0d3f6d370b7bec6a217dcb75380b1506fca0d4310c46818c090eddd31036a07a8fc43b7783df03db7bbba6380acc4c2c80d1d9a81e798051b0ec15e06601a348947393cc2125f2130478c0e2deb69682e1535bd05ea87577ad8662a3ee28f672bea12f88561c8015160f12c2d1fdf33add3e9de9fb574518dd8ec179936ee2efdab5a9145513128f024f541649d98b58467a4237434058e75ee7d00581b42f6244a0de200c06fea27042976d3e9509cc3f043d670cf32860dad4392073b299909d81fc906c587884befa3c5b775305aa0c873a61679a74f3ee2415391768b9846afaea0288ac1eed71290f44126a971cac6005d853a69e3cf434484968faf15af040d536e1e85445d6d29c7ad75789361925254625975459308d259a8159e9896934decdf372a477be7ebe9806cfa2f1a61f158ad3e838ccfdff5939b0a939fee33d8db160002d373be7ae466a5231bde1d4547b54879ab31b52b72d0ad98a9cb0622b2635e5583e74c5d68d83895bcbbbd50e57be86399c7b54b9fc4e4e89b428bff6d0a12bbeab2ad8b0e0383a0b3c5b1de0bf6d61f819ff887b335cf5e41b5df77e12e8a2f23421614ec2cda25ec379849bc636878533a98c5b54e891cceaa572ca0a5a00df4f4555da1a814e24598de0a593656d9ae5294550577b8876b9af98dd6e1b0f48ea9cce7da1b3e8ca3c9bb0eaed04222632041e63ceb51be1cbc91f584447c035fcb4f348795f4b5b8cbcbbfada36edb8bcbe1b32cf2e5b1e9a4addb7db3e798df03a6e98f23c909b13c19db6cbaf0a743a1109cf080a749bbc4f94dfb9aa5d5d079490e1f8e117c8fab1570a1833c192d2cfedf8fdf62f3b9f0d06637d54963223ffe471e98080fd5c11f8da5a8fac2c45d32ca6bb602a08937f42516c0484b2064ba6df46ad8c11b3cf262fbbc9d64140908538391426c07ddc942ea27cca745693fa5f00ec331a4cef4f5923374fae43ae322aa2dc49a9215e37e9e3c9b47d6b85cc6c0b061ece3a12e362666561d6e6b9efabcdb9b4f57d1f86a8f95440863de096279064b3604f8e4c759b273fcf1bba9dbae8a53fa5436db5ed3ec685a2490483826e2666e1c2ca3ba42cb1b54034c7f3425148c5a3872d0a429d148defff50a96072cb59d143a55368b382c8aeee320c52d071f60c0cd62da6f121c585a16a80c140d0d4f894d9c65665072515231c295bbb39b3c33561291ea3fb47efe1b806000a6d12264d4b3b6d6f46ad3146e8fedb1828dc3ea771cc6fe8c49d5d742e864b7d10b6e4eb813270cc878b731585a80353cb9835345de404f80cd7f431bb0ab9028520523cad91cb958d866e6b37ab78c92f54cfb3747bc5e9f9e99d136d95e84c9a70fc1351ed8dbe30e9c40e472a4c6337e5dbd169687e78b7093907b8e675cdd216f80a84c5ea3d609dca8d33b8b7d8661a642adc0ff612e71d817d6917640d6ac73a0fc6c51178eb91e986afa8ff78a8650ba89219ba016ea77c2892bac9823fcf32aa53e02f8a03a4d1f4c9603f918d429b205db7a6ef6bb74563285576815df13e80a42acd71b575374e26d30efd5a5ae26349afef49167f2c019c0cd610a9b59f00b56ebda051ebfef0a4b12ca3db6a2151ea4e8157430832e219485ec49436678cca29ed7be90faf663f7d091a6058ab60616aa5a0eb8691ad02bb01526f5f5969f3fe73751e5fde862cbba34e32b4cf04afe9121075bcd8080751d03713928001b25db015cd2685b364234cde381589739c307c66ecbbeb40ca9848e743886cb30490f4ef3cc604e92d81332140d4fc5de129aad086c9877da87cf80f973b8c225b2507d814e3407d29d802eb64baa31bc160c16b16ea62a69af3fbfbce88a10e77d12ffc3239eb8b9622c99634055292c076634a9ff0368a6584b7e2ed1208b17c6faed807bdd93c3924592a8e254faf6dd9557caf48d9b1ab3ddb300b708be6e6336fa3af74e912e4fb7d42bf2618a43ca4e57387d85bf6c47190f2cc72b228c5394086aefb9178c41f54d2997231a2b554f44ba4ff704e3455a19cb8bb9176048ffaa2a3c11e97da862f00366f53c99e1afca734e8a4937a5b78ea3d78e8d9d27fbb6ea7872696a3edc8a44817ffa21deecea8b695d3a3c10be63837e016817ade4e5e2c841346596068adc800cb5a82a958048b4ed5b6e96cd3d969d4fd8340e6c557fbd596a590b12b9ea17a07d642b0e099ddb5e61a30fa135caa50b42ff291d5e5698720b9b96d8e409b76562083ebd2cb581862c5c722bf4e5168ad52bb1a6f46fed719407bfd13d2ff7fc41f01527ccc3156d661e086f7444f62cd0a49dc930ad0b0044a04853f24d27e2ff18b404558f35dafef99ba5ed80d4fe3ad4bf1265abb5b6f098c7686b711b841b5ccc12793ff645679e487a44c6d5590a2cdce89c501cb1200509e0873c2df9bb37fbe968e549929f2e9c44f1db1bdf43e397dbc85307ca0ce8725296ab361313d2a45144b369e2c3938145f831b7b14f8361bf71c6506fafec393b60e1e31397ecd0a0e7f7b3f8ddfb883ba317253154b967c5bfcce3cf5fa8af0d2cca0de50c8075be2bfbc3f77cd04d96ecb50015204221e6dff77e1b87b1b4eccc7b67c8aa2c2d685d0602142ea5021913f7c9811a3fac62b1b434b4430510d384165bcfa00ed78964516e69d5ce6613a600a5b5f758194257d4ba2d592efa072ee96bb44b7d6781f9aedc7f6acda9fb5fa0aff0b0ea362ba90b51705f69d33dd1695e888a69c8698ae1543635aa78eb47757e8b4ea453c27582bcf67fa0e6d37101f01fd4e1a7959ca3810240ef8857103520ad44a392f07a4457a0dc63ea7c8aa7a91e9d48359b17958fb492d634259cccef1c21aafe87e189c858f09bc291a58a86c36e965ab1ddc91c66d5121991d32ef2ba3035ebcbd9e9d494bba64fe4e7b2dfa7944be85fd07028b8861a725031ee2be0873c56481b040096953a8859f2811b6bd8582638b05e39f39dd2b6923be56b3def6936c4c7f495ac398e9a290e9eda14d77bf8621a541d976aac6d61dc37b60f8684cefe47f0eeed31858ad908a22f517ab6de2325a2e84260758a2f8a90f83b580a0e5faca98976ae27f52acd9fc03bcf663b288ee88e8022d8bcc671fa76180d6d9ec4e97687b56fea0c11c2fc858248d9d7d1da2700461fade75b91472ba28cdd1538a08da5a102a7d03611468844f2d34983cd9794e4c423209122a3b61b7d1c05c6260c2e9d7da873985ccac25ccb16e7466655d686c60c9e9c54804d831725378d08f2bdd33c2ebd8e3eb4c1cd99d8097d1e6e1c19acabb40a51690adbbdc2efc4728d3dcca251361ffa0e6c4fa9aba0d5ba7fbe9a8d2fdf87e0c3624c176098082259064e28b255c68ed01a0cf8b777db9905c7e36cecd2de3dbd55547c7d4c46542f458d5cb74c6e4d87f7254d69a201a41b9e97b310711bcb323f31e3fd32507733a3ed4defa994b62c1bbcc7b66dfa47498ac502e06541c5a4048478279a1e6e648ea53d01945cb3a3dafe9ae0e3f64790f0f41983f6846c8c88d33df763ae7e4aef7ca40e61c3426c80e514b98a65ae06096cf1aca96484316900f78778492af72b7ac2f501317047a1643223b673d9fda61f64802c222fb3528804fdd4e6d4356336b1fb528b16d376ed3d62c278fb305eae268d9d927dde989e8458ab9cd29f3306a8f306306fb06908636fd0a5c735f2bac207613aca4a67fce81340c3783a28d625a06daed99d2c3917ba92cd0e4013d194ddb44b08786223f9b9f3c7c2f73e642d2fb7ec35c0d2b1d2d012670427effa8fe33bf63f3c0c875c3defced9fbcca4ea67fde76c632ac2312b85d8a879154785359feaa6211e023257f288935433ad241efd139b3b68d371fcda32562996b11494c10ea8017a4249643ab90658d69a860713a735bdc4f166431b302aa9c756b70df881f7e7e9687bbc61630cfbe035ed2d140944a97bcde3c19c0dbf56dd23f6ba36d08cfef1eaab953a940615814af5f7ddf1de580b3564fbcf7c5dd699a63a1a501aed9837bb1dfd10462f5db0de80fe5273b2bae195296de7a8f2b2999641a94fc1297dd8bac210d931d956f0a6d474f5a85fe2b9b646a3f1dff34120bda7af4ee6651f364a4e70b906132a864b26e8ce606878e784707af2dfed1a783ad6818b9e0ae19e4dafadb8dfeefbcc73944ef1b978229bb5d68549e2392737ad7fc094fcfb2d1e80d46861d9313f4a523783a19f1436e46ba89266f8eab3074c28bdebbb08997a71275ed86662fa6a8eb7b9714b385dbeca523a2eb8af86bf66d14d64cd3f036cc6bcbd6fc5e3b828f14386d24500e2bc1b93b5f91ab2f54449d49eb60e207df4da9fc6e21f34f9a2b01f55a09b52093b05dcb2bee98b53a6ae9c5348959694650d11a7b25020cd1094e160d6e6872913b7860cd6a2d0172fe218d94a3aba475f5a2f7e8eff032c02c5fdbea5caeb468f028fbae39ca51f275f396d2cdd13e2a099c1a4bc3fd69965f36611f63593baff3bceec661efa037d20445f25a6553ebd8839f04b97f3c1c4f745610918d113cd83f60596dde66138c2dfcb39c3b88845557d53fcdb9a70ebe6ba5900837d75f0f37313d4f18b61590d0de95375b992a92171cd979519ebf0019d977ce584af0a7e358d54cecbf056671907e972fd199b42bb3a7bb551a3b9ada9cc8c001762b82662acede281ca851ff7c29e4913f16606b5726bd1eeac4b4baff0fc9455853d726c7a4a0a7d14ef8676c0d1943d34e4970f3667596c5f7203424587c1b46e9ffcb60acadf047da589e4b9ddc0291256e0c40b13a608d634d05b34c7a98e729516660a812c6a761e9b08e6b92b2c7c8bb8db89a90b07d4241ea3cf884f8a304b5076c46c03d683222d6c663bec2e90adf0a9187065a5b05865685450e372b1b4a7adff7c3d111864f54f09076faf605d1e93c0843bc2c4fc96f408bc7d96a0a65c9461ee71bc311afef91093e1b7df07efd2f45c6fdc0d44e185b7e4c6505627e97ade547a9964f5ba8d37fd3eb361508573db321615c1fc7b0afbb450346c5066f54c2753ca1bc3193f4a5aa26823147ef136381ee5418483d385ca7473261477cf5c6a431633bb6e343be9807e9c68f82d9fb6b19c46394bbc2bc913bdc8e8d4ddc9d2261d349316d0c7f075694e3b2c861c93d016c7d6c3b69d9688f06cefb24bad09cf08113fd0043e3b34eb9c64d69763e509279518aa7fce90731e1f1c87d2c35780fe2f63019c9336056663e3b0610a71f0abd8cd5f0c6b98bc759a3601572bb92cbacf583282b50adcc3c27e02d519d1cebcdf4c2797690f2a16d8dcb051b7b2cd3784ff7dfcba66407dd0efdfb642eb1a51eb8a7cbe10d7201dda2a4bb3409ca52758cd8921c1025a6980da1e54d03b0c43708d6c2d8240b3dfb292e9dbfb1d00477bf8f9f59ab98a987a8494d470e58677117b3927a2d683e56e7460d7a2de114d3e8d6f680886b2499d7dc953de81a91222240b96effc2cb924b8faa867194395ea1922f6bca5f19df4b6382fbf3379873f531093aa6e5467372f515f7a99419095d3be716b7b8941ad80c4070f0cf3640d3f12ba189a598ff5088a500bb841ca323c087984d406c233f43cecefca6b31d3c0a21795462b60db09bb128b8f6d09c8969e5ffbf256b443ea3ff5c5f07420629d46a22b9b2e378369fd7e677812e83005fe49899ec91df9152afc93ee7abcbb16a974735d6e0192ee9b86c7fd0e45ad225604645ca3252b05a2c8adc3fd1ce2068bf9cd5f00476a03971222d7097a7c1aab429f8756fb31cbe26da404289ed267524758f08fce47d7d8f4c7914fd373a513b8ba67d0de027a565946ec7c215cf9094a66a3281adcc0746ec867f4d96bffe03fa1a4002bcf19adf8394ad757b34f0e0c23636b0792e4c744e8ab4c02e1f628bdfde8299f9ae772a8a49e5cfe4949804133e5374af66a1b9ad75256aee6e96c2e027dcd0de8e1ad3228a4463ecd522b8d4a0b9223fd86f1608f2003475ee8c41de13e72b1471e6a11a58d7d24262ce5058595015c1ac4047bc84bd0f43a4a74677f89f3ddfea0eaa144d31ae31af3ed16c302c049becc5ef67d2b8a6b426cb9f7f88db870e7862263d05178df6cb6789756ce56555ba0a47f419c2198cdac95ac067f48922b6ab76e1d829222bcc9bd6e5461e19340fe7fbde0c4916826504dad88c3f79b889eb4818a02596afac9d7188812037436632d222c080804e14faf81c08f1b3ea049bb2ac90f81dd803bf8d6d8062984020d0af61b43c23e09e5cb39c9a2ded66260a6947d13e8b1083870e61a57e844c9b997dd45ac3c56603cbd89e4e7bcc66e8416157104c6426c10c11c596ee42ed6a5e4ac1fc62a2c8114dd8563f517910ac909bf5349133c93b4220f5d8781ad096348f9a2e5300ace193463363687a310e9bdb4d78f5d45e9ee2913c4d767403bc0eb245df21079a29ebd4be5f3767937199056c7a2669c26296f83903b676dcac0b63d5cf201eef83f60f8e7af69237264ec0e8d877a6eb449f69e5c3d8ac3e34f93d1bae3710703ccd5438f469e94fed36730a3679a4a2004ffc405562cde7fa2f738f2e08647a53032f00fc112979ed687c722736a20ca8235909e5d376a7dab61cec0afe7f7266e1d10b6363252994974d80cb99bd56b3e55226833e6872c5cfec10a30bd14bdde523960d9cc28fb2779662273413a1b939100d53f552a31d36a5c401867964c2102630a29bf292cdafe0cd7ff7349aab77f167dcb73af2f7a49ce56f72df2482635aaacbcbc5d9b8d5bb77a407b69119bd3f6950dc73f6b9b7181e5da7d90457159c43e334fc22dbef4b61559d7f89bc5f33dde9b35e95cd0f31ab792b3e59be026b7f9973756c7436b0de9cba6e477339e11e688e1f900494a915225b0c05a1dc8af17126e6d6a1393de7e18727ca39206be1dec0770bedf3ef62f5a940f09b28caeeaa267d2373877ce6e0e6d2b40fe6e28597125ec738acab5f17e808f1ee35213b0c4e9a9db6c100c2babd5470157328e2476075e59ac4d4f32f5a3e3383af8ffbf214a049ee911281c4b748666ab1b6a040692b6c3b0f616edeaf52d79f9d419a2064f4b94b2e8e5f4d1e53d4fd8475f4344585063a5ee17a4701d93169b1113e784a13cb2691f0b6e58aadf603c2aadc501174c15ef821338ea548e14e3fe3bee121021f825c7adb7b106f4e3eeda2faa323eac2d44bbf261bc93232e32470997bd39db671249c7e201c0bf04e5925a973a1e7d6da26261e73f65d516892f2764a2b0040a44827746a5598ded32c7a996e815908d6e8aa5ac105703b1c206085da323dc709a6351c2c074235ad3d79c34ddf52ee6c90fb57fb775692dee9085b3a4656e9a7a11442e97b278a14e6067c4d7ddb0ec3702efa4a2389ff30e87a037c6ad0df00b56f49df32d9dd1e26af7763fe822fc31e9588e3e7d67683001fc3cca3f9d82ade9da7ea824c1fe664c223ac024f642de481e6acfa75cb26ceb3477d1120c0f90ec85f718dfd6d53bc4c13f7dfa9362baf5f00194c4e0eabbcd514081d5b4324c214b3e57e55e0208e875cac063e5d00478f2994ce4679f0e44c54e02494f914d74d0feaf55939a07060086d7ad3e02883dd88c28276908671ef167cc1d1552e5c7b74aab5632ea2a2414f2045aebad46656052766af2b44d819638b6bc1826987c2b8692338a3050c38b16c59530658bd536414e4f24abcb7f64129966f2542a0695607469a6427e2062b945e7122c4cedb7aba3905555bdb78ed55d90bf223c6635b897c68e4f5a5a66dfc564849df5235728eb2f93e8aa277d36ec7cd9104e4f9797689f611203ca9d42e47c1175dd13f962185606906d9fa4f9de3c6104546ee580b90baae09a735adda433ee33eb46ddfbe0bda1fc3bd0c60162e4a165ae962be862b247689e1379042988307b6f81da8051ddaf7af5a3dcdf4351bdc8d74c716e2d6595815a3f69d34f810b6788a49a5074c55623691033d0a73254fa22b78b64c05e0f2d83757d9c8e412b6348544b51232fd98a952fb0fbb755978ababf52a2ee7c50a607907c522d5670d01501432d444a97131551cf6e6bb8c79d1dfd31ab84c272f2ebef7413d7e727c55afded12621b72e3a90a12c81d793016a0b5ecf46dfd970eec6fe71345f9aa3c9b862e80cc4f04847dae3948eb79f2d0d8051220e24b4453f27dc3447d4ca810b0d673d7df23dd9453da03a93f45f1429232abfe627fb2e30e7711ded5179f1c7dbc2be9fbc9d4e17e4b2e42cb813caf6410659683f2a43cd1cbbf1872a8e65605d2e8a819fbca72224e02dac4b6c27c24d7087b9e0d4878ae0531d74b66744e044d202286aa4f3e00a08a49f163ce22966a42df881519dbba079536d8af0c6d337ee5c2cc3fe140e05dca6ce40d26e09c3329cffd06cd09c2e24752a059cbaba949eb60da81d16c0e32b04e8fa80d395544dc6a06ca1d37900ac4a1bdf673eae3fdcd25511c169a4ee1120f8e6a53007636787286e7e15d0efbf29a5f3a1ff1ba7265b1cffe82b135537c5220baa328c42451e98cb95194b7fa720a3526a20d7d0e83057ada9346fac2ff3d39efd1651731e37e3ebc4abef1c5e186e30c0a475f5adffbe20ee02dce52623b5bff05cc7a207624dca4e40a1873f32721c5fdaf052a4dcc84f460e7b7a7ba4298bbfa2a4b2f06289b8d0c3581dc26f4e180267ecf1aa742c7e449791bac72a275bede0e9229517feee146ad978f940efce2ece101bfd7f8398e0c9e3cb5e5739630ef7ca6961d0689ec1a83f9089fa8415d2043df695b0826d8411298b0316e89a6b24465096860a8f019e21bc72be14f6f9dfd599230c78c131ed403be878517ea49c9fcf5c855d574974697d4f89808879c00bae9405d44f21bb5c5d3a37ec035bf3d003eb620278abc70a58c845aa85fcc7974a8a69a56efa2432d53b826c24755f09cbbd77642081c9c0c150d6ce3d93ddfdf167cffd46b053f9c39d4a5adc0eb62e052825ca29402e777d1d0f74d604be50748db48ff757bf00ea736a316a86a72b928ba2422015ce01cb6703a033362324fa8d22bf4e8a086e8136ae906647c8beb6366508736f7499ee6568ce3a62fafc656f1ed70dba8d710e8d877b69115dd0f784e008f74d1f8b43c493b63c04d96db1617699526d66688c043b3ccc688e50da6994ba976c76bd8b2cf66dc7ef6b6d501f7f49602a67eeabb6b294bc4e539175287e14927e6b12dfeecfb69bd3d4d973e566f2e52d1da66a6e2baa02ec541a02956e7d1e1973df909bb85807ffe15b58786e5f4ce75b87056a42af87ac378af6e32cb8f170f3acb5672e143a30661e4c933bc1659e0dd13fa96d0951dbe0ba08072237ec2f4591139ad2d60fd92ef64193836c28590baa32693d86c25ee81311e95cc351acef811fe2a4c37765bc292f62bca12e6f724032eafff2056ca9a4fd354771ee050b7d93f83be35f3977aefddcad3b25c09407ba9d246c3df7d83d88a38db46eec23e3e26f6e534479e20fe5f9433a75901b6226cdfa4d62bd4bb0c29afff934ed80fc960495bc8157a8c9221da34ac38d52f32ddc3d1688987330e6afa24fb528e9effc2d4fbef860047e465f46971ec1832e7ab7a75d78c469985aa0b959528710bb2667ca42a607bab7884a1ec231ed59f18a67e7e695b47b64fe0165b3f21d8566ed34a9104264b7c91568c028ac46fc37ccee065ea2fc4f34cf7ad0794c875d28e31b1ea70580eb7c0acf15cc688510ef0f4ac65d15527cc2dc3f3b25707ba2891399f406b2e298e7e0d75d3bc91d0825bb9a3be709ebb2ecc31f4053ceeb9c2c4600a1299f8afc19ff094092a651ce2a9723f3d9f75be54117d97688fba680290a17c7e7ae88c2fadb3547c9e3a7a42e1ae0114e413f522db43eea8981a17ad699e0d0ea93f8d42d3ad48992fcc596a9b79b444bc50cc33cedcf05974c8d17fddfe4eb788efa834a924e47c6fff356b8ddcfa51f6d75be561c7ecf65bae288a86d7144541acba430b9d45baa8696ed07140784c1e1cbdeb0757a3a17f3332491bf3cd30fe90a6ef3616baa533a53855ccddb8f5a5568fadb4797d6f197be49f71fa5899b140f249cc1f7322140081223c21b7e2c7d629f31581a6109726eacbd5227e86bd58e70a1abd13cc4c6667e85dfb31db0bebd2832042eefb8a095c62bee6722d103f8e8d6da91f91f33e786145b437232f39448993d82e98155ee006da3d725c56c5633710a622fee1c995fe30b5ae194d69faafd6bc8ab130d1d126495e6d54c53ade665c2e8947610e990e826231f4a611ac01439098f53e1fedf0c8dfb3c8b033aaea5c6698a3f9bbd464827ae4a964a086de63f8275292520dfc317b931c58c42c89dbba5b3ea343c622448b0efc2becd6caa34eae8551401046daf659044d898b0aac50f350ac41147c87aa162d289e31fa678c421d3ad7a73da6bed8a67b002cdc8970d220c99bf407073a08d67c6a0be7ea8f0317016be242641ed652c714fb251a7dc1f9ee40a364d572e80f8bf92b45ead8101f3fe63f463cf1072a8281e42ffafd78561f440e6b3c0b69e71d44411d224be79d6d65b5e7d01d9c7267a6140400c78c4a029ba4620c799d701f31523769a5ec6a29825c5a300f0aca4e810639dbadbf247bb6263900e54557dc8da401f61e8ff8116dd8b9cb1b140575a2cd41554fcf72103c932a8c2d3e64344ba6c795ce955ea3ea3f2fad04d1ae38df6b9b620633e7a0625481140c6fb7e4df6929d9a9cc79a917c966cae22feabf0adf7b58d1965c823d0bd79c8167f9b65e0ac836df5e417fc60194feec58d2184a70d9a77eb1fd3b17c5b6ceae90c124d6c1540eb1ac7419fa08d0d9a45d9d5f2790c6045b5178550927409eaeeb6c2b0fd1ceee9d5b7ce63aca2887e7bbc67eac20a93ae9408e3f1f0b869b0b982d8597fba25b0b9d3ae44933fdf7c4eeae91d7513284f635d2f406e5203be7384e0afc3fb4734b834e5ceb7b7b8dae090222d8456c7b504c44ab9dd300ebc66e97bb25443849fbb4d25e7369c4490c6c99ca6846494df703b8cd26cae04dcd87249e2d1a5892409345ee996cafc5ddd116bd75a41a68d02a113b3030a65edfd860c00b0d33cdf742e2189c022274c8ceb39ad37b3264ceb507ebfcbf986cb50854b8666024e18b4a07b7e9384826dd834d92c319d747e841829b4dd66b5c31ab338436fe47272f9d1571bdf28b942ea33f2c336f404b7b9de2f8625aadecdb6c8e3db117ef8404ef29f8798b2ed88bfcff365415ea198e3d99d8f40cbbacd217ab7d5ed613cca1899d27d53cb816970613107e2b8d5fc044e27e90d377a894304a761b606886a095a3b8ca5726e48af95e682768ebe49584d17fe983d6638354f4205e4b04052d6b855a03a32ac22f988ccb7036605065b6b36991e9f37acc577c0a6756305e67cd67449074d7f127f1cdf53e6f5c180880065fe32293be0cfd568603a5712519ffd1f7a232bf0cdc875375be3bcce44c61c03f157aa8b45ddab986eed737e80895f61fe9f9294181a21b5eefc2d9a2bdbedb444c077a2b35e5dffa2b8c41e877129862a0cc2965aa0e54c4d372d292ef5ce0db5cb53d0e6df073b23affe66b9871ac4e3e7488272e2fd20570c3840723509db55cff57fd36ae50a99e6ce7393e6ab93e970b48950358ccf7a461898cfc5c12f7bf031d69124434e0058ef6178ebef104e4d7080e9d43143f3e78bd19d5137612c601a6418041fcf7ce3808baa649cf4ab1c990562f0b994cbb4d8713abebd1f443283fd9f0e9ed32d911566a75b026a63a4ec43edc5cc82481b57131c80a2e4b920739a11c07c328c00197ffecd1f6ec1f29145d42437fa6b1ba90bae6806103da504d44feb009418e005729d735d2625fbf0776a25a24a9bbdca92d4f42b0523d267509b43ab0b57c431fe15e33f81ad168e16fde5fb183ba5746cbe8f3565e79cbcebd46f8baf79553ee54d8507c9053dfe7117ec23bd8bb7a47fe80e2997ce67def27ecffefab59603ba784e02a0fc2a2b30366be2e52fc165f776946096f179148f36d18e956310f0a538327d00fee3bd3b703e0568c9e1ab3b2e8f35c0d69ca32eb531f7c611f48f3d19c8ac46420edb185af86ef6c2cb11ad4ce946ecacd62758efc2558f0f73b0ab47fb8f5d6bc128e71803f26b2b2cb8b7a25d7aad25c400f035cb489c37f623744408e07e6a80e6d1fee1183eb78aecdd30fb5bb6e359703a2fafe6517d08e0fe6d21f88c96227e8c834194047410d66a581211294be388b606978846b6c2fd85217abc6b18cd16b35676b12a952b02862487ebc2b88609f393fda2362a2877e6332e1ea44d91f5193f7cf360c1bb0aa14b84917b8ad09ae61d37726c1e07448e846a13c57f9fae14ebf8d43bb0c71872d9b66cee589938dbf62dd2b0db284058421998a91033553ba20d09448f4472254226248628c44e1afc2450cf3ff473129ca565989750951644ba794820ed07b88635b84377913c1ec2621836a8e177b5089e9ac9d22e9bdb7501f97098735b5c6c61eff0d00a3cc8ce469040f3f428bb60f7451c96cc42913d018f0b200187ce9cfef3bdd7f1dfe9439f8500219e72c7f3f37c685a728ea5ef6bae27fe1d4722cf79b8e034b63bdf0cd8fc723120843911db30aa0bc63088fbabaca8482d9535e6d84c4ae07624043007363341aa94cf012fcbc3936e6831138fd58b81de09b20261e4e9c832a07444474f88c7779c9f497961d761bb253dcfed133df4def63a6e1cbaef19ab8686d50a2827f0f7ec913af35e801e073b9475ff091f8a6fc78946b58d9fa6f69027afeea8bbeb0c81180a19deb817e6aa8d5b8193e0f51b0bb38481a4934144bade5434abfb2f93d0d1e52049c51b8b6acaf5e251c9835bf1a066b6dc45c908e6620c158a4029e741028c62eb90af82accc0448098d1e8e4e3a5d33ef1d7d20b0b02f49e3dc77ba6bae76c6b0da11dcba938d480c51e8a4c48dced89e06fae3e1bfb89d966ae8e78a2c533d93d650a7d2f1d2b2cdeb11831cff3bf6c642b162b492d4c40bdcf872b0d70b313198706cdb2a7ffacb3ce7034a054b756af3af2a59273138b01f796e393b187c9e8daff9fc0b04505bb494c71be978442cd64540523cc3e6a9e57df6e198951f779dde944491d97bbe145b9ac7508bccd71f9b70510891c7ed0511596811ac41fd9a73aeee159977c5502210e903ced85aa39ffc9a7cf1577dbb38bc83b5338620eaa470a056ff8b982efdb3edef6d0196905c378706130e101367b491cbc7f46e0ce46812b7075cb80c8ea565b4539885e80889814f51edf5bc0929c86b4e0b47ce0e8e133bd042a16c1eadb701599ca6aa0c9206dbd3574708d640e24276bdfe42aa6d35dbe0611111e9f7bb42ca6dd91ac02ec30c3e30367099052fd93bb6a5b60f74846b46997a746ca4c0436aa47b5a4185d2abd343e25beceead0c4d050e10df9c1f7c7149c924822f322b60d5a57d6b406c25f55ae35ece0cfb17f33135a5c708c7ca0f1bd0c75b14d0ac817d8e2cff66f8437e29e989c3163903a28a2357860cbc11a0968b3d82cead6d6d86fa6b1c6cf8e2c7a5a4912363df1232f4767295fc1defa5ec0a54d80385159cdec681058056470d890838b4582a8f75a61b6389d560232ae3ac10cdea907ce13a7204ace1bba4855cf353d2e86e3170c333a84f3b0e7fea4bc14eaa11ab95e602a120cb55fc94fb1e2e533262845fa2d262c800fdb4926a7da831b2f9d46889af678969a8cf467c64a04fba52395f1fe6272904592dc5b2e18850f39524589d92c86544f2657ac3f7abc2d0571ab5e9f71f664796cb32b32defbd7acc8bc22acd168a7ea8f302edab5dc0c25109db7979b085199607a5ffda6d4288c61f7629d558b84492b2d766052cd179c78beea70ab84c565808a5c16393e2c332e97d9a6c93dd3aabdd0d298d16d5b60b025d4b53e00cb20bb600dc746b7fe3226d97dca35a993b354b57d3cf663b05a4ad5dd00888994f6821035f27b85b404b333c052c912e0a2e1ee4a18917bbddf7d4a96771a65a7f00cc41d1ff5ccb7e0507beadd1977173300868ac1d4f65b026c8997bcc03f1d48db459bc1d6174e7904dbbb341dbadae158766dc2eb47c338eb1fdc736ec47bba80bbd9e2df1b4a78c3b85d580be66797c7b0588c494909ee2dbdd51c5e3f21210224156f69a9931d708dda499ac0dfd786150c19f79b8a616d6feaa881c8a39a6c56b21be0ecebd065c3800045530ab7e2625cac775460a3737929b97c582d7e91643623ad26d0597dbce67469395eaed4b9da28d6fad906c8c98dbf9c181102283792155c49420b5a531b547670fe49b74ca6a6b22169ef3acd00644b640ffcbc48c8f6945ca7d77ac19970648c5fe434a574bfdde2d3563a718a7a4730d096a57551956b6cf07ef468042803379e5369d5f2d62f53c67e19877f4489def523e58d0763dcdd8298548ca956f821f71d58b524a148c68f578f0b5f9640e02b29d05adeffdedd20ad9b2c080f5cf99b78c4ca83b70da20bed31d8481d4ce7d42d83dbe38022a4639755cf19a80f576337075dd0db08e34194e43cd5ac2391dc93866bda10790c44f4f66f987970f02e5e2e5a44e469082ab72ba1a5348dfdad3a58ac9e33cff61cec0f640f5a0d7bfa5bdfcdea7b3e8c13ada4d9f8567805fcfc46f203212b2ff638d4115cf2737e41924ac97d06277f91abbdd1f6a78138aaf285a70dbe85feb28a16490a4f1e7e874094b53faaad92d876c54ac9561dc63db13673e3e7825340e4dcca4a55e0b41a2ffb467e22324c971c9e8c1d82dc6881345d88b66f32106cc6c57a0809d82504a1127bafb03b35d1024e86035b94d7c00b2cfe4ecfb51880573c954aa0626dbabe428bb162a4fb3a6a93cbbc2d937a6786073e5430b7f5205aa4f8b3bf8e0fa0b8156635be4c0a2ba82139b67d900110bae65d2f1511820be31d32153bd4dba7f0636393842b01a121909ed0e8cbe608379ff0016d048b6215a4913001dd5ac43dc339ea225e36bca34c30342a17a660edecac20772a7d78711828cb9fe4c59b203a584e508a011176b08744ef7e20e7adb42a96376ffbad357c0883062a87ef710c80de0e25b3794ba0347e7a47031b79dcfdbeaef9eb3b5177a238ebfe5590d06eb382a73a660da8c57b4817777bc130a22cac8cd3c1485fdfeca1e4f2b803185fa9f9cd964f2d67f7b7c1d46c550172349ffd2a1f119036b09856690ddadcac4444081c74813f3fd578341e1aa3b46ae38c6d7a3e79cb645db52c71037938898c8f2d02259e2016fdc0280a24af4435547cbbdf475e1c3e35cf7d67bf7aff3e0f852a8c5471ca093c19e645f52d6f4b894c733b8f3adb1b0fc8d347a3e57775c86d201f5f1d6e32b84f4caee0bb82a79dfd4e2a6fd24354eb9ebcc94c55d866cddac1b85e41c0c9e79e65ec5c57ec9d3f3194e7db1324f0e32920c42244a97068dfc9a907882fd8699b5fb65ca9c17f0b33d66bcec4747118eb61e0f1bee879a9fa4489391714de3f1ba9a9d9a0d8a53e8cc3afa8f4a84727480eb86671225f134b269211611016261180f1ff82798b5e8e4e007bd7094324eea33cdea4ff0b87dcb26e7a9ba647706ee9ff92e8b5c373cb3745478c27abf1e3049b573987263bf2508aa7072528b78b9a3d5b4ed9be46569faa5bbc03a059dc7de60cbce40c319a3dbef0d53d35f7319de29a9474a04ed9cdaf321ca791694728a8348994283053058b4bb5bf8c95422eead75016068be10b0450567bd054ba62273308c9674c27c28451fd5bd71a15d7dcb67aeec0fed872a816ac2c2fbb72cc246b36a6c440d8c7da32aae505fdfd8210d4cb54fcd895126a155988361479f33c02db801ff9ae4f9ff88ca6b09fbcd7fd4f5983343962ccba36500eacfb2a13b0cc5e6e833be07d4d8aff9d4ba4a93d1c3bc10ea2bb22a59ed195c0fa914406dda025b02d1a68e483077d0585d3b1fd2ed1ad4504c42c3b52d2a8446f0c24883b4b259eae3d952c8c5c55ab45e9aff5aff5e9b9513f8c4933139c03eda448b90fc31184a18401e6f99abe8f3eba781ae96f18d67e959159dd411f4dd48075f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
