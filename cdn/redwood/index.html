<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fee828a5c9454e6dd585f9e10a722dca1c7de047b15fe1c9abdd561bddb778abd48e11a6ab4d858f6db644b8909765bf41b356844cb5198b0b785a15111bc3ae6e88c329dfb6abc44ad34f051d2bcbb6a6e942f93865e8dcbac964dfe8142338256905ddfc5f07b7a980333efd1f00c262a2a50fdf7f44380bd48ecc0cf135147a88182d94216d081b912725f925960fb87bab000e10ba425837d8690dac74380c710cb02a810f42a41d388f9bd39664302226c7ea8205449d6ca122c91e37bff8bc0da016baf007ff7f744cd0cfeaa3085083915264c417297cbb387ee8e1c3f0e0a28c374bebfc0b331f936cb7734caec705a70f0d792ff84e6c45a6f88840c5018a45c9e091d18f0b8f84b40bf5b3ab7319fd2616d1615dbcb7fb56c74adac10098b4417c9c9ea0f2d4b49d03519686ce0c5ec09e4652ea846b0f122230bdfd0836fbf48a1bd39c1ef027080b97aafc1cdd9519022d11ee4dfb5157dc621c51dad0bce245481922fdac805e433b77213614f6757844b8493e462744f8e523e45b62be18a525c314ace51959182af57581e3f8a60e63670cf9d6f61884d9904c7af62b24d98b0f128d142460dcf7ed1a2a4aae126b9bc1db305235bb55ce4e8eea2bab2a2f1615a7af1114b6caee35fe6e44d2d27a1fd465537b17e7f66193a0e14b1794597434a509c20127f06978ad231a6fb2758c422fe46c72adba8bec9b83d1e5879004934c250e6ad8b0cb8ab601bac00332ca3238723d9441d65f815b287c04218438bdc478f4ad21823892105777fb42dbfeb489b85a52bba7e1f205346cdf6b89134311c1d53cf5086a61dfb980d15d9bb7d2cfb7a8ec6d25907f0e037a685c95aeee915b8247027d7fcc8f864282748d058294baed3ee719daadf48149eb88726df20ee0d32ea9495dfe2025429a1ea97c5c0ec44422c8dfc5a368eb14d4beefedaa51d71a3bbd9bcdf0bd74adeb592ee6f2bf984e1ce4239ecab5b8216547a74c626a356fa7a06212dd8af625a8e48e6f3171af8ffea7ba33d6be8a34bd9a2bb22b3773f3be4974f996a8705e838dfc7daa3a4d168c0f5bae21f8850f8ffbab822092ce6506eccaf0c3b5a4fdf4b9dbe01eeb4d7cc905e4e1366cfb378d23f550576952795a34f47e2361a81844beebdaf0c9ca9275637e827842af4e5a17e842c82d8c8782195acffe42bed6f83c882d0dd13883b520d6a4d2716f2b1868768c8d88513b8ac1d26094fcace181de3f99e409529879430e2ebc289e5759b7ef5c3e12498ff6061176593b76b7ddcd05f4051edc18d00479e1cd6d650dad447fee2acf014f39ad25a1ad3ac3f34018a361230be38679cecca66a028870b6b1c7f56a1fec0bb46f3bf6c3d03eede0c003dd1319a7987bdaebbfd92512f12eb0f46e55d1918f2526cb8eea33c4e9e1b02e79ffb6cf6796319eee864ad0d1000ecbdaa86b016b69c0aa8b93123aea8b3fd0bdf4252ac99f2a35fb2aae1d42ebbd28c921b9cdd15eb696d61cb83dff237daeee40d25ecb51b3b467b3d8695d9c25038e048ced1dedd33ff22cdea4b7a076aa43927c515372f097d36a2637352905eaa9a1c36e3af147bc24ba8002240699f79226de85a5a87e37a16976d52982fc43460a72d9b128f157d001421f22c2991db3c06d4137b2931473a9d4c36ca1b789265a70ce56c96495a7c3c84515de345950e900788a1d608b65d8718bfe8fec6b7c559299680782de54d18191c30c477be738cb36166d76b36b3f8b4c6f92af4a989334077de503a8a12f19aaf96492640b4c6231497038b34c177a58cad6cd9ae4602740834b7d4a5c4c4a771f79eb99373385be2749a268cb81032a9eab8176789797dfa38c3b0ef105ab592a94b29068e50557e33da9a97f4199baff9431f2417df08aab66a1d3aea893184e30d1b5ad27f59044b06530334360fb3e631a49560b68d49682a31be45b4ae80b70063bcc6881ebb094a1544548ff16b1d3dd6b1fca475d549b6deb10d1fe5dd3c251b6b1c77ab21653a39de281137b51a03a0f402ee0ef5a61241d497895105fa43381cfb9785af8db62e2d42fa20c18823f5e181f8d9aad67aad3a2abe7dfb9cdc89bdc165fe474ad55df90074482396af339e0d1a50c3aeffd19978e4fdc439c5230d799689a8e32ccea159a92a55cbc5eaea6ca900cbe5f6506579f6f0e83baea92397bcde3d294c7fdfa04a03afd9695dfea13234ddcafeab54c9bc7873240fadfa13d7748b5364ef733c1fe61cb4c39f2fe83efeacf1eee02a1a1f354f47f9d886610852a40d4cd0f17cbe05257b3867298d56683f2902bb94f2fda731a5ec236b09ee5969e1604fb8b491ff657f8ffbd1b28453957217585ae65eae8e31173f8783df00efac4ce150ba4e5426d24dda4716220cd3838a6550d74e91f05d96a3c633eccd9b7c38a2bc0f4cedf74d4ab241ee0ac5edfadd0fd33145f6f3b1e5b850644bf5e8adf71c4c0e85524e94be76ef196d73bc4dfdead6e5b3303694a5bce91de02abadf6ca0294eafb5774e53e3b80661745ba80c03e5c56befbb46ad879b97eadb24f7b8ab337347028b88893a4ea677629763310f6c909b1bc64e9b5c3b4b901d3b37e7ecbb6e5db3f15458b03e9c13457d7e06acdd0515e3d43b24627fc55483d36ec0f45dfcaf1e40074131c1fdf920bfa405ee63471f2eba1ed5a119ce7ba99e88f987af81b97ad5b13df05ab1b6a2c13039e7cf6e8b54bb86896bb568d712d20afec9545a4d45e35551a42fd79517e651ae4e5db8d3374d1879c29797c3ca5e5dd5c481efe043541c1239494d2147a904a788df5962473af194be5ccbf4185282c5fcfcde41145bf5e0b4b42e2e53dfedcae6872db9eb7d34af95b50981ea8b4eb9c26c7acc34b0161b14091eda6325f2ae0606fe2305e27cd2f1301ae74889a50991dfa24e0e6eb01709a6eb4df55eccb2b15ca29687c9a0a9d3c70c5ea06bb8c34375ad3ed7b43976e47b38556abc0ddae700b6f8f4955e3b1104509905c23395ec3f83c25653d11735a6f1fce3605641c90bc742c04a32bf073137a8b4487f408baa6aa28ed8cebc5c76f6faa1122989a4f2561e5c2be7cfc824cf5408f3899a3e6b6126ad4a878b05a1c60f2e0465164b989c9c57ecbc283b6fc8647ff8a745d8d448db74187e70485d24b99232e30a55b9b1cf20b26823817e164c92aa51c254edbaf3443b13fb1eced167165ec961f1146080d9090bbb37d8d5ce022be982f08282aac05ca4b4b7176b97157ebb47daba079fbb54056476859423f283c4bd9cc11afe6ed4ba03e0cceb53138870d468fb1dc1d9a7e270f2e2217d3306f69a299a5b03770ab0bde5507efe2e6a1b9cc2c9fa33bc63805e5ee3f25d7af851d55e36bcb25fe7028b22a545b0ee44bd93372aeee122af2580baa0f20cc73ac257c7afa770a5d65bcb32e278ad0c0b64a959dc79feae36d62f5d8d575f135444af664332856808fb9a252cf66eaedd42e3826fe16575bbbf50ffdd78ea42b1e5be89a0c2f3677680c0aea2820810fe126000bfe9f77701bf6407e9157534b4c479e19fa6d114edc8e6ae60bdb1e75d9a9beb255ec7355932706e2b520ce98a81f6d9d24bdcd578f6969e639783b87cb4d6911c7a36552ae158ac69135edc4b1824236eb9dd234f7a07cd75e9c07de33991e853332b95e96f4b92329101decac961eee201b0bd4b96f679dc2a9a58699e76e8747941f425e41dfb7e62a6eae0ea19af95e7ddaa356bfcab129349c982841408ddf19739a1826bb23dc8537049f3dd41c499798c0a8bcc6edc4a7f6b6efcc0b78448678a29fb6476ec502cd9586150d7374b1c6bbd9b6fcc93a0ef59aeb19ea369f28e3040b828907d44388d29e6c6d783eb67e2959d056d75cb58e27b55f45e216527ad4f584fb3b623ac59da3123d492669a7858bc5a47f6a488e2662ea4adb0ff6b8b2923d7b4189689cdee3a493729b844708ecbddffd6066ba67d562b0bca3377e4590ea17b2828c7342c99a178018f309b99fb0f86462ea20d146b74e52a1c3b12de55f0beef092ca1d071e514c8714ac6128ec2c6d6b87199ef279bc248e401892b5652c5b3a701496648fc61d705941c0ee12b6784191658570133e3e36593f50e57b76e09361f1e0a6baece24906e6ce5a6b1854788d64ae44d0b64cd42d9ff2fe5aef16decc90d6630af9fc883cda6a92ab69d38cf6cd57285eda9fdc2bcd3342d06a260b93f775dd11df7c06f970f5d8f779704bb8b8aa3af853abde2a3824710c47f040fcfccc0547964110968ec943a363292b2881137d3b0de9be21bf6541e7d5560c002137501ab721c6a7814b08a92b9b2891857740a41c62102746b8a33fad6764b2cf48f1ead1340711d10c734e7854970bdabd054244793f2784a072d5786ea6213bc8256fb3e0ae0e34430036e74699e59ab09c32c1a6e7bb43cc8192e4f0d432e8297edf2cf8f73c18c17aebf28d4df74276edd83f654bf058897c2d6409375e1fe138bce65e794995fb178a58610df6492153e75115b4146a80bcf3e0a610e1afe0a9d423856fdad2761301fd82d8073a27058dcb5e596e030c779dcd1828c399ce7d50defa28a9c10ea81a7743b7126b5d619d12a9ed4f6a970a9931c4a017a19d3ab6fdcf4998fdefd9dd350a580a41492627c527bc428f0341ad72edf09cb95047fba8c9a440e2ea74246dcf29926acec8df2c25276f92f4be2854db173a4670091b45ae1678f39caf9e13fdf8f92080a7a9d553fe30cc6aba361fe64f3de81798aeadf979d775b6a40a8adec105cef85a31b5e7f49f4e6bc412ea2ce2492f77c0028a4c5358843e4ea9071e19000b56278a5c86287e1a77426a1c3bd5f0b4dffc684724974217b039765c19b90ade1a6df804b8d6bd1eee02f78b9f5b552eec15522ba298889839bbeae5432bf63692c63dc41c3ec6fb72b7701451a4330a9c51b2587822dee082103a489536ddb0935a5c4332578fc7a93868f31bab5761b644c941de459d74204b1c5037e98e4dc7f4e862e0902e9712d6b5cdb30a934146fd443ae9bbdb184720554c8a83712cd21a330cad8ef79c5fd64965b3ac5e44e52c880626a7f8a1ea2ee4ec2462a48ba706393db30ff656ad3cfaaeb196d4f28185d0a75d38f1e81868bb5858ad5d5f5df5d7f677e626476673478dbfdecfa67a639c063bfb09858997c8ba57dc4259405012591be2b335d1a04bd6fc9d8019b4e7668dd1d27bcc133429ead46932a76223256fb2e33e3cfaed9bc1f2749a1b7c169fb4b3cfdefb931a90841d40ff33ad8a0c0321890c15bbb7422cf684f3134fef0bb8f77d4f2fe2b65bd03236adef9f599a5eb6c18edd62399045c1dbfb08856de698b54496fd7ac1d295a00a35626c61a829f35f39dfa507f09ce959b98267e069f8a2b3c5b6569fe205f694a9a76a96cdfa3f345102af96ee3b1bb39835f975045aaec2deaa666bc6c7ef3b8e1d663605b06de4c32644ca64cc87f07e1e138f78528809c97d08d6d185945ebbc809b1759f0c10f29bc95440f929baa0663376aabfbdcd23c04c42d7eff524072fada002c82a478a92b09314181444d5ca08d49904e3e516a0c26f135ea8c8c0500667f9957cc6af61e0f9e599e6ba5a0ec0fe39af7c250e6ddfb193fcacb70331dc099da0cfdba3a736cbbed3074820f911d887a7407d54eaa93b7be60acd253de769dc0dd50f1c1b745f29a2f0e994c54c8db75c44e59ac8af9580c4c4cad0fb6623aa11a756a8bd9978aadf443e1c3cb64b99a262cfb847a92128345e20a95d9a9aa0ce658f4305bb91947b5af8aa5cf8635d526b5661279dcb21dbb030f8e3378c70ac3d2751de49017fa5ce094e1c65162608b7dfa2bcf838fca54144944cbaa3663deca025042cca08347f5e9e49b9b259646dfdd0330bb7a5a106c4f921ab01d7728c47500eb6986216bfbebc5c4ece190c453c9ca04435ad76ff42a1383b1b9539f9ac371f000527a17557749da9fb1f622f559c49ef1875ba66574265fe3044c6ddb50b0ae1df298d6b0de1b1d2baf30ac714dc45a64298d380e26f33c7af21b0915139180eb2c10b39eff6d479098f7868263b47445d95d82665d30f1bb97a52c737098ce1d738f39a1967cd4d66f6d936112d13c1192b0c10030d4f3a55aa0735743a504a03044c3767d77d847d1ae495063b34d923beb0e0f699fc2a63355c33ae300c28f31d499bb66602124e8105029adb351c756c00276faa402298b6dc9c02feaeb606ffe75cbe60cab9c758e463e1122253c0cc8576d0ccc79f2ac021187f32dffd4977e68c100f63b6c5820098369e20c1e0ac73269fbe1ea06e2598f7599579dd9fb640a165914f7184b5769d4bc22c1f30f6beea2a98467ce9436c4599b389f30fdf7f93378085e12e96a916bcd5189de68d6290fbaddcad24fb4d04dd206266e293596db325668c0604060dab6b66317408802404667521504f1075eed8110d177f874cca2baec6183b99a960b0a81af1114ee2c937fd412b07105ab561f34b448638061f004260e2a04ca6b3ddee45361561919f70a7742d6c19379e6d6bf52972e0a35551447400c8dc0f43b5accfee86bb0dde3eb57c1c8a37e87221afe85d83c1e2a9444c6977ba682df0984c5a44c185d4c08c39db0093ac8f4adb57fa735a7d4e41898c60d5979f7be65c55be0fdbd390e0e3b2f97fe35b8775e3f1b9fc6842e2ad148da3aa1d5477734deca1ea8a764d71058558c912e3b27dbb9c34b9a76fc23862f6734ded8eda8c4c54a8044953fa612d4e5e1dfe3a226f55c06dcca8b8f12c22882372dc7e9a9daee9d33aff984f41adadb0dee03d62c2a019d31a99d664217627134c140e9fd1de18d8167a603a0fdc8f513027b690c3b2b8b6511200a538b82476218b133f16b1746944cde88598245704e560b9bd41a22025a098124350b6820e46d11c1b9ded5d5b125856f6718757dd3307ee41d66ca0e1df1a04c725c7eefc988061124a5c7430cb53b17a84944197b4631b053cf14a1c9297a7cd3f45d6f699ed9121e9468c9243aa7df22a53c4b374d197cf43551371d2fc0418ef2946602dad0bf1b3e3d68de5046fea78b6480a2f091dee85d53643ae5f351de2d082149f34c3ce1d867b902e663b0c2193ee75c63c11ceb13ad5a39375012625b3b008725f4c29652fb069a8e55bccd7e331be1c6afd211dcd57668f71218a8db6e7e12c62fb36e20890e9eed749e7525fb0f7fd2c30bc84b36d93383cc1d89c15dafc394138c418c5bbd8a72693c37822bef64901e679d6b9397a7b255f7edafe055c6dfde02e9dba44d60adbb84db3e2496f383f82cd9aad831bbb99bd1fba9f8784343807c55e6eccb7d6fe54715ecaf89c60c9ab2378f23be5f8b16f9e6f5af857d5e6deeef2cc240a4d9d2df62ac3bd7b65316be42d959c82a3f1bbb3114f053c57c13f8cbee266983f8c4311534a00017bc688cb7eaa82493459bef314002fdda5bc7a0dc70f5443ce5415d6ede62235d900b5fcb348dee1e9a33815a8422f393784605dfd69490a930cf98abe3421c62fcd899ec8a354434935650e600f00a20bdca0687ab26a3ff8b429632aeabc36306c7ab15d30422ba7553a8d1372a8ebdf080060a3c29d992d581489faae38f5a4b14b2a1c7e9235675510bd08d168bba6d21edf8aaea900a295613207cfbd65f7b0ba2b42046d161bb6ef75e1d7dbabf8d5a91e342d3162070924f359b3606a654f388ca8b9a9f0f59102bfbd6469c49f9892ad594fcd0d78689799a60f25d57b05f7332db21982eb876a5a53bb7258425d762b358659bd7cc12ab8711249997fd6c72d0124e2cf9cd95f586257c4f184c79ff01f0deba4609ff8e827c7330e7511e91ca531a6da0fc53b9f8eace69d5c7f7457989c0e3a84a7e4626dc2a15347e646d85b827ca8ca084f09642864a45b8acd5baffd08f2c8925308e4de367e55191bba77aa2d74f5260bfc595be3e5347f41299deb4a5765d45a486a33c2a7f950616fdc53b9d63e77d8faf9890547097ad8a85db9caed33ada8c7e76eeac6ad8e5e5178244c811260a486350c4b6e0682ebb6c959e0f989a751eb3d5f71745fbcbd43de26d75ba13619c4c6ed77aeac2443e80f1892f01e218ca81f2cdde8a38e1ebae505ea51990f676e23feb889b9e9c4522fcb2881b1fbeb8b94d64b282b05fc99eaee319fe858d060ea3189a43d7b73961b7f2262ad3a4fc5894080dc4001fc2dfe199bd5075a2c13379b6033f54f58608c8b419daff7f626d7b3fb809f8d442f8c810af2613198ec7b2055daf0317aa2e7a41e3f7344f07dfd67e790c7161ae49c1af89a02bd9a3617a49a9560d189ed09269d9bb8375f16cede04b845a3090d1c3bfa97518b0d901da43126ae02cb0dad94c5613c847fca70348ad9b1618df6df5fc90b671c6fbc936de4c8d0d854c1413e513f2b81535d62efad852a5c2af6690fa9bd040f6ae52de59bf19accf13306cf55db52da5a75bdb4fc9d6aa38fe29d6a7cf0e8e2eda26fcfd2daaa80e39826a18a4d3899e5bbeaee3191f7dd6eba745fca9ddce2323f502c36b7d3658c8145d17864b6cd16719a926de95c71913906d6e11a671eae9d39c8a7df1bc9fe4661258d9b982ab47f0a9bdeda719ab6b661dd275d69c9454e9eb4174b3a0acd1264cf59a0ad6b6b012d888bafe77fbd51deb2450048472d6b33a0d303ec347251ce2957251f1768e699db64d92b8720714d0b47fa85c52b4a42af9f9a6eea0ecb95d56a33238334f14cf731783a6e0dbf8f595709556b8ff3de3e77e5665e999380198595dd4ea7106c825e02c3ae1026d0ceede99eac2596fda5daa73a2b902c6cb1a9bd15c75a65ffc0d620a36e56164d884776d92d62b8cc6ef160dfae49b2b08d71ed090344a30c8aed3ac7a1bdb1044dcd98099308f8abdb12a22d2ec7dec4a5f59d969a8338cd7144df04e12dea9224001a132ea3e63b45810f8c8d0ce54ff60d7a8bdae417111d4dc09e49d1f6e2bf17746fd22b56d49deda5eb4ae2759629f1e53814f907052e5ea9dc78467281fc9df477c04977778add56f09f0ef457d5ec26460fafabb18c521329ea499bb15dc040cf5e405c2862f0988f282fd339ecd305cded5ac587600a3ac2b1f9cd289edf0b9fe6aad4bc4655ca1a7880dffebfa82c6a7542bc7fd5386ed55729464307d1a52196c33fcb00f0773c97cd865f43842cc5371b01b89669e0e7b70e2731317cf4c633cf147262aaf8d2da6e761788758f1248c457ffc885f33fea6fe82e7faddda66d1f3654fee27ae89b5da24b64148b5e78115b706ed233e75e8474c60e54e3000bbd3da03bb98f83b5d25985dcd7b30cff4486ddbcea3242189b2d9ec40beeb85fe4bd990710b52bbe420b6b6c19e5f12b1b63f44a5fd19df96989877d07c24cbbe6a7814f5c1a8762b9be69882fb4cd0503fd43c988390800802e4e16239cf73e214042ee51f967a794a7014adb968756fc0826467bbd4ea9873337dba680838030875e272624ef6566b520fe3725d8be51748025cbd73856bc481d259311791639086406c3fb5fe392fc7375d3ca369ccf0cca0a5cba8c5100512b0fcd73592cf1322928d36de2540085cb53c4b424ebec074871860ddb02d5487cf911be6d963373c0c87b0817fd4b9eebd6d9c6976a1c10a7a7570a9bc42d1d4a673b2beccdd7f1baacdc1a1b0061d980b3baea407399407196e081629aa04b19cfca587d9cc18362300008de5b014a8cb08ed8feffdc9087c0c4ba3a4b9ed10a204f02279219459fdd89bba452777b1330bfa18ecee619f56a351cd1776bcf3ea4837cd45de3eb8ef909560fa4640bbb2628eda0f6e83d1a6bd018010a30de6f3765a281931ed22abfbf0519e7f756185182542e506f082fe0a3525b2a92a1f46f43597602c55c199ad6678b4309e57281639f36e0ceface436576aa8b3e6d1dc52f86e72fb9b5976f9caa8c9a16bb60242758ac226b37fe7a6627a73267bb03b2097e623ed922343c948e5511cec69ac807905216e162c9e7545aea72104549b756319969a73749fd1b225d6dd63be56dcbee8b1882be101f3794699692770d1cb75dbaa46995290fac129645abd06b595902a45760c699f9dc12334390e41c8ad1ddd3eee88c69c804caf3745162e94af8261357d7d5180037f3872435eb746572f8cde56a5a23d854ee75d5ab71bb242063aa231f30b6d6344f87c35393fb69582a9f5e6298be2079f23bc9d978af18d12a48fd9d90f99da4b293da90bc45eb909a34732d9f5cbbdf9160f3a05e484386fe68293e9e041bd2003e822063c187237537e61573e75ab84e4a5dca7fff10acaa62252ca80949c6046d71148a0a9babcac3ed76ec2d82cb21cf8f69226cd0d2681b0151a89eb6512b22403bfea42d6fb4aca53b9511a8288b18e15cd1cb65299b546e7e4b0f0f875ccc6419f7d1035569f7961a1107e2c9b88cdf048afbe2c01e1b29c34280695870aa0dadd5116819324cefe612befab248287d916fe5e3588969a3d4cd13ffa6565284fc41f3d67c33516f0760f29c7b8f044e43729a4980be22a04bc4adf4606120a13b04817a833984eddb0a6ddc9853cab3817d3ab00a19e504f718dd698f675f62cd6e4acf7870eabc718480ef10c1cb4db3f3e2c4d509d5f59be60da993ad3b5bda92d8df7a080889d92e9e56cd68f71dd49668459faf94dd4e702d4adfd06effad12bd7241a75922f72174084bab9a11acd9062eb884cc558122e43a9ee10683bf9dacbf9690bd1d955e475700dd836da7e56e983941fdcba2811479cdba3a9a511c404086737b22db53c29d1ab6f8291107ae771870c3303c68c129d462d7c9a62778b0ba6ff6eb2a98dbe67328fcb16230cec28e3043a4af9cd3e5022f2d00f712db182ea9254b0075a5c93bb26e1b604f3c479dbecf01a2dd4c9e4d19bbd098b21bb090281879b8c3daa96aa6043c5b57e84d20ae1d1b51661c3c7e2c1e29bdbc2bd0da316780c734e069911fde71f43dfc91e19953e3feb4a4cc9fc2c6d2df55ab4e7362086549dbc20dcd7f8c9c13413f10c17908f8431c8c0f11c75f95784767accb0d277c1314ef4126cb9301f0cb1c24bc5414ae2e27517482f1239bc496245ecb5a615a22e62c62fd569f943658d74bd83652a4c60e770d6a3ab0c76b618d65acd487b95865e61af8f7110b8cd8cb5e39c74432650398dc69e0e7b610ce7647f7d4d7b14277562436a3ea7c256c71168be8f45e32a6e4017a018e83d54222c7208574ac3c65e62435bbb38a2ca053e70b1fef9ec4322149e362932ae0e093a14c28eca4613d55eb98e6afe8fada74924d43a8608fcc7ff5bc8948090b234eee96055bcc758411bbf4ab7f8b0ef58070555ad5497130ffd2c4058afd610e4895724c60ce52f8012c048accda0c9c4abe8ecb9e54829e0801afbc8dac5bb7115331044001759c1a2411946096dcca0c4f7dfd5d8c0318fb1f0716339b13e818a137b48d37f302bc2de44bce349176a5252663062ce4cd46d4946ed5ae79a32b5d2392c29885d156b36af1805e78f777c424273e976370f105b18d7f2341df4c3346019b42ab937ab91e0fd8c1cf5c990e90de1dcadee55970556caa057e1f6a3af3714485d5fa93a1a63637c32bb90ff7a4adfa92ba4d9f50c37a625db9bb5e9cd83e76f08d78925da73bf4bb7cf6b80e5472ea34f7ebc1a972bdd8160a675b5e9a7202dac6502cbf89d7634cb3c9482a35df44125a2e49ce2982bdda68952c5546c653605d423bf4315c7b07d49cc75133c33e1216529c85389bc84dc12812f8640e0ff744e212574cf1ef54e2fa05311329da378c65a694337f4f618c8976c5000c2098107fd1e08f0774118a3b8a451dfada167764de3d3cf35082d5da59a72d9cf9e97d9a012f2e4eb75cc69c4b49448467041730762a5a7ecf4e393e67798e47e8528f79a9bd46db21845d8bdd5c182c1e17ac1cafd2afea962138f4afc4a6757abb94f9c9aede2484c64931ee71cdc024dded2d9eebe55b329107d24b905075c018c425af8c74276d1e133057f74729e8a41a926557ccc7de7e387cc940f2aa236ebe492a2e70e7cfdd0fb04219e60710188de91f960432dd5d10e4bef980b54ffea781e88291a71b77cc4b49afdb802dad849695177f53fcc50a7a368fc0af32097e2e315e01a0a876f922b37c844287cca35f8f07fa881aab89c3861dad77eb21356c87acf163a2d09bc8768706e83b5a9e814d7ae446ebe81547b1b6e63710d49feefa2b8354e8eb6f93ae622b1881faa81f4a03a069dd64841aebec151c7105d4e2504dd0d088caeac9ab57a2f36f84ded44c9366c8370eaee4437c8a3ba073713c542d1c12013b723bb319654d2285867e90e58ed8af139860f1b03fcf501201fdbcbdee7da397b148c8bdad251dbf71fc79db1d89ec31f4d7cc36db5679f3bd937f2a72a8b06688b50cacf29200db4363c632b0310ed53b754a8a48a0665515197fa204b3cb6c42200fb4786263d1574ea99ae0ce1ad9ae6e495d404d3cf0fae4defe79b2e4bc9e614ca3591f059e3fb55be29e4d2ae29643a62c9172bbf41d2e4ec2226327d4ab29acfbac2c1586ff9e3c4d91c15cda7d415d633d34dcd10b018961311f06a95abe443b2a4c7606bd95f2736e6628c9df5906818dc915116f92ccd071e702be1a53d106531f1397f09ab57ff567bdb1d41fec348b1862dfdbc5d3dd7949dbdaf99a021295fbdb8e923c319198885320d2d0915380da53ab40b83b8e13cef478d4156a6b6639ec6f49037235536986cfa0034decc59d69b14ad350484124a04e64dc2e7e068069f75e55e790f851dcf0a009e46ae0435238a46e20e5ee8db90309b1d96504107f72d1d149b0c5a6d3e6653720eabb00f60a6fc7aa1f18db5bc76a6cc502a38c5a6d98e40862258193c419f609780ecc99a715c6443fae938f57ff7d457f474a620f151762d348d37f5133920d4afbe50bec5ef3724528f73f1744d0d3738f048a3ee481b9500b8f80ef0cef3d1f8025b4b45dcfb9d049f22076f5e951d7dcdc213e8b8aad3387e319a29529ee324b5a7443d8d98a7c999794071e32e75bb0131ed461ad6be2056253107f816331a81952ed3094745c6888df9d737c07b24854879e6bf58baf531c1d3d33b16cb8582029a3cc9070013b87a5ce4817a8793dcdc8f9ef0e3163e0fe92d4298c6fcca7df9ce83546ec93d5407abd0c4e252c80d40396632b61fe1869721e8584cfb44983228d5cdfa47b72c39174dfa0b52ed294db3cd61d2bd7398c34d99a36281f028b316d39c958d7d51e0a03f869f9ef7b39282fa42d8978130ee6443521bfaf96986cb46a01ad25229780c02c8959b9ca3549491d5e92e009cf628ba6e47923327a76835d5a4635b355636f9a00eebe74af2114f8489f5bbbeefc0470ec36703c40ee9327109b8c348265d68545feef97f31d97d9b938c9014f2e4a40e4f44f7e49c8fa976027eeb32276875d45fdd683d473e557638b295f15ad8afc0fd5ea0af1b44702fdaf53e0553624f5b2426add11d5ab8a8f5d7b9603989aea6c543f9a50a1d33491b23d77c75c71fdedda8070d604bbd82b26b2f5f7f1df5bf9876a5c495cd4d12dbc89dc4c9254c5ee9c8e16063281985be100eab68408952cf2db976ce83accd5265aafd75bbbc09cdb957df0fe1b8490df21fb91e4b2fe7a54f3b9f26f048be94b57cbeb2ef008af57a709eb8f13f72b1fe79805e7776030d2bbd0c4ea0b62288952ebdffb2c1eada18333424a9edde1e902ecc873049aab4fb2bd365c7f0d291094515a7216880715ce39388691a7e059ea013b26b95d793bc10ed19b1059b4b46212672a7a0b9c4c321c6c90daa6cf8835abb886c489cc4176a3a1269acd0f37986afe7e6a643b080e1391086faef599632d8a64d832adc6e7b8d107a372c0da95d3b2459488beb58ed9daa7b6f2ae68a4d882f194c9fe16fe7e0e182f7cdba394e54d5d7fefb3b1f6cf5375f6521de239ae8d11c78479eed067b10888610da3465df38d19f2ee903b7d9d7dcf4c51a0e4f15d0c723348b0eb3026dec6b74f05e48a93194fd61539348e61c52eb4e36310ee7083d4114d47d30863ce1a32fd5a356723f8a844c2dd8548fe7c46aa42ff2e1da8a07deb3c1d34e892e0ce6cc3586d23b91e2903daba835aa7e1737576b06a8e09c2adb2bef9858265247df02344c9db1787b299b8004b07ee82449fad9d980472398a773bbf26c525b7f8cb63f71cce6b53010625236691199a87e2ae95df85c3a6499addff65666446cff6bbfa57bc0f4b18969bfc65ccb13988372295d566b9bbef1f10d52810d9fc10dff710a80459ba82245828e1bbe8856e5a4624c19ed10378155de651fd16689f18861ff803a9cb6ed8164d157cdabc56c2d49723e2336ab66b50419913e7bf2ab4cf022df025edb73599264aaab72f546a47c0b659cc48c4f0659fa488b77b612d8877e295b0f0130480f56433b554dcb257f4cb77749be79b7aa3f3ce63880dd8a46ce5352e8c28950af27053142627dcdda9f7a4e98666c43305dc50babf4665d8870f01281480a2e55106acd2f069b5d1a7f50e9eef4c50e224d2527a643897918d6aba73b1790a2b99705779065b0b2b48816861ae5b6870ff2cb6e84ed97b1510498c7e5fc0af672dffdd0cef3eaf36f08b4653caa20a1f177febbaa9c3a05bb21bdd98d827e13d04aa2488dfdcb5f2b83f33719764623f8e988166e06cf8e89c1cd47d3f6622291171fd70d27b0087ecb8aa49569a0e90f55de917ca9a75c6d4227378112ebfa0710982f9bda7e0c51bdf918b979269f0f970025d67e9ae65b7a892b44df4a72485174d9ca5de9e41adfa6293712d2b67a5eb0879e769e7ce03c3e81f4ac5d54d76c1ba2af2d3f722a0e5b7a05e9ef5f5700941e6a1d0985dab0ce3c1dbf4e1f4f3b6498b0dc1e5ac5bc277e24dbe0dcd20c07432a280142d0dc9f3703a8943813797bd2d8cca73f21585982bd497acdb23c052827919f1b95600e1cf8142310c2317a91f136c620697345cc622ae6d7bb54ea22881fff956872c569e500dc1f73356314bcd755532abced26537296c25416b1ef595be7e4bfff2192253aba0d77e190ba1e8fe767f628a8b20bae59fa8285500b4ff45fbc13e82048defd693beb1f0b85ba75b770c903cf109fa3e9fa79b58d7a56b4232994003d9767d417e4d30323a5ed677c1f90905ccee825cdc15925182acbcd9811f76d43ca667c7209b7e32f3bec7d2c80b2a4af4c2a56f2aa6d1ddfc39f0acc91880bb9ad9ec9c11b67d53a08d4465eb83fde3af66591825a8e7a9897021da5079bd0934066c479e0169fce6f832b5ef21d68a4433185c14073ae2ea39e6232ef119e952f37b6ed56a5afc11dbc87dc7c2581c8763799a64aff04ca0961b479dc71aedd4d25e8372ba5eb4387891654b7a8a28779fc659f564642227d42ae5f5a15ea043c799d233231bc54f6b618bfe366a699a2f660d1af6b4451ca8c3090153e4a259b3d6efd25bab91423cf74bdc17dd741f7222cb1bcfeaac44d8f3e3f205108ad5ce3dcff617960e7d7902019bd31fa90eec1314b2f0f8c9c6be0e9e39fe0da7d9584452760d0677d0e44bc50ea399038eaa5a71633aa922cc77d45209a6131fedf18ac5bf1fc13acad0c48dbe0d23624739a026cbbee309c58ff152c4b2ff884919caa8bbadb0fd9d3635184a33a4b921c7b2d11bfe2fc450f9c5f3c3c4b3b026a2bfb506bbeb236d19c3da51c3ba99675d602cdea3bf0933a3ca93cc05984b453a395f3a761e34a76887452f4f3868fb250b633823006de409c3ff9a93a2f3cebac93861d96e9801b8416faea5842caaf5e5476104d34615ed0dfccffc0a47ae86b49395bb211bd45a23d34bd5f2c6e499c4581455625af809dbe988af22ab67ea6f74f4f4e7f79f3ba2060b16305573d2cab70472de8a45b25440395e2e4da388fbadd50d15713e7bcf6a0f276e8728986516279c951918d732749dcca4462efde90179c175fffe7b6f7f5e201081ec78b2bb9c24bf7f532ad6861b911e0ffdae7af787cca35a30bce661a34fdd7b4a471cb9cf65e774059d32024ba9128ac5d5566fa5c41a1c240d4bd320637c3ef4fabfcc6d2188576140b501a8b47edca3201e91371277d1f5719e7dac441bdf6ba14075018781effceae48aca04ea8cf40dffba78d372f3dcef8a1fe52488a10cf867f6374677466c1752d7a3d93693f9b87bf668204b949ff291e7750743d9d2578ac9a6853092d3a36a2d202996ace95f2b75642eea43999772997ba40591cb7465b3cb0dea99414e423d2c235de0f364a335ea807437cd72c0e4edd813ab898deb52cb65b5906e95693a2291647a7ae2d159f42eac37624a8f8c26d24e167796f6912d41e7ad9897a46d3673667cf85fc282691a1ec5093ef8df46f2120c002b9fb45f889af1b869a6b709a2d93db1fecb1c10bee3a0826ded9e72534cf6d7633eec007cb6b3e528bd674e2205269e79714859902d9a9b54cb3f9b363051a528590ce141083272fb82bd7a6c602a8562ae2285b8e6412ef6db849362993896510a2f11dc75168718f1af3540156f628609b7fba9613ed2a41c39cdce64023409f3530c773215788f0a76ceee3b8c1a9e7df8e3da7b4a3d0c3d778e9fcdbee2e91b047bb2c4cb21b8e51bc6e192a91cc9fa9b1302eb187cb90e6fe553bcffa799c66cb7745cff9038ac88aeec6e9fe5ed3b14b2a50cd105179310275ee9495ff5f2aca38c37a19c1106d7275358e23d8b185776cf96bd0d03090ca2340fd7e85761377a73362bdcbc7a62ef5661fb020c4a147c73e3c2df94d34093f5c6f8b98fa7eb5ed69d03cac0a4caa16eaabd689809813579037b85d640098acdb1e4b8ac27fb45599430e8aa27719764959fbdfa78e7f5b6a5ea28cb4cad82674dc7e1744329d4ecd62d3a6a3d01a83b82c9cc863f2e2ab1cd1cfd00d126e5bd177d4e23a5b139e4bb5e411c5b151edc81374d16415b1c237446b60d99c1f87bca44d08a142042503280f86427fb0016b9a1fd9a02655d70df76d3f80867a1c1996c5bf2edd4ee90b5e4997c5b5d8074d7244aca5c8e759f5c3e1ee61116a2b95dcd94968e338a31507b490ab49899bd999fe958a75defa86a545250b8a2b44bff6925e3c13ef04e70b942a55035f5cb76590a4ff624b81ea561bf680397bd90e6950b0ffe7274073086929669a624e2c99591ba4039c3913002081b6f83b4d7306bbaee0866b5b6eb77683ac44b887e447c833158164fa75e77a6c807fddad900f24c805d0bba5510cc33035728273be9350724286729115f734e97798555cd127ef0b7b1844edca5219a15142cd13d5471fd237a46a86bbe7222cb245849500007e9199e6df53e9119fa9576d30dfcb889c76e3dc53fe81659d8f43672a95bef43b0c2fe2a8d01332fc75596ff79c8edcf81ad285db9ebe4c1a87f6f0759ad500591c0aaee746a2a99269e9518b3662ecb287a51bd1b207524e367325abe7ae636afa862a44a6f9e51492323086f3855e947198146cadac391a30e4e17bb1690331675820689bdc0a184baf3f33200f3f01e62fc060c5905b201f908836a1b263dc61e7f8c58e00fafd526d90d3ee384476d9f887d683809522a23bd731d3f17ceb6e6647652c7c5cb4e3dcc03115f60e5555b92d088b37ac2571ad22b221f2e6ad1073efa52f3de4a397cde2a7131ac9fee22b970fd6fe2b5483082c1be74225bf87cb74b5a5d7cb3de4596e6567dd656e83f5843e899a4304997e04d68a6324dc998abd14b9bd0d76a86bcabc1fd0925b924cfb9d4119de06e882f4ae3b289d6217cb9828abe6b943f66bb2d641aa05c1201bbd2f8a74ace29ed983723365d442f6feb814a9ef0d12022b82ca024cc6d0a97199a8bb3eb69aaf0ad4f0ea3e8c048837d620f231f5379d4722aac4331c0af92f56022a66c58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
