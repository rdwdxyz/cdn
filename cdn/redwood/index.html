<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3f86d9bde7afc22cef9d61b8ea2c2c2849e950cc83469ca3b4c0a2546dbc448b957368b193336e86e516a3769642ac5a88641f7f8e8d14d60fea63012b53c154262ec4247ce341a8cdb85cd2ce1e8b8842458acfd8eec81c033efe441472a7f696ba2d194fbb3006276aa0ceef1960f6f626717aaff1f55a88b83e4501edab8acbf1645c6c16ea9c469688833f9598192508f382b0e43449321ab1760b2ef5e5b4d9c0ca78d5e561a31b282ef716864c0714fff02b812917ee068cbb99802fcd187657c29881b6877a245f092fed40fd0edef75285a21d7dac282b8b32b51cd94ee4795d4822d993bcb700c5602b740bcd78237b66124a4ac894140ef9147e85d18c0e6765b70eb365b0804c1d1d300f2d3b617a3d185095a9cc34b814bedcdc889ec2f47a3be7428bcd3c67d22bdacf7c5bbf21989737d1090a1d91c5e2e1e06e3724b39cf39ab8680dd482d01afc5e67c8b42b7c59108b7ec53dc298b41e9dd311948cb356d03bb058ab3b634ca748c11c7ae210b983b15dbfeff9d83a2393a9562f0e5390cc51ce1dbbc71d3dd417616b01bbfdc10aeae3a4ac55adf82b5befe249be4c18f5135e03c90ce928dc6e4a72b2e4937101e8aaf33a612b0f47ef48102a27924a43cf273ea14d6cba69898c1419873d732c931527472a399a24e31101b7e31e22f0baf25e0ff6459c65f07374258fab96ab685bd85ce38f99af742b5af7aa5687b559c90bc9a5ccb22a286b37926d723ed87e3b9bb81cf75102a2088e0b1f167f2d727d43a563a39cb08a1a615a9977c74cc2201a828adb63bcc9a43653004d77f1a362fc9fc2f207fa80f54eff253150b74ed1794bcbc4119076600b654329a5ee3519a8c68dc55d50f78ba119488c0ca7a160be2d9ecd66ceb18df378ed466e1a9de46058d6036491beb636bda9167ba89126681d2bc84aa5169588e7cf2e067d5e7ecff618513ad5e3ed7ba8306613805ebf61c90790ede3376028be29d1d002bc4241ddf16c32f72522e0391d3514b153d022afb040b3e870e07cc1e255b35ce3583ed87d7ad296423bd8b64659aed56d4b9a9d894dfdc7225ac901105e704d0986a0d4be1f695539e705c258c7abd3aa3972ddf7b70bceb49abe7133f3920e2d483572d7c01b45d48980bcd7075f58c7a536f8ef4fe32d255b4cbbf97767e077b0aa6eafb95917065478a0c1ba4bfc3478ca2e6bb8a2613f3d1234fa52457c9e5011cf1b19438c3166ae2692f9d1e118e320213b63aceda2aef8461f7eeb4bfdd562196205ec1ed5674d42b4d75bc906ebcbfa4af5239a7f3be9aea85bc08727269c48cb6001a5a9c48c1aa5a5663885aeb72c090b0d23ad02cc9b6d0c89ace27b0d360034672886482511d8e5345cc7911eb5a75c2f5c969bf8698522e926d694d26f16db398031bd936399af4134f40a875f552ee6d6ebc0ce9c32118637cbd2821120fb09ef566dd331b8643d59496440a4ca79fdef941233e2b8e7a33f7e25ab976457a2e035d1eb197846648e4424f52c90f2b5f1a74de5ece9e5b43e53b9167c574ece3dcf9af75577990135199fc0a09fc916914753d4cc2909c304e3ac2f77897c85cc351c4cf061cb57acccf68ff83b6974a945ec18fed07c11c2326d3c481892f1ef133dcfe8e1dc7bac40e6f4d2fa19d4ec8a7bad10a24a428c38a47589a2caa7e2e0453999597131a3be8ade71ddadccb3e165c70ecef12425474aef58a9b5152837a32b54b08f41feefca848c19e031c785031a3649903404d45e6875dd94038e51dab4cf22b3bec1e95b1499809909a109cdbb8b3e28669650d3ee330baf84b29c48c9f434faf89981ca6a06da1a640424406b3b27b56fdf7f0104fcee32c177cfb261c690fef5900b8badfc23a29ea4f4bf95d0321b5a5b655f37efb9d0265698b7b5e5deab0e11452e9d215962901dcaf6f4e3e40785495f525c7f69405f7a66a32f1cb78636d5bcd6e338f2b395d92a247737e859752e5f61314f536fbc7f0a12b7a833b546b7ea534736ab7b339cbed27490f685ef324cfee7c27bc3ec04f8fb4ed39ad91758ec4da3bcc31ce48fa827dff1c87fbae42210c65341802c94f30ff6a6c6d7d6ae7455578eb248c61c90a2a827d19ed31da1c4c843e1ff607298044877d0cc9307946ad711ff78de29610c2ff4aab341667fb12e1efe5eae7e62c68656356cf1a4101c34c145280f7e45eed27e83ac3cba8f1bb348b06a0be00e53d7da3b560b618ef0af36d0f23c5bd182d760b4aff382418ec33a96939d465ab08abe3a39d6e1b0394d1d01dc30f5c58e9080d34311a58b95c627c3d5d9d51d0806c8c571e388a2d56f1bbaab5a51be618b5dc993a6ba2e4dea5f334993a0ba8dc810a94fa1639c3d63e4d8f0c9c52efb3a48248b3f62ef597c879b54517d248437540cb8515facfd995a1dcd8c7f1be78af43e94770a6ca90129cf879df444c1c40fb72bd3b0b0bda2b2acdde88f28ae565ee6e7e01080f5931cc09839ac1b54e21a8f2a2f4c91f1c7a5bd7b47cf2a0b00cbcf8b2587f6ffe78eb8f9f0a9f0f950756ce7061e22b22ad69a525204957e0621696183ddf50751f1ab4906ec64a33958ac25fe058bd7e23c261729a2e78acc0bace0390180f798672416e2d9e40f74efc0ff8ec652c2c435187077aaeac09ff9f97e13d8b28bfbbbac99e9d9ee93e6bd8bde2e2bd5c5a72bff257127548ee678f85aec74a75022e33f6e6573d6ed1594630e65d30ffc518f9011a4ea49463c113d418dacebede15dec486dbcb5199d07f25d0b394ed712c04294ec7a01c3a212d61dbf0c5daa47456bd021d7e2fa0ecc0feb41445df8a86d0d542725d4ccd4d7a126617e58d8b428e81c93816b36342ab0796f7fbad3cb39a119ba2fc38ca7375a56e9f9fe298cbab1f3142b96084c30688150b4519779d3e6970d78d3425d3d7bd24b4c5ef881d0f503e7a49ee65a6bd0757e36df16873b2ee55bc5cda2c3447105571298be6fd8a2c5437a76019cc6f4176857f4d333c6c78c6136db147529570a142cc25c8cf78fa17e21113c259b85f64e2879355b8ab0ba56c8188cb81ae50e75d963cabf0e69038081dc9c95bba467d650e3e3ce43b807d2bfe7da3061e3e77b5e378b38a29c2c42b7780712a6d83607b020c7515738ee56e474d5c82141c6683acfa420c88bd3dff2909a1a1615d043ff1fb13586710792a939ab2d70b36986419a95ebbadc0419ed19d081118299227c1f73c520ef8ab39495e0cd01e9642b8c3557c313029699b98ac8605acc82416450e4d7e6d1efd37d6cf292cee3a4090663c1da684f03e65c3cd9a4b03ba9b3fb96db5e713ecb97143178a648023b65838186acd566d4af01d597b736a7d5a333388934c7b74798a43b27a15d6ac76c67311a06639386a6597170ad77d95ce058029af93b1e470a2f60d454a28f95a4290a049c7338d72b3f3a4c2a708a6cce05040ea1884212af8e9e7554c7cc56bb709132ee89c14eb85bf8a4ac1995f1d9989bae076120e621a033a918c1d3658fcec80e7c724ca5bb44dd14626790ba69959157b7a4eb5c7a26f5f87651e51a1da5a2fafceed26289d20b935a4dfd66fbafdabe2d2bf2f6770f9c79c8f88382d030199626df5bed15e0b10c698758cf59e1b6e92022ba8d509c4ec7b689591153fbc580419ea3627d3bdd7a2cd98cc86b99c0af8465dd487d8ffb2f52078d27a5857309c207f70abc7ee77826ae619d458f9970bb425821e1f410a1f74a3a52b0081c7ead43d55bb5d7f5c55118f4a2e86580308b4fa336927fbea08990cc99f6f02b8928d4e7cf48186b322c595199fecf92459b82d0b3fed0a0d4faca2506a4786bf57e05ee8a4c2b425c5e5fdc3e1daee53ca25b2a0d4486657c1a57933bb16a44bc53e918a790f00304357d4b33587f35a0098b38029059cdde433525b18c2720f968efb046ef526a3912e02bc632c6a9babd83324c18d6832a05ad1e28f01c3dc95560e06ecc1f143993ff665730972bd9dbb3108825fe440ad797ab7fd779d3bb7aadd88e3df6347e5b95778ff969f549c5c18a42e663acdd83f22b2193e32fab4247e590d3415458b6283d255aa42ad51b35419933a39232556025681ae8cbbbbc18993bf1b620bb92057f085ec384673030f4e7551e046588184b4c26744c5104759bf6d053fe07082148e0d3eb540bfbd51e8323a98c222e6377c769d8a15f577ac95ce456a64bdfe391bdd718808d1b75d0dc90295555cb7716ba1e37dd6ce91c99bca2d5d1fb5d30c5c0a60350821ab1846f7988e8debb9a27e5806cd161c5a73fe359f2c0e1bf20780e64380837bdc118cf37681d375f2db71ba8053fa746d8220875801681612a96f55c41c259d92372d6c0f14d7239b8ec7b93677ee15a7ca3ef049e8765b55f09b6e2ece8c10638993557f991ad361560417da90be5dcc86d396aa959cf6b8fd1d61e44e37e1606b84e06293954ed45ad6630048ee4f83e5dc4d473f554211dae2831942e87da5a20707599cc67a177138c1d437545c79c326eccb0f04cf9aee9374631a53e1b5dc98d5133386f095367caeb1bf81adc225888be00709c4c790185974f889512234f58483a76be445393ab17a57d5b4b7d39ea42c329f91b876dd44490e95a55cac62c0c3a4a9985d9b88e9235f8fb54068603fd1b176be2502e0aa16bfa77700da5e41c25c4efc5cdbe4844813fd5689277a60ca1b0798f96c3130a33ce579c15e4ca0e8918485c5bc31fc964ad43ad9538febb1580d4029a35c866eb475ccf0c66a9ea838f7bc0826c6d78bae69cae175bbc65f19cc644807189ec5294f9df0622ead3f959d79dc0bd496e9aab2bfd8532e4c2f018f01d8adb9cabf564c72726f9d1e50aeefcdbdd31c2700411f30daeffc0c304dbc4c62c8aa40d40e18821a7a4f7add44715b7be3c8d95c6a7339aa2e40793f8461e97ae002853191e4b32d1e58cfd8929bcb73007e9d737f61a443071e12ae59b59473434bd1723be2619155878c286fa44987765fa40620fc738e9ce5b533150992e907f12a47c856a37f4c7620e1919e828f3a3d8c28f04607aa2cc47d593ba7193d467f86f311e4bbac3e8241737013d78850eb850fcc4211b29be8b841d04deb74ba3e1c32c21a2716e82fac7a76872d450f38f325755860512eb467d84224fa159c1fba8e3019b04356b210bdeb7480f9a8bf2f35e732269c7cd11b96e1735694d6f0e5490c8866cf4996e099af8d0946118751411dd0dc758861aee1f56c8defb76375a29d4d39eb6697a26fb34669bd3c26abec225cd3c7df0a3001d103f6e66206c0837336c420fe96cdd33fe26ccb4fec027d23eee20490e278fbdd63d93fe7e11e96aff64121780e3d687d6df7288c01eb85ba0499dcab79cd392d7e3e3b1bef9ae024b5abe1ae836805a2a592d36e5fedb5c258c7cce753ebe6692fbe0b494dd2abd18d95f0250f65e92aec79c7ddf09578346d257f544d8ed7da876453b82f2ad25141215aeda59bd4ab6739fcdc515c96a8e604227410876c7f51d805e8fb04add49cf1404c4a7109658e7c6b06ce401f0317f34784ebdd72db07a9193b8e7982eff4e3bde05d819483d4dfcc3cc38e980d3e289b6e2335523fa393f57e26828fb6fccd7f7370b6ef608f83b77bdc38f12e4483574ac4de5c823c9354db806d3eadb6cde48ec827752de553e977e3bec450e190348bcac9be1f49ddb90e2620db2cbdd23cc2dba8407003ff98d140ebfe36861617efcadaef3d670306fe07e3f8822b60d7cfc92bbd36ad955d6cfcfce06600dfa2cdf91f97f85792bf4fa6d67c374243f63b38a2cfd8df85c242e0f0f9f1c456a7da05036a3e94e546a06c90d4639993fc22085c649eaab29ed319de151a4aefdbeb74800f1c56495a6489b2500c1c12023d5ff120535aa164970216b55b9a658f4ffc71ad0023ace15165da56ba60f064f911153ba393e2181088d270cdfc88f81566fdc502e0a759de8300b66316369418191d5e78d69444e959ce0bed33d929b41055948a889e8c755d40541495f3994ad68bb8afd0262b735268ec73236705857fcdded9ec8ff7388b4d1eb6e3853e0c50ec8861ec846de0f0457b2163197197f97ce072d390bb70519a11bb42027af05b44b69fa3cda373e4e648ca0b3dd90527cdc23dac9720d6cf4a70eb8c429b8858336827aa0250417bd53e0529f5878132c6e5acc9a6c913c533857817938fbb004d3ad15f60f65cf0b90c5672ced93284553d51ea99e80490e963ad9ba21cbe3037ab257defdd7a2235caab8ce26d893961707b8b739aaa3b0f355853d53160f011b6d4675a51fb8b8b49d3f81b2884a150bd4768ed6eea30a613d484d5b1625d19fde8228a02cdae4ba1bb34f937c1397bc2b719eae33932944d148fc42739186cf51ccd2bd4eb0c5ea6776ba44dee9457828bbe8016a6b780fce2ffe92eb5bce59413e266d8e2c86869dedf82ef8d5a22cdc106e95737a8f4c166bd1917fae61836e289d3698bb6c4b860f7136d454df1d795053b184a8c8f8b25a85b9c163dd3d4b51d670cffbfda8fdf0013d01fba86a92d5315ff83e899e32d5e3925975b5ab1e98719d6893c14e828cea26cd00ea9e631c71a2950f650701bcbd96c88cb1ae99fa8ca66d88c0ddc2feef4664eeb03e5f40f47a5b4cc1a04e1d74008af3b58d4c2fe74d1d09e2c7e86b5b2659621a31612a38b1369a3777ad75b9ab36d04b46939d71e76dd5cac62d05bf5dbfd93a88143f69fe2463ba8f13e13352718cb45eacb21433e466df2fad7df445259bf8f9e5c52cc50074116f92608b5b5dce16d602dc87ac865d6478dac60ceec1da70ee83db1c19466e69e57f48778e8b485a3fe6f6a2aa4f073cc2588d37a6b3e40883b8181d11f011833e632be949882241a62f8ec019105ea8b93eb9127f6096b63b73428b78c8a30507faf06a5292954700cbbb9d918cf6882eb4d4a20c4c5b652ce6ad52114fe9746c5143a360428771974e5937fa7b7bb9e30d72fd579074dc37d51b5b87b122a5f7f5bc3eb5b66c79342f053014ed8d5173d2b05fe2dee1f8d700155ec735c792954633af9b51cb5c0d60937a03f28c4ccb2cd11adbb02f82e9dac7b68c61f7290a96cf0ffee0d992cd12a71376d602eb43da0e378988dda616a974c9eceac577777a42e3a38930f75871e77f3ef87830491e6e544a50afc4ebe0e2f5d2247fec23a0645d834304b026239f6260fd3ab08cc8f2c5e8e77bfad5313bfa432dae1068ca32aefecad5f728e489f1dc7aeb389448b4222ca626317b47c2dd4a9535df048298be77d33680478e56649a47582cfa0b96ce0052ba82190275e0461991139d2230b8fc1385489d0981746254c938f737867d3601f054f35e3b73cf9d403d5cf07abff91fde42ba566c13a93a064f89ec548900d0460db1d48cbadb6731d65cac7c4f5f6b9e30002add38fd43500a3bb3a22c4dcd1bde9013ea790af2e673835b301c4e839eccaba5335aedbbf871326d78fe81b7ce49c53901c90a83e1b092eb17fedae404064b7005339eee48635fb50758de78046f86c8de212896598bf7111a1dabda7ca1fb9edabd8662e02a6a423e179e9a58f30c075c9a68de1e1b49c3bb1f94fef7bb5b98f92ac73a177f0513e72be1e293117e61add4c093579319b3bc7c3424f92028324950fa82dc23575b230d5154c71254c74e6be78e724bf70cda45e2a8d531fd3a81f3a8550a78fbdc3816c04a5d96c937d5f62966d881876f47473310cabf2d06f67137007169a4b97a86ee90a134dcb16aa25ece350a8ce12ccda8c0d7a2ae4533f75b7efacbd4daa4ae0b27e96602aae5376dfee15a33628c72ca0fb44231eae4953b53e7e21dae119d56f43807cd602798b8a5e3a0fc808cb7f7c7b87054d0f32b7387701a492ef13a353b477ad73db5054c869f009473d40b8ea3872173f9d25262b73256dbdb509f0645d30d326ad8f522fe5612b988b6dd16da50c4f83ed7a57c7c7e4bea9c68fc6f2e17ea46688abcafcdd98e10c171cf2a574dd4ea7186a559c13ab4408107c53b57f65412de0697f222ba56a764a2b4e7596fe92c0f4113f91f7748966f4018498b73a30296e2fee24c43695e023cb9abfc4d899b49236834acc641c15881c3280a0e32902083486bb712318bc5b91116b8aea89063046ea603f561ea6210ba7b27a01d5fe1d586a2fa0a93a645035835c3bc70240fe1cde97420824c86a2148ea2b55a7e74303c6b062efdedbee0a6508f2b5274b11a4ad356bb5fa04d5340e2523ff2cf9f212d0163317fe202b3738b7a5f4c5f681366b38d86655293a6703fd31d1b2f72157f5a8c5e54a7f58798f73f7a2f9983a2e7cfd8e01ef633a0f501893ddfa74000a3bcf80ae273d76d6ff9de6847562e030328a755a746f2d96fb960df6b0bee3544c5b15e4a45ef721c568aac7dcc3233f96803e211f459791a9b7ae549e9f270b96ebe106505c931e1112dcca6aee0ba92d4b6ca5e55cebbdd6e37e5fbc6e9f9e2f1b28b742c5ffb64ead8489a669f84522326d7ce6cbeb1193fd34ee739c874ce9793c67fa40a5273b3376e5ae612e68992180ded9afa80ca4e5d2ad74da3a99a1b11115f3e0586806394421a639ff0c17a50fea3591143b768f116854b38d257f1dc5ae6e49901e0e44a632eb6ef277826448c1f5e7204e3e61669165f1cd7c3324bed0abc39bfbe5bf73613952adaaac25ed6cd3d0c901725139dad30f3a7dcb83c87b7693d8fe391ff22f6d37716ce81c00809461ee265d00f9e1f233036e12446051d8d72eda0bc29960fc31121479537f27600a61e873373d8a5c1cba17d2e3e486ad8af4cbfe62ddcaa2285b9856cdcd7ac05bbaa4e6b05d91743c01718b6e422b31f1f9474f219cdbda3e3a0865dd29b6f3d903eb5401ee967eb8331631aef9fcc8f462a172d2b6a69f7be8cac0619ecaaa3573a7fd792b89c15b103dba0ddf8ae4716915a563326221234fc6e729351162df87a7f542bfe1d2776fe5e46826935b62b4d13157e1bfb72b6041b826696fcd1d8cd11d0cd775cc25970a8ea67b731e31a58b40c5b0b6a9dfde0777242d652d33bf2198aba3b157fc8073f226ad159843ade0145cabd8204fc6c93e158a1094f8a879dc9ecb4a98d9aa81332f158646cf52e5ae0b11688255ef465c8016d56f86b8cbab0c6d1f1694f6d8a0c5a8c25755e5f367b260402bb37a52c7290576dd2a35dee4845596f568d4a52e4f22359035c1a4c3c30502bf067770a4db8762ce29a32d670b1776e60eaa8a60ae6bed4d8cadaa5ae90cdf1dd09fc556c7a2f6d8c965f55d5feb476ac26820b51261bccbf28bb49668af83ecfc14a1deca81ec22ff160f0a941cf33a9c594e522c0882d3d1d9010edd82840e557a3e1ef6a8cacbd687743b93e00d4f2d148863f12bb5f81b105f5a5164aea39b50c824af30b70d16c59c1138904f2c0ac7ef7fc83e455a249c258186ec0597b5793d4d6ef9666b7c273c9eaba2898c1d36dfc404c8dc29eb4d87e4ce7adfbca07c3b70015e325361929da4431fff15c9971f4be3810f38d0902a1ec65350ff3f0bcfb498098e794f8a58759fd6d48886752189fdefa3578539089357e86b5ddee88238215740af7aa547fc199d5717e8b895f1e34627a2b1f61e3b223f509baaa71b7c8b3f593bd705ad7e97e5eb45e067b1cbe882110c623085cd9a98fd0cdd362430f99c61bdecec9a229cb635d4dbe333069404fbae5372a3b3e8fdd141eac16997191d0d4d361da4232b4bd454faeee56cbdfba0abae64dbe97983ebdac32babb0a289bca5f9df63bac2ba5a92ab240b065225c65b7869bb3a771931bf87fb6ce33220d4d91e1fb4583db948736ad75fc1bcd68dad07c1cf7e572fa48aa6b77e648fc5c3a68a83b07ed3b6945404003ad9ba5c48ef47304b32bc65f35305fa66d2affec2aeee4fb7c30c4600df1f6b999c5e6ce6a917add51bd4c0af96257b7147ac663477f4a755b805de29864882419fdd1aaf55cbaee188c2e39ef3b07f688d70f17b591ce673c8a7e0f4f5d1739a048dea1f7f254428a4d13a665bb486f0e675bbc74974490ad02c3232e4d3afeeb14cf2d2cdaa70d59daa19dba02d150a547ceb811b14e1de4e52e098c842bcca9ba9680f269a30d935f9840e4ef2f22e3a0a2376e518312889e4f8298e898f102fb3be67c4e4f2e918489d0020e069541892065241a4098b0a6e26f7df06876dd599aa52c0b57b1350dc83579fa2c16646b384c63232875483cb7bddc27d55a0349ca06f13acb892e0eeb6597cb4d4d3ada664aaa74a0b498ed1a966eec5a6e8a737c7273522b34fb6d1e35ee2cc13c51508d009b906da8aa9fc87f9847d1f02e89e47f53751ce36192f52d01f48c2c23b9ad8447c8f55000569f11d52a069b981ea8bf958079e1d3acfd6e6e81c7a7bf5a49ada4207e7976283e725ca9fecbd802f85faafc5d1cfd0c35b64970de2234c0dbee4e45ed58e2b399879b3e0d7a1f3e0aefe056e03cfd657a7044d80bab0669cb12e268f9ebfc99df1df9b3e8d96d77718ef527178dcc4f3fb3accdbb63b96ac723810ef34d64a870c1fe32c87ed58ce58586bcd12d655dc374ce529881014b250be897eca8b884ff0ce8100757b5f2df44c1903738e97e6c52cdb9c5462a67307cf5ec81a68087ddb51c00b4d6ef158af6536cad8cf59d2527c79429f981809c5df4aeb3d437b01f362349b06e9ccd6c178d2806df9377f6ae15eb24bfe1072cb97dc8e0c1f071064b5545bc245a3268c1e3153d4b07e0ffebc41888af4a1fb52583b7ec68833c6eebbaa32cce7baada9d856827d22a323d3e5b61f681cd88805c7d0caf572bf8632be7b793c929fd448d8e6e6b71d15b7902cf8b0310a4b57f6722bfd93a236f9a71dac28654d90ce9e4dc15f7079700b984e115a01327d6a9f34399142cffc84f7ebb26f9e4436186d1683c1574de89616d87a097d7480cbc80fa478c6edcb2630831701f33e2586a9978235b0bef9bcea81b33cca7cea0174c571c06b292ffbaa774784bd596a6e1fb1066c0ef0fc8e6e0cbbbf9c8d23d76806d259658b6e1333fcd4d0767d39044eb433d88c46414df3a08e31e1f7a19d3dda92383137c007606430dd97a4e269988c21d9e9feb002ae9758b6859c771f53759aa00913a2522cc3c723011a83a93379c4101b0e2b49820b3bc1985d649f90efdda1e292d9498c54de1b8892d12f5bd531a1d484e138e2c0bd3736a899e349162aec0d6bc017b90d5de72e9b6395eef140640f5a5ccbc880d24cce7190ff1c60a40365876d97dfd26214ded61f9bfd5a2d7b2928593eb007e3c7c73cce338e9a4b2bba698f03eaec743f19d8f8a865e120b1f972e679710483876313191c119b287fb78f20d90620d055141fdba06125f466b118a95444ea4d319a7414bcd4214b53b42403f905ecb2c3b9808ea375475fd6a741c4fd4e5ac69d2b1e9aa59883e6bea79708226df88c2bc63af3b9654b71ba65684743dc6e84614bc30dc066198ec9e4637fce78fe5b0dd2fed70309761ddf6f77a098f110ef178dce9e9ca30cf9399d0d76152178a80535ab3a963342698d5cdeca54a5dd9b854121f5f1a46e93915547d8920b5830f095c9a16df884e762503a3a855f1285be618947d6322afd25ef36687594d70253b1dd91db51037b92ecd4af62a4988e5e71df1db23aaab304d66b196d12791690355da822ef50914fa59d729b74dcdd67fb821c04922be076ba9e72017c20261ce71e76d28c24dc7d0cf33ae39becf917ed8fc02524b82a16e78ce5e102c82f16d0da55970e68a3c3f4c7f8295d511b5ec60402fca1f394b2e4a772ddf9cb879553dfdeb3d5f1beac1cf63fd11d70c5f9041436e5d6f9c2a57ee2760491dd60c630b40a8cd1eca60166a34307ac61ac36b4962a426eb1020faa5b99c428b1e67087411640d0c87aead53607e7d542984f0ed2c9f061cfb0c11502e0646a7076186fe1f8a31c939f4b81974f7e6384b46c69450083a174dd2bbf61c3bd73485e6b04c1e716e0df48166718f0674cfc660c1d57ad25d8ae6cf8bd4d16199de1b6004f157e4f9fc34a00cde4b0b5cbdc7d8c9b54bf2b82614833efebe51f317fd9314edac5c927f9d0adbc3303e38b99c3eb51e0ebc4289a3c5d54045313a02a5bed97a2a3fd2bf80fb1d9ed51875bdc90d6ceec96581f9a361ca96f9d113651637aeae077691d27481969b71b7ada083cc1b743dd3b54f53ccfbaf6b3fb120e5c28d531ff9cbb3d73df07db911273338ff685fe8a94e09823c87bd233d35a808e0bc6052e5c7b94c1edc4054f4b4f5ab03e566abe1f78242e47bd8040d67df0c94617411e96af6231154134404af54b205c3f90ce18152c2ee6a416f038e8e9698245f95c441e6f4f376a682c1f8f105cae7c3c51e8f6bac5c8686912aa5832592f44014fcab09e141081f848da63167f049c850870ae21342593700d0c006ed658c84d7a4e64b86a3f942a86b3610bc2bf4fb2d4639625553e5e8d44790567093eb7f2b79eb6faa97091a269bd6fbf45f10cb8aed27b194fac17043919e65740d0f987612f2ae8c76f0a83d9f4ccb817c0cab9bd794d97e6da94aea9cc3a076eba3e4c307f8a285957cef9ff926dd73ea87241775394d4871c632fd77bf212771ed6ee1d5829a5873821d4c364383f4ba34f3621b5d14488c1b097063077d4c8bab091cfa9f9a53d84a3737653a6ad0fa125af7b83d4f9890d0de1ea8de0cc0a98fc8d3e13520a780e27f6523d97e68641e6ef2cfe79d94f2f6dedc4bbb91ef3c9d1f9263c6508e895e8ab99a7f219b0b97119d37740e9a0f260181c96bd1db80265eb13e3c81125be55bfd16a3d4d6e5afc5026e053e3a65e603c675b3b1900fd7c0b6947861406e60cb64f1d5cc5620839c1126ad4457ab62fc2762667666ad8d2dc95d1f4121958d71aee64c9e13bda3db17df6d81ec5762b77106ab04afbc79b4edc8743ca24ae9a16f883ef0bf92feb1fe41f4da2e857995fa2ee3240898255d8c7960ea1ed3bbd3e322a003f004bed17647175784d9771a709518056d88422010b820652574cfa73e849faf857d5d0e7279ff7641e3ff3d884e217d3e1c102260a4ae910a8e134de7bd306bb9669eac45ed5ae50c15c9dd00ea8749cbbed10e4a724928df6e063ecb242e042cb954f745509a01872d37f6aecb23fe6ece825fa803d113a030bad172c14f681c07a5d802ea02dc9793f8d2950177f919d543ddf20e7597e446760d3f79c7efe6bb65ca2911033ab4b0508d4a9bc0aa6227992142439ae4c8f907207a633314cccb121f6fc52d7d0fa4dca84141ebdb6fc900a7ee59ed89771cebb545962e3f924aff2a5c22616eac7ad3bb60b7792bf8d7bccc81204c0122a271864705aa6cc310dbdd0916ffd2e59a6377363ed40fd5266088f4c8f45d2dd430417e52a4c9c77b46f9fc885165cfaeac03836f6ca211387e863aa058f57ec23c00c7e9ab4dcc30848b7438b41abd68ad71f2f5b738c7bb464899d581e9fe8ebaf00e9000c621a6fcffdc6151acb343f07301d51f55bbd49e3fe5d8425a06136af65c266820de3bfe633aa3d8746daaa7fb0798db51ad9207c61a43056c77ce2774aeeda413cd7688b2f05711d9b537f384a1295f01ea56f4f43733c5f6124940f7b78caecc5cbe82ac99fd0bff061bd38ffc1a02a7bf81aaa31a6ab0ee4dfc86c99494fd2b577af917d3e2fc4841100a36b527ec78db8c82ca4920177739f48a7fa7dd7ebfe08df2e2236c17097f1d426846239e870767a978d813c6055130ad289adba4019b76417742363e7fbd8f31e08dbf009fb3daa2714d6e01fad18b761bc10949d397a2d255b790256a906263b6089e4e845a66562bd8eda70a582750a7596d5851240dded2bfa6a43cd003e1a0272884530834fcd5e31100eb76766ebcc908b5e966d79b589832e3fea2ec5af5bde950de707aa6a1a3a04b1caf35509a1169a4d312f244fad59cef068b5ad67935e9d58730f78e2c971adfbbfe0c2113418ac7b27dc5d9c091909c99723b0d2ba843b3adb66a98f53f7e9ce0fc04ea37c872a86d4327d4c178934f9f3467fc09b977f80fc08d41ee58d1ffaba0f9bbecf06a37100c87c5a91eb555dca7fb0bc9261bc664fdc49d0c235eb20e07c98bbdc0a10dfbf163b862b7f1b94b238d955ba8d0a220e33e44f7fee49b00dd034f3852d2ea9185a80a074525038aab28cb399308bffd8c5d8bf9b7568ea735d5f7e551c5cbb0e0feb402c788680e395292efc8302ee18ec00bfb48579dc6271d05a6a3563d3bd7a0162d7673e72845d5b319840ffeeeb4e8fee3ae9ad85c24ff89744cc78211fdbc1d65f15007c784df9891b724cebd63f6047e617599e6d0c2239dc3a822e3a7384fb65cd33d865d3f4d7e46319034ee8191349dd9bf44c8c33048c6a5ab8fedca159f569bd11fd0a4fe33796cb0d862651fdf2301e2e64bcdfe299ca102b13cd226bc343055adbfc82b70431c0b03fc1e04000fef38eb4f042675f2ce4d50e1f4a052b2d370476f52e31480e27ac5e60c0e7f7cbb39e3309ce9d51e9ff864f0512bc4e00e952a399801dd9472086dda39b4a216b42e8e3b86df9308212c9de4809c40b3aef642f93183daef1d878f158e1f1e3d91c4f6955c782c1e4427c829154b2af35ea3f53bd824ce69285e579196520dd514796cdce9446c147a9405c96204b9d299b9c3a1eccb17b8c9e2dfd6e322f8cbff1083e8d89bdcf49259b6113fe4e49651c84359308b21212f0b640c0d043ee3829d5a402306bdcb9c41bbd84a6343d3039d11a159c5e21ae77a55b0de764238783ff322d41fb7bf4834edb37d2ee363318eacfc319fb246bab741bf0bf009d5821d09b0b77baeaeb2e048e95a467809e56c20e77c7f979c080ab76eee8e97444272a7387df745204e0f8ac02f6010f93b159acab82f4f0b0d9904f675402507392012f64a4b9032307926355108853030f4b0829f07196cbb759796fa6b615fbd5f45f0a1a806269ae35650f7f980b453532809e660214ff3bbed4c66a4d300d8b85aabb0f490dda57c21d61f9d54af73b0bd3f5dd04f17daabdff95a01439c13bf626482a5384909ccc3116276f1fc34ec5bfdc547f97e9544c0fde6d77de8cc026533eea9cef213d6636a1339d58e1c8a1f24e0c7c1e7d5171ddbe483c6c0328f4bd15ab8cd959d8823850a582bf116c3f12073f1aff1848864e05e5fe79ef1b36fe87bc34e85a8bf3876c42f9c53e0047c61ead8a8e6ac2bf9e92568c8f9846ccfb1f6f9f1f90e2f0d4df66b234ee4159cb6c6a2524bb797486eae5bf0cb80fa3c8585c2fa8c00368bff488a8cbf9ef0b762ba69fc369266cfa9d967a507f6f93c605919978ee4c1d1a13cfe3ca1b9c814e78f934057b6ecfdfe819612b81784ac104ab1e2368f66a482acb589d6fecb4957be6ff81da8477e330846da5012c0efe7ab5c73a0d2451305674798f42753b839b5b76236bd69811bb02731e97bc4776d9b265e26ff356d8d3141c63f9c3c409ad0dc0bf51d89be178d92238a818e278ddd66f8d4c3989c3db9c1ae3229d1e7d9c959a47968524d35b248b0c8d4c2d2d52ff2bb5b6dc9e00ff8223a02db954bdcf760b26ef9e9a0bb61790a3a5a807867e446585f25880f3b4f8e5c55853c55cac4b1d5410073ba9d103a8b311c3d39d944dab27ad7bafcc32c7047c8393b2abc8ff46a2291c4ed0a4c44d40e3b1f7673d21e593619c9e110ce3b91541bcd4de1b25255b73a6585d1baa2e69187e89c8ad214f8cf03a0afa34703dde82ac4d09f5d907cd6b78c828341d79e17041aa18d9f4ae8b914a7cfdcaf1515f11ff47ed47d936854ce93378d3d2971638e026635cae36311e44123951fd57a79463ab050e88a1866223771b18d643599e91ac22ce3d750cccb86c38130cb412bcdf0ec8ada20de77d7477c5ad2c9a4160b1fff432c4778cc6ea6756dbb475bcbc624dcea5adf7d94bda459ecb6dda7a8a9f86368a4c827f9289904ed7f29e652ef790ddb25d8c8372d01e1c927f4a36b2e0721543233269ac2bda71760cbfb5e1541f16ffc8d8fe6ebf2586aab43652088423c4de4623cb8868718169ed2125406da995897b6193044807f29aa540f447789202b3f447fd3aedaea2b632a48a4581dacb0c1234cc608c5e9d75315697ed7f3f3cd10037e65c2796da07b280abfe8534f927c777b244086f365e579df1b8e9a53ea641f85d80fa18a2f4db8fc4a1fef806c9759024dbbf5891f879599f489a044fd7777019087602bdaef6e8bc774e0622f76ba566111666463f04b6136aebda2ff37fab8899fcc3724926f8c7a307e47d34ca0550acc99c1e9f72dc7165c7ddc8258c8e308db1e060155efb2b5850a2f48b16d04e2eaab25f56eec84254dcef2d6920d1baadd2f932ec7e312acd3efe4779c83c3f3b7e3974c2663a2131941dc38801dbfbae7e357fd5ea19a4e0cf9f681a93ab9072ea85fab73254f89817941269f78b7c8a0aaff0906b59a95531cd153c157432fc3b9b8391b057a57b9a74cb690841fc24211f4728d66dc7b475f8280a9dd5110e1d20ed1448f5b7c79041ef6e6a48cf7b0627205469e482c7c5fe605b44932edebcd9b293c4aff6147edee218ce723a078b9a00bbaa8d2f77e89d820a7f9fce4c795517e1ad951e3614e8de19ef28c97da876ab8dba40e272e2d0c2cf738f0ca17a67c596c8930475e6bf142d4209cd4a515428dedf901f6068f893ef05ff84aaa8362fe0fbed6753ed963cc98447115392fb2d0ed4768edda8cb17a750c2d277ff02513f8e22e0e62f1f9db2732e774d075859973c2bc3c37cf17145645cf51f854aa8ef89c889455544baa0d45c4efb46e9bb5d0670caea1b5209cac6fc16285b668c60550cf9f937e65a7fba8493c726775bc2ea16bc536710753244dbeabaa0bb1c84a39260f3e9ecb5db8de1c52576bbcf5e68add4efd6fce7b71f0d00997bb4ff43d56e75de919791a16f4522ab8a6d3f7027e3c8ceb77699f1c50a16098697904b31a3946d47833e81f2c9e4ff83171efa866b2e0cc808343e2e5b681cfa2789b610f479a47ee66a3ee73e01456c9c27da085f7ded5dcdcdeb6cb84c1ec34e3311a281c7b64259fcfcfd7f943de212a1f735e2e30579ed8b21a0854825eaf77f42e89afccbc1184d22ea7ef150650ff16b9236ed6c806577687e4e4f2cb83cc31ef5ac61da1fd1ac921263a220744768693f5a6b36bd7adaa9d093eb4eddb18cc380d9dd9ef16e065da00cbb208bc5e6a20f7ee21051394f9c531c02377b4bfb11fb186046043ba2ab8bd8b7cfa04ee0faa1b96f88cd1e02cbd6f10ab8fccbef47fe63c3ca1844564afe5438b5025f925a263242b9f44e06cfe30691032b97f2400c4381c1bb07368a2908911fb201600f71e96e76788cc65564244453abfda8084468e0f65742a71cb33e1e383f1f95ab562a10241e5ba390411c7a55bac47a667fd7272dbf8ce1bc47235bebafcae9ebf3d62fe585ca5b78b642d432784cef4d5f762184f1c275a8adb7b7294ccc752265eec613612be770897c8b2f8829a860adfce79443ad851394ad4f7f89ca3fe6c8ad97fcf66a38e23b0da585ea70c92e727e691e2072418033aa39563c36715d3a975816ef36e29a0b963d678675b5eb12192e6173cf5e71affed6c30f3648189f7b0a8b9dbe4ccd43f8d3143b23c00eca0db5cb77f26b865038854a859b26531c337c6689b2467fb4c34cc5f750a055c265e744c339b2a84d5d9cbb93cea749e7575ada9982701739c67c496e45bca104f718c7665b016e39f920aa5e2699f22fc0c83a7c3e08dc949431a8b05a2ecca61e7eb16f643b815e532a2be4c99a74945c031d0933bf05e426ff75934c933fb28ef0291be9d775f9737040cf3a1881f3821422c0a71e19896eb644f261c1da368deb4d1ce7fe4c990e3c7aefd362683093","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
