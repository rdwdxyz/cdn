<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac7f77cc4800e3583304decba09285cae6159850326c28eeb0f915dcf8c48906ab7b5f5dc283fb7990b21df78eb06d39bc6200eb0cdbb5b53c2cc046bc0a67ae85bd6c52a7f6921c25dbcf3c002cbe564ea09723bff5a37f1741736ce3289a4172622f0e7d01159cf85343e213dfec72d0a283c80405dbf628cd11950c19f8cda0b948237dfb489bfd7493a7bc3c0d7d50b8c72a62c16a61c8cd758e0dd01ab16402b348ac0226f21d8e3df18c7f83679b89e7093bceee572eba23ef79461cdff5acb8dc87f18fef328a6deb3fdbd52c8292735caf695df61e45480564dd02d3378257c9d32d2acd31196b2b944620adaee6e7e5ebc914f1d2e6b724a1e645499c155465e457e6feb92b8374a9b87fba93cf4068b2239270054525f9f43e93367a67abec6876fe980a65747f4822a231eaeae452dcc751e1fcc595fce9b9c164bb86a925ab82be64f4f0148c068f7d66865225367f73280a8c82a7f56133b2eb168e036dd1e9db050d024f42c73aabde3690ab7c741250d8ed3198b1e12bff7074f3ee62d857b91a494213852a098edb0c1b540ef109ebaea0e8070bb7e8cfc1d2b08e5a1be17589ac9c02ebf94cc20415c4bdd77f6e216e91514206f8e569aa43567e19cc675476cc463c5bcac17cad9026fedbf2ad7cb19243db61bc6ac9af7902b816086516d7b3044eeeaf517cc19e2c7be19cc419dd590793dd452557e8a2f3d5ecdf1bd3710775ca23b7155df9adb942b300dea4926b39ee5c8ef2a24f76367a5e0663cae29e99328d5ba7648f74359ced87660bb620051968e29b81aee2b5b249dd5e0c546b36ae2894585818ed207660445f14a5450bdaf668d3fafc910d73d8f37cdfe2c58fab1abf3634cdccd7dde2df9301bb0c79a19e83c8fe3d0ed551e6933cd5c8643ad3a01969e47c462995fef7ef8d1af2899812521e54df761922ccb8c9b4ff9a8b5c8c77721f4bff3cf4f75a98779bb7b6bf7f8120a136012b697dc3beb714bd12b283ffa7871528bf078dc265b132171817e2651eeddfd01f90441d71b0d75ae22d8211b1058e2f1d124025fbe75bc422b72dba9ccd273b356dd7c5345a806f5d1a3f8263d1449b9c20b6465020acdde9755bed95d703e132f817b4847dbdb83643ad8649e2a92251effaea50e377c172c01858146083c63f4698bb7d833c59ef0f77ecd082891defd9ca691a7e9446b297440759c8c2a7817e6df079805939ff11c2592d1a5bb06d0a35778bf7310f50e7baa88a979d17447a885784b3150bb07969a1d911562de1d8800110cfbdc831a1ce9a5e43fbdffc671d282cb43a3c3294569e6c2dff8717e7b390fdf8836846aa89494a7261c8face9027dd215c11145454f2d80fd4232872e19f4f02bcc33739a3c5b9d2a7be5ec1b75c907020ec4dae2d1bbf244dd40df83028713e3cba3474af7237ab3d3ce1af5b59a0fd65f55317e9fc179ca4060df5e1e40152b5eb3af0023f6da222b90029e8903c345cfb341902155d372cf076d3746c277494df61ec3b8c89af2435037df25135c08c19943cdef8bbb2e19859451cd519e0a512108374b14de965b7640b66e212a214ebcb49d494737ec9f276400632708bbe49d0e8ebd3fd067271460469947d72187f0087b3bbbcb06f0215e5ca755ab2122f85b61ba00bf6801a3c4952b91a34cc1e673a2f851ad84c852960c5169cabc596df54a2cdbf77bb970a1f6366de8ff5e61dcb420c1c8a235589f39559e8bf55bdd74cbdf3560db477138dcf6457d7cedd5a929bebf8a1edbaea139c6dc88ed5e6df4f71f70484576ccc8c612d9f39dd739df916960b0f11535313ffdd71b578be8d87cb1445fd432d8efe62db562722e1aac2ed0ae3b8ddd5898483a02b96da56d1947b3f3d6c895ab506bba94ff58092a35f91ffa244d0e0bfc5fcbb4bed56f700860b98184f770d0ca5ace241c0a078310f71c5ee654e14ab0c3213d4d25189e03c25178951dab2982332195326661f62f19b7a91d55425ca4d0fd814f8cf321feca5b409597f5a898706ded80cee9f95670bff7441f234b76459f6676bbb5b1fe58e9e2b38d5a1ce59ebb5d0ba9e24a1df618c1d5aedc87ce9b28142ba1cc5f3be79e5ee3e4a4b419688d6add7bd569e721dfddf56b95e39954d01618da08e51f796136f4ca59268b93952bfd5a09b0342862db0659ebec3b2c12ff5ff0aafcc2bf843b837626714ff8f1706a8f625999e80b07b1f4a9e6f4175b3b5636ac33a010cb96d31dd57b3853b885b17fda1e6d1a8a94acb2cf7f93f45e0ccc3090d56aab136078548cdfe337b38cb6d49a682b17ee2a9801e44ab190101f0c511ec1fa6d5cedb3d2cc93ef7696bd9b758e5e87ca820e394412f6787b3f7dbb6a55da4feeb5501cb30f9aa53a1194931e8b928d68056e3d47e3bd8d91f689812c36e065ab750d7d82f44db3087f7eb084d04c1184c606f40a776ee3837ef675ab321639e851373642ade8b093d6af49a181da42c72dd2efedfe879e0d47b24c8028701c325c990672f0e6c5541c84eee07b2d4b55db166f29ebed144c0393ee9eb2ae1ca9c5bc28eadea90f8423cdc3973853478dfa5c9558c557feb5456b9433d31a3a347b9289586f1342bfd66544dbd724ce6e2bb8eeed4e79839afb9950ca02dcaf921b57309660d0d6044b24347420d2e3d2840bebedd06c991dcf86ba939a9aefebef6f35805f9280499fa64f7505e21f50ccd94ce3925ea20f0d96453e5c03b71550be026d64edfe5290ed63ecc8d9957224aaab345feb3ac678b8692bb0df5c91501dfc04d224a3c41b67311fef9a85654159baede1e3fc562fca4dd21ffbebd3fcbf614b79a5c906e0e8de9da57d252b149b7d9d398b84d8f92ce73c01fda3a564918da6dc6070557da221e6b1181bdf7cedb0a00afad0c27fee2824c1f9166713603e99fef4be84c2c40923bc51675d533d84e3ec5fa6c7542a39c6252ed5080f8b82b000cfe2967a5da49a46c22928ced6ae539b894176db7163f76ffa080e03a5650446d97154b9bf86c85508eaf67023f0afd63e364c4ebfc716d7261867cb77a76d1dd3b9d9c68560301dd1642fd2d7b1fb21916966e8502421c59cbfe3cc319d382c7ceadc47f5a605e9e4d83fc814294c1be14ac0df165bc67f9ed241ec090f35ed0932966d75f456c17e515b5bc83810ffd2e8323a30c932c3480832e96e8e8d91631930c28ec15bffa095d7a25f4e5785f4188d20a0264cf5be5e16ed7d2f57ec384593cd724753c103e77ddb69ec8c013c27f59fcee9b71f61eee56a78d1aa8a785e30dabd81c6c4859f949bbf78f74f869b61e7548c6d72498cb6f641b770fbfec33a1cddd11b1f7c71d1f02295f470184277798b1bc322d1da1716decb9b756247a970428b0bbcc7731cfb77731c62e35c83c2d2eee6322ccf24e9c3f868825b9a2d4d71eaf26c07cc789c88dd6adadf1a9e4dccabbb48f412fedca009406421386f30aabddbe903e087aab8865334971bb536d2acf55fa65c07387c82c4aa1c2bc9b7d22a85f2dc27568e18283bbce19b18f90f31903ec6804104f789abe2e9066b4eb60401c24d28c26258e9e7550c2fb1cd5d4d9ee5b9d8689fa8c0b4d3632146a8f0f6bec7434c904c7209b4a2477f265306a75fbe63848be93be753e76cf84d8705faeee73dc5fa0ab8cc2b9da527dfe57d457bde234979ebe766c88a0a873fb6f1e63eea5416d5810e576124ffd500cc964881db390caa9298c75c5e581747c080077ac58c99734000baea95a1645d0719d4d5eae2cd433bfe5b654c676d23b2f965f5a04183046b34fa6e6b36a5193e891971904539b5f04d875bb7f264f645a1ad668cb2fb7be684b3f75a1df0e2f7e75330e0d4e3068a285e7b457c86346ec25dd990a7651dc360e3b86884b1426a65c4516bece6572bdf5eb116b7ea1c97969e2b39733cb48108308fe01f8c855ea9c25c74ff0598073eab8305b23c11252ac9b6f6c785f255c5f87ebad56cd81955a1c333e853e120857cd320e74ec20cb3e4d9dfd408d544b18bb34a1880573e30f022ec48621ed39523923338a3c84762283a9014d9b14b9e00cf8723c68a31d09e2f97c213307b4c4cb82c72bc455b3e90d4c7b77591adc4317d895e9fc0c84c819afe08a572220e96a20d220ff802a63f97e956a4adcbf9c70c3dcaed0c8f2ffc5d2a4cfc43f74438fc4151d907b86d4969ae434480449fce8824470d091e6f12de70836098e7703356b7bd1b5a8a842dfe9d3030102e84e526b6bb4c189bc379e4e652dac956950fefd0f27c2196d16e05c2dbaf00968f3aa6bc89bab901cbe77053bcd4bddb7a599f50d91aafb14503fd092064f4cfba6465a05d021a776ef8e30f2d7cd6eefe2b038191c7bb071ed411f936eed76b63d562327138a9bb10b13ef2739d2ccea6e861830f853b545b2818dc02d5b4b47f912b3f885381919f86fffa81678b2e4758997975c356ebc8c8fd488b9154dcc2d17368068ba267feaaaf439a9f66ca06e4e111d17542b4fb07617a553a526354dfa7a9e9f8506da8dfb56752c7348501ee05b7f55fcfaeb511d164d3b08f82794043b8c95de8d97f53c9767c32e50d240090244056714cb8b263d05b21604f95a638f4e0245fdcb42f2778ce3856749a702ed7adcf8bce3c73a634aeb1d06249e6984071347db08d13222498df2a38b359f7da1fef5782a7db1cdcca76a30168f13dd6df3e31f15cd45bd6980382df0c022d2c922b9e802a9df9e8cee25b63d4f70c81d0241e6a988ce4e275bdcd83437e9925003cefd335d2323080985603b242cc30c34acf26d6f2a5e764eed4036b343cfb3afe3a3b1c8b68f0ae402a740d68608c2b73a5268ce4222d604b203ff0c7895ee28518ed6982f8aafe1d988f432a8d55afec8ce4c444565c8b054d7b134f394fc9f6dc53d0f9939d726920a3aa0dd28a4b4eb6d6b2ff3c194f95499a2c7190607ca6f28f10775d1f2dfcaefc440027e9dfda7a73d703b8ca68f0ae2a4db812b13625e08b2b0cc19745f04d56f50950c505b71d56a7f1b4a67db3652b63dcf43f766ae6f91da41b0a3bc117f2c26dd098bf5ea4a7b150323514b7492c07be7aa4739fe9a820e617a3f158b0f46eb0f6a06116c66a039fb251b8eb6a12ee8027c6dd7f49969c252e388ea52668604c452e9155312fe43fa834becba290d12f215e0a4b0aba334de525f9a8cf99902bfde7615ca4da101122dab915c1f8b76274dd7025b421d065fb95c3a60cb41ede09e34b91c725fdb300ff52bc401c8698f3a44fa8715b622087f7dd7cf4287aa5bfec27d55b5b4ba7c43edbba044283d622c49cdf902523d3c4cb69b1a2cec06ec85cb6f3da3321eb751d8b93a007668d9ae03d65ecaa8735b6222ae7bf09ea39d5a8ce7e69e73a9652747cf006ca95e2510344a70d1999e298fd7c62b301ac73bff865f1077f9bd20273a939a90d649dd4d80b100ac96fe1102db225ebb46702840fba8c0eeae9064b79b4d094083d299a67303ff2b4efb67833225cffa6dff67b739ed183b5559c7b40fb45787cf4bb96e01c2f9d10ca24911438d54afd62590c6c42545ff6688384bd010f538a111075b197d61d335f6b28f74a8ac0efc5041eb59b1bd530f1ce13fec7c7d3575f057c9a1eb050980362b6f1afaee0c14a44d24580119262f10c09c4addc6d3212490c7ebad2975f96c9f62bd0db8ce465f32a3cf620f83e9c2315bfd5d902e29f0ba9ac07475d10ad36ad133d16209e359f22e121ad039b47b69573ef05074ab38eb31da813b51f92bf2993c05ac5869df47568fc3e97080fd7f9ff1e00fe8f3b1623ebf5517d6aedc2a949538e36b65d223fa60bf723b92af63a15209f5122495a402531456510940182f95516aad4b40033a01f02876e56be13859aa8c8de47959ec36c9dd4e548e2c6aa80abbce600be7c5004b5d80570c33f64270f04d98e49478a521c9ec5381ddb949c61e633f02c2d6395f4c058f97cf7f97f5931430ea4b17de0d85de49dfb254c9f5a2dd36454606cb53c8eb8d3f5ea1083f93bbc317c14a77059099b6e830150bb7e9eb8b6040b933b3e2d6be2358b4ee6ff3cceb7600130c3c416658d214aee2ea7f04e86524248f2bb8445fbd06cea72374dc39bf48a8e2a4deb274a474a32b07b6458928d1afd0c5b8d2951f6ddfdcd4e8f740b2d3f0a83b3dee658dc5748a88a012a4e811db207375239f7492942909f38448d898144732e3b1ff647ac411b8665c5c772aedd49788b6a35583e5a15feeb1817ef5ed6613d00be3ab3ca41c8816c63168ddc99f156a0fb556d74925feebbcfd4198809fcb3af13e318d6a5dcb60a7295213c5c881149d4f9df796ae2c6b2a8c8dee642701e6419f0319e227c34382fe5225fc6336917cf759c22de20f77147dc3a5031a0690b68562dd38c1fbc7fb6ebcaa93c24cbfb5b512fb036a4f1a69c4686317b7d93d070b7a4e435009569997024a9075dd0fae4996626052fd2cfa474e3c6db32824c7ecdd66f25724c63cc9b90f8de942b61b7ff53e770bcf3ab7a972ef67ec3007d346ff3dc5f198dffcd25775851fdbc7b67793711c77c66cdc6d2c7bdc219c61ed174b14ae12aeb4c56107177c25773a2387f46cbe700a47f38d477437521575256e2bb96cec3a8c593cad76e534bd53ce9b906ea1195ee987693874a001179fe2ce70f35fd7015a8f43c1adec59083cd788d19aa47c40273f0618489785894c1f2859fb66d38729a8748726c21a74a08b0a20f3e661f4dc87d43d5ff9e6e599cb0cca6637fc76019f22d52cb8dece453e651441a57c11a3730367b6fd4faabcb3c9f3f547ab1a0631a38a0a58dde0e9fdd330aa1597df02b791301b8be0f806c938bcbfe68cfa1b978edfe205a03c0bd9588343b2b3ef9e941d4e1d43487c64be350e5d84b7ff9cabb3cee593db80fad266fe2dd5a0e87a6d4a4a293001eb776e922bedf19e364c58a8432380b02f11f7e25ea5e82df4d263f6af1f61a5e426b17fd48ace83442baed77e65028db744c954a566fe562edfb787bf9bf0f2905f30011511ed5d744588f1a2fe1f19aeeac48b456da6696acaebce91cbfd6d40923fdcca6d44322d8f184f5c010973678148059df0072516532110fe314d0856a339ac6b0ebc4fb44cae49b0696bcbbed793f9c91851a3434d29e0035700d028932f1c691981831529b0ca32e75a25d76ba90ddfae49ef191e1cda0738a1e9dca03f7e73dd680e06fa7ce22bf54457c364acdcbca1be7051f5468542f39a6bcd1eb447415c3dbfa9553874ba850c28cd85a8a9cc05ffbe733c5af000b63a325d2ac59eab9abb90a6acf8f74c2ef1dd29cf98125998f90544933660d4580cc5fa2fdb00479d303640838d2459f12c63f67f9a42ef4ee4728029bf8085bcfaa9a9c6df4b3c56ff5583d561b47c2bb6dd75cdc3aa3425028fd57406a5aedae56b94c888041969fc56cb2c76d5de7b83d78f384a1d880cf4fa7cbe3a03e17173eb55698e2585a5ce4a04cdb4321b1c1c2b708784c7f7cf5a7768fea59a6c31fda498854e1fb0b7df410acf302c5df79e5fc40e201efdb6a84d92070bcf4fa9f504b2beaca97279644d98aad0d6cda4357df0d881d7a318133e3e85697290679b64d909aae7228b0f56116a5844b1b118a872b1b8d6258a140ed93e32cdf922e1337a39b40606b9276279c92ef28367db766df5a88dab8baa233d56f95cfa34464a06d1e7fc07427512c986ce9b0ef03e0dac730fd405a71a34f11657a4661f36b9c75ad7928a4f8adc344fd08a57a1e42078e07c118f1ff533272243fb2aef059ed38a674c3d28389599ba46f49fa7190330a6df33fea346575c10bed20f7fb0a411771d3c7291336fee62fc5490dcea0beb96ad0986cd3225c15880ec189898b7a6ea54b7decb4ce1d58229b7098a53ddedcf2133c35fd649711abb3ae65488cb9141bd28a58f30f87497eef5c21d633fac5a3e368d70a27d2f0ec2b5260cb90420779a6e406d1f2358d03e5a54b2859dfc7cde2beae6f5471dc984bbb868093797ef7130085086d65b433f93ed05b6a345b3a93ed9f4d1db0b32348c02cd6a0a8c2d0f0657eb344058ba23fe9a76e6512393e9af8f08527d550e8b9d99538718ea6290a7a3fe2215aa9d6838c441910f025690a075d198faa1bac4e9074d59d6ed5415e0e4e186389f2b389173bb337c98ff37695a2cecb2fb3f6a4d89ee38c859b4e916cc02627acabce5de6b06f39f967ab7be85c0be9279ffeee2f90d9b70a0f102c20e0df074ef654101fa4c70270d98c8d08067411109f21d8b67591d00b6606a161f048944501ecaa8c452e2a93e1bdd0a255fcd8fd3c4f88f11cb30c58bf0df9debb007281e7b4655033942ddf30b7ef60080cba4bba80e3af499512ca920da1db25ef3089ecd25e953c605b3884415588cdc3a9c5d6caebeed1ebc5e9a80eccad9de58623edee18f655aae12e01df90428f6171256cdc7c313cdd42fb3c83829a98371241f37666de07ceb125559975c306cec71ee2eb96e7ea2715a65eb644f816034074145887cb66cefddd0ba2b3fda0b03dda7410e196f4455de3a40bfef7f12091d7c97e57e4e6fa6d99850a9c8062a126b38bdbcce5b76b3d0a3096d93d0b237a095be6f7c44dfbd7095ffc25c40d9f7e6759359808de6c3e51821cfc9b70d2bcc9592db287960763bde7e00bfe9de28bab366e5fdef1f9b5c5d031a8a8e7794eb6bdde94bcb5a6b446f21e9255c65ed8c9851a6b1256b32822c9fdb45f3a6799bedd1126599c53b1c47db947d4903f6bffa8b189e3f77d98dbab34cc8d3e9dd0dda8e090bfe1343bfa69d2804b2ad3fbed022827180c7d7f4948d10dd9f8d1a30fb6aacdffa5c9e6c919347cbb0ac4075b80c20e8493c9d2e6eef57ecea2ffb1de6be3d63af60618aa9b978a3a3c7358b0385e685ba9ac1c443940582fa4233e2ddd0e5959f33ffebc5f22702e741c0a789f2c396096a0bbe4a672b3441175597b108cdb43b3efc6e7796ee2a6b3aa6f5a01d0b952695b35dbf8818c13df00b47e2ca8fa6a498aaeb6e26ae9de19535eece3fe5cc7e9e35130c8214781b27feeb156419386fc1ee314cbb195712b7348c5d1d882a4863bf77817f5d254e15aedefa0eddb2b5046b066bf7bfe58e0da5701cf0d0427b4e396604a8460f3a7ff050289bfa663014da0502e8503d453ce712ee2428d56497217333b45580ab199b21a551362ee30f258cf786859b737f7ed4d9014d03c4d2e1c25ff658beaa68a6daace2ba617740b9bcc17a63d42ffb63c1ecd14245155eb1df12e957443f40621b07f62c3509f33b80e5f4a6e1f1ac5438ee32355733bc60fbaadbcb1ace71fad62ad08aa0ce6ad6bb3ba02e809b43d9fe458ad861f85cbfaba4e607f1601f081efde6ed508afe244610ecd36fc1cc60c1ebf130be0d6533b8cf62002545bfddd8c20698bf930bd97ec55e981087bbf3105ab278f2f9e67dceaddcc69ae2e9f3e9d8e7d1a304e23489cf76fee75d3358d6321812b4a6583e6593b40bdbf1e79fa0bb9eea620d6e8be8404a80f881a25347d6be7caa4846e657cc916ef3981da659e73b879bb3ed7abc61b74deab1cbfef47a7968955f876fbecc42fc9304711efb14c5bc6afd92eaad999d3f0b7ed5ddb4b075d71a0bf32540e95d46cd46163b1821e3ef4bcedcaae11a1a479772d2791f7841f7361153accf1ec0eb619fb7c0de37cfd56ccce0899ce1cca90897998a992837f5eced7e585007d53498316afd64344898b2bc7eec2b0f280f14bd3296e0f297d38d261f3eca6a803ba29749e2f389e5ee8766e3fc7c037459864a275c395829e11e01797a96d0310e82a768ab40d477a99c5f4cd0b06c7a72d022f90c30f387d0ff94d401c916630bdd62d48a46b349b3b14e8058ef8d200e77f23450156c3b49e6a7a8cf09a1ffcf0ad9b5fe9bde7fe32fa61e6187d1afd4292b95990c0b28ebd1b6dca3cb53af6308d8a433da38127deca28f0dac5938d6a789ceb44d320946f4a2accf24c9dd106132a69d02ed16e10659d82cf856405fe0c2f25eba584b9e060276e7f193d8a9cd0e8ebf0f8d71b0fca58c05f01f56a1a8015265429221311d281a59f95766cb8edeb04847b51023c96f4bc9574effb123fd7015cccace1fdf45312ada568123fd2d581412b2600217891bc7319f06c62ebff64ff7896d43e48ffc335500e00dbb079c8bbfb46765185a8774a135135888bb65ffe7f3c961ca233b66fbb2ef2e9583447e39272b980c62a1b4935960ebc8702d6edd070ff325ebb1912fd44677641693f9b4513141a85c5edd269f43a2302cd4ea12f4aeea3d9e0a687b5eec048fbc08441551e1c85630ae6b38289b4ca89ca17f45138059a4484ea8584b799fecc9584e6433bf33f33670d0b3600c05883880b7fe796aa41187f0153cc74dcfc3dfe3ccb9e1da1058aa18a12809eb7cf9be877b8255bee17d2b0cce5d99fba80dae3738fc66cb9875c9292edb32adb5169ac7fed552f2563e82fe8d625f6167ddb7bf25f5b4a4626f711aee6b8f053ad5e1a17d09bdb358dd4d29ed7b6dbc8820e7c8532f05c9a6c1f96859a7ac9d5006286c958bf5bc0ad69daa416669b8b0d5d4ac7bcc925c6fa5030fa4a0320767f4ae4dc591bb6d765ec4f1cfe98686295856f50e111a5687608f995a4d67f8233e336267ec31f3694ae3830d1f8704e262cd380c075ebf20bc97c40b2c72fb30156f0dc36bc04b50b75ff6bbabb8235ea5c62e7c0a34dff2e944b771e554fa2fd87244f3ffb78a2bc3b98b464801bf266e4151ac0120362f9d9b77bd87284b7d1e25a79b5baedc52257854efa4c424c801e22e00298aa76b07f8ccb0216b2e7ef6e445885d44e17589f03aedeba098df187f1c623727698cc9d58e07c83158b272a8d629f5087d78a8609096322dea52a28a2cd069fc925e13d5fc415e801d9b28676b0bc955b62b580db3deab0ce8c586d91627570f64754a8448b40bc07bb1901520d211f162d2bf90b5d6220118aa343097636a6ebdb48d69f3ab5e16537d8722bf88b0466c2e96200986c0079d244235a1d85e35eef7e810c0767c2535a936e5fe963abe237870ea3be8176fcd73c7be24820fe310bd9304bfa4da287ce2a5f55c590e46ae407b049a07cce9528a9bf576eb35229be9bdf8eaa81893b19ea6b5aad55db17d580cb77f323bb7261a295cdc8bb3d601254cda7f07397cf8cfa5021f7a992518009df5621bc16db040614dbfec4b0f709d851a8cd138755f2ca2f9ae2079d832c160b6b1aee0bcca2e79298789beab9d8cb0ff543dd819f4e0eea24b43ad6b98429ecb7d48f6d2119f58f467d74af2e47c1d087b529515d4c568cb4440cf39fbb2ea5d4a518aae54adebd73a309b6d9e587a515e2bc93db0a858d3ee50adb96ac49a97a4c672a217fa881e6b74f316433fe610a24afbccd2608ce523e08c171f03cc618228c76fca649e6e26be30229cf61d3a698fcd8084b7442dcdbd9b5c10209e8fd8267d08c054b1033211614e720762d4f9c050bbe6b40979f9a4c9417ea7081d3bf0d5e53fee3dbf49de90917d0a055abac749d82e002a6f061982dcf98297a0c2b135f50d6f101f566a55aab757acea1aae01e76948c9543d7ece8993c01d18706620f7948a080ac0893f2ffa5f4e23e4d90bfc9427f0f56cd5edbaa9bbf258274c8a247e9459c41252c64670d0fec78c53183d05e91337bb0ed6f03991c070f77df2900529b91d52a2066a325781293dd78cfb3e0329843f3248bfb261bdcce3d544b017d86da9e3e793398c546f03fc7a2fdfcfcf3ebeaae87169335aa32d85155f83c403c329e23a54a320e3ad6f05e9834f5348666482f785b51051142961c06c0ba41ecf7146dbf26cbf0c408141cd9d228eb5dfc57327fa39fa76576f6deecf3fccacd7708227e80455beec36e3653826e073a231902760929e68eb58df8111838b0a6437197e365c6695d46e2535249af499ce07351524aef9b625f2d0f5abf3a7d150a3901608f72daa8ea0b07dd1aadba7eca4552d6bb064eceac178dbece3d0cb77c3ffe2df281610c1ee1734a4dfcf771dc4dff683b6df531b36cf7039daaab9fd448c69e1696abb76079d39840b37509220d92170cdec705fd366fac4c2507b7c86873473f52be79baf1639cfe2b3c0a1f73872abd5d29ac65116d6de03dbfa4fe742bbbb05e70343df7e363ca6622864dbf99d74c75e444b599848b0fea35c6202f1c90fbe10f6434b778855fb4257ff4e41f51208d51e62e71c94576af0a4f4fa1f862ed1dc1adad3b658b4613457b651dfeaa004b5a3e56f946c9ba5b06ae1430934cad29fea878a6ea1b97eb2def9cc214726bcc26e5dd7e7bb6773d6be74e8a167f5441830d7348b7ef12e6064bb5263a38ebf4c09e737b2f916baff6819c225542568e8e1e48a9470a6f4df4f1ddb22399008290148f57224fce7cdafa9cebf3947cae295390cb09361ad054a9bb33cdf0d250803764ad22896e224385e60b19539d797b6f919e00a54f8893ba830a23f9bddadfef6416b846af72b9f29707d1c66000a7724ef76e1db49597e459645f3f429d364bd8fecf91b450ca7cd36e2aecc9378837f67b66bc3011fdaec1048fcc03c81765b0df5a1e60cdc18e71ca3f501086d2131e64a81d3591ca95c9e468879d1298b43e8ab590f4808301ff71b187f9e9a39ddc59552b090fa731dec8430a77f45c97d4b538de095aa2a65e1c3641052d51b0793aa74eb1e29303db88c8ce7dcbad3b76256c29cfd5888c1a97c3941981f4e4e272ef54f7de5844867bc2a386945c93cc140fbf14a5e8c6485a9450668c2fd61c8e951e49261482d5705b45d466ee7bd6e2a6fff1a9a376801f0fe948625091b7913affe4aeed366e4103eae40f01e0afc79352d13633cfe694e3fc08e3e0b511cfe4d7338f67291f1d3857159160d3137d4ad6ec5622c9a351c08092f81b668c396145afcc946d41068dbf73e61b977f6001f7b453638316f6eabf140dbebb6c2b8f182d4eafbf1d7b560ba36ee9510731e40f07c997b83189631892c3762722d6f5cfdb6f410739c27563e50eccce718f5335f9142213081d87b36ab31b31c376be3be571e51b140551a20d6b861294a264a8cfddbcf572baef63ccccfa47d1fc703c20cdab84ff3855eb9acf5ff5f34fb5b45a2313320a89a1faef9bc25e43105aadc6cea0125c353fcfbc41dbe936ed1c17d464499c5ab173a58e63367aee8a31890cc640c6d94db527770cbaf2f1d6168f8ac3339e72323077e81ee6d15a4baf47b4bd878d97161d9e8c320cacc53330e0a79286f7f8b475c08f5dbcc7953a54fb441fee8f8ea15b03888b0d579d16059afa76447396f5f912652943faf3f545192155c33a1a00beea9095f2b26cfa1fdb2c429e6116a3aba53920c380b393a5124183ddb1606ee12b437dfd83cb449198978bd2d1eba8b6811e3bf819290fbb67f69d6fcd12c2c8f819e030e88a35576e1e0e1a8da546ab44462982a2128789f185a9a6d279468c7a3be368403677d7bb3b2eea03de329a820f75b5feff690004934e8b5180a0bb819b7705944b82ca6ba31a4e551363297e6ca6d79f8efe5bf3f995496bc289998f74fbfdd9fb719ef6c86a1c38b44a8ad49ad4dd0ca7eb613ce6e5e7d8b1e2e1f22e5c76a432bb5f705b310ed27394aad1bcb521eca7dd055abb40a076cf9f8d52d3bdeb7f4b213a845a37112e9549c42e6998f87165947d3c75681654a4deae044440d177d3b0b05cd49770613d695b33fdeacf1f2d29fa28690dacc40e99d1c8eaf767d6aba4c5aed34953852caac3646d5185304bce3dee67b6246ac7416a14e6afae0b69cbb169b3d6a86ea715e2e6eae3bdb50a7397ac1562fffbaf53cd9c166a6e68154518ef553347c87d6940dcbefa39d11076e8de2664da3cc9daefc4d3522964ae96175920095716152100e833b8a5816dda30635af3c7d10e61d17a0d8cdde1ba2018bc723bf1595dc8d246637f68d4eaedb244732b4027127860534c69f41b5d2b6f813d7e0d6066a4358cab7603ff492505190b94b5339a06cb2b52da6ade1b7b377a8a08841a8d324c7ea34dca629965f72a6ee658e87d16fa91915353cfa6705747d04f49795d01dabb24a8995342c1a131cc7dc6f5ca4ca708fac48d889ac8b17a4867abcd1fae50bcf33cf8672327c22da2abf4b38497b06351dc2692448a9c45c3dbca6d1860661b2c4ad31c2d1fb471ec96f55f4038b648abb5d4f56886dcf1d3a3912dcd7d44ae5667487d21f934aab8397ce6b2dcae47e2647e505ecc224d47a99d9892559b2fae37bb9c1a95d359812b956e4076b29741d7c8379c93afebba54929d2d8a561dd172f574363453773752dcf4a85a122380e4a8de2beadc762b55226b5f1b497e41491cec232755a09734b1e0998a7febf1706a9c5e1b437ab5cfb47e0edbb280265d7695c60c7de0f3357bf33dd3b01433eddb63f8fc10da49184efcf3043f74f88b78e59d87f18fc2777508430468240c3b9fe51acd0b3b31e28dca845a95bcde5254e212dcf4c0072e557c5529efa64481be4c444e4549e368a70219c722990122d60c33e8df24f0334a861ec1e07ab87b9723f477722d1be654e55a70da720143cb0742b489f171526e1966193433d49c498da3d82c03729e27db781a52e8dff36da3e3cf8ee4b0e92452098e00560bf807a2b956124e471abd2134808bed3942565a95e02b93bd14ebbfde7f55349b604c979c6f6e531960ccee1e911a7a76d37dccc990140e8d72d1a9ec0a027a879dae598fe0eefec9134ce5025c7d907a99ab46d0e119773c5d8810a8ec01318e06b1352784e2e85678de76a628b68080f28708e0e27f14b224f70220906a638b7655a148f6f59ca52d138e9323f1ed8f48caa3c6f34853fa46789995424583e2bf0fc00f7dfa1b34299fb6a5b786e6997d75b0f718c0aa4c324dbfce286d7d6d68d0f686753918ffa1c2899f19377e5582368f132b0c68c877dc4f264a1ee404def777de7b60312d98bf3883d2d1fd18a7593d5549afa4e0e1c99f95cd987e7f01a2f3e2ccf334ef68a3f1e4fa398acc9dbf75a736a2e352c1bc37a9c2f49bc9dc85fdf01df8ba62e174d6e776b3115ea023169566183f93df4297941ae8c01d98016c6656d030e83d681aec283060070b95355cacc3842cd60f30160383a680ed9bcbaa1a887489437a55afe2b1bdf8ce265d053d20846ddbc8b1e315d05ccd22e02819289b8d75c5dd2e7b5b9b5400e241eef1e9bfa2efb69244d429ae5b09b6cbaf8d0a0d2a04cbe0c18d45aa9493060d12918a566ee35a3cc540d78655ab0d0626db712775c173ee5e3789005e2f785e94b9b47ba81d2ecb450ae8516eb6bff1f5a365323320a4a56655c589b147e1a5f683535b95eed78af6bd9a3cd5beef34045b05068bc6f720dd871ec6efa990999e3c25d817d99eb1f99994c66d08d18ae63710e023788c4fc5ee31ad2c256831f141b9451ed2ed92c2e12ebac5e710b0ce022b18837f8c54997eddf48c8ea1d511a0524b22814a2032cceafc039c4f56affc4067394efee1bd7e607c9e08d5bb92fe2248f0753368650f119eaeb4fbaab9c73b94d08833cbaf1f9af7967baed1635cca793b3ab0cb2042ed5bbf1115b35a05c0cceccfaa7cb336684c4a03032845c1fc50a8db34f699ddc4e6f9b226dd704bf3d840d70aa1f2f8f7de63fe91a8c5d93c349fcae055c06a22a40c4864d6f09ce63aafc9862446af44b315beed1f21e189dd3f762ca44701e2163b1abffb36d087ca4f7529f5d62fa50c1decc05076c2650ab7782ba2ab274f2859b66eba706b1e08b9d5ca9b5516be5ee81849db592d2d9f8d15b4c9b5fca230bb78da62a20e4c03c6fa2ed447c868da15f2f584d3437519a01d7ca3cfbbd31776f7701309eccc06db5e78efd8f4d85bfd182b0de189e6343bb7f7828d105e3b86d826ac427a475fa9e86c9d88039bc3c1cc16cf5ced8dbbfb8835f7c3a44147557ad91bd84ee9ffe3361afb0fe2ac16e9fbd0ed4e2184ba9c6ffe3498893f49bd57f60cbe16ec727f063fba5802a3ffebf3eebcb260c8ce3ef3b75f0a1f3b2d60a9f70ecac8d6e1c4e9024d27f61da1e593dfcfa65eaa6b5fe84ad3671e2c7cd0db236da5e609e9c4dcfbd44044a2d5fa6ba92f28cfbbd11c46225adbe0de705bd7ace0d892903670b08e03563b3af42fde02e7e829eafbb26f090cf657327165aeac1292eb276c91fd2090270e3274d77dd0f481ebfc340d60e3731f4270a97a811bc2951960ee416242621d7945843d6bf21f53cb79737188947d2025bdcba96927513f006f516e1917f0e06e821be3c653aacd06b0174d44cd7613cf6a72d84554e050278430d82d0f307d01e0f095ff3106a120d95120d0033f6209316e61032dc5f589df3541d4086bf0c5b85854ec3eb2665ed184df6d9ed1ef2d7f140924ad1d0b6c3c4c9dbf5d11056c42f8b9b0097714a2ae23d63d9d2d687eba349e9b0820ecc714377674e829f6ff95bb5f68dd656233bb9ea19b32687458fd4db3ecf341ae936a42d5c5f3783ff758f5bb10d59f4862117636a39fa1358a1c827bb41fe6ac4e85b380bd7255ac7774cd077009ceda056d102219e6d6348b4401e54b56079ed89670c120371a9d4ccecc76f3d65dcae822614700da2698fcdef88c64ab98abdd64d4302c9a7199a2e8a8b3e0b50bbd3d0d1416140aa4ed34ff753f685ab2e83f6e731b106d267f8bac3404e2cc4d3ac6684fcf0638d3afaab4131b335add3d77268ee92ace74326e1fda4095903709bbcbc841a8d35c64474c31acbf1774a4fc244e139ad8b7ddfe1e4b8b3fa0c729b1d95b080ee7e66993bd31808c2d3e51105e172652e8120d94014fd3f1c5226b4d70b327652f197b1301d06508416e817a7d641957bdabfa6938ea38c8b5da6c52336803497f3ff0da2263c39017a03a172a2c5711a24996c10fc2ef3a815b16d8a2b4b53cd618a816f043c4bab47cd91af8990a9f1cf256451c32ce6d4963f9aa696a7655e5f9d878f68dd2446cd34f6e50d867eb0dd0620650c1b60fc6660d7468d7052ee1b30a50ff75819b429bf7f7bd4bd8e139e0cbafa7fc73bd4a5e79b6f1dc5a1dcfbe01a872d01a6d65d13d25a5dc0d5d1c4b3edec92327318c5ca9f855f35f0a5f8a46ef33569d94fd529ae3934f6ee6929215fdd946875d30282408e35f5a07693426347756c7d6861b1d3b1aad7e442cc5f28bd211fefc41c3f1739db0a84499c7c50bb3f3053d591e0aa2c7a85995a23dfe90a2c2cf348d29341003b4081ba1716a2f523c97e717488ec71bbad543c6c21003d5ad1aeedbfed84a4196326881f846134646fadf35e7b2e41d077939b64cd388d6907b0912c40a598cfac1639de563ce2784c1a46d9cd0c07caa7e2905a9b9e32f0c0b2585856632520446b40cd68241f07df35d82791298a9d832daf91f259e5fb51576dc941c0a73ec6ef7bbefbf0ae164cb456c6f827f0ecd02cc1dfb2b52545b7423ea3eb1d0037a8438e733c934d96a8116b1d9c853cef03b1efe58eb5bf1d6581115aa18200d60fafe977bf673e240d581fa4454b816824a2cb7133f2bdf561aa2aa46dc2893fee55b75de51928181d3aa30e6f8007c4673bdf2d9c142c7f414c4e1d2c393acc548b47330f3e794f8e4365f7aa341a5041e00070e393e7c0578b45a2eb26e6f2d3ed1243dc4794e151e5d7f27d15e6d0e60006f01498f0230afa88cbc6cc58811ada439465b71728afedb0814e44f7e08155c8c88163b1dff4fcbccb3862c0f7a04297473562f5217d45f8ad71a00eae92e5602409822fc3d5c68cd3ea75895243d9a19db8c953bfd6ab5b173bc937f2c8d84a04129d6cd9b30a9365657ff4f53e659102fd99294d547370512f0c2bbe2d64c071943db1a70c7085ae2eb2bdc9de58fa3d61988e5461f0d7e0e7fbcf624a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
