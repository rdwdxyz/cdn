<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec7126018735c383edd45558692b6f3c4693073331d182b39c898806e73016f2db3d8e18f40656ee57f692aae0602270a8c091804f015d4ed933e5a30ad0ddfb5eec8c404e6f306dca0f52bb28e619b22754a9106dc0cacac3fd5a3c2ce97b07340a63cec86fb7c3ec19b382195764d1ed583d47eb86429af2fb5d0eb0924c2f2fd39d383a8e956b820cf51f2fd286cfbe3c48b3f5d50c7d65ec3b87c38b9073a789977bff4bc0eb4f18cfe7a89e4109e8db0db988f5398cfde862140ee91e5740f54be4592752fd868d6698b7a4b356f884e9a8756057acc04adaa7e32658b00b5a07f191a06cec724829be379652ec7383466632580c52d8d1da289e33b791e4655b20748da23e49f47310acf78d8f758a5fad7987aed0a04caa458d21295a0b5ce5179f0d6c4c3fa6750ea1572a15d4ddfadc79ae8700363c719c98fd4803033780f78d46d5c34811987fccc275be8d5e34af976102f82b1bdacdac63026a0b9f0aed3511eba37b1212c3c24307350ec3099aed5eed107a7e63dad343feae123cb7fca631f545822c124ab66be68f52a1dd916148ecdddb0e7e2aac8afa888a43e8d6c1eeeba3b466e13db2f9140ad869436dc76a392b5c8bfa647c3aef8676adc90d8f208dd63484946595018d0cb354b059daaf8045a020fa7622ba595f5639cce8a9ff96b6563c170c9731095d9856bcb056c505c97fccf0e3f911631fd42e63f59849a598619f1fe3153a075739e81bca9a60bed634d0db13cd9a207cf18a4d0a6e163506392939a9c74e034c3a708817c91474dd91ed7410a9afa4c0fdd0548395d91a3c7f81add5f3fe34fcd68a66613e93edc84f35b90d5ce7dc1dc826b089d7aaa6c5b824459fe2c1a32d88d2e42de6fbca92e52e8a048b8430972deaf124e09f2179af502b9d8f1e31ec8022d493c8ca659f1a6ece0e211d08caaa8d3349475701c3b1e90cbb67a6b611937e2bdd20c1cc734fc47a456f5742a6beedff2fd08c9f7dc512e65fc32e76c43fa86e7cc3265976c692bda74d58e73b533b4587816d090186920e3c150db0701c53ea495374993671ea9c7f71a3d417ebefd35b5ac0893c228953140051659ee6a0fa7e3aaa28cd8a4cd798bcf01b586889c6d0b53463d4a89d465519817e22e17596412520d14eee60b36d51625c2a20c15fb7cb5b1782f814b277ce6f49a481cef7678f0d1d3eea427b956d24263988cdbbe125a7a479d5894ddfa115e89f3f2a9fed77c92a0f5b1794c83263a98272904664ff9d983842ee8c2fbb67954d71f5a974ee15549d0f3dd893c18de20e1cfb430dfa3f335f7219e0edbfb3994e9de3001ae695a0424e6dfd512d36edb0e0210042b147753c7a8305dcd77234c9119f186c84825729b87d674e2dfc62857c36582bfffaf765f41595d0c8e7b34456dead71b408e19f682f31b870b94bf1d964323456b1c2e72d5fb21531d465cc4e8cc002b5aaf8a292dfbd9a868899d55373cc91e475e27e2b451e32c3cf983619d6f0468d5c0b16b4641774e74b17bfaa0979740f369a5376d6616391cc517131ffab5109e4fde62b85ac90cda01ad2519ec989f6a5601c33de7c93789fa0052140ddaefdb2f67d2357a2f603e44432dd40dfe3c613a756224a5c43503075b014703da9928ca49fa6207b5038c18bb2075acdc5b11517e4f0c5d2cdcef59af497e9f45c7666bc0aaf1706c987696057236fc4e0003caf551559883f3a3721c1d4da96207dbcecf7d49ee6d935b4df1957dbbff80a186b53cbc96c7a3d7c340cd7675969bca82a3dc92f3d5d62d2981f29ba52ac7810029afd5ec54a79b715cfe27919586393a2f33223e387dd1012753a2e587cd2dabbaae8765688c3f58ceac317dc53e1018b09ab6337d0f3a40bca803c770f8117a226c6dc482bc8f30fc59c61d27c901e44ef243304840b7ad6c7842529e7ee48f62eb82ab9f0f2c4c2789ab1cf10d1016361ef9490acf696dc9b514913b82706830085f431ae2d7278f936d1af0c951b82570b8615bd9b076126f6446b3cb2c5f577289fe01530b584f8cc35101d4059712f779f3c059329b0bf0ae2cec91de06cc9388659416748948c46ccd7f7a6341de1d4922695e0c0b3a9ecbc32093b26164574ad2493660ddbea4d9519a702db80fc62f870ab8445cbc967a9513677397f953af5e0ccdb7bb6e7102c23dc838f0d398bb99ece695656b3af4e31be18b971f8c4b6af5b4b7b6b56f522dc3d57f363f7986339f85adb1f915a768457aa9f6ca99790fc8286873713a52547bed4375e81152453cbae3ec62df07c2741e35a185e675fd98aaa09f5dfb9ccc5b69ffd9fb2e6f4fbfb951ac9f9f680a4fe489b926fdfa0fc2185fe89a3df0fc244acaa800e8870b5fe042b91cc48765d9463915d02411b3e1e664a9f45de6d7025acb7a8fe807ff22494871ecaf4278fc44a422eb4e521dfc9ae3ff7a03cd44177f9778eb55b245be2043ac8c4c2e0d6e64c9ff1594daabb4affd558334c5908e5eec3568ec78cf13c11ec1c392be89475f54d168438d23469ded251f27ac29ad3d79b53c140f1f259f5c035524ca8839ec910464545a8cdd41080fe9a226d3c08914493bce22df6e7a58168171b3a2f2b92b833f921197e0686d45660e1ff493bdefeeb6a76c8880a497b594b7922c0e9db2a0a2b3762721ad510441d7cb5b342b32565131c4c7361c3b08aec1ba6feeb26bd86ffebca1ff50ec1d8a2d05b281f650010bfc15a1b9252b2bfd833aea171bb771e53e4632c5b0114ea281cf2c1ab74553504f26b701350bab983feb21d78b8ad7390829a217b05b69fd71af4b1a7d300c4073f438b0e5f9d22629b716d74ffeb7aafa69e9ac28366f95831ef443adbabe9a89debfb54cb328b3eee49b1b60a90f5703ef9d19ca2f8e42fe53ffba516d7cd7b27fbea84c9a7847fa1a21fc6dca8a7e1bf98c872234354005145883476ab24f71e9528df445a1deb36d3df1f960cd747498b72e6d84be2bdef9b33b5188c01bfc833b0d432a93b870104a1aa458f1668778bb1b12a02ce896fdd69547439fd0c1e90e216f318a038867cd326a9daac9c39b6bf237b4fb569d52795deea9a26914a378bbc732cedb13076455dd606d0c39f207118cba5fa07a2eac01b81a954f9ee1b8ef8325a37acbbac52f9853968f15d56110113d7500d0a41130429f269eb641c8630e7d7e4095ec1e2065165b8273e19aaa9c3d8ae690ccdc906a75699b6860e86d467cb6b0ff4e68ff912aca6074e660e12997ae91129e54960f03a79e2d817456cc30233a69edd4ff4f1435f15bd290abeca8f5263115debe9676a0d9302d9e79ed4f7f57c2b4b05253ca9e3b727f1899ad0f324824308a7dd88fe809321739ea6121d365e2eb253c80be0d70b88cb499c2c2693521875ef7cb0a04bbcf85c9cc86a02cdc05941aec655e8b6b9a1ca9e201f05eda1a13f4d2fa4598d633aafbc5318de4cf05ae4a3b46279067bd93a097eb5c643a56f895146890f7c06a9aff41167434d5df42634e10b5016662304ced7a5fb35f80f48d2810141c01379d1db5b6604eb9f818cd0eebf77af243a2f5a1372a82f65764dd21e2d80cd4a80a209d23d7e333501194f24ef7d7224ead8af82c8d73defca68aa037236a82fc2d27a180e9ccde60691026c9a305d3b94fe84ace05e5bcbaf527294c0f114182d8b8b77ca55a931d9cd6c57c255a2f9f0ee9f659cb259e0f1bb9227a82056c3497d1c17f0a171a68a9599d234d4ab3b8bbedec172a633edce7d2bdc75b3df594b30b0c8f6ea1a701ec076f399b6d1c3087607553fcd97f82c4ef70d819eb931de0d011736585be75b993f8ed4bdd451cf5731b05ce4d89d33c2a96a9c951285547668532d4e6088394fb726d6688a7b4cfc852453d9fcda953d700a8566b69e7b5f1d5cf8258b947c99681f61355ca29c916f2af790411b5cf5136d18d9b38fe14bc14d6f6f9df0b5df30bbce3f393e00d8c55f2c5d3321f8d64d27ee4279f1ae45db75b471189a5edb32453171ee01000a0eaaf48b9b478943d92e13ab5ec5198b8289abd0fef5097b14f32cb9b52979b00d819ae6a1fe4e1ca321aa5d468697cf51850c7c356dfbfcbc672f14536d39425504365e21f16cd5f7d1fff639e0e688dd1e07c97ac9e9d631578e884c73553526a2ece688120501881753bb695d8aa5845eb9b29fd02837b112e1bad5ec4479f1e9a9ad9649c1a9eaf5bc4f93d980c0256f7451c24b7991c412b0c68838387e67b31689244299182bb96cfa5fa96f5692d6774f14a085cbb6235f465572c2ba8f2e43971ffc47078e8c5785839f9e73bf698759e90ed0cb1bd4ce65ba276f31abeec80095f2a5c422aa98be06ac0ba07686f6935157c3090e0e565728f2c44c724287c95177ab9fa45df577ec682464d84bd74694acb3960eddd0b248c4c806364d506cc34494f12128716a133f506cd155935039d7d392bf1f33157096e58bc8c27a6cb849f399d3707dbfbe7554086988ace6d0be6dea5eb274e0676a94b5619a88f916b8e57d9738fad625d3033d63a664ba19fb1ff39fe26dd6cb3c1c3642dd3cdd9936b62eecd1af775a175f5d8c4ed25d50bda48c0a92a904d14d5bbfd748e1255f008c2c70e8f963be09c4f65abfd0b0ef93bc8b4362eeab5967b9ca544e0fe013f2d43116e241c34ee79a669ef4711df354c249b4d12cedb82e563a5313074c90ae1dfc0cd15323942e45d1a364002b54534b71a505f362b664c24589dee125524ace3fff75800dea13f26106fe8d90e51c13e1f50e7dcdefa9626c140f747e3f99a9a65a56970c75c4cfb3ed7c2a84427ffdd325dc93a3632f002ae21b573a4963c8f91c53eaf098b48782a7ea61e906f9d948d18890e998bee561c633a481e727980241483235927e85ac465c008ff43ac84fb1c7d1d267e7554ac21be8c7b7d95dc126f8135bf2ccbb10bbe202d2108f0361ab7ee98c14c8a004040378926eb95999c5e0edd65a61d50cf2cf7f1a0616493a8baa2c9a5894631d6757bf59d9aafeba1e00a2b4feb5a43d21778bdc82f63b4f8c7d8cffd23f92eb211569063ae362e52eb6ef23c983742cbd0993235a130d3d085134a8e4fcacc2c01e432423b89cff4ef3f7d7187573911d7d68b3f1b967814984f40d22dcf994a264bab78388b481a4357af11a443bdbcf6881799cecc47622a41a53c84bf7de10aaa3b16bfb8e587a796703122185ba59ee12c79952da56598fc72161026d512683fc62ea05116d39d90d7c88e5b1050d19c54e0a221818aa637a95dc171f5b264f7e6fc376713ffe7f68b1ad5b726a925778c1a0ab31520f1e1792ae87ce4769c9ba739bc4f2ff8cc4ffafe98817309591318fe6502b88af758b3366b9a3e454ef52540d8b2476eee57f3b9efff8f5be80d3f652aa1434a31f51b239fd43768acf6e6593fb1ca8fabb2dafa019ed553d1db4470a144e815d29ea7f0ee04630843c076f40638cf4dad496679f5975a510cd3cf794bbc94dba4fe6f15785c7850adf05b143550fc3fa73aa21669a63610bf2cd66d7eb9009c24f62627feb39b08396d56f61475c063b566a06776ecbdd0c478cac0e9cb606b07775595a9474e0c8e8a6f34f3a6a208c113e4c6d56b3ccf07605208d79f4caf175eaed341613963b2570bc6f7b373d35b056a9ffa75d06266cc8857e3fc8398933775282b63e6fb176c1dfaf188d491f556faf17d3e5d49d9ac94c864d29a3e09475446cb676499b36c55f4e4c856ea6247d225a4708740c477fe08e80855969527d9a8f33b1782cc55367a44952d3876f25e351250ceeacead7dcf374c799327e898270953fb0375cb9ec5a076c376fbf752401859b5111efe5d8c2cad2a828bbe03fe6eee6056d23095c2949fd1463f3b37bab8423c82062da8947e29b06dc7278a2399c516388c6f620c03c14ff645894e33b37363e07fd2fce82d3257ad1d3f6a408dd0f5aea8f435ba85fb89c407cfa2495f7e1cf97009cd89b5c44457bcb06f5e496f3251fc35fb53c18b73c382f8bea4e8725164293968f97fa0a87a16efc87edf15f3d7dea1747fb8923a7144f15aee88b6e0ea09082a2b631037de2e55d9fe129f28fa6f2903949cc5b9452ab40e2bf19bd853018c22d470a11a2f21eb2e91b1f0ec2c78405bf735012cbea7fcedd52e97d8afad06450d324168b2ca7e55ae2ce1f6e54bdc3b411b91b9b97928fa51552dd5d3d6b4a54e33af88de40d18702b54fb536d0735f7452a592babc5ce8894d58f1dc3c54ae86bc6e04826f237a5bf4830edad184969585b822494b301541740e17dcca050620c568dcab0a9cf1b39105fc99e94b78cb0fe78d5cce923f3bd0672eecca97fb5f31afd9a60591a94325d6c1f4320c045fd4f8db334258ada506b092c1dace15e6bef16a1a99459f203be801b140bfb756f5f2cab035f3304de4e30905bf518323d56a1e518ef7eb4ad3e566f684a55baac70c13cc965aa6ae1dd1f74dbc7cbe105733773a2ff724c59ee333b83ed5706843085af3cf65e1d8c3097baf499e7ec1a87ffb72d2344bcbf2decd897ce54685fc004619bfc61b8c9bad56ab7aae93b1f882b317aaf15e3e3a828ad3f7890b59d3a6b6131e289c65f24398adb158d54591609d6188ff3abee785371d18e9de7b5ecf783a0ed552c86ec188b93552fdd2ba6c882af4ac4f463eff10f59f024a9e017ec0f6561577f28bc2aa4838374cd956bea060917ca9eb2cf6f9feba82164ce63e83d7f8e939c425c46744d13deae6ceea68afeef44febed5b5191b915997ee53e9962f7e36160d23903b92a48fe24e044861360da371d96d3f6b23890c553fabaac0ef86e55d434c8e9954c1f55e356c4198e9f20b3a6ac7d04fa7987ea02603d151a32a382ba0cb2341830c53a53beae07fc5e2132f95d2b91393a7e699735c7c3bdcdea2d8070ceff1816952ab510206746340fc084fe27258bdf21db42ddfc482a5a344b1a24fc8766c963505a09c76046cf0d431a3ecf6ed9477c934dbedeaa6ed4e649b02ce996aa3dd0023b207f78ed6d739a210fd0ce4c6f2dfac2f82b4b3f2328d6961afaaf4fbe40fc3e1e5679637ac7ac5bd5788506c5ec49412ba2008cd32a67ead67ffe1133c25e12af5bd984f6f69d3c8845edff34f232d68dbfbf0dc27bd2212560bba59d1351b2511a43fcef329f81b1493e26c51df4e8afb0ff0eb52c5f21a1324ec45cea8342e2540c3bce4e0802ee999fa858e9912e7302949387fcd35bbf709d20b31908d62d7668f812d44062333e1e4c2a8092305bb55cc5d1ad09985cfa704ec01fdabd077303001e8b650c164bef9d82f33bf0db949fb7ce7a4e3c20b31d1f7604b39e95616d723bf407d7bee9046a94ba9a0e6b55cca751e6b8c8a27cbf6f0a1e440d7842e24eae7a61f674ffcbe7bae1463505679c687e22465d0cc91d410501a86fc241878d48849f06ccc31b52ddf1f7d705bb33d7c54510eb112106d9f2bf63d530399d6917637dcb97f58283197cb0b9249e9297929ad853ad3fcf8e792bb9b50e391abb552d43727ceedd0bacde7193d93f7fdfc22eaccd97cc66e53c521613240db27d0961012ad32749afd88fb704f59596d2a3d96205d59f8583a486dfff8abd1cc5457bbb9430f33f40a7f059ca5a9471d4fd3b501669ea5019f9affe63efc9aaed93cbe8255833b94c49dcdf9a87e3cfdac60d621c2b1d8c1dec21d2cdb6839699046913d4c6f642d41c8fd5c1d50ea9c078e06705b5ceab40d72358c733c484f2fab70f92b0fbd963a67092908a062c5cc40971c2c5bb1d47364ed6b34f114b8a3181de56d8792b9c9f81d38cc5718c86e0d0996b9bc9f15d02cb9733b5ef93554c4cce2a6e88d9f970f55ce9be018490509a988e47d6a298b7ffbd2fa27f1a3b9c04221c9f4b818f39182c0e2fb19f8615e3f1c847129dc3ede738e6a17c7a9ed387ec76feedaaa9591e1285ce80db141fec7b592502320c1daa8b33209a66576066001e34993d34807c751b42a177264b042f4616853205b1292aef648340804d8f43c17e65c339e0f55986849004f881022a4b98d52436a9d1a70c992bbd68d73b5cf4ee832417c41bc2db378154cbc489c9bcd62cceb546ca6cab92c914f82572b776e0241a5b076baaf38a78312687b0d27aa7d2ccdeee208d281b5aa8f11b5486c3d1bb1f69432c93f1409e2f57a19361ac8cb0c72761e3bbbf21a0edcebdecf6e6d9d0be8b6f7a30c3b1cd3ddfd64aededb1b07920e0604807a26483cf755f403b0ccbdf06fb034ac9060240d42c7017a499be4212bbfd8d30c38eb4ab5754b6c73e74c858e8295cf9031854d0095dc35a238f276d35d2ca92380dd28e05f5578e2ae26524839ce66979b8cfccdf97c9831a8ca0836fe01026fbb9c26cca0f6608cbee64a2e4660e9e4e0721789b9f9105474e1af7b8d25161edbad98c233ab4ca38fc1e08f8fb7111168e5d284f612c94f6a7e8c25a1020e7fb9d4607b5324293ea0d2e480b8b0dd6167113aa434d6d6d1d3c3c9f2070f86c88f69e3863d366ccb3fb54ae5b35af67283f27a5bb00421c80aa75fbd6a0a8b1bc7081804d5dc40173f1d65418f97610c9c50d1c7bd0e615a3948d205a4a830ceb9d0e24d33441b6241f804716e4a6a6f88bc7a73509bfcbc7a3c079923779b884d6bc4c08eadac97b1d1813e8ab4e6ee71bcf76b9312d6d499cbf2bdf3065f790ee375017ae689522e5abea4ec7273af001fec20123eef89ce871e2daa17edd4f7a0f444592b1528acb3ce501219886e70262adcf504abdbe9323c1c253aa503cd5128df8d7d94a81d80dffabfc8619ded1507d728b7ce4ddfd06e3da6de3d1306af705688911d83cc6d23a27ffba7b7464970e021d5d6613b88bb7073da50f8c0d4ab93d2631f2a8f37db3beed843d347fe6fc1b5ec557e1fff43e7feb55c4545090e7594868aa899dbc66494e33e36b98b47e8dfe4cfe9f303548b46cfc1c2358a3b3a1f44a870187177396cc7df82e6ea1e0170c7da9f28362655eded8ac2c7d02f44536f37cd0b1cd8e49ad7788ff7ee7a8483be9942addab46d6816b8d6d9ccb6f2b2329562336710c54bce83dd39178df49f7a7a1c71c97c9648c6e265126f71800c5b00f7838200a9683622c470a8fc6483aace043817f2a0ca13fd6c00efe610ec5ad8dd45de8bee5c8f0aca24eb045f09e3232b1285df6867f8b3cf659212aab5f79f96e658ed2434b64e1cea939c88cf32f463cc19cfd8e17b416ee38e635d0bf766120047f27f851c593af5834b9f40d1a63055650d5a83f3abdec8b1be0c8e90d58dcf2b65669b9c02b5e93cc052c62a2b246d984398949ed9b6747e7cd11d18c9d91536348f9a2d8d2198e74ab66c670c08fdead00088cd21f3fac1125e1d92dffe98b8bb0b64f10a54d4840046aadb7b86a07d9613b5cf86832317f7bbcd9da24c2d88bb0939eadf3f162712512e5d55222d9ab31364cb9b84a7c18f25efd019344d9d8c40a635f1a06f5d6af58eb79b4b93f80d30c9ea4fad6efa993b47364f4b82a261fb247e84ba623dbe66786a6f75356c7a0c1d9950a63d22fdde8319eb81513112f125488431454f23ad6145266988a5ac436c4df7078609a8f6ce78adad8b7dbbdaa10c15654b8d225e351f50e9106af0a82a3e7ff0b20ccbcf09388b5e137c9b7f327d978c371d517e6e6dc03001f14f5d3b5ac95a2ee82c0e41ca0c65345f0fa464698359fcdcab3bbbaf223c80b91912c86bdcc557127eafcbe8b827c70866ff6690c6f4a31c2059dad41a18f182e55bcd00419beb080195b7fe7b0bbaf7e537776010d30108d36cb0bec48af1223d002481d5540fabc35238bccf6bb21375b69c99a21d0eff6fb0eb95617fa7c5de99023bcc4ada6335804f8582ce967c1f2454463f739847c6bb716534bb2a50ade2383530e816857ccc78cd96f7b05e9c219e78057b6432dd8ccfb078fb89b13fdcd279bc168e62e0d4b2541533d7706e8e47831a8721f25e3df6e6e20b5f078c8e5377da158ea8a03874e6cad4c14b6a7f344ee43e7cb3d5c7b0efb20f8fd87f6c218142460aa250295de248098c8bafa3efd51eb634e97e25d505baec80f8d8100d03a07b5b5e654bee5e05578824d23ae4f4e00aba94d017403f98f2fa0e063d68b71fd7e85a513fb0b38342183c445c561b18eca7c08a2fa24666376af6cced94823d480ac3464a0e873cef6eacb3c5f24919934006be4cb78ecc6b990a9d169208655def0b482c7d159a6ddccee86451c2dc1ae4eecfff9425ca9c9debe158fe1b18bde240a035aad647c8cd6a9d23a466a42042e4609b463dfc75e1cece17f6fefedbd8383c2ca082823fbb0ac12ea2eec7b303a555bc96d62e6ccfa3de92304d336c66cae1d854771fc63089ab2ab432965ff63302a1d43cdae9a5b374fcd92a4af936acdd0cee5dddfbda806365379d27ead73e274d595fad81931c142021ba9a658dda9c8d91a9347f07650ee2fd273781106c44bb19b349a4bef77ab4c221ed0667811bd1b5fca4da1fec3505a211a8704dcdfd47c0ec7c8954bd01d9f5604eef574a7081c4a5c17d9d9e52e0c60fda1f6bf432e531b2ba1d788464b736c4c35dd2ec5c33307d7d4290a68c24fc8b854839ac5dbc304f26e45101d6abb4b4e40f729bbb46b74dc058e08ec7b7c6a3abdec3473874c345b429f38ab4cb1d1d0b7bf4af498ebc2751899295000266844993e6a37eeaffcdb9b75b4b3fb5535eaecc04292081af610396efc1c31abc5473582d4bd1d704bf140b67e29693639f22d9a526c0e16702d76a5a8232bda6d624452752af6cb8daa6d5feea430edd99a0a6028656ff5868103f61cde90267dae1acb758621954dc10ae8c88fc9cd7776780785cd7660eb2e70c66330929a5775f50ff6ad368d703386fa24511418c9f57830771628d5c182e3bab5f7c715308d1fda26eb7a04330e477c5a3201ec14895f19c016aaaebcece254eeaa2d7c2b72e37a43361c67ac8f530b34c85c2be6bf038dccb3bf6a90e982e2ae43d6b9a60a74894bf1c109c943a1d7398cb69c6049532049be373c699311a331b4e8a7bc07e6958f68aa697e69c282e13b434b00a047552df617932f3f049cad3437f3502340bbc5a3cc0a57f8766839bf56fbe3ea8494c50866df03a28a142b8e34606413273e5e3b1ee0dacf273a49e0a57be5655436f6826d40b29611acd4689046880a4fc5cba1f2e704579967a1ea2b8a15b75bae6b96dc1c0e6aaaad821293bb80e5f56b0449b39677319ee5705c9470b410272457291ba719fd334e177941ee23e21a0704582fb49bb554907503d95436041de96d3bf06173d3e0228d801d4816832f39f7521e863072d7fe67bdd57da889978a1d9e67425694107117d4b0cfbc62789151b576091adfe43b8f6e2df9710379c21941b496e0283bade6e208545e5e2fc3fa2fbe771a41e100e2c2ffbb11265b023b55f343da2b4d7316d2ca49a138d3f37fe5668204018635b6906644cda7760304ef5818c12229649655a50036f693518df43365ec7f6da759d2fb3d09b4a576f5e1c40ae4d88038a7653addfb9538003df7635c4a30d8e0b7d352e11356888bb21eb364357082072415e96e79ed22c7b65bc31487f1338951d7b33b2913b7f7d0bc0b736c394063045e408d1b383d777fcdd2fd802ea274d5d329e7702f6fecda42ac2b7eb125dd70f4d7f123d1c1fb7bcebd35dda0e039e5b3c5ad7f0ef48344438ea89d4a924fa24b82e32eeb51ed1d8cc4ab8b0bd19db808b66ee50037a3ded02b0e369f60142320fd8854604dc734f32609397eed34f55f0f08b7ba1a45695350dbc701b9366276f27635d91937c836e4975076b9bd1b5ce6ef978e17cdbb6a10ece569bc0044b598dfcda90475c31923c755b964f59df1d982411f080061ac307caf996691eaf5e9876661ff2941e2cb2528aedd0a5d877d956f9ebcb42fa2ea951719e942cea0f61279d049661e3d179a8cc810520e33ebed8c4ca5d49a1ba8df659a7c10a42108feb7e9683e398d4316eeb5c5a0d306903267c6330701b6f0650d772729d0e501b0d986291d410b750f4b9202d582fe30d1ad1718037b2fa7b56949e231e073bd4ce60d64f77273862a9d338c8f5521833afcaaaf33845014e23fc9b704684d82d8c85caf1786669f4c2263b25e9adea8485f3e87a3fc24e6203018d08a071d2ffeb73c7c61cf5d41d1e20327fc0685d98fea126a3b53fbbedd800078055a47429c4639b845cc1f2a95253f142f570a901d872e4e7502bfbbde19135249a50f64a28ac7587c10fdab9a8474ab7d3121ca2927551193a3dfab914e7d1d006a0cd519b49b5b66ccc0e91e53aa118f076fc65c7fd9fb35d197631680cda65d7c91d3adaca4c10264f3bb568af7eedbb7aae3fdd4bc2b6344ddf7696e23a4fdf580066f5a4ee046c7825ebe442303c18083c7f3bfad03b884f92bc1d4b147598775d5d6a26b5a93ef77bc1848f745631d31c535d7bf6b4207f995c1aad49b4eca5c22c2529a286a2fcc960d1035401ef57f2216750d18409c4be1797b95ac4cd24e8e122122525d62a131a4e08eeb3c41f02f5720c21805a03763ee4bc719ba7705ea27e4a43026a6b9bcc7c93ab009a2e3f3ef7e8cbc5a1a2281a03f96cda4bd591bf5edcbed72f9973b85dbabeb8edeca53357dd801d2e1493d0e3ff2128dcaf7e06508601dabdceaf2ae163e44ffd745da61bf23e1d2ae3822584ac4e62019275b6a740509b631849b92bf73733780d0ea5079e9b2e1f4192013eb156151caccb8629f5ee5fec5f310534956b00b6cb164a2157f80e27d5934fe44a5585b585ae33c6a38519635d3217b4eabee1073b3b2c5d7976c8679b29c543f395a27258f5ec1dae4a8c72633af5e5ba6a5715dfa4abfc41efd8877ddb9242f00489c50739bbb55266d68a34e505daac8a7fe52528437bfa0edd6b3e727e5c94eff43da8af04884081132b58d032ccecbb53645117d3c8938afb6c570d675f5f195ab79a644f9e902c04df836636ed88205e0a0378c818c004552ab9d3fc5f181cfeac0c524a94b3656bc9b2c5995492d72428f5c92605d196e7dd30c372408d410bacb035d82686d01bbbc9b517a60bad2769d214e6edd2311c719fd44ddcb8b87ebfe38a7d7f2f6f87442d542bb138670063078193de8ad21ce7239a9f0489f1028339b2c4278d7d8b809e9017f27ffbd577d1ad81d8d5a5bf258ab006ad17e93de2c250c62dddef0f931754eeda6da39bccb495fb159d40f20673d28ece2a45e0cfb921fa87a65f4ebf84c1ce6fc9787568320c9239febec25be3837b152b7eb3dadeec031b5f6b7da9ae3cdcb0fe1384a1932547392c0586f51c4ac63ec648cf223466458c028eeb474bfcd38d5a21530221a0105eaaf47f7349abddbb7c2187027b643ed93bf56fe4da35b0bd94382576a2b23510408633285b9f1b9a9331ab1ace6ed3eb8b5dfc05db5afd73612b8579e62e297aed6caa3c304ce9e4225f81f75cc59b49b2232952ea96ebd81fceb7b567c474f44e3ef5ce2fe2093da92fcf7f9879668c22d33250356ef998ca46400b7f125f8883e0bcfc0cb6a1b890bd63e65ba075b51c326abdb75e96231dbfc647c84d9934795da5ab7a188e89b6ff497c172c8930a820c9a7375d246d13e27ff8312caf7998ea314a7da5dbe01dc11e37ea0e25213cee2fab009e377d4a5d6d940aa677e455594ffd5f0a77fadb6074146ddb611bf8cbdeff0747b342641cdc16247202a0bfa050deedf83f3dd89688ebd6f250987a4dbe0f1ce6367faa33262866e4f68ec2022718ca16043fb231aeff441c13cc628dae7d1b2eb5a493be297344f8ccf6946e4deca5fc9a5c17a04d75f1c60883505a14a18d62e1c661074a63dbdd72befb33533278916d35bec61ca9f7529322bf4c17ac80240366d14f7fc80bbd59715a0ad9e59ff21ea5d997109c23f13e0c88a5c8e1f7bfece8293e52be78a868de47ef2fdbedd94e4a6803f774b3d6c25c4cbbc75308f929c16b8ef0cdf609a6f3b37b5b9a782f70ec71cbb6fcfa5001096da00be6c5897bade26dad2f89d306745814587b3ea356d5263154fa8cc9c28f8f716dbea17de7d9f73a3e557cfbb5979a0c9dbaea04b7a95195461e864cb19550cbd3b46470dcba368bedd3291a39658516591aa1af703df729114472264f1da0afa34c60ab10656b5fc9830df0ceca4d1f987c0c212584d7762a0aee72e51276f085ca4edbd6eeae6e7e750fb8d13c3a19efec6234d4d710f3f740d130f23d9378ecad0ba1cc288cb1bc06d0dae57ba97992196bbc5dedfc2f0d6cffadcd7abf67d056ce0e5da6b66ef187f5d67da4e4bb96be49a99ddda4fc3eead0fd5700859d20752e76935fbbde87747e6e4641a148f3f1b200c3a1a2885ef2600b08ed967c1f2d8762cc4498c3c5051fb8c9932cefdceb91b9b3d3e3da895dc4035c814baaa27c27df9a3cc52c998c7f6b4df03faa7666773fbe39a015a84fdc185fe3744f3289c07d6e8461a0370ba07793523e5353c05e3dccedb94909dc022bd7848c4c8260915d3a2c110b80f07ff794ca1d8df8f714c0b3f61f915342374bd751a6f62a4cdf306ca17edd20e7c662bdb6fd7961e09614ca3e1e721be2e7122e34854fba0126a2442ce9ed229d9a79ee24458a9b1a116c2b0b7d22259117c56313be07867dbebaa70f4e736fec8e6a33969888d168a65b51c85ca383ecc6fe7d49997559f27bd19d774630faccf2658c83558b453883e3ca0f80e28a6856b7cf7d81101070974af0a761446ff85da3103cde97f293ac1ad1faeb5d9adeac6f7c0788e4a85e8bf94ad5fb53dbd1d21cc526f25d0d233fa432de0158a2cec1511e00a96070927f96a13aa30d046facd59673e85304c1d0c8c8c034abca81d019a97a55bc362f46887811d65e98718613c4935eac68005fc0922c7cb7dc649f39fff1778e78d2dcd1bfcdb2b24bf8fcd79de583a3c2addf3c32fe8fca2f36d6fba8dd24b202405772544fd00b87cbd68fdf72501d9c8f4bfb8b6bb1073a1f78fde66a0c880199400d537399aae665bd72912c01919e5ae3b1521322502f4d058b0d82b8b80ff4c117a5f406357b9ad3424387b5b9ada284a7b992d7a39672126915fa51b19b3625048594e69fcf5e24c1e5cb2511f854512e309312366981621c14ad27f8e9b7052f7ed1ed29be0b27c3ddcd10ec33901941c2919767e0b77e4848401171241d7da59cbaa3de944eed98d0f19631893fbd7a135c9dfb68a13bd9d213379fa3763a3500f7c27e913b491237bc224d7ddda07610d6a9f669fc4e0ca286a9f62d5b8c9ac00033f3db2a85762700f72f1153a6ae9aca319c2f09f506c70e256bef80c059b3055334dfada45b628f80ed1a0a8a56f787907e22c299b118bdf56e897d197f0d88f78a78c4eef2655a1964c564fb98e65facddea10ddeefd4e40d7c172c05d53d9b21e6b3d35b4a3fa69556e244f4abe7b1353279f2a4a57af2d65a9883282851b9ecbbf28a45424153aee5e61b54bf4223b04f2dd0bbdde8efcd55df857d65d485a4a7dd0dcf0b8f3c9e3c299ea726c001fcd36d752a66969c47317034839d2b847051c6bc5b183f5e93c27ef95cacb09c9532dbd40cda4dbf6c3eb67038b7892122e64dbe6b53cfb1c5dcc9dd59c0461621a94f290820aab5ec428d55ae3f7c6f59847bb980995c8b5181f02c3fef9c64e8991ce76f4d7a8bf457e19a4ca08e24b1e824c14816d0a2ab1a3dcc2793e8be886dd7f8d9afc472c8a16d8e2cf1e9544c52300384828fa4f8fe4087b5ca519c2550abcb52a1bf0bbb8d237507d1a34dd007c1fa01cadcc3a32ff46617a845b1b1d4487dc17eb7ab286bfede9704c54aa2fbcb625a87f18cc4f1d2f8b8fbbbee6a2b5632c839bb9f176869b0a27b10df2801c727f1ab704242bd8214fefe4bd972cb7e3465b06384ade65a7088208127e8b8f334253fdadad9c5763520c9d2cc9564c1cd88d81748fd3507c6c8d417c7270183154bf15d1a6419ce3affa03c0f4e8f867eb6178ea3ea9a14016d3e4dca2227a98a32772db9b190439479ccf220f70fc20d82e1f01499b45ab785de9f91c77e68f5552d12074cf24e1fb6c39f8a214461966000901ead5b9e3dd2df57014275ad4567a51005d4dcab5b421c42f69847dadb0f758073c098eb0abd308cfb41acfdcbd9060c4ebec9b204a578b2c73cb4797ac2caa4abf173c2d1415a5be31da57d42ab012c2eba665c20cc23a7285b46d7902b9bd13bde1fa6afeec0eb1f7105e4b4931e58f475cb93772929507136a9b839d432fe3ecd6295aeac06ad1ff193f6367082e2d46ee48a8c1e62b79789c764c4ecee23bbe73c178301fa3fbb653bd75b5f00498a4982cb4c44e932cdc7d38fb902a7f5da07de8cad36de3f8459622ed816bfb43ee4475d17aca6549ccc3f0360af53bb95f8f03ccf931b17508a6cc19a25f590ba6a8bee44c68c12900832115894231a366aff69fe6a7ae3c489dc229330ef8043db3f89ab579fe548ec6991bcd3f1d1acb05fbbc5f703430e033037b47a9dcf7cb3af68be376997468ea2bd65f738ce8bd4975794095fc4cb7c5b2bbd4acf92785aa6e77bb7b3ff09f5ebc9f318f9091b30b647ec13eac11bc25741fb7b371d4a9db1bf8b138a6f9115169711bf8a0cbeab09573c6a4c3d7704c6ef85096f63e169f841d8b6aaec6d97a4034584871c7c931378b49231f7588f832953d9882ee121f4f55751020ca6277faf1d93d60167aa2e08129b85da7ca505c662e1007e1efadf8a338995326196eb49042cd0fba9616d9bdd0e1ce2d58a3359017f52324dad1c51bf46425e0ccc652d6b375258117bede6f2343f8efb12220f023f3d8eee7e3a8523e58ae06bdb9a16ca50340a4e89f4707f30ff27a7e01446a7df582b85e1b26a0ebbe18fa410663d38715fc0483ba4284ef585f1388f9766f13a91d4f0e00ada9b8f320ab118526773159f447d3a4ada86ffcb5769f53d365c88b85f00eacba10de832bb410308999b069570c4435407cd6efc6313d728c81b1c838ec1d4deb44db45721ad0f85d974759b18f6de8a7089904fda9a6b15247fc02514b37702f7dff42b0aa1fef3f6c81ad1c1fc159c6e444cc82f910500e218b033fe8bf855d657875a6f548dc943563547cd9819680ac8fa08ef6042dc828cf21c67c3f7b2692f1ddd55550f0fab13371109e8a4ade425e7938c57fb456ac4529ebc46a787cd21de6f1d7ce6e8c4501ec7a961a34474555cf76e4a93edf36fadb818d3a0271d26d80c1a0146eec8204096ac99ae76d859320a2469125d3dcde119ece8a2f8981d4185f08a110e86a2a9e30e9bff655aa97d7beff7668b32b6bf9ba52dfa3c250b642918a24e81fcaa7657d089f38d0771a40c510d36f885a072375f47752b1ce0a3d7206129cfd29b1ebfa350a8ae642eab3a92f513a5cc6a63c8742eae85dbee0676a8a630bb5ad5e155f3462d2753be2940842a55e5958b79aa4d8dae6641b45939d1bd83fc7fc53b9ff4c0c5f392e33e9e09fdc376e605b49e40bdcff06a106ba5f4a94ea39796f48981fef976eb0f2eb16941863066cbea02072bd51ecd019cc6f0709ff28684384c6a85c9cdbb01f8bdea3236823507fb5331b53b02d19c4028800fd29ba4bee739433f48431ec390ccc792fb13cb65b30a4e78ff3905a38b9480797a8c956ce858c0e562663cad04e1ece98f07afa0676eb869a6d286d19d5a0258e087b325119319fb53f233e2f2f608ab1c7c1d612f3f9b65615f19a87554f2693158343a4c8b9c67d71fe38c1852fb3169d05c88f3b421eeabcee9ab6e822ee8d4414f9bb9fd24e8a770078059d41164a71c8591bcc44d3d6650cb877ff73086b6cb16717ec620f667a26ab67767ddb823fa6d5585624cd4e5acdcccbc2d7bb04bfca4281828fca43d83f8c373b067a0e7cb7109639f5319258fb4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
