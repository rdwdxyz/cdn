<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d6c1dd71e042a97547154d78bca8601f786b399369806c65a6883e7d46a45417bdfe7330a07b906aea4c940985679d9aab89be58f5ed885fcd80b0889300154ae5dd3323bc9a6513dbddeecce11b32d94e39721b2e856c7fdcce8db02962276164467be73e851ef6f1dea76cc80696ba0c62f25c1cfce17965486e2fe9d80fe7daa9630ebc22c89f04d242d42e8619cffd0ebb69944b5bc53d5fa16b1050613016bb1ddd6596099b835b6f34434d0429fd27fda10c3cadfd4991733e29d353685aef26065431234b8b7a63694b5722227c3557e9017ae607d14b233b8816605cf91cfaa76cbc369d8fb157f5c2942a006544872e03c5c634294707c611250a65de0632fea08c48da84ae9fcf1babd90e613ffd6fa9f82cf1358e2dc9e1ecf651cb5a4254a5f7e3a54fd8c8bbaac80ada492c3a7355b2ad63e3e397e44bc97ba8776ae4aad66500da8960e55441c0aca19d3b99e9cd8a9452b099dff637ef9d2d3db0b3752540864ac32a53edc9322bfbf0c78777c2d972036530842fa9ef28fe51a35ebbf187fc4b9808f0f95fc6256c8a9e6dd619cce0b8934e45aa244cfe29b9fd0c44754300843bc319da19f1d58daf67cd004710f27bfcfb4f6d2e92dad4ebfa32b8d6fb0d5c5504bfea4e2037e8879bb5b9eccaa8164d4241fcc1aa6b60f8d6892cb8d24ef351d96f27769594d00e0bf026011b41562b144cf7b06768568027ecbb684e2984a461f1699005acf5fccfd183429dc5681e8f839db719cba18dc595f53683a17f53d3ef7e9de16f6f80612220931c323327b9a94d2320f7b66c1b21d26538e915b9c92fb23c5d27d69a9925c663f18dca03520d457affe49661fcd51ae31d926dad53e3f3adf1d2533f0b4dfec417b1e3466b1f5d7e948ffa9cb61fee8a2e0d929d3097ef4ee68e4d2220011d881b07e7e8b1b6f99dd49e5859d356215034e59f98c020271fb5c73e4bed622ad602527a5601608bb9858cc14062d3c85766063ff51261ec6647ce72661318214a15b3fb52a8e6dc7edccf996d2c9eb9c590b1229224fef05ec82bbc0079ec3adb4a014c0984ad49e56d04d7b938f7eb093a25848a21ea0c378b7e890e11a132747ff3fcfa078cef62c0de5af056f087abee21f9ca41f002c4f661818066c38216aa357aeb151bc864eb66a8b72debec2960779dfba198a0f5e94f704222f039d9974634805f423f64d570a8c84aea6d598afebad54a9d7c70c02ce3be3bcab87473fa8c649d0777a7d191b7f8e70902b48d45f4c595bc872700ba39ab9c96157abdb64689b7a0dad684ab2c934b019b893d2becfe57dda6841909b8b4b2767215dfdc3b23cb3b523b9e2458f55ecbc9594853923e915bf148abaefdb0832d0a4ee4db244dd2a5a1233a294b3d1102facfe3dc02f7fb91c2ad9a547b5a9572f55781d806adf8da3e65fc8c3323337c88718ec606ccc09159e5d24bd2dd37f7b483008fec4a5ebba7f725c27c5d9ecb622f4827b70f1bea91235d4d4fc08cbfccb0a70d816b94d15e62d408e66525935e86ba5205f7590d8a7fc6bd8825c218d2c1c7b001ebd3fcb8def5cb3b8d64274ceff12005042d15a38d834761751c94aebc9402ff5c373824a363b4c0d26579dd5fd6db2ef04a1c9ba0aca2fb119570c4967d42ba86d861bae74d90436383693ad51de7ad1a84e25c7275abacd308eeed094d5cfc0a6d025b4830c44947a7d3062e59fcdecfa63ca3034e469b05f2fdc379dabd7147c453c14714f6b6dda1b62d2078451248d58a75c60444a5d38b3bea35aed260b55494147ce895d5b7ef8562ee0034b55ebbfef82fbd410efaacbe0bd8a0d1a3e2a24f72ffb82a1edb7b97f4e894d55070d799b28130b687638bb2212197f044089d1722f79b5c70a5ff00e398eeb0636f4b4bdf0bbdd4dcc5014f43d4794fd1f3734ab8c644ece5d459a25948a43a67a00125303a45b01d2f18e576b011ca78511cfebab6a9ab6b260df01e4fe0a8d438b924b872a0d4006582ed7c1ca110d67402002ba8a5c5beaa0df34c46fd85265c8bdc7b5fdc626bba6dede2947d1b5396b00595610aa421438540f30f0a35018083d17bbddf102540a30eb9725a548a995096ffd58e6e4a2f7e42488bcac6db575e2a9a1d13da8db08cce735cba5d34b10416b18d61632b749aa7da920f967c905f6809c9a87f717d802e3f892ac7e199fbd57f6dedfff4a5e84228d474b27285eea3e2696b3224ed3b2555327b5c7cf0a43f335bbc4fea82b1b9018d616b4500009c14c668a38db73662fe517121ef658be01b932d2f5eab540f7dbc7c7f2954bb05a9d155dab70780171e83961fd0cf2bd80c458f498a6c744d4c1d39c14dadf98d08dba08f1f007f4686240438e1bcdaa04a0190fd93bf8095d597d4dafaa555a0679a33feb04f6163869433c75d996e77063a7cf18132db3d7292bb5ec59f5d29a283bd22f6d5316b0596d4bc717486975f4d2807555829d926c859cf150172c57e3b2efc0bb4a0e42a35ec9b4345a5cab185f9001fefbf971ba46fd43402d3ac5552464d6fb210f4681183086851691788e3972698984220cbea1d52fd815bc10141f695f76438f8717acb01d6b68aa0c2e46256d9a8cd920611bcb4d2027010b1845841755dadf17345da0a90ed273aef5395c0b7da25455d72e619c1e674d5ef8ee000c634768e808541eed72089e9c3312c3d914821b00b436f96de3187a7033460b09db0663bdd88443070577c9b174afe9d91a433e099bcc2bf4bec7cad64545a4910330a6a553b01fe20e7e0c49920216edb0f204aa2e9d367283c9cf10e7f28573d1a0fca393d32521f3bc7ef8d6b8aeccb0b9bab0d7c0d69a07a632266b96afc7f60862286d2fca418850b8bbb496b4a332e8c8a843279ce6a5c941b935220241b32f6f5bc4b0fde56ce7eb934b48a22c836dd3735f29be9cc896063a39f968d1cced2b55da7129a7f6ecd7db1dc50420f4575ab571d1617ced4eeac00059f613f770001d07a8908a512c30d6c039fc43b530bc7de481921ca6fbca212ce07779a053c48da999d4dc8ead97b184b9241a5f0e00d4923067a37a1f35acfaca8aab368ce62cfe0c6e4e1662b818359f043fda6ae9b57d7e08b3b1c19590be65c2859bab6e45b45231b323e3c95b0e2172b3dbce12a83dc9923ff2ca0e31646e4e89c38c6ac6bd17ff7f0c3b2667d38cad0e04f33d2d1645411fca06a3a84d8ccdee8ebf51c28f05d23274d8131b3a95772d5c4906f2728525ec20435d096df94f3405c5c23e5645f47486db93f2782570f4e08ef317522deac1a8d8d7cc2b85139fe0c431648a71e91c371d752e4e8faf47b1e0ff68afaeb1480eccaa551193447ee612b26208158ca4c777687e1e60c57ee077d55a024ed2504e18a3df0f19ab1f6640bce78f6c57134a1c1b13e0a9b4f8d2555d3141e7a982bc2f613f0b6ecf3bbda4619777efeef5fd5a4bbb41551d2258852d3b0acf9b2dcbc1b21beb34533e2dbd40382083d7b4acbcad7706cd5c91e6040081597b7ae341a925111e8d0fb39783df00ed4ad9a593b5766aaaa77b76cec2bbe4f2fa6e5d1c53e0cfeaebc404c715e4dc064d09cd9eb40d4c2b27e27670fd4f2aaf8a1612f2edf6422a919fe4b7a4cd0c45acd78de48e48d39433487b071fad79c01b50c4423159234a700bc57eb87313ef50cdd04b0b6da34d9769484da5a930c2f44f1261586f242e1e8955aecdbbdcc0e113964267980cfb437836449b858a49f7843003c62c53e8c6d9372a07b361b67a328879e883cfa45ad5085d0c8e8d1a7124e6a3710986313db829310a3c2dbb1f3e895669277bb41d58503c04a32fa7565c7618ff9221ac40e6cfc60e68c74213d41d2742332e4f79098798e9e66254af3c52271bc9d2e5e10923acad32b84bfdba044ad98fe918a1f4caa14860f5572289967041d6c2d3d6b97ffc30881069674c23f89f6a579f31f63cd8ec81dbbc3685276b00c0b2aad85c995141bee9377140d153da0abcc46a39d2836933b55a46c21c481c28e78325c9d7340d051512f7f7f8afa6a27f54aa5b8a8e6db1723d7d579685dc3aca021491bb7b192955494cf01d2915021e5c78146b409eda873ff5c005f171da91828384e13d45d3d55698618b38c453da2e6315e7a47f7eb863605c46ebf46ce39df66ed6329bc40299649425dcebe7cf0b30a58b0287af6621f90c3c0530e939393e1899548fa412522e559e91dd18bfc6ccba0628f9798aee0fcb465cb7798fb2400da310636e45e434c8c5a1a0218ffd45e35db23e3be9bd3fde3d415b08672e1d3994c61f0840ca1f52a76fd838815990b07235c593f486c9745fdd7144ecd47dd696646a2ba0f186050d0562798c6a7b2e69af42e2b854773ff11a0ad4f179fefc0415f82f2318ff0201d235a62ecbe448f131f6b372e068d1ce41f72aca5fb178aa2ef8874a026b945293f4b1d852a95cf939987394167db63844ef254f224081b28b537c0821ed8136cd1c95764cad5ebeb516310a5d0639868ab988f5578fcd5347a20cc49a5d675bacc2a6391684169650dc9d8e6d6db6d8bd75984b3fc2b308b34adbd4264244a5f00d2b88893b1d556a71ad072f1100e281f3e4dbe2b05e3f594f797f6dbc57e77c23e76608baccdedfc10ce780999bccbdbfa2b043fb0d090b9b50fb02adea65fcbd444c4e5f45b12653c91dea865175a4cb4713deb0ae72f079bb70b6b9be800e6c3e842f2be51cd51ce5b0e7c17a8f736c647a20e8811b15b4a03fd5a74da80a50cc2a15f12dcc3d26712a600cbb0b51994b2d296854bdd5b68e11833e0a16801b5d62216bb33272a998e0244cefcb585fb92f1c2a2d4f58107ab8e22491ddd36913d523b1dd2f94f258e71aa699f1131906df9ecd59498142c8fd55393792c25f17246578156bad62fb1acecd2eea8b5d15c3e5e5fbe4c3b5157af968514402d7f98e24ccb869b04879c646f2981727b68fbc9c2ec9327bc5914d6bc6a4fa4d20cd4a68e46712894bf2db4af2b1ee8c6989f4e411eacc728455a6ac913e803a081df435fcbd066ff6ed5c13739815cae6d2e87151b156b637fab927d0a42f6305d9cbee2210e3cc0fa37084e1df77a076d682b70d8fb48f302b93bfaef43e8ff568b2913a332d17926aa0f28fea0a14c1d75bfa52a9c07c6b13afb55ecea66f509a4c2bbd6b7823874ea0a683abe271ded33b183cf5c6868327f8471cbabd9981f2ec307d8e4f2b629c8a44264a11c3229e6df3b0571bdfa137467b8a79c3d3dfb936837617310ee2dbb740b19cef8a97b9b71c856b61f886f2600c7d4c9d85d1c746d5bbe4768ccd671a32825a537a2ca9eb9b176783052b3249615c76f79f5c30acfba1ece4f620d6654048999e14ed3e82b535ac41b5a665129b7928fa9c7246e0d910f16f9d15572f01d78a72b320a72b0d517b88cf69e0a2c57f28ca3bc0bfddb4ed0143896cfd31fe489362fca0d0a2a7ea0099b06870726244be734535d2a18cfdcb164859620a6ed1c1d79fc4ff6cc84181e5d41948872c21d034f64db36635d3311117474c80380bd3ce3874488c3892698045659a57288f963710d8114f16018fea12e3e83202b5d25bf721535b7f29493083cfcc4ff36bb62fc4d3643619168548a97d92b18883bd4513b443a2c1e94798e9f2b6db9f57a05c65062233e046b6a9e0e3859c7af15d7714f2222b89333568847a5b64e6fdf576cdf7037a72924d3ee5fb7cc9812a4cab0b59f206d04ad78359b64cb143a96ffb129a0994f16954c59b755146c8c3499e5c4d4333215bafc0c821b8cfa4a07c4c55e6e25d8f22f740e1c9008a623d6ce2abf1d4a25b1f93aa6d81e859d0cb568655f0de0b51f121b56cc9e50230a65c3ef0cdfd717dd542e1e1b99bc21a9126e5bda159f4259718d0830991d5c6bf18459f0d38e7903f1c43e2307e4d654135f2bea0ab2e9889036d20af6bb8898ecaaca086406a226ab15543ff218630c174e82700c8b7c369b9d19ca4f23a9f04e31d1d93e2adc8023e217edee5e47c7b36d6b643a6dd38ea9104e462b87f9615f0b5648444ff1e218ff0fa4fa2d278dba9f25d17ea321c0bae3455e8f3304d8d53cd3977cc7339bf37a0415e0690e5e52d37021c8ce0f2cbda70df37ec481885a815511a35934e2d2187a3d5babd3c2f328c14a4c1254e9201151ced1d17bb7222dfe27cd5b7e2aa969e2f1becb70c21ce4a62eb6f24508d36fd63c2a40de4face0c499b031534f807940e25c7beb3f4ae0915b164ce35056d172c71f5f1a0f9cdc87a7288468a6fe37849a89eba260d9b79c40d3ae09c1c0917715d5a60d0dcfa16b700d3d7b678f83a85ea1e1c9821b53895e33124a4c9aeafbb477ce843bc970952ae6284fc31dffc15cb013508600d851d369659fcf4371e2e976c2315dfa60d0c4b1472db33ba4e769c72fb762aface49adf5605cd6344e5a5ab668beac27e2fdc7a25d7837be34486b47ce0f1500e56211fbaa3bfda49b54376a78e07299b62b744f4f52529982727774047823ed1e417af2055f8204701c8b817a3137b2a35608114926762451a001e0c467a8245d29140a0bf386d0b513a7f9d6432011c4effe98ed7b7b51c2acfc60ba4d932e5ef550ee831f392eae6c2603879d0718bc46742085910e91c280d92387cd2ba4460a8c7f4698d3a9a4c142dc6c5b73585cb3a65d4434881005b599e63f3e8ef43147e9537a5239439e8474abecc284a39f8a159fbc7579d31baf2c52c8bfc076e3dc9e8dc94a157b7e3f30d669266632b0715ac425c0c07c3b8f503c3a2715bd89c78df213e4b8f4332e898367cb47b06145954d07402cd02b9ab9798db5f171167d0b87f7743fcba99e7fb7e3d1ded7c43d76f9ef4aaeb38a89ce63890e18144174f63aa544a5f5921a2a036ff7971b320f76db12f20c3193e1b2e125b2e311294fb96fdd856d3305d115d3ff2af7d83bc270ba04597372ff17ab39a89cb89a194aa00d71c87d0236386dd34868b2484b908236727203a2c65cbfdb5870c7f85acc667c9e96dbfd33d07f8579b55b0213caf0239076fd8b47bde4c9909d60930d166de3c8d9cfdf6b2de0edecfc283e7ed1cc2831cf5c5bb64454c29eb03bb8685b5deaf697bfc0fbf77707ca1de0cfef404706135a1e1b0cb940bfd7bfb7923cbc3a3d55234468107b921f724b3d2da8d686befe22fb9ec58c5ab3e4c63eaa95213fdb69f7d335102d3aca38f88ad4b371b941d82a5085e9438009bc9d9aebf439aa649731bc76c286acc26c36b1c37b48081ba9fd16a509ee9e2f4215c7d3370df98a16a1ac7e5d5efdbb122e3372e7be7b07b469300ed9c32f60cc21c0d01a78c0bd32aeec893f1833479ace9521f42dc6718a95d29407d577bb5393efb4ada8c4c5607f6e785696471f2cc3b28bd33ca2786b79e0d687d6700d294324dd9169a8b51815ecb89668b27d931b7b27e16fb8bc26b1a3f773aed7431999481db6f5cf8a86788441832512e0b6910a1dcb8e6d3b6e3e2b3591c8d38abd228d4f790a7adefc55f39bff6da77d2942027c08b2a8a3c3591f5f8a322faa909fc74222a18cf81eb260809e5e0e67dccc1cc5ad9095d1eedbeaf81fdf1e08b43af2410612ea46b0b6b01574a2be33266b8aa72318466a0bd91694a2954d105cef747864cb2dc2db6059a0041a275a356dd8eb537089a691bb8d0d596d720709ea710be46c4c6e6f9b7833dcbc25e6bd0dc08cf5576434b25a8f11122504e0c92ee991945ed89d67be86551f00a604934b9312a7de48050e599a324a34ae89a43f314ef9bfbd914c9489e26687d66bd62cdd6f22d383adb76088d88eceb54bea872cce8a05fb8c36eddf435e4c37944e072d7c0e260d40a2ec08baa7c0b7af9274c7dbc867ae9c3fc54afb5c910bfefcee1c16ce8bdd46361692521c4b13f3e87f28bdf2bf75e978bde7f55a5ac1579815daf452f9101edfe9ceb9eba9742d61aa27bf18ccebf150a738323c1ea580bacb98c899b05ffba389cf0a1dff8200994f912f976b3a20a17209e9ba6fb7dd2bfb4687c71a7eda5b36237f7194a52f9322274307197a643502e7b09092776289632b53c1ba2c2c34312863c6b47399b43ffdf46e66cf041f2974d4389fa79a832c79d87ea7fc14b0ccd829974036c0600476ef899d701c0e465e93cb1e3cd7c13035f7a6624fc384f7e96ca8c8ffdc5f84df2159daa9a032da4a8b7ac021810e62319e84d47815dd7da1097378b1d2259254953667fda69851e0c5b71690dd2c442426478bbb27cbfcf40c45827ff12dfd671d9f7b278274eb63b57c9f069407b722ae4ef92d00d814e8224313e9c16998e675cf3bbf50c99aaf5a5a76b3918631397e3d0dbad19618f8bd5a2439cc4e0096d5ec0ed7ed7fbee800df25fe363e32a3c5e54136899cff863ee0b300cef1a0bd06d91ace55a69fe0c223c33f4b4aac46c95906d120050151fd3e5ec456af61070cc28dfae26073870e3c72e98491be925e28f7970ee8dfd2bdc71304abd8533c36999f7b50777be987c3fe76a849aaedefa8e20b40c5ef774cce5682982054855f921c9fc6c5b7ee0f8a21f7f103f6e7120bbf4552705f27efaf420e22c2c35c9d13eb8c53c5d83ea61158dd17bbdff7e68b28aa6a5a8f6e4c9219084955d259d9a8d2a6acc8c0af100af9fee94e408f1a84e7564fe366c0cb64e5bb8285645fc12af978ee818b483a1d979db0c081eb88f1d7b9dcfcede17df2de680678a039382912754072fb4dc5203725b897fb80f6be9ae8f30ae7253db050b1f5b915d18a415e526dfe880cf81937de94cb03f3858236fecbb4dcf1e8e534bcbb3f75251c73d1fe9abd828de9263573e06ec876b048c490d6209268559dedc8dfb9959ca0068da2dc95a9421184dd8e50ff4c9cd88b3fd8f84f6870e2c9b170ae3a1fa5f60d725cec443820445657d92e1a6d06780b113aa2c140ae9d976bea8ebc3d1b980f7cb246b5977b76d63eea3e9e75b29520e75bed5c9fb6b32aa25b2c0e040a8ff84269d3fa2235104094ec9435d350a307b72a05329b796b23ed3c535129547fddd7321a46da9e438a8afe75419eef8e09139cf5ea0832dfcc263ef62ea1c7a5b15bbf0160cc9dfce8ab6537754425be27bae2a848621030abd88cfdbfd150975a95818a72f38161645edb4f11017edea97d2a6a3e3cadfbbc9dd45dce730297be5c3591026f3e05671e2ecba669420af96e1c74fe3e1e69ec5bcf0f197e2ac066a795fedf7a91590efcc7d34953d9f1c1e6aa114a153d0e7c68df713d065ed594384655a70bc0f382c4613dec5db3b2bd09dea0def02cdae1fd0fa61e91eb44f9bc2c7f7f6446a62cb03f4ec59884b393f03b2e434d349345251d5848af444bf7778aefe9aba6cfdc4a9d3c8208268cdeb53714e2c5df1af499e71784a55986f7721c1e96bc2e78c8d15ba3c51974b29acbe2f2534010660152db4a8f86f01adce8f1feebbdf7be07394d44b98058b0a968b1fdf83c33149f0b03f77b5cd993fb8eb3725b80df3da2bc0ee3485ea82a455b75cad7b26b39c7ae099290498867898df016d277d242a4d8e362682f95167b5a4e62d0119016fa7b8d30b0fcda37438b4f7af59e13712ba0ba2a5341245f9f0660cfd264829d7b719a553f49019d8d192c4efd4f2dd51e8ff1a91c86a8f27e1ba2d64c191f7a543622885852deeedf37ec8adbca911bab866e4505994c70ab1d5427c48ccd74c73789efb225b47b4dccd61422d64984379e48dc5a71390549a23634f076ec19edc3dc6fd17facb29afb68e0ff2e836a520cb0dadc9046ee60152575b8429ead249d6ed90c23617f8481044a87906693f7b25931aa9964129914c35785851168d34b03d448eb6159cda0a14aae462ec005cc0d5465d5639251bd1ad97e3693d5c04cc671bbea4b18c77c706ec25401c99708db63f855148e299c10b1e98b3966a257c058bd977673a7a93678a557bc85f4713efdd6b0310fc44ded4f5bc490fd4e3e59ca319ec84627e4be8eb19eae7ce79c3156008bec2b28adb67af855b6eda0a490da3eb40c73f4a5a1d7747f8e351ad921c812b912959daab4e6c7da0d65bc5604964991522c59e42c3f8cb430c5175072b0d0ee7447ef58ba2efe58b04815413c06e4d12bb4cfb6d8048bdbab242e803f307f52b0b789e9e0160eb4b27b97f0160171bd26e210db263cf1b501424c7aac73adb0aa4853418078c0dec65a2d5fa4f69fe656904075396288ee70e91cc1f2f08b2bec795f3a785fbb2070ba4e0172a8a595689c9b06403df60dcaf52f90456965cf227ad0301a104a4ad88ef2f4fa413847a9708a2ef9db614f5a0bc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
