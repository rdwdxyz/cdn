<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60a121bb7044b460f0846483f12a74f35c5a4c0ab7a0ecafec60c40b7d81c0e332962d9acc7ed2b85db718018fb27e55610960c21aa5d52e61e2cf79562eab74f030a968f4ea85d66894c8f85294ffc77a50880cb31261996f9221b3b2d9727f51729ad60898433f7c40845bd7166908dd9e7152426ffa609b90f57d08f66fdc70275f254f1b9be6b5c00f283f48296b905c03d598ca3450bde19ea6cdc573b25beef84af473ab989ecb0e897463e447a45c847341e797f46f25eb8e1b20b9d9bb9983520bfd5978ff4cc273306dfcf24f73b109d52ffcfd3a47fed180b7644568896962fae38b4c891602555d6e3bab68a5efc8d253ffdacf3da0ef048045c12d002f765874fb48bb69e240aa6aa8b3d1b8d4a8585e4a93ef716d2f262184f952ebf841c34c5963a15fbf48039c53cfe22bf04ab884eefca385de5aeb8382bf4e14fe4dc60e220ca414f0274e7d50c0a9973d21d6ef359d8b163172ee9a6d5d5755a307b06e7d53208d795de17c84cf0e9d9f442207671f466d8f1204eaca37e0112983a41df9641ca24ab13e875dbf15b5011218ba606b38b6a47141124988bedc17fab30d302737a5aa44bf63b913fede0c98e993e3800b654b72da1886f487364a7328a59283ff1ddd1486408177f50946eeecbe8ec274833f5e856eafa0b9002366dd18d5607cc72accb9a8e361d7083399f8b207814f760b0b893de18b04b144225243c1e8f7f3e6e36c2860d5038e6f0597b84a0d138bfb2c6a48ceadf7843d63c0f384ab72567d069dbab7d0a7c1c5bab5d0ae730ba05e4d9b95dae18068ea26212eb594e079faa9160edc36dd443179235ce0b53a42cbbc7018a31dccd151b3289fdfcdc71b12f641132b756eaa3eb115b185d156389adb056ee53f1dac51e3c74ce7db9934a125ae9c8c69d7a7860727e7cfd0e3a6e0e23801239a8943439c819f204942e70a925527396ad1b5c953ec884cbf0daa0660b370b39d54e66e004d16c7d6d91dd8ab774eccce64b82aeb58857257a3d9a081a9b80860e3b300d9427f9182816ed84f55e9a4fa6c014d789c96f57890aa5d03c59ab99204571fa624fd51f4c5c8cc18a26787387f1eccb8f85c3fcc94ccd5d16b85cfb86191de8229dd316b6b4e50945ba149564b783cd377d38977041086bb2561d2a1a87b2bd25b4a12512b6090ff662c7b9a17b1990a79c1fdb06d0d320707ae240ac012dd228b85a9839a9bff4589d2972125e8d34db7b5ccea0e366e0ab8fc447f49046c94edf56976a05466cfd76c04ae61ec38fc2122bf6971ab0406a2260fd778fa763838eb70c01418f078c1e2048f44e3fe9fb800771e66acb09ed1f5adc97ddd3b89e56fa75014588bc30f96232d95011d1dd27a5cbb53f069c25c2ca4c6beaefb239dcb75fbfafbf284761a1bd2bb3aeafef7f7ad1fdf36d09a7dcf9248b751304641fe7e568367015bc51177f8d5abc39391de509bdd993f0f29e34efde18a770b17bc5f35db6065bbd8f4b6986d54ed37dd879a1970e31b137ed475355e784b1432b6e52291bf002929e176ab7ee9263853a4fab7627472995819f80a2905e32b339bf8d98c4840898c6808027ce945d3373824997b3b02afb24112281dd058c05748dad563427acdab9c87c5d9f22c826be9880fc8a9ba1c91e6abb86129b3fca677756627c89142c3b698c39aca7123f4bf1c8d2720d6119f7e273cf62454a4662260a7b92887399bc944464f54736f8a697a373277152a3664a167f7464917655f9dc6e68d17ab529631207e559c860609cdb5c0190b6bee37015e07b7bf38cff5ce5f07dc1ccfb76794e1af1afb0336df855630565bfaeda45a5215d1915206b35d8fdd7d71118535eb16eaed980f3fc57b4e14f8b283d093824850c6aab0170abce8d5690bffd50d0af33a066a4cf005496e21374829749194e4044b3810a7975e1cf5fb5564b2168bb85faa204e4e6bf8bcf1ae917bd0699ad4a7738d9be9f7ce9b775a7764032ee2453b36fbfcbce80a53413c502d5bcf0a415235fe53a7791b10abd18866a8d39721e5a5b5dd8c921310b8c2ffa6ca62dbcc79fe699d5051752973905d154350bb93b1b929afcb0c62df9172146be3e11e09610c6afdf31b50923e5e36bc94763c6eb1bd4cd523e0426316bd24cda3e9be55f27aba47083ff3a25bf2f6fc0bdc74265920ed2af4a9e6425aadfc5cdc61456ce08bb1b2763929edcaaffac220b9940adfa9d7da120cacde8877e3e19fc05aab09414ead58e1473dde13e638eda6d5e8bdbdd6788f5d7bc86b1634be7799da82681382410203cca8d33dcb943bd100d525b44297a8efba947efa60c675bcf710348346c892d6cffac78160421b2aedda00324530d3480f02d4621daaf46a3ee51565cad8cb75fa083e6983fded0061c8be3f29022ebfd47682ceb99005985c86f63077a02ad31b421f95956713bfda75324708fe9d1fc21eb062d20e1dcff2846da721fd93658e7272109755d777065e3b3950bb0645ea025b2cfa2cfb1bd8cbeacccae88b7f88d4a7df0c51e68df5e26c871c13dcad3e96566ed2df7efd9ded6e01d0f9f09acb3b04f8e3a0712cb39c7477d4483d703dbbb94b3a299600114eb397fdcb904bc54babe8eb717ab1a8a5d4bb57b5903d5c082b720e3d3183e26c17f28168225309b6a3e016d73e79d71db270cca379d5fa2e6324a0ac20252aba776bf8550714070c76d3f67cce790c80d234294f22cf254f9bf188552124e4a23d7eadc0a1f6e250127f1df182439856e197bd4590528e1e18861c3ce849375e09d8c5611900665ecf7444ab6a4a1407a6e9f02ed098e1ad067f6967085dc7d5f715569c8858b84c1fc022f6c14dbf41b9e79f9f7bf2f67e8ffbe6da8499e9e4c03de38e4cd06cb4c257d507df09831b2663cdcdb94e6d715963a631475cdcfe8e563ef4376cbfd895f10857a3729b7981b68ac31cc5ff6a222b7623ec768efc3dc4b750b48dfe2515e8d9022416958806a04cefcaf29c39bb62b479d2cf6f0fe8a16304a1b814cabc4d35dfffdbcdf65ea52a34ab5ff81ac489a2914ccd70e55ee24e2a689156c750c62a391a43a7faea3b188512b0f3d7edd21c5a7d5d1a918ba9f7874c2bd1b5218c0fad813a492db6f9515db5795b0cb0f948d07d1dbaf2e4f7d908af746bebfa5c47a0b9757403e2bc4c28c28ab89b31f28cd0b2c0bb1f47ab457eb0ab5798e88eb10847eb4ee5f4f28783cf4a21a7f42eee7e4aed967f0061e4b40df0779c4853f0d4f792c8c42e3e22850c595ab80a8a224c64cc3198b559a436a117258704872c55541a096a5b12176379dd9b702398670cb928602e2db5194ac0da1c7d948942940b7eb5b65586d6332f8de5c53e5352b9b167c91a7e3786570f2fad2af1433e4357692ae9a737a1faa2b87822f25bfabbc7e6ef9f893692481b09913717962a170e90c98a20359bd4916478319d818ff36f8f6551d5e19d026c753bd281c78ff1fd4ccd32ea58bbf2d738075f69b0a363247e8d88f7d1e6ac79e7985059c7b2b2c27bdac5e993d0b76ec3d9296c6bc37f579395ecde751a6ad43ee7afea87a329ecb5ea5f1cbf1391428503a8d3ad5e83cdb1fd083873f04ca655bd7208fefafc6e75a14f8f3175c41258c5750d67659a11d4638c2d196b9893cfa74caf3ffc1dfe897dd3c804450272246eb4bfdf95ece184fe8f119c1ae7e748737e5935e9ff8f5b2ae6162f7403b176dd21aca0971488308239fdf1111c37e2ffca98b42d086eaf1526426bd72cbf205d6d5dcdd5faac375278cd2e9aa48206539b5eb08207b34f4fdf583f64dcce63514a81c6f30c25bb2e3a2c285a4354c32ee57f2ee7eeb7f05ef71e93a6e52b0257e7f7dca355de85de711e7dca1d506d0d6f792657104db0a53a582096a235f3c3587326c2af2a390a55e92aa4dcced2e60d1447c727e1203cf0125b907b8eb507da52604d7aea7e8e5d5c7cf6a88be8e21a0e5162773a4548977803018f6c26add754b5932967baf99eed5d7f90a4d57aa1b78ecd629d95d3d00575285c723e262a2c9c295310e7c4c6d9e8a7f9b55ce165d1d795cb4926de162c99456e526fc35d90976adb8471ab48e98926efa6669861ef45b209f9a3b0a10d04326e1d736e5fc16736f9421819aef9aad3fd39fda01a6454af677ea2c1d435a2e309656ef61ce4779f667d63a82b571b5d5e31c73c02b4853f48659b1d2d64a7fbdf73f5d5f3568d1df99b9d965a76cf88433fc067a766fb5d0dc5e94f3e95b501a74ba5fe77a9126a18f7b30a606491ec21e7d3a315ae77af62582950e3def246ed7e0c3a3e5c18d36d0518c12dc332b5877ad7ecceb93dbd383a3aa70891211eb4ddbb76c2e389d82a4cbea8b33ab9e4330f0cd174ef9f840976f38b3c80f85eff02197eb9649d6e6d52a739a55eea466fbd7cd35946cc57f030b9378991b4d025428d549507686f71e2930e62eadab9672a332c46119470f2dab58a717c67f856718adfbe7e50a9738e60333005bacbd89a0abd40be127dca48ad6ecf83e0c05861b0b85f4bddd27ca31598420d8744cbbf7af717cee09e615661de1c5208a43899c02e8ba2139edaa9f54f01904f057e0722f86989ac20d7410f530f2fa00394cabbe0d60da1b42be8b2f73896b0c502d51700399ea57b03bce6676a6e57d777bc4f96d8d8b2c16cc9141d874350ba208e8de2cc3a376112f81ec08198fb4897d4f470527f4474afb81c85990debe43970b839f3ab31b0b81a5072cbf3e586b2172c3f1f033d257859368c22be7e8c94127cf44401c6711785aab01d6a3a7e865528e0439698d17c7b492b63669e47db5cb8b677008b9d3d787b4bd7eb13d0b1f56b4364c345678e9548f5e704f186383399c45dc4efaa5d3c8abde45e6aaf19edf38c1d20222c16df448915ebd5adf7756c737c673f53700d239214a2a1bb21a709a9ab010f5afcead75f0d90b6fb2a94bf28838cbc065e69651167a4b7fe46ae0a19d0daecc7a5681395d20155b568b052e713544f59ae66fc5084af4af8a5faabf33089024ec3b77d971ea3433b0c79add0baf50a59ddd574be6c057ea2e95d2a33c5e125e21726574ee38412fac6b5ab9292afea2e102c77f7675bc5688bdaa2a8c68af0038ee13239392e66d01e635693d187d64345691a7c6a5e624001307cb46e041eb41e0cb12e12f21752c80a55d23f82871132def3cc34d0c841fc0aea8113dae910c367ae397459aeafab252bfbd6a01f701768ee328b89803bfab71892aaf05cef98f0fc9d91482a4f4fc66a263cdf93cce7126237ff5264ab3bd0c7b3514b46e131934ef8370dc09aba224809e328368a062b280845d03e4306a62d4b3b0655abbb41ababc85a06bc1c8a5bf963ceb0697ccb304d52249d57505899dd4c9bd3f2effd2dcc4f2898970886b36254e6fa2e93eac9f302c93e226180dead3699ea139c05481909dd80763b777a627588fc82300047b4e60918715f5776e46c21f018c2c88cc7cf4e4768f2933597dc3570ff520a46a667421aadbd92dca933da5c2f5f279f32b51ff16ffdba0541f78b0d26b97e95bb8c48e8d36c6e5197906fc0eff2b428dbcef9d16ceca11b1e87d28226858790281e68e71b42be005cbed555e4cf0855ff7eb3c68aa330f8ba23cbc67bef31aa5472094be0c511e16befd08d9d12f57b18f80734cd428305f38d51959a4c58ef5a8f5313bbc21cd960d638dae37e27856904f3230caf3a4ed6da57eb34e9b00f0944dd62073eb556d9e0b6ffaa86ca307cd3ef964947f719d23ced420bb70a2729f806b898610250868f3eed6e7732b5936ad4a5dd29045509971ca88d5b1f1dd90edcf8cc0d928caf84fc1a9aa35bd4fb522d93dfb5ea8d7b906b40a284f0c8918f110b12f8bc09b38050d13aae043f16d75bc9050dce27f49d679a210871c8d514ca0e259d33bd13544f30c8e9c10d04b4eb85b50653c1cf8e3ea54542811dba9443989b984e5f43d06fe9ed6e00f7de1e2de948c0b70da1cee91145bb1d2f1fdb0e57f63f5ae8734a7211b72d55b1fa8feab98bb67b3eec45203af02564a265f5b85667ff84bb7916d523f7d0e8fe91338275fa7c6d1662c93c07a9a4803b3e428e17c4277f412401a6be0d76c39c76ae52e43ed3bbf3b6fc4ad9046595bedb203697d4af5df481ecfc61f1ae926dcc5780e7ac5b08979acf8b0055b3cd7c9cfa2d1c972cd2c5a21db28797882f93b364c99bdcae87a6193462c7d15cf00cdb02dc530983c363f083bfab5f2cf5f84b9a588b237096bec224117b1400c1e2ad106c6cd7b25a5cfc07b1184ad4d56d83d81b8d04d9ab539c8affec088aba5074f52f4a875c8856a59c92a9d6f482da1786cbb639d5e411acba5b95e5df71ca301ac6e4a9ae2640ace3bea656056c220ae2b0c1c16dfca96dbf83a1bf607b561da9a0fbc6c9ad160ca120edf219512c35b64efa531f103d676777f322395b8892c335be447066b9c25d25d608f1e94a9755bb0a19442ca59fda547e26801c92f2c6247408731bb1fd236a3f4a3584219cee3b52b06e30f47844be2d23c7b72013fa9d2784c7350008a2f81993ccf7bdb3db9a301190aae4615db0ac4735d28a63e8438fb5ea9b2cc30d8e59ba2995ffd8ed26288acd0093add36cbc1ea1bbb96e8013068b48bb1c92099fd6ff8171541b786c7cb95fd2f40d0ad019a16da87775e136790a723bd946e14111274afaf50c00dd3fade574c2ed38679f62f2b81e88011e3034743ceef0e5c2586323c6371575643dac682f2d22262491070b450b39d5fe307cf5c50e4c3434e3580c5dc71d922fccf5fd6da77118a574f1bf45493a156c5c26097b4af0958593c2f398336e2464873eae56c003ce2fefa54e83a15481993cc9c8e367fccb642e231da7b1459f1d8c04ce74a9ccc1fa3427e5cfb308ac85ebb294705901eabcf29b9242e391e68f930d9db80ecb9a223ae88e19ca8d2467c95e776dc163a905700df572e47c1101511adb98c10de77270e6179fa9115c43a172f5495c313c18678719cc141ede2a9755aee1088a944500ac836f81aa25de0fbdb4e019d949a1c6af4853c58b292af171ef2ee378245c9b9e88fe05c7e16717fbd41b5eef22ecb4d42cdfca44301bfbca7d9ffe27695a66f37f5d5bdd800d8b2c282534b9024df7de6ca9892f61de7abb2f1c5eca8ad14242e2a465bbfb3ea0019b0ed1799fd7cfd9037d48654ce1505d0f51cb5ace55ea8d8613bb801a7444d1005e619a02b4591ff196523963fb9f35a0dad518cf231302fb155fac2c7f108ce1b195778b82231231b451d39981f72a0daf7cbc52a3e278dc0b5694deee8c2bc2e1136257f989608ebb29b326c836f0f4c41f2dc45b6c91cfc8f496abb786e4b87457fe5e859789669ee9bf729e984cf1b1b853ccdbba5c3738af5e57b56e4ceae96efec8b501a5e0aaceefe90fd7a60da0680ec16e8d5d15fc478ecfecdcfd7a666b6e6d8a0cb6828569a294b142f1ac0aab173f29b8b7b3381ae21f350a45fb2d3f1784ac47ae6bc6c997025d68a76c43152966672ab74eac809463179f8aaa5d01b1fcd76e686033d9d4f1603665b37b35c21e83804b90ce8bc94faf3ff8f10ae3382b239d3d23c95419d26d290603d986490a95a8c914fed51fc3d3f326d5c2b88fadac1f03c6cf6947fb9c0ef32531bb2234eb041c66132017d8b43b80331e5c2940054c0ebf7ed7d5fd499b8cf9040b9e306b453ea39886c681164f1c63f8f4126e7698336cf242dc9192e40d7997418d8837e47742bd3f2884712e63ae38bed2390cbcf7c981308658b5e058d49322307ab22d2419aeae00e511bcca7aa3af1ef60a71dd6dcfac29ea6a17f79a4cf707502a234e21a13715f4075df7ac43444b3abb937f945a5ed0c92a0ceb98d5e3e1a5a36440231739fba357c08fc292cf7ec6cff41140a00682c970b2ab0ea56c676497a15d683ec65afe1de6d4193b4845877a64b8e79ef9ed5bbd1109160d823c8624f44d47d5ad0c6839cf1c9ec27a42960186eed88da8071adda381940de853474405faa14102c3d47c9d75d49fc0d9ec876540b6001823dd29b4d55cd896d4df05a4452877ed37a96185b565acfe271959a642adad21cdf477c13bc0eecd5e211d366943e86d2a934f7e58a9f26e00b634ab9ac3d907844d0f0f4ed87b4674fab431690ac01e0e88327115b66a2d20a8b454663f16d9e59340d4f8b0585bba59e017a6d9686be864f0915667bd3504f5558777a850b6eb90ffb4df39f3cf8ee83717542086fccb870bdd370aa06ebea5c35c9a393a72092966a67dea10e82bb138273357ac43458f5fbe8deb44a8f2752885ce5b30e4fb4c22a5793a0301f945a3857d3bbcbe3514b8f82547320d66d3d1f2e5df7fe62e9f2b7fb4c5f0bc85d9547cafdf3a2ee1b45d02ed02ccee6fca1203cf7cee6208347f59ac25a7bd28f943f702d762667b836cc2a94e192408a0f3c61a6c6f889898745b363acf5e05521ac86f664ad91c2ccd59011abc90a2e1e7d86bafb8cc94bfdb894c21818a85de8a33a1b82e2c1ac3f0fb8345afa8ec6dc250e25363a1305324ee93458f53c6fbe6f27067bf77f35af2007a423cab5d8238e026c0005da2883aa89bd75bbabca44e7a80bce75d1228244552d7184cf71c47e6e620fa024c9ab7f2d380faf9304df12e5f140d71ce4f97dcc51170721de7d05b1b6e635f22e24fe3fc6d0eb819019c6010e7764b1cc09075fb6cd764438102c1feb05f4a36a493bfa5ae11574f94f342852ff94484c153301db56cfbf50310f7ff80b956f7af70d10b9d6084ee24029d7ccace69c96781e4bbc69ed7d8a5c9ade058a32e01449ca1ae61cbb8fc1ca4844e3dda71790f9497acc7c77e7117a58faacb0fa9d123f262ac427a6dbb7f41651902d72060cdcaa40df4b23a67094d0a74e0dc94350eb3eed0a11a44aad3f7b8e9c7b54c34f3c0205346d8d0eebd1b2b6155e77c622439f475372775594658f3c01d4565d011032a007706055dfb0b1a2279a050bae062063e6dbfedb829b54460d044721c444bf34b3989fe8649715df34543e7e38d54a30035379c355f8faf5994fe029f951ba75e414d5b7e0de637b25f7e0b0c08a3fc3c574cab785fc3119d640579d3bef9b63d0ae5734adc1bc5d62ed284487ca6b856097ac28915660dd7d2a14043bc0645d8a295d04bd157604e0a1095aaf79d17d40511d010ee04eabf4c9115e8986b2e38cca66019237575a25ea875a35b73da9a78576d5e789f680fcf0527abff6f65550afd60716018f1ebc0aa7a5ea452de88d26a71fa5ba6844606bbca78234a875a127678799f35c5c01799d7f1a578059824eee68815e535155cdb186dd2f539bb46ff9f7b8c9684d851ea8c47439839be5a481fd7b3aee4461c737e54cbd6b6c365f0b3cf8f292f68ea4d563226190e5d3cc5743a9953bc0de3d410f536bef7b0fbe52b14b28f627195e22e24c737b2082d0ec9548beb5983732fb98383fadb95069b66fe370abddac189e9fc0b2facc2c563738c3d7bfaedf01f1166115dffac6f209750fa3845694c85f4f93dca9c517ac279dff18d2e1868a439e8aebcec9f9006b7e5bb71f48f1f0de418e63ec25ba02314b94e3c8b666ca85396d75607024e9333957b37733f4c7b3e2417b7c4a396570dae25ab2259281a0eb26b57c7256f397bfba5e8f88153d469d4ba64ec77ebd7b791060105c78986b43ec2b8a248c7942e8702ada8803f5099db38cba6ef90ebb5759bcc5422ed0afa3b4e64abdc8cded01c4a11c3a7c2173fa1e8f91dff7edcc0c79effd509673dac76a5d5e9e3e80a278a2ec039e716136c0e2059b9088a914681c0398208e13506dd73633e8407bbd3ab8ebece4fe0ca8733062ebae08b84f8703e4c7affdba1236b42d5cfeb4927c94f9ef49488872792e07da5a12247696588a9e98de3773b1aeabc02f70b86ea0eca713e489693d573a986a280fe3c6445f5948707b83aca90314bfe9c24d43ac431d49a250552b75af87292adbff377b7d3e4c06c7446599fb0e1a3c6132a1c6da588e5854a4ea40e8b91b6424e582687aa70a9468a7ebc66281fca02da35f10b406711f260a963227da7aecd333ad3a61698898cea2959e07f8f60d16ce0d2b9eba348eaed129745685a0927542a712558e49864863f1ad8bbf8908c5af121e8b73d94def6e47761de3e2a01310f569d433bd64b625ef9d1e28dd92f47b7333b97beefb07cda18ba330c9ad1882ee3d5d032f2a8c64d5a2bcf59e620e645ef398fd271aa1ac739a05a9ea1cb6bf77bfb7a762d486e7396769575c371701869cdca09bc89072c8cf690516b7ab64bcbceefe315c39c075ba317fbe1187d1d988f23b0bb975dcce588b4e231132d17867a7c075d02c1b9507c1653938b69c2b4f8d5c68a150c0a676a49f4392ae6d2d88f413bbbec4865fb6db38a85aff7261d2fae2d23bb37fa51e8dfcdf1fc930b82420b7c48e5f8256c9acd9649ba790136156ce9e54df6b058f215c146e7ac9ee810bab8dd875ee9874e517edb26aa321846740260f8a526b9c59acf70f5e5eb00aed3ad21e9faf6f7cd53a48077f54e00ec630618fc9b9c5da22d222656a691b6c493c407c5cee27d20cd6c69cacf9cfce044c35cb41d7863329b8edca7b225fcc4c25f97a82c42a77448d288d2db785dff609d871926eaf6c6a03442945fe0aa707413006be01374e85a05ee387458b913c426fb6b421b0b08fafec575a5ec962443f9f7cdc8bf62a30003b12ea2a828c403322fb74a3f837409e8bd68e5e75a396fb5576e2bb76576d77b5fd08413830e304babbb46afc542a349f739ec42a53d561bfe547360319fb52702888a52cff7ac03e1707064d3b341408ebaa3a5dce42dd1cea5a3597d59636a51e4523af32795b9e59a6c761fdfee2bba4dee4c6e5c64eec2b77d8193061c693647f02103b5373148fcbea10efd525a002a1c6932735dfd41ac154a186a4f8a1078d59d7e7818cfe88cfcaf975887da3eda1906e8996578d85e76de061dc4dee24437d4fa7e5dda03a12188bec48d2b0d89d927eeba990dcb82e3c1eae7d44c700db70c4223d4742398a8ce9243ebb77b9f4ea0375c57ea0752076eaca7d035965854c5dcf2e77c1fa755f90e43b37fdc6059dff66f4d020beeef3119bd594e009a53ffe5d161c5c0d7fb78ad3e1eee41167ceed6ce3d600d1513860f5a85bf804cc67bb47315d7bd58c37642b89ea26cd4b054c47f31be770a6eea8aacf6e68fbf2405e09b78429ff8240af3329d262dea63e784e05d93d04f25c9fde29d0eda6c98646cc8786da3972041549ed8e1f57e1c60e1c3b242e821f6ae055e4ebf199c3932c69b7f8659ed3c0307bf16e8d14dd9c1389dd53fac4f758e515d48949263899774ede95670bc20eb4495b7417931b66e8d8a685d6d374e642948011999f5fdcebd03cd98b59d08316e5b2228742d8560327f8a5a6da4f04465d1ff7afa9fab8ff6a2fc3f59629868a2146921a4e6a1b0b5ab46e493fa542fa7da25166a0a1bb77dc003738a0529ccf49832689d0e33eee32e4dbb3875063d5e28df00862bebfffe15c298b6b22d6707a4b8756ee103967b26b1fd7d9e00b41f07701fa30b5f16c26bfe94c5931d8d7f505fe285c3b7b12871bc5d8ded208fa63e355acef90954741e43b5214a16a29f611a8220c9618e8843256654dc2214af08e6dfd27dbce3a8d627f96a493eddb8976598ac5e2e5011383e120c9067dd82c5dce0c042e00ea14fddfda084619f2e14d4cfabfb7514ced46dc2a3b70f421a774e546ffca57db54fb8c4976797184fc244a8c8054556acdac7f2bdb9d3c493fc6e33825ff70ca19e2e34a43ab3dbcfc05f87e01883b989dba91f8bc39520a1bc39c6d34b3c624804d8a70222882aa7d85136c403c787357ae9213f13f69a526fed1369257b3a7ece22c59d38f7c08d378135935d0260db9773c1aaeed5a702289530b2aa2e541a42df11d181184a4dac7f5ceab6e2e56a328064c1c484d608d0cad7b3b06223968e56fd1eb565cae1bad0bde8190e9e6501c671477944901a8fb2b4f8d8e75fcdecad68b7140448d8628f59abfe10fbe7e115c72439d3fa57342740a694a96e45c5307468775b07d28c8e3509b969c8af6fc75fc14c4884aed0291b3668fc2bfccb7e8bc631d7a939dffa3370bf400614ce0dd666050b814cec98c0c3c4595cf792d70e34bea73863e08a1f00eeffebe4ae457c0d924c23a4622be8aa90af3d016ca62c45d8dcf4acb50e1a542ec190d4b0cd309d479d39b558caf3f74edbeeebcadbced32203a10f96be2ff430ac01c0a794a31eb368f585a12ec7b99a2d854e3666c24ba3a51688db9808730c35d226736a25f979f9b5469c68e110f23d34222f0bdb0bd915551e66e990b6ee256485e55a63e57dd3ba44c5d0fb56c2f10de3ba028066379e7a3795f781fc18eb8ece2c29fbb3fe2d2c00701985d6834ef47179fec2aa1f6b210dfe6d3c905f0dac3a58f5c331ab7a9fb328de2747231801df34b3d4cfbc4910aba21eb724df530274cbfa14071e6c3a2f6ac3921a776d69f6b1af83e01bef7eb16feb137de63b38c1d4e53639bfb5f9e35605f51d3c15a946ead7ffabbc761768f0c799e90d09f5b48bdc6a22ce6e160c9b796299ab94370c49524f81556772f2e25a4cc33c2174d0c2865d4c29c43e1abec70c98ef1679d65574cb3276dfd65a97657a8dec63c864e3f3a8a23b76e497322d239f5f87aeddfe109a9b96055f9ceead458de0fb9b6589f4e96274631ad04b6b9a78fb45d74798c5b1603fb168941225dcfb98960773b7b1126da49153400fc2de2a52dc26903d8a0241d3d326c91efeb11778da141db1d9a11eb28228cc17bc706b5a1371a6085d003f760691393b5156c2425fc4ecfb2d46d0aca953b98c5ed1430839059239ca7a14411d06dd6b50c1bd19334d9a482840898fa3db0dec428137e80a3c5c53cecbcffe5ca9884d8632f7c445430ca5730bd54310afb79d3c365bbe03d2bc727a85f5f42818a155c6e863109d9b8da38c7ccf52e085842ffaf1e2286c9d320f2d22217d400845aec7d05cc7aead913b6a468617441a5f2f21d8cb2d0aee57be180d899448b0daf18eb56a6f578e4e2cd68ec0036d4f0acd555eec30f021414176c532fba8dc0cc72252a5e777166781cbc3c40d60404bf23590ed5462681541d266e19defa61ab85ff28072ab2ae400bca022949fa893e91b2b162f7bef6229fa9d5aac0278c2ff79b19a24eaef4d3d9cbf04f5776970bf41432579d5053a4f953e43ee960afa0567b6d5c2408dfd604f2efe215e69d399999bddd4dd35e573f39a971291a49bd2678e12c21c04b2d33db5c73e8de1b2799f647be1fe5c20510a084a445a81fc03c941e593dc471985cc3053b49d9b8a176fff563b89585103e4b538f4d9682d27e431fad9fa4df2bd8a9baa2847455ff432751a401da877d82334f476a2e1a3e5a93f610083093731b67d82c98ffdee71f2ec77ad721774ecaef6b42e38eaff9e63de79ed40215ca6f9d9bf81964c5b312d30fdbcac6f322f13e2ab7d6c0f2260b4c6412dde0431f3f923143bae9aad154f54b9dc92cef3749c3605c07942071c92b92bad18088eb9168f71c8c86a9a19bb89ec241bd78f44f6be7ded2c8f6f7d9f15ea1291ebb4cab858965083a7a392f44ebe478f05c7b7200206eb808c3c1045c7587789e8dd3cdf77ab0d995e31cbec91ad79f19487f21a0165d9a2ee2e0ea4fecec0975ded3a23b8fa1803599aedfd76911f535db34aa0e251ca76e47a3ed4af380de3a86c67ad827e22825ac6c04eaee0a9148700276ae8f942ddf7ca5fa7076ce740649506adddc531e98b03c24562c6ecf0af939b3bbcd18d586b1a05f0e11456c2aeb51ca59a37fb7b5add45f3e291d7e2b9013f24255602125dfa19dfed0ee6de636f406709a981e0a076206b0e139d816bc35e69c6b42a9c17df4186c3f25066ab26cab30e469b505f58822cd746c5c24c1ceabfab8f73d58a55263649b2101675260a60a023769ac1f5713f0b65eadef28f24ad2c638a0bfef785354ce7db2713ba64a30eeaba3dc5cb252e6a154114a63e40f93a02ee8a56d2b8adb79af7162de3a5b2fa597181603449853c6a06adf40b76fd0695ea709d6aefda67f19d914ac6b360a7d9a2b8fe3a399d14b2249d8cf46e027dda2b9ee5bd7b109f09dd70e5d4807c6db7c4375e3d5d34209ea834f37c1b38aceb2b287d8eaa6df206b893a05cb43f7aeadd5598b08f9c739007535f88decf4198ea0ca90044dec3d255a93533ad8be9c608ace8bfb67ee6c52b48d3f364871cba39f2cf4ec4cd7f64988ecf324cb95f1baac821e9bc92297b55d2639f10d650e9335e2c27400f6bc03dba6bcfe968617530cbf85e558be2ae0c772811293778b7b888510cf0c250518791e807b48c97b0ac8232e15a291d05152f33d4ea26cb2b2c409cbb2822e914f3f3f1cc09192f677926efe6ac79cfedc4af864f1b14b4e34ccfdfa2456daee48121ab9c76d9c195fc73aa828564ec3c42b13b631a5d5b3f9f6df02a2d61b182d6d60353567f1be9b76b9895ea4a2f8d9bc0950889b49716d528f3fe7423d259d154b4351e84738ab474808f703d60f19a1dfe95b1848752d6c8a780cc07ef144ecf62bad10fdb0db4b7a07ddf6d8d96495a80d2dedecb4f86199158aeb899cb6da685eb54fad4cd083e80d6bb9b7ce0db638bd4a466904d2f28d3c0a787a9749e3114a12c66fe246358ea01573d6aaa06fc504eafcd1b8992806e7d1a867f9a38f86b88f61e15a6d461ad36622a8b9da859d5a25f68402bd9ebe846898d9cce5941759ab54c9c211e27bdb726204937c6025a67bf85fe473dfc693fac201f4058db45a01a0ff55e1d90cc5bdc63c53f8bedadb3c79df9424737c00493cfdc51770d8cd73841566eff97dac2778c9d5c0471bc25633f3423e68840d0c0a55679855b01fc0c4b90adfd4037b20bacb662970a0e6bcd502e7a956f1935b43bee5cc7b1348f6f75e8e6c9565c706ebcc5024fb62aa2b5ddac01e93f48061c9f5bce15a01a4562b30ecc3bf8207f3781eb8fd992b98d1f1794d49818aaf3989051c85e4ac8f4dfda4eab96ca1f866a10512b9890dce1cbea3887e20aac4920b5b67ff5f7dcbe86af6d9d38b3442f89c8efb51f9868c8aece6b31a3d35367a387b3a10ba3f1ac2514a4fad4c31bbaaa017dd307c34cac6b1d5912f5c9ef7df23997a5038c2ab0739a65bfd2ac92e09509a8ec43876ffce405dd140eaf55989e58c92f64846e0fa34d5c700e77e8f478e4b72421d3336bcb8c6d07cf3a0b5e10087451af1ad5498fb70bb99479383569165b382f54c18efe1db0b281ca04625e85c3432233d50ff2bfff9dd1227bcc7f9c28874d5616644c9fd82a1b6ae115f4ddb65113d99688cedb1d142a3343d639c8c522f6089663ebcfc15b36ca45e77503752e34c8ae2a95f5d82da3033d054b0baa67a30d11d2662b6ee5a14d918783b7660be555aaf0f53358e5b4e7289908374197684780ef6f35dd4be85ba60aa9e07cd62360a8f0b94b9cd3821e27b841d3c370855e90d1d3948341356662918e2a1245793203b9803b2e9a6a5afbb1095c9ccf687c48e67cee5e3623e1eb9b91faf991b060141f96b50ba0bd70765eeb5c70ce7ea34b03bf1e4e15a02e950183b0269ba3bd720a1ab9598f6e5e1269e3b138636d6196f1f45df498de81e0c84bf474ab52b68d3ae4a9bf4c3e1499903c3f5d6d5b07ab9ed17f0910698b9ed9a6fabc2198e62ed5a4265c60aacc86968a3d5ed8516fda22ea828d30ea83adccc2198dac4b2bc131f988953e54bf6f21b8933e6e49b3aa6c84190cfaa8965ba2f9321f48b276bbf3f500ea406ff793d8eeaa7b3eb3258fcc201965803719522cbfdc59769d9bc410d11fd85795d6d3f49d4aad6f6d50b9a23ec722b0e075abee08bfc42d64ecb8cd82da376349735ec6308558f9923d74a416eb01e07c596f3640c6b9ae7700f0ca00837b93b91b8358443b349419189523461287f9cbe573f4d79d737ca827d98d6d5aa367674c921a5adf22ac9f28759b24db4edbc06680fcb7e322435ae305b75787fbcc8f87a08b24c9220092e545b6cad8d81abcd5b736c0d1dca45d2edcbe0dbad6981225c6a2a8193bc3bb04b358080995b38f796c54187088c3ae718f112f22e0c7f40e0edf0c0fd1fd1c1ae4e460af195b7326f2a1d334a8b9bd348f06a013ac62d599b98754e2db7206220c0c7d191eedcae25e213986205a78a884efde270dbe022a1c9f42b0644de078ff3da704c78084159f608cf273bc41798d2540ac18622ed52fd0b9c0109cb7816974245f5c0c6e63ba4e66ee3f60281ccbd85d11cb50b53f98c685fbbdbeac67777fd51f0ace2b199fb50ab1b4d395b1ab55243a62612a31dbbfcc7d71ef793d3b2467287bc373cca838e07acc447f7d3d411c403bf3e9f9e110cc8cbaba0bea5ec0d9a947bc07b8260a6bcd0ab9c36311135e472f8c9d4297a58bb75f2db21a439401338d4890873a065582e821b8bc6b04b1b2f697f257ada436445a71a76aa019ee1ead57bc1929f7e0e2f2a53f0b3c79dde6e0e51b0aa0420dc28403579e65fb85f1319be8e388817cf074207d4435adbce8e556943a4a43e338002cf1d72208bc3f4a67de44456c348a56511bb4233b653e6440a7ba88b2dfecbb3643058fcf407e19f9e21e2fd5256b122ff4f0e53bcb59aca15905df636f807ec7dbcd6e6eb9b2a6de7c422853dd5bc5b5b8189744086a094145c5fd21cdc56d3476e8c75ec005ee5cd283297b021d10cd1f1928983b0392bd1122ee15b5cdb973daab70f8ba532bb6821db6912145c4ccab8ed96e66020eab9c75b6d47eedf4fd9fe45e28ec6088d70685c36257205960b9b29acd22e9bdbba93b59ea45870b9032dfb0778d754a6a926fa2eebc48ffab81a45c9b5047acf486e59bb83ac8161f5b799b570e58ec9e3ae65fc90d86256477bca1d2f1565f1c55749599e705b06dda0faf366dd8efb928477320312616b1a73a21f0f1e00b7fb4fe338937b07de89f4368e03a29ad1b28b02d3c7f2cb2f1ca86ae9fbc98cf5099e175abb810e99e1d45e6a439e6e20e739e2e6b91865ec792fc28622b8c915053193cdfc84c163ac9cc064092779b5c9b1e52aa859728b1a8f38e7f35ba964b47fb0ae7209d634722053ec631c6493b35f626370988399b9584af3644e77ed50799dd177b25e0103b222c4c6ebc5628737b65828b30d4504888ba0dea8b5ab6b19b751b26d7c74c8e9a1e124a8ee313dba926ef2dec14a7f3e7cb9dc96d1636d9ca1b4e771eb8a6ac3cfcce7d08839613357c41e6d442d9f5e4b0327b3c781efeda9e0c6f5b0088af569331c1b7723a4bebec742f7d0b5e43dbd83a9c945e95627bf5364a411de732d946a7112c6a7daad12d0eacf2906f26e3a910678b7f8f49d7df38ff4e8d3b30bcffab62dd21faae3ecf7c10c49f8bdfe2adb23ef97198ea36e7512dcc210278c73b38fcc90ae41495e4ace81be7f1fdf0692d5397aa8bb4ee0e4d184210bd35550b524a7429add91924b44032107c62be44f3bf8e48ef61903a054e0153efc6a3513fe816fbd342a2ad87dcbc22df8d62b379b0b63101bed963007fb58f08c800bc4862ff58768846c7266d9ec94ebf6750b1e064b35d138e41558a1bae538254d5ac97686ad914e9598e8e42b57773f8d189b9dd957df58d8a690fef9ce0519fa78e4bd33605fb9de42f861dd51d0fbd1574a7d20ec5cd2306e864b57c169212400e63f67a6bf24be8e4deae728983fd2adc36216d891cb8d14db449a6f6dc1df5d2ae4735ca130ebd68afaae5563534d7958ccf7ba2369948574ff2d0e12d3c4c0306067f01f20e0658691f5323010a36b17399d2caf389d4f1d05f579949444747348bf742cec0f3a5d7429d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
