<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f1a28633115ef58915fc9c5b18ee1941ec00222cde63f845a2dd6eb92e39fb161aa9ecf9d3ac40e56199c8d2321e39837633fe3ce84549543dee020686e89974cf85ed9c913601d7d39049d9d917d7784c3fa50e463df1b9f37713aece51e37a5076f26567941bee5d0d14aacd2110c55ebd75e9b1223057a8851aa1d824e02dfbc60bd3b71273c6d8cc7589414b9e269ad27ac15a305f1385def24dbb52cd29d10385bee37729645e405b6ba04d2a521614005800dcc2dda25b2b69d07032170116bee11dc67a7e5a01b0505c973b0b30c6b130057e11d08b73e75ed77a4a775d4fe1bf8600e1461d8c412f9387f5461f3985fe5d7d66d458df4f8315677f6e3868242f58f89107268d27094ff44aeeaa81044d8bc732465825f84f4a71c156ef4f6a503fee5a360c517a82f6f3cb6b48e18c0db597abd4efcc5b46a2026b3d6164c7312516f2698d946032dce2392dd62f5f399a3d3ae6962d4c697aeeafff64feade42e862bdd117bee3e0d0310dbcf4222f675d6129e3dfeb9fb2564dfae21b5f3338e118b7e7cd036641c424defea88a5c81a8ef76739009577c199f3d62eca4e964d8cf7c30ed49533bb0a1e3a05657fd0ae169fcec87a6a2d6b2e195bdb82bc5a211264610ed2dd93f53e6c86de001c66b5aef412252a8ced229f9f6777c693054e1b82156beced1406aee4d9fdc3abe838b995832e5aa4f717923e2a71cbe44e1f5bd9170c59398949ba65e44ebee5442379e764ab6bb6db9b917dbbc5520a6c28677a04321d65583e91efc8e9de3eda1b360b045deaab9b65795d0a12d5ec4d59260e8c7654c5554aad9d82117bc879f0d216cfaf6570f2c93505a5955e31b9f9686dd7221cb71f1f868cc0ee568e56953e23d4079b9677fc6b2bc48d095c485ac73cbd3b689de1984eed5be44a732ac3eee43ceb70a27030a603d5bbfcc74563e15f886ea5928a7f7b4bbab9e7943d5765d96f9c009f18c3759ec3b98a3a656d68a3bbd737ce67a35be5c2469ce0d7ed6ebb569713d17490ca6dddce381ab5399b761751bc1fee2406fe1e188de26661d3ad56b416c8e29739f078a0caa5bd5be1eb3729f84810ad594de8055c9bca7a5fa35a36782d044ed57fdc0c1d6f3bc945dd8c10ebde071d919dae796ee0a2dd8da683c5f97fd5e7351197cb285083adc646d1987ab4caf4331428a9b9ba59053798b579e96c12ca6fcfe80931486435a06333e73545f6457c0a5c0fa1b8e3b378979ae450e32176adae87eb8cc31606c03528d55a14aa16b1d9f0fd0b93fd5c24982ce33e1c9918dd585ca718da71c39dba0b99d3031168360d7bc57f5ed88c9f33484dbc6f4729cc2e8722dd7c041ca1a3417f6d9caee894060766a1cb30227e102c42bdb8b36fb79a3932a881d363580bc1d443be84c1e7463c23fcfd4478ac40efb327d15796066a256194bd4008b37bce347eab1110de91c1bd7787f6971e4542c6cdb4d74348b9c081b1209bf108adcae52bea0fd138c78d92eacd93a7e8cf1e5098dc68b55e4ae76be9a5e1924ccf56ace22772adde805321f899a56ebf6419fc82457da119d46d962ba82b20b3da90ba34718da263b61a5e95d485735e202c382593a28c0bb3356821dbfd199826f9a12811b61e699f54ebd66c58896af277db6f8f6b8549f59faf3ffc6184415222c64bd935e8c870cd687d30b96d4e0f5539836a5599898f2553977b5a54a59267f3c8fbe0567ab9a31fd405010574c378519c37a31cf1d24a55f83872a0f4bc295db10c2ff47034d35d09d886272af4f619f3b10b652113773c70c93caa72e108fb1f9d6e44fbe2a45c2c2cc789eea6eef222df363525797ba191f13446955d54c20f439e0af6aaeac3d8182ca9363ba63afcdd49cc5677bac12e0ff9dda7362154e07de8379da1d21285978112926764b43cce85d268d8faaa524353a30339878678afb20a788873f3d81ef59d02866130011a617d730970d5338961a8951b6eb293337001324657d57d4ebb79efd4f7db859ad5228ed8a51e00bb3c521d81e56f9bfcd4a6d3e4d55e318f3823615953334b4849928a5ec10515e752c3d55e78656581b7d8af2f7b3ff9c2a4f23a6e7c175f6a3cc8f57e894e87a9e350e70957f6b34e0edceb87a5590678950330749bb96aaff47066c95123a4a5e650b6685e27142f51f1c4b072d41c119737a48c294c538ccab065ed60373e8696aee9f49e5189e99b4ac36578c8ecf9337920165c2411f1b04e5746aa691e0d95a1882e4289eab071d84051f90161664225d0d7e533cc1d9c5cfabe3edde704c2782d5e928cd61d516b5f954c7aa634bc9d303271b0a580f73035a96bba7bdd47a6fca09790350386c64d643b6875ac0f2cf5cd6e7019aca3cdd3b62e59fe9321f5727977c4ddf117da88943b82ffe53b5f7e510a5625d9dd90742af9e5cae9f3a983a04e52f8e5c41c90245dc262f81bf38f9fc7191046a86ac29e20e46e096e6d29b9640034a6c5bf26f74db7a3c940e8157d7864f20404dd2e3f951475d5df490207f3ae977d8f3c866f4a63e4577e480c4ff8a9e6b423776a0ad112cad770cf9bee03ab7393f1d0bac72b7edd176b5b48d9bb6ae513795de809f47098160f752afb891b8eda70ffc33c80c34697f5c482a741238268bbd187820d3644d743c2737d9c350255e08ecaa5d8369fbc2ab6106ebb083c81c14cb69f156fa0c4df17c034cf52e862dce4258ccd012154a3a2f57e8889c6a204e262e242c7a099cf2a708a811d390565dd67a697ea8e90cde2fb05ef88fac421b1c9274b83de999fe0a4804b6798057550291d0f81be84127a505ceab78fb2f154e28c56a6bb0be407540c6885305118a85c4349a4ebe985c9af471c66356b1f3cf83339ad3441015c8cd04dfe77f6f97ad76c68bd2a967fb3cd9c3d5167d60f05679b716e65f79158aa3850c71cb7018380ea6ce934ced8c5cca87e81136d90dda933a58d0ca42ff3ade2e4831024d8ef6a34649bf4bd180b5aed8f910c4635e285fc543e5e85fcdaf180918e24475a88369ed73068d5c8cefb77c74e0b7a2818e2ce557c30495cb8ac8985365ac8a57876d3c30fd3d640af759b63b91df8fff5399b7974423c797f009c3e1e3a0aa94cf8453ed0a86f64392524bd7435c0d44c0cb08859e91f0c552c8cc850b2439f9b1ea357f0652472a673e97d8f152ac04d3e61972f86eb2846286a6ee64a3766a55a16e982ae6d122bcc79f2ca7dee1b61230165faed5f663787aed8d716ba1de8da48f77e6ae0d2edca4b9dcdf61f8cf314cb69a058bf4d46f8235ec3b1ddddd0b4c008916c5ada4e976c8d4e1a4743d3232d80dc865b820756d50f6358df9903891716b7225639c41b87698497f41f1354f2fe28b7a20b8e3e7fc9214ae240b6dbcf6f2e6f1a7be7337edd8305dd7d41f7149a7afe3b55a505caaa7bdd87cf08f1e696b4ad2a9475bd9cd82ed3f9a73306a958b7961ab7fc1a1179c22e519baef29c44d3e6ea87fbb69dd3be44e9e67f3224993f5d8bb57fb110f3bef605a08fa0dd559438012c53251bcf6f6621ce5fbba9ccf2eedd6dd74c03a7eec8deca533ebccc943c037e6df9e93bb25e5789ae6824ea077d52e215010b04f8503d95850ff0298115fd29770b31d36b90190b9adb89d545790bcece4182a813eefb8f87c41f25e28d32c3a51f97e9a51f42e4cc23fc7c79bd57ddbc494496b9995f5461331c0e86c963e8dd9f6bfa064cac2694e57e24ab5e4e1f15d5e9ff20532ebfc64a112aa3a60c53d150303bed382a3657038020dbc6b0b2753b7d80f8f7ee569a1a8700bd1d65959acd53968352d5c4b9c3e9e56a5f275b6724b576613fa233de16ea6e08df049dc57e4024489f5a83cf61729b2c465635b90049dc21ec93b2f32f7f835ebf2f29376bc61e0da8d76dca1c3e5743ca56dcfc66b0ebde76cb9759908c54b616e08a0911653c1970659ae3bf57bc80ab8cfa6cb95012f54923c074c8ba0b762929931697c4e985a46bbc09295e63cbd0c6894819755516ac5c0fa1c1670717fd48a8365c5515e1c9c3234dfa4a4dc6eff84331a97947cbadc5b710792d5ba736582efa049af702b3c8265f65dec4f58b0108da55fd65d914b7d0089ee936813b4f9f1902ca539e3ca236da73f9f1cca6e3c946b2cde4cdd437808ece4e7e22d2239e16eb37d22f13d7af2733b44d619efb8a836f21d47a19d0b8ab1fb111a104ca83337eab7279830919230058eceabe7ecbceeda586fd494cab18f17da6e2cd726f224121579656e5e3ae012357c53cac68fb8737d2c740fe308e94b35311566c3a59a49359c43813503f22f857e267a37a7f7c73238c86977cec942e73421d8322785d4f2eeb248f85113bea6caba53c8f94d6ca048e7ac97036b3d37ce48795688c2582cf2fadbd3553711162d31da5f7baac16bcfd1ebdf537c0afc1f78e54c6a79957ba718eb6d0157800ba62efe1649b397c78eeb924d84af77e577132312762990dfcad1826b77591b59c00c4e5f9dd54d74284904ef808547076bf856780154ef078252486eb1dfba70a272e92dc2a146debc9496fbf388d9358586b0f85fa002a7d6119f3faad244cba51b0884130605173b5aff15f2ab19a0fb2fc1e2b20d2a6e4bb00de3384833384a334d81fd6bcc500f9ab6f1b89ceb4c4d952def1728eb3f2b5e7de239950c2137813a0c7e96387796d9e837d776f78d50ed7d933c61f766598dac6f24e9e5c4a48773fc347f0f21643bfce6a3bab3ca59afa6ae5c18bf495e4916d8a78d04bf9b992b686f3116aa103241e9df193ec18d0815971cf8d90d1416ffb07927fba78980202a7927d65a5179b815a706ce46c861d4687bac36c76d7cf0578717d0fc0e334cd65c1da0a460218151df2e104b5cb1093fd471a63e0b6aaaa76353c8b84aae39c5a7d019c0dd587cb4a70961b521622c6576524db6699591b215d65d3602f561dca724d499c56c909eaa6b9fe637d636e84483621f3dbe6deae7ebea1538d045d081d4081da493be507b9dddf46e07c54cb662913e5128f1440ec16f9e0cba5b9924f2927c08e3dbd546a1d30b3af55046a6fc4fec60fccbd9185072cbef52ce7c83208f1e86169b5a9539dbfd4ff3ecdac6d95fac0bc30a6c8ddff07823b935daff38aa18137a94a5f2e59ceda9cedbc6bb7a18f2065d54c00e0322c14e1eb32fe7bd4140b5ffaeb435550b39ed65f52683dee25dcff8d0d8e2d5a3fe6fa51e44dc0be60db9e34d64cdb64ee577e60539d4d508ea45f970e6be1091c2cb7612e6d604543852042ef55dda1adb2a8427bca57e13727afc77af1763de66b92b3b2f7baee0a1d987fd11091fc3dbdd98b8e9d3334c422ed7d0f6a6f8a657f97f428bf87a25b616bc8ce169be72c0ae10d7641cec718e5d756bbf6e468e11afb2eb16bdcc9e87765f54c7f01430feb92aa087bf8c02039d196e6bb7df4e32415f9a8efe478834b4e5ba9a616e331daaf1d5c66140945bbd0fa8ae2e6ce496b93f5d0c32dc54c428e5b687838b578f79dc4aa7adc7780aead236b5e57ec81a83d21a681d3745ce12d545b9cf3f9e2cbeca3e784d91a4b8bafdb1562103d61fc37923c3344e38c0ea6a829927b0d49c569195489b5d92a188fb0474a83a7eb8d05a657e2c44dcd2bfc35ddcd305b18c8f4829c338efda96e11f589dc1182338d90e1044d787b4b02c7d0c0e13f790cc77d277a3abf516f619e7facdc672cdc225ac04fd3616e7511dfd8552c657e7c5090c2ad35a5ba2ee5193d48fc917ca2b38ecab48a9335b5dfca2e32dc49838138a709918230da20fceacf1213f9fea81075cd31186ae230e54720e9d262d84bbe8f30a6581cdf63149e58e29c98e53542f6a1fb6109cb8264848b0a002868cab150a0f44c10c6d46b83c06c68b9991fcd0fb3171bd74829bdc9efe81e69bf0597a8ea1f784e594922982f9dd789bf636dc4090043b266be1499934bae4b3f70125cb93554dc3c0a3dd00f781905728deec348b73c54d3a204c3089491baa05996b707ca93c6bb12b6b283251b145aa1dbf1393197c05446f2e338b357b7b61430d2ba71f16e6df675edc1f0ce445ee6e6a054deec8fb00ab4409c1c1f259011274e4e4b776d81c70e343382c7407b5c9affd3646a692215b517e969ea3b0e73e3f4346796b849bddd82bd709197136f2a0aeee57bd85228828ba7b178686e2761f0f222d387b9d005e874d97f3036f0b4df3782eabd429024fcd1706800c068ebf0b95f0e6b440ccc98acc9c03fba3e195a3baa4877728d66853f44c7326c1aeaa7b271ae1548586c6f60f5123e96eac95b58dcac80fd15a00a74618a133e2ea43fc4e9c46be69a5545e9b50b6058d85f97d149169097ca7124a34f34e52530cb28d00f240d3faf4afb6d168c5d4b6683a4c7c7db63acc1cf8b7c3b13c4c150275511f9026dd7414910ff38d0383ab07506bb854aaaea1d1b8a18aa6db5dfae2255a64a03bfe1b7f9737b40fd0225caad6b259bdf955fc04ab87c20e060c1f88aff404ca07dced1ed2790922ef70638dc0be0fb71e9e9ab63eeb4225306348cd2ed5a85215c666f9b5bc8574821016feb4630cbd566256f20efff334df8487bb4df149233fcf900dccd0d8b5cab52b7a14c97003e743889ad2705230eeaad73a3c8d2bffafc4813fb3738c708c8867ebadd73cf1cfe0623c02d0aff46d2ea41d8f2e7ae9453c1c1a6445f7c1d26029395386c2ca9bb8554fd179c3996c57972eb3f29a7bd94a4c938fd9588ade46dd920c44c46847b5c8b2b4aef7fa29b2c03b1423ec7c0fb1b759b1792afc590bff76ef406f1d26dd14525c772634e6bb44d482eddaeb3b4bf1d6a83e0dae49224978411b6bacf4174fa14cbec7a6558596063accaaaa806c0edf1afe988af95f6ebbc3702b1d54661d1ec7cbab20c1563df8d67995020f710fc5e51f20897b2dbccf148a53205706d9e164eeabb7794e2fce3e66867e0f0fb04b0f4cba9379bf63739e2e785864733a41274f954aac526c6388e07b78540c1c7ae20d90826ad8d42db7254c12de002ac134bf9db57d19b7f7685dae797f6f556dfa74eb66c2f85d4da7168bcf5595250f09dfa8f7e892d5ac1d9d3d4697f81ba3e0689e5fc273135e09b0988997f31bf58aa2a533a235c0052c55fb2f81c6723ddb95849d01f32957733ad2eb53884b999f7f5c19d7e6759ea30d916b5947fadf852319731ba639113e45aaee33e264cc7ddeccad4e73f989d25873527d505ab198052800f04c9c305787dfce8205e585e531ca36ebbd8c4ec25e86c2c230e25c5f4cfa18f6273ca932b8705d21a7b088fa20eb86b4ffd13eb5c680cf35eea7daa7c7d5c8ea772b04937d453da969880422995fc9deea54a85eeadeaa2fbf23447c51eebd93e9066281f398ccf13c9c4deace99e1b47b36110f3426cd7a7f5725486a503a229dac60a12928aeb004e22a470e0e3719acbd04fd0beefdb3dddec2599251adbc884b03957f43207d98ea83b1a29941bc1d07cd1261783bc9bad29d7d81f2fcb4d73fbed18e85a441b0371b5ac8a9bf40da0232823999d34d19c953b3aaf25ad52d14ee800b309768a14f19963db4abd8e049d75ed17b3006cd695649c5c12a59cdc9264858edb50bf57b2eeee79d64bb22c74c632b319ca27c21d5a2bc4ffa9baf6f8e51ef63af1ca71ed84df2b4415cf01d3e64c7602f87f8ec2bf9fe5bda3e07b2926a9d102effe1e4523426065973eeecbbfab1a89144a23232ccb417d30b4821c07bd6ea5161b55356dc68163143fca83f3340549d4e92671c480760c32f4e5c6b5d74037200dc5ce8fc1f18195f6ed7ee5e221b397d5c754a3a9e5da1181e4e151d4070fee6b11c70fc2d29be674fb6f95b1f166cbabce32a6b06e05e501b9701dcdabd32ebd26f902211223003c2f389eec030e6bd66ff45ae212863f160ddbaa763d89bf796be2572042e2b71f5cac60ca2971c0d7b67eb0e19c904ca98591100107b65670dadf6f0535af2baf2edb5538819f947ce3ae22527c62e07fa17baa31e95420f99a3b1f61512e1b4f006e614ae7b806148b1f2d99c375551b71604685bc64b8d94cb3a86042dbab976035c5f1a28073ccf08fa71648b03d050dd3ba19ed999b6f0317716a748e04ef082616062ac1d6d96e44b22518e827649a01000d732c04764f4c199922c13b947161dab111aef31e98c44382513674611c2da9b4e13fcba28ed0f79d0264c6af91aae4cfcc5f05834b78f44a3dd7cba6601e85cb89346f3cb70f6e0ebac119d3a7aa53d0074388ce58120945a0ae8f05050cd26502b154b5ed7d8601a85ebc404fe8dca22c3945cf3f7f732b5ea5c429e8bb5831a51da5fd81e43573215a3e11bdcc539a5b2e4ef6daa377a463c900c177143bbd9abfab5756d80bf80d8827f7ce5855934c0e4bb7b5b677880b2f87c1362ea8041abc43d9b6a930f3fc9e35699eb6cbd5553c057cfec28b01852def157fd952c0186ba42b6e4a8fd6efcba334b7e11af3d92896a0213d688e06e77969bbc177ecfad2e31f0d1f9692f4845c34aa9027dd9ac0bb318c5feff027a9b1109ed34fe5aff60e621452dfb84d4212cdba4dd052a06a77c38275d2a5106885cd769946edd84ce850b44f255d68475156dfa4f440bb3486a772a615fb4b5e87ec8634636750873add204d6e696f701dac9fcab98e81d2badc77b9d00307328d30ebf344bbbe1b4f9b62cad1c0a7157b7d5700aa7ffb0be278486b628f2fd5d772493f8a1125a6126d600a2e2e7cbd5fc66aee147696fcca0fb4864fc294caa94a85f84c7c79d75ac4627e6962ed5b4a8e6d234ac0f0a8c3eba36ff478ff2dd77415894442b44c34e1a0f31f853c450d917e1236961a2669085d8b91d5eef31c5c1fc3e6480bac9018f1198695f19f2f306ee695085290192bf755e3d162cd46b3aba82623dbe1d390d4625f89415df897afa8415aed12f84ee0899672ed6ffb321f207d1c29c0dfa41fabac8ddb7f188e14728c11e32cda82c7bd16b36450e99f7c0c2edb3374e9a84505d2c6739e09f626add8b3a875536a4485bef78293e490eec8988b73139f73fc8795f4c39d42274f6382da0e390345fda71f6fe9744352c03da7e5f9a64183b1d7b505e0112d4a9e22852aac072b39f1f23f56b81a136eb0917402c82972845ed6df21c421fc5675d8fec8310c66fb9b8ff6daadf2755bd267f4212125e3c9cecb975c055b908a9b48c001076c2133814e16cba50a85c6aafbc0cd235648c78c6e5a4d01bd26482738243fdc9ab7eb468c9e087e9d3b9eb3dfc7931f52e13273d1ad83b7323044f8113106d5a3946a5e155fb96b2849c5430ab26c490b8b953c7a45f08f4559b4caf39fc44bfa70daf625a683f36ea02f4ec38447994d64f9e05eccaca140c0366a1eee1dc344d906526b2f65a7317daf57bbe6b269dbc9cea69a3e2cdad55b13a01c41aa769bc9731bcf9b7f0f88936c9faec03412622f517054d3bcdf8508185e16bb0d413d93de97182c56dabd9517ebba74599d62a5d74ad68b5c0977540f5ee1a6e86e12ce030c92507c411b0df75aba68bfd058d63332c69767939bb5f21b9b0ba1b94907499601f6e686f65280122fd89388dc469215931610b8f42382a24dccf90f6a83662572ef543f5877f24abdf85962439f3410440d6717d9302ce3979ad3eb1c6bca61b4a0fcae6a7e17aca854e0f9f7062e3b201e7c36f2c6d641377f781c0ce8d5d5287fe36b3846aacf876efb9488860f9be19f7409ea0a5b6972ca7f07e1c25244283a7785ba5f1193d7ff30d07a5f05a22b8673a4ea70e64e8480198f81e455ee3ff878f23a463528728ab4fcf2953395b9316e7a00f12243ab860152e69075d8251ef9444dbb0f0671105d4fb3d88557fcd7111377b518e06b299fcb9b8cfc3b4e09307236671050ed549a544b6ba9b705f502b62c9f6524cc7e6933a34f4b2bcd38c22590dc3ada17e87a565a030d72b1645789aac8cdfee5749877d10a17513f0fea1d4622744ff046aadef6dc0ca27b1189bd1194d2602b9a86e7dd8f14fb30704c1fca36833769255f4a5b4a82f6fa00f8d36bc2e94797f284047d6a4890e6faa92a6f29604c3c12f65928848f9ff4d59645fb199d96b62ec82d6a990281bed0a6a0f698956d54532c06367c8d6763fe9fd242a0ab867f47bdb1019905bea834ed32a29efe2abfc47c9f1deecbf7347f3734c114398c3bfc1cdf3c27ddfb34feea193e63a6ac1f65bcd51153ae9d04a4cd65fbe20bd03668eb16845c310bac557ddffe655cc1d16cccaf8a8c0a70ca1debba3b2d1f68a6fdaeb677833d4e786f4865164cd7967b2e6ce6d5f9d3b441938db94760fbfc2cbd4c7b1ba9dc3f3f2a87b2e73d58a3263088384db0ba12732fedbb9dd75f415cd80b18cc65c1337521a5d90c09b97fc77feaaf9e852a9bcb82ee0c46a985e879c2f1ff701b85bec2f81f9e1a45cc864fa1e664159bcc137b72091b9e785b8ca796bbfbba7625b115ece4f999d0bb27ddc70acbb2c9f17797d51b3ef9de49e99519f70b20face63428a9918b75ae20cc9dc702488f88e33f11d05dd2f603380e63cb86a81fac6f7ce0bd8a13cb4e3dcbdfd107160399040513ebf6caf2db9e39b863bd9bd08361f714e0f7896ed60534cc2a4860dd487bdd39137b911b9ea6341771ebeb3c4085c44a193cb9bee9bd4185b34d556ead05af25ca15c7af7948f3cfad5e176aa2734994606b66df86fe7fa3cf58c1b0100b413c85c2ea8fba1e566c363cb9874c64c9987c7eecf141372a365f26380148f9604f445897a7b58d46c0482a15d62677617e4d050808b35fb36579e4e88d99aebbd6496e28a7d3f35a5f4d562148640a4f9009a6b60cb1325e7f48c1b54c8b8b28d59ecac5952daef5bc528110079c46922366633a2e3d38cad452905817ea42dec6ca1287d7854175492ccc4004c8668a2d81a667f7fb4b73e1493de22443b21a083ee930a286f4c88371a8838b199f7e18ccd029125b6d876e2061f9eaab6e6b8c65a51f076137888424beaed6f74ee2d9a42139957967613ca2f6404602b8fc99c542ad3945a32c5ef3e9fddb148bf6d1cc9ed990449317e0935b01db94ef76daf44b88ac1bb3917d7d0447754208690e4a3aecee7f8a3d744b327208c1baf8c35548c877903d661d6e2a9615b4185560003a044178700474732fe3dfac5770c84b8d25b152b1c8a3fb14e6fdadae2191fee16f4352e5986931ff664fa4f2747fd98d83c69d1219efacd2c7862c3670693b49296059af5c9cec93c772070c904f46ab2316d911c90f759f283602736b99ebd334bb58295b29ebd52e32e09d91ea9206a8b60d9a2ec4a3b3d0ecb18bc6449004f9deb62b597eacdcf73e7a9536099a0a697cccb91fe16f90fdebb256668fe039d5b945cbfa3ca030c39c6e4c757ba5bd7e299ed08a525c2471fafd483074e619965b68f2596051b32c49a9d5e2b336084b6833205b55bc2656e8e173855332906661ca8ac4c50aeb6ba9b0eb538f14c32472b3c9cb2b5c172deb53aa83b7b5145674b159b75c4e82e7bb766a289b0c3fa05936d26485e73bd92103434900c7cc0eb820483d7f6b5dfcfd49c60437d180c7c86eabca5ce2b890827747245cc755aada6c3e35985d147845009d1da0584b2e2cce0235de003fa3420a24dba8c69795cef5ccd0bbbeef1d20b0090f6a22e57f7eae6516bd01bb0295f5e960d295c10ea12d95004e90481b7da4da9712aac41655514a888b5b14274c1e0ae712a8804311e676d0b95e407fc0a10243d80308eb73acb9b14645f88743c0205fa68d509b1836c68e0e92ab9043dce524d367668808410c31d81780a0ec699a97ab5f40122208f4b3ac7ea22cf4132fc5a739cd1d5656988bde4a163bfa626b11a95cbaa16a27a4660d8d6ae37875cdb3ffbc3f046c05ca4aee77099a0778f5a9f874edff3e9949e7ced22a0ccd63c9b8ace8c5a42746a63c1f8705f3ce80ba0e8ee04abeb8594c96475a842cacf8764a6883635399ef0fad8860f20b4cfca010a9aad0441fccd2aaf0a62fe5a0ab6a416124ffbe352baa6a3c5b3f84d8d0177f5f545a7826539457e66d0e668f313938528443feca6112fb1d910c5b211beac2fb9145957750afd75b97e5d99cf76e71f3797abaa57efe029baf4c7aa9ef6ddc925b8f58a8a0e6330e43c23a354d4f40f83ac0ab9baea5c1c085f9ee0f1f3771348e64890b7d0c645f108e6db171c6afd62fbbcc3438976a490ce2db0835ec5b9f32e6ead973c40f28cec7145ac1184b1e93dc64dd0957c77eb9f670cb91a55fdfcf1ee6ceeaab315b7fabd74694ad920234fbc480841bf4f96d163109c00186786e98e140ae6e93935dadaf0bf89140e1fb7df1b491398b62f6fc4b14f9c199602a5b0a6d476684dcc5701b3066406a373964418607ebfdcd7b46ed61c9ed74b270b73c7b9923c1e4912e998b7ec6462502e5271c43e29d36f3b53934028c4ae4231e77ff6dcb2d8c5def6f39feb90557ffbf9fa824ab2c491eb68880a6d2d4c8db17ea5150cf8bc13895516bd8ccd6f4ea13603ec3f052b432c49c73f8df9d50ca36c9ab8656b39792b2fbd159546aa01f2a70f9ea16afa205619b13fea1df59ffa8baac0b381c77a2d4825532231d5d51204a2b306d44293f019b1c43af7c3415d8cf52bda392b2b1dfa0b728a34d8efbe60651a0e448f1158f7d3412d97f64b9a968843357af0c16ed1b64ac5ad5ba0d0a7c99b6caa673a3f58c105c178b2475ef9cccfa66071be9882c5985b97126926195a72ca1e72d6f817e72008959131bdb9776771b44fa92df1646d6171acd59c0de36a9063143cf46ff5f737432b726800678cef7ff30250eceff5b2fe3fb0ca352955211f1e0505a417d41d82d9fa621493dedb18d6cae279934a91af6309b51034d60d5d2271e27177637846fa27d50289961d153ae01eb4358258b543d55195b277197bdb87fb923688baf976920009b962bf625806c9faea606852e69aafd94d444e0848fe0e6bca9a3c44e6c17f8eeb2cd8d30710c619df55fbfeed3a2e4844c81b75ce514cf29873ecb5a82a8c3c9930b04fec7ea10367a2c3df96c347209124305ee25465732db8037d336a10c784bc2b80b8db688a6118d56328378876409c8bca51038b3971f8d6a6b74ba9b8b6c3053945dd1889ae597041a3172bac81603779f76f7e4ccd62f3ae01a7506707240a1360d97a4a7ce0d033f06cc37e9b6543ec699d5e25b54edd6472c3bb7cb49d08811c072dffc371b0e856d8c61910274b9f197221536d0f6330e38f79733ffce5a90034aa8c6ebe1868da2f6f463d0a2e77e57e82d94e2428c055a5f676edb527807f59b3ae0b03ead43af429064044c3c2fb1d0e9ec9f576a5ae770b874bfbf8fa315cba2a0ad8227e7bc8b4461daf8d38167f7a87f80f6f4420e33bb046bba4f3dd254e8ccb630b3a6c30b46d0c2d9d79bd9516196030126631bb9a13de7142b7342d594b748048cbc72729c6d3051fa5fb2418e261fd817a816a40ce27ec8487e7ff778114f49f96adf7dfeb0045693e2d1ce1dd12c9ce18792f24108c8324ac0439a51e7f72e0463950d49ee5b9963eccf9180678405f39be2c97149bd6492d2b1c83582847ef111725dfd0d08aa9d14c621d19b8f6dff451930006e55d39f67d26a51390e5457b1ae0148ba503c740f975cf888a89e78db1e9ad3958b3c563939aacf5af45c65be8a0b7c9bafc8bfd4ee1db7b00788a88172de62977f3a351d8ea801b8c0ce494d4023e82d48476641432db0bceb0b2529b7f154d3996cd94fc599a01d52a722394e4b9b567ffbb38cd4d6c3fa2af57fbc07d41dba51e3961919bd0ccbec3a2bc83f90ac7d10188f5ba0af3d106cdb6b25c6e5aaa67bd3527b0877e806849b246b9fe65888c470f4c680835df30398efddc1879edf3783155a92871ddaa1fe4969fbd7fef9ecfa45ce31408cca6249bb2e9d7a72b92f45e4b704466f53878fb4f5bb84b6329f15f9fb74e24910a95256c04b01dcd25d991d487d629cfa664757e6edd91798e7d7700e9fa7d7032973b5937e225acc2040ebaf6995ef0bee8dce827477873c1bff304ef6d088307dc67999599b6260afbc8e73e3ac78875d3aaff1164aa386baa43b1fcc32f6b33e0179cc5bad3bcceb024e6490e9ae6fcc933fe4f104966d8fae3bedcf08e47023b2c95f13533d5825d055891aec6934deef9c1bc72182cd5db9125a0be9deb830b59ec0a9671f0c1c6ab5ef177dfc5cce39a42b38d885f499e319cd1b3b59a9100d5d456edb3dfe89f330c151bb1b800c2836938ff300f1adf3d6d6848f4261efd12915e0848cb646e4871b41ec8b6f41136877045f3f8a0906b61feee3ce5a7d6454dd929127c77fe62eadc152a1401c50b06fd47741186ecdbbe68e19f7cc8ad1b99f43ed1f5000f7d804c6d1da1142d9c4674e0dbbb8995b34d250307f159aabb2c556df69690de60a029dc2aab5935545b940073515ea985fb95c6d1f2a2fe7818bf1e067ac7c0980eec10e90764a7391dd12a3fca056e71a6316af20469432491cec32aab6277c73e06734189dfb78b3d57f856867e652f26a71e528fcf9d29562a9737a81c30786ec731a31c4da3092c4de4fcd2095f8bcbbf9872862b849588816f0fa73b5cb5f07be3ff75c155a6e8d7b25122d02026cec40a7c19ead5cd20558e74f0d83fb46189510900dcfdc47fdce8eda7b1b99d99ab363c50ea8abd9c0bda7cc25a910bc0393d60885aeca615484b87e7fee0dae499417653b1c4d688f0940e94cad026cccb4963950fe438947b00e44318c628a65ae891e14085c69c24c4cbf96d362495f6f716abf488b84d66b8beec4b86f182e080b439405fc4e3ca18fa101f5a9f34ac803c6ede03201a50338d0b4091b266b57307840c4fa8e63342c91a11878d597dcfc9520894c7b98c88671b180b89b14c85e0c3b798c0eadd1e37be66151a1c62b5d8048d0b40708919a38d7b92162ca81f13103b3903e5e68bab8bd52bfee20db17a8f4a9d5f654db63d73b73bc60cebc1831faf29818bfb3f6a1067956bc65d3c92567a05a9fe8e23d22de7bc04b20b8ad8031a18adcc620f8e8dba5e70d17cbf2855a548b99eb4a093d2b0d3b1d1c18ae870cb0345aceb1e021f6ce462ce38dfa564dda960a8811afb3b376b7f1bb4af73bdfbbc18c873b4acdc1f9eb886382d11e52734eda746023cec482a29d4f5c9323d14f04a1288769038b75ac9d07c030cd8cc347ddf85de029a709dbc1626e0444d3fca1ebef7039ea70a6ef0a093de8eaadf63da99761e6868c9bd8f15753f01ac156d52a5168fca7150c5f78642c4f5247ea1f45d53bf42e626ead93fdb369a25f46216a98029b68ffd2e0823de819a521083bedf0e202d0bbdc65d40e9528716b6a93d8c6770538296e53e89144d6df176b9d1057def53823678bb1bde64a308eeaa8e4c59332378800f6e479e0ec68199010cd31668bd7d534e93f5bd19b6fbfcbb7e1b6cc5e6e8ac31b7c4df5796a299be91dba4482d22b40c73789d6219f8240567ee0b939f35c511ea35fe7db30722048f2bf92776aaef5c0f3936e4b6e9dc3d185b306f60dae37ae55e08006fc8cc540d8724e6d08da4733efa35eb8986e2b7943052e3b8d80696ce39b5bf0a8c346065f85ec3ffcc42faef7492bcf746ab63538cdeb0b3052ad772c36b852d31f950280e693d3ee43d2ed2ac0e26faf2cde8d5ed378306cae746903bd3c054a9a0f5b8981902feb3acca42fb81ffd25b02658d70e70a166007ae4c271c6da1be01bc9b892656289a26c23b9ed7e2870290ef4e26ce899dfbad2fb22c55a1fddce7ce8bb7a716fcf3c4b64bc9ec27142d68c7dae2a4db8b742a283c315a6aeccfd5b852df8f11912e92d6cc19e5e77e6fe282049a3dee43de33ec32addd48b98ed20be4439a2ec082f89d0c297397dca772d7ed400ea85a595cfdc9d05ea72d4273b5410f2c87797429cc902c64c458b46eab729b464abfef482aec5061bbd9d5c623cb07941ebb2bcac231af40cfca7c0411b6c863f963524c05aaecc0a6a32b4f2b2379bf0828679f2d4895ec993c6f4c5d5b6c7031ee6c950eda8c5eb80d6c7707063f998b98a5994862a2d1096d96541d9411d579e488822f728616f810a1ceb0a3c0995c5f003130598423ef2e524e701bbab317ec07fd9b9028ea93e4f7eab8c2ee5cff18a2e1b72fd9de296afd745f58449a6c73088bd937535bbb5772f98e77a7e0028f5774f99334829ce27bd5d32a5f2f125fc83bc70a44b6c546689bf86758c3d0e2918fed7d85256365a3b183d1ba942233ad15dc0e5359d5a1240c9531b805a51df1e7cd50be6bfc85df23074ce68561d6a7eaa5ef12418ec058694eaaca82918c83fe6414cfe11d8fefa57c284e0b946efcefaf1c97da9f6d9dd393ae0dcd483363dd6c31ae39aa80fd4a4415627fd5820d67fb2841842919341b9eddb96243522b1c28337e341621dbad8fcd2d1dc3ac69ebc603108cba0f73e5db20fa1e55e4cfae89b6cc5c22326a420a6b359d274dde1e7caa1e1de606c8e6e756c5684095aa561b10094c5d74f80ee543523151c9f9f36850aebf024b08b98339ff34b80506df07179a70629012af88db374855de61cbcad9796c7c6d38b176ec3dda1accc8fff756929a8123b3e89acd410f9c100e7398a7317434ae294dfd72d72e8907792b21e086ce49a94de2bc8f40d9cbfbfb4cbac66e6f17366c68c4194a064d588e1a839e477224ed6a7d9130e8f4b69a62e3f3d57562d22a70ac0c915f7b82a30bbede47a3238828240fbdb06e8539af8ca4e4b31324745249c876343f6d6c4eae46eafc3448f87006b326619496bf42f90d65d48fd3b34666a4db73d9066349161cc9028201b523713ed0f340dd7fe4298d3bcb00ae78b0db4e13dffd2d694f9c67f74b0f87e78e17756bf10c24b2e0b54e46ff80f24a4e6b136efaf1aec6dfe1c85f5fd70e2a5016f5697a4a7da4dc3d0e40383a36612da4a4c4b4ee57765d929466ed0aec34d2e52b34f2fbc80a93a94b074e191c6496e63696197c143ca70393d803d97657e07775ed3bf09a7d1d786908921b97d0495f4b4e3dae73993243f03582aea07297372c36680356f93c8ce398437803fe7761ec0fce34c3a709f60bbfec87510bdaa4bf36e8b8d3cac2d549b8d1110245a148fdb47eca86ea05620513518111c9f84debbf97eaaced28bf1619004bbce5fc22da3062d7e443bfef447b4a50f6489bd544180c7d6ff87bcb70a88ab1e5761080df1c1e93b385da8c9530b787dc93bdb5fa08bf4aaa880caab8b698c07a33fe0cb47dfedae2d7cc8e23e342509663586103acbe81eccdcd4cdde44081b9f330737ccf1fd0dfe95d44fcdf6a8732c0080627fecc40b3b34743b2139508d79ed69fc8244e8e45cb3a0c87d48f20a126cd15598fcfbe15573e5b0746fed7dec40982064045d5ac13597828f7b5c04599d572f1f52b40297db9bd4699749a97322a6da158381918745069f893645db41dcbb4d3d6d97c65d76496fc361e8c447e46b1e439e17378275dfe189a2f700209e42d525b4245a5486a779703dcf88e0a9d2d418dc7640e1f3e7210e5305acc3e13abda0dfb5433aece87f8ff971a5b09361e5ae0c33ed903c6ec58cc6715e2521941070e86f0df2714fd12b2d64caa4bcb4fb62e05ce308efc1b0e31035d86ae7700455fe6c5d29ffe4712316fccb62702691bced9cf9c53573ddd86ceba84b4475354554e5fd05d1f0e441c2f3e32640ea2153ccca2e49b2e6e910e315c9acab922c9845ae67a83fc20e7302d88f6997f5f4264f17206021087d58d1e47ac3dc662c8c104448f53a5830d23d86d8bf94000e8e4f06c3be4a237bda9f16ffb6de7383a10d89fca1b84888f0700e6fa0f6ba4bc5f3de3da142a804091c6a3324c6fd446871bbe45efa415bbb2379f5ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
