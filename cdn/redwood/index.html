<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb3b470cd92b37cebfca8b0b9b797ba847603704e3a242583d006c88173a7d708342e31fec96441ce776c989c032c51baf4ed1aaa763381632672c52d4468337835001382878b11398f17108d2003fa2f50eacebddf8a2387a50419a2ea164a6b48bf25c448bba63e4987061e1b9ee7e1211c49e06069b3dbc4966fd12555102f222efe8190542da68ff26d354311a1f8a734279f09d42a2e20e69b70a05c035431808ff721877092e95c53299f434ab4e01c896cccd9d4147f8078e5123c66d393111c2cd24890e89990903197ecd6f7cfba04be5d061ee41143751fd378b2cb9a5febf20a11aa5ae1552e3e4bd2dd0b6754da203f7d04e2dd3ac604dd1222d8dfdae9d01d286e605464a158cb32ba3863e6f310744087783a61a13fa999d05aab55a8637c3a16c0f7b1353b32f8c4c67d525e6483c507d1b744e3919304fabce2bc5f904b3f30d75b2e3d54862248604b9f1f9c9d9d801c2a0b1420c284a07b05b0e3c4966e89514b141c41a070c6152768aeacb2db2ff8d77193d725ef74b9ba6ed19f83ab3e408a6e22479a17af2da16f1f3bb0761ae81d891bf573e37596cb1ab4393b60409fedfd8966b55659455d430d34e91b9215c8d2df85a052fb4f97ee9177650c133cc449628afc89f3a02fa2c4758f2d2ebf99e6e2019ae306e8e1cbefa5fea52ab379836bcf264698eddbb377c00e7fe4ae3bef723d761a779e4f7d5fac1731c5ccc62d134478b86b93d069fafffdb02a85b5341676826302c55220894ef56e3368b9b4da1c52bb9c4959ce0e881a6bcab0c3a7ecf10f36bf9ef33fa233db6fc9d1c4f5b27134b8259aac787caec64c1a25d3b4439d6758c010ace403b5bc8e767db2bbf8acfc50395bda800f401f588f42673b66c7f2d78c47395a12c64f33ab710795f29406144261feb0aabc9ab34663e870ea88544f123774639b47ead6323ed04a74cbecddce824572dec8df545e74318b4ae58f4848d692573165f7178cf965ed7341b1c57844122e2a397226405912ed63be41a930009f1bb11179cae14e35613b7d857f9953c6c2e580a7eac6c74875c6b8e7c9393177d69fa63c08ee870a2797eb01448e1e8629aec35ef8b369a33858c261a6937fd6fe2f9f249c1ed5929a1769ec28f733cc73f0198649d5dea9952749209531fe22bf15724f6b5cc45c63771a6858e5a9b85347415348559a0a836f4b7ffce1bd7b6867590828adace1426c1075dc1a53c74dba4873db7439ef086bca296cba1ea5c4b11d8af05a5f0b0c7178187386bcfb137e90380e22eccfb2c2adada2293e99d3dac4a5d6209f5c5794b070776c794e442f77191b02614b4fa77d85e30dcf05b5e26ba6e82382b663dbb51d891161ca741b00592d22cb5ab258e536da5c3f6927eb5ef1e56656f94de520883bedeca254d138b83419bbf6428970523ebba93a9f055b6d8d168737eb0270d7a6589d9a860a233768c0779ce697204530c93b3d9ee4756835705e9999b0b182bfa402df4ae854c853c87f2eb4ff7318109fabd408d63a3861139430228c101c54a340c5a3d75ae3a766aa5d9be6f08ebc4d2b7617a655a1472d268fe523395c91b214f9c16e2da5d7763589cf50e3a83478db81f78795abb3afbc0daf91d23d47619c8e56f21b9dfa4ac227bf1f406c0b765bb01842cb77c5897897476e06344ad759cbb1b25d9ec9cc3a52bfa5710b7422db002f4e4df80187404a4ebb212e383a2a74ff82b1224e2f1ce79b766e4f877793d3b8088eeb713554665ac817116f5bd2db33c1d69888e1da5e773e229e345eeb636362082cfc7a743c9343061d720525d98b8a6c44dd6842b7c03831799a8142117cdc6b7dca44afc4b9e32304c6071a217299d7bc53584880d64bbefd09f0e3194bcff74bf22dc82b1d59747bf8a89a7246307a9198b8a2b0a2a7ce85aa5ce6400eaa08a2c2fbd85d1c4f219da4305a982412d472f2c850180e8845ae7ca6c4a5979c7a760630b8b2bf91cdc43db6e306aaafa73a3e9a78ad4cdcec45114ed41c4c733507c2e4dcfc721a65a269db6e4641e16c5a099acc927c462221a83c8033f8b476cae1c7d2f025cdf5a28482ecc87f593c9d176c3d615f30b72184de92ef264cd68fcc0bb3c4c5dc19939df8f135e53e43249b88be16d94c7dda0d4827b70e211bf39a3b99185d24639fee2635453f4950756d389f8da4976ec2b2a934a422e5f7a67fbc5290ce795f5892d256e023f4bc0ed8879a12ace5da1d407ea041c887ce303d8caa0e978948ed2e06e620f87637df8ec0bd8112d2f74c6edb6d290f1b3482b9d4be46e94f652425d1ffc8b221713e6c8fdfa93043d53588ca5d350d140e9cf655495ffa82a5df14d0267e29fe5cff9690c6e42b675f572356c1c0de55835ebcadeecedee45e2000df3edf354e8f72311d8b211a9ad60fb0a04fce9b4c5fd51df9b3b0dbdaa482c0e509c4ae867f773f5b428838014f69284c9c3b80893d73b779959ffa3c57be334d070b693d368db2fa72bdd5e9459ec8029b2f243d64323a8600dfc57b5cfd1ada7f2a76be1d2f8e74dbea0238d4fbb189bd86cfdf1c03567771cef08257277a81496b48ed93dea78f6030930afc72ba2a21024491c19421ec4233f7e10db0d8616329a7a67530c5772be835d8f29e49342325355aa2ee92d049a92489b52a1123f8456c5d3eea5856c87ea50d869e26fcd080cc1c5c09e18c4d2abfae6564ab86dbc9929699dbc0fdaee7fd76310338d09032c6c8c082866ffd068345c95a20aeeabed2beb6ba2c5d3e2ed3e61da2981a10ad7c2226c5ab0d2b14089148bceb7d09ad3434c680913e8533b57d86d98e3f67398d8a2d2141779f04aeda60b3da85de5485e6d60abc92c94a7acd3296dd33fd88823dec67234a2d5a26f92465258937c03ca372985447cdc92ec4184bcc8f03563a979e5dea64188cb689ce3a194098bb3169ad9c3615087f35b5beea915b8f1322bb61daffb41ff57633d73609f35a3a3d06a9a5f2f598784fc94420f5cc70d61ba9152fa834af7b9ec7de355d2e602d5e1d23e68b72c687298a7f940fbb654855617d66b7fefbafc5f0c9025531dab33c71df1a17589cb1b898e7de7e8961145c32003d0410ae864b3039e49103df4218d285868d4358287cfa555ed1496b434e319432975f2a6814ccc24ed04b8ea557b2d949ac82e606682a2476cc975132de80f12d7c89194b48ad468f09944359d0e385f99e99e25ba00b5ed253c2a306002b2d21b3c65e8f05d583f8fa2603052ad06840ef0ee9077d245ffae600d85b7417f406aaa7032d5d10b4be018a650a8330a226a4e991762afe7fe40a539d1f5dadde70a58d76d63a1527446492f9d181d5d53e4e40207338cf7c7c794d57dfb7796ce96fc618adc329f7c91eba1ba131930cd527db78cc05b728357d1cab4051fab39ece25ded60b1a2379a32864c66724597ab3996af1f1191de83433913c59bb3e7d0b843f6d5f89920586bfff6e0d14760fcb57900efe063d523984916833a094e0465b2e4229a6ecb5828ea3bba7cc2290210db36caf415c363ae3ac745698b2ccc3aa87822caaa9792c07a026231ecef40d48bedbc02c3014b8d6063f40faa43f15541dfa4b840c48bffad9bcd44318e5c564cb7e5eb356f1c2400e01f57b42d6efd0fc92eefbbb2379f030563380d3b0b689097badcd7f0a60a4920e03491d86659dd2186c05ed21acf7ce09a81ab6ab1b1d636842de4e39f2a93df6c7047e039bf3929f2349ae40ef166ef659e6ae85b8377773a9c9ebfafb03588de89c15c53d8c4dedf82c9bc918889befa67ac7520d080031f1411c79ac0e5194dea5187e93df818ab4b7f30208146dfe8615a3f713896ccc501b2d728d60a77dd1d2921481cc08fe71e766141da45d4a8adcd64ee8af25c3e34d690fe59be68a445834a16e9a4f6302f95bc8e0854802912b988bcf4ff2111f68c54906eaf885b89ce5153e014dd788bb78d1d8c2b5057bb47cac96121f55a862168d0813d77699be1a1573b1ad3dfcaf7b556999ec41146e02c5573a1f03ddda41cf50b33f973eb9a7b47b2f89a76f95cebd89654a00e25370d9b35d39a73841b98c64c132f1cc762127fde5a89f1793deaab791f5b67dd0885ef841bce11e3987e8f9a61ea0217751db6b577cff63b92f0eb6aa1add2f8680b2ba951bdf9ceecb943e5373138f262f996ee7bded48a68f95944ceccbf901a9a9b20e465e39b442a9ded79df1f80d28921009925551e072a5260cb955199d95c5ec0f31269a71046c3d5b7d58255131d68d86ad70a0a7aac03648ffa9e6d93f00d8deda5726a48dcca74c92fc9dff3e9416dffa66353e258636e750ecb5fcf557976da7a15d52aa81a6ac9a5fa16699430010232c1f57ecabbe0922d1574421723de2f36db5933d1fe8219df14929a59257100f6c46588f26061da4f40a1c619e228f440d86e8ae534c98915197df16e3abc74cbe0d328a6ff6b99cada34f0623139bcd6211c143dea782bb49701afba8265e600c69d0222b2bf732aea1b3ca0b847e1013ddbe9a648e47935d3206e5f4187452361e49daef60514db5416eea26ba825685808fbd689dd563220e157b1a58821488bd300c8c0dd00cf51c44f52cf823390b0a8250ebb1699416313ddaa2e431648b93257544a9c70bdc04cfa03018bd1ececd043941e1b7a20e2df850f3d8058f88be97f95394478265025c678c0c2ac1cbf5566653d2555428f686f34187e1df20e15edd180b7b312bf3bc0207a2ca3c0907ba32cad93ade1374c63db57b8b9932a34c37452844c21989af10bb546caa02fb5ee532dd8efc63fdd17bc96c1987bf7a987e974bcae93b18cbf74468763c2744c3ead43abaeb382758272e11294b0400b025e7e12d3d3cad78949a67dda6fd0b0963f3f3e8b8c06f55e6502738e0bbd9394a9c703225f3ed97edb4326619882e484905541ac7729c8c2d998f57cb685e2f706ed5dc0251d9d11d60423db0d4f05b17816dce9413e793ea9c9f0c526189607e27a828430f7e9a562d8fa7ce4fa27c20414b838ef40ca83542fba6eefcf9e5853bd2596b01b99536a31b757aed1eb8e5a65acdce90ced108533f9da542d6f5b4ff6b92149291c5fcfefb0ff5f5b424c5d403c51e21d6e89974864a71001a6bfc298983f76270e6ebff4b025f654d1c12601646b9ec43768270f87bbc499a1611eb301b611572b370c1727a2fe1b952da44d18bf582f9e2da232cb92557b5dcfd04e847289c43509fc09df4057e0372ebae0bc7596fda9dcfc7a4f602094ebf74e1c3b5ebbdd8ccbe4f3fece0b303dc60a496faf91ce6b694ec4964106656597ed8b2c9d654664bb12919b4967307f531ca8d7926472bafd0f4a7fb5a5ab94d671abbe10ac055e4c9b6df9cd680782cf1ceb9ff892d301c8bf9c570bf649d241876b562f979c222bbf6e53ff6da546da41190e76992e098a9cfcff50361cb44d18bf6c4b9af3a75473df6d18bea9e70a2881ac4c3ef8a1f57d3bf262ca5305a4eb46d1818029d5bf0fa20f3056034f616b71699e54ac0765f7fbf0242aa9b40767d9ba7a19e41135dca43640a8e87fe9679b0c9c095bd7f9e0927fad60889a8abf1150d0c2c02f0906dbbb03ae238b619c5a01c7601fcbf46aa0674491ffa81c8fa5c0f2ff75212039bace8f0a42c05f160153a9ea14ad6775cb5f16e898c8d1446c658cd1ff647ef95c8041a64e34032fe447424db06dd9a38ed18fd3e972a1cf6849ea3b4dbef69308e2d9d3e2ab8108917f60c2b57e3c90d67f92e238caaa9b7d8d79399ff40068e63d0fb21093966315c4c9d5d2fa642861501621bd2cb662116be8796f0ba6cbfe94e7e47e4988f42f85f381920323fd43f6f6c5a186c0f19be09d2ddd577b8e31adf73abbd007ddac369808d60e4d6adb1387997e070fae38530bfc0ad522ed3b27ad626254d8a94f89e469a33b9ebfc1a5c89345db7cf494d3b77c88d0d9ad058e7ea38d4e93286436fdadda1f0186cfc6b5018acd19a82731f97e9a852f6b54105bdd2166dffa88d9989d6b75ed4c42e1c8256e0042aa7c88f1d0f77a2008584dd32091be6096e136279ed2bd6fd9b40495de678125265515f38e1e1ebc8e5f482255312c464a4a37ddc287a0906d66c65912a037398d1820c491cd1200bb6cfff75b0db2109a495b88e00cb578f6631c0f7536b6c5cf2517db42aabddc057b0b771f836f52bea3901091f3c5d634c4416b5c10fd1b2d271ba48017693bb358164a22bfc5c1fcaf1c1ab43ee52dfa93dc1dccb7433a402033fee926a030ce17c4cb38f4781f5ac6a7d3471de98edaa8151eb44fd93290f12dfc690e908b0dff15e2411f9aa19dc27b032eb9226e1c4b8d2a3206384a02b47b90c139f0979f6cd6794db43f914db3d09a89dc656222691bb5e38d0cc32962cc676500942a1cf5b34fcfcaed1113ad7afe783e05759c026df475c985a92ca6526367631a558f6182705fb5587a83739aff9354294f1d8e2624b5f0f136de89ebda96bfbfb1ac5ca00c9e132f72bfaa51d9336056e02bd55cd59a71cbc7d05cf2c4a29de43a3a98fc2912b11c3817cc009d7b951fc6c63ac31c97e31d93a5a49e6c22222da84356b5cbf2c7c4e93acda82bcabe767600f80038850cafb93c088d665190f5f851cc1183268cad7ec7f463eccc7e3ca5459fc2dc0db258030ded3d8b4351c66d8e8aa3e25e2b4355000a99170ee03e6fbcd1351a1b1a88a3935e083c08700690cdf2da3dfb118f126ca605c2c76980de8f500047d23be54c585e5f1f8f319357ffac99dcd254ba84f0d4b9eb60e44f379c4f514e931c261ec4469a7ee8299435beea20e7f3c6d9f2e2f53031c2f35e99c1bdc72f31a93bfd88de212bb6388f0e5f9129da3898211ab78b0c2bde3455564eeb7fe6d18af7ecfd439c4796cb1bf9dae02600e0749fc0c6d82384a5fc9aaa1c4886d512d49b1251e6c3c9f51ab7fda32cc92724705258c3b6a7528db2773a493091d621b6ae08a281e4a8bf887361b2b389fb9742cc7670fe9d97b8b19fe47bda14d22bc186f818c80c40ba7b97e57ef9272eb6a69696a4ce2d1e157c17220e700ff443e884a719e6b6edbbb0a62aa46bfcc60adcaba0988881a54e79bcf6f5175848783133ea77a899b0adf9b3059a67343cb2879fad901af9070c8637abe141502af5eba6b57dc366b378e5e11c2723d8cbe312d9f7d6fb5796b4c9bb6138fc732c5a7ecaf5b7c6e922d2c02b00c17f7fa1c7cea5e7120e22bd22fca97b45699c548572b46ad107aef26ec88a7c36b08b43052884429a1d55154f76c29ac724725c4624e87df915d50727bda4f61493986bdbb623d1f87455de2d0cdcd023958d27cca91db029da81a582fb8cf06df048684f8af01d1881c52903a92ab129ebbc3b7e36b59fe58f23bc0942512c9eac57dc50a25339c2f4d73751202a2aba168158e77eb15ffc8682d552bdea60f07d470e4070cae55cbb766d18cd99849cbb8c8f1cc0d6a312827713fb64f867c48c163206490aa83888e29fec4ab2697b9b289b0d01d36cf767eb879b501e596412e8859f045dd4c422eb79d13dc3d5703fda6a61133b6edcd9288fdbaf826c9ea325bbcba768764d5118d946543b6ae2eacbc660e84123892527dc6d2d347e06240c613f23295656e8afa2555250330ccbdf70a52a90a65561c4b05cc3dce1ccfcc3a143a77a558864d21f7e79e68a42911b41f13c0ae2a3c18ab3e60483a8074d858b3005ca018f871fa5d68ef99ca432052b89ed9670cad8c3da5385be2c7fa932dfa386ecf06cd43426af0d23e702ce02b24a38fd212ee76453f35350e915250a930ad313a10571e01e0e07316e6d269917063dd8bccf804692f5a3ff5842297f09d7460a81c9d57a0f5193dcf23ae0bc21ca51b1b92a757b2e3cac4ff323115b16a17fdefaae52a4c9465533515bbb96d4a5b689fe9f34f62cbd14bb503e68c56d554b6234d54e17dcd63fe775fc3c7dd20eef80968e08f02fa5f4cdd6d2cdf151aeceb915a0838b7af5e4a8e10221b44a77ff761f705a035dda494fce346ed2dc1552163c195ed8b0eeea62dadcac47dc8077b09fe10d01038fa7298d261b04e9a7def8e8bad98ae4b4c4f13e424c1eb9f0d46b199df0f4a564e883cac3049a98c1f84f17179265604b90a861654c33f1a9bdf7f3798659c9fa7e676488ab6113c19b145ee03fcf2df3c667844d53fe55f78f1548723008555bb569c6430fe5d974a4e79266647ce72388680eea44fe0ee687b4dcf1d1e4ed7da715c803af631ae0c94b185cf1fda4e7b6db60863174fd6a65b072ea69f0efc69ef9dbae929a1c7eccfefcc3099c446da78cb3f365710e3dda811e6bf29179f05728b7788573e3534b020ccd4db54ff8d4c9b64add16d8e917a56f9034dfe9ad83698c317a01a90af164f4cd25ade9511925ad101239f793ee1b4fec44b624b7d039efd4528d2acc3d32572bc9324a6024c0242c2c14e3c096d18e73f440bd90a3fc4b77bb85145005a51375870fb4b4b95afb3a91ab4edc2673c55b67b1c0db892ad70ec6126c7baa43c067a0fe5c179b3dd546fd4e68f0d257ac7b194645ce9397c26be20e205fe082031ad18fc3e821253ecd92bb4dfcf9335f65faaf20a905e083c67a3f0207b2bc235c4414fa032fdffb5cbfd1602a292798e07540ecad23bbc51b2370f8fe52a86de7cbfdd118c22af2fd7227c08d23c2de888b7f65f2f433ef52c7d3c70e6f12614a79389af8a08f3eeb4a8bb108d3d34427c9ee03b47ca4949e19bf92b3bd00031331c94a5db4ad62460840d0e821ceef936d16e24434c6b3c588e9a38c014152c52ba24ab88408d2877108a8f5a44caeda4819b615632f5d6c4803a09152e538d2cb9c3016633b4d510f32b7035940e0847d1a150869f8e1ad6a6461f3e33ea6fa40be73c5ea57c1de357712a8a5583f8241599b35feeabdb88f1206f81ba8644ff31ecb1cd0172ebc499479f5647e6c565794f26842101d7ea314dd3350f43f48138a00f6b437ad81ddf72b9fe0ca0cd79793f6a672113004f11745b3e1b8f38fb988206bb036a90a5d23d7f081b5bbc00b208a75d9993c2547331e5acd35eca9fcb37a7bd69ba26a6d609f332f3a7b061844fdf5f1b25108dc7e5bbe3602851dbaff66f98e22ee39dd73488d930bad8334e771c2098dd5cbbed8810e8806234640079ae498e072acb4a1ac07362fe8a172e655f7ed2d5b80ed47d9e2154774c9d0300001c88422dc624824e9b684125ffe4c340e64cab862455ef8f12faad33781992fad314a1827152c567c2e9026ebba66d75cc901d32dd0edcce44a43ca3f62aff2a7bb0eaccb992fbc1143d7cc13dc53cc1979be44fb72287a66d53264255987db3b7d9c298a882dc377f9bbecbd79a61a958a7d00232bdd3df51d3b5d8345363e07b928a51f9f6bf6a60ab5058a18c7884498e4c367f73fed69a1f69af1adc6d6c0a6422988be65a6d51a0827a138c2c56257a8ceb1bfc11e26060f30b52fbd94e11efde73cc4f8c57b5a75954fa8a367a9ddc294a83ed31db7ac16bce6811a0863e508235b502d18188358a5a4af7b567b427837a74924ef4b19bc378337b19e3c91d9c625c74eb26ba5ee59dc8b24c294640e96f80e259f552da989f5e8d2a84de3b4d9d386aa03ac74edd44ad8be5232eda0b935cac5ce23a65437f20ade06494850156b1cfbfba6a5e6ce5d6bcac5560a897b2d4c0743e76be7cece20c07bef0c8f085720c5df55967bce6db12ca8cec7ab38090f60561aec2d7823137206b2149badd98889bda2277499dd702acac030a6ab1d55ca73accd4710dc4c61bffd2a8379a20ffb12194ab492a2c1b8b2673eb24078bf20ad5cbed4125a90f55599b349ae353a28007e8ee6696537e304120e7c397e064c847cb9cdc49684ae49073a386dea93ecbd5406b719704d5b2e065d2441e6e86d2d1a48b9cbf61055d75f9748b4db6992033d9342e0298a2689ad3ebd65a95ae265611c79be5dc623c0cbf243e781882bd9a5e6fb0c595abba721e12a0fc7434f88e7418b3fedce290940ce01b16d5291f26b0e59febdbd2682d1767ffb1dc000e7e4834a2f85d96687a2111173ab6e0d9b7b8f18a043a0508b0eb5f33d9afaa14686f8753034140e73079afd9ff49d9a9f98f467fc1a40cb3c3dadd005031584d2688857275a70eadc10bf2a3de65c2710f563807a94625f89d1437aee259cedb88fcbc61ed22ef04829cd241b436c52dbab979060e00372f8a1a651c5d83d9d4aa566977fa0d636af7c6f263227f09509a647cfc06b7646dfb2eff01408a176d66420c788efefb5f7efe5d5c0b25340963e6c2957bccb4a6f11a1274e7de64be4aab22cf1c92d6871caea7a42002dbcbaf1181e4ac23e0726e780cce181f2cedb839bd7fe664ee95e43d785a5457f0041e7783431cf503cca02091922ea8c1bd047691fc1a13095c626eb9066850d6ffb554bf052738ac073e83b5c9a60ae35d2e01e92f9d359e38ed260af99c54be95062a02d624d8af318b09aadd315f0ecfa4954d0ec83e8925cf81ca6bf78e26bd6a1d7eda095825b107d7b71fd0dc4ffde919e94906bc9e2e8df39e1fd0e897d0266bed4b3b6f86e0c602d03d6ea2c88cf45a6d0d810095d28e6ed421a51633843b15f02379b05f0d5ebdc9f2bc243445ee8ea54dab5b1521f9e52fb2abfcc32249886aba89d2381c0ad2a047fef548abadf28a32a023b8ed491f714e2acc3a1f76b4d44a3396976e8a2788eabdc676db3d65b71211c7dfb6a57136b5bb6940f22005a69d3528b127a13a2ff7dd1059bd00858a2e7bdc7820f9e29619fd446a68de7147b6ce6800f518492dd8ec3e2b8d6280314b179e8dd086544d316b694384f76907b6a6a8f4795fede3fd8249e296f926047885d393cd16bc8850533674e5211859d5f5e9905d71d580bb434feebdd73cb2379caf21c529e500351104da2074f6ba2ac4a1d870d23336cdf60c741fa36b46a859ccbac7f8e627d6215a08c73f8f1775f9e80411b292dc1909605825ed08b448efd6d178678d0b6408b4758e47fbda192cede779e8b561aa0f04cd3f516d4091207dabf4bde6841c76108bd6c7c41dc0349de3d2e30606d78d77247c940be87d00683c4c6c611fbe84d0b35f7ebc704a43873a9d7d2c828797f65de6a57dc7cd47a7bad6879645b8ef7e397245ce37e34ce45339be180d52aca264e7e2dd99e6ec837f95c88ccc408d7cfaa5f29ee78de8509d4ab6c92ce1481d6e28a6df4a90a37a178a8f9258337e9a551c5ba52d52810fce68d81076c0db8feb654545c22ddbd8914f9d957ab547bf674c4651d29dc9dbfbf9c1a38f40415963573d4a232492f989ccd3846826f845d7bbc5d91f13ec4cf224d200378f6fa951afa8615aaa4f2973b93e13d71a99b0da89849a8cee14634f50b5862cd246f4503ccf99ae53be05e726dcc179855fd186a1e38c3f885a655676f6899fdc42c51fabb0d52c8fb57188cbd55fdfc44baeb95f53b06a843f440e47580bcb99d006e0d134ba1e9722383f61e12f60eb7d2d305fd93fff93ea43cde0a06d6acf92efcb38daeef274c9ac972b4bebe4de72cea745cb0c70eb357054a94f2d3aa3689db9af4792bf3f0551c1cb3d7f21b1746b198d153d3911c02e2b222687d664892bd90807f3b90a6645facf025fa8835d3ee5aaa06c190da6aca882a7233ff0f9fd47f468471291c34754aece074ba9f9d97faea97759287e32e6bbc4915380ac34e6f9330889a9b1588507586d2ad4c3266afe358aede6d9f425afbac3d6ca06ce02eb7b7f6cd9af73a59d8983a4b98909470b366be4617534f70e3bc010e74840773b5ec5cc168d1fc807dc422730bf9ce285f70b49b327d0ba3e3c282fa9a74b7c028bd3d303f4cbaf6d75bf1a00dd94a8cf448128cfdbb534e4c46bf10b2744602ae3df5b14c27abde7fa538372f1755275b69cdaf7f79a362c63c6899625c62c161c6a4d88e4fe3cd8f963d21f82ea9650ccb449f61adda450d85da69e57cb474995bd9302cf24907fdd7711da3ede6c4ac47149fa8a571012f18bc1cc2f293b8f59217a094d0e098ec3d92541144c29b8241a3123e9480127b527c752d5319b96b422af0aa8a8b6313c8b1bcf693fd11181e25825f0b6fb47f15bfcd6a13ec3428a817f2fc742ff60ae6350885b42c9475bd5a1860f840a8d00b42c7b54ce0e0cbbdb9f37409e61ba24a57db3486a79adef16d0c8ca758b5c73b70788a539ed666e4c0286e9145227817114d1d0b8b25d404e921e374de897de0ab030fbfc1ad3e4c028ed5d9129f5001da2ee4ead822fe654ca97ccaf7367b11a1a54dd289565e1b170b3c4305143048878ea549c3c0e1c8ea6ffc7cf7d255ba6c4cf3069e1a3b0afa64f525d25b4be52589b88048987e19294ac2f1b1f428695c10f658a91dc2a9444bacfb533e8b0508d4733beba532e91a7f3cd7f8bd04acf1fe6f1c66090d38a480e0d22c8fa41951e3b2764a2555dae866b23da0d0075750bf379c5d7993de6add242183207f8f15246c3c398dc46f91b973fa5bc81cb8da0095859fa3a5bdea140bf443ed4b7dc9d15e013dab47cafc5f71a11b7d6f0cda4f5d5c79a2e349821cc1f8a99c347fe396153b4f41b307770b8715e0690a1b91ed2de4a193015965e5b5c1eccbbcb552ff20fb51732a6d58b0a6c82579847fb12826388fa250917b8cd06eaddfa5fb88fec59dfb3af0c27ca1367d2e1021671605bd82eb10c3ac7adc2244331c0d191c87cd22fe4654e8250084e853fd41b401723c6f464c9608f2e14b809ee22a627504e9e35ebc6ac09ff76e5b00abb8335aff2466fc2f1d2a0b25c07eea374912ace7aab572015b293fd61befe2d4fcb3fc67c68a8e15cb7b1b9e734d9c1196207ef5eed09d5d7c4e4f9255a5135847ce0aa8f5495d1930e6601ffe9648b65d8ac7d8935110fc3a0e2cdcb146bdcf0e59a66578466073dac8c48f3eee1e2b2fbfa1001b4e7f5651b69c07de9edc470c08dfd5918490f8534c67d38a48bf35fefaa06b81dcb3b385579bf524f3ebd374149feb0dc3e994be257220efb579add2c47191cdbf13de56a9136f9509521a11119e8aae93f11680d7b67c0a6763d39b497d9cd4b815992cace4ec0dc560b2bf00f242a7d10b5a2e9f83b4bfbc33224f4d2674addaf8b191a8945c0471c82fc536f88aaf6f6866116eee57ff05689b8d566f8064bcc51ed8ccfc76ad5c6739896853aa37c9ab543abddae4df43e03f45e73b9a71b818acae4baee368a068973cd2805d4e2a4045bb71224d96e6894e9650a9521be65ceee031f293a5b94bd4c7703077195557f0ca77b4a44bcd0fc4162a1be3edf4fc282bc326efcddd5dbedfb69feb687d5673e24fe41bed29c200d5b9313c0730e2e43333b771400aa51f305c8d5d2e3c297b5a835ce4ca3c06393478aafe77ba355d56e10ff069256f9e034bc217068209795bec566aad2ecbfe2e5fb9791ee2126fbb61c793acc20b533e553f308b494a12194a3740e93265d32ab74be9981ab4721a3f605fbc15a4eb593301e0aa96f3f22f7cfc9f59d7480cf533414c42dce3cf910be96d6e5e6e1fd905edbea4998b64dd1cdbfa9f5408f2fd83eb2564ed24996810869005abb968ebe8c2a9e0624288516bedd2020e2190f85dcc150c59dee2c785f0f8d0acbccd9b9e61cdddf786bfbf3f670733b36db5986f475e3bab863471aa69a8f5082f7772001076774c6ed0d72503acc1e213f62ca84af44a22b4656b7a3305fac0a43d11cd6b4f426b462f1dd67910fdc5afeb46298e117fb787bd894b2a31489225d683c1a1b46304e36af6cf60caa88adb67f73770cf9b4810f6fade51d82ab0104a43d30d4863ea751f15822828f00323f4ef157931eacc4915af142ea3b2de71def2b7147d30aa7fa14fa5a84fd212ee4790a1173281bb74535de37578ba99f872e8d1516a64b568ad120e428d4aeec14b8329d4626c6111037866eae8b1499963d1faeff2b21616f52bdd621e6b2ecf4bffc8447b411151430e6ecd34f4e54bb9f4d22cba050bb1b76e26f104c97e3387ae9898885467762b8d49b82faab747998d376d52e3bd505fa3178cbf3604bc5a6acefb6c734f855cc58d521708c86d2559fd9a8cc2762bab325c9b2ae60bd95390d9adf9eed777c659050c2ad0b2fe9e5323b683f17b1d958204132608271bb01ceddd51f180e13fd125a680473d7ca11ec40d67f4fecc25b225e388d437e921b6857c6ab33c07fe6e186deb33665e9c9f1d7b346f0d1e4c29396680eba4756df1e9fe0bc386a87340ca1d609157562c3e1771830263db1373310590ac9318534560c9a51abad2fb2192cf8f029fb09d22177480ae0d9854a2ba922e134b1ed78898b47920fd83f82bdfa4e78d3246859abfd020b831e343698d0f0bcff3d6768edddfb44cba225a40b124db3e4182f2f01a2c602b7399d7d268b0781848f959b72d8aa759d420285ccdd5adf664ac4f396507002d6bd41e4e56b0552a3a57d99c156cb9eef396a320718a5e64fa7cff5bab60f829d784dc31f9153509e5715b03c9d204c23a400e0b5941591b8b730d017ff28c3550a64a78b093451f3122cedebb83917580f30aaf23f08f5fc319d1374968cfd3686c725f91f4bfc318f1857777d7d43c5978cd635a394259255c3561f35cab9609fdf626b5d89f1a08f4f14af205627344e3030ccaaa2b679aa8cd4173a97eace1961557128d02726122166b6265061edd93056d76a0ed151075b43a51b93a42ff678b34b16a8c0676484803ae1eacd9cde4464bd81659aaa53a92155c6f2f5fd883d2a5826416698ad09331c81e46f2d386645a4e27b8ec275a7046d4cbefa4f7501fcb8118e6dc558e39a94987906268a7eeb1d85a145b18365ab407b56ff061dc0cc90a8bd8baadaf2463e20dba7caa3d68962fa4a227082b789e9a2f4a32ffea2984295aafb6ce2562c8abdfe0d47649cad97102d11d74c131a4d844c47931bc07fef48da99f2f4d690ebd2b8a3caa21f82b07761e5e73e76f25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
