<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"053e19b7d989d30c1ff1d667602adf4d155b7c52f2b4ec4bb72dcabf48611db5e82b13a2898247acc9ff69f7d043ad3af2e36b1ad98a953671812d7affba86d393c01b969bc9dd34ffaa04cc6239b7b928dfdaaa7168b2570a1e7fd5d209b1dce05a0c662db1745609a0909d60133d1d9ff871d6c81fe59a2fcd9f7c7993b067c87430c7451bf8d5edd808ef3b123695485389955b7dec4a98b894dce5c4473c378d289bc08432a9bb8efb0ac44debf08a6cad38d735ec2285c5c733d4762d144a98dddefe86e7d4bf6101f2b701a34f66a7ade49b964e670d16f6b3a40a4c50700bda61e62ae45b6f5e291303a61d4929b050f62709fa4a49083ce9addc776940559373759bb4ed0ac82730d02c535c94fe779d1c087afbd0cfeb92e3e8dfc6f4ef83639fd017450ea90778c174b8dc3793fa4960f8949c351e6b8561ea03dea4d15980d60f9fc2d9686dd1d1b9c77582d565dfceb36535c7032924e58b109d4fce03de5862a4ff78a1fb6b906b27b37690f2c9a72de3799d754035f0fdb9b5cbeb802fbdab85ea61c5f162fb426a21ae56f3727759f81f61331ea47a342f409184060001d1f69d961a8e8320df0b5002158d546835058dabf3e4d4b1ce17502ae4355f870cafaa316d3666cdbc03293e24a3ea1564cc5a536d1080e45f430dde7f87243b2179f07bb094aad3bd2076ee3cc3732804945cf39fc86b7714d5860b55e8e040d852d20b4ee716be8fc95a29919e0d3dd72a0b0771b950266e98b488023559882ffdd611819f23678f11edb3cf6bcce31dae8391a52925429975bd36566fac1303edcf1135edd5b85a6cfdcdb403850e430e12f710ccf37ebbb4d3bf6602264d0a77a34cc022c3bcbd4c9a6017f5adbd4dad10cc8fc4d50aed62afd89f1ae5467773434889d56ac6880b43924cfd50da63615561e6d1e08b1810e765cb54117978164e272f3869395f33dde7776a5114310ce6577b43c6b2207692c0fbe917e087a41d9b356427835b9d99169fcb34348da8318f1323cb59065cfcbbdab4546fcf0a9fcb0bb114c5c3e0f1747ca7add10a79088969addf62596144939a45826780c6a8da661ca229ae04c395a7ea102d59319d37f13e11f05fff825c02bb1f0ac572279cfffab8db16a2a5e634dc9ee00eff6e3bdabc6e8905f7cb36417db4782672b20df16ee9d4d45ca44e28c134a59fa1e68c37212063b906407c765da63668209432fdb54130aa9c76fe8687865d09689d18f39c248b617428c69676f31bb0977e67d6b787834d714b077e5cc4288739797775c3672459cfae7c2cdc31fef86b5dd01c0072a7130bbe8ad422c574c2c6fb47c1e596403d1b2f1e36ae42d480a07a2a4e0b9ab36a625ebcd2320d1ac9ef34695182cc01b404ae1e6b6fcfc0638f611534a8330566db525a81915d51f9ef567a5ec3ffa9d409b2bb59e478ac358b6246dfd22279f33f4233f7955820e609734e9868f7a0ea31ea265e826fb9a1046027c9cf2d8461054241f4ab14e601d64b29e1ca9378ff6181e51512552aafa232afbac9bc96e240c5a21191c2d0a59a7be09edbfbd9d1a5dc1262c869e45d93084cc34ad2d4e249c7be4990a716590491318678bd77f428bd692d29d0c63fc699554b5c6e224414b980509802f95988f7b477102ea57620da04711e4c2b656f826e72fda624606a4602f7b5ec58245baf68443a5f7aa0b24ed34cf852d5170d89a64957e48d35cc5f2cc788f22d2141260cda46ec77b480cc3cc8de0f86b0d455bdad2addb79ce80f5d7ba745c33bf78fe33daebcc4700601dfdefe4c41a0d177dd5ba87297b22565a3724b6df6c6d20f189a46217b55d45b9bb6e1bd6e005aee1be2394693e9a5f12e9167a2a1376a84167babc82e599845f33611c50f221c15d05e65531ea2263b95ee08077b6b2aff56af743495a74430042c3200c045f6c7ade990360c8d44aeedd285185bf0cadab189df5380d3bc3d3276a2525864036b9d7538a36b2bdbafbca48517e1b8ff98f1400a894afec80f4003ad9d2c3615fc48b1213acb03d54fe2fe1f5c14dc32f68ca7faef08c45e270cd1072ce3e07c8ef4719809af9f9fad06a897adde288ec0529fe01a885c6501502402c048e14481a4be3080a362df5649ba7522243c8296823b43ca8e1e4bbca59d5321f1f3d17723a6263b161cd2453d74b806ceef78254565640e858b0a4be3c6d460937ec69ee163e5188d72aac5158b134a0f62b22841bfc075ea3fff22ab548587c1f58bc1d7f14ea3b720ac9acf6e4df80a59c79f650fd4203ceedc3da3dbf36ec76a8ab46fdbc5dd8f9570fb7948839b76b0080ce9146a446dc1501b8a737042b0a5ae8e44739627a5a36249df50e25dfab733045e3e21ef4080c50eeb34c3d01d1f142114abee3ae958ef15abe518782b413c328499f15c08ef6ba5d6c84306b427aaf4e27493891797ab7e4e37a002a108b08ca77386e4f62fb99349a79cb9762c368ce28936a08c6723b452b900913029865368216c31362d116f68db7ee94e7d4eb12c1ccaec71bac47a621885d6e3c3ab359c5ede3ba6656a6ec6b74793be563f58e2a510fa4772898ecc6ccd88ad2cf95dba3bf3e589501bb44fa4a943e9ebbfd76e35dff61b29b1eed97006fc173265470177433d42623ec5b6e7aea5f8f853ed0bed694862b38d6d3810c85cecff2cbba9704a3f2c6448778e503d53db2d580769969ec0a0dd0dc4d0a86afd3caf648b3e67ad7816b8525d23c09087c60561dde55356131883f45027a533f7b8f8dd372c59993f59c99b2bdf878b90474eb169da989b918245636258c8ea60dbc5fadba96a9dfd063e4d0a33bc9ba3bcb5d6666b5e760ffe86cb359e4f5a140c1dc23c7b799a5b381fe293438e0ce3c0126f87feefc97af8951a6f3fcbd129ed3dad74f222ffa69d19a4328fdf22b50686002ea284c46e8cac9fe42271717212b1a1c46aef54fe876bf7dcbb5b1ab931f6bec510f86799aaffe01192bded2eef9416bd4f59a5700bd29df9a237e9637201680f9c0758ff9004f8a482320d0efa0819f1b087b85585b8240cb33a4722f790d1239cffd7dbe5e3a0532aaec8b2a0206b31f4df86a3c9f413f8d97f6905d2e75e0af55fa0db2f212ba536228344308ad264f48233757bbb3808e2bc092fe0522f277a5708e5e6b5b5114bdd50d0175f68c4eb234da9fdaaa765024e5f33b619f92415564852e8105314c1591fa342b1d1f73a205a03e1fdf8db18f54e4a3413acfbb52213610e820dab8fc270791786e89ae41d2485709c5372a582da20dd6c24383d84f0c87a90a606d80816748536d60205ceb26eed3ce98c1ed0ec0a78fccfd8d32a31c266325c32f73e95f68372cf0345e09f7c5ea681c5dac0d471c2764cee4ff435b3d957444bc68f14e1832f9fc647bdd5ca5879b8a9112d981ff586f7b203b549751f61f9c2b586ebb478e047200c0baea2efda9f7bf4fc8566ed0ad5150afad72e129f8f8fe9b5800df52f509da0b1cc2ce2b97b398cc7fef124f8c3382c8dc439d8f4a5a4548db16b24cee81060f8119a17ab072d42cd97d30bb4d8d38bf9b1f55f34ad702a6d3811aa0f64010ca7132956e231278fc10e957cc02f3a682159940337f773d92753cb1bc7b0154d148d290c3c72f68fd43215239dbf9b2f3c1c05afadb6f245142e22a44d80bfc1f1f849ff563888957ad40c6fa2a308319591b1fc89ca3ee656b06f8c344a6f10803f5a798c1a03d42faf92761fdf8df10a978aa403e392dbb5e905d4d68664ac36c20d5b887c0174c212e987bd65fa8efe91b025fde5a005251f5804993ad7d98506fb24b3cc1d6a7555e7e8cb57f0ccafdf1d5f198d76aa493c91f22278edf24ab907be7eeb4b3e97027c54274727d79237bb6574153c52aa47e1dd994397a1b577bbb040072334a0e1c3fb39cd0f4d14b3b4133661d4cbe4a0ae6168f956233d1246791122d92c1577956b6c2b5c7a05b4a14414e7618dbf8986a55f2ec93c23f73cc78930e526cb8ac936d1e78aab1291d7c7947348ab3770239404b29e919517c4d34552bd6d2fc2add6670d78dc5c7131e94a6f7d65b1064d88ce250657516be4fc35e50dd2aa2129a35bad0918d9550544a3613133d976b8fba0ec67f56252789c9bbc59860136d7d8c2caeff03675daf80211c6e457d8694082a4a9a17f9f085cfb2ee25b99091f809676f34fe266a7f94bab446431c93e262fdf6a692a720cb452d8590ed8ba1c122766798b718c32fc1db59642c2772add491381cf4d81a0e34dd1a2365455edac0a7c56c4a1485da2577c1ab4ad5debfe73fde10a06fe03f1f4d53289cd9b66df0c75354b366792483d0911f662b356f21ec0e8d9a7f9ae8ad22529ff69023c3d0d04ba2567f70328564f41a07f0565b334315caae10a8fea444c36850a2d589fc4f3f23c3b05c6a8d8c38a6c1e62509ab26b076961a1859a12814c0cb345536674fe91aed5b1e9c7a1c3bc5d97c9526a83c5433622f00026cc6d73d5682d156e3f2079729a4da9545bb68a7fe6200c780800009fb67f4f21194541e882070ea0cb1a482c502566369f95dc7891a5f56cf5c914f99f89fed83559904cfd721e6c85907312c46bbc4e2969a6354b602786827b300b8b0972e2028647e92eedb9d4bd5437e0fa13553d3ec04927c4cc61318a5bc161620a188fa9850214f76ee0e4643e3ec791ba3fd28e30f7021251a77da793c79b6bc51c23cb23f0f5a12d813d8fbbe988d1dfd4d0116c949145ede3d12221e618b9ac99865c2e036022bb0cb0dbccda5d49a6be93a6448546dde0b24f61adc93bd852e927f9b1f62a46df95b23721a5da0b86cbfa28cf1705c0984265ea12276bc023be184e521e62561120e8dbf23731a829a785f510fbc902591b9c1008e88585746101c990374c13545097044f0c17a35d270fddf3977d54c84f2ce2aaf8c2c6063e37b88584128ab0a280224e4cd3b9ccdf030c3ced387d84beb8e23f3c9ec8a3fd20b5193e3cfe3d1be6e16db959476131365e5e071c8ad9ea9ec819a361effbda0bd4dd86093dceae6baefd49948e483c99c5f8ef7ea54e1cebf92063b99073dfa6ba93752bf6a7d794881f98b006f9ce0f05d996a068334760b5e96138d246fb1e583590e26d8687c5c90c7e73c6f18c6b02518db17f11a704d9b1484fc7aeb8169d5736339b65f618b09c7e360ac19e494cd45b9d1408ebaa382689e806cbceb67627a51cd82588aea7c3ec0c4a8e6ce67981f72271798aaa6aa7aee200e8c7ae784e16ceebb9ec501096da5f6f065cc1c139e930edd5c696fb53458b8e338f0ab7d29c1a9df4204c252bd605ee21994b36957f4598c6649f520c5ddfd0b5af0a7e14304fa6ba28f0559f22816e84434bba2c02991d3472dcc30cec8ca849aac56f1435464c42f23d0e29cdf0b6b37faaed6fe302945c5ad6f83eb1d50b3b2df831e94c696c1eb635f889bbaa34493ec7dfb211cdabb298595acc7a76a6cb2c8ee507170fd8af754be6bb80e5814ce0d795d6b77d9c6259ed0e743fca8fd901d3b292748bed65a5f8c5b55a0dc5c04c4e619a42d42e4efdc0804e60f9891a605a2f6c7d8969d1cd6e61e3b40018bd46756bf8f9fb6e403ef0daad34a23e8ac40a104552db351b318b6806aa34eebcf792edb7d2709f35875b09e8ca60d2c9cec0db10c76baf05e9a1d9f6b0c0fd84456ca8e7bcb55c527df0300ac6f2d37fc8114fcf3d3003c5bebddd94248dfd76b8f7853a820e48e63d6a67d4473af13b317ca80b93a8b62fbfcb80b59117847075b490b4323c4647e1ce525c308791748446b382aa018eb92da0592a6425f2526f6be5da613473ca8a2f37ffbbf859589d4115b9ecad446404ebc427439b6a22140f2c58f325e6f43f3429e78dbc4bb07aefea6850c98c98c6ceab5952ba46b6de23210b2e25cf716b88966e692fa1e39f6d2f9caeba1655cde533da5cc89b3541dea22a3af35e586f58ad518d2db8a4023ff274be5191f7bc8e051b8f1cd1ffa1756703dd1759ccc6e74f61eda9a1bbee0f204a3ba5a25df83c1fbf3faebbc7c5be10f917f331b51f2d3bd630475b7ba87b1c05bd6bd635b7024ce34f4b29922a276a41ac2deef20ed87f35b8bebfe56992f6735dd3f555537efcc8a9dfbf2a75803228098717fe32989a0ffdb32747f8c95830857a69abb49300ddf032ffb1a12cc8a2767db9a93a97c865f334f851c87115faebcc6f57fd1d3b8200347b5e9c0fbacdb252b7c90ce4229bfea2706120ffb0fffc1adb5df7ab56b2bdae72a5c9af5a8e8ca3b3047cfd7ec4af319795c27ec99433b2f0f0658f5cb08b5dcdc5d1dfc767b48ee32ea53d136c5b93e462f4e2396b9ad6837695869ba6e42b8914689d91d586c10c0e0dcfe07a753e0cbf32bf668ceddf287623f748b6a65e0ed09e5372f26cbb6dae48563f80ec9157d96b3cb0aa01fdf8f6752b74c43fbf02652cafa90c6bc2ffffe90ab232c932b7a1eff0cb892254df209050cb9242aec9b5d8c12407c50079945bdaa2f3cec38932f2f2473a2c91f4fd5f0a302f10a483187b6d6cb00d2c5999693d04346b2b5715aaebfa384c68d192dbcb740cd05ab817cc8182e421d3ba50857ab1598838318d12281379e1e23e4b298a38356b4828560210913fb3010a8cfe31b7d3ff163b44129689f6ef9960c49029ef9e45e96e8f5166a5b32a987ef285bea1a850935332f764c0dbcbc498b48863084bdacf4c8f0f604488a9cb301b181a49662f7cd76c81ac8f33ddf531c7c73794cafb713331e60283f27b250e11238acec9f1e0e9dab1f2ed476338a1040a1498582fa873d61112cea08af2e78b478cc92ab0774ca2a305a55858b96865d6b493c18a72c0903f6f3c1abf2bfe875b8525acea1ae59ebd3e8037dc39486aa275ad15f1d7c74fc94099c41e10db3ee7614f55b3d6999d06ea1f8cebc37ecaacaa4f734f97f725f1f70e224b81416f58c94f01c9c946f0ea5c96b01ae7eb9ffa08084cfb50d4c6c10bf1c62f14393e49f06341fc9816845d7c43d01f4b22ea0544c5d202a3401270d30ceef1c67097eee42f42015332da12a1f0e42b50c841b023236a8ffb9a81c7e02feaaea6efe29e80d86dc08b353b9506436d0aabf3596b5ebd14603c7877ca62131d05301b0bfd64bff874aff5052279fbf2eb56f073dd892e40e51770ea8a3a51e087daed706d03fb02c54b0bd171c114360265f2fb5a74a1c2bb7b1fe4264ffa828f31d6898d3d6fb8c04b59b3e70cc922c156e3a226e826a6f94c30219a8624f2b75f7f5c11729106217777e1cda25a25721070d565af7c113c3b62c4a97c2972425e5da6af7993fea5b0e70ab0726173c7aafaa3c3f6c7864ef7a0773d7a5f71b6a02f592aaae911e644e410ff0b94a3dba984dfff8f41aca8842ea5c28323d146e345837e13253fc5910ad8eb8696feaae55cd49e407bb9aa61fbbd3672a310ddfa37d1c717b0b6610c1fa7e809b071198eafa29b701811247bb1498e7d059c90ae5e201f88284b59c480ff92a75144b00b20ab845c190a344a4fe4c5bd296ec09fef51fd49c8e3577c77083acd2c5afdf6c73292571976808d296d00e2a75c67c44876a66f0f2b9cebc16ccdc00de88ee392a7c4bfe431a99dc9969a93bb4c82b4246da04cb795957f5ae47bb2aa675444b6681f7942769ff69dff1b57614b8fbb16e4d8103ba34ef1366e657d6cd42cfd71b111dae7cff11abb515ce2d5dd1d91b310b1670339785f610d067f296ea322bae26a226d5b503ada5d1b06af3a9cdc4bdb329f159eefa7aeeac9e3040887bf669a14ddcabffda98f3ec5e3ac27ac1782368ed988cb5359dc3a48ad95b00e036a2e356659336eb16fbc5dcbd01ce3623d2c21eda5a2aedddf7d5886759a949e50b36d914282905018a1d1f5140edaa2bb68f5331d391027b5f1c74fc9c9e9e716ebb9dae12e03d53c97c58ae35467a8f7fba7f5453194ce7ec3b915051980af6b30529e6a189b43c0501beb91cf8e25e62e4276220e2eb149527e007b0e7d9caeed7fd10e10c267e40203abde13b7aec344fb3fb4d0d8518688ca074513c0f486e837d62b4d3db5483beafce6b43f8f4ca8b9824e632b4a92cde73f3a9eefe524585660b9d39854063c8e5140b5f15f28d6b32253ed491b04e2953928719047e5547ffd99f7e0ca823d5f89d935115c9c1e514fa42285d03d7b54e5f6da465daa845b63a20f50749e67a8783b667beebc0dd50312e02abfa3abb8dca0e02a561f14377af92cc398970568aef369bec5b58c96e52ed3ffc59104c475a2db032c288dfecfe5c776aea2e48336d7d960a9ca0f159bd7d2d8d3d72a058f48f788ee0a4c0041c1de15b4b1b34d929045550225e0b23b3126b576b4042e5114029586654c70256a6daee7a47a4af630df68fd259884b501c060f10c3c11759d82f84d2c28dc1004b3e6479e68b6e9573e5f583d209d6fcbe72ed64b92d6c97d5632cdcf1ee4fa3bd649427fb4ec0fa13fb538f9318c2942f1a8a10f62716e3498923cd3d398c81a026def3d7617a4538de19bb439909bfebf1dc5898f1c396cf8d0492df51a5784a75543a08c477eb91d7abc8d230de50b099f802841d3406808eed06434968fea4022dbce8daa0bd2cc77ea48c89b2fb7c7bd4c89a3b1c109145d49ff695c036e5065f8981c5fc6c6dcbedda3210590184b4f85cc7fae1a9cb2564bc227a0b82daaa71a12c276dcb38135b98565a6b89a31e9e11308f704be73109ca47fa951d7af5fb25913198dea61238dc25e910fee68b78e48775eb5a3cd67b7a1a04e2632944e02ead40426e10ba4502fee60b191df2a3c7ff8601398651c944fe6c07d4c357578ed40495e47844407f8ef3e9b777b6ffe15c6804b66082cedb2266acb3392d6413e8aa63ff3930c89ccb802d0d1a324ca66041134027ae7c87c96e70894aeb21783ffc2afc16b5a957fd344c20c6f7a227d80898b952ae44cbdd3d40b1e58a498dc66be13b7bf9e592ea49dd95c4b82e3864cfed21cc854169f8e1fa03541243b541eb52225ec0103ee61d1b3b5f228d6b52cf8ad06ede7bb3b036d3e4c14ed07df32b9931a4855c787e98493aafd5d20b72e820661a54309e2e4ce7bc41194aa92e9df6872ef0d2a5fdf3b7aed6f3f87cdfd5d196a2aae7ac15c45222fb2e6de079bdcab29cddcf97ab8005333b0ead1eaf7d10c2e4c488e98383181d7aea06fb70dd4569572233a33967043afa7a23a1cb7f064abaea9d8f1f994a5b9429fb3457c31018ac59018a6be27fb5990c7d48fd7a275a4c6494940b06128281a9c15a7970923e045230bdff55763f8593e177af4d19701d27f56fa854ec7cb80634574e78f685b6e5430aaa21e66bfa2c1e45a56517ffda31edbaaebee586685d005a4883bde236ee20365b6d041e2bcfbfef9d9eeda165161122566b52009670c20c211194734b012beeffd9b4f14f3f84ae44fe7d0b52dea8f44b4c1b1a94bd83c45a3e38bc4d6beb546f797d40234ce0e864435719fc672e0948d12d1d7652147c4492e3e530dc273b91237ae9865f658887a748ab3efa3f49a5e8bdea19d014946d8f73fd5999e7d8eeda4e46d98c41ec7fbcfba4257ff9826ad6bc9143d827ba21d823af14e5c01c108c64d7159f0c37c62c10c38319792ab010d43b69b93b248b005f7ea59a0f8e74da18af309f3c7bd4f404da9403e764478b164a94c0bffda76d703288500ebd3a18efa7f1850d2215b3bb05ac2d24a2be19566632d278f188b0ff74bad8ec6320e8a2c0c54302d641fa36216695c1009bc6d7a624958cbfcf3be0466ae6319b3c4a89341674bce578ba04863cbdd7d21ca8f49507464caca09b46b25ad2d4cee6f610575bb040095fbaec21a067a5bca5bbcfd08819c1a465a7a06160a07d2b85e2f68b8fcd16fed79cc25fc9809ff16c35ca915e56954ea61e07e77cef35d4060519f6eb76f4e7803f40e5c13e68303c0e0e3424bc8dae0be3d3282733a9430568a1e94454e874181c3f0f6d097069c8f2b3edc1b6f94eef9af5072c9c18b32ed6031a3d75ce168897e07a07945802e279659d208a7206ceb4135978aefbc4da8cf4d8fc05dfe2e0a74ebb95edec6b54ec1b39dd71dbaae018bed2049884d1000f10ef12654f8198d0e31445873cd75a45e01a59c31e43c24955eea3499eb2731cdb946dfc3c23ea49584d8cbea815b8e101a50ffd94e06e1daf40c45445502bfcf3a86bfb2733593551e71d7e3da876aea7caee754da0fa44c6ca5ebbe600d0d64d3ffa03313c7b4e4c994b475a131e7e40c0ced9e10252a013e41ecc4d63cb79146abb1ba84a8c35755ac3533f15a665de7a9422eb4926f272a3d648a882e5f2c81df62699745c8bc1d19fb33179bff30a121ad58a63a2ac59adb130b2fdc15deee59bd15146c891eb9448941438a70e2de682555ad077c1b39618cdb01a2815e77b35994576da403ac9daf1731a2f58c8ed7dc2c3e1c9fa5974b13aed17f00354c37716f55a3b2ac1b0ce6f635535d13a54c45a2f609db154236cce8c57ebe2101c2bc51c1e973187297fc2889b72b6f27c638086bb6c0c4f16553c877d2c6b4a54d3de7448e76c9350a9c66060264aef3b0982f7daa26642a222c1e7ab72eb634f172798279fa24e31c71906c9daa6f0757bfe0c08103cc516276c3f475b0f294d0c258b5a881cfad88c1805197cb8ec8fb1ddfaad9e54c7fad3396ea6d32a65c7f736a0a0897b1e1b8f0b36c9d592c2db404f7c6ebd84931c7891fca30a41994dfdb25de9d8774b09c69cf43bd4ae5304041ae0c8e41cb310efa5f3a0f77482800c87533d2d7c192874633b64d32ce9e07a008c4600b00d84afa2864033cfb4a46f345bbb334e0e53ca1ae157eb3d4bb6340901d0bd59b5030de37446b711c67dd66f45712b2a2f1a3943c85828469c1d2090a03c2b931a325a348192ecfcb4f39b0f143841c14e94ec068e27f44f2bdc316064c0ef79ec14ec825603abc0de7fc8aeff3655330c79f68628921bbc9f93970f376f765177b1fb5b9d77a94f90bb942426bde52bfede91a14b13dfcc8cd73aaaa4550be32e8031359526a8012008707c3d81bf32df4b3a58da48d7902f847008a9aa670c3327406f69a467446765402a1e58707c0af19aec27743caa5dbdb6afa4b59ce5af3e4cda3798969f0ec18e79ac81dbedb90a0fcd3a04a6cf067b32912352db1e86a8d877958f25fefe0762681076dd54a73a420b20587ea01909ddc78227ff520ccf89fdac21029ef1afe8c5d8dbb78ee4d0b2020e0dfe9918fd7d8a54aca00ae7c92e42e6a990b94e4e32c4b49bd6cfcf01878a3b5a26031220fb4c287ead50f0520f01ad3a3a63cbef568c861356af142be966b94cd5af194cf3e7e69645029d5467d7f3023cea1643d16795028f1bcb60d9dc354b5c6cdec76b83d22e02085077b62cd18ee2ff3999ffa9b62fd37276891930f4c8509092ddcd8452aec519704297b87c47d1dd7c1b20fbd1aafd1b8fe158cdfe2e6c7038ed84cab7ed66c06960356edcc751eb9303cd2098906dc795ff323b93ab1284d35a9a41cd9391de16ee1139267a22cfdf3eafa04e6cb56ed457325565d24ea5ecf5dce70ae3504c6db233704b09a9716f9ae84ec392eb6e2f4a9b1995a216f5e4107c4b7d3f1d03a43e9a41c3ae31436089854ebd0a6c8c8a13cbd7805acc2112ab29fcb44c10e626a9ebe4a8afa36722f8f6fa3b64f63bdbe9adfe079471317d0973b5b5f1dfdec978be3f19262b453ef88d97bb36d7d1f5fb263079f990518e175811c052ef0c8a7a65b5ef6a82f441f691c3552bdbb6b4be78a9496665021a4a6da406d6a203ae69eae301c7ea09060ec2d441697224aa776a56af9f6b4067dc017a4805ee05b9accda54c8c46af27cdd77a25b5b79d8ef19f7b58a6d150138edc4d8005139277761b91921470ec9beafb9d5745f615963705bc85ee9ce6ae7490fa2f348429c8802eb0b4ca40677e13284bf49df40e015ee0094cb6596189037305cbf31c560df23ca0f005a7e89fd1d74d64840074d9b9efd1b1e1ce1021d03e72a35c8eff1054230416da46de59ee7f788d3da3a3c014e12e251a240b78eeb526e413c62dc94f4f0956ddc40608a8f105cd92f71f5936fb6124c3440d1725fdee128b30cceb0a136c798849e0c6396ef68eb30eacd8eb3c362f3f1e21a856b2ec2cc2055ce9698b7c4e175efa779506022bc93e76fa118b7f3464db09f81df4fbce06a4324600e57738e0ac083a4b24670da6f60e942928097fd5ab62c33380b3be9bf936e59dc388ba599c3d7dbf56b5a36a43792818a5911df8a885cd18b96f073be2013a5d65e7c831331958dc87ff42f987b9fc04965531d5706159881c6fe1c7878c489f5694a84f0798e42cf7aac3c07df46a244da50c609ea9009aa24e752d12b4d45f10657c404bed953222a7eba73ff00df27fabd89313faf940d1276163cdf0e5b2b4efd024f0d48c44915fa1f69c8b5b82e5be94eb97c2f38169c0300e8e7847fceda189966eff80247357af40cb6e264c8cb008213caeae438e92597c1630ee6a8ff37893e40faea13565d17de1df01dd517d07666f858e6c152a007cc0ac8152ea1934b4a9e3d2e5a62ca53feca68e6c086a6d856896d18eb4e665c212b0d529b0601e87ff182fafe6a4f29411c488e7cffac1b98375f5df41338a74d1b50b7584159c809b8c7346e6bc20e0bd7a86b07893244bff7c1b827b0be90f44546fbc07e564c8fc216c096b1e6eaf8307bf5879a864ad619002a8bab18d6c646312f3b03ebbd8f3f651c9ed1c956e0ee45da25729e3b75dac883adaf7e06f8a17130d2d094a8b59bca661f06d600bb9eb272b43f81fa0fe0576319e5a10a72f50da40171d9a24bc75a6fdf8f3efeda83c439c19c7f75b456f3820678381bffb9aeea8e9449582b25191eddca4dc9000c8e10a86bf401b48c1869964274c8ebdcd710a1864c5740b2c388766b04149e819215316712ec51a3ea7783b5b8752d23547b67f2c3eab69c9864c0da51ca836f3fd58540fa80cde1c1e667e93c9bf162c95cd7cd92ac22386c0bfe359350df8162739f67df29c7afce33c35127634ed169a6ba0c6c0e90b39871773ad16495325a8276ce20f4a3c3b5b79347b9dba53b46f310d23c050b334f081682f52d711387594f198129aeeba7aadd5f6641d87dce001b029bbaad047c4f0bfff0a4a290c3e12e455cf9b480845899ec299e6d325ee96718983e8cd4a726359bb21812a25e51d36bcd40110f5aee539fe9f2531dc79eda4e76ef6a94e61fd18e12ee9ef174bbed173a600db49872f37120077a1e5b918791f37aa252e0d339c6acaffc2d75ae4d4549ade0b7ee39bac1697b535ec307b0c4a2eb02774abf52d663d25ab676b136c0451051ec26e41d4f5e7b9615fa7e7f8e17865952d98286fcd0bb66c6a099ffd1a37c1e0b596c3349cc8eddd13b47aa1cae123e758b35f6e8570fe54435ead66cb5d9992853996d67960bfb3858f247f75281cab19d5739bd55544f090ce91517511634c692c75127a622a5b8245e73d751a0f7d814c6eb2d0a24c2041dd95df49f1cd8f5756333a1d78582aca8a2f7379e7a61b2909075e3c78de1e14915fd93132cab44e0014c67d4e3a9b33d1b9aa45c80a7777d4c8ce0abca5f2c5f90be53db537477a59260f77e9c77c48d9d93d16d0db4470413192a082c9dc1b69ab5b196961f51580d39f47c1ea6d68ede6f61686764ea60e30e829b9bd136a0260ee043c9ba261ecf9e5ab947be805c566f96f200514a58445019a2790f778c3cc6ef30e800712c4741bd6924b53ccb76e07e50e15eac5aca469c30e9a950ac3eb5ba3f6d28182343ace7e6f9fc822308776a552a127f1b9dfcb1aaadd44d1e1564d61d30832dfaa88ea2e31d6a59104c2a1e8c39a283813d35f179c0e3f11eb9bad8733ae72cffd908024fce82f5ec2f99fe74227876196b6c601bb1f0a9eef9063c9a3f941a80c10e877bc168bc8c66e1f0afb11bcf5ef7d48ce22b629420b36a9c3e65c1562ececa825b5a671fa6882a02f909f2f76f13a5445628c17215e05bdfc832bc770764106a98edd0b08ca6b45595eb5d3db2c4b03f0ebe68ee5d66a76c73b04eefcdd32e269b32e018f6299938e69ee5ce7a174a2e78bf1e1df9826ccb7da6c59fd1769c286e4e35ec17c5f20ab5cd94caa293cff27bbb55b00e68dd4c88604e4f743ece3f09a1669d01f53e4cf676475e8861e236c81d96c5d666d990a4bde1267674edf55b0ac108929d329461c06e3ab298b0fb6de4d0844bd02c1213ac50f4e31e58ead67493acaa0d5ff9a8a9dd668ba7579c8141b4379ccb4585836e776c8b1e5b5a649f7fd3fa8ff02adb15cc18033f3efad38a4c0cb4718b4d4d236f63dc43afd619c375dca3626bd54f2acc622325d81d8c8fcaf67c2664b4efe0b4c81d7911907e45aa455633e7e90fe6c2fcc96f56840bd79c04e9bfd9db3667eaef5b0ad6430bc662f19cd747aad71cfa2f299becf2d2ccec866ccd8c8153f210bdc5dadc4378b404d3eab68a0f904f86fd4cde6997149909a11a0abbe9b23adb1f3b6a24b230861c9f1b02da821365fac066f41d99fdda3d1e1b022693c5e359b6f17810e40194e2accaf5e5b5a02d68a34952300484d3b9819e186ff74797cd4e3d5a0023170a7c50c13886a64a2d8524ef00396066df7729995e00a6f48d9044ef9a06cc523e0aa65d38ba6aecc6c0391cca81cf8bc64b6940c86ecf0130349cd76279e37a13684e5dff6c2c1c637e1370e71743a5e16f1828e59ec18846d2858297d5ccae3b57e8599b0013187db91024ea9f2298db6957c024bbbb86dc0e8f1a83faec12a033df2dd230f11f1853f98dd2e12e52b8c388311c4b3bc48828369b91a42d0fa03827f2c8c65344b527d129a65c938aa70f074b5bd3d1ef8419441de70a5af79a866af7fe5ea9244f0e42a07b3281507e971fd029237026630ce67c860d630ddf5c462e3b904461daf9f188126ac16dcecde488d2ed10b3f7e81e9c64f906f03605e0c7d4ce6c0746ea35587513329a43184aaf851ca610f5d149444f2f7e84af75d2ad90e237bb7b9b9cd70003b557f75fc176ca79299ec6321d2ce5b43e414c48e0cfab3e513fc2f0def30b6044c374b68c53e2032bfa8864077d4711d43d049834c8faa94261dfc62ec7689cebecbbf37ff64c155a7d70f1525f687b4da4a27243660cbfb1b9a523006475fa719bcb64bf90c57f4db70239d6921d9df6a0ba48fde842004132d5e4c20db2946b5f67b72077377db4b358b302f401c36b758e8e6008fd911a29624ee611cc9615c5aa55729229c82540bd771e3ff7a529c98c491b2b191ca4b134adab00d060e0df476e81eac015cf12dc275809af09b40f3f71cb04a620d01aad507268780928500113bd18f68bccf4793662d1c1843a9ff21bf80a093cb72ae4015d0bb4f8aa19d8b2247df35b1336ee5a912e5e05f26be7be95c32772936880cb7244b55aa6b7815559d46432110352dfc008c54b35ac8c1f601e9547b348024af3124b712fa23beb762770d1ae7426a66699f602edffdd22f22ee4d67e1fb6be377e353767bb6d0d74a00c43a2b0fab829a7e5cb23a5453b90670cf41fb97d3c6d18f9676f359d1dc5c768ef0f368e187c84e822cd87b39a196b6dbe1aceff2ec3a7505b70aff5ed674f3c1ad08f241c77f5667719765b7bbe520832e3dcb95830cc07781b9249bb45b3a9b35db3a0256f632dda5d8dad694f86db0607588068873f6679ae06a435cadb894d24fad3f04fa3ebf4aad4e3eb222969869b69961722facbb84c248c79d58a07189abbe26b43a34be8e33801cfbb8805bb2949c5ac71b4854b8da911f896b3b94255335c72aacd104ebab6e223e9898a468297b0c7d29eeeda5275f135040b7f94dab4a830aeb57fa9cdd14dfd0131118767ac75d9ac1e47d7845aadc0569975d40448b87231d783e0f12f4da4a508b5de0662b815f95aca8deca83b4c791d3fcc7a8bd9ce64e79b5671b4d40d861e62062e3b44420d4c5b43f3f824753daf6f0bc6f7478f81eddcb51f0921a4cdc98327751a8265bef68306421effba75fb5e6a472e9e58546b39bc1268b8065818c89a7a750b10caa22176b867503ae144c2aa47d9ea87ec509c86c04c31ee1ac1018ea24af2f946ce4a068ea2a3b70020312d93f215e66ca560f220b44f2cc81978a4ceefc166d569753ddd55c7d3ac58e5ca93978351726a42d1b6aa114537da867690333abb0ebd0de1753efc861135bf73af486325bd8061e67a0d29593f00ccc186f34399ceca149ee0d393d0be15b90df4d20a0f218ae76fbbb5b61f7f03af252e5042a582c7287f3d671ea6decb7ce2617612ce8e272638e8ec8a260b3417daf45c5b70da80a541177879d6de77d73cea1770cd1b5cbfb1b28aa02584f355a4bb9c898771934e868328f6f2533d125219a569f21437dc640083ac189f6eba8ce70fc1a8762161b71bae44cceac36c12eb68b2c761dd4f151c6d2f583c759dc12640d7fd9f1a2fbe4fb7b537094937895a8932a263bc2106fd7f17efd4f9477de064e2910600d5060a8a02878166f0692ee7d0563d70c4fa273176099218fba5312b0aaeb6d96e0194dba6d0e25f69419a2217148bf1920f3076f410443fb0e1f503c0d923cea501bffce5e5c98af2bfd3658e99fa43dbe3d0f938bd867f5f4f0cec71ff84e260f3b157c04316f5fd6413a17cde690e4d68c755357a1893e2e6af5c611fe2ba3a1be36441fa4cf07ed372830a5db331ed6879fe29266ce20dfb1a7bfabbedc55c41fb238a84b7d029eb4e868f25da42e0a9123564e4cfa0a17381da2ce2130a720e0af86493663e80d37493a0c417a7b6c9aebfdc262721db0cd58db5efb464edaea3dde61e4eff529e869f3c01f7512f9de7fa37206ea11cabb139febc7508baa6be1a7731a4ace5cc1f72c22d0f2da13ea066d03688a094fbc93651850c44012cdfb2dd353e87922d16e23c1158e2380979046999d0e4b60889eb98623ba70fa746dc9a1771cba47461ab309061f609afa837b64e3e4cd63f460409e0e91dd58fa146e9b76adb5d72e11242a440a0d70165235f37db87f3e00a78792b9bce442a93fad448510d50bb28ba538a90cad4a186c01cafc12628d6d9ef52cf78cba44fae8483a86045d4a63109f87f988a518cfab42946d3fb1246579154a14e3fee0d497dd3192de334655fc90da36713a47a0870e90b8398b50cb6a0a7657855ee79e738452164f8e8943b8ee3c137925372000c0cd8e1915592520ce21d46e4997c62bf8737a4453bee7aeff7bea259f98bf41b8f25308c83e5f06e3d1844788638d666ccdba7049cbe4330da05acda1e403e0a5d5616d91307e8de920bcee3bfa64415e3402204d0554ca7daecc5ab3fe92ed40ea548793ec5013f80ed7243cba0d3eaa891573d69d4b8ed50810887f717bd32e600030b173ba89783dcbe7f589b43d60de49eb1ee1a3bea2f946ee1ea76a0f03a73328e9f5e976530d4b54c72cca1732283c8155d5ecf17a1a4bbc4be59d7f900348163d82639ef2fb0bc7eaeb76c58d930e39d9d33ff5121fbb1efe713a58df81bd1e9917cbff6e49c6df885f39834b8054b7afcc5ba97174bbef550d41a3c3e5276aac71d5fc2be97d02955724136ffb124386f2a415660432215838939acb34799dfe5e30f99a34efc9f297d18c9864ba4aa168cd4b37f8eb9d1ceb163c40a3770bca3eaea800e35994f2d812fb1ebfb1eb2a68c3c22f1ec2f30a7a9f04e2ba6e7ba0fac1738ef630dd8a3e463cd52a61b67f9345f5d40f65419cbacd770bc7ffef470ba8fa86966b8d78c1b1c0234cf40789b1aefaed95990ba2b0d7f9a3a6ced3d2489dbaa7c17a3d3a63a55b138a18593857a5de87ae75af1e1141db4adb0f2d9f54b8f1fa629779b4a72865bf580ffb3bc5a4aba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
