<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e120efb5860f09fe87ef728248f62fb22d049e4192d34d4b1386d628c4e0d5a2aba72172e66dccf838a0228d05b6d8ae71c87c440d7f5600ec190b5d1cc13bcbd69ad6d60b23ed7c2f272cee0487d6b8c49cdef099eb19437a66d3548c0c1430b3dd010b8abdf5990d69871ab35538ceb829f7de08bf6bcd7b93f313b631734345e8e268fa427b6e6dbcbbe21078702f26bac3902b9236b2022beb4caabf3c14163b803f34142731a691a5350c724a9d1fca12321cf30bcf65772e9967e7b6edc8c27ee23feb2b72c076e2eae608d45fd172dabf29790c7410fd764a802985eedbe5e42d26e67f35c4ccc33eba78b8bebf2e7ef79abcf5c129a5f9e2841c3e918706d9f9f3d84b53ce91c5f0af346a91aee32767210f826073268e2eb92c8cdc8a18844e1b0930afa2ea81da3b936c3738fe084b339cf1e73ab01b8d92b2f7aa8940f743106bfe60f98c17cbe2aa4138e1fea337176cfe58e2f37898c263e66c849ab59b110fd62617d7955e773356eed7432026761dbcf49011893e72bcdc767a01f4d18ada0b61fea1882dd5ef1e56e66141a2a97002ca258cc380d4780258f80d76a3962e27c5d9be32597828f5f86233dd454b8706b41359575bc955026996a65c88836bb6618e525ded626e653d0b6c3147908c83558ca5f4171ce859dacde305db218560c1282227c73a42dbc91347fe6abb8f01d11d9a43f3e28255b14347073cad1ec7b6e0edcc7b5f0c67ce94f467013121c1d9292b32ed24b8f31b9703abe43112a0d843b6fbc003d7a47dcfafe6945d7fe2a256b4f04b1d7587f8d9ac0e73338926648d9d81a9351cec1dda17de5f1b3179bf64f277db743ee03840c7f6c36fa01e6f120c48ac0484f96711c709ede8975169c00d88040645264994d7d8a5ff6c409602211138a3b827ac4cfe96abba4a2065a5a8a6e7472788d93ff76aed7aca692f1956b8e9be226c364ac49d3b06b6e4db2b0712e05ee65bb7e9b6631b2e7c0b93e27d3714fdce47ec0382bcd468d93fdb4bc88bd5994336e7b42ce664cf564a303ef175fb4cc7e876226e2af577eb812e83c1c2e2bc05c1527cf51c90b7c2cc066e2bed7b302d4db398ba64d108af0b5ffa1b15efdc390803285d0d5d8feae021eb02a1203e6b95930814f7135908e4312978231a8cb1702b9c6fd3918e45ade468cab5a6ed31a68fdcb2b03b74c0a14c5526c6b73c166b0be0f1df7d4b6c7fc4527513bd5f9e551987d551cd451842e1ff585244a0f7fab305cda779f24ee19431ac51c3c35642b008ca74cf8cc0a88161d4bcb7a9cb28d1ba378eca1d647fc0325b9d3da300e48029218dadf6664ca9c68463cbaa054799f67a515d53c36f3cc49fd9094e78055d0d3737804d9ba138b485ee7974eaee685368bbbdd0a05ae3ce3c41671d7f4348cf2e7cfac3774e85290648a5117e8b8b712969d920223188c76d7ed67ec09759ec1e040ab573e83eeaa3a8e6f8c40ed11739988d5b7fdaff24bb242428e26803be2d2c8ad72243feda4fbcad6fe4322f72b501ab610a56ba892831f76b730e2a3beba4cac7f3e33c185076faa650f772ad02a82da6b30b2abf296c8253d3b7a318df9276df41d6b46482b01a299b7c87dac13e303d2ec41980ccfb98d60cff429aeafd27bf18b9564a356ff203cdcc460f297d45ab960ee27d84cdaaf71a4ea1311b44e5b759d46d8468c3cac15e75c3d25def48db18daa20e166e0e53f118cacee912cb134ba9628b508d5c02ca116d3b92457f47446c01a3601b5c0217148e1fcf626937b62f384ea5d0b2a2244ad90fb1b9e903a47afb22c49e4752ec8bfbc208cde983b7889a256d6f21b1d74238e44552b7f1dbe9fc2745dd1622258429cd9a9b139adf709050eef507be223f2cf3de7fc291d1d250b4a5f3151df39421ef10e1e0205153e1e915323ffe8a037238080fc568d33f1c03b3a27cffd07a1cdb529e0dfb07a2c855699126c758cd73aede29d5b920b6ff5e08dcbac458a9d0da7ae77b3f24d5082448c6229a60b6a2c94ed36a20f79d45534ede9e67f95624ab64e8f2f0053f784fe7de1c52188a0882462c9041c732a88b9f36ee23240e4ab7216895ae38bc7d80dfc571c0fa4ed13c0574b17ce8447b95666cd4e49413231fd36926c28a8935d6bd57eee656aec9e442717acac951051dfa6fb2155f40a96858cd28b1dbd934884eab465be0fd8eb0eff800efeade7d2bb6bcc236ac9775474428afc9432343df43e96eedb4bd86d5ae0e056764a4b4009c0cf8efb4ab08004494e5975766e2ef614f00ae234b703dc5a3f23ea1198409d01c0e57fbadbd600ae611038ad6b4fc6190d07e9a3af630e159074a0a48d16617b10983808d584e5d783c551d038442a58729cbc617482ad5ef16d227162cf77330ef49dbf056c7e66e09d4daf88545f521daea75dd0f9d66ce833a8e6b0d5f0c435ac0649c9e7fb88e884865bc552f5a344e3dace2e25f0959831bc1e55169626d65920920c0bff492c8f8eed4b37365209a09524524e76831b3621beaad08978f1154a5bc67182f87117e2517fda247e4e404d7472bd525c90561775b7b4314a24870ed5e047ff2af5862e4cab62cac7627da7eeda4c477acb802773a3b5baa90ec71865e417bdb23c819c72e60e6afdb8b782a616c67a21d8a2505630f62efac7ebbb45d644229e495a002a84810157e8a8bcb5822e13da7c8574fef497dba89cbe493b340c340e7d142ce5066706b8e7d1297fb7d48e33e636dd0aacbf2b659e310a8af7336f0d83e8e0401ea10f4645bbd9d630440d30f38e6f5e5b62f71a29a168a30050661702c0b027c8250774ffe1dff25cd820a1cc0fb007469712d01f6ae8c8545331807d56b591b672f3d63812b0cc01ae3eef2a5cdcc3bb3cb1c068eb725c560b1269136949ebbe851b5474d90457e7c422272171a79be1e690809c03dd73d4fb610c05f5ae80f36e25c69c2eb72565fb1e918a7a3cb832297698549557b069999b1af38d55567dde667067784c8b6a4091b7808340494bff217f40b757c0c55c0f50b7d1c8efb25d53bd7e68f417fd17f6b65c9731a14b951e2b53095003edee9d5f5a41d108d3d4cd859071aeca0e8ce577f65c4d31527887228fd02b4f89fcc65fa675f523df9ae4d2ff3c1e19070a7d1334f3d1b3a69a85c8506f9af5f32d9ba91a177159ca7cfa225c2069cd94e39935a5264d5e2142d1159a5da44b6c3d814448ee25031e1933f9a5a09d5c24524eff2bf34204706df15ab0d8ef8cdb3921535c767fb249125fdf657faf3f9415d57b427f40ad6cf8a8317494532d11adc69e112c1a69a0076fbbdefb2234798609a843946bd4107ed9ceaa2049a355e6c6c356946332ae9c45cba9da734773221f0dd68f9539f207e876ce2eaec3abdabfc9396b560a5d6c370b3e7b46e54f7dde0b49b03f8f74a281728d3044412e5c83e64d347c600a5ab044fca6757d19ac7ba777aef3322ed2abfee616f5b4607f955e31bfcf318db97688a540daf5d37cb3fa5e92c5a87fdc476be31850fa93c550c441d94a9cf6dc140eb9d1f14b8eab069d037a069c6d4b103c9e4b8116a8f8d3bfe6763ad9078bc03856f520f9fb02f3237306108564c54dfa819391cf924c18946e97a810618c6153f587d3fd21220eb30397cd502be276403bd4560fcfaf50f7cbe057642053969db0d1fee3194cade7c761b563776ea8d41206cd23bcb9aeccdf7c7b159b104df8a8c23b54c06a2c7463d1482f094d82d7f7bb24b334bcb0f0db8f798a392cb5c9d238794897ea0d54623e77c3e9d866ec079bd3765a5187886982df60ac055a42240df68ec37706cb930fe01cdea2bdb63f5776df349e62a7415428b282c0ef97724d525bc2cad672be5645243253fb29027138f2a2825a0faacb8171024865c6e203dd9f45e0327953567dd420bd92eca1f7a4c9aa2ab020e5e5f552805e217d6d857a4c20064c273d5eff0ee14d23e245e6b40bcb41f206a04a76fea9b0de4fa2e08c6d40b3d3e1ddc996d43813499099d9d0de990736cdbc3231f8488b005f5974a896419f111af30129c29ff67824d56b91402d865115334855d1a3b8fd560ed8299380e92bb32763f8edd8947dba6fe5316aadc3fc6fd5e4b40e5c6956644b8c448903e965a033ba6cef9110723b359ef988cd6264a7f435b1832d974b188514102e88064386584779526e5399e07683d5788d740a3a830a038045334fbdd0f27aa5e178a2f1c660ac5d42a95969694dffae62c49022c74ddf6ae3c5899655babdfdda2e55964717b70b269dca12b92f8c3995c48c19684d73dae69e97e28cd761a539d19196447a4dc3805e1300760616933faf759970cfadbe9c848964bbf441e65fee3e79def79747f8c57e2c53e28fda418756b9231a3ff2f807e13e829fa81bc2b44c56eadbb5ed2cd34a114bf6c72498144bd86edf21bb586196c7ad364d19eb32fac0fffda4fe8ef0ceb969ddf00cba2494f9be1e857fc3a11294490aa2424b3b3c83c5e601e4727027186b598d5ccf22ba41ed666ada3a234ab346a80341628ca511f65408670102fff3dc43811089642a2147338fda3a81dd90eaa28ea82a4091e3414480fc893f21fec29d965450470557a1d9b5e68d68d6d009b533b47b044be9fb87f66983d62dcafd8a8f955852a6bbf191e7d489eed666ff29a9c2481d4ab80655d6f87bff67fba28975ce47b9b3523d9a6aa48f9bbc3f915885a75d9ea1575075fbdb72a578264a103d423c183a3372ac991ea13220a21ba87f638590dd5811e5457137b91c53713be04576ba38f6eac36747167560a80e9337dc1461271b1a9f99a6fe8947de43287aa0654ce60b21a702da0d3ad0a672e0cc6cd1f06c112233fefa6dc460910a264f786fc58a78d1c670087f6a50e0405c32e958b721102ffd6b52847a52dca1705313fc402ef9ff164148eec2d2c55e99cba4782717d3372fbc20a4a1d19f98540ba52dec0f3a6bb5cc746fdc4c8b4adf8d8456cc87adbf5b9111743133aa556719f238b91b130f6d38717580f26f3398488ae84aa25d13e43763aff4e355969f13bbb01f9383487c040d803f4974184baa0c804c051d66cfd8f0c8cdf369fb9b97003f2d36ac05035e023b4e208f5df74b13b6db018969378587871eb4cb7f853d00e5db74f12c6c588ca87e90a731d8c26fa693e3e84a6af5303eeba67ebf679b01e8256a70a2ad77caa1b5dd2e94072dd1b6ed3cec6f4e1a327e11821902093f9e8684c9436485160af8cf211e57b58c2ec138b0994b108eeecbc908bd3922093e14e118e885cb92e0840e545f09cdfffb7563c21acf1c05c18681da313a10a3e9379fef403766c948af2118e5624a7897c91bcbf6e432fcea05fed0547b4a9112e5a9f01843246f2cc6c23e4a3fc0237b05b07183e25cab71a363d61225ecf2c086f7099930220625ffb0eb6444ea380b2dbb5af8acb61699e2f3f3f795dd23b055c3cd82139ae4b57ea53de11b9808d3e8de1845879cf190fa6edfd87ef17ad888b8e3790d37a0ef0ce8e75f20b871663ce42693d19a33ee0ec92b8124babf69eb302c7b25e42cb2b20a22ddacca86b8133e3eb0b18d492f86a20f4c5c7fc27822c34dd172bd8859f18a7f2bc86d0ef56d8a25b46a41e57be0064e2a84fa99c1767fda8fabbbeb80dd0cc937622f5ac5e52dffd556f5d190ac438da713f88f3a28bce47306215ee998c6bd1c3250a98d8b2659ee71e1ab0162d394885ee5e4c050392aa6ea58486f6f9dc346a812a87b758fd4dd98e9f7de261ae96e1e9f4097d79fc90d2884c84b4e4b5bcf4a6a4083e55f2b2a762dc78cb70cee11bd731d2a67b85105fec7f5c5a2b7c9c791a3087cd81c3c7869154c10c4d6b59d82728948d98f15e23f0fd843fff2acf65be9c2b48b24d88f255ca6bbd49c552e9a39b6cb8d7cc679d8c0f014c23916ff4c6fdf22ac89862e2a3b2625adcf06178003f52e305403577f6b73d5092442666d922a41f475e70029e960e7dc1984cec58a29e908df8ebaa4f3c69af41248838d8f426605696529d45542c5ac7cf8dbc83be3c9746c3ffd5c9406d4fdae2672f12955b5e9841bff14bfea3bf73aa796d9ae7827468c910250a30587f81818306753f1380b17ff4dff9b86d9fa4d43d486d2e77410437abf7b592fe025e5891d7f0b97214a1805559168c71ed8e952fa55f20551c1fe04ca53da04183093a39d574591428f148f3159c88ea3b04d099f937ec3b49d3f986c25a20c03f3b7385c961c1d520dc54cf02787e71cd74f9c293ba59bfcccc39ab127e7d681fe9fc325e5459ec21398af3067ad34d0c851113eeea6acaacbcbb9662238e857cfc668471c08c19e9afcf2b19049c9b251ba211d6810faba9b1483cb43131790934961ebc5bdbb8e95a8c79ba6853913cec8e6aaf4c954dbdf45866047d2774c6b162e3af65f5604da9b0e9a1f87dafe6f5c1f3a74fd1ae83911250eb370a905b8cf5222252c714954049b5e58ac89d732b5b7425fd62c4f60dfce486e642ec4cfc729f75617cb8301557bde88c63002b2171636dd80fe477432d569c8989102bec0a35da467e4d1c8ace077dc1e0e8cab2089f93e6636fa4c9163b5fff404a45f88f4a26108d7d2d096797b34411e04cbfcb373e683e5fc2f923feb960cf49e8d70df1f0e0d563546dc4de703132c772f09a77bf97468d4bd836d40dea41590ff45f374e20727eba46a47a7a3b4bb5df4be0be3aed33708f552f146d32501700aaded1d6a14c68cb760e2ccc55a1f743b33e175cd85892db9d52009af67f3f70c7e34f979f4eb9850dd6dd1b1a2807b1241f1da342386912973df97ecaf9a8daf51a3efd97e0b78b94f2d40357f1d4262b7a5d27bf9c2980c85abfcdf1b36e204a875eb4610fc3839bdb6673c2148fa599fa0aef887f6c412f94ddd9d60081926a520a746f5c0d9918ee2b6b95902360f7f871b1ee61202f2dccd31139aeb7834e5677ae36286f08adcaf3b8bc3294ce171c24e2dc6094560ff82e59dbb69217f53f46e99666b64aa41bb280c2ab633dc6cab512a1bd65eba812ed1911c7bc97dcdfa3c1754319d628886628e0cf0c59ccc1aa6c2ae725e79d8b083c75c4b16ea32fdfb23c37ff7ede49f79b94fdc480e5971f5be51c1882728dd53ae12423f9ea7f170663df5242844934ea9cfe35431af46ddcad77bb37459788b2960d76db9a77fcbae471e67dabae20237aa400b5e68092098b43fee3bc1886e2699fda08e9afe6a8c82e3aa8142d5e81115a7edaf5945a4b49412e28631a74ac99d6b4e936faac413618c5d96e2db8165113eb64711771c70d8ab1a6b7812c832755968e0bd49902a2f1718372af98c4d9ed3be3baafeb45120c1d955154c6fc615e43dc708187f83842c026dacaee3f296f163fea4138e8adebd1d8a3c9dbb70f7fb8b4e883da640e6f389c562ed426195a336f1c0902ae8ddad3a5c8d99a8ccb63719e51cbac5b7f63d40683dc8a8d43a0cd0b35f8aede3e9d8a89269f97f7ccc3aca2607bf6b85d1b285bbfe933d43747864bb7255dbe6e94fc2d508903bfb4805d14faeb9f47c1a831b0192859bcdd5a88ca43139431ed84df564cbef4b0bfc4e7694b646eb855b5ff9f6482064ce227c9a559f4e4ddec4507c992d7f24463d2b42115972aeae9256bfa0395c80ea4f8dfba0d6cd21d876efc74926507a664f06fe71ad3de176118fc8c23d4910520e4ebc0d66f546d044591c19c8c45e145518c0074cb618c70148a4bdf6f856b2eb383e69e3c57728716bed45d2198e06be2905a7c22c2078218095f85b2242c1e117aa9c398aa6421b373f5b804b3d114f6bcd472a0a22f2aa153a9d4b8e771ade660c66ea0f1c80b75ed73c8d130dc71c025e1d71dad4d0eee782b96572812a89d1dcc80cf36a16526bc17738fdcbe63bd8c4f2457328e8b3e3717c237f5c02010314e138f81242727ad4cd5ba2bf8e9696ab84fdb6ea20833bc2f1c71f1150176ed3f32ba8310aa30ab3c33e5add7b3de595337dd7756b29e43345fdc611fb37409807e67f77a52fbc0a887cba9ecf39fe183861585953d2eb6e90291cf6c7c45332f509232bb12a3a70499b4cae36732c647fc25c673da3ad34ddd151ae42cfccb9ee42e661f4b073768a9b095367805a87fdc355f4d29e60917a08c9c2a75721904e8f54acf3b8970f5a915c57c4a5b3ca749ffdd52f45485b64d8bb64420966a1df0cac87e2e4abd03152357afab3ab712dce8676bb7f54a431bf425a89ba5ac2b366b52d8125a46dab0c2f7e6803f4ad6603cb166b8e1ce0517f581dde368cd85b34a44bfb4171e1c82f3fa46ad0feaf98cc7ad32f6a83dbcd42b18ba0634feaee6402279b4993150b1f38a0eab8d3816a3c07502c2ebc4fd496ec47844658f266a5674c91f072dfc82b79d00d1553633fa0938099af2da5e22851519a37950614b1f1a1a2b58e66f4d1243868875b9bfd6ed056716c00fd2bf9795020fb296ebbc1640064e414192164b3a9f3651161df0ef0a849e34c505c81838baa9e73c2e634f7b707f3e210d013519dd5b7bd013247d2b6b7e35ac2ddba6b9695919248867f6ed558fc8a446618f5e231d9df768072afedfa9b5c39bc96e2b2d12e7383b7f505eb6edb7a99568513d3a98005d3d536856af9571618a790323a10c49039fff8deb2a5d045b08ff010279083bd93f92c60ae40406a4ba8d527822c9fc95b8c7c4b32c8abc41c4e3fbf9abe3c2768762b77230db2c2149432757b762f9794d29dec817789739a92433299fe5f3b39fe1db32e06e42aa606401231b5a0d7c79053e780008721338633860a5b254aa08fa8a4a35e4153933e77b628d17472cd12f3c973625f0d43a6d4f1f0a78d20de97d1a5616ce30201bcee73a6002427cb218e72755f6654fd312496c3095ab2c11130737e76e7a584fc9926cdda6c3fe994eee81df3dd293f19573a69612ed60ace27d402850e1b710b468bd30cac78a5af7b256119a3ed269e0a8abd5f2255dd3e4e51b76c965c588b89e4dd43d8e2509ac8797da0022e81878be5719f57bd8c10e604f4dcc2b6d7352ec9436a27a4c1092455c4d733d7cf89c02034b6167d4abf15c0ec8b34347f7c983535fd63a47cafac55c16820199120ec7450dbb90d7e2a88d5ab0a1f1e19d57ab42b396bb3dbc24c3edf954cd1e3423b98e8884884c5b525e0d678ed91be2ea745cc7895304faff29791a0428b31aa7edbabb486ffe80b9bbe881b843e3fc143f0d08965845abb8d7848c737c1188e121342b35c3bc2cab140759a15828a20182834ada8344e05c7014204739590d083bde6c8f3c6e9d38527ee92dfb1d6c01c101bd24e8c7d802d4d34cf3d881fe555623d5bd9ec4a2c093e7d9f049b76d167d8628209e6784941c6b7735c1419e8faaa86d966a7c50b6e10cf1b16a8f074291c7e0edb5e3bc272bcb73c116a9f037afd44621f30ed65d9466475e7a44c02decdd1a0c1ffb8178202789232469fb592b5d31ab4b2833ea0420d6ef355b88e099ab4299809edbcb59d749701e2de437046aaef59ddde030909200f21105c4b82094895c90a7db44a43df9a433db40aec898a144d3ddec7dfbfc4894a188d5b8b6e99f177dd56bbf6f437082cb6b511ba368c54f04201db8caa5cd6156cc4b6597b1c44c6061f5b2f268491923938b4eaecbe847899b2589858120db681d01b390d67a077813a7f6a0fdacf8b8b69f8f469c513e1103c7e4f164e42548867ae17be9e0bde7b911147172ca8fd561b315a69847a13c0b44b16f3e0bcac3c92593c1c5b0d67bd5882049c18bf8b879755f0dd7018ca195911f6a6ab5f007d0e0124ce6e8b575493950987d263016173e07f42d3d6d26c030b14cbc8ed38568b349ce6c87367a2136b966e731cfe12baa5da134a5d9e65678048d4a21e48f70fa84fdc044ad51a214f843b8c956ee042f6be7200453c3c0a3c0cbbcd6d7bf6be59b26e1f2372de4268b5c6bc963da50c2bf6b65eb722fbb80c62df425bc1cb949c3eca81b4fdc2ad4663a58ceb2ceb059121cdeca66914a0455c4dbecfdb07185a0273249ae6fc2db65e067a8a9a98401d8ee56b3d4b83b6fe02e3cbf88e3ab5deb2a447272bb6e4e0f32a09e1fac943e4dfea35c0e296c2f4209488d7bba3e8ec3f3ac86b686c18127fbe9fd137f7c7cddb7d4d91210472a19ace6411f9ab8971f2079351fc94472397eed2baf486619f3eb36c65de746cea5a3258d67599f1cb9bb37e89c6dc33c7ad149e2bf56b97ed85204c67398d419c06e55c74b53eb7ec0f077d1add090a35930666acc9aef408d40e79f600a882aa997554528c9e4dbc272bac7adcbcd6a681eb601df6c2f684919f2e563be5e828a943f62ef34d5ee03bd2c401241cb17a733ef8545386b4647c1c945529299716651a6259ce0b3f13452e356c3c74e6bdbfe2b1dfa11706f720ac131d0b903cf46305d0f3b9f95f12783a5c8ff11447d187334329c002c405bd11bd15592cbd18518d79473fa87cef4671cc89fdc352b8f19215e32bdd48940eefec371961d6abe875582d440e172fd76fe7392ac409d7f99d1fa7e000bac01a91159dbe9471011cbdac1a44caf21710ca3f1e5b6be7e8cc843cad813005fa39936286c1ada33209c21ea087863b6c91be86be0666513398c397c124d50708c731116dcd0aa5046b99d337ce104047c90b035ad07d247ceb4f73fb8b7f313521666b02ada93326e0a6c6f02d3d9d4b7ca5f676e661181ce8c428752893689a0344f25ea3115db49fdf4b99b347bca9790886279bf92f1e8fdc237353a3402af9e91d4bf0b2e67cca682a01b994babadb7e21882c11a0dd83fb7b6759945ff215359565e85f493a08eddbf56220360b63d4da0565909e74edf4a9a991e840e67f6eac9d88a89759de965031eb607cfcca22ba54e906feb47232badf79191abecffef21666b4034e3b12c0255905873240a986dc302f070064ad65abad99348b15287bf85e43555aad05345cfe3f359a3472bf0cb4310ecd59fb75818a554da6c2036301bc4cc2da351c37cf776ca266393794cee25afc16a0d7bf481ffb27747e3eccd85ac7890c250182631cdc263572b8b9659cbcf95a546bc416c6e0f2c68eac61377b0b12435aeb736f0446c07306b7da684deb734f3238279b889353495b09429306ad604c0abfd5307ab8c86968e01ce72f73a05ce828e3d4e863d9fa89ad600d829e2543602cf30b54ed3a8924af64f214d842ac75f9b79e74d7cc6cca091cb9363a62d9362e4582eb4250cb291cadf9a10253c44437b69b280c2d5fd1c6f27b07bcd0cc261f8c4abfff2f05c8a2036b9c801dbcaeed5bccb60a4e4e8d78d244e4e13d617de40d9ec1a6e542b3badf3ffab4730ef7e995f2a74b61f28b68e4d8f81538b8e08cb7376f752fbd59382837383bd9572dc30ca4e0823ff863409465a35b85b52cfcf789487c4ab21fcfa693f8e92d0852c2652414535c67afd38428363d5c5246441d6bc25aa7e7844638f29c9c2d6faf5b3c849bac3d9c41fa33b58d68513fad6846da08d677b173daad8e9c884a3a7fe7685a47cb736dea54b274068641c9c2de9d5f01c38c69408fbc824824289d17cb197c78d061fae2a693a8b1793da7718d0a45350ab46766faf5381360abde017453047ff06825362ead85d7327ada4e3667d4b4ae4953a3dd1707f7d76154d2cf2fd649afd9223a199b7354301c3d26ed25c5d356484372f6dbde072775543d500adb34d37fb10a1d8402fd3fd8353bb68eb7bc4b7dec2a1593525aa011d9ffff23bc7f86e7e1a6f2f73d0fafacf650ffd2a54269b708c64680c26be2485d876a44429fea58639b97c695e7f197dee437901f43bb0f12c55d78d84f98c4ef45339a0d413b7f4f02c04ac131ff0971ed3116adc7f9309b563806395776e2fea39ba96db3efa9937dfcb54d321a84dcd8ed6361712cd725bdc553549e55ce94b8e060aee0737f742f5bd90087956e17dce9b966f967f2dd8543640431678e8019db192d7d46aab5d96a98fa79a8a30c7594ca719ce84f47aa54f4d11c3dc64b055bbf938666ef138ba905821b0888783c9eeaa524e1a913d7d0ed37756d809aade8b393f27cd6a0d9e819ca9d53759273f2c6c34b40ca772634bdf6e4ee1c512a0aed16447fb30aff7a3796b06ed4af0a502964f7577fa66d014ae0c826e52ddc0734f8304b0a86d3a7cc69b483f63b7b5b97601b0f79d2b0c646e640a8a047ec7e31f09ccc4007251f0d607fbbcfbb4ee8a56b3b95d4ff56e13b0b01a686aa53186fda7bad88edf0bdac3b5b34a45cb7e0280e0d5570f669f553bec4b1502740226828c1d98580849e167ea06f0162c0a9b15ca50de3eef02f73d51977f063c3b7eea2dba9bec1c0dafde751add4795228fbc82b22eaff18f330f2e457c723df842194f11b7cd1ebe622c5c44195ed331c4a85b6d3b1f9a39ee751e93da648894779af2e40932f21b96c51a522ca57ea3dc5b28427d9219522104ac5a871d596204ddd2671dfe09867476f2b225ddc8d32c58d117a59952d9ba16646dcef61f7edde4b5416377d93afd9856f422389726c32869cc86b144e1526d51d433305a2e20f55d03e0801ff40d45a7ccbf60a28212947bc3ea238ba23d30019c9043c7095649abdfc7cf1e947756f34ae31e9743eed1369f3d5dd7e29bfc9f35a6bfb3a462125e884aeb20895f408004ed519e976203a366c82a73d2c2d131aaeed3b97e060c3a635cf86285b07dfbb146fa4387d05d7ec737d7ea0648dbddb5889a9dd871bb50b42561d2ad1668e7b85eeea54cbf34ecec8a98ce2a475fa622881bf733761f3ad524a57d3716013dbdc971fd2548f7e76c7e495aa34ea4d1eead904a8e572af06f0a5e1c4c6bf9bcdc6c8b4d5b0d6cf3edd68f83672cf7a545982c0e1e614dcd1a237ba91a9b3700c16ea372d41e0fa9687be08aa127b712cd097d02c07e32e5757357bf1f6f5cb7361c5a4ebbbc56ad15d391d4c7434545175b7eb62933bd5a885761700b0058a7aef108311a924789532e855fda06c778f40e2f169d23de7e0d3b9205646b911e6e0078e9b8c81e3af5e310ecf0bd630d5e02910ac8696c0b4abf1d42639e044a23dbbb42cf42adf2025bb0469b888906a6b1a4d34e7c510b0dc02a4539be383ff1e015b1241e9b24bf006cb05df761aa1dc215e014bdd18247a943b74cd5f4d8aa2903d32435bb46cce828dcb02d002a7a118a296752d6f1f11f4474a43954c5120bbf65c1655a5661995ff2829cdc97286fc7b2592a96eefb847fdd2139e6daac0bcb4d4b0f69cd55d161f6b73abc5c2c80c68892df891c89e090d6b6eb388b97a44f6ea846e0980c099d0802d684cd0b6515014361a8ed3973aec9bc55aad58831da4dd3f5f2e095c4f871a35b4feed4609c20b57c2790a4ba3cfa35468b64f89c9b92946a997f9e1b6e3cb9d80fa4a13250e8e6ac9a81e01a196fce7a77f2b52e1aa2316e726b3e8bc17f6fff83b84d17df30063c57c80cec5f39c2912411b8ac9fd7fc1a4432ae0fff311d6f4bd7aef0455de04a64435176b433b4b1f8003af6759963befc3f9d9fefc3c4f315dd07a110736999f7c9d7c411a5bfd37578feb08694af7c20be671fd6b048237edf5c6e6ed7b307b3e2cfda5805f420715244635746657acdfc7ddb171c8e0fe9eaf113c1d9fe344320032c809898b87560d80422a6c5b29820c8686f0e7f046889e8153e0425268dee0c3a565600e93709a214b8d7ece8ef74c415bc0067fb96c8898d13c49b68ce90ff50866d978a5d99029125f2ba14c674c1212e2190562769cf2828c86357f54e90a019e7ff91b689da511e499b04c41228c4961dbd3e9ab7452552d950997b7ce266ade0e04e07f8a74a2c039e3140a403787470ddf2fc71e1aa1036f87b1b77155dc9665a1f0d6b4e19f77764066ed8a0d4d514fa591326ba3ce7d046302315e55431cabd9bcebc2d339851fe91a43f67a62669d4404e67b7f531d68d143d18b66b85b2526a594b97a3fbcdcd0808d833a9c1f08b8251f167c18e17e4d0d68480b800f90cc572a7517584bca23a25e442b3f188d552099d585f909081b9ddedbdd3c98e001897f893377560b7720298da0b42e35c247421383445c99dafa8d37ddc40994c00b2a8c104808e711f09bccef757d1b01e4c35f4ec98e46795fc0b6f6f94f467bae072a5e70371353b4b028a712fe15ebe07f7a9d898b6a70bfd99b5ec1b6f131cadf4baca9d9926a9283f20efe561130e1ae1e410a5e8228be2d03031212e1d0418af9eb8721487908f4bf817dda8409eb1ec44560422156a35fb6af8f2689dbc59c0da38ee266088dc5f5c1918a5f9ccf04097075462c03148191de9dc14a8a4a18158fd23ad15503fddf90722eb3c590998211e857943a9a06b5715a3340e3e2461051995a6771dafc5708a282b6540b46ff9f0320f4ef68fc0129de8c0a5caeedcafd82fc42688e8c4b94a59e12333312004744fdc4326bc66e8356cc947f4f941e46ae87fb96d0c26d73e7944cd75a7b3f5b56a86d399dee142c2eb3d83e9fc926e9419d4990c7013cd42c1c62bcff85d5f28a142f1fdea8856e397d6fcab38ebefc1a958f1ddfe71fd514ad09f51b95de2a10a68c442ddca2266e99b6a8030a679f7788774fda56f2316a1757b6bbc6c9dde3438a1f5224ae99eeb168cddfec8838203e8b0b8882b28002297f0ff489fdee9f6f139e0b1bc9b6bbb434a36deebe4beae1ca9422d8f07a923e51eef6ba8d9e615b185e4822ca677cc88cfad1af820e3f655e96c9363c9b479a6991ea249865cfa4b0bdc21ce930e759b8eed14e9536166bb465627615b09f5613d80e2ebb1f3ae7ef42e27346200c06689e3f89128535de3108d5c482e34504e9287510c76c94ffad813c9568ae7cd033d8e05363d42a3bbb98b33d89fa0ddbf06c8e611eb96668c70bf82960f497b88cba6c9926f7d97646d312056be76986117bd970c60c785e6d36981d35205d831d663d0f3393a872945d9d568a58de566e3ebe202a8ee7d35fd54c765004b867d59c08a05f381717388f151560e83fe537dabac34930f98231c9bf25450b0a774e780e3e204e1e16648881b5cee41656f36f6d32046b23d7f3990365eec5c705028947edb1e1db0ad96f5ef97781403b89f4d9c11e2bb1341938edbf492aa56013d6839d1d241618746116edebcfbdbbcad853335e352110696f7c7fa255051024268d2f0c15e57733e25fcf764666d3d0a2d03260fca5feb73c9c763196740a2e211a3f61c51a7f4a8a16d45ef28720df446d261814c4b8c339c76b28dc2af15814a0623f0101bc8d176c9a79f51c56dc9b477d8269b70bf6e807c99d95326835833cba603007e017eccc7a9a2cf005e15e3be2e396af7959223ae9000de1f86833ca666bc9b9c5f21f5fdd4994281f40092bf5be100bc5b30369f3c2c9b12ba70aa73dd7753ab38c42e6acd1d73b1dc35346e8ad4622246789880ba187e9e66301cef4002ac3ae3aa76e1e96af1dbcb6c99156c77210b2b046b4d0403ef9d2539f13a719968d031a2eb5c2b0bc6da1fcdb0f2b25268557f29acee61219162303dc2265159f47a0cb0c59ba27c3c218ff7c2de3da12f4a1e3d0102204f3da573d42d48248a23da6fa16a015ed183df19dd93bb2fc1930c16cf58f31fdad75acf734441e533a8cc9934aeefffd1eb25cdd99470944dd83550aaf363f88eeba0e2420ac80bb257c853c49c50cc03a23d7b305c8ccff5625d495a8c45b42cfc72cdb389afd481bad3ca73e39c6ed2c60736bf825effa03802ba4fa2ceebc5697ed52d1439d577e46b913b45b1c284c2457ef7e6cfbaf214927993388f868105b24f3d2e5ae4f10a1081d62aa9acd89a206db5bb17f3e5ba6e8e763951416ff92c1d0d973756a85baadd5078a975549c0d56342bf8de51ba23a4eeaf1d1404e936a8f784cb5b3085e23d66a923c17588a137226910698207f04108e39b76add62d750998c40b0f2941fbbc38e68d87b66cccf5757036a5dd1aab64114a099e209f7075f4b590131250fdb629983d31b04398981707b488af17cf174e6790152f1e39589fa1d0692c2a577d002b27f17b1100dbe809077c3860c6c2256f1ab4b712e849497d22feb68feeda8622033ecc837ee0d0292d78dc83b2941d87db5e1c98895e26eab1527428b554a99dcec3d8a6dcd00d9a90ba319dfdcba75470ffc6d9bcf5c6273c8311a55243d6844b4870a5334b4c3a44c5d7956c62d40602ab314028a2481f75b94ddac0285d47695b5e1793087d61f46702e67dbe01d2f17bb0b44e3b0495fd8b4f1b096674567e3ae715e298a7a8c5edc3669fa894d6ce8eae15f8170d829aa146de7bd91c6bb46c1f413bd25b002065e3ad052e5a2503d188dd5a1b2adae0a5399479e28be68a473cd775f4be883df372bcb303f3a157ee488a18a20410c233fafb976d5ae68385871fc8a7d3f7b461925ea76a3920935ba4956f868203b248d466cdac7f5b48dd51cc3152097e60c78a01e9f090ceca05f04eb3289b95b2c97b29cb429dee711faa4c83c7dbffe8da373f01e9041c9277135ac88d168471c03ee9eb02826c6c8880c579825a8ac6a963155bb087c5ad3c35c9b518fd895d692c0ffef3b287e8b35a3ea090295ea2a35624890618e357d2de7d680362b79dda020d3cb5531bb332158c9b63c88db84b56b1c4e0e9b906a1c1d41a882f02ce5d4ae74d71f49f61c7aef24804da6be04bbaf03459f68593bcc2117d82fff39a7fc567eb7de8f9b461e467a89ebd5704236b35429436343f19470f3bb99edadf448e26e3ce6c012e72684aba22607b35ed36bc4e57e9b83eadb1017c81ba3f1d4d59e8c3093397e1b49fc03500c1690c9814141d3dfc60be4c50f07502cb4019665e7801f0f7f13496bd4e0b51500985abc4303051eeb80db28b450c774c516912af519202cdfeb0d0f94f531c289d1cc31f772c5e42d927b0d036665e5102a85962b1d7cd0d2de9794ee7c7375236559b5c39038a0dadece8ee36b9da0143d353aa0212ba107169fd5893ba2b0ce6016d88636f5a4384674dd3181f7ed321a0ae48de83b207d18fac5a8311332fab08baab3a6a399af1b0ec753c375e2be91f38dc6aec8089e1cfe6933eec25390b37a1adb339350b12d7c710112d182121c11f32dd11204838fca0c318b5fa5d160e35690af6496a6f1b106dca73c9f17a324f5934a6c3e7c1335d68b8c6cae1bded9400c37d91aa499f493b8b1320aa002dd253b0bc80953d1b24e390b3af3cbaf925304fa83a2c93658aa2071d002a92d622842052f793259f142457749a83981db831de8801301b5015c24bd771789e68597fe0bdab991f2ca63a6c102d630b7a5e62287f576c6308b0e41014a1696367bb19c69e203cda14556646bdbb392af9c4f170d5ecfe957d84e664bd771996a7f119333209613e4f063d440dbe92b1c43c4ee92edd2e23eeb0d78f052905c12e7038019db40f4052ce4ec108c4006fa76d092f1223a24f0693988b0f3ce531fee045b7af6867eba5f54f857d3b74c152fcb7bd54a513aa9c8ffdc3fe79289bf5ff9d4b0ef0e3f3bbf8edf4506f4eec161060eb31f8c7caa1fd2d16285a78f99651969a1ec2c2c40e89765a8ee84449822be874868f47ec4d2a0bb9f434136d96dde69c2da38e101bff176224819173254949df9eae5ad82d755278a2838f3b53748ddabbef465317a6a21163fb2c126ffc394c498a59c017ccfc8642d119aa9ba2235aec5f59c1b3df323b3325e314a38324e34137718e475ef84cf4ccf47e1ff157ca5c4ac62937aecf565620ab218bcbca6ea36528776e423bf6cdc865a9962c9c4d0f95d1f619f44cc3a529eceefa5c33d96508c824fe0d640f9e39c0912e7489af282b8d9f4ab18ddcc41df38f13d8bf2e4274fca0ae435466f4ad55101095213a4220d5546d7b0344b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
