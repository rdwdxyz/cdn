<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"318109f527431470466cefa5a87dfb877c591a1a65da8f524f212e118ca3049862362f4fe8051f40f1c03976b31628917711360f537877927f1e043a7c46142aea8b643887599982c9eb95dc2b3d1b2cdfc18e6895bbaac2d626bfb7eafefa4f1358b452398a60375b41a922658f58c18cd96751a9579843f11c22c8ac4d7073e52831c29df1dee155a35a2050592988c10598b6632099e0895c384520a14f986b9721dd8383929a981b8a84b72408e73ae73f4b6782f3fdeb551b1ec1ba8fc7d6d11b6813e30d64f942456e57f70637d2288f7f6d5b783e77032ec7471d33ab238e46fb971a1d6f500dc6cdb01c8c28608a83eab51ce9cc9dbb9cb5f34dfca68f9f686240288dc77c48d8c913c33738545c48629e5fbc7a6e6cbe969ca1dd1a3fcb4cffaa6e8f5db933b4a735138d2ec2a5f36ffdc0029a0f8e0d19a2273e7896d2501ddc276e2973f269fb0796f4647cbe49f4d95ae58eeeae91c38eb68f6e84816c759424e7ca45bb9c0f5d5fca19da25962bc401eb47d14e39d2981cf87d292860c39863e9e30664227e798a5d405d9615156fdd9e3f0949fbdd92adba8907ddfb796bce4b203b8a39e79f511cac054c11b7fe4708fa13ba526ed1a8a147729d2b9e9b44cf26132e495264bd56c9897e6fec06a1b62586eb156d645c3ac9482714cd7413f6a3067696de8b58330c67c6a3caa2f68965f90b8bf6c8f7d0ec3bb1e074e715ace7faf9ff7dce8d941ccaece64fb776e2e044f3c0762bba8991d64050060043049053a712bc21841c3731a25e9020c96b917c95d1e43729520f998f7b455fe3aaa202682d1d892c9f1ecaccdcfc440f645a75563edd83c12d309d9921d433ab079a7ffaefc871f4bde919113b54a88af6fc2362ebd857ec55c30110ec41bcbfd8acd573f7bbf5dd522e44acb67b0c7385879619ec54867c39d851f5639c92496350869d0eb8f9d5ff3abed2692742691fd1e3176f8fdb0d6f195ad00ee7f070547886cd76b4066565abe617953d69ae174d8d72269320f02826045e6cf3ea359a276250139419b95f4a62d23d05a80c3214a571898841f92f187126fc55f03f7b31e742eacf00bb9b8959433cedd75d6153bfa25c1d3460da4900bc1d07d1281a66308323eac4cd386bab857405023c02115a893a4699b7a5a3dd5a40228383174fe6ef10256ad561aa5cd8277de275797991bf8f11c290ef6eb534e0c912c802a262ad32d0a7816198ac2414f85896cbf54244f89a695af5a0928bf8991f321b5b0c15daed953dff1523470ee1bd634d7f94a69a6f402ae5c8601b138d7be564c996cb913383f25121f4ec5037ecaa2d8bd0518825cbbb64dc3e9b9adbccdf30d3bde41e07652504805895eca3a913f6dc974d5405da985e6018a93a4d5c0f2c90e3cbba8d04ea0802c1e026469fc38940d7eff4f51d0ac77f82c1212dd94c8eade110105c0a2c6b1e80a977735ac66e573c5705f1966f54d087d033e9ebd6c0bf80bfae5ef8d2355d00ea720af4edf48f3d74a310eb9952ebb8043e60f0a8ddf959c114485936dad912a0d1bbe79f285aa79c5e174d59d2666928a61e3b0bbd2a209df275d99b8fedd65a7415b1d3e17abf0459143f6276de330e212364a298dfe33ad42dd452f2cda301243b874e22e2596ba0503645f2e5bd5cefda639037c5e528199d5d2afe625e4aa58a91ff701feb1a47e896880d7dfb72510c96fc3513fcbdfdae355942265d404c25a09e2baa59d4907d77e782091edac3226fb1030ab94a6dc8e6a7318281d83edf2494ff56ba51a5a364316d609257edffdd61314c5afe18a89cce79b4f91ca109444432739b04e3f06cd8b4f7fdd53d0b7c1675e3856d938ce39831d4218dcfba4ff8477f66d12f3f61367d2428ca92b5a4f6ea49621a159aeb3fdf1ea329febabdaaeb0a364e9e3106171510f25cb8db845d6e0bcd05f83d22efac7f1c0327d4e8dd0caf00cfdb9fab4bbf568d0da14f9f5980b51d69e1b5cbee3fe26396ee9c6018d4fd99efddf882ac6446f3c3aee433785f597809ea84b0a71225a9c93e68f729ebccac07f93e4e002293acb49a2b66980b3f6d2746171b0e10ec43dcaca9bccdaae414fe340e58d14d689540a72fc943374ef9939fa641fd6d8e3ba32ef0f53d360cca52dc4072cac116869a2d76b5f2a7ec76c25a8dd88eea949c4ba1693cc5f274f17b652859054985bc9a9ae8e596a140d7b3008d9d41262de92519222e8faa9934f0a1ea3eb46c083c46303cacb9809ff7c6ebec6e80ea4ce275465be049e4accc12f4a2a452f4cebfe28022f7f182e745888d619acbbbb15348ac8061d900b23a4ed738564785ad26c4a280cdcf5ce93f5c7fd4e14d3030e836623b49d976ad74876cf9c761d1cd6573b66afd70f53f7b65609ab0dcf3717efc789fe5f300de88d665d89de3d96fcc4148a3721be030cf0619634ecd0ac71e40bf17f699e9bcc8ca9f8030cd039ee6596219e8fde2708953a704efca3b484005947f4d67058eddfabad01a431e00031f7629affead28c258259a535dd52f47725e80d2e1213b183c5b710ac3063a887e926603e9d39f8fec75e5317b2e1f243c709d217922e29bea9fd842295dfc2f21aad9c76f9caa30df9d90c0c72b9968c8bec39cc25128805a937192bbc3a180337658e7fb8374a7c4a7e103b2f25e6d36a634dbe976978fe768b03cb97b7fcfafd214b969f7ac6b962c18559b5e28049b34822e342d2f4a78f809e0b3a42349313964d92e125f311496d2708bce9121ee181e2ebd0f4494ca2cafb2557afa63ed17ccd1385aca686e4d0a567fe4a74449118621ca34d1b4c8485f10d2148d6eee15ba4fbf81b279874c09c309c6bb373ac27fb4f92079c856e3a298cf28c8fc5009d19e3ea67408d341b53e088ae785f4c695c0fddd224a72611346616843de5bc443caa086080bc43cef9742573d0907446733a1733fc299ecd29a5bd44674b0c3a5938fec78bfe58da973e1affe5f2f30adebd85fb052b601e112d3bfa6df170047b0a8bb4f015508267abbd2e758a9103e992b0955ca635f8dd998ffd8f4866245b8d704767f2b95b1201b245b3d857c08ef2fdc0c203ba487a15627331e5dfa8a5923a8d5d7cdc3bb75ea3324f20e8413e522a21b005870c2ca98c472640c6f45083f4041eb2671e97428968a7771916ec01f5313d3a2d29d464b251d962744b0ff6c6d942a307d8bdcde39c319ff82451a11582c6753a14de30d555371759070e69bcd0391ec25492ee58e038751e74f267a155b41dfb2d669310587a6b3e6d9d9a1f49e7a64b7291dfbb34c567bdeca932348966c2c156388592e0712c27b84039ed433792b5517cff2b72f024b1a1dc9c8b933dc650cd63c322b3f444f031d32ab07bd2a338465b25815750c4e8c1b14d470cd02d2868b0da81876fa184689d558cad4cec9a555fd37c5b496242ad9e1bc6933965fdea3f2b432542563a820de6b254ad2339c13db683e40afc40daa3d164b68f7e56f93f01f1abe42e4ed9ad777d237cbdad1cc2b475e3cdf0e3623ca62624e793ff8cf823f71abc58017c08b867f1812034f139674fb463dc8848dcf989ed5c0a82a652cbf59e72e2991981446af2a733c509648f1e099e4da9b79f309a8de3028b475ca8eca379b60410be6dc6974b34d9c820ce861cf7e1365a41e2fd0d536ab95d1282255cd2a32bff3eb3a67363cc0ddb286bcab5bc98a9f87403b7d626be6f7352c4942a18c845a7b74ad65735458b854fdbc8b21e59ea3b2c31d78b65d04d79993ba44e0bfe67d778ee5e24dedf8fb7a20ca429486a3741f7d249e22c07e9d0883fb8f6dd24924674df97f234157fb1254d8bff048b05028591ba06b7b4d5c1e89947c7954e6d4c6cd0feb3ea23f6dae1f25608610b411c8af870e2e8b24d30b48093fa9aafb9273be57939931e75c5825a822c70b9ac00bd1ec8b608151ae419af33d6f01219c5c18314edeee14da05d879a9208d96c415a720808678e27a000f516fc560be3f66655b3232115c363b5ed4c1e8ecfef4fd82317f3ff93acd6db27f37ec652f945b44ef8342b3b4bcad72172e6d9fa353cea50d032964ea47e9cc644bdf8310a464d9a5ae1fd35ba80fe3ebb98085a0e026f28f913f645198583a75f60cbb84f3db23aeb4db193252453908614525f3c6f176b9ab581e8b54d48fcb25d22db215c94466c5ce6a75b0da2e2c8d7f5016e719820e5c9d8aa67961c0288f6ac6d88ca350f232aea40273b937392c9bc1fa14be42e8c48dc0905dfb2f57ee7c3557144c1ca8ddd57a9365fc3cfcbac12b28ebb261d5f8d57fb90ebc0c337364dc3ae5f86c43c6fcd8b1ceb9eacbacf6a4fb84c2134ce36057db97e3751ceaad2380a9f17365dfaf00f871c99ac6c77cfa8ffa4b7c42df81fa8086a62668aebab2ce0d93cdf8e4b7d45bdb444ab6b61df4e26ba76db959ba3304aa0d76d124a2e74c77515084b6074b6613dfbe01cf7cc2e3b36f25f74057fd394ba447f94142740dd50a00a2119e605fca472867e4cd281bbd377fc3f18edbebd3b0454db13376cc0e8633c77c86342afe78d65ed4b81964edd7f1ee654ac0f634b2db4bb3640b3e3dedeab84b9b0aca9aa51e58b0e87c8ae2476bb8ebb5455de2c5b5b53fc2d8490a5671b229300edad4b10fd445ece4eaaa84c89c955a4c939c8fb616cd3c03ffda7cbdcc26b9dae390af6e0226236b09e72d75ac0213e70999464103a88997dbf647bafddccc2dd1619987fcd1a76d2b15a69b33a3806c4a171b66b6678e24976cd0240ec21a2167b1f576152dffc3204c73d178556a34d8ed0824eab9f9dc7725f69d924379fe33d847c41911b502a19427a599647be3f09a26be56777685f17c196baef8f5001703bb69a92b20034aa9cf7eff4381180349172781c6757b78dd0111d3381e21f1284bcfd411332496107c46ebe82fbf40d38f5b71c7feb9dd6ff465e504cc9e731d1979e226513f29c9ee32b9adabe1baa8f81805b11911344f7c0fd143a3864a03d5566076dd383d457d93b347328b01b507c52c3afd9272927f80719729682ed360bf84e622f72ab1aa511672badce0fdbd539598ae87f0cbb70d6d992e23e37308150b94b55e9f20e7fa7721bce47e58eac7f044429f5e1d6a12bf74df31f88120fea9948209db751e5e6de4f0c5976a800efd75cc54bf5fe2159afef130afd227a5a81b1a4a392a41f9a76a6363d412d467c1d6b41432a0b582bea93d9ae51422aca10455d296a7577d93605d8066bcf6fb536a4320ea7a72f001d24a10cb0ade7d4fdf32a60413593c9c66695af1b98d7cb399c28b25c148626e97e1ec5a6b895bedc4e8798e84900f7a66ea6a36b495b466708698e825ef5d32f5c77888b0d81bf18b3c489e319cbeec20fcd36b65a45a210bea679f09f86ee12f2a00afb4f32adb6976054d66b235954da5c650a4b2d6d64f0688a1eae213f960877f4a17c5456d034e71534975f48f4cc941be37ce3ce491d0003c87e191bb431795cbf3ed0c44d95d338d7073d95ceb5f865089a279cc8c5288a8dd482cf363b4489a83a3ceab4412e3ecb53c78b1327cac0add5f568485abf7cb84151565474e767ab7be1f16c8611df112e348a1e04934b212f8063cd43e0997a53b2e90ae5eb599ff8564f466173943fa000d261e642e06bb29395fb5f43428de00319eee2ccd0813cec0570ae100778a7903d5597911a6a6791d331bc823b60fb421814adc8c084d5c471328c66dc5bb180ec6a34e6464b2fd0608381b3cdb7f0a24cc1cac060ddb032cfe19db44f6416394d97838791efba4df212e97ffda214b71df0f05f6f27ff7d6d527a916c3fb78f1d45a5baa40d5a5c401e7ccaf475dc289ddc9d577ddf283e6c9a2f73d0a891817ce9c78f7de9943dc1b59aeaa2718ddabdfed19cb92e400a306d0072a2f49a9c7e3c8a8269ba8f4a87092fc8d95acf8b965278aac61b3ae1bff08d32722a5637349c1155b1355f394e015af3fe3d36ce42488779377dd2f2b711f3007a764bbc29ad89cd99e097a13da157c73d5fa81825e35bc27600d4137a7ac7a1dfbbbe99d7140c7b1af1fa06f6455527f30f60337296e6da59d81f1d9bca911f698b99ea32b9db6fc562b15857d51b727121e8fe9e1a4c85cf51972b88a656e39ff8c6c76285567c4534af2f6972e8dc73407102039268178ff48a5c653431bc4dbd6077267709463a2839b96779c2963c26c75c50fabfefe96a63ef9ba34bb560e674f62f6abd63348cbdfa184560bd635878fe730dc7c8da393e5e0c4f657d6a21205453c01ab11ff361af5341f210f3592c6637bf5ed2c81c60fd5ac66ce9e5fb8e76710186e0fc3423359a74aee58259007ca6481c2c71c26c23db09a2ad1dff44d8fa752a8d807eb2e0e94fe9c8bc54b20f6bd039242036ba0c51ac40ec8adbb8022f61a75ff4215222530f5f1e2bcdddb2fc90552dca5c1b519f0693a56b6635474a85cc3b4ff4c07417724b1032d48400d74c58395ff825700b529f3ffd97cda4cc0296048ff9a00433f57c1e96cd31d915f6038caea302351f253a0a31fa0c94e856624d03e131fc60abf70e4eff83281e2473f0544b37e5f8aff5d355082a3d4d18c97dd4a4024f81a6c3be08e9c05cf23a5a9007d0c93ca503e23fbb0fb740a17ab31971017f86443acf18b887caae70f61af0aae1675d55288d8ba347a820d27076cd02d90917512d1f0871dbda0760fbe43b6ad988980d520ece48d7d579bdcd074f35522315d72f70f8c7270b5ca2b26a86b62898e78d434b5736cc2f54c80bec7e0c4a8f39e6390ede5ab02236a73fc23c5c1df42c35a8479adea613300b3be189df3ee4d97e39fae50072faab49be3595c780de7103f25e1af8a400e0ee4af0778bae7efda5dc6ba187d299090431fff1b64be6208a6d286b2a489ce4621c0b1161eb23485d6266ca7ec1b758bf798706347f41164652028f2b9e0c10cfbae6cbd9a483518402e3162c511024bb04c98b820748d1ecd14cbe34ebf7d7ac8dbc69b708a6b1e068c13227d77e28515454698bc98f0d914e9765d002bd3fbc2cee231bacf123b08edd27d3d0c25f396e0eab689f1660458d7b4046e4eba0b55ca8657a832fa783a8d20208d011247e376428c5e4326164d6cc3794abb52462f5cdddfb0ec7a2b2521ae2f7f8d0d9091e5f48b8421d7ce3d131d4c40deb3152b5eb720984c672e1c955dd0e6a9cb026b3888f0fdcecc3e5740ffbcec5753df2aa8d857c81418a5d4fa2779b0420d31e33623f4d7ada01920e275d17241caa466952e6ba9e47e61434a263a5d522b3d59d53635a583e3373a1697476e063be01fa0cb7eb78a88fa81323d99887da1c4c99b652805aeaf61b5b4bb4abccbaf6c84970fdfc3d04589d988bc595a1883cc5fc2c1bb9fa251468afd73085b30c2bd308b06fcbf14874117e045106b0f7a86e9b4c5e4045882a7395f82035c6cc1fdb86c4547685db0651c720beefdb78d518cee085d166fdecc6e93e11111bd072b7ff3636a87c842582c30ce2c975be95b368e9765a3a9f424101d04df9ab5ea7fac89cf7e773826870b1ec664b7e7200b1db1343bc2b2c1d6cf5ee003dbbf2f9098bfcc54752d7469f3cfe80b7cd047ba3550670fcb263c5a7cd42011e6293f448c4c4ef1bd2cc4bd5e67207e44198be6d08622dbfff1dcd592ed16b4fa53a7523698bcb0c64f7239c96c2c23ed64573f3fc10f7419e85f700e950180e1d359aed95443c19af3a6b8c534ea16470e0aabe1a608779f9c11116f1eb2bd3aed7832c2e0e84319e587ecdf81fcbb6c9c0023fb64a813b934bd8f7ac63caab0c99900cee2b33efdb1ac955954daee7adc981a44c960e0871ef1e29d900c15f80434a1cbd7e8538fa00069b8caf84e9f18e142721e9f41c1b274fe20ea505e7f4910a7981ca05872c86e0907f034f279a115e00e8856f3938941a54c14fdf5990d57d28879ca083d2f2a8657ac13ee31254d0c78c82b64641d3fb1e873507447fcb11f0ffc56a625f7794f680beb51a6ba20d0ae5708a880fe749b6cd7ef7c40f23c494a72cb143b00262372b646c759923a7d54f7c66e5b686696c596e06420cb071f6117000da102cf428c4d402796f750be5d401a5e03d2122b4a1678e057fc906e904887bb9b4e4a3535d12449c571d9ad493c2743405f35ad7e2376fe1470d37fc5b21dc3e60b06aa20a610aa5e18d459ce7ebce83588278ecbf287aaee801180f89d1ca5f1ad63107723bb2e2527ac7feb348b211afd5250e2641a9e78fe5c1a5b923572befa36b9b99a14a6252dc6cd8441c144c5356b171bf64845355ddf51f1d70ac5efd1c8d162d35fc6a7e75f38cdc8051acda26f2f1a196afeee6c98515e9396ff5ae68d162729a9b87e839de0d4dee55321439797f690d41e29ff3d3e50d2002fbb22a59f5b33c1d99b16f9e59d000e9ac21877080bea4e3bf9ddc39ad5bd764a56561dd1e7e17f72ea9abda30845aae94d9a6da0d3aa52c659648eded1d80cf1becdb14e577abd1fb3b0eb7af235e3f8b5d58cff85a577ae464e833bfb95f13f46c05b2775bf8a47122ed602a180324fd43ac015959c9f8eb9f1954f27d7c20a7bbe5d6f19a868d2f3c1ca8129dd0ac34d3af1a266204c73b66b9d563785f787d6cc3c65fe382fd0c3443b93203408c16d1b92793e49d0391858e6f8f478a0b772b768de69ba04db3829904131a4e09a440a1caeb04344ae234412be93d823b4dd921769ff07ef95f36df34aa668943395ceca2d3f7cb6ee4ad5c035f71f84cb4d69454c9685db9f3e8a34454bc9fb567a2af044befe350f0db22e1ea4b5d1797289caf3bbf86190942342ad44feecaeda28cd7b746f2b432bef9f2d365f06e3a722814ef6e0ad9045811027702daa282c092e7524a7900e13694c39810bcfcaed2fb77f1951bd43f14de0d58757d45b881626af39cac8cf4697b149fcd2b8201bd4f96ba9053aa8c5f690f29c1410be11de239708f5c2e49726cc2b5c2d9fef3c4a629ef32ebc8dee81e1e4ca28acae8611fde472642ef3745ecd5f16a567a87d218778dc6cdf1a0714002d6ef30a3a42de2b641f903adb09094b1b703d646a7fefb8f8a805fb77505da78eb7cb3dbe8f48a4a3bb02c4ab5344802fdcc2045e427ea89a46080a49fe186b286acea343c3eeab9267a752ab3873296cf0817e89011d30e8628d76bd1b64b48a3b7e7e815e67b2dc4a42b79d66e959be0f7245a331eb086d7f7a6bf352040a73b1aebffae14d0d184b57144ce80c9b49e3ddb70288f952d841adb92586132b9f9cf5873097734b818e75004fc25522e85cb2d42483e9e95d32f57449bace3e1f26231a2bbfaa646b5a2c80b52ac7f408bd4921f4c5e2f6600233c6d988c848d70ec5b5ce6733555afc1d9513206747a1774ce696f0e530628f8cb9ea36b5f9e31cdc74eade2e324817d3ce0cc390cdd064beb82d763dbf0b4f5f02c10fda905fea6fdcd3c2c688c2333804b1962382d3676ce50942e8e87af7468e6ebb4a3df81c40f5580a9df443ef27c5998811e45e51750835e68ab483b26e5e6da05f3bb8a3df4af511efa511f4cb319021bb5494deff6136255b76910c5b023b3a21ab51bfbe55f27a6606082af574d2849e1aeca36765adb78a8990d5169cdef299a30d853010e1789510cc52d5c8c80b1c6a7820be7cb859a5d31f46e0b63dd4183c3a8cd0cfeea44c1e7db4e6b2688cac6de8761c7bb0683de4709cb53f0f5b2023584c3582cc18a9e3dd9de71697411d4d987c2d3932119bf9f2a0e9e39aef7ad7be7c23f4593cd08a936d5e42cf59b1f7f62f1443e93654586dbece54da94d5477f6b30bfe6f0f266d44d3e8e482d1fab7d27c1040bd32de3f00d35f736b4f157e1f1f7a05e48fbc1edbd362e57fd82805dad6ed3882abccd4e82c1baff0c764eaf945e144a128d433e5b8a8bdfc9b8bf9dd89b9b77a4fc8a3a35cb9b034d82b97fe3a6b61c72b11ca5427bafdbd5c5492792b12cad7a9bcde6c81b0984fefe6e8f496e4af79291e22ca527036512e774f73680de72698cd0343b2c41a5cecad1eb2394c534240bb0a19c094576ded94579e36e3e31299418e398f213122db4dcd2f10875923aa490bfcaf6e47d620c13cfb5d5d6c8e5594a1f836113c7254ec7c30620d3860a7b04314084faf53a5e13e063a0cde561656b14ee11fb6c4e9fe907a0efaef7dccc94e8012827bca7457ec93b94d1e94f370962babd7c48bfa46597f7a543368fe13907916f84ae7d136e61a2d83aed9ecc2dc0f7d44a6159083593e0d8d6cd3a40a59c139d7c11639b9d8718f43aa97f3d43a51c0af181755b91a629cf1a06f5a43242b2f4491e44afa68dc6d930e98717e1c59d5e38b0800f55b68e7e1bbce8c30d4bdf02995cbcde4060888a45a48754290c02b68a8e005e97cdf194245900b675e19c2e20609e8e6fd2ef2faa0fc2c2add14fc72a9151f0bfeb2a643abc6ef8fbee3d0107ca62afb2112c65f72e321e34b031a81da31b59887e03cd96c38b3251faedfbe7213c312707bae7655482d55d6778f4d1157a796d4d5c589280ff489bcfb9a0767f9c5b7f3fd0c68503d65160da6ba87f9f9e84f28d54cda265c04dd56c3957b97c936b36d08ecd5ad556370c05dca169e0e77e42e65ac7886dbc37014926839173efdcdb3c21786c60152049d7fdc1e5acac12888e9ba472cd18caa803e63baa9acb152053c541bdf8406331cee38209b23d3e64c09eed83daab5790cb69d2ab48cadeab49e22b988d5eda6947f5f49a72aec3ad1eaeb0278a9b4ad59cb561c3749c745d4debf272996bff389d93fde5c5b28016e4a60227cd9df77390088a9ae8dca5e094ca8d848dd6d6ee899dd1fcab112ea190566ce83d7d55ca872daa76c8b43268f49745cbecd7945e1538e50263efcc0a86e763a847c93023f10606d6337582e6cdf5223bb4e960d04b2325b7545be104a7407093ba791dbaab0ee4e1b5c96dffeb6042db3e0d4f38ff36ba4d1149f6145117ba4ccf50dbd521cbd9aa8fb15480fecad318de320915cbc92bc61342c59d68f5513161ccb5731f0093a6c336f0391f5bacc265d88f5538a8a2d131ba4794657a4748b8998f641caa6a4745235f2d2a43b7b7f3205d000266c3fd34792f9dfe10eb2e61738132299261f66b7d35bb83d469204e15ef5af6b9ef0e7625dc0853ffb91bb7a871182477aec16df13aee4496ab70692399af34176edc0c29e65a1664a546c7cb85821c5d33be419540f565a9431fa19572bcab8d09a3db47bf3218839763d5d48f17b3768b8b7a2975d6744c4e0d5b38034f8ee10f57d21f3b4d7ec5bf99c6e6662d539c3d87016934524453e34532faf9db9de8c01aea44798c84a678e549e4d6da2571034271899942b0edfdc2b46ed0aea702492748795abc6babc02d227c18a084f4f3516f3983299bb49863b5cfd631ffa45e71fc0bb506afffe25844debb0d5baa1877f82d2245fe49338c3610062090f186c980a4eba651a16c7c820ef5b478fdc1304ee112294ecc3e4323ec2b9faf13ed637fb60201390c9adfca20b449353b7ecf843c63eb2818007be8f7a850b63b5500672665f4db8081885604de51f33e1c95ab1f410064720dab1cd201d453ddf70a4b9b8f4b7b15509e5ed80515dc36e9a3375d91eaf409336e6746b6377b38064c9c89ad2b3c877cff792f59cbb0871ae00dd073721c1ad8167d15c064b8df147fe5f1d16edd157f5c34a20085f4176db09b22cf9768b1b2c215561dc7cb9f4e54f51652fdf16dc0741fc9b76538665c6a9c867682338aceab91efdfbe728e256593c1fc551362e2a31355160a77ad1173ce271c797d40dfa75c0f179df02d6771ec1f6dadfc8a5cc4db99adca17e3a02b68b70a0b796fd58be6b92e3e795afe45e92a9c69a7c732652a3340a3e6e207c637833908469d2625c366e1542f128a57270d937fa1cab59d9b98f0cc7707765d2f3a7639715eb359bbdbcbcbbf5522dd3a96153a6177bb64993a6a300d4e5c7e8a11b0156a75d2f84355f138bd315c46418e3febfe6cba62cbc3ba4dcc90f378086d7954d1d2d33055c1ca6131150660eb8fd5aa7a4c954e0ee5bec0f5d976e960f98e6e8222aaf3f80d5ebcdcb034430ef4d57a97df2c89598dc0f1470e36a3d93d5232c8b27a9614ece19adaf6be11db824018fff16fc431f5dd845b8f5e9805e01cae18d3203b80805a2796c8858c0e25bd9dc1c9d55e0ef20cbd9c6bd30e1cca649f7f5efa7e887c1636824922b157ff985f02c81c9d0f347863acde7ac54de20efd41b930ef7a8d865f7fb1a8a059b0b79d1bfe9d7f3c6d76af41c22cc86de4e5d41af3e809d3971c7dac4090ddd6a1f71582f57cb8702a937a329a6edddb5d979e89e362eaca2e8896f4685947974f696f4a39c2ca1cb9aaded54c8619a7186d9259ac255cc2b2c919e507a0ffb05f521a26db5411ead3fac0d648cf0da7a65763b88f1774cb47136cbb455e2a96fe085572498abe11f54c18d2520cc2b6cecf25f6b8d149fed98a2a46ecf7b0d973ca5aea82fac04062ea3e2a58865bab377859e60c8e125cc19b6973c41367d0138594713fac0227f2b9bb5af17ed5e646879ca186be9703ce7d3b797dfd112516d301ad88e72492d24cba80ee36b36f9a8ad5105860450b47b551912a08d2ac8a7f9e6b7c3b857f3b55db9ccfcf90e901f64ef4332b5078708ec5964383ff1cde4aa7a053e8cf15fc6e67a3aa9f99e5d06770709f030d0ec7ded61f607189558e1b8155024b00bb2ca1229febc2f073de50fb496937981678398255415cf5ca1be2f905a358eb74a9d061f326938db1600aad577090016cf0dc62f235882dd4cec1395606a32d32d94fba11ce93bd0e916cafa03cc7f54f1daa64cfac9c7a27f899263a36c37cbcea3c100019d8e267e3ee55f683c30f8fa7f08ca17f15bccb4e668d35257f5f6a15b3ffafea4026f2a6c8bd3c93a3e991bdd9420cf916a70a7397f07d012348b3798592dddcac2dd2b4674b75d2d71161c4eaa3e1d57439d3ad27109312bb087c6f8155aabb789d4a597e448f4702acc880f88531be4709b12c9950eff841d3ead78267803be6faae6cac360e64ef921e5312ba08e6abbeb1bc8949464e240cbd86c139b1a1d8cdb5180b21294fd6fe861942a225454a5d524ff10a64f0299e16e56baa86cbd9d34bc68ca2d9ddc375ded612f519a6954c8d69fffe1e33845e9d215381545fc03d43dd2496748d3c9ef6d341340e79d6830b738aaa460410ed8f1c2c56a8e47ea89bd8dec461b5b3d09a375a94d40b0f8f9030f5ddb7fed0e17159a0fe0daf49df9d81c85be5ade3ff8c5b78da68b4bec735c898f6da8d9ff43c431e1c1260ae43479b37555af0bbb08639c937cf8086a7bed3ac1a446427582cb1db362d8831e9ed86b66999cd51fd1b91d6fa1bed0e05651ee2e5a238d0619ae611e559c50c6743fdeff8a810d397c364856043ad2757019eb24581c44059df70b5d74c5603c67013399077df7afa0392ddbd2fc25fc8916d1cbe2cd54fa77976aeda38127471f8a96489b104d33abf4faf329afa959a0aac2c5f152f96c50065b6c0ff2a981c8cf09dcfe485b87f479ae9db5a59e437ae0cfed80b5ab497a096abb8749fc577b3c73806472c32d394177d26f4ec8680e254ad62f1a81348d323841e6ebe542706e96739398173b18ea47a24c33a1722f390d948842e2e6ef4ff03b7503ab5563e0f60efdc09d122a744c316c48762c0267526798ccc1e2e1e8f60f322669557b8460543236f95bfd98997f02efd8bcc45dfb1bdc8a696de306814dc812fa52fc137715aaaa59166a96143b0a1989ad3f0c3826d36cb4f260623d1ef22191576f4ab702bbf9b8110019f05103a72f79da45f8d43d5597ec685191b2194028935c31c6c18f0175910427e8dd00e8419250e6efeb608e9d56cf363db48ea3d9651bd90013a2b0587d80f839b4d901971784d1669285b41e3a4c486dbf97fb7f82afcbe85cc3982e00afcb4eba871203ea36da8d1be21ba9eff124951b7040737d583236eabd78fb0b195cf2f62fe727626e3325f30f1f6de784e5c71a22b5c77c7ac9a8d4fc4cad5f2d15f949be422b5c09443b4593775c2a1fe78bef9f191e6296a539c734b980c6e596ae433861beabcab3b8ee5bea5a5763055d294ee095adea50bee0ff59aec41fefc8ef8d94e53399ddfbe2a5658f3e8385de71d36eec42f4c5cf574e08516bd363ad56d19f9660564e756c42dbfe6fd95b123ab0d639ab3387e5a9e256d5ae40209a2faa9fa692dd3235324a7dfd5fc314c5d5406b2594f2181c91961b99e17a7d52e51cec2287e458b4239c1b546b043840efe7a5f2e2bcad0dce7fa7d77e2826ce6249eaf8af9f9cfefb3f7e68e13501e688332e50bed7f5b0363e0f979bd0d92e0242a0f24acb6086d9a56d399c0f3151fad48267198ae27d7517e87a2303db87dda2660f15fc3e6931a701adb5bcbc70475581b6c613de69d4edf2a83027922f563f6757c569188639b552f6698d91453cbe33319eb42df5019d2b56823e3ecb3563fe712f5911ce050633cddcd211036eedb741071380a8fef7cbb22a05cd908cee55ddf46cea0074e92cb8f468ad5d0e11b789a37757217e4653fc7659f19a7ae1267c3d4b2b1c7e5d961f93fe7da868195dd44aee3d5bfffa2f3a149f6881d83cb800769e15b36b43bbed38a3e6d55fa69e8412a850b2a91efcd97468ade4f0b11a6b6da5130b5dc10f06c41a25f7deba47fd50abdee9887c82c40e225b4796b275bb09d2abf212a658b50b814b3281ad1cf76b5124d1ce915157809782fee7090f231cfad1f6cc2c45c0b5d65fe51e710934f3fa4fcc6f3d6ea433b8e338b5995be9f9a90f4da097daca8fd874b0e3528a67688c86029c64c6c77c1b30929f6e0bc1d1f8e736ca13c0d8861f49a74888e9ca3e17acaa6715fddf3f752a269039789c79befcb625d0489277485a751ff82b2075484929406c571fae88e6c45a0f66c8aac8caea11fb06f5e9d568e0e792b7e663c0089a49648669dae42abd61c39782691e3a738010703c12b48a63187825cb469952a63367291f953f2a16989a81fa17bbe7a711711c91563c7c2efdfd9257ba10d053941d856487ee4e48f604f9c0cac98f71439ba3039f95516fbd051f553dd6417f66d59a1e6d61159fb273cf70c49385843880f68c06366f94faf33ffe32fe2a76aefaf387453b5573e7708bee3d721aef730df24fc7332e9e90d3f6ab4b38a91d63321bcd57fd10b89e42edf726d184b24dcd6b03256f50cb644bdd8547aca87237fb0ac22a95b7b734a089a770808cada983d351893dc558080058a95d9fee22d632eadf6103d6a030b4746fa3af9dacce82de5ef736662b45f58c0b5282bb433689cb21b41bfea2485c2a12effb511aebe65f083f898c40b244ed64f27677ffa172202f17f3c25a8ac91b2b7f6ddbc18f9f4254b47ad5c2c98250940b860b801040798e32444d6d4ffaa08216fb5ad6437dc9bd405e48f75fc49678502af8a12ab668704888659e43253cd85bc62aa6cebbca21bc91e0cbe0d7dd5b5b444995d0d2c365b67186692480909de95f78f2fe94ed898218808298c22010b1d95e493286c30f96d61eaa57ab86cbd046a4b65057f4337544783cbb113620c4d28accf004257d6250fa40945436760cf8c34adbfeeedf934d2bb30d49273e15bd32bea7dfeef11350f7a361a6bc04cfb97722a3c684ce8cdd5a3718e15a897ef6c4da2092c4b6626bdc527c7d8e2b70edc9b30239be5a9c932542b341abba2e5d53c1d6399e2a51e5e25511ee6a66b2fdd096d3540cb0ed01738a7340363027ce86a899956b8636a0c7b371ab70f8887ffc98c6bb6f94a3a0bbb073fd42a1d9dcef4a61b53e8c2624b3d4f0c3a632f0d9496605da077645706a0dad226363071587e7bc88b651d9348ca7f54400a6224472ede981336cb534314bfced42a537b079bb63dd28b995ea3a15e7c7cfc3133a5024cb2eae4deab3fe8eebb6f9d94b5b3d74eb93a8d8a333365c8efa00a9bab59c7ab64e175d093565f0b89d5d9878924f7987af6ace759626afe86faf8193b8aa5621cefbcbdb8ab8519f4f1f494c3f7649f7d44f8b46cb06bb23bfca8a385edf388d456eda30cf38662685a2d015ec31a78b85a511a4813221463df6577d6b0283b11ef1f2f84059d707228d9de1569626fc6c31de368567f609f9e96daa2b5c85222f6d7c09b9cc1754863e8eef9cf8241c6e36c63989a6368ead59fd5b08cb555f0c92d52fd3529b5d63ed9d59401ec1f2f4579022297466a94855ebee692806d4e30e8753a9baf604a27dd69e050d25aa2d627b787e01896a193211da88036e2283ed894dcf9d24a86760075b7393e9248d653eef639b921b592125f5a9a864e760f8be277bbaca2311f6fbf52936935517656606b3f741b0ed0c7e683316c010b293739ec7a8766974826a14a635c3e51781e2818452339c532f29b4604ce54c2e037b327907da939b31dc1799d31312fb8ab83953d856206b3e2528fb9bf075c20c42ce518b070c6f79d02a52049edf07d07aa0e97505b51cb13572ff0171dfd4cbe92e849f75b889e64b9478c859237140574426fd88ac61d9f89014be48cee1a71e621823f7dba2fe8457d230237dbbd5997fb619d180f7a6c02211c427500575ce1254c616d69fcf89f0d6cc8cb18d55456de7ebea1072766e50eb288048afbfb466b0636ae1bacebc5ad619aba2caaaef6543f1ff0d00225665bde3ee87a4e86dc56126b38aeadf447c9b62befe98e823bac4622d22f13a6b3805aa24ccf056644924e354e6bb1edf34a60416cfb431b63bfd75b75c15a3ca10f39120bf15132e9bb06d38ab93f0d2f1296747fdbd25541794fca8037bc47df883911bce78840514e496bb423192f7d1db508ed28d66e0147b01ef9b28ce17b76d8a97fd34e23de750b91daad046c566184736e61b91221cbdd04f9ea9ca04022b251de1eb0922ff5f5d9e1eaea158358b03588feaa356dc046077bfdab9a38aece9049bf5302c030d348ddeab6a5cf9eaa938e286e40ad9b3685d7fae83044d09d9808be9937a092a004f22954ccbe5c7248f83deb8bf8ca749e24c279353df2fcb061ef6e3c9cb9ee2e1d8b866f180012d942cf277bb5b7e084deba6f40559ed4a1f98bb3ad2c30cc52e2a73168d896a52d2406589ee59155461ba73cdd757941e6d3980108acce04fe1ba0de8f8417a9090aeb86a7c2d67dfa9f0aff838badad2ada57f9557ae11e192a6cc859619a35876da8e60d54d180f2437d28a4015a4a7b663e3fefc6b49f8c2e3e3e6d7b169127691d8087ce0269258ffe7dc1fa98137b5585cf4dc22d0077cf7c595da5a6be56c34080f38ece962c84da6aee52f6337b016ff9e05b747e3a233ea2efee838cd9689c855fff87e6532f9db4f8d65ef0b18eb02cdd39c749dc29ef36ec6fd0dfa9b53587192a69ba4b5250759931c7a022f8f34656220c9239303766394caa4361d98279d12c9df26c960afe0eda3bdc49c3e5e59f0d28f34365aadc706e2845b3f131784254d46df95c8ddc32f579a324b5970d18c1b693957d9746a99f96d2b8d908f572a91b1121647faf3b75f9931b4a222b2e0ac61dcf35135a0acc9c87c1edd5ced55ba62db79c8cccc2f045b1c1da72ac83f7c73a3f9107f74f942291f622c6d9535720d7b792715d496f43386d35dc94970ca8ae6f62c6a17e908f68cae657ebfcf762b959b8446bbb0c0795d49e84241533d133e9e877eb859d4bf2d0f49bfba00e0a8c1abf7592f3a4ebc7fb5e7e6a427c802f7671b7646812e431e934697e0bcc63b20ae21ffcbd8d0f8035669b34eb6ed04d6a91d82cbda49272e3877b9936000345d710725fca5bca236b18cab27e9decfb71d53e86c2f2cadb3b41f96f4ebafb48c6d716e16701f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
