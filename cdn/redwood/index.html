<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65e6b1e89e69ef51d2c00f67e3e6443156fccb071219c22472cf77592194eeb4b29a90f11de42aa7ccc47ecf251e0d4fc0e68086594afc5dffa5af1620a536fbee5a6a5184b4486b365e21449a698f0a15864175bbea33323473ef0967e054fb939bd272f2a8ea3b555be4f2f8b2995011447dc239b81deb3505dc9de9e7c98aeceb1e825361ff7be2f58ff8ea1beb1b874d77c2042c4fcb804880153e242a6523e4c082aae4c99082197d4cfc163228ffec1d6b01398b4eb49f175ce9cc3424e7d3cb90e2291bef4bac73c8b355a8d0c55d8b7c9579bf19bbe1c8fde10ddbb057a9f5fac75db2b2e777ded4bfe92a62cc7dd0a6160f1807e880ed22f74bd216cc1c59c3c150908affa6ad0db17c26108d82f3d0f1e10d1ba7802d4ed693cdaa3462d03a8e9794bf783d9d93113dd2835ae041f43a41c527440377b63bf538d9717e1d841f2572aea5bff25effd0d112785cdf4180b62eb5cf22b2781cd7d68fc193f9e2959ec9eff9091af6d6c42001a43b640492213f1e05a1790dd0d8c4933c14a7863bae2cd86abf06b141e8e982d4739084d06ef459c7878e4a564ba34466bdcb4728b41d0a0d0dd8921353dc235fc9248bd51349485a1e94c70d7568dbae60aecb3a7af4d82ecabb8c35320ccf98f5497e342ea4e9c81d0c9bb9639592711469e9e8cb563910ed72a9c892a36109f548e4579efdd8844a2435e1f515969ba9bdd2a5223b31ba2ff087ce5839bfff9d0fb082a905bc7cc8627f4661a27dcea11383a1fde66f240145a206ff0802872dfb7076c5bb47dcd966a355b3c06731620505c677a7556014d163203460c4af4406e47872ac2a5760c1c0ca8be53782a26cd8b37ff28617b28255690469a46a36068c63074f98014bf785bbc3ff8a5866459732903d9c7fd316aa8c29edb5b25b0013a5893aaa676cd5f08445d36a77afb521148f70af6a8734a56cac560d35ab590121f5c01f7f8278bce83ff0d8be0e7a535f1d83c7f15754c5cae6912f247ff257967321e2c7e5c8eb7119cb5b0637c099ddafeffdf819add75351cf551789ad2c82fb27a1d15dd99bffef04b7ad89e976bfbda980b46fe47aa71c4fd4f12f93fb923050aa64c57da2ffbdd31abcbc4509d496a5a865c1b850fadc45cd3406d6b4195b5fb0dbd542706e8234ab7875df620c2d72cc0cb4b7c6a16acce342f402cc05935411fd4bc864b222f560eb879fb53bdf43ad6dd3d21fc7aca890f2e9c8372f31f80d6f42b7f014fc9def92074003f0ddfa38afddaf3e1fb818cd69b20e7485de16b3c6140a91f27aae04210c76026694d4b4503cd5a89a660fc80ac921421f0121c53f290e48f87713273a98b3901b090da66c0cddff53f947ee6e731f73623738224f25584d99aca97e090889840ab691141bdcefe17ff7c5c891f3040e70ba7618b44d2cca9b627d9453f8cf397e0609657207b2d61ae21f151846668daeace151ee01b90e52e0d107d9877c1f6c7df287d48673456e9d20d70dcd6898728a0b59c075b154c11ab525abfba6db9076f1dda8c3cdf984ffa11a91161c018f332ed4de9db633e81ca611db5d5145cc274fb6dbaf1b263a4c300175c20d3b296901dd8a3d1dce28e939afc566cd9986433a7aa7a6a343321a6a1caabfb06b80c69155801cdfe4a22ffe4c1470c69e602fe08016aa8ffdabf3c86c0659fab62e3d606dd9b0296cd37a5d8d7d9bc47263e341c08a5368263e914ca4ef16a06fafb5662bea6a7fed337031c71699c58840374d23f41b06de8acc1b4d82af8ca9b7bcb446fdac73df46dd2638909b3485ad4ba77e21abf76fbf077a4dff242ee142bdb791eeca87942d85d6d99ccb0223d4cd66fab0403e5b5c50ee008038fa7552e0278ec291fd684d0062153b1aee009f41c34e496c5e1571e440ea3f4976ef4c5ebca6e2d26053471eea4f27a00631b3430adf920fefed08a7ab1aaefc0bbd8bb77eda25b45758e8836d8e2f97986ecee3fc05e475d18d098e4fcef07bc428387ed3dfd0a90016e7affbae6cd477839828884af380820f1e13c601e18f75400c3bd9bace68438d335489ac0c6c0f95865063adb4338994b56db7d1d277467ff4ac8cd27a3d9dbce7e992217dc2029c5b591446208f11882660d787aa5827c258d43a57f91bcb0db67009c1c79903cd4574a9149aebdef51186464a75e9ef99651867defe10762dfc4e698a744a18dd4c98fce3a1aa860eb777cc966f9f904888db6bb12496dcc8d516d11947fa578563b8372b6de2f5cf61b4d21061e998bd8218f76be0b50ed6510288fffd8d9a61da9666e62e3722daa339f95d4e0aa408b0a5afaaeb8afbe791d3b4869b7d040c7362140d901354ecd2e27a728017f803215a08af8e2376b078d98093afc35639c02bf851ccd0465c8628aa57f2a52ec5fd968a739f7d905fd0afae90d33e557be6b505e73bfc044d0192b9c598da40bec1b1522fc8b46a5cada8f2527e64e03433d0aba97b676f28160fda612c1f5197a50f44dd80d260d37c5d8f031d91c8639c70c056d02b484a522a2f3186186bf882eb61995c0065c4cfdfeb8f9b942178ba170fbd7c3c1e426017e2c729ec382622e2e597dc2238c89b73c08a73557aa45b3e17bb93e13e1fed8cdd91d3d82296bbc5807150fafd5071ada5a3657d13c4a1ffefe7169cea202b75d72616a93d90470d66642937f6c1c6b5e8b13f20bb4c40797e0edbf3390d972590c689caed2b012ba662ba6d2cc4d9d7d2193f3db8cd1ca82a11a50d36d34b623a098b3749f8befdd7ef3215d257b129c978750572cac5efc22fe9d6e64b274d3f0e7856b54842b1b8db85a062bbab692eeeae8ef502b8f6738d17c59241cdb51c1428b306dd21afd4b2757e5b1d6057f481ff9a2f1223a5dc521d19c5d5d37ea3ae7496065fa5b8a80397a797b7ccc014c4f054ad407eb99e4ba97509a6006ee0cf32d190b2701eb30707d692045831915c2f34d542060b00abca63686013f105ca01191553069504809528f8e50d4ac2da6d87fcb6725b9a1d69205bd2851c4b2e933ee640e89dbf756fa8f444663dc6e3e7e0ee340e32b71cb0f5d6c5f5c29c8419aca1a76a559d113a3525785ad71d25aa0b425ba07f2e68196be84a2aae66d364665606ae0606861a4d39b5771df17f3a74a889536d4f1fc10f6a2f4406f2d33092e08b031df159dba4472c04c87d5a7d15b7a41e938713047dff3fcafd4aedb7da29661fa9b7bcbab18c973b329954c7d05f23417ff2689f982d6cc6059720ce55abaec02ddcf08c16dbdf8d4c8222fc7d31d7ba079b6ff3db9d747001c4494c00e751b6b2b819c42fd4d024657ac0ce374eca19f54789101f944a858ef0ee34f0d6b7a3c455a661e0108dd9dc3d4517e7cbcf57c49f8317da30a80cff94793848440c06cfd1699ffa71815797df57d88f6079beca22e237b6b3679e60a938e0ed5cb83130b9736eb4e145acad6c4668bf4ad6b53af176074ef280559b799f2521aedfac340d4dac1fbe680fb94a2361a9b718cf42b86eed324945334c013e21554f61e34c16076a486a60c0c513eaf95349acbbeb955a0d073517dc66e6ffacd53ac38882228f1f768b4405455ec223b7e0822a300c4a0e9ba192c219dab4e76f7a9808024b30177b28aafe19def11bbe47b6728c0cfafeb2279a838eb82c20030a8e2ce9719940f3223b6f015a5156cf4df453de85c13dc6c776c0ab32d34561bca422fa9c421af5fddee27bb393fd1fded7b8dea2f95490f99ce8e5f8208a7cf9c07b8e19197f785e8858e14e313f350796453996d80bcfd570f05d855b9b3281bc630152070f48f896b6c3157eebd2924afca0fec36015c88efd336371969d1c38facd31b42b0dc24c018b037187d899f9edeb756d1a509e0f89fc53c557d0b6340d5864b9f9c1fc529b3daffb7218261335557a7b3ff2369b46bf71b1aa1bb043019c84f38df819f6d0bce39dcaae3697f67a3c26a96b90874f6f8d7fefbe2cedf02dab7b491f924036d65f939eed5a83c68271a1da201dcec95d1a154175f31576d10d548805824e68a54a4ad5de28b1a1c007fdaa520a2077e54489df1bd512e80940967af5723bc65e2361b70a99f678ad1b743f151a996a71923fe428412504e380448388c21d2ca5db333f39aca8fe80a34c53b3ed2e63faabff614e1d7a9d2909e1d09b6d1ffbc5a1ba2ffd98bf02bcf13de0d018b4cc92811d78a4f6cc520ae66978ea36560b6c0261de7bbffd046a7c3b1057f53667b5e5d18505a17063988470493b3c97ae61f16fe15df50591ef1b6a87f9088f3e616525749b5c344b9161674fe0de27134f430effd3e8dacedbc67f4c28a442ca8d94c89e3376998383dc2392416a844bc564b1a9308efa9483da11f78f2fbfc645166fb739ce8f749e4475bbad809e32aace1e6a63e8d87bad79b494e9bbd7c13849ed3ab736241999dfe66f69cd8a3732ebfcf951adc43dca75813f8b5fcacc647675d36e77b76e347a511a304c7457e88432b05d6ea91c47a35e32a3054a2355bf44dba75b1d76f67ccda005f02b22576d5ccff67ca0c624de6f34484026934bc345a9029fc4e280da2fec5312b40edc60154f66ea3e46c3951f26ecab8eeafa911392bc6b3f84e6d39b16cc4ace21b1264afa0687dd561b149b00bf57ccd2eba303b8b8891159e36a126c8a2f8356d192a2508125471624475b08884895fe9fa222220b78380af6d58b34910113df13bfdb31b3161f6cc4c3b05d61f6f062c5069c0715660c00d8036457b01458228853b9d0f5c8bf41e2a7c950f2206bbd86aa6073bdf23bce623f18b464bfa3c0011ff5cee627104cbc82dfd97955d24c1b0d38d2c8c7f15528a9e145eab43110231dcd1817409f0d8d71c199dcc63c4ddb9510309fde4b68417cf0cd43f10b57c3333cccca5f199ca8e28d16c3c76696e0b4452a5c1812ba2d60cc603ecf43c8e0a432ea5c16dafb868f2931ef87fdfef2de7b76bf829f08124a861771a2f0cd39617f9e612418a64846892acc8155a65ec402cb5eb13625429f67d04567b9e5f328fc8478c393ea996bd34129a5fe8259c3c6570209f8c0982503c2bac44018ce30a448bcb25c9e41c9d42d07018e30f2d1740e9dfe302523b0f66a834575aae3f35f48c52bec867b8e2eec0fc37a1363cea5ea984e2362fe0a560512cdcffcef998663416d9f99b064cc5b4436b483a47692a7faf35e28315aa0667e41f5dc679671f9b6a47a2ece994dd7da54fd35d65b3b7190cb5e7ab0557668828b439bd780488ad111c929b40b62205b4402e9b7056e644bf05f9ae0b3071df42a87223fbe82ed4a04e776aa9c1ddaaf9900e7ed76c23bb61a0fe82528aa3f145a810df09e46b81dd4ba7fe186ecbe118d77bb722d0f1fb9d2cb0c5158c1f2d86d7ffda18e9ce000f31e87241bc3cf090fbe5e2ab0a9222cff66afccf6314cb58c70ef97c75177ace795c09f98e0517d90b62b6b243f144aea652fb863ace9f25c9b07be7c43131a5a5ed62bef678355e0e7bc1ed7eef58104860ecee776deee6331587cb21831874aad98acf197de8ef0d86135b337ef9e76c7d90d9dcf13b345cd6860b06c1327cb35af113aeb9a55f61f6a8b5f22d3f16ef12426a8b53d3a50c8bf6109e6ec18b4aafd07cde61712ab22fdf84938f9730d7f9df6c7a225e9d7c655e2943bc2761a1a72094cf9e59b8dd9487a30161fcd9b312b64c6cf148dbb3b9829f3378b3bc225327804c58f8dff183336c3321ef866a45b2aa052beddbd0e8bc418e00460c16c97a005027f9d0a6f3466f6fb7b92fba937748553323712ae2531ec383731b90cb8c3336a8472f187956953a6809389e9ead1a54cf84207d0b49de70fadd09b2f117702c9cae475cc013b11db68f6d735c13b21c585f5b298c2e3d5dfeefb9902dbd92061b11c56c5b46b377dc56bb59ca576b608f3b64601a0680e89f30e3e7e4a863cee222e5ed6415a10d37f7cced3fc20e23500a10cb2f060c11f6379636177557c0d5c646d839bfef0c4236e3bcfa91a8fe11194a98a6550e2c4a444477f718568003615316dd16d24048da2f566066e3a91e2fe64090d12ce4200fff14bc719874cadf70085bf21717d66087666a7a4ab03181f4c659f215ba2ca21890e85f74b93a16d1f8857baa012b5d6bdacd5e76be9f46f7c91ef61d4d519d799e25853f3db5cebab3c63ddeb53019f409e7039073b81c9afa6bcf0f5e6bec4bf8721ce45d936e1a483338f4715a9ef56f429946fb2506179a93fcfaa1b8295710783a57eec5fcf609f5dafe27a7e8628680ac3e8e92ec07a2b86d37470df52883fca25b2a3aa112b55106345a5c93d6fee061a855dd29f6a931e9afb0c733b2c7487f4c2c72bf660439806a45e4df0eb26a163e10fe7cf8faf4b0af68f638a844253c3272d645033c4cbacc0d6659acfb3dce9ff478c7d1952b564f345a766a5557f80a022cbbd8d171847980ff3f9dc436106e9c7963705b2a3cfa2494322db47c2e99c2b5c4f0f426368d454bff4322fe36f299dbcbf519d9b64649e88fc4a25f7e76aef1a5281f41daed22b61cd11359eac1f2197f9963509372480998f62e923337c94be5b843f16ed08987a2d5cbb4ec4c5a6e7437c9785ea9af36d9f1b44a9755e06885468bac19271634a8202b4685cfd18bdcab9483e5d962122e1a8836a2a0aaef20f1c08ffaf0fbefa9ddd5a43c31bad1aeea41033e684d982322cd1080157461ffb2a1772e204004f0f9ef9a08574871d4adb3864a0082f5ac47d44cdbd3680141a65d9005bf2c965486f7d0bf4e6738119a0f53a4a4c36c630bcc7e668877b00a82c853ae2448bb60431870f8acbdf3c0bbad1093fadaa9b5071556b92ca4c2481140f2824d759f5fca9281640a5d23e97f765130ccf01d1f3b241868a7aebebe516928c35379f51e4512ad9824a8618ccbc43dfde3b71634d8bbe3c80cf9dcc18a40b78c276bb692a4ed8311e8d51ca4985ad2e0a37845eb19c8a3d203549e0a35f9acf448e4230f452abb61599d01536428df85821f908e4c30a3131c914a2c43c73a926525af6c80c5d8395ed226f97de32f17e0bf03d7e8528157ec347177d13b0b4d016100713ac9c21f3497981482f447b98f9513cc2247e23ee881bfc9d9ba25ed92cdc0b0546776cd8b158fbc54863f14e0a35427c2767cabc5bd470550a941d133a552fa540283ea52ded5e26803552f060e08ec39f211a4bbc1fcbf96ff52282a82f3c968c38ac9055181e2bbcdae8caf43a97885e0376a99e1b7352c1c015dd56f9372d547346652c1dba3273230daf185c13676d3a19710bd3c28a7e0f59ab648a39bfea34f49a71e4edc92cd65b42cd207761cd3241088801b7cb7871788de12d305ee51b9798bb8cb45855964e7b1c6ce72e4e135292b0d60f0c1f1ddd2e6f012ebcf11f1c90529a3acf7453a7e80102e0eabe8fa343b0bb1df2cc8fe5768f56f3a2317066ef4cf1f9863d8421a7d930b915feab72d2cc7c31924c6cb0dec22b45f515f4daec536e46abea63375a4b89454bcdcd98e7d7057371da81f40f615e8d376d1821ca5b311a1b55c9466319db19c73fb21a1be0f56f764c54273d67cb0b648ef4cc84a89fd8b0a159aeab6f9145478988570cbe64461ee6230cdd8663b6f12fb2d53d026af788a995b9620dfaa9bf68f53175bfaf7a04c9361f4e2e2d59fbb5e751812cdc26320a638afefc35bb993d2e4104716b116722cf6ccd118c576ee623c9b1bca984fa3a42af626b208227d2ece093160ecb44de789c5264610b2742fde969ff8f95c4cef84a6b27e476895df529214d37f5fd5bc3ac3ed7cfb1895dfc23d71de3cea7b4d5a3fc2f09e265ee058c22eea5aee938c367da6aaf6df54de49b4a71af3b80b5d9aa01cbdf46e5341a5f70515c89b5601f498a55e972a5e88e28e0e41d886b3f0378b77e256d26e5c655359b4107ad7c2f796d8471f13a81913ba342b25a7b38a3f033f6ef1b3636f250d4f7c6a38121f08e5d1da8770fbdafb131008c990e960f9e84600e94ce0a559a5b981aede20ad4286de8abd5fc52766803c414717de630193d09ffbfdc0529dbbebd5bfa50cd8093d7f0506b40e7d938b3c5dcba5f9f745bb73fe8002ead2bcefe6b4d42b692506e8aa667a4b858ca426156b0c7a748028746ba5c8bff8a253def6c2af3de549a0a4103c52813752f2672443964ee4f8be2b435a074bedc8fbf6957b886faa59c56741b0ed48420fb59f09d42b0ee1035640a45267415b34c6e4035e827b5c2854cccc98ce4c2ae1100a36c363950d300a8059f8a2384efa7ab9e0c40d8e2d831c488c664eb1c34bddcd50f710313f01a64ba3530639c0096c90c67ede467b92fac2976f09d955c34bddcc6adfcd39f19ca82167ed542e079c51e9882f3164141bf035b505518d08a3ba2aa8ad6cc88c96d93738421593bd34d1a0f1119d7848b2dfea726874efa068d730d67dafe308a9de1416e8fde1afbcb44b42a116039a7320f88c798f2df504d0f703bd286d255526af22e35ec69c5921a93dfc2eb2f96663a8359c555e68e1f7e65f453e4ae3332bbae4e56ee19e24960edda9c594b46b98962cb3569f6c8d093559f77b1eb03460a89aae486bf847841b7e337e769d4a9441c24729e66143b204ce5fda10536319c5bf13872864874d6e2ae1125b9be26d5fc6f0b565bfd64b717068ad27dd3227c30910c389f54e688f6c9c172ce7a3e41422e010ae82ba3bef71b98d8659fb1b33ed299d39bb74c78a8835f66f35b4921daa99df15eab398e77b4ac64626b43bab58bf24f1fcbcf1f28f2c511b3f74afe5e65c030beb5aa44b10f90d926b4624669bc17414f916c1f5bc3c3d11bfb73ef4c59d022325cf96503f23ebc856031f37b59fdb23f8053d960f90adbc8da72a8938b214a56f098bf2397ff7976a95b8743a774aebca1bfc7570ca81978a6810a88e91d814821096f7323b0fe99e1a25a7baf36dfcb1c76bf2293fc6330ac8e6038549017f909e41eeb296df0effa6508dccce6be57ba86704cdaf6f25f7e971de213fc41969d485cb7bfc9b5cf2ee691d236d0a20c2f2d0457b1bd660f86f2a4a38285471555d5b47e9c41a6d4111e4b0aa487aefed963b6fae586ae0594b24bd6599b0fb1138c2f6f22a286aa8ed9edfe4990d21859c738f00b9af76458dc1fd676e350a56d68ff1e6397619a5e20b3c0cb717394753e3bb7c82869d2c49de2307cb9431bdffb00e16ff9de070de0da50939ca457d739485e4ee581f3b9ddee297a0006eebaceb49b808077a7cec41074df80e2d39272eb32eba8a3866d2cf42d765cc43dc19a1bb626e755b9524e044a21b8dff8b4c1ded5e2f70cac35166d32e57ba743844ae0cb39934679629959a9ad28782cac85ecac4b31807b27375cbc16527e4a74f3a3832d159bf5782ba75afaac4caf144c2e01a64b004a8818f1f43aa52a3b8a2e6fe8610ff4a45799dd4057e11ad3e380ce6abca0e9123e94a0d49aab3b3c6df2191da62a7f14c16c3f412a470d89da7942b84fc711c8337a48a4ef560b627dc56d08f05f9221290f5e64f33e7e0f784dcfa00ffca794f84e1c112ed91c6b2f9c166d7142c82dfd855af990aea66d0bf96f1101c9589952183697a2dc8a9ba4a0a07d269e040c18ebce318fb7372a780ff3c61dc3bcbe23b87a4d0d73015ce00aa208883f5571bc7ef68a4ae5b4255395707ca3bf629d255bf08ce2fab274c7db96fd9f3987c05740d4baee489cd071612bcd822bdb5be9f0bf3daa3d50e661e26f138ed4baa4d1f2ef5501f4d7af054fd8ba78711d33254a3cfad77899d1d3c5e0cb6e7cc39b76eb5d5dbb6c60fb403e4229b731a8442ce88dcdf9981a97f73601ad5e5bfa4f7f88d2acb6a1503cf2f2444cd5b6444bc210155e8d3d2892adbaf85878b7c3e6f643893ec6147bf6abb03ae1ad55fefbe04f3bb3b5f386bcce22fc412200ae6aa2aea56f921f5d8ad00fbd9f3b3a1bcbf67e28f9c28e66d5edf92b7639f488928bdf58b3ac7540051e6b673caad6aabeefd0bf7404271a227fed397398e9decbecc1e3902015d904b7bfb443149cdafef91f3d564827b7448ba29ebbd2344857a26e3c7c840e9cbab5ef0bee4d5627e8e9c7794e70f7d34063e4d66973f25d256c68b284bd3ada7899bd9ab7ab6919e818d16369330d42a2cdc4e964d3868c600971a51eac692b84fffd28091263fb8635db4a9dc74a82dbfa74d10f9e52de29113c1425fd931cdacc85da5d649cf9ae975a3352625d8c75af2dba05db04c9bae3884d918f2b24f88adcd4ec009cc2d93e452fd4146cb96b1ad5dbe330d3b47a001595ed664f9e88781ec1a8f301039f03797a6b20bfe33370dd8dd17725d3ab07272ba7cbda7eb3b47d25d069cb00fdb373c9713108a4be9b557ab228252142d6b85d98af08e6f87960a992504714f23a8abf03132ca3c9f48a63a4b541f636eba8331fd065b7d8283c83d71592cafc2bf930a13a0f12651dbbf135fef7cb3219d1371160ee2c7ac70ae58bc6284af4a50499dcef0ccbfaf71d758db5cc5c2e38b3669d07e0a133a79992de80dc503d3b4664e4341af271ed01fe48d703f6dbd314d77ce823e2ab27d84eacf9de3ccdd9bb8affc7381bef0f578877614ee603f180eb63747883140ff558ba493d0f6b45ceb6b83d74c99c8bc2b4afd0fad6f3827555a854008e7347fe025bb7570280988078e7a71542fec4759a5258daaf96e9b3bd608604c271855a720b3a7a6230b860e5f415609f245d12fabf9300f1b20bf7909c88f44100a66258470717c5b68a8578893f7784c3a5aa0c1819c6f5dfaa446637845f3e8c29596fe52e28e90473b5015f1d558b5f23ccecd555d9ad283a2cf21925af883cd4315f90009b5dd18b88e696e719887113a1df640f0e5b56b273b8a86f64a098717cae1adf9eb12720c22a9a17d48861ed355a78167a7e598a49ca21024bb316d2058f8aefb9141731dff422641c5d023d1904e5981d8c120d509283c50013d145851b2bbbd1596a8601dadee3d3b01d569d9f4f4b8f1138258fb43a0d350909b97844f344fc6e5e9eab9319478c6741a7e6b52c10081a7f930d11fe36013699f94a39818e7162434d9f6c4a52d08776775df88f7cab29389892766bcc66e43d9a7ef6722c2cbdb237f81bbefe382f3a460aa8a244f605617ea2c6e8dbead0b4e744073d23c5fe0205d570e1293f348589087a88b0336b39065bf41e69cfec5aff181226e71e62cf99bd10ab344cbdfc382edb683feb02b293aeeea460b842b3985086bc6b3a62ba258c3abdb979c1e5b5a5e592f758d60fc701f7b8fb61b207db1cc959a46f2d5f952a5f77b5ae55971501b5599c53d3672106d2002fa1e0f94f933b614342a0963e10c0576f59c8489c4d6999764426212bf7360e1afc26c4b94b4b816428e6c44b89dac109b791ccde8e23d09c5a160951c5a575dcf23ed47ff9ffbb8acc818e67704d70ffd82d72f5fadbe5c58880137b259440d764dc49bac94095cb5480cc28acfe47743c6c2eec06ea997d4ed37af9d79a80eb70e31b2689070decd8e24e56c7fd8cb214305133007d0818700eb9ddf849001ef69b59ba74665482ffdf1cb1d12e2e511189171687ba25d62072beef1365223c265a7a98f6487c933b505d7d9e64b3a312b6b18960f201f7b143312d4854c502212d8057cc3ab898a7e400af90ce7d865fb0911237934a2d4b30704ff4cbb40b83fd639639d15834ca52d749b90b91d0276438440f94aef00a327a5adf059601eacd5e5f377bf568ca0ab1fae63345743ad4911586d22336ffaf9203ef5272c4e5f6bd56d711ddb9dadb3589539d79793d4a4af21c189176b8849cc0185dcd1831c4e473d6a543e6a914dafe645d94f27d2e9078fdaff9bbccf96a5b74052b8440393f17fc2a388fb0e8e5ba8ba13f2f015459619418800a107ba321fd66e45587062d41b5e5d28972bf583eb0e89f7d2da04214046e7ed5cc0cbace8e665114166e97d4192af52e6aa0baec5f4c4c37c36ec2d6b234dbc6839fbe75a0179bc4d85b10756ac533bdd72c704eaffdc83c4119c85c17f7010664b44168ebbc351ea914cd14350bdafb0598a3a6e5caa09a90099dc4739157ac430a482577d2f6bc258ad0f090ab20496d2bb5fd6be7c2e3e706883ecfe33c1bb2cfb7173259d72dfc15834e8ee64b8df4414baec583898edd8f62fec35f1e071bd182c691d80f0074daa80cc5a6f548d763364f43e214e06bf1ce4fa532f20a35b143c6e8b5dd79fc7d3176ef96ed6d382d2ad7a5c9330264cd324271eb96de5fb32e3888d87e56004d9cffdc970d275cbebe7300aac3c5b9609b3586dca2aeecb77f3dc5baacd28f39fe75afe8348692ad9f4831629d00aaa7df0dedaa86c91f9cf28231a7c9d48f9d62d2bc41162864a0498a518da6a820d97d66a804741d8b201499cc21e263a5c6c9e1696da22d743f887d34a1e5c71890d1bb3b04979322b61a02d4ce41cb6e3f8d53c383dd68820772ae902eaee6eee2823bdffd00d869d8ff7e07009b7fe183b6ebaad89c7bf4afe92a5a480fd8ae8a1d13d2f59c60329274247ccba8523604197db34f396f4cfa39be3045b64239cdaa597f61d687f556e1b332d313683aabc72cc3c6fa736bc018f1e741f6ce734157d1f19ecceda21e5bd4df73b838312949d04e132b1afe179018314489af20278cde7f9308d1acc928eb804495b44d145420488fd46274f224d73d0eb57a9013cc1bd52d33dd552db43ba263da0d6253ba6c576d59414b40752731a403396cb930f656c89062c13a5d8cc5e569d9e6885686004dfe0061ab6e44a65c3e3a0486223187cc67c41459691d5a555e4b6313bed21de126eb4b9a1e195b82853334e3d0527006cb7b47af3183a97bc88459e021b376582f95441a0ba994c22640566f45eb898ad29c2d9e877b0836433ce4984c7b0d25f9a443ec68f9d7b8725ce826557345513508c76713cb2630282b78b5a4b58f6c5f90c039326ca3f4dd7f03c1c07caf3910df9f72c9d0fa023c6a64f92f57e4d2573848f19c66c9159e3a8b02f84bbfa489da96c86b9d7803027369de9c70eb0eda2e6c9571112d4e5c9dbc26168ed70e0b9982de6dc2e03e63844c0d694acc0df03998f87e002d4e173d657dbe025ed1e090d48cc33232ed9b7e98c5e81fa86ebb08b309d3861ec697eebf02167ed6168298e0bac880b6951c5d96556d75b2ef39d6319ab1ecb5e0cbb63a9dc545dbe8396019ed6bcc04a431dafcd7b0efe682afce25e6d3f1be36ce3b5485d3d3d2a4a466f46e2d77f524a77d718b29dbffe5b98dd5be5cfd5b6bb677e53a1e57eca28addc917ad5f94609d6be9a56002954968095bf6cae94e977581324776d77e55df3dc46f904fba4f42556408bb77bff05c1f1e04edddef9da23f08e970ab98fbe250759af6aa8cfd8cab065be8484fdaa79ccc8b93bcaefd7e38e55103db8bf276bb135ea4dd1965834d3c540ad187a566d4ad02588686f1621cb1f29b9d9248af59112359b1a2fd10b7a23b3bcd973ff336ba19c5f6cee4b0ab4f97524f6eef167bab312bc56c26420815f3cc69e089eeb2d05356a5696ba2f9c1b8811f349eb6be2a2faf42211d5407191c8f4d0e67dcdeed78e3439a44e5003d64c38a55a28a413a95a5c68494aa600a33c7ba4056c9dc6f52248a39272853c223e6fbb0bf00ece1ba208df93023b67723cf0115ad52f43a275372437e351d8aa84d66494a943cf701fa303f8be4c4c5947687c3c12e5be3bb63b37ded6ee36d0a2b6bd5736e9e9d31f9a1d5b741166226c3c952d011d66d2e347b66677db3495dcf55031a2920cbfbe3853189779adb4515225874c455459459925ee28c4fa48c92aa00756ef4b00439eeddea6318747953a8b2a48576386612e34d1c1e710c20125a6b46f3038eedc1a59f60d943b0d999fe4b6121c38ffba12c6aa7424694cbecba88d577a187299881f525408272e819aec470e073952bce374bd7f79d2386132f9700032cf989397b9ee2a5d9410d73e7e0b510e44676e473061719dd503ac4dbe394f433ab0080cbdb1a22ad2fe157926733281b8f423d258571033589095c414612fb021a8a5cb8d2d73a316f5d04330a90644636daa2d3ad4272ae2382ab44e0d268cc181c4820d09fd4fa492e150769ee95ecba1a348a522f48d84823e2ce7f57ebacc500bf9129552824294af5192f48992c3b10b9e4dd5aa1d556a58869b2f0b7ca71c671b89b10ef22fcf17496b85a91a2d08fce7546d750c07da73434e921ec00d8c6c7a46413f31ac334f8b7f2643042b2ed36dfaf01f1739b1cdcdd3053a89884336e25e3990c2bbf306e38c2cb6bd211c36169ccdf6b7b4d074000cb6e942a56f25c5f57ec1e35223bb690b964258af313b1388707352b74bfffa47663a49c9dd016da2cbd37852c230c6bfa1f2133454f38174a971fecde70e7997f73c92f2c9df614f5532cf37665de1e0f2ab9c69a1677e1fecbdd32f52dbb31adbdbb9479e300780349d91fd4cfc62e7045222968247e7a9abb15bc20cfc56f7c3e685278106ffeb859f873e53377a841acb3be45450b68fa8b17ef86ec7499d55bf1732da9ebc2364869cabd4838fc4944cc7cf020af7b6ff1d919a00e1cd9da574c28f7d5776808da0508666f1e9cfee8289d451fe8a79fed90b5f8174b9cd72c4a818a5acba67eebc8042beb11348e2249f6e48a39bf25ba8c5c61db5fad48975841a9dbd73a81df8d62941f1de3be5e37bbb225c03e05afe4dc4f2d795b7e68c40ea141a3f7a296699c39d4bf054709c0d72e4140a75c3c44ae3fa404df8ad6c3b5cf0022164b2f41556e5e3702395e5f0099f5534bd6a019bc0836818991049e60d6cef6313e395682ff1a1fcd2b1f8ca4470389aa9f0945093ceccb8f544134b566e3c1e6ef0c55b4a53cffbf1e00568a4708e53e68c8a9d2c20f22e07362904a13a81b7432c22dab49e19bcfdd45306090c0c287f07ad672f54da0c0a3a1cf253c12b70445e21930a40c7221309262ec847f366d76f3e8ca2fb4533125bdc922262c418dacaf81d72ca409853cacf7e2885989c5265de238f63d65dae2ef008fff08ad4ef8c0ada8cbce69db40e4cff4eb530a263382cfeea65a04d42848c56690fb9483f26bcf4792e204518dd4e14d7d18002fd83fb67fdca7a7f72a1068bb03eab0429307503b9eceeb5c2bbd68c609f20543eb1f51f92fa56828ecb45765a7bb2d4f12f0b516694d33e281017fa8096b534e9168d9aada12ff89df1d4afb45bbfd52c31064aaffdafafd366fe29f20385c44e8f272eea56f891c2106c0a0ad3af97b370ddadacbd1ae56e40d212027d997a3b969afa4cf68aa6ebc4c0e3558730a45d3d8d26b0b323e0d30046ab53f29a86e494a6937e48eed9c44e7fe984af7cf745cafb2d3ee36fe395850cbfa54ee61a8c2e16f821f09fbb10b459e4163c02969c3c2fa8e31042b7eacca465de0d34a07db2859d3c5a3ba81eab22707f29a0ce67df97d1ef81caf3d188145bd1943891194d272254b7ed2b0ecefebed00b4760e5104eec857ab9b06f7faf7bcf9967b1fdc0d3a3f5fa7519091e069bbbea213cbd4b3de189ad918e49d5d90c17cbcb4dfdba0112582ae2be58d57b9177d3562552934babc5fb1ec849e798e1b6a04a7d0d4304fe5d7633cbe694108a1676befb4f7cc68676789f04e05028f0c8261f77a115b87c8203644fb695adcc905338b823897e3171ce36916c2e5aeb6ee66ac488c7c6ba8ef7442bdd34b9baa7c199281130443264e8e7a12bd71da1b99231c47c9b80e61ef5e4264e00b198e9d1ba9e2bcbca6dc6f7d7721c7664b49c462d8fa50cf7c19c98e64833b0dc15065f3d37b5374bc3e78e5074a795c66a3504dbd29602f30c71beaaf436b752217617ce1a4cdb33acebc2dfa479919d24e79c64711e80cfecbd16d540a73ae55e1edc5a0a425308787e606f2405785d9ac7a30587882935939a34061e9de703d9284a8d579ca38ec4a04c7945818afc3ff0a37a643c55d1b7814c9102b3ab2ebd04cdd719dbd95c45889f5ae1970eb0722b218ea673dc4be575ad4ef0908ca37da5570ed9d23f4c468b2279246f92e36f507f03be0c68bc5b1fa0daa037599c69444374f839a11ca27dd07f8198c8f5685a9b3dc6be1a978d8daffed037f9bf099d62df2f9b5b1d7cc396f482b725a56ef7e41abfd22f802eba044f7b4956c2e44a2b78d2206766ba543b9f162a11d2774d3a68c049decac114ea335d0cbb4a5eb9d7eafe656ee0a38ee45b7b0f6e517e110063c273cf198571918f2d20e3b9420648a21caac816a851cb977b526b9a2c9bc427b8804b83a2e2b8e0f9f467ae7549e793ee613c5b8d3c9078b6da30cc69332f164eec95b09cc6f9a55847c1e3f84b266e7680383bfceb8e8e71d0870b3457965fde040a7004ae11b644d5b2934d6cfc353cd31439504ab818c9a6767d55b856a2be43aef321c72d1503d140714d72408320dd2ef73a7e2f0e998ac95216df4194a98a076006ce7c92574557b6924f5142e698688ef29ea233529032e681161a521428b0e987df3936962c50776fd56dec9a0c0ce665b92283ec5868e1762cadc92f333859c944b626fc57912295c7f2f26140ad0f64cda2279148ecf87e31a6bbe5fdbd36492ce3231d526695482dbfc98f63259bce891a1868aeeff15685465046109a17eee9eb8a1fd7b120ef815cf30b88991ae48692dc722f42a44941dac7a1a5c72d0749d8d65a85590ddb36b320e90f087f79b273b7c673974c7f5c2c8f4740d49c61b5a4981a32006c10eb398b94ff23b2e061ae5ea483c90c928fc41734785f322cf9c7071c270b05a2917efaa08ecbfb6d9783bb65630e688f10753834a581a81d1c80ea3d9cc1a011eaeb03d47f4beb10505f28d77ce5bdcdc507f8410ba9f1568687730e9e4635330ecef2bc515843d044c675d747fc8661dd8512a9d90fea51a3c6d66581e9fec6195a3309d62712a0a4a9cfd20a782b0692dcda6ef30e3f17fefa84129a8f78cc4102fa14c55629794b194538071129e44a9507b0cbc1fb1d19d0120b3a9d8413802fab1fa601370e4f86f48a8dba99894b86aaff767c415219f75aea91adbc28d0b13e8841765ddfab213bee2807bc20d9f7c14de9e6df2ea0fcc7398a9ded538082dcac061b09b0ee87c37f63c25afd6c3bc0d36d2d084e56b682aca0600832dfd177e19a2e6a45221466c176a7398b1709e446b7a95ecc81ec1777dff9719273ad072497237d70f32ae96fcaccef4e893abf904aa7312c00b5e2a678d8f775892fa3f3c2ca2414ad25da621957f747b0d13a7296bb84cbf3c0835f8d4e9d3ca4ed7b7e2f2e59596cc5104b891475fd2fbca7c7262a82c142494f8af53d770ed90785a75bc60b44a8a7028e8104c9a0f649053a1582bba80f850f15c457d0b0076761f73d2ac5bb795855a187f5381ea6c254cc551a060b1f41bd49a508483e31c85e9fb0270411229af9d1f481422606a63566d45fa4d31b4214b0fc46c5b583ad8f900eddd99c79e2637a28e6ab16af1245eff2b13f47dd48384197596cc7f5969c2fda0ad9dc2effeec8285dce4cbb798ede0513fd5a7f0ec2a26b8900f528bedc7c7736da2f22876c3b2cab8ad9f0006191305d8af7f6cad7bf6b5266ad67960f0589f7a14ced9bf0c65e51cc6775f637e13069a09f404f41af41845c9374d526c0e46018f11ed94739b1ec9849456dfd301bd5088d0272fb2e43f66457b700b43e6ce2dba26aca70a1e3d34b2444a9c933e381d040e6976945343112235497067043c3460d8d17a65aa1cc26f07b18b09c5e2831b0e46e3a2e1b9a58a15b2f92223154648cac4643acfdccb085e48cd73d97ff8951af9cc4e556f5d447f39f665772f6f0ad0538f3fcb224a4ba83f556f91bc4b76def7112fd6478e1868bed380b65966595e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
