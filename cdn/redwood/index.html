<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac835aaec592a5b284e5926723946c8562bb9e1fb0855178b165f8075f41ddbf954795208e1e5530b3a5aaafef3dbe0d416ee263b3b66a1e3a27c3b945ae397608aaa2610f95be6da085688441126756cd49061da47489744635171e16ddc9c9bcd7cdf4d4c10b307a2aa43f42645a833309fd0a58e463e662e1fe8701d7a22a7b36611bc49c926e3a2633cf106f931174c980449536d42103375152955b1dc147bf71a91837a6c30ede42f9e03f2c933c07b6bb9306e70d86a8d6c28ba353f04c65d7a43fb138e71c3b7aeeda60a073b01492657e50401e6cb0466dfbfc962f00e6f8530a6662b1851f439b5fcea5b80d83ee2f6328455360702d2eb45fab3a3f11ea75a6ffd5fdd4313341c89cd5f79f98b302c35cc19fd4786410bcf99db35eefad5a3a55bb96b4b6a548156f4ce0164d40ab6c6aa69afed3840178db2fe3c0559e46203a71845b789f3f650613312275d4d23e16b16c61365c0c29caba0ae3f15480f4861bcd177d6968f755fc44bc0804a81c45bdefbb6382652a4bae9f8d127be9f22ac6c331207016e2b2bafa483eb5787363d0f8856b2d48ee32fb644f6578f60e35fda9adcdcffddc61b0cf154fb593ca562bf7cdca8c7899663ef3bdd874049941b7879fe52767b4e3987e92e7c1b8baec6fda76b4326806e313bb5a24fe40b12b5bd0a218435c8b4a6b1a0cece426cb7fdefbf4b5d090ee1e1c2dae7f925f9ae6bc5daf3ccfba935118e9511dedded4cc873a483bfe1497190f54e31576101f2a3c78a5478e417762a0d3ca9cbee5baec891d0337eb8239df77b5611df48bb8bd52fb40dfc10cb611ea87f1bc0cf23d2ce179262ee8d542c4bce5d802cb8f2cbb0ce34a392240f0aaf985af48a9c4950b67e7307484967167737cbeb98a82677deb8c3f134cba35520b3d04a75772910db5001210f1e3fbe8d9c14edb6db6300ce98f48937789050ed9507352dd80bab1098f72e99cac456ad774085a1673393cb891e99157e8a66830b5270247aa58e5c24cda555520ba40c138e1f384d90416f5d9a399d3f7ef880dee336e4dbc9d4e21155080dc32cbac30a6de7fbc898c0d6a95cd29ad52adaa9b74d21c7bf901a4d45d386850300ffe674262db69ad9c5ee441d66d596f2307ba595fe5594728336ec87bd236ba81bca0dae90fb333028ee3d213a286d6fe7ff5ae210041fc4281d8f98c50316f5979becd5d278fcf7b2d48479aec4d548a7dfb8383c6d058a99f77678e50d53a620908356fb5e63a6fe8043b3b5b6205292bc6db552dad28a11e41a478047ffca8e25d05d6a712a31081fb2f3954c12c88ff2b5d7facefa1292ad03da13accfce16db2667e6822b8bb1595b7671eafa7732fd410c411e71cdb51ca5ff104db9b27e3ebdd95fbf1cf9cbf5f763756983801a87109d6c89d67a07e7471fd72e09564cc0c1c3d25183ed086d24aa16c47d8994025b87bc36d45922e94c0a02c1411981b36a466c3ee086e08cbbbb242ccf8c25bd5de00859c983bfc9af73f6eba31d1783bd4acc6cf860c8b605a2fa808167e84eada3de937d39766d52460a8a5089df511f617b17c48424abd03f642b456c49dfc67d87742340398fc80a0759177c20b7227bc0a218c5965fc86ac8196640864d121b6c075059fb8ad13098884fdd45d91e8cd81dec99fc3a8d03e50bb0a55431f9a5f53348afa2fa1f44af06ca3defa7484b65b6bba6a11b1d6a4c13a5fd8d68833ae61628d36b76854375e56d79982fa6d1d2f9b982eb94ab36fccfde4a8a28dd47a86391a58edb0a965b078cfc0cd3b738febf035b40f2a16d8e01c9c4b878afbae589066835245dd511f971d3c4788647173ed0ae59a2c31ba7b20980ed19847313e32434f90c28285ea00e3d4fcceeb64b5215c289af7462a60073dda972970b53f666c146523876e48b7047cda9d6ed5a3e1487cacf98f66393ce9bbb2b4dbe405c404f019e01f4c2f8472df59e2cc2cd474e9d0b5fcabccd5161624f9519b00799319eff2b26358ae06e34d23fc78813a57883c6a4d5bc9105588720b099efa4aa82648067f1225653ae313d76b59538d0b679f15b94dedfd56a3779928d5c69518055d5968fd8b4eeecbed413bc2834571f0e19ddc1a3e820e4d4ff9e5809bc5a3c001b40841ca065d6927ac86e0deec32957eb13a2d05a81afd2f5caec8eed5f742cf50c7d8304dd475f43b1828ca5f9863f97acd3b604d19770964102be61da48084025661b0c81820ffdf4d5d81d1b0127bbb598a4306272dd380dde47d03c3f20383178cf81caf04f834d6bf0a79ac41cfff607efd48ac0bfa5b353dafbee1fd269cd5e5edd86a613a562df7ff57d22b1db8ecea60305afd6048e5b51ddc0576d2dfb334749bf85a7efff62c47e0f794cacabc44b81bb7e5be7af81c27e35a244c29d56fa3dfe3023a3f9fb2bbf00f3c481f28f1630af8eaa834df3ca6463a86c68c503304b85e499f809fad6912dcdea26385b62e92d297191c5eb3280c47499d39a81e826672330243ff113b8650c9822d3bc182a83324ecf98af19c18d1e2779ef921516345043de225240cd660b0a17408bcf812a55a2fee4f31ece19b86d746d5c7f4ae4db3e5238cdd413b3748b08335c58e109fa82ac21bf583f3516ccbb837e1cbb8b7349f54e44d577fc8de51bbb1a7fa339e3e6e9c5cd2fb4dc2341bb8d36113b2b3189c0bc60c3eedf338707e4d13e9c5aaca43517cd34d2ec03c1e585edc521e7c888fa57150e73fa785f8455bd3613cc1d36b11d6e0295a9936392ac721cde5638128ade1229fa775259183f5b8b00de815b3b331f2b0601a687fc96a2846e78d131132e6b4b482534ee402ee34b9573aa69adb1c52193f3956fed7d7f68cc9ab53faa72adf47380e581419873fc4c348c8772547207f577cd7a405f1ab57328fe5bb80f298ed2bf9b53e3952c9acd9365861c2dca67e23e47bce8ae558d8a9e4348741334ef1912fe34f01c933b888c3686f4d52ab9319e131de177d4c486963c346f9de63f9f15c4dc5a3398314b5b0d2a2cec5eb48969e29399071f67ae688b3ce6432328db761b41b4c5350929c8cd2910bd53bcb6815ad60027e0d0356918eb0168832d00b596bab11405b53fb1dfc0051780e151edd1c0ffb4d6c6d74ab7699f87c27e620de92f8ae085842d41e2d9c688ae5cbd79b948cb1d7d22e149fafde353737e2a5361a22e5df2d0e686a7f1e9834cd762b08f51f933e4a425aa8cd2328081a692e36b74e387fe508478425569c20de8d9d72dadc8c60eed42eaa4cd4c7adc2caa3c22ad2763b3d0191ff760d5baed9b421d8bd9b92342f9a2a253cf360dae7269108c33b80b101084d7b3178d76a8606f32fb0d8b77d286c05ef6625b74a1fcd54fcc7e0a23009879f33586eda03306ae3cedb128e4fa64770a310be299f0e65da80aacae3c21cafe4c9547ecccc3e3de9776cbd5839df4b555b96cd01081df41a87573a9a56ac7b6df4e6a0beafc33259932e549bf3f1682734dc3c854f2720252fce15592a0cc1c059c3641cd06b544652afad17e6f226b83e2e8d1e2db355d7244a99ee602eabdb5a773687e8a1b627686c25479f51600d2fde7eda4ec097fed86092bbe7ad0f0f4f5ff9d11864a54d420250e662245a4207b3c8bc6c305cf7d7d23d10a3401b2f8e929bc500171926ea435d465c0525b52df04b8cf88834237f080367dfe5b74892fd05b664bc839deca84e1fa8053c2aaf41627bc6a8ba72df31b2d7df8051c07f8ec40df4f7b9a5b2867f33c61463baf1c548db3495fbd1aada66b4523f393e745cc8b19605d6d044e055bcb026d54d3ef2d2cb2b0e6164a0cce7f3c26b8a35707a4253cc2a966b2da5a8db6d5f4133015dae90606c996141c957b772efd3ad18fdb592208457f3d8da919c57b83af6e86995c354f8c2f29f11a34d20f4ba0334ef73e9c7f7ba23fc492c99069a3b51108d2a4da69a14dcc2359ba99a9574fc5b4592d30a785ada35a1a3f97c3356babdfb3afd9e4d9d169e1a8e75c009799dc8cdc7457f3319f930d65ed66ee86f28f207985eae7ab7bce97542e153c4555b0e79eeebfc25175777350865bc46968ea27f70c8d9d82cb9e68e23f3ee4c95bdcb1f9d17e4744169104c7765a6025c7f1711db08d75d5a45eb80403dfae2eb2f7deccb01a5e1fc99893dc42b77d0802626f657fd69b25e0e1ed459378eda1ef82bedfb601994a3f641d6857854a220eaca7c54ac2c587414aec17da6138451b09ec69deb6ae59760fcf7083142b126e4528c7545f757a7d25720d4c3ef10bd8d3b4fbeed67484796727a986ccc53a0975466b4a509951169563771e2588ef1ecc1c7ba52a994bb61ff35bab6e9e6adff5c389c6bb52c97042b61f8cbcac291c42a6a64df969044ab4bde8bbc1300db7965acf651afaeedb570ac6a5a36a382c4b761405d4aaed34e1bef46fc5817a971abd7c4777d844b0140a883ca7be6e6312b046ab8f37054f3f7d3da78ba16c8d5f7056c59019ed7c9cfc11592fd2fdf59bbd3323e412fede554a00b2ae6fa0920d5ef2a308edbb8130d08f4c4e864a8f715b052c9b9255e033c2668cf0b19ebf1b8adb6c3e685ed85e8529c7efb2fd8f5fdbb98fd66087cecbae917d997abc265d53a794cdce5f2909f10e195f8ac4a29dfaab8dbffa409eb2092fec921e6036722ac88d2815344d70b3ca1079ff0435f422b6e6d5b7c7a72f430616a44badd8bd36c9355921cc97953540a02972dfb3bb79689db17eef5631de53dde0ff5764199fb67cce402eb077648e43fa958627c95ea8bcb3420217fba583e25d0c23e13856ee470c0bc5147c9a754610173760d8457107d0f716dfbab80497845f5af3f96479febdb8b56039082db7299007594d85cf512fcba4a0dcd3548c165910f39704eaa13aceccbdbfc6c8f5b06e04af1c03d4b034d60670e33eb2831f3cf72f8576a9a55b01d502715bb5b2054de1f228ab1f300c3221e3a12347f8f3f5418314f7b6401efb114eb48695d938708eb9959b9ea610e6cb2da646ac2a2506f24c81461e7350f29ed0c8f3b5a7a8bff04fe1f33f7c9f3b8fd6570015d671b534da0e37ff49075b0e0c46ba32db89fe04af60efbfe529dcc7d68f41f91a645c81ff64cffd83b48d21ae44a508859d6af1fae83a794b1a6100982373adac82484db7e1752266cace9d01ff4c619d9b65170d2b346ecf3eb912832c37c0acb189761ef08317bfe337ff9afe361b8e6e5958cb019be43df3768981c88ea44a7f6c2fd2a8560d4ba6fa0171b8fb53dab72317502e58ef0588adbb9d714bc1da4ba045575dcab5d66cc3cb35e2b2918054d99fc961a6910b6f8fa257b3d23cc42d02622b11b313a5873ed119528df3ff660d7c7fa6cab9a0153969ca484e2c17ba751f15ee379a79ca3250fc80b234edc26741cb23f4214a62942a204720962fe2527f19657af5c402827e7d103f0034655ac172325ca74711ffd11486181419f2eb0b23fe706ca4f224dee37e066feae210e414f27b9aa6f0de1f5c7c56e3c73fae216010ef9810c5f665c7d6740f6c3b48c44286813fb9bda8c5976d43ff06962e80beeec509fc5fe4952c032643763f6a11c67bb96fce5a7ad92710175a7d457c4756852ca4056da7adcb7e9b10ba0a090b5e7e116d177bc95e8ef8360be74b01b67469776cc1a6677eed3c5b5aaf334e4fa85c6c7c59bc55b9320df6511f56621d8216b65480b6cbb944fcac9afd0eeda52561108a70e088d2bbeb4cab4633827c7cd57def714115b716f88750677acef74a78536f9fd5f1c51969bb471641b7b5f55ebc2c1f64f19be12844987e536a5ba095819e3b4e4382805d9ffd3b80f03ecf736ad1a73d54b9711437372e0a2beb49d6571000d574137f82f3d69762a50e1f47e5615d9c18ceffde637994d51f0cbfa3e53b056b85f1fcfcf140224dfb4f72e7369b0fc662a7b4310c8c5de1e2f16b5944ba77d255eff0fe9c8e44af5d47184552004825ef758fce3f2b4627e0422c9f9eedd235f0a3f305ec415f60dc098d72f905e72ad7dfc9c13def1dafc2df5c24799736582c510ecb39dbfd292cfa47dbf61da505f3663051740adb0a1e4a5a9e124d8ede3a32606af7ce8c4bc0a38d9736b551a79882fe9e5faf7e5bdadfdab75bf3d50e7372e3d37a8a36c9593cf88fd29ebb51fabb2e2e29111fdfa5abe81aba3cc3721fb1a00a346f3a2cf4458043e7b334b497571fe0d25d5067be691c2ff178163d9fb69ad3c7368e803e9af8a269787fa2c0a39cb658823d2f5024a217e1396585b56dea635ee867e7ac4ee4b5b613442c02aa47b62cc9972cd41dcb7f2b5d8a0f0106b8bc59eb0ffb466932dd9f9d0eadf60aea71a564c5a2f0e52bbbc967bf736c477b910cfd8e86c5ccc9c36e905257df1c0533684d23530f0e3b45cf001ffed8f141fe9448bdbb1a3f736df3251f5bf43870aa88e2efdd77a4fc10acca06b2b21bd0de75ecf13407ed3accaae50736094d6d912654dac808fddf1830f1bb39187a2e5e8ae40cfc7246ffd45d73c4acf0abd3501e66acfbcb7ed1bc5711ae96a9683fa86399f5994c8b293518ff31b33078618e4aff5a5b24c39ac1c5fc4a9b6f98332c0276bdd7b6fe5dc3b36b0727b5106445738b34c731719aa72798bb003ec0b1b973ca2ecda3ea900b8b0fb97e4977beb76f5b3dce0064d4ff80191a3c738d360f91efd1cec83127f3d6a18389fdf215452589b38ce720abd8d189b4678c370cd689f3edfe7f4f3623a2081ed3bce2f68932055b7830bafd06534350c0874815c18c89384ba2e82c34c403768900a59a72d78a4df0951ac3459def903cc03eaa35f7eb64dad4a91caec305db3e7d74d5aa34c4c89ede1f65d89a1ca403ba53a5096478d4d8cb171f5420257ef5529da9177deb7b0eef656cab713b7d85d0ba445d08dae5d45d9b77073d55a568c0caac0227dac2719bf789dda2af6f28e13293a3a2c33b20680b23065584d517f258ea88c2347d663e1b48c8931dd149bd20b19aa310d85884f6355a390d14bc004a6126616536e6aece28c7bcd82da3350c791e5ea88385a0b34e1cd4eede0891c8c3e6f721259e7f0e9140d66fb10847533fa23be9923cd72ff76520db4980fa11d05d1c649c8166a71329191ebc86c9e240b11a3528236ac7ec6e740c8fc20cef83d4e0e38bb167199b9e2644340c4e0a2a134e22c5823efe27f579b64afc9d45d44556b0146a4871d7356f9dacaee0309abfca6ca53c19aa634c3d6d4bd146db5ee362b0aae4f0fe56b027aa750d9092444626cb5b5633d0625aa5a367fd6c3a0e66c770cfb4e8a4f327f07d7b495e2b3061a70815ce4f701c10a84fd996a2ec3cea363eca82d6e92cdf51ad1718dc6d33b81053b261d9eac9cba2b3ae3e0124f4ca44a3b2846afb69d4f9d5f45bc2ae10933914b9d484fcb7ff5df54d46286c9ceb51ec8f990b600f0c65a218e7e1ca44962df6bc869cd34711efff0165211c7939d77a8d1edde9f03e1cb0ba4075bd634993799a52f696ec9f6fe812e26bd138ee364ed1dde6d15cd04b1f13783ff95186586e562501a459f925f75c66dd18b9327513cb4d977a6dbf8987df9ced7126cc233722e9b872ef696bc74b74e229e24e9773187094a79944a08398e74da97ace2df6d06498f0e3de2de53d1eb62687e9b4e67f1c27f018ba0ad2b73d17601fb3bd23999324acbc6ef77b3fce7d2f7f2cf5129f583cb0d2ab3d027c61334c58eb649eb97fdb7832ed99bf05604ada23699996d33c82d71dc1c043884d0a12e24acf5e35d45272ddb3f9ecbffbd97a7b61fb046395f62b7a9b51c50b21914183ea367958e297e8d52655107b8592cb25a432fd07a019aaf1af558aaebf2164ad3cefeef7abd0cd2f92606a88bb99a06a3e905ce7128229bf8eb538f6c33a2cc575a3bb39a4c46c1dc0db465e2d9ed1c6d9f80a54dcd2f44bf8fbbd2bd8edd23d11be27cab5508683a83a3a28ef4474a6b2648f6a2841d5d289ecc5a514aee1e82570fbdce7b1a2fa78d449bf3ba9b574fb11198ac6ccc10ba7f67f1d1b8dc3964e4975a35fdb3b1f543dd42651906ff70791b7dacf14985723eba9c5fcc138ba479d08bf80dacfa1c63de36f66460deef1baae7bea17efae6aa2ca7f68846e4dc2d0405aca4277cc921562e1641a48e7159d1ae7cb379973e67cdc30ca6281ca762f4098a96250fd5d91ab86ffa0f70b9c52480d7cdcc3a755d76fd500da4c608d331fd6339f0aa32d690622c4832b45cad238d455431987fa20e840eddd4505cd8d2f87c5b770be12481f5b81e4ce4da6689d356a70f7c7e363270ffd029ad1a1aa7ed2b14f9b9b29af833af4c0d519d6103c40bbd076a8da1b8e120a7a9c21abf29d2fe7ddc591614824aa2431603d4cbbf267e997561459e8f24a0f6f4f7c4d7cd07dd68d808d2d1f4052a41d8f5f6457658f7ce652d2393bce501f12ac0b72c2af7af017284bc9e151728b24b73356a79f84f341915d606ea2331d8d19c7de22a6113ebbba0e131ffb6a6632fc26d561b4a1257dbf71ec107a60125c2533ec274788942b2d756c8e080914148e77ef48764fc66356fcdeecbe1a199c440e7db5bbc1b89bf7b6f1424639fca05ac6c9ec5fdd0309f05c3a447a45812e0d5e54cbd344105b39cfb3bff6c0652f7e1c5f165b8b09fc98927c44c40565cd6159443b22d4aae5eee3c1616189ca45e1f50455be9263f5259bb61a09246f1483ab079ac1a999ae29486e903b3535f917bedde5c01220555c2e6a591b487fa95149f618cc741e11762949dfc486385986b67bd8c3c840a4c0138250420b9c40268763a8c2a7fb7b55fb9dd0f4934cb1d780d693a831cb973212f3b811ab847ec7c7dc823edb604d18195816b6076847267306e6270c1cb1ff2ec9ff5486edbe77706702b945fac57a7ac779c7be9d3e96b6c072a8aecb0a6b713f8e227ac50adad04952add069aaa7e6fdc3562453a4b02e6881b0e725c9e4285e8f09ebfb06d940a21c9692f45fc071002514d5d372a49b7d7df0765de08c4441052e54dbbc3e005f09b898a32309128bf491c2e824064986894227ae1f47e3aa7adce863d50bbc774e874b602322860b41bb3681da5f50ed135e94b9163c552454cd444712f5c7837920e98b4bcd06f8b93d658d3b8545e46ad76333ab9dc1c353d01a5e141c4603b2be468b307d61750e7d4ff5caf7e18d19c9d7a06c0327ea2155821a3294cc45b70a8df19e76d71bb837269bb4d3e43aeef367115f3c841344b1a9bb41b597980ec5bd459b80886aa02b62ec526d80fc43b8ab6567b51bba0ebcec1d6db5240acae3c343eecdb15af2ed4a3de09b39b41a437c67ec044d6641a5adc3b7b3734569ec6d230e1b132b9d06f8384b474b306797cf73ecc77d5a5beebe0ccec2191bd08420f1e73528577a18ad85f3162f57ade11d5a7c5cca505f9b2a15002ca665aa8430520a2824fe2da3b3c92e69a1246853503d15cbe98ffe120d5b55dda2cd79dd22680d12f68f5996ff093c1a91e9deb391c7c784a57bb1ead71a9d7948199372cf4af492b624f4f540d04ab6e84489b8f03a27af24cac5ccc5a7e06d57fb7fbe007845b15be0a19f8aed529e04dc4d8c490ba2328346cf665d38814a8cb7df4e6c68e73d244c82c522a5aa2911380edb2f5839b2a5576e9149e10d954f88f03914754e8bb080b0f8aba228f79d4c1a758aafd168dcc41846c4b035f3787a841390eb3d4f98809d506b1a093842dbe6e5d51f4f5d9af0956c58116ae97b21feace58a2c23b32a8f0db0e1d2c971023645c2db698e7d603d890aa207b5e13330c43a1432ec3b730a902c713e4a598a567b7bbd043b19e6984f0c45e052935aa7226d1e816a2876af58ce37d2e76542ced2af62da6db83075b47606995cfad228163be49b69142fcbe27a34abd4852a48801f970b875406c2e6765b4c8236364806f02ef4538d40d99b3d197c2fb6ff2179dde9cad2f5e613c8253775b7f8c33453a16a714a8888a79aba97961c00051d6b41f47926dd77b49b3102a28fe5e308f94922c87a4e6486dc3058b29ac783507d136bd7dcc0e8021401569c9d9c6a53198807db0f6dc8600290539d03ee3e73b50767dfeeb5aa9bd7927c141b9537448542bf129d543ea0c7a585949f28381ab8daeb6798a2967d0ea33e0690ed5a6d8112cfb7197a3039db163654e7cad85467d59f10f4daf730080cb47ac23e6b4e0547060bb3519abe3820b24dded87170f9e90db59f499e7e0df9ab24b4f02cf3a70d548272d5ea8c4c218baad8403fc217c471a8bc1797cefe3f2e7ab7b70c09b8e7abe9dce16920c1443d92a08e2da39d7be45a35e1a4f27a6d5107c6ca3ca0bb5cd7441b43ad5961468ecbb1d01e146d1279131e4ffa6410f04a0a2e80de9d0cb4d27214fe4d4207fe0a608e20722463cc1cf1620c8a0971b537a6a2fd35187e1303302f8b525b3fbf9939df6151cb4992c5fbe2c7a74fe644014c4fe00dd905c0c4089816f7c9ba2d0726d57386dd0a672ec341af8ebc3efba0fd506ddf9f752d589b69f3ec49fc089001ad64a28999ffd288211836edd936a39bb0c41d76777d0df1cc8cd936bb5bf030aac5d63043b3cd7d987147654865d6f10d89a6d1801489f90285cffb31e5db81298ab12b601e3eae6d1d2941d1c4798f8eb3ab47410a89e857e3470a1f61ddc1e0635727250962f3f511ebea74dfba3638a75bc9efa8e8dbf3b22ab5685da1e5d3b217eb2efa5c1f9776ef728682d74ec238a4de43742ff2f0b564998cdb0e26b0ff07711d77a62b1140be84af692c289e4a26cdf35c44783c04bca532a26188931d389b6d7e5fbc404f270c895f06300198b7b954c58bbaf27cf35973bf788852b75712f4c93cbcbe6d80a37c30ffc32a56f606e1fd40cb22424b3e61f81f293d5d878d674def8baf5cbf345e7f191e665daea72ef1d5e049364dfe58043e479dddf231a7c19f4812628da278357378c2baaaeed680e36aed0d1a7b4eeea3183cd8372773ac585a567ffcf6dda586fb7ddf41d08f044dc2c1900c8d4b3cfb438c0b5b4bb6e6b9fc2ef586874b508e245bcb21a48d22873fcf89cdfeddfa579c6a13040b02553ea455c9219f2d8b232c9626fa2a184f51f01ffa60733721550f4da4eb2f99cf0e5080ad5c1f29b0e9574547b32741482287463d564ee018f28892cda5a454af5216fe1814b485135fff63445dc5152bb704f423f871f4399829fe417d158fb266c3cf1e31e16be4f5519ca0539fc0aa45e658ba06dcfda159ddd5ca2433fec14512df584437bcb6b1301c630d3fec0cf6ccebf2d87f8c779182547eb26ba02b35f1449d37780732450724604875af4e843c79ee4628ffea0fe4ac93349489f2816524203cc598830d52cfc2527d2cbb36d074183c670ac506d95263359dc7050b18eea15c6768bd0d834a2f9060e2c31b824d36443875119699083fbe55a122044c538eb5dad2110808d6f254bfa8fa0b81ca912b57f35353f739f458819841f296377017dcb28cfaf31c3085cc318681838ff2d25216315b72e2771e6e8cb337f0b35e41c436940a26672c20a3407e0e61cf97be07c42ece09103c2736be67d01a94cfa4ec06a7306af3f87bf39854eb49c9b56e03b98c853c21a96b75c32a5abecbab34a345bf61d492bd7d70d5f667ab045bf94f9d55d0db18a7a347227c9cc43f147d172368d951561184e8541a4381ce854a0392ca95f7acf936da378f561117a8d12a16a26ca54b4fe1e0bca750ea0f8cb7749273ec6930ae8f1ad90a8fbf2cc76c2043e68b9e2bf7f253b7a92909b0b3846be95053dab4ae72870213e685880a4a8743a25880f0f81b2c05db161c6d8c6a0f04000e8c3cd976754fe9c46620d4f210fa0529c54caf87e04fa2120b82337ae6ddb5a7483174db7db560bc6c21046f82750dc456d3e8a8449c18306ec1e6cfe1eb79d0fa785d3c9889c9a4c937a2c55ce16f9e65ed5d6263dd89ca2f6615e86acf6ac2ebd0e998c6ff8855c6005dc1c0c62538e8eb5a1816c4ff3c402140d8885341008c41bc4a23adfe7d11da2885891610d87eaadc9d6b62b5987d16c208da706717157e0a980979a926ca06aa7a88ea42896a420135b4f20f11863a87aec2f8d1c4700be2994b5d3d7c0e73788d673b9b6a8cac75d1703dd9d76724c2d6d2eabbdebe7d0656cb87b1d2a75e595f75bc6a84490f6d4d2eff3cd920e17b6cce5effaa5c5d031992c950c543e7c143d054d320c43385c761d00df800bf8398c7dd5c35d5360e74b72fd1df23e8ed0d2af25f256df4581a6aa4b655b4a13cbad29bd5fff60e7774e246b2cb876907020f3503483391c56058ab87cc1502f0b56a12df354f96b4ae5cee36fcc086efbf67be3605ab6c715fdc83030a4bf5018bf43e74e801d2f4d51b0262087d3246109326e17827b5990dd9703680aad62831d1fc2c11a96f9da600b0dc162b6854274bc0a02f9e7c4664a17779a31c3abff5abf64cec95c35e23f8fcdc3d3bdc0f5d089528bb17e1ef40208613c2432241a937dd354682dc895b3467fb2980b4276eef6412c7789dab2289d604757f623b1b72e3d84b6a6edc506f2a006c680d9a92d1c7e6403f2c95ef4b1663d4fbe8a6367d0c411155256054f1641aa83381e616aa0a07597875d830123044ba90e19dcf3006bfc1ec3366acc6ff085fca3df578b1eb5621698c25a14cf06d0e1d813dfc45054d0d3d2357b263d1b37d19c0aab5a7de1376a82b935b7f3d33a469ef93fd3467d9459616d5b58b6f77b47785e691a4605e03d7d742ba3c26caa64b6c9e53b7b0c1bd92961cb3ff60b17111ce8f61d13c39f03917e6dbe612c0de22e12c08d0b02691d59e542c73a8f666884084a33a320ac6167f58a19e65ca7a103258dd62e2bd80ec94e1ab93e435bf35fe77ba4101940e84e10ef26ac83c7206cbcb9d1ce24f4471202d896f170f1991edaadb8feca679829fa8e8b933f32f4583c2ba796f768ba8b2249d9181db333e564d803fd7e0537d58881fc4bb76c6e4a4ac3df483b6f6a6461422a0cf6a0ad7d40ec416a2863e3a5cc165d275f34f6d4d868f0af65de396bc3bcf730c8b5bb6bcda6cfca5813071cf4162be728b6c82303005fd49b8cfa1770bb8341076b7109b292a18bfacf3993a0cdfac9fc9e078283314e52783c98ba11ef575b5259869a5d87f5834b6f6bbc90559fe88d3600389eea37330f57deaf1db04f4acbbfcfc238ab3520bfd4987a7403ff6001ae1f30e8288ce2dc8dde017f64387f12d62134761541830f8b9110843cfa4fb6b6c087f500b14006ab4c3dc10d73b2c982201542c5749a71fa16309ec50ba76c71953549896af0fdb77181d0d6f8af8bdff06073e8cbc55be5c6660c624eefd71bb924aa2255ce4f6ab95770b5080e6ca07757ced509ff3bed7c5b96069866ca6faf1ab3a4e69a03a1685be6a10edbe89afb313f20aeb2d9eabc2a89e9f210db04027dfc182ea4d2ab2587c929639da1d7dd26a33f86e9a2b00a67ffa063b5b43d14234dce4c766ddce11f01e2de2f68edd1bbf7440ed31a467ad5bd6f73f2524c102f00b7b6d2e6625c958fe677a4da90ffeba68cf6f22f7c71ff8b2bf97d16164fe20d1f32598affe7cfcd5b1ee68f76ecd7a42253fc7148bb52f095aa8eab925bf5ecf1350e0a8f51c70fba1e90fa74bce86fedb261dfc9f07bb5d160d8cfbccec35a8a7e60bb9272974f5a3b4c29c8b2abd01ba9b99f21f829a2a891a961c98b956b3dc4668d0436cc1f80088b2076421e8f785620572ff5e4f7f42a6b8bdef48d4b40e3a1eae35ebc64749a654cd340f05290ec65ef5c5196d0e600b8cad9be51d88e57e5b21ddf84a3eefe43119d04a387eea36f0e2194a0ec43cbeca2b39e3baf63d9a68ea0f25f03d209cd89df7028e3ce6834b0a911582ce0c313320e2c655cfaafa4ed7fb7dc639d533245e83d00e91b0e0295147586b9cd000bd62586f07e1d64f45214efb27fed5d085461cf19a7729628faabc597f4f13cdcae4244615a4a4b5cac48283f79c6e209fb64ebaac37c4de8d748ed6e43348135a6ff3d57d6f7ee00152a732949c703bfed57efc0a0f59a02eabd1d982de534f28abce1f027b6e412d0f0c2119aaf04662c2a9168d1ad7084e23a560a7ba7f709c830e6b498b7c2328f2c146670dad71ac9a37de1a11908dc681a185735776cb72501616acc3cbce822bde1515a00977d1cd9af7f467a0cc68054c5a50f1b1db80d766eaacd96619c5768ab3b3521bfaf9437fb266b546deda18644f4e5fc1abd83c74b7ab5e2e947923cdd8ba42eab8db7d251c1b23d168003be2a26e0324cfef24333a3ce9096bf58f49c97592c9dd590e04b7c40b226ab5f4c28c3e13321102816f2fcda2f8aec50b32e1dc571d63f3f96b964b1fd79d4a745a8cce178a9b7c91908301f0f5184f61aeea0182638c692e53b2344a5520309c98fcdf28300b2f46b92bb154802e44980001051244004a5632dd823bb05aa97e7b0da0a3f080b29b439efdfe3b09a701399ba54946069b5e156c07468e4c96a4babf0cb36af27cce832aac9bfa50458163d26b6c5476a57e008647351adb3ac71a47dc4a397ba0d83b64618dffce24f6be34c9b000a1a25c89df039e0b6559323945000eae1f47a31bfdb7892184ce89329dd00251a4f84d83ff4f5b79b40a6bd8be10b19c88874a7866f0050bc8aee78b10a7d1986d1c6c65fc78f39dc13e03ef23bcb0eb976add3bd290e8fa6c5793176b170942f584c38a8482c379d2e3041d07c0375c6e00e906aad9eec4f721383816049c90ed0064794fc7739ee1c8f212aab2d36c7c63dd03507bd7ee5452d407f2cf371a690595702db140eed85e2f5a9975c8865be3156ea30ec8c1e5cc62ca2b5e04ab98abd03fcdbab659f22038335e73b4692241216bee249543666d2065fe0ae3c26dfdedaaf2591ad139a0044dd3586fcf254002fc37deee0b08d7c9e3cb750adc46010afd987b94d1bd9c2e0823d21d1056e8c19c3c198ea1b510374e3a382a8b7ce4c90e77aaa0a5790f1b5a5447d638f68af1993cb69eaf01dd60f1c90b8ae675fca89fee7d54170db74d5c959cb3b6e1ea86a587efe51e4128b6e8383ee95504c4f035927057ed15a18b3f33c3f2930e03b2fca5b92cdc7784b7f93852eef30051b40e99a0c17d02de649a8eaf5a1d2e201bea4ae66b32116a388b6848382efc5523740407ecb907417f14bbb34145eb1a65bb05ed6699d27ce2a9f3d28cbba831d951fb01a875f79a07b1fe177a3064edd49e42289a2e3da5296ddefd808d246d485f33206fa23414b8d72129408f268f44dbb592368d846fd1017e6814cc67e4697316f281aeaf419e315c871e0799b124a15494e88130fa98b771deecdac9f4f69cbf8cc33722e0ee7b1cb21b72da4bfdf5ac170e408e7d1a04ac3bfc039e19f192137acb9a60e07aadeffdcc4764d57b37ecfe6fdb4405ad3464da59fe42d98140c48b9c52848f6d3faf06f39a1e554e297c5e42cad91cd36a2899989ff0e444223acc0bb66f31e9b04947556f6dc8ea352913d57fb4ee6d8f37689abbd1d8ee1e4b41008cdb268be08137fbd36980cd3feac86f1e0543bbeb6bf119a7b55fbcd472c922ac1e6ea832209829155d08dc2340c9aa28949dd3e1dc456acbbf10cbc1f214e2fd156891bea73a4d06480b7dba44a5bb362bc971adad9f5612fcd283efbca5a5be7ab7c130be56e5576c504f090d09b6b2c3281b202370e28e0731fe5c8ae215bff0c65c31d32d81a81861b06bc58dda0c368203e590825493edb71dec18ba407998074936c5b9c2d6b3813593d717b5b5fd8a1e9d617e453faf75593e9475f0b84917cda1d684aabd8354f4f39dc08abbaa2f6de974a89ec7229c2c52adabf582bb0390831eec5b719b5a5d20fc7aef6a3a2e63f6289b453d7cdc9acb48d3a7f5ae4725cdad800b2a7d6a8d7942476c692ce71637ed4b2f9001a5afe908547d6fadd53d1bedaca4e7811180e77f3c37006ad7bf9518fa3f58e10d4e594f9ee4a96c59ee33466398d86cc3ab461ef2a032f29769d745c322b8420a8a203d6ef16568c5660f67c7fb35cd9540bee38fe3f77ec3876401b3b6868ba171890a0f297981ec9c6fa8005932431983b99c855624baf7621767333a1b92458f3de9b5657c6e57f5d41a26a197309d5c9c3cfdcfc42003a28f899e61f5db7113c1217f340725e1355f2c455e35acda7cfa8173e864f6338ce15341bc4301ab10c276e54132e4f478e101db03c6f8c4a50929a43cc8cfe6cac11239685cad430fb0bf58f6e94ed0824649b73bbb8cbe38b73e862e5aff34bef4936d664f5599ae4bb37d8b018ae1d8cf19cbaa2d5ed3e16899e1fad3a5e6cd96fdadae5d148175ab21a3a7e132066b673f3114d0346980ca86b77c35ea9fff4e8c48f172391df5cb1f5432bef7ebe31233d526ddcb5f3e6b2a25dca7fa9d977e21ac2d21d40fc10be50116851e3538c2aaf143b1aa2b54f90209e84e5e8cec5b9a76afd9ca0f6d24699c95275a6981bb87f760d2d5b78086975dffc7108655c1f56639224c2c69071b2795827146bd824a9c2fdc6dfa8c282898e65fccc8e6926972e5157a60a7a662a445eae80bdbf5f663c91d4ba414fc8caf2969ae9c145e688624c4df87453d48e5a0a29680ce0743caf495dde5db10142126e494e70999969fd66cb5b13f1940590a6e0b11834a408002fd107701fd076ab77410db11fa8251ad4cfdccd7321fa88812e7e74d6dd32da18bbfe6565ae608312fbb0e8532742b938b47c6bbc0f5da494bf14a7a445da423ee73044adc4e9ec3df9ea773bc3f8b9fb9dda93f80c3bdad826a285403bf79d000cc212b84e5b8b60f2caef0b318185fe120d09412bfda6c887856de050e2b9fd0b611be3abfe8d34809a6cb48102c7bba32dd098faafab1d458076d50a3727c2974f3eeb3f2a2791ded12736ee0ead69e203e9dcc14b4dc7b25bfb385bbf9feaa0f5d65f9e6b236678e0f314cb1368e662287c1106f2ab0afa69928f5ed8d2b741c4b05804aa82708429168003f2a7246febe07a8c52219ab2786f35888f618ad886ff0f0c9365a68ba2c4fb97785273f10d762d514f1a0d8880fe97d06096b72933889b6a4aff377ecec803cb937e0bf6ae2be113e202bf5daaec2b23f1e97421155098cf941fd345e0680f3eef4ecef4c2965a3c73a8be03348418814519c81d3f60c9bb38f4df13c58e9d95908a687164f694792b445184f648269df0955a98a0909c12c7f16b0caae7a864deeb561156afc15a487ea565d014edac45d6f58d71331cc1399e50abc25db4da99a5db239d89338122c7f160f16ab7a8dc281ce6053225dac507242c883ff3a222b579b57b41a48856b8e8cf1bef0bae10730aa138784005c74a2d219b9fd9dc33fa108590d234da7beb8d5b690484423a9917ee95392d03a677453bf77d3d3814d9b445d7f108bd0108bb20edcef6044e2acddbda855c3016b234e881dcbaa4778376a92db089b7839d9a836d6538cf01952d186b5f860d0c37b2ddcd447140f6a53a50495dfb3c5209efc54a2055e6670a055d083d4805a4f41b46bbb4333d665ca3b9bf733a25d2b411eb6960728191e2ce5a474f9f98716604877bb146a289def9264bdf2060c1515328388164de7af7eb8029d931a4a9ac4be701299a07330d9b31b1776b2c68f4d675157335cd244ae52cb2d199883ed13c73c21b4a91ce9ad035affb55c8e798802ddc27fefc35b9e20013367a333be7e48d0cc183f2629322b07ffd58aaecc442e6d40ee92a2351adde1c5f5a8545e2c572f4aece11173ac2d1a83854bef6874bb223901d67b25c701e803677272c1dfbd885968cc3b897a90b84c36bc0da0597c80bc15d266b625bf5e99a7a15586266c00d52e1bc014354279b39dfc8049f410fd7e8a2f4bdb65c10db085d8bfed253736afb4c9f4f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
