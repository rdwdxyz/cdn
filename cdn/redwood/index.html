<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24ff480aabc4d3b873fd612c17ceefd3e35da4e6a28577e4774f78b42cd1659bed36f58635435ca61bf5a8aaba9b0c258f21bd33babea0627f04bc30eab3f8b1c78d404d1f6aa059f26c7605b3b3bc6d34b65d4cd85ac72963cf093b04fd5dfeda807138c54bda4d09d214f25b639fec8556e1c70278c8b1ff6b5b2b58833e7be1e36e8d21aa7cf7a63c17bd52caeadeeafd715568355aec0cb83e4928216ca12742e8a73b14e758e25eef009f54d8bcf8622da31070a4b56e5569ca6385bbac598214ec58194c8130b0f25ac32108b4663fa8c00d310a43b33f9f3c48eb119a0055e11fa029059861cc0f0aa558567ea82f4a0eee7ff49a0f07ea96d4d383eb0aebbe079308cffc6c28b52199f85a3164912af843b75bddddff280384682529a859b6608884ad71788c18842d5a8bd1718ed1f09b4d32520ec7ba82ed5e7968fcf215839819bf6939929bc60741e11cd23af9fcb17ceec186037829a7b8443fc1c97998eab8afe85e747514e74a45d043f2f73a17118a858e106ec9949c7eda57305d397a4bc4a1127862cc831cdf0022f32d9418d93669ce9de51cd94a391103a62e4c93a7ca54ee30112f0dff35ff76e2b6006d54793813a0ef97cf89fd8a50f7a74884d3335e1e2e332f424b700734e6f35b6e7d4ceb51ab96597eed517116ea675d20667278761391d1541456c74bbb1edd564f764e07521ef6543f1068c7e9256baf1000d9cf90b9754be25532cbf071d93f6e7a182cfce520a0a35068d0a7dafa170a6a5d03e5d7d246f494395d432d1752890c64ed82f43b927b102ebb77a32fd9237594936ee86fc168ca80f53b06e99e380b46da98b6e1c512c201d50c35e6933c454f39090bbe07dbad752c6d91ff0ad84ce0f64699a75fefe39f87c98f78df7f0b898c47eb262985214672ec472a6e8778411fb58a471de07920f0711c26d0eeab272622a9be637d8d42b8d902f2fc3f613153cdeb22b2d0c6423e76d98af362deca2a7fd8c75952851b6f780be40a0d92ac0402573c06b5403d8b9bdd0c09e3f9c1b118d170c9a4d357280100c33050517bcbd488ee966d1a21513c2375e86dc5770bc3fe4abfaff0e1f3d1532cd4d7ed4131c44dec1a0ad9e691f00a668c45e72d2a976a281b49272ec0246532d42c131868bb8e687e82d36bd32d952fdaeaf3ec868752d7b5e34dd45b0f762a33e35afaae220470a1ce089536c60f858959d647429e84d4ed58054fe358b38409336af73eada00dfcaf32a1a6d166628c50110ef828ae111dff814379e045ceb42da637c0589a1f4a1b3e6161c6620bcfef9341746d33fb702fe2e77ccc21d29107f03b71d492269320a1e8560a5d6bf98b6a0d57f1f912f818c75359b42bdce2b14d5f3ba12f6cd61b7d402a63d50982a9ec13409026ba7d561a5e690747b068f8a513483055baaf8ab9eee03d628a92a62d3450e958a1003f1735ad1d70b7888103451f5758bab41b109ace1c0ad14ec1f4bca4cf25ca4c55d25a90676f41023eb9ef5271e87b38ae521d4c884f97022766140221fbfe137d406beb4dc136670043b29051a39afae078f63fb80f05b8fe0f850d8c00858454a40e0d641700ad56bdac660b008152d0149e93e8df159c093daffd7d7855de3a3a6ab36c86f57f35c2943403924f5ffa5715a7ae3cf4a20aed0c714e289401b0ec141274e9313e59659b1422a9e44483a727a6c36e4580f04552cf22b6ae1325e313ec47ba5b06339ed716c453c3e36e656d33605273b538d7cb686e743ea78b48c050d9916c3aa69238778b3af0afd8d20d1e43dd9de3602e336eb61d942265dbacbd1de8695f59500b113ae644f06fd88ee19a59f53d2c64dc57835197e082f367cdc21a01965f6142f0b4b4a0f1604cc1fc53a6f1d78cff38b957609b54df396282d9dd97dd144af39cadb73de7eeb617867ba845737a891a9850c02be7d65bc545f2fedc6b7c003bab6c4104d8360b162cfd4072353b55f28b48080e030d0a2629082ed7cf2f03997de41ca898823c5463b6cee39b7a14f56281f4f15123bb22247e9481a2654fda62ae2edf2094982f8451cb86eee544b8bdc5982a8a143bfc4f8e63e1aaa76eeda424e955b836f525083cade33a6bdbe664e08c917d52cd24b96c27a9a72cfcecb6cb2c8968f257d696648166a681507f07910ce9c888681b11da15084bf8c84539a9392367469741cec159a126303e94fbc40fac523c990bdc6fe1e334ccf40c8d56b7a3637dd1ec6cdd69c9918622ad537b2196f96251831471e1cabed237cb9f886666c5ae5b9868fbb693cb2f6a91a21c2e9577271e99e38ab7ac33a2fbfcdc3b565c17bd15e8c731c8e1428ebdacc8600430fd50a0427ca622b0899ba7858622298c51cd80a68fb46bd3266b80dfc1eeacbc4b34c7e00bf0285cd24ddddbd8fcb2730490c0f9236bfcddf93ad89ab6cc8d27f626f4b8249d295017f8076a6fa73582e46d55b74ca82572d5a40bc2be0e7413652bb5cfed44e1104402aa19130f9813f5fd7c9d3f0b7eec7aaeb5dd3b93888152cc2957f6fdeaf0e40ab6d02663089f340d36400dd154693cff13e6b09481509b4accd083cd2f066303a4e603562c23cea32e2f842a9d1c0f54d2ba2144de87fa06c87a6a522c6a8f05718a5f49ae62bb5ddfe634fafdb05458828b81994fd6ff1e7966557f5dd083afbb3dc2158b662d7b38f0ecaa95a3d4f8bc326b14748ba2fe4ffbd7b252527cc4b0aeb6bbd2daafc2d94a482a656bd3b812adbf22fe94f38f3da575c36caa6a9e361a8c1262514dc43b358239f96f7a839eceeaccbdabd41c74fbac63233f7fc63e09cee30287791bcf1339dfc8417749c834a069dea5ae888e54876f9ff3edde63b093981ea6d3d91c442731b0c0787f0965e93fd1db2bf1adefe6af500b522e11405519ac19f002e1202bdcdf683ba515b07324207f404efc77173cef88419715056068594ccf48d710fc2e698f2b05640668bf809811e3ebe2f4763ab8f03cea29f21c97d8a38c3db14d651fad72f69e3360425e1938d2a2454cb4478783b9a20edc8da4859ccebe71d41ba7508f87a4e4658f0ff8a49c37d150bf2dcf1306e37d59718798f3e9d4ec68c4846b09df59bde6336cc8300622a519dc76c1da36f7ccddc5f919cd48fd3f8835111411f1d68131e4ab7f2c1a711284b8c541a4a412358e097c99bf16f64a06bab891f8a0fef72c1c7bab169dc393a6890256761872348dd4cc988192aa5c456e216b121e500bb31b6df21c0f4cd6282a57747d32da96063cce84a8794564e6dfe9f75ff58dd86a8c0b38d1c59c5a4ad174c070ff0d6bb9c35ab04942c451f246154983afb36593f7b06436b35cf6fc2ecd76c8e370dbd57613a60a2e77088b2a828c6c72a167029b152191043e85c67b011f69ff0f5e0306e204a5f2fc73c7683d2406e11a789c50b7cdfefd0c765f0cbe11bc92c1744804e95a6b52a4f4fa03f598c01593ca85ef44f4b6271ca9942ac6aeb126e8cd23a7b181311829a5e59f2a1ce8447d4c32cc06b65ec8332f135b6a033c022ca6f2480ae394da2b1da4e5be6cfe5cc5ac1721de6a1e82850e27d4870f8323dd575fb1e2d32ff831e9069ce0dcc704aa3fb8ed894d472f9d82bd25693870bc66f34aa79eb35d046583995b30d2a3934a43e6a8e63d7cf2bbc31697228fc832332bf8bd5f96047d8545c008143eb837d8439b45ce09581581f569260ee14887886d6df386333e029b44261971961a4395419b783aca2a6e63e74ed64050ffccf947c71a58940868828d15d6b9fc49ab2cf0d1d113fb8091f73cb4f203a715f7d138450c0aad6aacbbcf36fa1c6677380208c5d20e20329c7d7c3e1b96b95a6db7b867d0d33ddb7bee24b1b9934bef3b1dd4b5261a3719c25264a48f1ea2ca202b7d2ef3db794d8600e1e73aa48b63f480b1a884dfada732e5ea70d91d4510670afc9cc9c842fc8de244f146d5a4465e3bdfa96ab6b8ed1307989bf3584a7b43bd7f516b2f69629ce474f75872d32ca45ce387ce00bcaad606f0fc543595c8a11fb8b648e253cbeed4d35de784a7a539bb989fe7176b3a2cb67697beb8269765e0bb1db20eecb66902ad3107eb76fa85d73804968b86b256c9d231c30b7bd8febf8fbc505160aedb8100a1d3f6329bca94bd0128398b4d0403e1771b6479b29d5df9c1ab87d9adf6c76f39f6714255f54863f7597de48b2e4d74dacfa49d2ea111dbce2b6d4d9a38752b286c801556e2c90daaef9abe1c6a895ae62600e22f03237054ef7ba7195902d1f3af0b8344d557200763fbe213f469837448a2433cca01efb6e23d4df97f6f5ea88c65b7e8815bbd7ba75fcbcc557307751f17a838666a00f4ce7aa7170615ca294241330e29e4e4a25d60ab371a6bb55c59f5212fe57833cd8c054b8d4d3ca746fe370ccc5b79453197ee99a7f20c37dfb29ac3b24fd6b279408c7d7842b543225900673d211ced5e087728fc02dc520ada5a8e55cdc5a81f1ae651eb8803ee198ab7291f1fa0c9cb3e7d2cb72b37e224aa809424748336566bf37af3ca2851b0c96069d5702c0c76db82910831042a3788c7e472c07afeeaecea748d0fb863be33fd30fd66a18c24cfaf3acf6826453a916e383e4f4b62d5d47a6f66e604378eaf8aad5498d6eab48a88547455ec71ff431b1c6a3f6950bdd1afb07e4a46f2a0d1bc6d895e6a563ad8d57287d3acb1a4aa8e59c5f695be330d04cbe7e3115dfe9b10634dc242b67ccc061967afcb81a33cb54485a56ee4582d0969ef740142474aefcb8d9302e4a1fbf9df856613130a0e2960697e1bc1ce23820afa3ade643602090e9e35aa30b41851e22af50dd9d110e4900b540df91c6466e09b5767c04e4c7d5cf4293b4d691915a5c1dd663b8c9cc21a4c5ed2ad9f4b5a4f0d2a31eebb3538dd469f02710ffda29849e75a91edf7b510072097abd1f21f81819a323baa18c3cf69f420e208afea19a778330541831d7832820ffdca30dae753c9abbed063c8538accfa8337414a32b3a7fbc823774aa314f78184be7cb2c372e3865e1ea8f9830958269d1c0b0f51b829ece1469bcbe93f542165f59923734e8b6b22691b55baeda81861a65d9f649f17c3c2806cac0c5deb7247b52aefb1a1ec75a2356cf5dc1939c0a771cf299d3e933691c023f70ce0f42d56f0d7e02fa010a500f3e2aa323f8a1ca2e01b22ee2a1d78fc6b86f2d111aabd0978eaf056fc272d2a3670d12e2a0650c8d8faefdff8551535cd579cb38140f19365f85e2bb59111476a3ca1c740335143c3b31bf7db7476106d1a0633c75236864a626664410d9ea870a7f9ca56184f4d2bf4152a35879e5e5455767f51d53dbf3d3f217aadc671482af17fcca128ec343964236c608193a288f807a5a4420654e22a785885b3b9f0cb0d577ee7e975cf8e40dcddedf18133b10b929da66a05365998a286b72561fa3d113a4b4c6d78f95ea7ddd8536ded395941c086c162a56d77c7c62cef84fda8fb0e3efe1241eccc111959406976b85f00972217683df1d4bc7e78d062dcae5df4bc3e79d34631c9f1d284b1c9ca016c6984a53769ed06bf168c71dbf639cb47ba6499bc0594071bfea47e0d1fee5e3016b07e0fc36ad72010a5f9feb3836da26fa9387c4d794e109c6987f41f09f1c96b43c18e9eab352561835d534d8a3bbd4218df240287266ec9f068d6c4af9faab832613249bf686da6b492cbf09b1c611016290af7eb1e8c317cec46875314ef43fd5e589d6226936a2bb0184e04767d043b1862b5ce8883bf6639f1b518b351b1b2029cc9191c49685a9ee1fe4d8323e0440800aac639b575d3ca49d746497731137f9d9f1f33cb91603bebe010bdc5e4111d3d4d11433acb449f5655361a0244cedd7a3f20d32181f7986f58004676ab9c837be261ed107fef56bbf0751157df823242b3eb868e0c9d85487e8e72986653ce7099bf56b19f2e6d03795f9af022ac1326a10a98c215b6c6cda6fed05a24deadf8acf450921d261682b490cd38b6fc3665f1dd0ddcea11e7345fa5554c55097a659b368e56ec998d2ec4ce033234d0d599654d5584166a98cc7488e6f0e21b73bf36ac18f7f24986831659ebbd4240966783f2568f5613b908efe031f06f4a0bf67053e7e9b63fe8e0c342423f61023dc32c4da938cb30291da0a9e7ecb72fe8608e7c4f9b2e0d3bb5ca619fedb095cf10386da88d07e2b36996bc573e0a01e2d021828fcf135a7790176f92e446ea46cf0c6c8457e77adc6939ef5fa12f154f0eaa3fc2c7aeb0ed6dfcb9b83b9b737c492710839b696437b81ce2a20838ff3e282661436f45711b92a40d71be93f9e767c848aa28e433f6030457ffed915c32bd3340e9161d13f0ac38b29b5e30fd2f1d762a05ed314c38ee824f0fbc3ce764e004ab2334eec7e879b2ca55b8d4e7d85fa084f051c184f1716b0285ff1b57bdd591dd7264402814b1900da5e7a0a41815f4563928e7f5d2de97eb69b917baedc6148cfd2a459571959abeee35e9c9650377366d513637dcaef1da47b152189148e738304df9760e252a501e5b6aa1ea4aa0cc3d5a8b36c9544c2dd8e50bc3aca0bf0fc8bfca013f901a7402bdf491928e96a722f391673a6cac841e86bf686403d40a54fadb32a9f642d47cf0e103a454c5d9e57f8afe5a2da000576d65e50db53b64fa0751e166e2613de41898b4c0e3b6ddabf636f85599f22828fec84de36fc77f2bc2f8984ea5849a06ac2a9da301dcfb7a871b3fc18a11c64b8224d000641e359308441e89d5a0d9caefe27838d7ae5ec7ce452ca7163dc2cf263f166f98c217314a4ae7e02376326fed7e4809e7ba6e5cf3064eebd7254bafb8e4979b0d754adbfb235321e8ce83c7d7a669d38946df89aad6a3dd194826bc59c18e25a68dffffcceba44df5e4bb4e7f4004069c4edc23de65690531e47c7f2801b10709467b922df6bcf4804e649ecdbac3f5561a23092a3f95f3db73ad4a2de1ac1d28898c607ee6e494e4a27ec56aa0957caa5b5e59872abd7480695040757f65f87104deb96250b767d9cdef4f29dfcadb5e129f43fd6cc1d3d2f99a2593103fb155ec51f44d072a5bd2c1a14983d04de59d3758e2c3fec225cd62cc38c5c901e22160b9de83e60518e14e689c133b4f1eed13f0e8b1fb31b5f771a92c16f1daadba0a25090d3363715134a6e002d5db9219bc9ca59f5b5396fddf763bf0aa24f35a13e0087d43f8c6ae8bc30ac8391e391faf6997fa426061833d00919539d9f00eaf19449df2c2a948625bf19186ed65fb96572877be8a59fb285f24630d8aca42444846dd67de3ac06daf8cd2476bfb22a8e4ea65d08c91e8b6fd6ff56f0683742505e432607fea1c5ba5349b0dae7796253067e6ad7a80546bf010abaa7f229975f97ee678d4849c9b07ec7ee8ed4ed15cfafdcb50b85b7858e977babffc21771ef460d1eb508edf1c68613d9d19c6cf9290619afdb909363e8c831e310abc031d54eb125637ee6f7bcbe15e75a62692474318bce3052b3a9b6b7c846aa0c81f7544e18339ad7a75309ecc2393c2cf13ea25dcc00a93298ff5290c90a4be4ef91c9b6ec3fad12c06aea90a25fd946f86067bd018eb9a6e0615b8296ce09b14702773fdbeb1cc011ab5f3db29760b6759eac4c26ace03870d92031417aad569844be1e63dc16791a3ad5aa0024c70527268df6d595f5a99f5d9d96f7d6a93160c3c9bb1585c3d1e06a18b62e721d26f2e227ee81325d06d6afc9953328127f8b9d52463dc9dd0463614328adc07d593164eb16f8368c9ca5865bb172984ec9abe03cfa9e0f562df2641a8b0e5317fbff8e65f8a07a2ce5f8100770fdda9bef3a8418b5d8b2af1130a499adf97531266a4aeda9c8915bc1b492529e5e1f9771e397bda3027c1793b9665fd3b96d41ca671143103feff666385b39ec0dcb1f2795b40306ea2bed2b3a9e81d3483932be0193b359bb9f0562087661f0d0d0a410b8fec414c453adc57bf8c81573f51f5d52c2f5d04cac7b73685d4a2c819b1e71d144407ccf47c70f0c353ea51d7abdda439944dfc023a3635bfdff6496a3e739b921221f082728cfdbdc635f7c62ebc1f321adb4c0f9eb1193e6c748cf5642a7e58c1ef1dbd6ff5b65424070df7d8bb05f2a94b9f0242c9fbb0238d770885b30b204f0967ec0a263e83c892e932c451727d354bb6e59170ea29328eb4912095b95a5aed92e561c70eedabcd7802ab0cf3b0d9dd4901c448c5f1afd517b76726bfccfb0060f1d9c138572093fcc1d0c784cd928b631eb13c009a769065260805b6ba6f88367825f29fe942b43662941d69274d6e49562654ceb582ad013d90ed72d10dfc0ad5999ab19da5fea4b6535c3168f53f5522379f0295524d6b8849d4ab052834328829e5d1e4b80a20f8b8c660879804ee1244707747389fbec94a3218cd93d6a5e87fe2ecd922e091a0e9a19e824d3ca39b72f3427764fef25dd8ea95092df385429d591136da9764cbc9336c2524b6b19585a99fbdd665a96901a542b9166770a18eafd8a2c83355408f9d3ce766257d31c544effceb0e1cc8922cb835aae398fe28638354781620b862c7cd3b8210d4499b06edcbda097a159a85704aac24e72995029089b06bd4cebb0050c543a6876e6c09e304be6a16eeaffa6d17b72b47bc5d9fffbed5453c9e74ba1ba197a4b2736d04f5ec0f2c37d44933a7e5a97cd87d35bd42384c3e393f34b8527e45479afc1a6deefab6605e598e9564a4ce28fcf2fa44fe71fec2ab89b5733ff3612e6854f59deb7f23f9d4dccd97144f56f8214349c77e6dfffd365e3962d98d67c0891250ae593d801d82a3e2a00c6aaa3b93eaa5422fb52d0d89b93b69dc2a28d767c183b7a1d9c075cc09696a72e121bf6284b9d3c92930cdcebf5f97bef8a46fc311d0f3dd8899b1116b9cb32fdd66665cab5c4ec08675d3461e6adb7f3343f1d397e309651b4ef80d759b1183c5a1fbab0eda14470138a8ae730bd2ff756df1316e1c57c5a2dcba1fa2400effe3f08c837508cf9bb41dd9b4db11b167bb1c6088abf81fb60f9bf9e0986c74bf60a7b90d610e1654b536ac3ec7c6aaef7ac4ca5cb70788bc2c76011699e8da35db74b03a721536d3df66e08494ff9fef041dba1d40673da9d15862dc297059ecf86726073f0875c7133f4ff4d3652b7bd739b5db1ffa3e1bc8781b30d08240065a7b99e0180fc00a5bfd25c37d0bb77ed486e302d5531411f05e9ab364ae6fdedff779034df2ad125503432739b0f96145e180f9477bc7ba069d9f73034e325b21d7b83ebcec8e953f6783e8c4a83103e4974d6b9d4f6f5fc28de6d34fd8a8c5e5fe2d3cb04e9479d04f2d7ec686cb48868d8f38ca6b538f7c6a2151669012da911d012b3a3f8b7c902eb251f61d4691488321cac9ff7b59bb51398c0d24d0107c591fac1c45ea197fa9c93b155a396ba7e97f041445964c5c2c1f235bdc8f4f635990bd442c06b37888cd035988d36c28de78a18fb1f0b346fffb94d12b71cac1ed08d0e2bd6afc59d1e2e3d5da15100278d82ed2951fa1062ab251e1006963b85ac1bb6efd1650816b6ee6584f9da35ad1914a19b6060e8b75bc1ac15866310ee1b3ba3ddc80a8352453abd4a0437ab7f05330e59d8cbd85ca7d2083fda79945cfb127d1dfb11cd362064f0733d214744ccdda0e83ae583092ffd256dc146edce06f2f1d90a895ec44eddcabb7f0680175bf10e2ed6b472a7178c3bc9ebe5fbe34b2ed29207fc14dc407679f580941e60c03f2604a492cc31ded321745143fc49dcea869be6e473105c15c1d88e85b8471ece5876a800b73ce2b20e32af9b4f708ef72cb2fc9d29dbeaaa949a4f744c60dc04aabc5a19b22be99aa3b1eb556a6634f7d60c8c2807d6df66af94abf7654714f2bb841fbd71c236756296df747d1b542aa1760a46b6f87fb37e277ddbd14aab9dac082848e7a1c13f7a5c34f410d9abd0580a3b89eb877d84dedd82b0a2af8639af5aaf1c1c8a55ad2101454856b797f4b118e2f1561bd1d46b65dd6685bcb138f3255c90e96c81e519c0c584f98f84397529cec02fa1cd137cf16880dfd9f1e9b8e0a3a32f90c202303ca6f2cf50fa93938898dae41a243ce2e74f83d304d44a108f07f35f814a9c944da3d72592b0ee58a0bba65d022325141b4cf9e71494f7ac83b9ce898596fdec1ad864b4a8dfa4c40ea78f420cc9b3ac0465922e5deb57dc2fba358680e12e1718d744d0068dc3eebf53c108a7a7319e1590f89705ec421c02ae897053d7abbb09a86e547943aae31a873ae89daf1bd877cab3fc91786ab62413ed1b9235370e7a93a3620688255287eab81ecd5f3ea9f637b23ac9cc997d484456dc41a8f5f8140a031e19cb4966f7ce4e82a3bde02d798b7ec39d875e79ae03442dbd6411814293e4c9bec90fc23de7e1811abcd68996df2927bd292a420717cfc7b17e2df15e99eb7deca78adb61bdde05ee35346554446c572efb050a5fa80f1712a52ec9e2a741458da8bb085df9bfddc207f3fdb413b23b3e486d19e51d61a240867773d94d940f6e083a82cf2c95d30c18bfe9ce474bc9ce4126043d983a977df08e0c3030d16de1cb9b9880af76329f12f2575864e591d2718b2653bb03483171ed4e2056a7efc106fdc22234533842588158c7ad662a48866d0e1c6a2f8f853d629d06b2898f237cdee7676f97b1672b972979fa8f3ccd580b1f5e2bb0f4e9d5896e999cb9a15de11d65581415bccb94f4447027d84cdc640788143386df6ffc82a248a90fc48a0c930a88bb87b7624b2c0c763883364c41ff6f6dcead777b9df5aa57379e1d7c2aa8a73ced0677cda2005a5e16e80b9608cc883a97dcd1134fca802593c10403c7130ba0d807bf7f71ec210bfc6ec32f85ae9d8f7fb972b64bd1953a3d3def869c525055da595d9adecd2c6730aec3e1a7ba88a4ba4daa9fefe72cb4a83bcc985e4c12a37af9238ed48fb3540e3753227cfcaca405f4d8eaecf35612b7ecebcc951d48367dcde585fe496f0c770fd7cd40ce8a5357a6bc9665d855005efe2582f503557369692763d248cb63e02adaddaff841fbe1880bf2357c8eb59ed9d18fe3b0091feeb41a7bc20d6191cabfbb0c93db76b463680882ae512c9cd266ebbbd269d7be2d09d1bb602d9e6694c7469a7c00a5cacb64adaaf295032b2334721058d02afb0c229067aae8fea53d9124a869149949f3722c0c1c26ddf5ea8539186b7e52b3d1204404778ad82d249bada9cfcfe7796f2dabf5fb1efacf35042d31d4aa587eb409034948315199348f27113248008c360301d0fb8bf3464e907397e6550c0ecfdb9c090114d7903563c2ce271ffd6e9bf6fdf00b806b51bbae8b2c2f229d31133e86b46f7c7b5f4ca7fb6265ff259b67083b4b5e9a46d782669864c159b1bf38a8c145ed8466803f7d338f5f75d0da64317f42eb503266d6c1bbe00d9adfdc3c6642c2d969e2ac22e4a4d8133cba5e46bcec2a2c8a2a5c97ec12379547dd9f69e86eb4c48c91d0385a18618a3471dfc724831ae17a56c6212f8254c797bd8ffd7b0fda43c52d390a4c3269e6dea68a9d46c245ee389fde16f5ccd1a8b9d52961ad4cd63a60fb02fe1a9ffd89efcba525d6338a165a2e5f198b9a217b3139890e6acfb817e87a102fa7783cf985b94af76ceaf2a72f7744b8edce88e5037c1a39d84fd1d23f17ba2702b3c5fca794a2a71496d97c97a2f54b3d1802e5ede12365cdf9981701db79d48a86645a5dbde081b50a9f22c636995b40333eb7ae5c3cb35cdf2ef5f1b5f2d558d5668e6bc46d7b96377e9de74fdf37ad494eb6912a0edc7b842002dc5b3bf0c4a82fb9a83480bb32f6fac74ac82b5e7ff1f4933f80ddca0f29901496d47d6b34172731f4cd5de87a42d155c819b888cc69d53313b55c030070a57bcb156e5ad6d7ce0587e3e67c9071d3748125086ca3330589a4a1a3548b13a89b04c2f5615e71b2b2e6b65087df27e5551a568811ac3aaa46b3d3be157d650baf4ed3d17fe0dfa5c9c8e4792277173f5f1de1a05620ac5062e93993c3579dbfbfdb9baa6d6b9140ba46f88928c5da76ad30ae1fb7447aafdc3481a1fd8af6f1574b23e8955d47e87a2ed10395951a5744c54dc90e8af2c172064d90e727560f81870fb1d64f75ab7881c78b012d254b8378b282a1210ceeb4754fe6cbd3e7b98744b87a1188112bebdb3003fc0e9e9e92de1c7dcd543844d61a53c30376041ef636e8d1ab987dbd683a94121ba5ea3b51ba41146e68c3bb2ddbd9e2892832dfeabd367e12a959db4bad73dbcef06b1adf3a337d5517273d5b570388dced509506033d93dae9abe586fda113e38d9a58ba254d355314556cb2675285438892be72813719ff74f77889829ba3de042c00a8b44477f025ef28a4129d12d86023db0140d9104a19c49399b8ba749ed629aea079480dc158f70338c7df2b8ad71bd256fac72b133eb549b23ede52a061e620375e38e1a945de8d49643521af526dddf8b8698a71bb9b190d66a0e9f534ce920e7f2a604b7f291a2758508be2d5f4874e6faedf3417053b82127c9b2b5312310d863c0b3366def56a24738118efed81fb55fd796fd36f32b93c34db5fefc09608671a15f510bd9112699610085c52fc616106bec411305aebe9a1207ae7b1e2a8b205b1d7bda8a900ad3ce79283d9a0684b0a282b9b9aa0470d34c577c44abeaa2e3f5d6ae932d33bd2934fadbc3a07e57719213ebef1a99239ef4b44576e7d5a8b8ccf46bde025246559de3baec6ed42a75a8db715079bcac8393c6688b14181d9c4346f1e95ca91f8edf1b358bfe419be47f576b73aaadb426ba299fa75ec2e0f87ac48b65dd5976e6eb2884612a665c4f94efc935ac16e817704387dd51622b73ee8f28773458438303b190542dce3264b59273f848de95db2ebd63e5b620941167083bae27bb271505020459ff4b441f4f1534d843b7f722300ce50eb622f8f044aa881b7bef16df5a79b9241458c9b1527e80e9e266504d5ea9e3b052afefcb830886e577c7169fc181c5fb95caea11e329e951d30a8f10740c111ba22e0a35a4fa3fa15321d8a13971120021f27f28dc618bdde9266b022fd13576eed6b740a97593565f290f8253cd79f99503a554887ae88374a143c6c7f37de538f6770bd753f05c4afe33a3186abae08229e6bc32c70dde441e7829f5a14ec467eb8393e3372b24ef87eab8c6d8bf9e7b443703085e904a002403ef92792cc9fee0df1fa8e3db6f897f0e7674fd5e54f3c302e100d109889d6eab5cd26bd6c3421e0d1ce6eb42a59f8a15daa394efe1bab28d86b310e35be3538343c2eff464fb0c517ae747de83225b9b01eb016b19df41f5bdcf04107e936ce46b04d60ca985116789572cfaaa4ad67de7bedc28db0f5cae60be62053e4f92e1fcf9885d46e76458d6702f54776cb5860bb6f6057a880f69da4d816e8b672ab851964d9b2f303377fa3f45b333e4f12d1d0898908047fea195d1750743efe7b3d43d6a09cf3bfefbbcb0933f43653c0bc938dd91ef55ca1072fde5195a7841edc18a1ac2c6076c1d35ce9279ff2030bcc051dec69ce12ecf83c5e2f1d66120afe52c7c6935f6b52b557ba735e796c641373da5e3b66f146c600309cec6f3ab35f0486b666eb674b84a955b95f4e281ba399eb6fcaee82dcb58365d1baed2f03fe6d745ddc4cffcca316b198f5c0b09b8c9888df6d1d1e6e1887a328adb4b7a67e5075cc5da59a63cb1602112a66dac380d109e626d3fbeb7f982e660fdd5145320b8d701c77da5f67300b9742594c98e274044bb904bf49e29d13de342bf43b237b36543ba4a5aca3cf4444ebaff4f94316c3a92fa7bf8aeec33e3ba511983519c6805057a6c414d8df748ba16287418ec53751994026bceca96a076de99cfccb7328f88b1eeb84145793657b87694713b2b5c32524ac6ab3d4a67972d5575ba3df6d29c93677d94ed8f3f73a025672d7a7d80efe4e05b3ec474fd7e4b952ad93fa89b5de8ee23a7247de24a69ce544ee6b14f3e129ab3e2c591f3f297ccdc062d6757bfadaa41f87f1e724cc6c791812310c972349ba844f664f7979917e463282ca977a329991e5dadd9c002b0ced97a00cc5abebcda6be9c6926930e745376eec90b4134290c2c2b0f04bda289e548495f7dffe3c839c261d06d2ddcf4475274bba1515dd699662048760a416107c2aa5f3f6667d49c716893c785ced14fd8ccf4365fa8e80badb3433f2284c2d2a677fbcdbf893f8d6cbe7b670988ceebf50332208bbdeff341a8d7a3ee60830bd4cd3b5e2a599e1ec5af5c9b36e9a7437b6ef91b5903dfd8dc76f5d77edffac26e504609c5e256636ebd67ca7d5df4fe0ada77fb1bfe57d008657401dcfd723e69041a536175e4223197d8b8e35268f4666578f6eebfd93988859110ca00c8f18f7dd232c00be0549254fad2a41cf653e6210cf2c8d7d2d5be68c6c9ae18ee26b819ed3d3b77836c79a398ae6861f495465dc05031d3ea789a0ff1e9efe0e4a8882a205d230e972d681a3d255c592a93d85e402a3c252bc73c89cd653e9b397bac3bc0ee663cc15e841160ca093004a28e6b14f6bafe032f8f8fa68921d43da73598aa7f182a6fa3a4a37b42d8b1b144075a0486eab8c45fb48b9a5e0fe29d8afab1dca0ec46115d015f2ed21de716bfa2f5367ec088e1ad793ef7b4649a85757cd77b1b8d9b3cab8e41bfb2b3d463d280219540f19c8b6c52f3797f05386dc0ba8393cb57406534e75c09778ad86716a7ba8491779d8487d1794f3d50635deb08d68528185445ba0f8806875b88cd210f8350e6d55b64117dcc44fc3462db87ac7eca320a9fe21a3ae2769bd1b13adb0eb427dc3e2a32b035565ce2b846ed28193394996135074e8999ce0910d4914ab18bd832eab950c949e141b951b570da909e68192c59dfe58bfd5277d0f69a927618dcb23b15f7617597131ef5782359d1601df09b565d98b4ecb031b238ef35d1dd9ea6b406b907e7e0a7811863ffbe88c95b1a7f178abb97819b3702a8188cedbef48c5bb8c302eed419e6b13f83ec964c177ce8f1a36ab173ac3279d7b03e3de208b7ac60b957116ea75ea42fa961551baffb448a67e691a58e7e9f874533cdf46922c272870a622dfb563f702cc2c759ae28c790143bff3606499a0668f5d84bcb8289a984a02928336bc8040c5aa9ef9269560721582a7b7bb2ae7f07c3956c61747a6aaa8331accb658555a5edf6c85b857292ea6096574b078768fb10cf0d3babd09259615351a72e4ca574394dc1ee60b32c880942fccae2cd1c90d97199d1d32f809823ec6608dabf3c167a96d7e8fbfd4a0ddf6b720053d35a716aa328dbc06e99897331b26b73ebc5999436b8ea55675dbc797f824b77e6c1f2f73915a6fc76acc03bc0922c33bce05eb175b8ab30374e3f9286444541d1a487254c3d41c801e2d945b16839f0fd938769649fa856ba6cdcfadfe46709f5346d61af99c9fd5b14c7686ab216d83f4cfb430f5d922345fb2d3e439b1bfe37071af7fbca043b045aeaf2b009b68ffd0f79d7fe48898f38ab2aa9925a8bd84510815dccdcb2ff649674f2b03ffcfe3540692f98104a39d85c4de48398c06163f9175f14d0454feae6a04edeaec8171f0f88d9c9bcf89f047816361a4890c7d72462c1fda2601a2e034e2c3d4ccc88bcedc3f896a68e18a10fa292fa5b89c35fc3c65c7517df352201fc9a46e70882a21d2b703edd0e27386bd7d840362d646419493daca8e62df7f0369fcff7d8c070756453f428df6fcb7b479a4eea5264c7caf9ec930b480e201a01ad600e27d71d399323366505004ab00089db0864136a7f5e3a5e221b72122a623ff06f8fe4ff74300aeb6dfa97dc1d0df0ce8dc1439647498e0113e78355f1bb6d64714cf34cdcc5d509cbeaddc8cdece4957314949e4f0d58a1e330dc41dea2f0f3b45fafe8fa930752840a90af9abc37f32ac2b04c9aa899f9c758e3cf7991663599e123fc4cb1c3a56489640cad4e54980b41625e08bb83d15e1ae472d797a91919fe99fb30b837452255467767c9f02f089e061332d831a075af5fd6a70ba8e3ec00a84e5f11dbe14ee7cca1b9975880cb92596b4efb089f16fc80e22b961a576b62349311c0b3cb704ed11b4a2695962598770b491b9a73bb07e9182baaf15dc7ede3cbb176ba4ee992157126d034983e7b904e16c48a8032b7d93a64644e16fdbb47c6e6d035a0f644daac8ba55615620153fe0e34c80df622e4486e1054b8c8df697fec1c048192bcee0fa8a4b9042f307bb72f995584308544c62b66723ee8e7027c2757bbd0a6fc49307536d03f06cadd7b27c1ec56a3b64ac014490d2da856babade017cad19d643b579d699eb3ccbab19c2535deea7d02f5e0f53db7ac9ce04ef4e5c099a377118e6bf56210ad8957a9a534d5b62a21a877d6cab8291567ad6e36aa088f11bdc2bec7a6b116a13e97703193684bf7fe11f59090fc749015bf34b92e97a8bdd773948984db5962d10a2ff07f7fa4c38ffb62f55a6f23acc76b929dde4c68a450eea3c03e4aab4a0b9bcf3e74d51bcff062108322cf053fda047ce2aab2fc4e9bdcd98fb50345b14f48369ae868402b6192ef2d636b519a9098fd96495bd394a2bfb5ec1b1daf8d482795169ac788edb8d0fde6b86f5ee19735db6603a5533e116fcfc57ced44f94539fab7cba80737c26f196d70af24c71a2160b60d5ae001f53f2c45c7593cdc763cae2051969139caae809ef6874288017c96741543e3b4897ab765aa331a8cb5ea0a25507564df9703e86982db0e77ced91d0b8bec59870e95ef26e67c25b99aaeba6a31fbb2dbe8cfb3c24fef697551e9f333a7a392f568116894aa3b93dedeb203c87fb2e8766624937e789bb17885272f65c15c2a807b1385003605583c91b93fd9114a20057a34b064a9a72f949df3cc22525b236960dab315b685e5fb41a8214e9c54f0dd39658c5d0127ab4dda1979b418fcccf2bff5eaa2ee08cb60c4119a6bf07540362788091ddc79e6bb3df93d71cf56cfadeffe39bd9b75d4a649ad36573300ae473c499574ea5cec1225a602c9d3beceeaf1b3c4bf4e0b4b5eb164b479b54dc66a5466b6d5ba748252c3835a027407b8fc70918c1ebe5f77d2ae68008b158d52ecfed6fb51d03cbf3c5d7f7156d5f3119b8d715de402f004ac4b8c669c6fa536476d702aa8dc7f7c2b42d2dbb70d4e53edec43ed317f12543addb9199bf0bef145d2bca40e0aa6beb6cfb0d5258b24203666fecb167667d6c3981780f6cfd99aa86cbfd871e5585b044bec7327b2fabe6c9630277992bc0aaaa55a6cda89d2eebe8ecb5dd5ad1537822052194115d1d8f0bcaef09952aa72026f18be5504d980df6563eaf8d2e4c31bbc74038d3865d9a397ee0801bd5428cef5c504a138c59ba6b10d6d8fa86ae0aaa1c29de0426d494b10457b6306c0e06b9f77ba1387a3646f979f33b4273baee2db79f6349e8241bbc5e6622859cec7654394fe009c1d04249877caeef2d580505e5bec05796f88d3e2da8ca35f703b014d3c5bedc1d42cf69956b690900cd12ff4458c2773c550b488886a31bae5a6f24a1c61ab68fb99024fe65323532600cd23c9c309ce87f57baa3a787b9484850501a3d4f029da5dd7ebcbd6b32dcfe9a8f16d5b35273e72370b935391aba4a340842dd6e97e5493125a6d08697ccb1d40f2888a870a989346daaa65cea5dbd13ae46026cec572dd44c265a6d80cdfa2eb3c78b85ac1132fa8bee41a95a48fdced6480870dde56c36e407d7a41501fe237bdf72ca551dd62bdbcb7d4f08caabb2fbe748485bd2067ab1c83d55d8d83b9485a246529c7b9ee20a01accb6b5fd47b295f54270a197b21b1c5248bf339256a9f8e4c459f5046b3be69a7adf5a6bfe49ffe5458ed1cc225afc534aa0421f942a93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
