<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66345ccd8dc01972e0b4cebd345dea19afadc1eee02bfe63d23da84a59cc4382c510380ca443082eeb56407b0a55ea624fe49e5f85561641e97c399a754f655e4b1328251d98d1e835f9b5faf17f78ab4d2fd08af15e725c1e8b9c0c3c3fab9d180c7c25c96cd526d11119908c0284d8ae3ebc9622390fee20348df0d06d021d3fd78d7d19accad9c0ae52a1ca7cc53d8b594d8cd45a8eeead4421aaf9212058cd2355ecbeb442d1b5e6fcef30bc024d927b112167ae845470d3cbbcc16a33b6894be91ad20b8f202012519544b1534cf13188dc082ead5148ad6d77116a53cf982845e4d87fce91f8e16f6846077c21b89bd815c029d93a27b4a1463086033b3b1695421dd167bbee9bd2ec981de7640797a0ceedf923470dae5c21de08ad5e5f360e00c857a0244f0d603b463a495927426bdc21162de2648b1bf2d2b92381c2f8bdfd85f4b3a48a55b226c73d77a200530168a406a45d212edac3da55eaf4e46dde88bd430a35ad4779f0951766bd33a5e333af6867f70d5467df2d02d7b9d3b10a07b3b0c43b05b5aa9b949691b56e3a8ef50b367d4fe8b8629faa7f270ba5129632114265b7e46022a150a77991877868d911485d1a6c6ccab0c93661ff8501f3c443f1418182995830e15999768d4250b74f158c6b44a2d73a830370ffd66dd548d85eb6704769fb7d80c0c1f7f3af5c6ff0c22a243dcdd95a575a1b29334d60a342c1b6b45aa77f047f638f6cd40e2874e4d3b88bc8716847fd307d848c11f623e67fff24ae26d1f3a7b4a85a451a4e9c60fa9ea3d7f9fa46616b1f62dc294106421434b403490400270fc2811ad36ddc37729df5661d06ed30d898fa5cf47ea859ec0df5e675962dfcbe7da1a16c7b96faf817393edcf7415898ff2605c3b999a3137d0a8afb42291075386f3e7e88fe33aadbb95eaa47dc0bfb7f0fcac95721843dd8a0136f795ec48113d7de4337e2f4363d12ccaf74368088291c21eb19fda0825d7d62d795360ef86f88cc18fd56fe88e15a602c0410d3582bb47f68f2ac0586d6f5f141eb3cd6d1720c6268455d4a04e43aaddf75ff440b412d3c98007a181afd63f28982f8eb43f085beac458d85a4862042abd12371fee6cabdccb3d9285a97e7456ef3a35bd459e21a676a77a8b931cc545248949ea84e18b576c603fb5ec4cc2d9bfaae8cacd24109c41a28f4da9077374c97d2f1642a6125a398557dbb99ad88a7c357f874427f09e1f554fc66c65dfe6b9735c4d5a51f300cb8563ebcaed0bfb9454f4a3612143c838e32e785dc2e40d46033bb04589dc1f47827415b23e67b5ed32dd24a80047fb31660e1c04b3a15dab6cba0a39e6f64e88f0bbc88d384ce06962b80c97a066e1c4497e9d0f8a670f9901f74ceba3c086f6a3017bb0c4ec54678a90c8cd13de7493513e81015f0b5375d12f026ea298e9e6529a8eb653a805f791ec2b7705267bf0b7ef952c996728417a85c4a85fab795035fb9b8072c75698800fe5d4b5a7fd29638eb982ac01ac377c2f6383e383be4ddfb9c1a048a98a1c29e6c2be0e347267e29a346d45fe21b5048d7f6fc7accd7479980962525b750b8c31e719577d2df51f58652f94bedc5fbe1ae78fc15124e91c551f6d35b0580a84ef3f4243247e5df7e0c571bc9112e02ca9ff8f3458c5c43a20a4e2cb068eef51fe2ce48fd3d0c888adc4d547b0475012f4971cb4ec8ff8d5970eb7524c963ade8b97b0e6615181d4c48b4fb8d4c32f076dafad644737b4382704defe40e24e69a97ea2d1985537ac4a2216e9f044bae358405f3d31aa450d8558a16db8f053ac8fde558b59f1e479ace508556092bc072a3b4170d8b73b24e6d81dfbfe594443f917f552eb9f53b424dc0111f21ce81982b0f305791b6f28c4b037919bdc171684737d517f9a052de29018354731780392155727d78bcacf68a98fa451def78fb75ebb433b40b47aa2502ce584b70910d2e80ba73b14d2df6ff6d7ba4a390ce14c20c1f82b414fe6c95081f2145414bfc1c7b794da947731d48246318242381bb20184cb4b27c205eda4aa68465626c69d100c76421672c11f1deb73b84f347d4e87e256ed18cdb16b5dfd208ca0f809b4317630d1b500c0a2b99b925331c21f0fd6510272f456102fc392bde3973ba0eafd1bfa8d64abd219c553c21f4842bf4949f87033e4f08230759d49aad9bb6dc789b81c779cdf79b94e49061395574b3e0fe3a38e4b45ef574321b7ee6cb19973614d305b295f393864ba3145c6036b948cc5ae3118ad849f49b4e778d418a5ff54e4828f7e64872d55cfba03108c0bb02445c532e9d96f2b8bc6e0da27e46f328ca66b8ca99e067336659b86848046d97d22a4e8d20de167b1e2729bec4e8d803a3dc14f02cc52d444a8f242f2177c28163d8609e3a4ceec2f1fd212e7294819a4a875f4624d7d52ca1615a8e3ce4776e056bfe0a0d05d71900fc466e59aed052f8203986a0565f73e791f4e9e4be9b5b353afce493fcd6aca43aa2613d34ce5cf5b41828830cec1a0a13498e4b9cb484f30826130a9762bd8dfd4b31ae8eca29887dd582c7c25ba43ea73e5175cdd5e11dcb97162b97140c5c95b58aeb7456dd80747b5ee28015346445ca98a744d2a021c746edf55909d24c190abeca396685b483b1d228f40fe51a0025c0fce1ab62161b240e91eb50fcf0f50d81aab6039eda0c0c1e4a187b7262c60079d1a5eb8ea9166ff38c3a22302644e49e878072ecd4f3f9ceabad113f2079d5945e19ce4cba4acd7b40e4cf5701e6b0531a7feaa164d86c2c490c0b6e7bf83b8d1ef4d0a9a34a0e83715c434a6054b0d79c8b990f40370fe2cddabc759f1a9fd58d2eeba4f3876995d555b7f45d5ab0234edc96eee0a9ac6daea16a869679dc181c9b9f411f2e370f73c0fe13761b2e2db8e69e8f9fcff9deabe2497779d95a664398b4254299780ad06a0d4146fffedd4915c7c62b6f122e3577ca022755be4b78202bdcbc09050ebde4d54f0077921dbcf90688b3127c25748cb7461fed211c97265e246a5a566e0e70182507fdf10d90286006c2a529005b8826fd297475464a9ad53b42016e23bc0ae1267bb2f792a6f1c6edb8a2ef6073b3752e3925d6363da97daf02bbf152413f08b4c1a01283f5768ea23b5fe0fc043c7f97562cc831eb46550fac47a9627c0159ea1cbf4f018fc2b78a92afeeff39eececcddf2b0b19085d2804a20376fcc7c907b9fcc397ad815a6439b280a80963bd5c81b3f18e3b5d404aa6f0d9b3bec2dfcc025442876690bf3afc9408772f1352a8344310658d45fe63b4450ced2f63c4bfb1efcce82b5cda997abe4ad1c4213db097032cae53458551c0b70e02b4f4ac2e33307c2afcef8e7379b130da08b77c044dc6d49af2f0a15213ce8418967d113582ecbd4b1577d96b0db13f2152df29836466e4c6d47b57d1852d2a007bb45847817a3ace0f60e87b2e675dcc9be93baf2eaa569538e6253ae3ac257fac12300fbf0927391bbb312d06f8cfb4b2d4f602b45d209323de8e777ef8979f087c47f40e4b174a3ac95eaa7fc7ec1b44503cc0d93ed70feddafd467ae7c26bea8b03c8690da592c948a2aa318a317f0e8c52444f59903e82b85be2fc05d5aefa2515febeebf0e1a418f5b57403a6ca0f7764c546d28fab5f4b553dd05acacbe5665dd757f713a23ef38636eef6650b21d656ae9356b5610e757057fba6a59ee4eb19e4d9bcafd94aac6421f1a735b910a8a7f84302ccef5ea19561904d4810f4d9ab1410995bc86ed953e6a80cf305941cbde3fc37770d7a29bf087cc4aaa4f637093a31d7f1f0ac90c8b6d42497205117f5bd9cedb3f8236444e5610e623cbf03eec47b4407dd5470cad0197dcd9beaa9af162ef58529e8d921e64ee9c8843e636e96f4c6fecc062a8766de94adff3c7fa240f7dccd1580cf0417ebadf334a12160f7bebdf88cb41fcb7a7f699bbce92c5dee18bd2c2d7c9e4bb80e10768a72cafd36816a2c7c3d4059c207598e08195194bdcdbca6ca8ca60caff7f81598fb8b599f80cf6520a8cca501b090d393a55076ce42321ad456c8b65736f1d6b8d0e3dcdab91889b2e99549a6145302b057f0f754b6b9fffc19d1011309c655c04c4529729d5ee7668d6c48dc6bcc2bd4a8951a569d75b4492f792902cea0cb540eb697ec6daded600957f1304559609ae6a727535a095ee17773ab4a050a07e43a87446267a4fde142949cf3ff79e8f35daca6f31511dceb0adee068ad7e9863492f1134a5e47aed10688601c4c7446eac7443502294dde324bafd5171e2f028788cc3fe6b34ddfb1cf027ba90e5ad5ea3beaabb2e6dd45b72ba8b6a9b630845ea3a50e71311601391c450db0f8aaa869ba70289a42683d44a4855befbcdc4b577ad50dd4bb950639e6ab231a8b8663331d1aba8ace4669df6bf6fad489465f472331565fbced9b9728ebff3325cc3df79bd4ffebac9c9c65a0c75b8c8747b61664fd22eecc1f90bd9845e018ba9f73b4ba4138b1e0963b51b283e63bdc5ad472d935f341ee9dcb463c8079be9d16d92471c74701c7d549492b4d31f5d5671709a6c4e52bea3b856df329c1884946c717dc9ac30374c8231eb987f50d6379167452b827fe1a3b908212b8a103557a6acc339e194874426e79ee7b38a85538f32eabca80957594c10b8622cf997e638802b45fee25251d20c0a387438e83498f9f68800690cd5f567d4fce750cb7a894dbc4c49caef6980c2a9fbb1bbd6ed7c19e781b3cfff5fd52598502f9de84b4b4a845e48337684d62e7a9d6a79d505cae027f31f0f1e4838f15429fa198222d2aff1eca00df7e0862210679afd60bc27d296e61df95e7624916421c2916b6f6731504d8833784556ed0f660cf2bdb2a21ee15dd97796e8db6b6a0719b0fca5b29fdd9eb39fa0ca5e2e26cf0865474bbc96d3acadabe25a2cdb0d8ae0e35605978be06b34454806647d06596513d4904382ca9181286fb19cc8b7de79d93e89763ab6cd178aa1bc5727ef90e954c9cedb00ba175fe92da62fb1294688da49d3c5ef6401c44104476c483797f125c28c7d8146c64d47d47c3ab2317b022d55e3e75829933589edcb599e343b3b12200525183e862dd5b3c88bd0ee811496603ac31521e29d88391b0e6d34415228ef6a35991101ecf5667a6e54408bb3d2e402cb60c710e3b4a84c54829288607d0faf311271d2ce7dfdbf3b3acdd8a3e23478ddd1a68ab61a15895d90b9fee4f842910b3a1afab2ea4111af64fe65e57a0aa3b4ddd0d6f538028abba0c7ad2c6cc319a867bef64a2ad0a0f749804374e8498f92e7d20f321fa7b911ab0a0d3cd9bf072b2f8dcc83c6eba98bd004c70f9d6695711153b0580018b33dd90c2491a0329243974a04101663399ee977b172b6af8e6024122b3c58280e48181a498337f5891cac28dde1963d839b83750cd4516f54f4088cb29801d621f5960eb769269fc617899697aecdc15393f8d4b65bcfcd4f8ac011065a886756f6554402fe5acea06404b74778b83a60368aeaa282949fbc15ed9d2bb2714f7e971f1f142d0aa17bcae60351677ad7faec9bec2ba540e70111416a99572aa4e8a09eb3faf5861c2012eaa2dad10a1bd58e857b8270da1fbd8cacbb60a99e9bc7a336562f560f3529c5867580acc92acae7d78714da9684e0cfd07a5bac93ac145e5f7433636fdff3d44c36c0fb8185992d82f1723f792bc7a0191b3861a272bd5273fb86bd6e089a7c238c2879e6699a0f97c8c2be89df8e917967bd3b68e832ae8d4643405bb4fc0e1f867c007aa89631dfec757138acd8b98d5f9975582f1d162a7f0727d353808d4f675a5ff3eacce7951a94f413d9bcf21a80662d211dd5db86320b1ea7ca99e71f43c0ba93da26bf894ddb38d6fdafb4bae54f127e09067f1dcb8509c39903784a6595895181eb67a06d22d8f2450d2720657ad31a7106e83587877d9836b6396b2dd8d3dd6debbcd391bf2e2fc9e5ff76b5b3a2e77411feb8db7c7034f1ae6e80b17ff0509f798b10551ba833066109b0d9f763b5ed428ff7ab9f38f108ae57c3af510e1bb9901c7fd6fbe87f95e10b3b1c33d48d44317539b0ce4613ec9fa32f89661adbfea3187d8009a484b3930c1294435ecdd53c91d457ed54998cb7402cebb037319579b2404b48992b6615c45eaa16dd5e877833bb45d6fcbea9ab9dcbbb0f6f8f2b4bc31e4b46be3f4e230fd6ef2efea549dd7d29374bc79729533403466279b3b0497fa865496bb4f5072f369c711cb72d4233dab2cba3ecf3ef9a19515b160e2036dd934a7dde879984ae1960e4744c671fae4d01b4bf5ac152d01e79cef013b0ff8ecebe174bb108669bc95c47071826f95cd10454faf5f20bb7cd66a972acb165410d6ae08093188c9165a84c9819226ac1eb28d935597a23b30db0c03c591cec87f6ed63d3ce66b777fd01c00dd5ef60ffdef7c472574a8cb08ba597a93504a8788b8c67b66ac249b289e53254fc0ec0f4719721744b099c7d3ba87e7c45a8d0e569a36c4a5a959968efa4394f9b4338d364f014eb292b14f994814d69ff7e34fef350937ba39c2e0b1a688fc2c3755715d9518f874f4386eb9bc6b15c91228ced356b3a8db705878db7dd9721c9324249c2d1b57aac5e75f5074c09275b52f61ca20a676954038249dc1e76f06fec505010688ac66c10d1462c7933c255773f38180591cf40f05343b97438cf347885875dcbdc441b186baba140dc1f221ab48625580347b1f652d50320706fec3c2f65940c0a6028d2b1363432b3d817b62264e350f4b4693047126a95f1113aa7665c78b28f5fc46d772a4ea7636383000c5e18ac04f0cf5fd3cbf10283accaee9b07c4273f06ef5c02de9d411435fa336b9826301ad692132b6dcc8b066702edfa64d0a33b3c78a0f60036a332f574f9dd6615fd6b3828c8dfbfd5751a4798943dc02f7e92f0f8a9c25d01d3e4da3f9f0100d8aa08b0372d8594372369365213ff1d668f4728ad2edced6e8d9e63e8f4715205416b351cb05f940f83cf27832c52ce316e33ba540f08a8b25722b4d4092c24e667ffd4239dc349a609ee5237e4d49306a8cef4690ab97141fbb49e2ad2f2951c5c2afa7edfd6f270c10877e833e1bf3c6d4c47c029c366c5158c71929003f5155455c59815e47572fd8defa219c7644e7b75e5b4594729fb6cb0e566bfba1c8226dcbc7c265f56454f4926e6b59fd2c46de8485b9e33d4eabbb206a0b2b8dfdfc6942d2c3de6392c1a367279f10689b9c705be4004e87f3607e4ca8431e88f19e21f4f128e9d77dba964b9ed4f1ad94ef1396b1259771895bd3ad6f9a2aa22b74b538671ea5c7eb946848b32071697c240132b268cc1c8e742a963fc68ec10c8f368df3fa982d0660619859824e2710ac4dda0219cd1b6a60efb98e4491b5adb4adbad059b151dbd0b11b0ef367006219d9cee4d8697fe9d6d63b31a707be287a57448eeab6cea573b307920eea29fbdf08960558afba435f30c85bf1c13d6adf238049b022cdcb5101c985eeecabaf84b73d358c68f506d444c5a8dbc1174ebda2c085399be10e5c0f64647c293c6e00ea5cc40e1423b4162e603fc8a1c285a13219f602c9f547595b959607e837d923a28d5f51c5c1ed79c5328842ad219de72125be9c314c8998378745dd142b543e7a3457b042a12de495b81d69a88ba8cb878e0c86a5102e494fba07ae644d67dc59dd535d66242b42befdc3ef3f94e9955b02451554b575075bb93af98c739ab568aee069ae5d42da1ab2f1f2171dc18931e53211efa171fe3c8d28fe92bb9ba5b8bd2ebba4fe9ef454152a781ef8721b4f03925fdf46ae1181af4307cb7810d619e535e47c697353629eb8e7fb2affb0ea08515fef639aa9e60a14360e9ffa5d9992d5b6824ff5b83f8bcba4178c485cdb30b119cfe4f763209c1e5d2f36b10c12d30fe11aae80fc2384ab896081add7ce72a41ae16596bbfe409175c1a9ea121d0538babc2297e65882aa1d04e50ccd385ab6cf872029a20937446e3bb4be109c3b69a051ce6ca3554d636379a379aea74f7b922792a0336fa3f94ae6e99ad652bc6126bfb9c703643ba91e14403b3b0c8148470236461e939e7ef9d6c325afbb6d5ecdbdeccb3b693acb06b810e1a63cd2b0fec17586734cb94dd87c16d94a164f7e52ba1c806a7774269de12082ba989b8669ec7443a81a7dd6fac3db7b146db65dd5e77e83a7990d7508ceec9452474c93d35f5c893090e9b4896d2a6a012a6024cf0032dcddd4553907bc696eb9f4ff863c50b5a2eabdd447c640cb82c2a07f58e87a18c59b8d5043ced073d780be360840c66f9fced25b375fff9adf933d6856dcb151d4b6ece9118699362fde5a3bae09f90abdc314f46be82c333713c2b907a5f8cf6a726b6306251b619741619ded612629ef0e10ca489f727c02eccfc95d6a4cc5a825e0afc640c5ccb1b99f3f8fa51e09bbe55f36d5d18ba19179750d6cc0812a33cc4ae0a011601ff864e9a93a7147aafeeb50234566efdcfb47ab4f02d3a9cf7b8b0e5ab689ba6117c802cc4e49ae68a49dedf1db72d6f9b34e88c2d7ae777471c5759ee98be3f884bf5653ecf7505c3503a54d453649bd32968d43384995405c06f6b71bbc9d538b9e6759580f0e6ad4e3b927cd283e1192b3ff901672290904c833ca13554e7999a9e9a35c0a412d17e7ff42bb1570aaaffed48f2bb048919d4136e6b7266ad326ac073a7c605f8ec67c52f8344f4329ab5dff2cfda5bf1a3df6e318cef5fcb9ffef80ead269462035cf6846cb8e7e2a29e71389d998d43a02366eede6e76ed2f6f73cc5b1357baac85def665e07ef3d4fcbcb3a5b9f7495c664744f43be21937cb1ef262daa47bfc2d1cb15c064838146be5e5d730ff192032b132b088bec5173e7d308367da08ff48d0bf9d9b7c478d22a0f558a6572c6f4618ae45033c511718a58f830e7b774f20d7de4667992ad85a1f1ed75aba50062cd07535155609fb5796a971ff75d5d64fc0880832e07c4fbfd55f1b26966f5b7bb2bb03d16dc2c93e5a8065cf57cf6450162867c3df68df17b371a5451350f6d2a0f7dffe1c5c0b17f690575456e464cef7c043114b30640e3c0fea094b59506e8bfc490b3936401adb0c080d47f4fecedcae78e45c09c65a487a99163aef807302f9f0e5f5d74a00025595fd68089fd4b5ce80150814e220bb602a2e4408f5bc1dfa6759df2824d6fbb10b857e4b5eaeec67da5000a3bc445918f06df52fb50bf2190b304fa171be372f6beb666df51bcecdbe9e67b8630f36db73a1a95626095e520d90b001b5e5428ef4ca57bf8a9845a1c0c0a8c6bea0492b62ac6b79c2e3c4ac62ecb0ae40c178e74140b9dd36ef01928cabb41743b6877793e5c1052372c1e96c3be92f9e046638347ab3370288c41068c1f968258dc7b9cca8502373eb0049e23243fa497ee2b93a330a1363f4a7efa8c1a22bd8f7c51a69409ea9a3b0099561630dbd22fe83e2f7ddf47b63673db0cf48417b8c6e508f4467430fdc0cf964ec7f96d69a62b4436a614e847fef42416cc99e300b25af04d802647678491594cb802703045d67e5ef4d495de413594e36bc9fd07215e09428cbee83dbd0cf6f72ce77e2f28e2ed267e3ab1bac02e6675003d615640596fa2bf63c239e752f5c8b5ff0f71ae553eb84cda6e6a85fe104671a5f6f75e4d8e5928bee2634eb01a4ea3c1daa4949d20c105f3087c3eeda79859239d1d23b9cc32291f3e1ab36d9d445646804dce75febbe31a95789561cc66fbd0463e50230f8fc599ca3047f44639ed647e5fcae9bded90c19fefd5fe8a023cbcad5e17df17a6cb358ac4ec2d7119e7f721dd6abdd0c688d80f2bdec2f7f853cba99a551ff2977ad7581ae21f05b75fc75f0f1321d04bfb50622eb0e041afb75b0f0ce6377276762a94e31da14554f3b3774aa84f6320705aedc45dc8ce6ed379495affbeb23bfafd780936151e35a539fb7a3b2bc9c0773650f803955a3fdb11feb5194614a9f26c8c3bc6f27c059fe41c0b7d8066583203be9d3fddd8d7bfbaa9c1826e984b5fd07515c78fcfc3e2f4f0df34877b6988caafe2b985ebf245120fbfb75a711a5b5a19c238b0786d9e7b086e00b0e81b888dc4daaf6e3acd41d87943a0229adb887d67bd6207ef88b4492069716fab61c1ce63792896373615263f6f5c486c57c495bcaa3062d0e7c09d5451772b4389817aed1bb29a9761f1d811e9b2ce0c6b2d845bf85a428e7f63523a33787bfdab02ca17ae770ebd22f2cdfac3b50d451bdf8fb80711486d2b1867c3644ca806020611176fd14d725dd09d871a2fa94435b8d70dcfb776f46f2a92054e75729777d48acb0b442246d27d3080c5ff168746f72dbbffa6f17bd0a6ce1d4ac0853fbf111540d085626fa1397d6b329522fe0fde450d09312fbacaf388dab3aa2319b56fe6d8d0f50b08359e2405a1408566a50bbbd7be138acbc2cd8d8370766cd9dea8ec02b2441426255bffd178ec30e9a6f67c461e730b0e9b0a9e992b4978985a62f3622be3717a9258381f4977b56f50db630039c23d845d71bb98c4210c8d586f60bed1719d19608d40ac3bf0a6f2ddbc1182bb96c75bfcde9f1fdfb9ea954557b0170dfb4ffddfbdcd542b694a443c693c01a7f7a7beb9582a9b2ac84bed93eefedb99216c47584f232118e5b7b733cf52cacc479fbaea8b5cf16e54f46718f6d969660af1f0cdd200e03ce6e4eb6ccfefd40a01dfbc3eba2e225e1ea86523d79602b4d9b7fac10d109a411f4833529dd60526f6b9cb2f985f06aab76c33ae244bee5f470310f83010b05ee94c13713d1f8b752b3b35cd2e13dfc5d7980c62a70d86caab7ff4b899c06f76acb44758cc879b56b7c67bd958acb34af633ef7319d1c04aef1ed5102280e9358399cf2f473cb57ca1882c5770f1ef811786971185dfb9477360f9f324c058c527368febb59ba2c15951c4a75ac63105df018ef815860d7c567ff70fc4810879a10e6d798445f9b1da2a08a857c1be44d005e37eb8aa870cd90b18a867c4c7bf4d9bf2097fcfcc68a5f34ea18d4e50d7b1618e143e3e1bbe3e8a737e0f5647904079b2977051a7261a0d8eee0f0a0b8393ebcdb0b9625d2b83b477fbb1f780c2f1660be85722fd136687614ca97ab2cfeb7606a80ed63729dbf2fda90d8c6900ed26866bcc0f96ace123d35330004c02cc6d8f825e23f9e078c8575637c3eceadac1f6a2ab2fd875b45542152732149cdd8ddedb5dfcf848541da9322239f9dc08b78dec14af9c08904ae6b4cd55625c8e3813a5911c44d639181493306f4160c76f7752265ca2f12d9c026539dfa6fc416f61199d522e5934eec30bc93506b440c4eb729b8e269e6ea44ab7e63a4e48a4958fa11179eeac487f4ca9fd166b0add3232c9fc6843083f9a84564d71d78ebc1eea2364c09e3bbb37e8977b3745ec2ae49ec90efe93f41e939f1b36bfcb0f42a779ab6aa919f1ff382d56a708fd96c736a3f82c2081f5685340a86ac645c770f4f9ea7dd7bc0b0d8def1b5a9965d1b9ce4fb2571620216cdfdb5304574d1fec7fb6b2b7ca35637e36373439f8edacd8341dda34c8d3dbcb7b53532b371b078ef6982684bb72a43c228385f52afec86e0757abcb5d5fd28f63e4963f98472e487596546a8773065f3b64dc824c9ceaeb10fc38c91b7e8085da1e8f4e19c8ebd23c3343283a7f13a117b051e6238fc755de0b420b5f1ddd884bbee0bda63332083fda62fc66c3db7130fe6fa91e0538203f62b55249f1fd916e87fc0b13cbcabdaf7449c135972f90a7b8c3fabc4cfd3b4051100fb7840e1fc6dc017fcfca11046b82fef76086a345bb51e4ff93e9099015ea99cbc774710cdc3d92de6b676aaae8762f51d23cd0900f503e69589d6f50692f840d0c9aa5ea5e6c25b4aed5e86cbddcf868bc9878f91e0f78806807af47bbc26b8aa48365dfcef386e2779593df3dd25aa919f24729960e87073a38d06c4d707a6cdd414da79cb41d3bfaf8e80b2a317efa91887c3622191a6ee822220d386b1680275a275d246bfd976c45ac2ae77077108917bc983a2395fb655b766e6aa9add99f1a6ff375d0bb3e689f7aae918c89e2fa99eac9402a0b191912d3afa4c2ade107a8f03678ee8d3828ec190ed75014fe48f64ab5de7d07e9ac46503e5597efc27c07e3201cbd898d2592cb6e5313e2883cffe9b46c946a88f71c8d8f5517debf2773a0dcb1ff9dddc4d51dcee1f541276b9f0330be5efcfbca07ce58498e1a44d067f22c8833146293d45cc915b1d92ea443489bb4619f7a69c12282708e530ee2c8177e7c8c377c492b7791f906808b83e1fe193d6261a78b22ab809d3ed77a3dd5ccc10f6e0959d1aea7a19e87c4c16eb507cd4d425f47da9022e382a150b9a5f64101b9cd93f247b617248d1e722f8f9d91c8ad9f1d09065b5747b7768de7afc6074263a9369acf939294130c947f3971feb6810657e0885f9742d4595f6efd64b7e478942b8e26f908fd4fb580f85b634f3c2245471912e2ee9f4dc207d090f379df1d98574958745141a77927c2bd6f90b3912d6dfce841ee2d040bb69a119bd994ccf3488610218e3429bce388b213747e1085d53df488dd32ba91cb0241577a46893b23202090fef16a9c8f013f867eb4ec20022a1e3871ec58e274df76a4961018785a63bd4fbe5b5f8fa0b82fb4d1fc8c73b39faaff929e940617023d5ad366e66840e2d350a759291e76041f73adbbc702438790d77afeaee3fd97d7b624145d42c79c85859f314a3a250333b4b76a003716286e030f48b813dfca20a6e2f8a4666c30683dc72a4b29bc39d719af3a19091e8ad6d7c07b649a5117f17520efd85add00415178117816d7d00bd49085409427c68f654c00b2f5b439a2474624a159307ab9061bfc3e24abbb6f5c8668475fd058a91b7dafb17db84b01ba65ba5ea1ed697e92c231d03994b76c55a5a0395bd89ef158e248498ace62661f06e826efae30c7c4318748dbd3439c56c1a09da1221cbc2e1f7592d6e859b6d7bcef83b5630d851dd35b5b695dea210230f52c5a2d32dd163dde09523989ece8766d99523b7448698f54681e2ac3a7ce2c8331ddd0e05d189bac15783faac25c85833f3dcfcbdb3016d822a5aace6c143ace82881fe721f4d65a15a3e12869b2cc70b2b0e3d5dd6cfeb92005b90081c4b1db2873a08f6f659ac0881923d67e74d791b7596306f3aaa4670cb162a6a219e6d23686b3df7f4488b8dd21bbde6c36c00768d867b60ce1b07360200f854a5be678df100b83f44407db08ff293124cc653dcba6f9f49a839c8bd7678ed6ef2bd30835e21190f876e0cf68903e1789602d56caeb53e59f575a70e9e2541061009d32f7843bebd1d102af35fce455566b1fde5038abb3000ea3a047ba3b188ce6554772fa494c1933185c3370eeef748b87b3c3f60928fc659066c8e6fa797d1d1ed77d229ebf6acde81d625b09be53333687844648e015b6a0222c22d9ab1f2381da395f72007dd2854bd2a4bb291234c5258da0afe6b9b9bef9c1c5cfbdf1c0d2d86b13e033d91fd30a90872af2ba41b1fb20b0951e1bd3cf94ffcd67e4f1b637e5171dc0f60dc18228da2471adcabfbe24f6905ff2887ffb1f846439e4ad04ee61c8b111f89fdfcba488af38a078a62c1b3d8206a07187c1e1d1f2dbfe0fe981db3eb721b42af2ecd809ec82652235a395515bd2f2c03bb7981411b86efc5b9c1ae5f3b1bb4916d40f8e4e50d1391ecd7a19c752d73826b7e60733ed89eb8a8e3b9119403d938e2f8b1fc1c83996b79d130e3f36aeb98b1d508778c7f7b66d32842be868340d19b7cb9f9afd18ef0eaa60a403e2898cfa75c1048822531de45c39fe3977b6a9319d5a822cf418f191887ae8ab81fcd3be473a5cdfd1f330a3a58fafaf58f7c2a8cbd629244da62e9a92008dba22e874fab6a7fac0fe5de511d1b1b1f11ef8b1c8d1a78be8b72610d77f91e8d87351bc93dfe92fd9e1d626cdc20d32c729da9d81a929374e602f972be767ff895573132128dad823ff63c013fb03890a4261ac06c7716a9dfd003d747f532fdf65c38c12a607580430aa81da888b213b432724f4c3974e32e47ad9a56aee70be5224a47b8eaed5d9aa443d0e203da3b750bac605d56834ab922bf82366d3e2d6668bc5868058c9cac115cba21dc4f7083c7b92493eb6ef315c6a8e09f833e37448e7ea6a5fa43af4a00fe0221d13a232768d7c68b9921697999a542feaaa0fba2834afa58a17c760c4c94b433e28b627e43a349cc15441b72da2eb3f2f8d62e8f4577a027c1c05aafef0a395768be28e20ada511cd39ce6e02cc08d7b6899bf96521e38abcdafc2ccfed97117d6a52802b7bf2064595dcc04aae36113b567fd95d0b59fb0a52bb4c7829b849f93d52a973bb817f3c9334ef49d4cf641b36a45cb26cf6769b4ccb7f5261cafdabd009052fe3560c9c7dd905e9f6f568aa827fca135fbbe8b7ab39d8715ac0d4ff892169d53d5490d7506e05ef500147465df9810fc911cfdc08aa66995f616483c2b60d7f5a86574a396e58686c27ca2dd4168dd4a2597e375685eb3363eebcb0613c274749fcecd3503a6bfd37de56d8cd26e976ebe08463e459de54a1e2c5e86ededaf5de42facc87011733adae1764433012c0ff6589efc66b46502a1d77140264b49174c33867162bc4bab4ccecd0fe39fe317e9b851a9d19b5cf368ff128cd8ddf0ccff5d0a4cdc120269d8c6c99b159837dadd7a0989f90368120289b90200496b2f15f11186d29a55753cbc2eba5b4f7a8743c976cabb0d142750620515a47952c6b374750304d27474c79d0ecc6901d566d3d473926a07ef3b1dd80c249acceba863595c2c77251171e0cc020dc840c3333b33867f4cb5e09262b463ea3230ea2cf08d7e1bc23c9ba2499b65f1e19e703e993086c5322f96449112aacd7231e64808e46366c71208bc0adb27ad61c001987fd100bb0bc40bfcf1e85ac635489e9ca63c8c454bfc7242353b23951846cb0bef8aa53acb81c78848fb41e73d650f69db2d87d12beb6cff5698e9a66934619a413b8409e36bfa64e05089bae2a280059552565d7bbf58d231dc55c18f06fe5f1239724248dbf56adb7e7e9f10af4aac2c423fdb206046ec78024acc73ee16fe8d3412f937f8986cab6a3604d663ba8017aa51852cf2cd360b33dd579ecd9b87dc90284cd645f215164d4fc9efabc71d379f55f2d51926668ddf6341eb4bd44abf083b6d0bc3ccdd3dcfd1209f69b8a0842f4da75c28810063f909c0a5cd426477388befa6845e52663044f9db71480ffa09c3a44a863331b8ce03a62b1b38a33707cd9a5b824ee1fc8ae2009467b151c4615271845ca61464e8ffd28d4063b64c9886f66782f886ca7e3ebfcafe796df953ee36b117e7fd553de90436326e3d3fd62d6ba725fbafb4888009f43f7ea9894313e29dcf98bdb3d55b1baa9534e1add4e3da9431ce565830ce13d5f1f0c68e9fdd302eb1e1d8bcefb43d0decaa9f28f73b29c13f3a4016095009187f94540ea697ab1853461bbbf1fc9f9cf408fbbcc2657b7cb2a90b40dfa4168b61ef31e52ce5f0b234afeaf77aeb676803f728c7ac368545f5c837aaa88041495814a8440e8d2b52a6f38c910951f49db38fb02301ff906785620b381775de5fc0932d38f6ae53ff837807a9cb5bf89d606c1b728b91fce6e81c3ab5a2d566bfaeb708a57922d4ded24682ed3770cdef9a27bfb5b0b08ffea48f40f164a39f5ee0ccc2692dcbf83ba2d2c247141d9bc0513e56c44eb905552b3df6c4e93761f92261849fc9fb7ea9e6f80e44220c13b6ad2c13ab9df6457d1c2acab5a15922ff2fc2495db63ab8e812e439bce32d015686b7749cda85c01af9e1bc31c6f34bca15e0c99b628883f2d7ba4bb30790364646702613b4348fe277ba415427e8453cca99a957e0bd545b1e3aa90a67bf5c1f1237eead0781f090e842c574ced16598a34b1b20cc9b61c336b8b200fd47ad3663e1005d54c18b591b35a1061531b127a047a3cb09ddb5b92f4a51cfe56dae907ae50a3a741641447039f51c83354064ef15b2897b15fd417127fb206f8e67711ebc35514c4598b68d03b87d66d6e9bab36c9f017995866817731cff13a241065d01d60567d1683dcac7720f257118ebf1567e3eb2beec702d025042579260869d61c7c86ecfc28081e50fdb7bcd32ce73bafe77a50df4ea30d478f99e57c62c8ac128b23432606cf636ab3e9b37ef877d2fb64ae56f5e6121a60f9479ffee2800d04e6fef3cb2a85d1e489d89a2ae3059ac5bbc500bec02fe602d50722ad6847030fd66f20a81024cb00016d9ae9fa66f2084c27853c478f07e9ca21d4917593d4ad19a58f1725b6c5b529cb7360757498f89c4011f74d239c906eb30875c7e5f6f98ffc118d7f78ae80205fdb35a5a3e610b4143c33b59cc8f5f69b6cbe79dfd967d4e2d87da22f004b6df2a3a816b515aa9a6ebb40de7b6122f4e690d5a5a7db6fbc544c451fda787cb36783f70abbd67690688b5b5ab922d258d84b95188c086fa19508abb7cb90e0918b2c03fd14cb3c7e211d9e9242467ba52f047988258e63826e3abb43a96c8b95331b0505a2636dcf56bdc317f7c0207e33d166e2d9cf270d3b393a9d8e8bff2349d7d45f260ac1834b6905cf88ce2a75d9964853f3d9b687613bdc7c3e46d73c59fa039a3c2408eea3fa2932dde030a550e68a3808277e45cefbabe16c90949dba820b5dc18ab784a4e82d601422aa17a65a92bb1cfa0f314fbb44fc7c8bb41b82a90f2b8fd8fa24f20369683b5e49139672b0725a4f068cf6959ab005c7d205fb0a948f0e6403bef4c29122459bebe9eea26e8eedc9558b076312cad8acb0a9883aea7de7b98a89213aae6319f538efaaf51c39bcccaa2231ccd738f13f2fc1ce2773bcd17b0a4ad33ac79efeb9ea5b4cfc30dcfe6d875a01ba365b1329ca3a0489598985eb6f8817e111111e3bec952db281ab4a11202ad3bbfb2383515b1232d025ef5ffbb31065d36dffc5db3c7780bce8f70a004b62f96caa0d65fda8dbc9a086a280eb41ecf6fec36e00023afb807abd0f3de163115d236436b666b5faaa250eee36c29325ceb88486efa02cd17c4108c94c1ddd31646a48b82993447e7ded1c2ed1b813b801a2b8441c8d7b5d710f15fa3df7bdef6ab001c0458d8bbb07ebb14acab9aff2628daaa104dfae4345522cbe34cb992737497c0591606a09ac183114c1517e11b65407a00d71b7a585c49a42516db9ad7a5d87a85eb8826e49c69fa96c9e31c4a39943c9f98733706e5b0fb969102412ab241382d9f8ac872adc4e9e049718f5218a50723ba99da323d1284fd7efdb530f74cf879fd546165ca911e1d00b383e9733427309bc18a87f454aa50169826ac3fcd668f21f04ee99fa995a9876a7c307cd901f42c3835961df76ea08419ec344967ad3beaa539f1adcca5bcca99e1a455bcf6e3d8a5cf9a13dd763bb153b727191c3345ed378659ebeae3977b247b11b475f4b24ce74286111b77c44d92fb2c1cb86653cb17fa4c60ef5943e4e55506a731dd6b2c6d22187a9571ce404b67bd3271e6d82e2537daed0859c62cb24983d0f1574fe139b1dfae127e95e114a7d112e8d92872635cf4f1e0a9c4164123b3f62edb98b1f0b50424b180f5a7563e875fa32058b52704672a186429e4d90bd8f3bf3cdfd8a2d7f9b3e81d7ed6a653824b87dd6ab38fffc37553230802e1e0e682b36b6ce409c2d1906a56bb8d6d640279e1bb2d7da1072fd6f50acabf66f832846dee6089db8e8a7020873daf5851c0b6415091977405b5e83352519912d2501c3cac2ca9e23376fcd9f09079b20d8e13aff18b536f0028181533d6a30078ad952957b5e266c803dec1777473d5abbea17e8cb4db9d39eb9a5fa5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
