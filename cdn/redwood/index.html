<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1caa4e6be18a5b761614ae06cdc4ff8952e518bc22616df10a591e4e5c81f97d11443965d9c92351d1522ab67d21f7b831aeb0f56403a4d6ffaee394fea525a3c07c499b4bba0df2ac373e21956beb042832de32e2360eff27a8309cdd187549e629154cafb7f78b3fb0ce249f13229a9e850ea1e4d32a9a56bd6037cf8a31f73305a54c38871ad38e7ffa01359bf8ce71f692bbdfaf408a27c46d449292967e112d4ea79d94b7ca75895d71e7ad0fa997d66263c255b4eaaa34e7b7fc4f06ec8e013ef5d50f87b06d38626644f62cb93d6cb45a4843c7604538810101ac2c072261cd54796b62b0fab9baf21f948fc86e5551e4d29d823c9c0c73eec49666d15fff026b5a4bfb59afb55b82d97a8c3bb36a29879146d1278026033a7f4bb13cab220a16dd048da362a1118b68695d6525e77fb38b7d638bc3b308cbdd99ab4741a308abb9709f21360e2cb3ca98a141364d09975cbf09307d298196adabffa4964d56a85760e641a26c50067a8e50a62419a989572693bb929776a489668771216583cd98dbf24326fab68c196ac9dfab990fa51152737e12ee8ba7bd17248be9b510fb3070e0101ed28e81dd1819e160bcd0c9defcf3d46123ed95c4780506acc906b1b69fd3ea2e66ea9f618fcdcd8ef284404c9f579299104a079c9f7df09f0ad08033cb5489e4b19319474f728d9e9a55e096a9786cc40db3ee71aa648249bad4da29c0c5c701d849bae9b44a50d5b9f0ca9ec2c3ede362580932a7950b7135ab910457d5a3b6374c9744ac8de3755b51f007a2a565c2640117b288c3e9664941ae8aae935bdd2948aaea0987e07bfa0c4f3cc73c6d1cadb10ec3a3925ea453f798335959aa1ac00bc676a58d81f205d293ff86e4276694b26dfc39d31464319a317194f0b3af4c1e871e2824a2874435f85a8a143145201b3033ae6904a1ba1a134bc78400540624b55712e507a416f09dcd3a4a0c4a60b126ae6008594b12ae8428262257b5915e8dac29279ee0a11f001c90d1709135ed7f9f4f9b2ec2d60a380784ad254c658de0e9856113dea0568c7b241643b288b059da572d1a20056c1a795d7d76e8a742d426e22a18678d1028c645bd5c4b8f63c741898b049e21f6fcc9da93a44b5b1085ef7c3aff3241622d7c43e58b81521395219a5a3f9778909b41e385a4c12146da793f7ac62d4736d69e2b00e1118ce55a391cae3fe2fd4314c2615d19081ddc9bef374220d7b36ed9e20ea26912e6cafd77a691123405126b13b69d085ed1b259496b43eae7d4d3e9cb8bc7d5eb55f4443cf86d3e5341c01ea4342987e747e1f22062393d65a4f466d9d3b8e20f4dd0fbedfd6807dea549e4de902b7bc1a601397a6b53bc0348d79d0983458efab5e1f5e500b08f6f3687c35f77ff01606b4b871c0aa59d96b727a8de4676039958ceb04a8edf2e268507970604bad641b9d9a6467755df65c568845321235e8e962dbc68c8603551daef27fcba67477d4a4bc604066df96fddcf55c2463a660558b4e45012fb499d89e4637ad8ecb0962c8300c10c81acc39f0634ef9b03e7e1ab574c8a4bf76880a4366375b9b6cf667f6973a42fd781daa2381abae3477f907159acf5642a084dcbe3d44cc620d7858bb98294346b99e2795c93cf1460f71836937268677ab2afef810d2be6c5d2bae82e6e08be406036a845da92ea7a7b79a8da41e291080a0d969025e6d05ad3e95da5384919d0549a2e41627d0510dbdc4340b9a59b78f1a86544b3311ac2191fd26e940a1b12a9b0090d87ccf26fd1a2e83d84df3aa1c022f2447370c6640e43c0f57384d8d90961802d3c8ad95b33e05d7bd10de4ebb30c616a15b603833257998f20a9f602ab7909ac7d4f70c84a9f932850ac913d402343bd9be08d95ed4256a1ef903b91e6f0d025ff6c9560fd92abeb39beed0680ee540f416971adb6f7e8eb05f9881ccc878cfe920aa6a7243288e81b93bc2f9e41331910222decfe9d871a494cac103f39891baa1b583dd32eeb3d819ddd10f9f4c9fe592a14f9cf4b36ec00e8d06128228f0fe10dc69e244e051f377ac2c865f885e20b9ee16acad50032644de0970ed87929c004244ba2c56d64c3c674a7a8f1193981b93d48459c278471b629e07c4977c4a4eca99cfce00c5ce1a5d79b943b865b60317d672bf69cb308fa7560e1c54ed0c429c51d3bde24cffeffa3d10b193df15920b3f9fb32561735dcc974c0a3b6a544ded21aeec3930fb25d47faeb772fc9aac6402d56e3690c890a4f2f72894f50132232573060f31973eaea1e4c25b7a787ddca06953f1b329f9653e487338cfe214f09b41506ceb3cc56613ad436e2b7719fc4a33868ff0fb706ec9bc4506d158bdb2b7d30bbc491ceb3bc7088ecd9aee635e684d4ec81fcc5afb0ce9d3e32f1a906c908573fc027b2f4fed531bbacb5dba3221b53d1f6d0ab29ea6108313df34172b9705384d95971cfe7cbe758162df4e07247bbc0a191e46153ed02018736770addbc8ed8e8bc5d4ddbb92b621c418a18bb161286ec5d14c202c30d51b52c3d885beb421e6c9dd62875c018bfa750a9092518ba081f2afc0f5a7c361e5a0dc4a1388edb4058dd2c48f1606ef9d161dcd0ff96c56a71faf97c2eece3c051bc06389f7797aee7f5d7cc8dac6b14d48c3a2ab74ea08ff981f761a69f2134119da87ce58b0d0dc507c69249159208210836332e959a7c2b36e6814c7f51e8ea1da53cbfd89cbc503039c027e4929daf679dde74e533c8bb830d74c1e7e62db7209caa2d331152f64c5fd13c0ed62da346d170067d850463b0563516adb5b9481b19fe3c77b9002310644194a4b65e4cea9a9bb62ff15817c05639f223d493edf5829ec7903b879442ad960875a8c475317ea234a5abc65c8af2eb654eda1298d61a2bf2c8baa9fc0a68c4a7a1f69963d386ade872acdaa3c8c8210bf8ee7e28cdd6b360d184d41afd118b8273be00f9f74c370a765a35214dae02bd691ea0c2e1663ddfe2dd7fe13e11b7c4641cbf00e9b4e917b826cc9e5f611094e836647e9c30fb707a19ce6c9fe16af0d76339cdeb08c05cf02f8d75ce4571ef87430e8d136433f8d0a45422b8b8b0458138322b980c6b27e332c113a345eff4d4b259fcdfa7131d2e8307149db5cdd4840ae6c1608ad551a7f8a10ea209db49133c0606d797f294ef3e957bbd8f02f1b5817e18b0e6a7885e988d5e2d8ddd58ce92163b43878e813d1f217e44f93d8648088959120d6c89d25ec6cb8bcc135e40f63b0fb40d5ca6a93aa2b7daa06aa805c7f40d9a2187a8a8bfef68e4c4aa5592f2d96e3fd1b532a2f3b1997725136c2fc01a556235f35febd120d191f366f56e60689000851fe7748248e0689258727e1ee57673c8b1645c2144516ef5d5c3dbcd4defba19a2da1187b17375b20f3572afbb6550711a7001050c6c6504d6b1d9230f01acfbdd4916e211cc03c2400d30e3cadcfddb1de6fdd181d02f76bfbeabea9acab8996a8c28cca21fd7e9762ea32985fcddecad3a7896de51c5f7fbb2145b953ee259941f5518e437bc5f657aa6ef6785560c4578e9c238fe19bd451c0253339f816575f6f66391785a3f8dd9264281cedd8aab41785de45f6ed8ef205e99b35c8aec2c76faf94d5710b028898e05180bf0fd7c10072cb5b13a786a6df9c7e8a1c64722458b8aca1b53e3dd5436cc3f6bbd9688cde82bc8559ed7863e9f7c85db16dcfd109f3666ff1ff9969e38204c5760ed18e1f2ea17fee6cc1556c97605cc6e9351aa17d611cbb04ce5a5d8d71d3cc5ff13e74d18cf6285047b9353f9fa7a9e1dcbee53c497398acd6e89b45ff5c78f235cb175c2b19e26a3bc5bc347caa1a09c064bda3abd213c2ac9400035a17767b34949462a150434af2a9e38ecceef6c9f512a669d7749af23b9750fba38bd964439c7d13f445f8f97081134ae97a201abd013ca2048316a734aed2154abbef49edc7f321531d1f52d6aeda6a39c1bf8c567131ffb7bc038e6164933f6b10774eb0b0c274770340080a1a1f48a52dad474c63bf894e19e678e1301d59355287e066040c6b2019645efecf5aa53509c772047110d438e872636d31b2bcaf29ec4cb5b966eab9ea1b1e2d403ff8dbd43941c536bdba450b9f084a599de540747f60944e1bad7bb2931386a1822e88e04be8f861e1bd3864ab5837ba299b491379bac17f9a1b3557606fee2464a72b41ac0d1d6353fef27af69e6fe07a749be5b96ef2192508abb2208a182305261f9fc8094185c1e13cc1d0b1b681ad832de3df5e09e183b008a77a26af49ac31442d355507c4ffff88f1424a744e026e01a9446263bc45080d61b99f01220e4f3b282109e0c1a4f58335b7775755a834b33205ad18f30b6a692f93d1a15410ebda8851e55872fc39a79567d5c81712469c1202ff0db67d6668aa3d60085419657cc4e715e34ea1ca970deaadb2e42ab1a1aeca2140b9f9637aee82f9bb9123778667c1d2f980b3efac5d926bf45d8b5dae19496587b92a4012dac7c06634b1a1ab8c9c7c1d7ea3985c299e74c837a5a372d656af426484d8aa6b4487685fcd8f08f642d98aa79c67eaab7a8490ee766ba720401b27c83b1f8028fad7df2a485491b30495efbe6c03d6a7eda71f85d243602eceecfc681c4d3bdfb17d489c59bebe7d229cbd0259e72c7d96338fbc0b5063662fafc799dd830a399f75b88e1a75461540af40c0af99417683ca30eb52ffab78265d506e06f158bd5f5a8817a75f5d7b69a14c7107a55a444952900378508ae16a38feec0d94823e0ba2728d54fbe35ffd24f282fd5fe5be513e1bff64117d5778f4fabe977e44c3cddb69f8cccb6dd32b034890af0c42416e12bda50be5451b997fcbea964fcdd23260d0ca67a3cf09cc68e0b98527c6d0430ee315f06ac8400928037f5637984397eedd5cd108a101ef1d954b4e8efdc8b33e43cfff4d68b827d5c3fe0deab26131d5e8eda7623707870e3979f2719c6d51d27fc3390a46302d0efa4fe95ccd19512a5c89dd9291798cd27c95379e488fc9b7f0a8aa71057ebd44bd89c1ce25c0a04a7836e0426e7d029e37ff485b8c7b077b041731fb1c2a9e6e74931e3b206b377be5a0b864ccb10d6a280ff81901d7a7b00456b6dbd0071a3aa1d1b051342e93bca69259be0c428fc2f87118485f14a9aa15bcbe15910b4762778808843ad4034bb0521f19d7f805cfe1ed109e267594687dad8900a2912d20ff9a3cc42d6daf19b67343465770182cd1c34216dc913675a8f140b74cf9ab88c78b694cf715cfbde16221963041f192e91904f7990302607b9c792d800af36a197b597aa97133b18cd6c003f2984e4759a3db7c4e7ca6d74318abb7baf9bff6c9227d2fd79f6015ec826fa97141b2a2b0948ecf2a5bff9cf902b2a2ddecdf107ae72390985f2024abbe0ca6372cc68fdd86ef0b2cfdc78045506ccf2b2bf232966c385731c3ddde8312886b940cc9a378708627c7fdc19766d951123e86544a5798a53e2ec10d177fc3f9ca95bdc34dd3f857031b18abfbd503dce9aab2b31abf2e3d7b7255d6b5a15063b8494894ca60bd9b2dab299639ee01b250120863c163607a8e53a02a160201ad5bef3d9bef518288f7f78d028e669a2cb51f15221653fe607a5154ee5fb41dcf55765d7a090f65d37c35a64f0d2d9ebca5058087397cb7fd96bcc99d9fdecf8d221b3888375650455625049fdff84850ab29d3577a4a79d760e341ea0ecd65399284c29758f97ae44483830b6ba522a1b7ab6acb8a08dbc277c9397ca83c1d73285d01c8f2288322e5bec3684f3cc9da65c5a44ee7bdffc416238642f830da1818de6c36ca2eeb98ffe6ee029eab64c19fd3ec0229e6b99f907c3738b63df7497cbff4bb8446b21d6fab15edddc8a57aa467404e0c38c4d62c9678e204d228fbcccc8b25be1fb5c1887ba9b42b44fdb11f1301d5dd6b68d45352babbb804ea3c11c8deeb9876d0dea5fa8cead8e22ca45962c39ef2d266b67d97acd39aa68ffb476f1fab47999259c9de544c69160afa2e1f348f71cc4a9441e5e15b419af95d8e4ffb0a8c2f560b601c592d0b324cac72b91c7de211f6ea12d7c9560d7003b8f6c7c22c68466a5035abc9142407615fb4bcff56387314179f8008de272ec448727981c3136290bfe3f66a708edcc3892ff10e01bea1becbbd5a1b8068062f178e61579af73a8445401d956ecbea638c2ae6dcf317c6f293bd1f190d5f3fad62eec9f518a8deb58e6a1383947af3e87e78464259df111cc8ad7a69ed0d2468bc20c1f3a6e60fc710157a5d151671c948ad4667f8a376cdc67134dd7d9b38bcada75222dbd6f274b31171cecd11db6298fb3c9f1713748dfb6532e44623c878ca81b24494cfd0dad9d2601c524e590c44a3b24937865d501c3306ea053d8887cb7b7f69beddd1e5e65ec10dd59d974cd35be6de5d3a4c3a6e5824caff7e815edc4da53d1e035023f42424c9961626d6c3a67740812d382167ca8376f268bb2b2fdd79c6b7390b72887a5ea8b962fdbf601bf7ea523c8e3de5aa548b9eaf8d3f144fe3b045dc08a58b451a0b7ea483cd30c1ffe77a117068206f10919203617d622f289a6f15666f211dca2d62295814278206cbc7d1fe526392a9c92534fe40530c3b663009fe6e2a4e4559a6227c6eb267703a1e097428b8e8cf17508759446a35bafa4883a73d14ecea006d1923efdc5b885df43377233d36881effa1ee44b689bcbb0d1a38464f39fd21063d22eb2ce1234ff823ce9d1783abe52350896fa135d744bbe02a8bbade49637639ed29f6c073ba3798334ac069d98ee79e7c2aaf4adac712d5b3aa0e9323823e71dd0c8218926a4a42034bfc356fc3d2cfa70161484e5b4c2d4b0e2af22f98349ba35cddec98f75ba6de651b211be0f7043862f113c36131ecf19686f0ceea624dc6f9f8cc8d845b6f061c4cf5144a22af1143f55b024811edcc65925c41743a9b895df8a0ac83d82a544fad146206767224d2ab530f1d242778a9af5bec04a06ca90d41a68329c36e3f8f5310652545aa00ad5fd085ba8c0adb97e32eb4189352cd238c95ea5528972ecd94b1a355eca48cbcbf5dfeca0d15b0e2de17a3d9f0794832a433abe9eb53331c9aa6c9dfb1f3dc1a3bfb147041edfa0dc3e6513949515d9f5b2c9fdc8f541ed1dc792b8fdad1b338acea0ea0e72e19241afed6efa0e431cab4b591db4b89ce49af5863f6feced150215aa64b41a473a2f53b9d6763c59ed9741e9dd2f50ea6505e45b7ff87793bf1feb19c36cecb72722b261f81cf9ef2ffc7a64d434f454f1ff84a9b26371b2cf44e1625922099678e65b61a0a99490eb846535ae17423957d75132115a7b70beb1859c6f8a0ddae7c85ab9d9052e34af4a5b6661473658a5e503a1e8a6f7f714c4bb44e07b45182c387055b0dde8e1fc1ea039a92f96829ace94c5550bffa23cd5892caa1364942ccaefe1972fd0902e89c4394d8350e222b454da94648960ba54c7600fbbad227c7ea84e1c739de0ea6bac9bc098e4b9a5536799cd2042bb3a206449479328cada7a4424c6cf568ff6eed161b7e3c9aea556af56bee84f31afe70d7b2472f6841f559625691712372475574a569031a516ae96d4b53d40bc18a522cb682afc802b3f5a45c52d8cf2ecc12c5eaa321c7c1bac418f03de914b2e08f9e4db36304954e7a36296396156366cc457df9a797cb3da1682d193ccea281c8fb759e4906560d962c474346ab3cfc8b48ec664f0a22aaf9a903ba572303e1db12f7299b89253af6bb9a9c294851c5826e3258f9b662bbfcc9356a01c619355178e8905d85155bf662646d168beeeb34549b46a332c83c9073f1ebeae1fade6af7fcdf7b5cc6a3b9a84f6a65bee49cbb33467a9f20ac837c148e348b729b57f8ef31d7308ac78241538530585d6486ae2e1b980797b408cf05d73f3d6933484a7518b9a3fa3064e0563d113895f400a3b2b71b8472ae0f8c1a073b5af66a9390fd7aae93c78a568220390042ed9526a9bbc787f49c536d5e38770094c6ae372548809e0005ed93d47e27c0e44ac1967dcc3a86e1b7e2e13b0ff0b1f8c7001c058856dc791022049151f786ee6685e17916054a2c1a9c44dfdd4c07bb3132aeb89329fee9aedca8354b808a41c7dbaa3deb1128f44e423b3a27f93ebe9de68fa0e31acf9f8c809d27107438dd5b9d9913881fc43601f9dfc487c37f95b745d30d1efb9c18a83f2f0eeb4273942255c807c5a0e09c4a4d7e4fbcf79775e33f8832bc0952ac592863809bfd31c16d8e1a1cb9e91ced23c3ed04796d31f986365bbfec27cc8a3563822be5d29436802b6a272ae184fabc8c98039df0d3c4095a43cd667b7ec34694824aced85419e712756d9f87297b158c7dfe7fc37cf40ba985d655bb5430d06296ca2f9752848abbff9082ff7cbf4d4379d8a5d2543354cb9e5e3463c1293a4a95491cb3143eba539603524c2e6c94cc97064f70cbdfe8c67ba735599c413a54f0c69bbdae71908c83218db5e74401a854bfffa5c277bed79b5afafca44e513b6cac52a816cf17b613f961608beacbc84ccfc449d557b7c771a69b625793d2dd492d23da808b71605e6a746709b0c03cd63045a0e242d1b09a6beb0b95a2f9c4290fad6783396e7f21619cfd8c95473a912c3ff5d1ba8d583869c8ba08b5eaddfc2d4c5a1f8d6ed5e3f3ffb0b7429dd8c7862c066b3dfeb517d6c9493cf954d9c8ab7ab69da38904ef32d96dbd412a58ce6cb971b6faa0b1931e00ef76735806052b8a5acd2019e22510660776ffcc6cc165b23ea01977fa9d7d5fa7384669ad2250f827e80514df1176e0aa056716020d551ecbccfdb2ddfeb79f4a141fcaa5de4deedbafbea2bc8a548de923dc1a4d50cf4c5dfddbc9b2a24d5134ff0b3a535286155bc800fa4a78368bc1c0a4635914e2d90b947955e0ea8e562f61805af91e85b7ec770bab00cd6709e410d71260db62690f3c41462ec60a4ad636db6b91ff302fbe3592798e1b2e759decefdee723e2dfc119b3ff028eb0b546b18586561de663c47fa9ef89cf7543edd31cf2e4d05e333db74ad38dcf6ba1220be8a9ffc378f5eb17f9cf8a896b5991b7d3b63d3ab2d63e5274a3b8dfb9d52fecf6872db79422d04b4cca72a5b8801159ec6f63a7ce1624b559484e0f880ba5adafdcb0ed1b2338284648c96c1194a036f85afe5cf1880589ee13851c227274043208bbb234bd4f239883a3c906825cb178bebbb9154a3640d2fe7a0e9873b51db268a274b8245661a8e728a657a3b5e9dbf7a3f1418488517a6a975a7b15658360fcd0a49d154ff6bd928e7398c2f6764ec13654cd8ae8dcd3e3fec27b57d95342bc91c1a5e6289d6a47e68131b2462e1d538379fb7c4b1e548ae408ee42092c9adcf2d6c560cdf00286818be53ae7dde2eaf5a475d1b37dcbe7a95d8a18ccedda48c048db8cdfa2274c775534b5835c56d2c272a8ba81f718f37939d7b91b6e689f100a4c34ac07f4c345677653438ade9d1973e543be7133f457a87ca19851e7023a1a11ddfece7e9cc0263e7af7e4e650b64f474fbf8dd9d4e53a86f6c1d51ee86b5cb8895201aac0ade238f8bcc0885edfc95d3aa47e7bc64a06215840bee433f8e464a692e0e8285f416ad429cec0dafc4da7701b388fa875ead7c65ef776ac7b00092dc4d85c38c353219db09a0cccaf3a15ee4e8677175650e0519a87809f79adcced36dd7566f2a3b49634098a1ed45640cdd8bf4029f92adec2f33c9f349514d491e31b015800f9181f642ee366df8b82712df9bd811d38d0fbf56874cf44acab5187b2f616d3a1688f264f94b715789e522217fbef7cd629e1d231cbce7e3bcca2e80bdab7fb38364451086a87f7109aa465c04ed24c89da75113d4161c3b9834f5fee525879cc9b29a7549934d38470c6830b2406895cd80156c70d391bb2ae891387842619cfb84d3b72dc28451ead8731a84a19509040d0b8ea244c769f5a7a7eb15faebe7c64248c788de74e227f642d523108d88b8852b61db82ad10213ece7652723482a24b8686d4e032e328bcd09a7e71dc426a46a087263895ad24588cad581808418817a677eb38fd371a3c456e012ac17ff59216e054e18bdf5cca7094047e76c30c6bea6bbcc91017922207f59203bf838e6ced0d6757d0faa0dbcaba86c2fb34abf945ffd8cf0520e47e5bc126942625566d3fb623adac581aa5ea8cdfd958e63c164d4d3cda17161f635bbf2372c24c729a6b77294de6b6329d359b7eeb7bf5f1fcb8f0f24c1ade4d1fa4cb642cdad55b192299e030f4bc7841bc013143ad56476a3299e252623967cac02cf3b6148dfe23169f5afcb0438b7eaaec0422f8e965693b316ed11f2deadc096a47888d15bc7224a747f8a463f579062879db5e88d976e81d4f8766563f3bdbc5927a3a64b58ecfec257c1593709b79e2be54bb7dfc708469b3530a72c9a6aa9d73c71499dd06b9c0683ec9a992813799acece2c9bbf3a33c1e3427f1ca02097516e9a7fdf7b8d3069a5df646c2ece1a09db6774a4b347a0a0f8672508c066adfd6ddb9220f3d13822b54fb62de3398f040859bd8115b4798dcc75be1a81a9b785db4a1282301260be9446191b47208573508ff86e32fe2158134de4c7150a02fbeca809a9becd5870042c4c1ee922468ec736700a5d3b0c074b8a230eca6ecceb0ff22db65a17615f263482a7aaf3e189218ccd997cef1a52071a9b78f3c2c58ba1b3830ed7875d776d0a3103be395a512b0e5a27b9dab7d4a6f2306107ee5c44c16f67af3240cd4cbfb4ba43022a826d04cc9dfca3781d92f7ff49cdf65a42d34143e84cd2b54a96cd9acc725f994fed56af94489b4baaf1c0e6e675c7e71745c7d6d0b56910546a0102ac397c03f09bf118a30146d5c5344b803f9cc9fa8060464b3f6557fa8c517b71ea7d3e2a6c756a575ec47470f938f9ab6058eecc47dae1e45dd5443b999da72eef139a134e2be86fa87d79a2daa925ae558c25b1de0c6a31ddcff20ab02f07c59e9a2804542ff6d4db2dec59c30e0fe283612e59cbd7babc01a9fbdff9f32243bc8c653985c4c5ead476775df3f7ee06db563cd04b14f4df30088bb2436ba29471582d0bf936af8ef76a4261edb5dab93535d39a629bedfe2192013fc6802fd05f09ccc6d485d3bc52dfc42b8948b42b8d643b1aca07da7e2b1c485b29e79e2514d14206e24b1f706a327ba7906c8b301844f922e34520656f1d512348d8af5f101f9b6c0868e88595fb7d1ce5c20ef72e178f3f2e98e0c351b502fdc437783889aa25d20b10e3ac8833173ec3ec507c34ed737f9eed04a6c4671b3c1b71035b24496f8fe4ce3c29b8d67947d229f88ff01620db267ac9239a39c3c135c09f5f72c0127c8ecda1760539cca6d17e6ab97703cd0caf69c1b1e3df51ab9aa4fe3ec4504338639ca9a1b4efaab8fdbf510bf41ddd9112b22a3b3f7172951e92365aad5d0973e7e421bd637b8dde31abcd6a1b3688af12b50e3a71b5dbdaf9200a8b256120525e523dbcc5876bf2899bb9ae1188cc023f92d1b4ec9979b9c5f8d1a59f0ed3ab126631960035d92e6aaee4302cdd7cf7b9c02f36d937d2787097baf7de648666830a3d422cd6125ae4fc6d73b86b92c34cbf9f28cc86aaccc3c80630e1564bf8070d66ac2ba6a59c620e3559a20e41912b45e4ecdb269040291bee82b7cd22eb6f7dd30108e57269e1e03dcd3f2b8b83f45267924e31a988abed38ba35bd9ab8b218b9b5fc342068eab8cdd9665744b91549002f2e98af5ad0fd9c4ed0b1f24d03e7246c00c183a1d14b67d62137678fe8d3f8ab76c4466a6a4d2c20279043970382cbf36295bd58e3f6b7c18286296e9f250c649cb07d9521ae7c28b91d1f2235650cf854d7e10b19193d8c6d48d586d37be91350733db0d8b8cec3cdf2915f75a411bdc30a32da1e3037c66f4f1e19349b5bc5d56060f6078db8dcc5aff28eb7f92500051cc1622da2a8ee2be9adc273976ab64bd29cd1dc4eed8b6579a341d3c94ad149a33a772008824e16d26f389ddf393a87c6db59bf3b1bf4348957b2e9f1db3ba8590532acd0ba93c0ccfb37563fb31733d84c3f2d01b6d7e82cf382902fffd3459fdb40b38781820f2c7841a98bb1299f9b2d631500d92cd4c6debca3100b07b66c7856968d5cf28dd5938ecf83ade7263c792d8a36788fc76042acbc43bfcad2f5761500acde63c12b4530d7e06138a9ac7a9839e3a41142bfb506306d82d7e20b32a71ffa2827f59cf975206cfe65eb959fb9f31fe0ea7a744b3afdfb75d1f4b3cb63af97ebd1a08c130bd6636d2fbddf6c271f2edbfd48abdc9bcb65537df461c3b40473bc3435dc97893737772a2fcbcd281370d73eca0225a0740bc2f6f1843a73ccd7b5547179199d1e3d37359b401f9a24183e0c41202613411d9391d5d72e946ba71de4e0241f7c1c4b038c5ed742747a911e876ee1de431fc50bfcb442fda52907ba6a5a72f75b4b30d111353353675fcbfbb0638476b05398a34692f78461380a89096cc306bbfd960a41e6d0eb33880b52d7594f0744dd62cd9758af2544221e9826c103cc097db67ef46ecf2aff66f484315810b67607d254a70ed85c724e32b77ad5ba9c6d7f1dcb75397aa06e788e163e0092575d45df6b55c4d7619c78b755050d407f2bd2de424cf44ab1ed6e1787777a48d013f12fb630e59dc7529f8a489ee80065ba55f43947ea6e8db47dac689b4464ff0341f3e71cf41fc415d39f96ee6ad15130b4d4de390ea0dfcb7e977fb632cfe167b2eb0d49ff168d3c924a7dea14d95fb38c41f116e30cd7470b21d75af0da7d687084677768a01791fbd85a03e4474039cc9fa2717263b64c9ea57cbb4fa7881a78740651b0977f47bb2f90967e7c6baffdf2f35a6398f659afae9286d710a8a0f5b044ea1f74360cd43156f4bd0413387849e1755f7d57a31ca476642f4adcff85fc5202a0459bdb70bdc3538a0826b3e41cfc5f69606c6c47522a16f56a740ac36d1db16963650c5d14dcc6e1b909dac76dd912d35d11dfc287c0c34e8c90dd56d2c41cd737565386b54b78627e5d8075bd82f192041e2a2d7db92b37b95d80e3d1723c7d9476263984d6d9c069a91b584f4ce51ec0c8744f4fe0253764596f2ee9eb3571a2f317b10e13f218e673e8d88722ec654316ae7ce01dfd43015e0fcd94f8b23fdd2b80394b36111c5e3b69c9a922a5278aca6e94656e4d40795d1cad2edeb5058e6448327e7da2aab30143e9a35726159a8801a37ff375f417f681427d538d625d9dd9aa82c3589663365673716ddcb87437271e77803b4ccbb263ae70be78e3acc47e49e176aa8f130840c086e0dfd8eb5a3ca47e09e9799a39796cbb082a53a871693f5fac93199b016e2ed5fffe31b6018333ea275e6cdafb8b3e5fbad9d0343cb6bf0332448ba457a08271e81f5686f6c670f6bca8b24f6cf169bf7ca3677be3efea22629e6a35be38f44107c0bb1ac1ec6dcdb3b4b813befb46b3170c45856c50cbe0a1a261b82c3d62a095c420c43edd7db627dfcfeb341d4bba8787a1f142ad0d4e5c60af2e501481b26b3a7c4b97a1645a4e98f6a4d6973d4f02eb43038e31eb86ad9b07a4ec71f778293a8233433c9604f0f13a611e31c67f074470ef9b9894f36985b6b556351120556a63008c65d7e5da0b65682abf3d235e0cf0e30460c98134dbdb048462642ad8b9b4d357ee926cd954608de5937ed93c35f6d0284000d1304cef1b8492f849ab42927ac0ecddc1c14c0b81d2d18a25e080ca0a398ad6d44299b73840d395958b1e0d7befd1bc5b5e18f73cfaf20a878cf32780bfbc60c5cf0b1d507ea8307a0b68a1c24313d64db69f6135475a9f3530dffd0d41507bb0f89f894beef29d54f9896e6272ce4429483bbd69d881a01a771fce397261d9dd9864475b52113ec698cfa9d67d68704a0461207075dd1176f79095149be9588ae4fed2325d3567cba64a87e42a8c9ae89cf48ee0af40bbc0c206a62849fab33ac96fa9e98bf86cb35fe1a80e235174b1d3e944d6a030a18f58f9cba12ed9b3c9f76d2dd6c6f0a91860d23b10f52569a2bad37adea705293f8d1ed342a13f02baa70260371ae7d09ed913dca3364d351b0fd3869399e13e3600f00a96e1f6d1f89550044acf75098b77150bf813a2fcc37afd2404a985bfbf15a3c936b4c2ab58872561247b7e700ccd0bda7df704faf8775104c149dc6384d11a3d2dc27024a167c7aa6a10c993e69b51998a8da67016e81fd3355df98c1d7117b1768a87daaf0d678f76b5c42777dd4955a5f7f41ffd4382cb07633ae288bced9af2579faaa01f643583966d5d7c1f0426d4c1e3860563f0eddbe5111155a81ee00c236412064723c8af307296d5c1849a81ed45ffe4d3e27f1e5f252905721b5317f2225953a260ac5d5e880ca83999254c021f92f772f969a50d0356d009d22a9ac2ddd1d245851c2bd303d1826e9910a83a62f2b10e3032b4f152dc1c9620d9d183c7f9f3d6bf176bbf933e8502522a04e4af944c21fa4736ab0bbf8b0666d7a8c13e070dfb00dc413447e095d818edf14d18bd6f40d27ebe640172d8c812dfd8e7ce45389abc1d3796a91153523903f0f885dd65180ff84c06185dca63c1fbae7b4bb983b8cef442c54dfab7e65262c53194f1eb3678d8265c91b2ad97c9acd75f7f62dba722497a4aa965f1eee82177fbc01ea447b6e44516e22f89074c8fb2ab6759c046002e400410bb5bd8f954d0500a58b6e286037214dba8a23df3b7b1885776aa305eb4c66e25bf08910d2c661c703f557071bd4cb0475647f4769f210049ea53ed5f1efd25ec9b89747303085183d2db23d9b9315ab00a53df56b1441aea32348dc22ae4328c03287d463a18402cb410d9989f9402260d7e41e1b9a4bec1e0295f81c9a91c88c49d8a2201c4213bfc86725a555af155864be1e3f9bf362fbd1446466b6ee6967d555d9c0ddbf18ddffd3d7d951d02a55797f4e81c5faf6f697e6e1151adbd0cb66f7e9c242cbb289","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
