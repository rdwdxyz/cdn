<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d41f0466347e3fe4a2ede0ea782cad577c811607572f3971449557dc5cd1f62e4f71cb721b0b7f8d90984d5679936d343e140d1cb99d66ca952782b4d21d3aa04ba08a7c74acab4bcf8bcaa345a6722ef29aa3bd30bfc920aec6ce7a7b051f16b21d42ca7499677ac10110a87eb496c907eeb79a80c4a427750291d35a08c8e5076db06ec3cc461d8c33feb938e9575ff91cd423ee5718aa3c9e280d265f5bdae604f36bf5cf7e0deea991a4167654c74b0249d499784e37ba00f88b24ac36e52b7f15f4dd4a1110dbd61e4b54601ae42921b1e73a366aee0c4c7a69bb08952de51546de45cf378aa266554c40a10238bff1dc2a53162376c344a4ebf07a021b2ea02c646f26408fc9835d977030b71953ebd4b2cabe14b2ed4c0352000355f80ee970119a6715cca36f5f0846b343013a39b95bf4c8d3fda4ff473e7a40a3c7edb2d6de5db7ac7daa3ba98c79cffe7f3bd6e9b57cec18d4833c40398812aa056bd83d627a1949b035b5b738ee6e27462421335326ed0a9c9919991abef852bdfb673fc7ca08e38015e7f43338a74bc53d30d2fba43ed4efd3dc21a45316bb583197a93ac11cfed766d33110db785d7045836e56598c1055f2222b6bb191bb16c32e64f525909892cb219244a71e330da650220e285d48c2170a84b022a3faf9643f9b3804c2c798ca0bc38659aaefc0f8fa9c26c3931dfc34ec0f0d0186197c64b19da6bbfc73f4d901d81f2129f1bf06fce4afaa346b9c61528653ab4e04bd51f909676f38cb428ea51077efea0a51f066918192ec87d4d3cb2eb6db869abd520d654d27c2029e7ff46e1b157421e9dd4296e3694f504f631b9c3302a2f808367a770b032c7b739acd3de3952117e599c2134de18c8f6b7e76e3d9c093da2870f6c7a21dab6a578053425d4351ab407498d7bb4ab65aaaba89c6ace1f19e77eb21d3b94fa520a78546eeb0c5791c863884d082ee5bbbfc68e347fe0444071cac8273c2a840058a09a6eafa2bba2a695d1c23526d803a5f6b0ac59e57b731d60166d2c0f5dd2922db7c16acfc1a75d9c6b0712f8b83eb5401825f870417ad4f9502be9786b7d78c2ee022cdaf2e42d6e5d2ef34bf3c706ec495016338c68def92df63319f0621995b8812ef9796ec4caf2fb22a6af3a13517b53fba613038a0b44046fe783c64f2e0550b3f898260c9541cbbaf25308bef6674b593225d0059af773a67b10d08ebddd937c869b6bb67f0ee25a847fcb2b94d58bb957f641badec5d99f4f0172911cf53b937f1ec72292b31c843354e7ddf8d31de0c448f8579a7d0496688ea427299baa089e08edef229e90ee62f4430bb9240c61f05dd187dd70458cc7bbde0986fbfcd7eac0701b1ee3e0563f06197efcb0fad68df734fedfc28f92a116abe81d2f6bc9edac7f5cb344299280cdd4106f7f4a6de82f4512ae4a5792d624eaa22fb05d8d2c1f104b65698e387c25d48b65999d494ad3211e644558be5b141ec7d19b4ab24e05ce21dd13d4e30b8516b6a812cb842039c0eb4c1410185923d71a480801e0c973738b234362262ec8060a0d1b8ca6bb189cf0fec2a33123b47d7b3b59acfd1db77bb919ba1e6fdd9d987d7ffd7afd6e7bc6c94c132fd1b19f7e44722d50f5532b95642574b68818cf304ea71a507d10059876abbb64ed826f778591229c624e6bef5745c86b88642931c029a5a11624a7c445201135f33eb62dae8bfa91e50143438fb01250e899eb68d638ef58ebca573a6592866b50ffd4d8719d3684d2aca97841cb85f969429dfb649625b6944ef8b9031e82cabb19beefe6f08e45f47b8350cbff5c670795d2b6684781593def479abff66c844ecc957bb9967e662f9b8d980c6c7a64c4cda68198140e6cdf45fb952d627d225e3b02a5008eded02630820151d52a90f45dff881657fc6f77c099b50935bbcfa8830410b4aa6d379bb105e5ab6ab49407a967014e18c6d354d1fb6f89db3428f590bf8877f4a26cd9d10b14007d33a695dd7a46df0f88dc80154ba978333b9fade216fb1158b7b87141e2f2adce2630e985d24f982f31c7bd736e76622d64e54ebfd2c45e0cd46221b4ded05ea1a8a0f619aca6215dac08e98f412ac4a98e97e7fc3c1ae2089b49e19893699b7e31faa1b36d0bc5613a231407e699fae5000498770bbee89dce8446b64eed2309ef81e22e543fdc0eeee6f8e465d23fc3bd76f23db0c297ef7747d80176bf36e64ff0cec102da9d0643b726b85fca7e0a097a1c6e7eee44eba24f8bebeb3f090af169498af18d025b0e6f252f2c239a541f032f368dea652e7861509ad2b85f1934c49f5f2e35a87c924867c755a3ed558076a2e4273f6c752f113e909a096bf780c0719e8754a3a68c8ef0ab2e5e31297363f3639f89953a9f1174b8320f461d7668969a7c47db52823b184a439bec4a7db5e1e54dcfdca37bf06afd3594e75b70a7e331b661c75625a65816ffc7282977ddcbf4d35851d5b13fba5b338dded1e391363e8586be79cd8e2b536667aa53e90f0027861d04974c9764a8d949b3b9a62e024387f384a530bcc5037af373cb581e0912b145853b6f3e60a0103e827e2737eedcf86d4c85f97f4627f198e6946c5c6a3d00a59f207afa686c1eb58666769c32059601cef0196b8297751e9244c3644d99793935b77f0ba8b89d7be433c7f5eca6d74abee111b03d994d641a205942eecd946c03782583c193dd4dc72b2a3b5ba5c52cd43526cabc029a52f5e398912a1e3b00a385e06647fcd4af2d4295418239993230c2e1814c5a589d47e8d3fdc1b30eb0eff378fea5498886d7e27ed16c94f0bbadf6657837463a6c7ecbfd6bed6faa5b73f8636ce790546366828c08f1221197911e1686fd8d16d76a58e7a2c136a8d8d322d123a34880c9f1a8dc550bcd4c8509fbc24493e3867c70fe8a52a20253613e4c914b5e64e3d1253c76d9309d4799bad6fecc6cde5d84de5ebf12793ace5f7406c9e2d43e81d6f197ae920569b382cef7fe589931b3e3739fd48f7d795bf03c8e425f3b3b976f38501d458953eddd8bfb388efce914d1084413c42f2302b16a21037225cc73adeba2b0fdadd6c4e795d46dbc8599828ea106faf0ba30f5773a5ae1c78c355adb708c026447f417d5e5c8d4c992149507db442d62de6f433f0501ebe2e1e547c8d252cc4577a49696478d38bd3e2e1f4184565fe4f1b11eac540017d85bf3783c5723420e43d1e0eca755a81081ad27d6f2f16a317662bcc9b0e85b64c65e0b25087c4047b3bbf2961f2be564a06f8e2276fdfe2a1b30bc8e2dab5b2370abdfb3e7c3a505a47dcd5cd446b711ba3811dd33a192ad6bbda541fcbbbba131c9bda80928622e4f195f32716fbee2261c8ec8cd53a1689dcfc359239b7dfd982d35f328b10036f0e0f8db9740253ef49f0f75b9473547c63b5b77485c27b723a1074bf9999c4580f7a481e57ef6a11ccaa527d898854312896032330392b032006ae629f7788120f0892b65f02114656256911eaa4c09b6a6975f4398e86df96671566e0cec3915d4c8aeac0f9efe5c32ff8cfb0eb943ec4666e328ab73c812514dfb4a54d12f98cda7b8ddc4aca0bfdab164687777f3ec04de8f5fd1f264734fe878ad0e31f75d83703800fc540bc7200f42134fc35837bdd819b4e24b21524c456ceb38bba319bdc08105c5ee72ef1c843d6b1f1b5ddb87ddd65d5c339cc7e461d7f2cc0559c9ba6e9ecd5b1b94163165b0491ca729e43379d580990153ee5b4af881535b799c54bac66d8be850a00ff9afcd68841094247b11339cdbaab74bc9f7e694fcec71ca90255a2588bbb7d930a7661b455f6e5a719b879631a12f76df52402dbbd225e0b27f97ee2bfbf279bd8b65124133988b6d0a7ce7327dc80e37a4c155d326f1070f504da78a47305be841959c7633a771e79944bf4dac464a79118703049b67a3eacca042c461acc7f018b864c0696f47e7164b050e412bbca7cdea7e685550f5927afb964ed0d7901357c7261b1cc987d855c34ea77df3140742fb2fecca2a106ddc1c50e08e43e482b4721bbb59d3fb61bece9923cc13351cb3c630b95830bb045ffa37a24aac7a05949622c5e8244b61b47f39a2286530b2f66a9603925e377b4a42009caf27bb912d433cd2107e26937142ca94bcae4973719b232f0e0aa21ca24d602091c5446407da1f25ac687c8cbe45d6d4ca45c29414581c80c5119f1e98d69aa23cfcdc59fa933120b079f9c4d87b36999fcc552f336e321d48f6ae2279952b369607e843c8be0e6f4c8c0be7931b9e22a043faa149e82105023081e53091ea77506efaf42c1de5eaa41a37d1cc7fb05fa4aeb33e1a2cc8b4782c2e4c490591bf4e7e4418c9f84f35f910f33431ddd3c13380fd6a0bab96db9bc76a1b56ae11e9d4cf144a9e5dfaf2805c04a9ba33cb44c98eb8116e7225d2a6c20b5de56f9df8ee9efd8b8e87f4ba36d32ad27afd5c8ee73aa8c389284477c88175847180daefbbcbd020d09c6258bece576db4d50609ec28365de01e125442775b84507aefefc0151cd43ffa14491665680d170caef90619d0ab4bb6d0ede39f3bc67aaefd06f0d38adb5afbcf70080346a89016b958a54b6ea69896b34234c0d9ec00e9b46fd9de12bdc595dca018e25120c45b51ee8980d17b330d4b4d3fa1bd939d2ec5c072e1a08405049898924861dd7d43993024dca6c7445f6ec77bba961154970a362bafaaa08f7c7dc2b84f46ea608f64399bca343626619efd5ea1d47de9856211b843af849d7db8181ecc14885c83ed3b8ea6d1d76fab8ac25a4089c1b9b765d317bb3d0d173daa7435678d15393282b6458e508877ce20400bc440f59af022b8a9ea5d28667459ad52dbc56cd80b2c7643cf54123af17b1c33f888b9e9ffe1db86add553c145bc74049e9717b440207c07740ef9c789ad80f68e31ba5eb5352059d16c59ad967c7c7d79320d09fb78d1d4081919f1d86daade9200566b0da118048ae2bb042941c2952016e1f653d18c389ee63a8b27c67a8b3c6c956e347139b2877cd23194433a7f2d83b01cb3acd0b0b6e1ef92b7c34672d77bbd39b9dc67f912d2a3a4bcce8bbf4a3b0f2e753233287d0e5b17af42559936e458cec88133feebae72c09f436e77c39c7bf1160b4f48f20918fa883d6187e0bda6c7202c3cacb6e104ff696a073c6a81cd1117ec70cdb992801dfb46ec74466c4064bc318f3b1de67951335751226853605bf964958379820520506156d32184cc523c2c535334375d585b6108aef34a70118592a7a6b002c3fe7ea497c17636f9d27a2e695172b49f9142fef42dc03f30fc3d4b20e805dc2bb04f06cc7a29a1505a88a3b1c142e89e31393b9dac3f6a290a5457305340fa5f5a4106aeb0dbc754d477eab63676717d793398f78f3c655315f3889cda29d72518865ef5b483332876f1076008fa3d957c975732624678fc37ad155f8e0dd0d710b8e6964e41f6d7f39b0f0a269b5bb28c8d45f4f2c0fffc6c596baf6b78482db325b60ad8d5740c030f7089e29708fd2cebed807038cbaadca1d20b1d8cd000f24030a8b4b74f7813507084f0bbd32712b703d0fea888bb52e5d056066fe62afdbe21a3cb28ce20785a09fd3eaaca92ce8b50b68352f1e199e3fb20ebeb3119a1596a9bdeaed418d54cfe791462726254e729e198ab92e0014e7668bf166e431bcd342a46f326f708137872f02531c8dadb328b4f90b3c775d64fa8473c585121a91ca7cf8fb53eb68ae5483ce90c24cdb28785bc1b2652783aceb23d3e6ad4ce14161590297e8dbd42ea0452ff6152fb8701d1eac043ada022b2a79da0c6828dcb5ed6e7f1918c81db88a1876bb0c8e04ac70130107c4aa4a8d44b2d51ca8b6989996aa8ec86ba17b1b063fadc8c4a01d50b1106c4a6173293ecdf2090adbea700c93e491f683378397553dd35c28fdc364fbaad41d5cd8def1c59b832b1f6d4dd1c8972976acae9e8b3ae204d12888c255f1e1fac51660b1ba1d6c2cdd671c291204d8c268705f905430600850667331c491d9bcc579cb0e13d83a2c6c067c50bdde36878e7e04d2b833a71d0bb078d63f3c538142451dec5511a5c6d10a08f09c548224f3a750c859b88c23bdc29d5fca58b3d00b0fa74083e3000a29932a99c77e050fad30096bcdff9d999993979f042696151d173d10b63492e2f73d763bd8f4d1f9df01d17b13e956f1b3f7a2965a077e58af6cfac02b6244ef28879e895c882ff942d158f9e7fdbaad270c089ebfec2bd8566d06893c501aaf144d5bdad23e8f2308ec3937c6d797ebdf66fe9fc93e25b9fa2690b9e64a8d7def2bfa2fd3e3c285abb2b6571b12d6e015eb2609701c5cad0bb093178ea793de360e523b14d931c57c86281c8d7b09ad97d5e98a4514649696692f076dbdabab0684581f3010d988ae01ac7baceb129d4e52c25ad3120b47b4d91f396e3a575d0a524a29f6df1fae96cbb8cfeba8daa52777d05063d243bcf127dba1b74ba4362ef0dd1134f2477dc796eedf4f1a930151752e339cd8be8d3f8864a27e21e31f39a84af0167918b02a60db76e959fa5ea0964db829c93518c0ba4d16a74d2178e6625290d64bb6216af96e9a92f4fb184a6565e094ffc8bdb390d0a59b29872587a89ec8d6a22276a9724130c212c86dbbe4da916b7e6cf272cd096b9764825d1be811643b9eb58a99ec7ae552461aab54b8e784145b9873e6e1a0654073f717a6d83dffc43c5ecd724b23a1454d5ef3c2570e8299fb9ef5dbe7743867159f72f4f11bec9dfd2a5c94e0d458604606129749a64698c359008afc262b06243467f46876322cb33d448efe85e8bc82388db40620889a2061ceee97186c791cf434cdf29ce6e9e39eee685e0d13f86662edc00b3f2baf298adba37d5029a37dd93a8b4931d006a2f6bae4aec997892f4b898f7ddceaf527af821005cb7669a27d83b87e2d590d20ac61990580b7955ce62568f1db7a63131dfef25926600e22cd902efa0f3246b799d34f46df9b891bf23e491b2cce9628567730d7a552a0d470c4caf82bbf2a84b5b4c42c550b218730d769656c3ffcdba3657e3d23d0c7d94a7c75e28fae89a40640607a808600f3b55228da0692397b94f1485ae3585dcc40b644411f2247a02365d3027af9104de7d0e5e99a88f6b39233a9a0241d5d7553ac43547eba5c9cbd2575800e276e51e062aed10ef8c3fa84790aff9a7dff9de4890a22162eebdb29e26c578eebab17a44f31bc4ef14cadd27b8818598c26fe2cf19549fca4ae81424820fc30743ad5b9031b45528994a0474b15db293a8d4d223062af607938948dca6f2bb34845eddb65f8abdb1cb33ca8d7ddd10cfebc0ff13e6c00889abd3ebd5df948442a247fc70623a89906a6fbd9e2b24fcc845db65576a40e08e924ff8ef469a9e5850c81165e52c3444694fed83c89ed4db92990d565587a283dba5df7465249bd3136e3b11440a04443151fcb13bec00e5d8bd9a60f9f64eae9040e81d180a3cb898fac93e3643361611eb8c4a91813bc9caafc11d22bdd74e6ee48229b5b1507b45248acaf0f9628f5597299a7f7221cbb9c8ec706e61290873038a74f1a38de348c6cf84366b9597668df794adf83dcaa184f8e090f8e4673a99099e47dd15ab93660fb658a5f4d95539476bc79c36a4049a74466a79a5edede048a2ca133410c3cb908778b1659a10ff6941150b8a3c8e3ec6b12d9d5e39a50e735d92940d6529797bfa42ebe409c1809fc656b420db997bce4b698ee69b3b80d7249c8f4ba9b665eb91c7946f4b3c3e91141fa40fd1beae91bce2249e4643bc5830f1b825382b4b4341f0b3cc4a476dbb2ac30a049ca03a7fc6ef65b625ec1a22b044c94af2c68aa59fdccc9a80b7c2f49ac38a0351d90b7623173a2ff8a08fed6760b596512bb2b12e037b33bfb0b75c0e100a9a2cc4353f09dcd40193f2263f936b04cb356cbd7e95ff2609b14a0f66bc1a29ef6b583dd57df5e0216adfa4943c2cc7067acfefe6bda00191afc636dd2f5e8011bfbf73bc1406ab73c47c4ff326224b707e535226cc860cfcb1fc71a62bc7d2acd290cd8455c0f33e57130902e05efaae4d50fe6650032f9ed105c735d6a984a7b1b12a6ed9add303badcf9591fabcaefa7b6884b5a5e787e013179d0696e8828ea6fec3851d54b6e97cd36f43c9240fe28af8e3a70048858cf4b528009d651e9e6e943b485983b5d7e1c5454633503e60dd2f9c5e66363861bfd877f6a7d9148b3cbae7317f3f331e09cde41062ea618896ba3a20971632e7c7b14d087c21d356037be65613e9c47289458306fa622902958858108606095b4d05a9eca80c5593fe9c86970a192e4f8641520fe01e3cd8b4df454cb31aad9ae71bbc73b284d626cb6120e07b345afe7037f81c088742e5a9d52090451d12e8681f8e98d89e140fd296fb2ef520cb4cd2ef040afe65406aa7c36e88fb84e67bac9bd63e911658a8e8f916421384af267038fb511bbd7e7fc761c1d7f41ffedb41250b670de874d9392549cf42f0f5a4fc17f6226bbd4969bedddb608845a1b246dd57b3667de8007de34d5128ee31f7dafe6ff931189654f341ce71745d84f4642b31a11c18e953b1a85df4a06c7e8367f1b5bf78ecdfb8ba3f6015df2faf6bd4cdc013e3e0c0a6ac300d8e412f89c5950dc27bbaac0176e99f3dccea87f822deaa11052d82a9633642479cf302396db4202c6d36683dfad00b83a9177a033d95e427b2f14cee2b9edf47dea975c0a990fa256731d832963c69522914b4008807bfd3183e3c7a4be553662f1a946f3a4c73d2be5ab98a48723a60d33a08c33d199e483d18b9dd75ec73150f9615797c559e92a2bfaab978218263795eed94e4f74d87780ced48855c931597e26e3ed5cb6b71b74817a02d19c6a6f973ff80bb3cd16b3d49c0f2b9348eecf94a5a14c22ac7e99797fd7f61fde5bec15931a037f7ba2e88bfe7f80ea3d9348cbcf8020aca6cb1cdad7d0ad44996129e4b31632165131f9d5fce0744617f8bdda07a60033ef3596cff377804ef2702850f89613590a74ff50b849d6f44f25437cdef445e7460a861efca881119473b549aac7e81c6f5cd40994540038388f1c370c07d20276f6140e09b0b14cedd0efa57981345272468b4780424fe5f48afae931c26d530f08481487b4b204fc75f0d99ffcca22a13940e6e27bd035e7484e77f5a4d5400c585dcdfe02fa0f9b6eba8999d02c1b7ac35b106c9e5e102c36437a59f1795a0e38eb6ce9a58ea1be87cfded776c5b33326df2c48a60d4cb4d130302973a4858f9563770da7fd6fe454a2269cb94e2a3d4bc5fd00701aa774658f3b5fa08c1a2c647814f8982133a7252037ee00dd3dcd78b76e88b44982c7dd83daa972d89a1f9a3e9f774dd3496c6652228f8a837a4fbf624b1920cf0052f779021b2cb838df3aa6ed80b6e263f26ef879c22b0f8f208c72bfa1f359b20706b4c2580108ca51f015a058f4ead181fa674882e68e47724e1ffe4afa2231eac7dbd986569649e7a3a185c5ff574142d1786f4408b2190859ac0aa3743ce383fed174e83b8a86b0cc41d35ee9f8edb73e1cb432521de160552bffff93fa8a66adefc134ce6e3d366ef21364f747cd5d83795e04462da23085091aa5d8333235cdd45cc59ce80ffbc244524a7cd0d94847d6f9451eeab5ce8c72bf9c417ad05e711c8947fac1f3605bd5f9470ef81a89da12891dea1ebabc5357b4d344639076879a22e0963a60809bb54b7fc26fe9b46ea0f16e8d4d1dadccd7219ccc93812f305b13fce427cccaf562c123fe22e7605b54cd019ce01b14a5012cc6c9a4ea988daad7c00b2ca26f8fefff2b50d7445920b26c6df4b9345797b81ab665590fc7c6d0dad8923443b75a703c78638e35d51742022247f57b944ecbf7c866b5a0d251e4eaa778223f713f0ef836a78ae761909cb60956d2d8971cdc3b60f7814bd06f1535979116a057ac7dde0334397b9038d2998a99e34eb1c2304c5ebccd0e8906bd9a7dafaf8f7d9a3437b5d5f8beb46bc6e2a9cff34fc5efd4b8ecb66ed9c64f055235e7b47ce4352e85e72ed49836d6a52d627df138809a86833e1ae6797105bc52a6d723071116b919c7090f48c59a92ced644c25bc819c5b8a4cfa39114cdd3de0f1eccf01a5dbf69330c9dd044221c887e902078a5a1146083b8c2f03ea6d5eb15a0dc7761292dca359c9049ed2dcff548df2aa7c6f771e57541d91bc4a80ce2d71d9398b9e470d729e33f3498a878fa40f839398506cd81146964462d3b0efedafc93f590e95cd8b18357231642706b8df3b658588d708d9269e7b7547cc18a006ec8c91a5086ac656f50fcb0958dfd40318c5e1db5d1c95e305f0009b8653b33b3c051649e88324a4c48398f0225e3aef9f80202a1a79e4f409a36e367bc4ebc022ca4297f6362c7ef582d9030d2e45e04503fe05d446db8c6f7b8a08e11446b2f0538ebf964a17fcd1f2ebb6299f38832c18f23c83c6b4d656b2738ec8102d1e796867d4ca017637fe592def05c3dbb9589840bcb3bfa01522c1543a4b0aad66b71fb4747f21e7f4e90fce51c73efc8a2ec6fcc32d60c3460238a58c4365db4a80f35dbc212ef327a3ed2ef9afd902d0c052e33398c66569e6f083b61a118bde879858869cbc0455dbcd19ffc6b01bd53264dd8ed6d74ae4e09256df99e9a8e2bc7a23f3735b7f3bdfad5eb80b1e2ff7c6137d97d0e45b9e8eda2cbbfd72007c00c2d840736553330570f3d5a7ee20ad96af3a7282c1933f52c79f670ad651b0dbd60c4111f043ecce737ee04e82d193fcca3c766af1007ef0c84dbe0eab00f3501e6f504d690f70091b1a1019d457973de21b4002578b5296f5b12514d2ab21ee17d1c4e324c53007117ae6ea27ba9e7d3be7a45409195cfe02daaedfc17c69f0414417ef725e48196525c8ed043d1086fc2e93fd07e5ea554b788ea659982890add030562f454c7524a94c82abd78a6108ab64a4a5a066f3d9a71e809a1bb532929088fe7c72baafda86080d64e12dc2bd53cdc3d038f1a1ea17526dfd042271a48f22aa2422b53e7a72380a1b12ae821d6b178cfe61399debe916035c0fe545a0f84cd964550225013cfb243b77f882caf80110615c378d9e825f4ede15b0a30516c0aca5526a84d4d1351528ad92b03b5483288151553ca3c466151595c18302d155237482d2cf191c65b13a81f127f34c5bc773caecadc1598adecaa6a3228f0df880058f7e52ffa5fbd2640b03d48205f33e264bc1550ed673a44fa56fd73f84655ff05115f332514a1a318596322796ab88a44409359e55013fc97ee673921c7530ea8f7d3fbe7044d8198771cccb7efbfd0c72103aa09241d14051af0abff7a71a477b08b8ae601f2a07a53ce48c272638f0b936fb56399e56045ee2e63e35be5de48a4fa511532d5fd3a619159b0cd53a96b8968e9ea48c326b114d6de04fe5dd9b729d20495e38f5df5889e7b79adb4375d9c81f62b28c89f375bb5f950e597dc24ed0fbd5576da0b2b0af5ecd9fe64768eebce8453d9c14a824a252cf8a5a5d5005d6c7afbe8eadd68dc4164a9720d9d4091b2aeb8b3f858ab6895013beb1c586358f98f29635b0337622b92a38fd852e739930fcab4d364d593a7180d4b6df89b57e266e90a0cc03ff9590f5970b1de1837091dcf8b9d2b055710437587ab10542014fa596f61111a27a2c50dd6290c6699d003733fdc2887099d0da46abe11f878b728977cdb324a6ee19b1b2dc4c80cb4938387cad190b380722115bb7d3dc3bd76679c5964347e9dd3c7d7fed2c85a518d65916bb6b0e525657ead688e72182400342a385a13f0b3a4d644767121fff9dbf41c48c40785c3b7bc81d9e4efb44aed403dc8b2ec563b72f691f99f6b380e51535088a61df09165bfb469b044e826f6b4c8d5c54e1b85c0db91100105c0f496a4527707e9267c20b732a012f2d9abcdd3af8fe656b4aeee19a739329ce40bbba3ae7076979f77f0c9c5928e281d89673fbfcd343023277735db81d099225b0dae6092169e8203d119fd17e2931a04a17ae27d28cde09b20c066c9b5c6f83df57bdd9ee7a9cbca0465a77b04776180f5e9fc360ef69b56f76582b700bd739883665ee99f86ed58094c1f0a6e3d00a4d25eabb978e3992dc6fa41ad3c195da0ce12624200834c7f53cb50a4469fea3688f552f6a9f4b8c1af53875d9a2a5d2af75c765246e8095e31b2d41ad1ac180b947360daf5ec81db801597229e3ad91da0c3f14879e09dd6e3d372d41c8697fd7b7290155d6e0251c14959f2b98383ca12aa266a60f70eff82660173dd9772ff11973d0d7a7158f20d3967d01fc1bd678efaf43c550ff0c6366a0e533b551bdde74bbd140bb39a3f5f4b8033e59a408cc9a2f3b380daba901e3299751001cb8cac43db52999f45c3bbdba8c38d14b17807163f32c1570cd51d29401e420fcb1051bad759ab610ac1a8920f5e6544fbbef62205939ac341c199d1e140d1944068cb61991767e62e1aa5247912804b4e28c8c30cf48dd66f3132c244fd4365d6121b0f28c981d32f2a554cfbd532919fbe67449cdfde4d428992d4466c6ba7954a93c45493bdcddb24bdfefb0272430cbabc53bba625fa07d21ff5c4e9cc2a4c9d0727a6b07e633cd4b11eea0194a767d43cb8b643db08e3ed90c6b25a7c8bac7bee88a37b1dd52af1b248232259016be90871c0605b2127c8d7dc8f4f6ed956140706c199784c320b4d3637084e59fc414357e024267fe733a447692b352615faf65074c193780cc126967432c27c6f8715986cfe674c9eca333b568b5b926d5ab134c9616235de6c387272195fb54e580d5ff309c52f93202cbe3aa07cc11fa5aef72938bd9eb552a83357e987b599f8116f64d03d50f6b33e445f813d2ebe5d591b18bbadae77668f5a977157fb3eaa5b21c664b5cfe5e49473798da578c467e6cded2919f3e5da90cea56033d6d91a8faf6630037b11290b776aa7beb29af809cc4f1825a5889530504f993962184865b575c70df8b2636f1f9d3d094835347fa5f17ec7786183d1aba00753b4f072db8340b5ef36d855122933d3a8e3d3dfb800d8f91b199bd6ed8d9163d691edaf4a17f0f2601eb184eb479ac01014adc345d7fbea0a657e1398827b4122777f28e2f9a54c5f84016e0aa95e20a34cf1352a1594b6939d9b2a602b17b7de06c3dbd90f9225fa6d95afd96e81359d82a8165a14a249d613db3c4967308102247bf83500e3300161f89c6d7ac57b2452041072729ec18e1f806ec41d83cc81afc19384f5b4381a16215465b7abd4a3ef8b4d115e39f3d26cabbd7f15b9ea05ebb54af31a7a376ff329f3d156ff9cbf4e2af1e5abba42682fd462f8e750987b7a75f9c3323b7a152a50ed42cc5bc48709fdf67ad275baceec9c7f048d63912ada03fec417bd4982e5c3faebf8a83ef2c1b6eb31b7d0769a0fc8abdca22bafea79a03487cfa79e607a091a5ea97f268961ef4020dfa017c20af72007f06885a9cd66ae767c52dece8e950a817b3377997bd6c998e7495a1d904550951dfa3828fb52326a027704d4f217c4f8748c9e00bbd5f7e05e3f7b043e6a5930353b06c38c61fec0f362d58206507a95c71e94dade49b070cd5785f897cac428f7b930548a94cb642269a2bf5659122d4fcb5187be4ae4a76881c4560ed17bf9def4c0e3ecd687cdc39e29846014738498325f1557d387da495afb207fb17658d0b065e927ad6486f9821b678567506994f79ecf61135a0cedea7ea58e425fd7f03181dbfd3b3bc7b155986a1835bd5ee35744ce54e229c8b3031c7d02ae325b5ae8db6b6d26409fa4e1912511486edad51ea50da4da20bc19647424bd64705b7e286053837021830d61232afc430b31ec8c83d7c5a23a1967200458469ce16ebc6610618659224c7151cd964c5b11d6cf616179801f9d15ab345cf29d6b9176f8aa45ff699f4dc81fb9558cb8a23118c52f0d11aae2bff14401e63e43659fc4ec1ff671e7662084ca4c1bccda3e4d08842f0b964f5217a496deaf9bf35ce627fd766f313975312c5e6081f3788313e9901d5e41fa3366a8349e4801c0947d3be234221c24bd8d6c781298cbb5eaa3828643008dc37fb1fc231f183b407dc63d3c07e7e85e8edbca6777dadda7d3c8fa43edf27054cd58a3f381c878097a48112719ba817b1a28a9e90556d1a8e6cc8efa4d2b21084c3fcb4150e52cbff50c27ee59dc8c1520a72e4d4b7128f338a39d12c16bfba6fd35d879221d9608e89c18ef9bda8de629277eddca4fa9a9cee10d1b42f3a1a0a6647b301e2a9282142133d83ea69bd2318f9a67d52d560279e2ff2974b794b3b890483e6896ed659695c9cb0bae107dad028a1ba6ba941fb393fe221a392cd09508b98b98d987375e028a63cc5630ca673a99058abaf4a819b58a6f2a4d8f0e20b0adbc3d618e51def9458457fe2ce28f3cb7c0ad6f978e4e473a6439575b5c9e1f4a7f084ce9cd1ac4f74388b4f9724d1620805066cc490e181222c033a55ce3faee1c2efdcfb98a7dc288e59ee49987dda166f971d8bfb66abbc1fd4751b9cbf76ce50ec3ae10e21a00c666a975267971512ecbb8e362f71d8fb117d6e2a6e2444197d241600be88e0d9c91feac22c15b56865bcdb9630d83a5ccc042ed5a7d5e851ff0e263d2a965149bae3b017abab98e07755c8cc838a3cabdedf2d22128c3678d2d7976f96cc864aa9ebc239ac7dc76484d884da5ece0448a0485f91c8cc6920625c7707a38541b6f63e02a19337e1465f100aa970d28d963a85836571ba6ccef8edff77bde5c1704c7e774d9f338fce692cf4440868c98b0ae1b99ce859a1870870c64231032995b1f2cd6d6c97b24aea319fff4a28658eccd117c542c336c09a6f8c03a6061884de58f277a4e64a6cd2a603c389f4895f2becfbd2edfc66eecfda1acb6ab02fbdefcee5d8c895f2d8294e998e35680ffb9af45b96095ea39074beebfe833eb0b962f29e1541a9a3266c378876d4d40683df18b634907ca5427fbc79ac3d635193ee226ed2996f7bc07328ccbf77c8e4a8d3bf7b989909a8d5b30312089a61ace57ed2e129493a169dc7312ee8dfcc82b7085b89f1457b63366ade4bcc823ff71bb8bd7286df159c5d5e031cae1853161069013fe5dfb47161de956029bc6f01d429ca1118e223f1827b348067ae2f3b8180ab38e05f3fc19a1280e638a8c32239d5a4bdf1af3767f2c272b97fd496dfe83563a1447654758ec821ace2d81e4bd557c65f318ba72132747c8b84ac9e52a0af1e98042a9346527db59448ed7e33b9538dac2f9ca3954e332f58644e3b1d73b26b29801149d5b53d9581054e6e6470defd7ab3c3df217899405fca775ffcb30576208ecc575796499e49684707d36bfa5ac0ae635257e91940f81fbe279ffd914a39c0cc14fc563d73399ecad593429290440dc5de1153dfb1edf93a17d777f5680b05c6b202a93f1a3cb92d947798e7262deb16930f0f6a9842945b051d247eb424335132b3ed3275f466c45f5503be824ecdd46b29c941a62b32c7d9ec68464a55d013deb23ee184dbce21665f9ae0924e2506702ec486091a3f05fdddfca2527580fbd9127d3438f15de7493cfd11f7c1547403c0189b956f7139ae7d8b4d92725f36bf94e286287a95ead10b1ac37e20b46253c8bd1f5ad13aeff8089e9c3e567c042400cb0467986c1b57e843585dfeecb310fcad7bb5326fae72d3ec4b3ca411e1e3f86fdaef3b144abb941d7775485537619052f1e42c846c76dbfae5aaecf7bb161e0cc09a70d40d64cc317ea4cb777a6e20e0d263caebbac1d394c35f53ac1c5b3e5d32cc2011fed5a61e5a1e1412e0dcea7f6dcaf5fb88f383f452ccd5b2a22d974dc5483d5e54db9ba608ab8e1ae74b82849e45979d96ecd28fae736c7636a8146710a251dc3c83dd4dac69444d07ab99591d0efa672204ef3872cbf62e4e9f77f0da396395ec6f895bcf5b1017c37de78c2a4b4897559527fd55067723cd2b5aabf74bd565306afa9f110d503873e5e046145f3150d7c30b523217a22c0b412c3d68825f8ee978bf3f29ad1036aa82f1a8eca408715ed9d137e9813fa13ead339e00857c1afd01220421fce5ddf06f7b14c17ef45706b4054dde422fd17afa3073ef8d1a285d527b6b338675860ea850ca774e5f2c570d6538bc17d8b0b7029fa2a498403901f0bd306be6a479126f38fc99b10da86604991fc749b71afaf430c9c59a6252c74b1256f773b0bde16afdc7ce81e923792d38da351467b6b656f782786d3d4e77a2248617190187e7a8a6ac28b52537425159999515f8ab5dbad74f28bad098a13a79c582f930be847a51b3b48e0956f56cdc0ecba3106240e10db4a3eff0e67b522cfa0ecc3947cbfb3d3e144a2816c21f909f8c1ff1183c3d5f571c9fd56c8a2df8eb11c968783eff0bb49818e507297b0ee85e9fbd473eed33c554940b1b6ff183c39b264aca4f0583ede96ec0e7de3040c3784a75a888d1d0e105663653dfd56a355852291914feb5547e730d68a4705c3a9409de337f5a8e13fd0cd2e2d7a28ec3706df0b3b6257dc466161bd841a197adc3b8e82ed558e79356d358910cf5e6b5f3417cab73882de3ac00096381b5b317f328194d19cd3e90b4746b4fd582c4deadcd3aa33abdb4335f74125af15ce3441b8fc7ddcc2766b2a795ee26ef46e9f299ef15377cd986f60c961f85d67820f46a91a6481cb78112d096294aae5049b71765ea6e479d2230044c013de2577a48c3827713c40c5ceda0e4b30e8c84fe16ccfc787605fd614b621c72e836b9d2d29a8b4a66bbaf2e60955bc0fd95b5df091188c228e457cb6e94db78702c098dec7b0c6a4c09a7e0234a9d2c30cbb691eb5a44629a58525ed1846e7256585791403e1ab149f1f15e0c0c8773ce0d1c6149b5d7bb5ccc118cd6856dd430971124aa1722e1250c7555476d3414fca0263f91657707c3b19dc2dedd226ac8c2b54eda37fafd87caa0c3bb0bead87cc90061b4a936425d7ba2f15021f942769837737ce4359b4519404f7d0e0761d402eb12c39644715cd10a96d653f63bb21f3cee860dc19dc61c652253bfb6096202a67fd42e4c52c10e79f33b79f1545fbccbc0c3c6de0f15469fbf4be0bbbb948e6d0d850576d8b13e9fa15ff95deabe3404ebf38fb08847a1ebad72906e799a98c599c1a4050d354ba37a0f29a048dc28171e60fccabee74be016296ba1ea3eeccaaf365d753291259cd9dc4095f3a6aa9c8e66ba408b5c4f5fe1bc45b678b491477d969c307cf48359d8c1b6ba6a8420a0d9c0d037a9306f3fae5a5edbc35229f077847e93f957f4535ff1ee34093cf0627f848a9611466854af517df8cf0850cada25bde3d2205773fa4b7b04271c0b8251ac796af481fba54af92280176a07748001c7d2743e84bd62210560a03ed165ba94a539563b56d2de1188606f5b6c8211c81a61f11915502a8c6344d1c5118f5121195dcf0be074a7493ae7c4bee437527ab7bcd178c9cb0f88ec8c23c7e3e9e513303f360ad777b8507ab08934b43ed648845bc591c892229651bcd3fef57608efaa5903e975fc58a189abbc52b2904fa831ac8679308d1a0c03bdc9c4b8938a39122201840141a18b344310949fe9fa90e0e67bcdf71ba8dfefbd7de588ea9f568f04f7694febf13204bf03f6b020bfe6f3d4b5d5f1fea010802083f5dc563ed26457749d7a2247bd723e470d21bef504f29a69f377b7de6b844e5cbaf14cc6f7f7bfc288353294218c974d278e4abf1155ce62b046d9660f6144f1bd7d12c05cd2b307f9be8b92ef15a1c71f4435d1892a5c7234d95b16db04dc0625059ff393bde2c6170d989c3d91f9de034c095cf2db401e4781d379b15f7e8f13f7ebd9110f206e686aa45148c30f70376427661d86b028","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
