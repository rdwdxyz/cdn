<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06a91dd231ed869dca65e261ac4309498ae9ceef489604a91b8e894ca8d941fad5e1fbfefe5b13836ba7111e0e819fc7e3cd2ab3c1145ea09e6c3464043ffdead1dc8077016a76e52ed2a938713cbfea4bf9a11f350a03d51b78d308aac60f3060829b01f501dbb0b818fce4860101ab88f23a93d77d7e14c1d28be7ade10c9931193f936d8527d5b74391c776ddb6e323d6ff129b340a0bc4785435939e45d36e76776ac3bc93438299f3f225a4e59cf0f57e5695ea25c8c84c46d703b7ae1f7e28212b54fa82c8858572a9ec29929fb224bc2b52fa8642c2392cf7a081a29820593d5bd82b9407aa5c12c036f33027164af36ce69ca425b8411b30745ead04f60e6789c6b1446da1121df7aab34a5c17b3f63680647caf567350346a275bcbd23b4d4bf1664482907385812c720ef6eb6fd4499d1761441b1d741f3c369b5e2d272fcad724d0efc364dc637d2b6c4c1c73f625167ffdee471f345ff9d0cf30494281b9cac0b1106e58b00af54a84a517732d058cc034f92ebe787da8f7f4f3269fc3a85e5c6b37cdcaf9bff543cd82d9430e1a0ec9d9882bdfb1efa228f31abbb02b99d5427395d77255729ff3ac715947c1c61c7ef428dbf38e9a25e8c61f622a6a6815c7e89066d5cd12e864726f08376edabd15c2dcf180e9ae31bc38cb7abc5fab61c711373fe791136052b64a8ca543929fd72d67c4e8688f6903fb6583aa9b8578711f7eaab253f83b51adea7ef7609abc50eefdafe46069319e0dc104a22675be1f8a368b39c3cf2415119c852563f20fec353d1fc000a7655cf660befdc3d3fe531470533916d05b32d7ac2d73befbf65f614ba57d37102c2f48467a88dd1aa09c396bb159710b389349ea9ecdfb715caaa8dff26711c7d4052224fc5554df27a693912c381088d95651d869144fac6242022f57eb04cf9b5bf6ad09660039eefedfe5ccccfd9f5fd66b2d2fbcdd33e3ac1b72ca7cb3d0414616e427ef67c77b24e65c380585e30ffabeae4adc3af365209163f0a918fe345e48eac68beec1a5f4702a16e028668440ca815e839538f0ed4c8a4a3507b302d5da7b869762490e52c916952fa5892306ee2e623db4716340e10f6ce9937a2157ca32a0c8846f32620793d5ba335b084165a5ce54df4fecaf42dc0ee7936002070cd6558330f3ce0a041cb0d8fddc37eb4153edd21807f0cce95649a9c025927293a6872e792aa837e0587169ce5d52196d3a1452455ef4ed6deafd10c6e3fdda90de1835aa86b4a8edbd0ed7ad86cf3e4b290df5a77d098dc4e5386e40493e7ca1401dec049a994d99393448c5463f9fa3ac3efbc28c60f6cf30c3eb14fb5e2978b4fa611ac3db8d7ad2ee2052d6c35aa7e5c66615c465e0aa02373354cca514b84d5727f71be12587ace58a195793880cf1f8a1a4bdb31e1203ec7650eca7369d21a59f539afe57ffd495540828201a010604a58a13f2b2e5eb44310cc1c165c694b275a45d0a8950f70ce64647827052604a26306b65d7e7d6537a4a9c84aeff9b7d13c01bea12d23ed6d75ff7a38816aa626befb7dcafb3c8e2dad3722c7a4563e91f7f1995a9157fe09dd47ea4cb896aea9dedfd9693acc328fd58321a0daacf48ad2d8ec03b65f4c97a484bbae6a5563e8b3e250d87fe92211f6a5a9530bd209c866f3cd80983048991316fc966caeab59ce710b01d7650fb355ca098b87b750da7279439dd031ac67680a3245f0ae03435d71dcf7009855eb4a9c6a6b1ebe7bff8642cb495f7c9a0d59dc09fbaebdad9db59366c7ade14a27c970e43237c1d1a36b164ab825fa8bc19f199522040084fb439b8537fd0f129997005c1ec5e9313ecc89b36ea08239d83f82107c541c097ce7c3098cb793145d0299ceebe17ce72e28178792fd4900fefd832d382ea437d9dd611fd9ee009d057579a46ddcc5672e8933427ab191faf000a73b0482ec147d4f3454a6e51eaf1b0e0bbd517f263f030f693904dc8508b71ffce705701dbd65ba2dde91871ff9cf541b2f739db8412763bdbaf8d190a723f29e1cf0474ccb8ce85b0330f033d39382ebee9fb8aba6dfdac4a5ff8bafbfd1d66759ea4bce60c45b014c9296eec57c3eef56f057d000adb1522deaa3f673f78fc745b3e6714c08bba2ea2d8a8774be019f7bc1be25b928ef530fb8e439de5735c7896920f8cc464a215ccecf2054092c7c3ebf46b7268523108bec6c36f48defd2660ccd6be36a36c9378d6ed987bc55593ba04a28419dee5bc6ec57dbe70399afc13ea4c6ade29fefb026a944ba2c680d4e8d988fbe98e14fcefcf8f32c359fce73b8f073f23dd8cf9c658c4138e9bc8741a3ff00324e9e285c94461134daca445db4e89d42178b45702a76dc1f1e366efc7ccf1daf4315dc3f2b74ab7f211b3fe932a994ebc382df34638c05465a42eb48f52a3fafb5576d410e4163ce0d463e67c07ece904466f449427399edf5ea0e6361e86681d211d39508a47de73de8e608a260e462e552cf4dc0ab53420687ad227de11cd71595fad0febf6aa30ea42b5ee75ac200a94699aaa079dfcac5d9dc778d1eb922e1b1e3aaa5c5df86d6addce8833b571a76ddb885898d737f665461eafe6f8e2a05e840c13386093a486b9bc6ba5c9ff4efc568a2a867b7bbfd65203942a1e89a373ef4db4e7e7cd98e0b985947c75e95b8cdd2322262972f9ded52c6259f217e305a29daa80f7d0d2a44083ea7aeecaeb2515890095ec2dea249af4338819402579f35e11e576db5103f32c883e14c4a398b24683e9266289d2429c5b9f3fa116ceb7474429c0335b5091ec5e5d62673e05aba6ed89c8dc856996bb1abaf76ae6737ba5d61a203cce6a0439094b20b5a420a6be560a0115c7df7e2e757669e081ac63169ad0d5c7d05e6604db7309feb389ef2a06ba04050520a1117c62514dbde776a7349686a99bb66a721217254b39c644732497996fc046b88533a34394c10aed89d28c5eeb063f11b640fa27b05eebbf7dd83390e134623818161668f6f1f81378b9c361382b48905e4002cc5f4222ca45b17a044bee8289108235f83935fb09a24124af6a3ee26846a02564306fe14fcfc8fb837a8b0b1b2036519e247866563c7df23a062d87db977d89d45a620fa07da00aa9835fd56a4d652f1d1dbd0d7d63a8e6619e7e13dd41236bdd2f64f54553803ee6036039a57ce7696fad34d62d1f7b77a3682332f7ee71df4e16eeea70e55f8d213a16be72cab33b21138b6333f8f352c59b552de8092c2c44614fe4f2f11ff9d23da607de9094ada044baa5e6fb6a9373b72808bffebdc97750431602a8ed23061e8ddf0bbba4b721a0e6726d5c4c3ee07663affcb781ff0e06c15d361719d0f61a2a4e517cf18154e380c4f9fb966ec7fac293ea7c0450c19350595ba44e0e50c3cf4071df6dbc1506e9e57d07f52fcd68e5dc264fb22eb8f502e63da4e400d9835ab868e4df96372f04de2ac76d2290385dffe18ba2dcba2e31c78b8e2731dc0dafa9fe52d8f2eaeb724789c2c7ac8d5b1801ed04ae399f669ebd7e01d434261a085c301876538763316418150e81919a1a6f8ebe356936159c63ec81b388067f0ed885a63bc08ff3f4ecaa6b7e233fda60aafa78ba5befd58bb70064edef3190eab845dc04353992a1a572d7277ac0578dcc83c6debcc5b8d23057dda9d43049f5b84bafdb180c21ae9dd5c11ff4ed3a9e6dedcf2ffe8c28c5f798610ffc837c8ee512f687685b38a7d538ba59630e0e7462aee2edd3d08fe1208c3d2aefb67f645dcbea0a713f3d5aa1cd091c7b2b1698410ea50801cf065b5a8600b12b2c97c479528c7207c2cccaa800098900c902af85c711c242e9819465d15a4966c9d4c15560f9015b3b4624d10c4fe9d702a4fbf0bbfa3c9689308c4ebc8df6454dd595011cbaf5eace09226ed3fe4e62a9c587432a7c9876bad9c9559e39533c638ab381f3fd742bb1bc23d10bfb6dd85022425cdd5ccf2933e823cef80c04b1e77fa41c0e68d233a78321471e85a15bdcbd97849a56102595442c03ee506e282652d5261381579ed971f9eeff821d866f4da8bdd9597957e5b6b0fdc1b1d3ab1d21dff8f9c10524e212dbdbebc3346e85203cbd394c38f14bb280f795d8561402c7a544ea070faea5808fc70af958b019cf1e61464057c0789923b398850f7d1b87f224363c8c2f346d1a258b05a5465676a118621b650e641e611764a94545d2daf3153e2250ab95e8c8669c1d762b7d7d664c5797a31ae627a8a557772ae4cb2d3880bed9fb2999b208bfe2af8c80c23d89f61ac77da546b155afb5efc52d1986e828ccf897b5fe72599a222745e121cfa2be25eb0d20969e23f45972695274549cf9e32611da48c443d866f12d9ef4ee5e61e75fa3a0d0c845a2a2e9a7c76cae54c1109056e93b81b9e25d9a1df807d767fe2ffeec21a33a76d2faca8c455030f36be2c6c51c33c66c14ea95b649bfbaeb4723c9be0ea61c62556185b5e9c226734e182ff30d15123a89d2de58022956ac88fc2c7d7319ba5774d5966ef3621b230e8d4acaf35fd0083da84a28dc1d685ffe6df20adf4fccb1c1417bea16f41f123fb059e9edaacf816a463666a759638b0a4935e973988eed0eb34c6f83af5bb4cf8ee885e99224b5797ac246e05355cb068ce345ad69b8a9be84d41bf5dbfee41cfda4b0b299557c1a952b379aa33aa42459953b5d954d9017bef9cf104aac9b803740ef4522114bdb32724370c8574be1a933fabcd0dc1cdc9a1de05cd801e6766c468193a5e8f70cd485c7795d459672aabc222828600f22749fb1f3c444cd9900b17343468d475a5fed0e2f6d27d3b256777b6677c6c95e0349df6de1dbff9573b586f1542ccc501ffd838acdcff53a7ac71502b51e72f6b880bdda6f3a6ce37f7b914d63055f139c1853155b464fb97e8a321abaad9c1475664f1c8124109f19e4c36732300e2ff07995b6eae882bacb960ee3bbffe3bee0d8403ad73ae1c2d7f800e07cbdedddaa52613e6488fa6ed1015dd2db5371f8e82645c9289aa6d8eca3a151da0384119c206bb04c7d838a9b1b02c3b662efbc3c897cc633e02542473f22fc64cf8e7579758f612bc01b7748e4db1cae9513d5f990e35c38f904fc2a15dc8a1abe7e631fb33b0ab0e7ad6178b460dd14669c1e07ec3c56f68fcf213258083ea280e3fef033f2e5cb37bb525562dadad2dc86fd22d98b3fe89a4922ccf885fc8fe50e62f716c80154d4e47a872c9e365ac94323f95533e89c5009ad8b98ef9a0f03beba1df763a2262346dee89a35f397f4072e69e26ba19ebf75cff79f3d86e1398b39cb85ce20f16d7038c2b54e8af5cb564e1e906720a6c4f834438ff9e447d403de1057fed640a1573fe45561e5906cb05491dcdc8e3a20e3755b6b0b6c7d5aee47b68e7db801d5a4e507bcad0a4f29bd32d02c22e6c37805f5fe9d86a0f59cdf638c509a3753adabff92c5c3c69cb67c5ac41ce7486fa1ccd1887d976f06d8c0eca468a1d1682f2fa6733ecb4afaa55e39df280f984f2ddee528b588007cd79b42d1142a9e9f868cd52c6ff5b8c5923926326cc3018ed95a1830ba6765baaea72410ad8489bc7caab6bcd5b6e958ee4e595e89901d01f399ed17e3602a7887f783061e593af76696ea508afcb4105cc146f54387468d5eb987a23542d5ad0c70d4c9266da0f38cd61e19bbdeb922e4e702ad93e5005a471b6900bf92a9ceccafb555779e7af56138e14df75ded74fb09a3d52776391a5b7cc2703082ddf8dd2f2fcdfcf69ec8941901e818d055941307aadaf3b5a855e634d356a298671204c1e9e11f7fd7516421f19ccf3816316f2980c3cc3c2cf3c1e24f9596e7fbfae5cf437da43a3f91ae590583483357d4e04f710da068558576e5125a16dafc675aaeeab64245eb046153e320cb5ac08bec943144d75c42f6bdfd7debbf10d7b6509e4fcb4636c9f0f21624a6c44a618fdb0ded6c9783aa4553382f3de513af58e093a3300e895f4e7dc4e8dd6cee14ae530dda562c9a3001c40fb2a62e72ee025d2f97103b0b9df3a9804072b6af9f2bba9a438a5029c917c9f0b835300acfaf1677b5782800787feca8d4b196bdc5363aa9065ffd2832c2117693a30a8d6c6c760c585f7059d5c672348c2129efb184be852e2846514e062ef5d75a493b696e691a83a942294a6e5e7460f9290c68a33789fdb617d1daae2c8c0b67c5fc39f5f1bd438eaf0f5967beac4d5bd884c7b2529dabc14e4b7bc085393c1c078fc0db10b9bf01dc6b1409991267c71855eb172f363f6cfc710e98d82aa02646ba4b0d7709c05037d1937ad071ae1c52b857237459fd167211d42be40bb36a9144fcf38ecd050d5cb93863bc942061f74d5051d25b4c14cc0bd834138b51125d1a2604d8bdcb68fa677d72976d71e2ac967e684ebc4aec3ecb8eb5bec7ca665d9fe11019606bd781eb117704e968e5f6b6b8bbd990735d9a1b3060104eb8e09efc83644497ed606487254fc6f8123bac3305ca8dfd3f95c1e1d64062d3159bfdb7d91071074a555b8c91e29ba6852383cc3366d77eebecc4be6ce71773beb3e736b57cd755ab8d949f1fe5cf606fa9ac4171c89ad06b6346c829ce5d55f395c0c3be955f20572f3e7828684f6dafc842768e064fc59eeeaab833c996606424229605169af2c37d85a82fd3564c76842b233ecc53cf311c3ae442952cadffd34338affd26d4b8132238aa6614d9f49e388a71e42325bc7697aac3b9baf5b905241e5654619c71a07460aa7d968f35c007e6c7d3fd54d1ed00e4dfab272ff1054e1976efe251644ab6ec0f5dfcfb6a27c3524968164ca930c74a9d4d8a82b75c72a26f465fdd7d6814ff686475ef8f59bd60179123ab7e10fd35b237ef6573bcc53cb9ae960c82e7c50432f82ad51c9478ba8f2c65c196e2b68fb106b9b90d402385e830c46d98b8964a7b42951b419c8325b83e460689c99bd169bf42cb8f7e71644f9dce68771c353c840d590305e95acbcb667017a33fd64abf425d1762e0e4946d9ac15dc6c879d22a93847067ac6ff3a2fb75603bcbdc9fb7720d32ca17ad7fcdf3bcda41c23607c58bc896fb5177b018124d2a6cd5d88b26376c99e4ecf487420f4186083fd917c4db348e8e5aa0d3b1eee2384ec4cdc03b98f84f36560daedf4a681405ea046b3c78e4faf0d79ff2bd402e0d2ff3eb3b8c32b91ef7cd8da31cb15eceb421f505e509a469fac6ebed412995c1950eaa500f10ce137fe4c42190f2882d2306ea94e6b2278ae24cb9b0d31e978968e0c144e177ce3eaee95df09b5e6fe4d20dbfb1613a3ba77ca267fcaac23c4b39c0cfb7973fc1d6532859f2036b5fa1ff8db72f9915d5d432e245578ce4908e645a65c463b02a6e9856c9c795f6ae8b7ec204f5144c2b3369af1e32c3a5933535cbd24ddd1b36adf5e180ee36b2a16e20de46f13946d7429a07362e760a1629196a96220a0038838da14e3514f399920e1b27ec665128f365a56dc15264d4c229c9f24dfeb9c4ceb3a25ed9cde438e6c4ab9b7acaf66ed197170a5587e9a29d6060587e41e91ee4efc7b03d8b824a064826bb8e99a9ce22efbc37310cd2d51055edb042ed9ec953eb0a3e95635b2464b28b8dabdaff17704d49725fd9471111c1481809cffeb3fc30f164f357f9fadcdbc9e6e752bc5463a76c68748ed636fa0596c20ce98132234a351e4684cf18b1ac07312711f4273b342388aaaa261725529a4af69201829b64c7efd6bdb5ed9e4467345adecdd448803af00406a4ad5067b262f7274b1501a4c4713fce02def5316fdf5f785150ffc6bb311899450c20ffecc9fdf3aa407337024eca73310577f46ab3a55097860bcf4ae0876925df46c6bd87b8c0d62e8a2f020b43d5d85739094d27f49c3a67e28c3c85703746c4b208daed92fea657140edb71b2f3a05cb9f1a725f59459faa966e92803cd37b286c3db33bb5e6c72752e8271d68a9752ff75c05205662c1e28f1f054c88e6ae9192a62687dd5801c32d37cd6b9b827d3a6fb0f396d6f51fdfd4898435b5abee513ed4743ed86c2e241e0ac7cca4b4196ca40ef850067849afcf7a59133ac1f51822454838de4650a3cd9f260f581c52cf0a7b20cefc5d123aaf325ec53332a9ad21e2bd0e44e817a46799b1414e4ba7b872ec87f294a4514a66db85edbcf75c0c8d1fa84a1c3bf5bc3bc12bf185e0ba739b9eadfa47410100e2c06ff1e900964d222db9b64fba12bffd6e714e5851509175ee1ef0186e837b9bc9d16b153a8923164aaea1b36418bb1c5b011dceff381031dd710a74288b8f1904b9bb6724fa2d371151bd30b5cb2d99b779702af5841fccd83588e319feec445c1511ff9d5e285a1db8d440900fdd8160ceaa0f9cc6d192149112cd1fcbe3fd233bdcf251582b31e7381af2d6ef08ea681ab7e5aa901296512cf34ff50e54760b8b5d7dd3a40cb045575de55483a3dd8745589e58251f170fb333939d8e42197e6225cac01325388f16eb01a7c065b2368267c424ef53af27540386859855d33d87489d59265898007b733fba69b6741a3422ddb3e7e58632ee10014962ec5e63ad2ffbdb59be542b2ac7d088e08b84bc914a8aea5ae0b86e467b3815145ab7ed16a1f08bef25d1af9bd2aca6415de9a9779cf9c9445d57ee0d6df62b393c5c1ecf8f7078b676b8661a478e6ed1f68c39c8696f106e54539fe2969cfee2bff61f90186133f8f7d7f5b0b36ec1d5acdaf368a394b5318de0c4e28fb0a6e0b180e4260a1d40871f901ea40748ba315e55ae9881655dfe1f1da30f47c3339b5a3305f7ed971d40a1a493c7656ffee5d8466c240f647f11eb0655ed371afb04fa5254249a6c25bcbeac21b4c7eff07da43731545498f82987acba11b801fd163d61f51f81e4a3853d3bd6c7c08afdaf77382426729e87b4697bc355c5c799c82fcd9380ffe072561b61566e2be7e2c6a8cc168759fbe57b9008acd2f192f15afaa09bc4599ea6cba1038f3bcf04d5a3adc20fe7ff4bb3b20ebf12da09363fa2e7e18c4d4e1cfa2da23d6f98f3ab94d2f2cb0acd850bf619301a2f4745e32f097c27f9d2160504ab70de5e56efb9a277df3653b89f7f295d94567c3701e2388df77ecf7d17f1aa28c606b0be83b0ebef1d8cb900c989c4aa5b951826329aa5e11b6ee8ad9c95e3f454c70a619487e5d24efbb561a70cb7ced258dc9dc20c65ca3ebbd4976c636f59df3a29619b4eac7548a5abf9d34be7c47a19bae75a8247ddfe3ee427e5023c7b581465288631bf9efcac2992415c05e4c69496870bcabaf15eef3d7e08365f11c3c710f0be591d8cf2f6bd6454da6b80d64396bf67122c6fa8ae422e7433c05c133d617a3505091deaaa52e048cd6f30e1f22d2965600ed6e11d4b50a5a58c2c22c4df72efa3fa39af037ab2031ef70691a4f13be0db65c5a60769cb52350dbfaf80ea6f18e6b89f24dc71128447be94116c9fee61d5ba5b4c31aa30a9ae04b359311539aedfd7170f7ed359b7fe420de1ad420d948acca4840ebf785574e595db46581b2ced4e7b0ee9e0fc5364e3cc1d61fd05c61411db6c5b63bbb4dc7a4d6186f20ab5ec8e8620f5a3ac1544bab4298b7a4d15f06ea5d9a5f0ab35be865028b54d18d7c7d1db80190b1ffeabb90b6dd6353d3179c49e8ab81457288b74eb287e7d852db8994283b1e4f2a22d4db515590566ac676d5aa53a24a4c58eaf91b6544b4ff234b881f0f3dbe51f46075dbb44de38af2d9d2ff53cf9ba5f87b4884c55a9cc420b980bbccf0ae3fa9450bc2d43e2c7ca9c2968efd41bd3a6f9a7995dec63c4cb559b355fa47e016d7bfc6840abae027f4c98bad535ef4bbc96853ae072f5b80252dea442439c484247125366f06999ec17432ddca60a9cd16ceff048c1a509b0250ac1a91d909ca07563b5bae0efb11c1b0c3f8233835f09d9e448e61262eb2b6cbd967e0de8037bd13ea970ee377f1eb0cf235bd72f187df6b9efc684a0395c828aa9b1e88d1e4ab5c68536e420e091e8d27563b06a3855e7aaf755d6a121a29d8deb3c326843f096b866a403cb206277fc7f47cc337468b4a184e6610e93445431d3f404b65975941689f50763a0937e65abb6bd70b0c239beae730c6901cb12373bef660e80ddb5157455d1d785618b1b4bf884676716687bd20ebbbbff45e579f92e8c27548a8ecfa427e128340f6d17c7694aa2bf380d824147613099b767d0ad572ddebb34c2ee3c4f16b121f4a506537a59b4356d84743e9d851776d015804e3478f07c2fe8a29d0d0be93ad839cfa51457050df20b702d9285f3a6e57f31901b3814f66e79f7e5411824878c7e9f148a48761fcfe8cdb420254eabcdbb15d3b3dd358f65f4e4646fd17e18f1b419683813dd5ff5fe8c863cb518a58078a2447b33aa3968acb3b29f5e435d4c827e6a8d2d0fa69c70d3b1362792726f65a22029b2d671e03d3ff79e5d39bb737bd0ab090ab06e8038c546898c1d794a94a7b9e439a59e7bb07f32aed197680a3b0513cb0b22569acf273775931a279cb269dafd8e369b0d3d121af9ef96d77dc139d52c0142094adc8ab033aaa8f6cc11e381e0320738c060b8afa41c965f4b184d3492427b92ae56eb680e0ecb7ce97bcc4f3e243ffedb86a05729e2904c77ba34aec40fd249e14ea844496e77c54d11130e1528503a27411b6fb314bf09b336eefff64b6f2a1c43748c891cd5f986eeb252252d79fc0b45fc7dc609d3202a1427537824ca47b64d9940edfa3036c8308f6df25f1feb409e1b1b4ea2c9b644a698d5843be7fbe57a9ef054fa47e7cc9a8c90229aa49583b4c00da31208d79aeceb906da893ae87a2a0392705d4bada42b8861d6eba0ab3c6a80d34e9016ca68509d6a3612aad44e003972127945f57db07f363268a1852774869f68077d6fb6956153e273596a263343100ac897ae2381c69f75027a6c568ab89e6a70b51cc53bc562b0194607752176b541a3519e65654d92e4b128ac8791fe4c1d949501722b04a426fcf9e6ca4443b8f57c802d84df9bffa64d56883363c626915a6ebc617d2d6e6b81006c6ee8602ed675bd570d7d3e99f3b477b3ffc1e22541f0a1139cbeda851ad33cbca8c263d5998d4ff8ae3117738967971d400e16ce8ada1544847d4a89006a4bc791459a8716044f3e58adcff93247ea13cb202d12adaca00c9c8c2467d6ca24792aafcf9442a33191cc054c113e40ea9eb557669bb2987959e05b15ba3398acf6268f376139b39c2fd8841722eec3e3db0536c9a6f4176756f4c86e3459af8d857eac77e7e0ca19917458ba96d8f15f06a54e89fd3b23c255b0d3fcd240ae0c723764994f8d18eab82a48383672c0f864791e400bf0e5909ebe783ac1d2638fe484c7adb20bdbc2ce2b11f0c8997c7ce95d95eaecf3651a70eb3cffdadebac027babf4ae7d0989a8c76115ff998141edcc563c6d6af7d6263ba12d96b2ac7f392516b4e6671c810ebfc704c21c67cc1c35a1088f9bf01cb07c4255d609a59f77691e237c3f4793d467b4523bff2d35e82cd17133d2194b253cc1d5a054300507b66f4e6c785ce94fa786a1eb4ef7a009c0615608e9ca9cdfb8fecc7e6953b5b5de738e61547968cbe9dd0888f2dcefba66abcecc1d11677cf53a12acd3f647ad10fdfdfd4eba37b84347f4fc7d5fc2b916fe8b854b303d8d6c07731230c4754a1d3982e245386a2841a4d1a7714fdd260cc39a93cd1321d5202e64c9e1d3de8c7e22c893cbeee9cab98089ead15f4a6421ea9cb7d84cc0d40663f459a7ca74c583ce7430fe8f24c4e8c3f1f29919a96c5ac665b28b70f0ea25c0b75a76c4c02f3be5dfb6bf87b8939e0940edf600299e16839cce05972600c70ad09b439ef1c9d7b1370debf23bf8d80c165ab9c7c71bb1f51ab086edb4ac31c51a9df470f4a7177a53cf6af6df14ddfe5e186afe9c5b25fda03bc95aec41f0d518aa18fc4a1acd92090c3ee5237de2ac1168fa763504368ce11493135d84e4a55fe8724ae111582805062f74eb99358953000149bf0918d8a0a3b58a19200afe8fe48d2c5f83e6ee5b369deea40c065bd3ee5ac3651ddc7504eddda9a330cc7aa2d407a47ddb649389bc87ac2cab2649ce40b9a1be5795924e20dd2e3f54d3d874841eacdd15eba6cd843d02485770907a027adaf09c3b02ce86f6ca23341d1d2868974870abd429e62f6459742b36dfb7b5f516adf82098e3cbb416cad1ea67c4fe14848d2297aa433fba6d7fa6edf65874bf3b276a535f3331dd7aaedfc645a4a7813968210c8fb3e111890793ad08667b72ad82e0bd584fa05649f42dff29f9472076a2c2e06cda08c54fff09bd569d86e094a26bd8ffe826b5c1080c2aa6e82338b1617c7c7f530ad783972f04a68e65d261f8f95d77dd483a39f0f3f8894772ba7ad7407e14dde6cb9a9b67d6575d944dd022f3b5847eaec3589bcd149fd16bab7ba0688727aaad0aa961134bc3ae4902ac408e6215dd2786ab3a8fed3f23d5f736b663eef81da0b9594ef7034bbeb50a25122803b1b92229cd3d8d6f8a82f9d712c8a5beff0b56b2b398b75679e0e92d74782aa0f2c656d79bf09197329fe657576587fd09fb0d33d556f6b05679ab54a4550b0a0c9b2625f741a1cc0b4e7639be5cc2c1ebaa3705b87fe519e8226ca0ff1377f452d9fdbf7552de3ba38098dd9a1f89568cb32cd4ee3f3692c94850fc58f3b3cb7f050987961020690e6f0edc22f73b769a9ddaa583309774a3beaff569c708145c69681ff1b1eb7449a32fef922d2add5745d9d7c2732f8c05efdcbf2051b78aad27ce6bc41546b3f0ea13683b948753355a3d1daaf73f6f2902b57a4201dea75ce4df8584d373f214569a329c4d1ac1aebfe7669b802acbd8e1cc3f8a61aed2cd7851ef635684ca2634430c334747b10b2af9e62e408aa30ada558bcd1e267db86baf5ec4b5e406091f0fb83003efd8ecc25136dd1836b72c2505ddf063b1d23809bd0e20b74537d9e85c4f745aebaaeb708ecfaee769685ed52526fcf4e73d9f11c3bccca8f413cbb01ad3d99f56752ea037c9ff14686584c6b88278cff4acbdc2084fb2a7854a2a1c3d0d8b450b6d9762d707e8fc7c8fc267159541fde7a803c9d97c9869425a75b9763d7eed2339958c20710d567de95747cb21d0f2ca28a18cff8120f8ec50840e35cd3b0cdc242fe44f0c25b84526ce70732f4fa21f1a02a42d9903a988e7d1f79b4bc64fcea66bfc069dfdd474cd600adb451d758af6b91ed7cdd612feae41b0888cba53f0ea308dc1bae511cdb76ff885abdd98db8fa9c25ff4c8b7b43dc28c3594648b57e9f4ab8d2ecf9b9d0e9ce7b47f9d8eec4799c8c80aa7148ff74b682c3a53ff0bec2e329bba65047ad59e5237098325ad21f1954ccd81ee292efcd9bef15014d5b50a9291317eb7d1f4a75eb82639cd4d469777371e74704a680e257c3ac361898238f72661884a4f00d73892987f87fa882501f78246c15e07b671d19043f3d203f6425add9a5e3f7eddb7abcd90d45d205abd5cc5bd36a07510d9d15e9be37eb3c66a73f87ca042577e355aec9699c030be9a0798afefca7cec73b2ee2220b77f9079050542a1a8b9e148e4f05b78d9b0f2d05afe62729cd4d066e2d8a4fc53a90f974a24b7c2c6e88732ce914283f93ede24d1941fe640ed8285465c285e19ef6ed695e55f25ec9b0ada42d8c2ff35bf9e8257f76272705b6ddbb6ccdd57ec96c62712228dad329fa46894d58cfae8bcc9ed3a6830a65c04554cf9d8bb7a766861fe9d63ad44aea45e40f6f3696a2c6a6ed96338008bfda2f2302641b1d5f0c618122477269826d72fdfa0a57770eb30d27d4679812f8106c632d3be031e2f550b8f8bd0b5064f1abd4b5a4b50009f27fc8d3a32b0439c1a1cd9f414d22f3ce30e5a1787546050bdfb201fce57557a76b26a0dc22e7e3bf700e3da2f7cd2f520de4aaf13fe49fa324a5091222d63f3cc1693b63548c8b37305c984c22df31d55685c759209863463a4ca42982cd35db2ed668464f52f488f1ac47aa0fbdeda836b6a2a34cbb19320fc24541a63d3c495917117e546015e344c65802d5e639f47f02f9493d84fdf4cf696e6f336c6134c49c087f25da11c113f1d2af7094d4c4007f887faae9379c510383fdf8ad3a4793ff4fc21627bb63c8615fe0a112a66536757225f872494519c10e37e2377abb72a593b6b05f0c0376d89f39627c2e3dbc91f6873ba7abbacdd841409f667885e6c414e880606d19243cadb47345045c4ed3bdff14031cdae20c1956a04eb529bdb9fc58b7f923c7b29e92d170d3b4165e5d7fb7e5a7e54d9c8b97f7f518c30e08a3df772908b0d16949944b6281c14b22dab663f99ddf2775a5a7d6d09e4d249ad417a025517a20329fa2d60910abe80b1c4d52a4916c5383d1ff40c59153640687d063c7ce4101046f3db733a2a005cc75cf3a70b7edf3f0c0aea33e8133ccf5cca80e2b0e5c375a30d6ec7745d2585f872f412d7d8f9f380a65bb7b488f67229bfd1aba1fdea4759d5b2feef0dd3bff32da4047883c587cb7fef48e0c38c90bc5700c1182c601ab504a13da974ade9745e28a34abd97a597a934484fd2e75e88b6556de0d849f2383295cb73224726b889db6433897a203136f46d13fab497e8a353d228c6a24f0d47723008096a05d54b6a034702dc2227424def029b2134c8b140220e991c703c5c99cc81485eb0de070d49c30c286ea6b9c6e2c4327824faf15fc1f500d1abcae28b70020a5f6e58aa103a1b55dc6a865df212b558a9e4991ffdcf073b444379edcf89b1b37b4ac8fd0ab19a086b9b630d7b28bd4bb77a8924b97d147cbc2ae2361a2d1f9ce93bbe8c6ae7d9e004b98d34c88bad5ce85f79abbbed764c6242b86360409cdf3735fc41e6b31157a047dc4fc119c9ef0a905f32ac20f47f26cf349c4287ea97ce4d6bebf562f2ac312ca07d5e5c4282d9de6a0ebbf74360c87308b9f7a92d3e1bcf1474f1b1abe5a9c9ad4b2dc910b202eb860c95af0fe22ea455da95ca51973d5a0526696df787d94c26a55965d4244015e53584f576725966117a74fc1ff1b7a375fa96a3de043c50335376cb83fc13effff2a86e99d401474e5fc7817f259830af24672561d791bbad4dc6a4de08c15221d208654aaa22cdb2957df1adf57a2af841d102884f3be683e92f51840b742e51b54973624f6e2aee5e373f68018d13758c5106dbb1d9554a066a793331cd1167ecfd663ce03842e7dedff3f6861de4ed0390a8c004b14683cec1d37163d3e1ec1578c71f38c8eeaf181bdecd1bd3dd0905ed87d188640f863feb8031ed3b7fa2c814f4442687f42c2030c663b8b5b6dc12d60b550ee436417eca77e825cec296fcc8b0009266add3d170d95aa0f9a0330fb39cec2b37421d4a47a54167c9f8a2517f1729cf5b1dedba5fc24474fd2bbbf4073cf5b27c38f3a1cc26489ab7b742753a24c8b5efa453598ac3945779f902d102734c333ce515281214cadb843c42790cbf5622409c3dc9cc74f77b81a573835a60bb6908d238f7f833caa40f9c917e54d99b2490e1363a00ab10e1c70c0fe15b3064cef562be322802e80fdacb30ce6fe0d157c3ec0f947f1a87f49d2dc557c2ed08eddfb6ed932c40a89f27a17dda57c09075295c9160964332958eeef323a8e1198b10d1ce4d530a93a3b2659f20a3e1db4b543364f3e9686a43662371247b650e5b411ec86e95af6bc9f9dcdd3c970a501111cf330bf5f392e3c91d263fca5b1ac57dca38efaebaf935c3d797946c0bab016595c709aa545e5d9a06215a216396e8c9f67e0388d6c1d1db6a58ee7128e653eed82ce4d1a412eac9798d1658b026ed49fad7702663996b308053ad18f1d87879cde578abafb2146656bcc31a02b28ea205d0944e6dcd9889f565cb7f7343af37a102958d581c7e32fc411f24d59e18b0961e2c03c7cc8b32fba5b71fd153f295f24745792f46b8c3e02f68e81843a802e6ebff39ed7b241ea02ff62bae0d24c57a0f12003fb61d4b03a1acdd14bbed74c009387886b0e9990d252a32006ddf98932e7cd39b1deb93e87055e35a83cae52d415afd477d1ba84d04b4a64586b330206c4f2f2145579e8977745b95bab62b908d61365cb9a158511713f69d3b7d9ce6cbb6941ff8855a6aade3e2a6ee143b0795fee67ca7a5d80da7856e5bc4b59ab6ad9827c225d701e24cb69d2bb9fb203335c0eba4f2675f66b7230fa9a8b07e27c2952a3d0cdce008683a14a53d14fea674065d48e02521df60e4c38cdf868eceeac3dac92281be30908a8aca35297758a7c82a21165ef65169fafe36d8b37b2f1323b4f94cf3be58b99266f2ea8db8c07e9ea289c957c0ca2296fade9451dd5559acc30ae035cd7f0674e9932af6cddb58b04310044d304abfcd0a9bbbd4552efc9d7a7638b56921b55cf591cd83236d289f3823297708425526ed83158b77aebfba177f161ddb7b483fb5e767fa6c6602c360cd568a926a85aec05c17c9525d64fa66b0f24d4e29b07451dcbd7e28a93ee9e830cc1d1fde4d24d1350d40cacc97d45f5aa1ba8ec39e9db2bb9fef8d07af6de477b20510f613aacb9eca35d6b0f5e718daf35bc8d76d5d8342a07b33d3cdcc0a6d32f3c2ac9768a30a980cc12bc29ac7e3246150d97aef5842c976cc02d7dd1299ae74c6362d70f800d7ebf42b8ca6542a44d54b229a3ad9de8427b672b98df9b3e22c4cbfc3ac4ca1b56ca7de9370dc53dddcc01a367564a0687486f77232e803062debc6617b53aeac48a141c96c07de634c54a2a4b5b1385cd3196f4eab316a7481e415ebb2a04d6d5f450bd651745e8450fb2351a05116c1310aec4305115d7e14e7cbd82cc4fe0cb44df6c7db1bfb6f51f7c14329d9194a9bd4c8682e35164f1062638dc61876e2dc151de9a26ac64185b8117f27da4fa87c4b563edf52b1ff98f37053e910d9f9916193306bdcaa249ff6ae3d7b6fe5eb2986b1cc1a053a0560d2bedb366a2a7e9ff1cc50b84d035030ea433407fa29d8bd401137397aa602c16a67f5ff743355d1057703f09e6b3e8b94f0f532eefd4f3c6864c4fc1fa24165c856ff28661a7260ead668f4a12adf7836646899e1ee4f63b671221ca475037c4f37597ca0811c751be844dba3e04ac056307dc7b46231fac66483a2aef1d20c0dac54b5d4dba57fc1fd5f50a3e0c35d7bfba89ad43c45e6dc5f9a2228ba9ef023aa704fa7ed3b1bc65753f1b8327cd03d4c84dba3827d84c2a1daddd027374b0d53a6b6db7c6a4f60217eb2e879dd77af61e27095605a42b16af7a228d78497d59153890ccdb0daa59317e9133f18bc85b70a12443f52037d3cd732f21e9682c9ff947583be93edf879e1fc3e35388495ba114449b7fdfcdc6ae4df23dbd0f4b84b1871703088436d899ccf7f8b2c6c9470f5c8f6fca88f8199a1e9e80d4d4b9f396d65e9695810c07f38ca384ed6b02f001190e03c6926510a914f9723b2fdcda88da1e7a3e4e63005bf36e5584f5fe41cbfea1ebfe1190a4c39e61f1c89ec9d33dd14ee0827783c9f1e62c932d1b40c69015a924bc4b737558d4a74330a7bc4de6b76916388557589c9f73ec49a0a6fc3405e0dc0e2daadb2914a030aa7df1e9fba77c814ad870aa5a239a8323d891e5d296cd6fb977a9517cfdfc8b1a70b9ffe62fc10dbf9cb723564cb4b9a14bd45a06de968ab67f51ea69d7e81c74e4a7e2810b971ee9cec324f65c5f1971f801d27f163a57b7dc1c203289cdfe73fb214e8dcad629c39c3b85db60fae9c6ac516ed3d90fff934e00883ed5b734c330b056e11ab7eb3275620789f5db08fd33b853e3f44393576c0403ef82b542833e2737a099e66a3a8f316665a75256b9523f4fa7c3286e29249cc31529adab99ee2a9a664766c6b1a58cf4094cf9e24b458f9a7f0a72121217c091e5c4076bdade02c57bde8a61","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
