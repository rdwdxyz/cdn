<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45801528d3147172054fae2212daf365720cccc60aab73709a0568a57122ed8291a946fe14a6671f5f6ec45ec98d618e616d5603ef03645f1a925d30ba61feb13a65ac80e4d3965106ac7b1c40ef9f5d22332df58d26ba8fbcf490b690d2ea71728c39840e2fa8013bfa103da301ba8e501b77492a634e128c16312f44c46f14a82ce994da7955c14a09720134468bbf4a9472e969e802b342dfa7c872962407d894f680dccdd2a064c76723943e628b3c4a80bf71db9317e065972fe000ab4b677fee35e98da6d58734dd3a406ce5903692c9b1551ae6c585f9136a97fa8786f6562d6c0c19fd97a03a15b70c476eeacf23ca357d2bd9c18172c1afb4d5ad5e2a8e260c9d17148ad7082d9f05c26926ca7ae44734da1bc5547deb5b3b25ca544cfa7882535808e2e61bef4c0cf5e4d3dcd2dbee5a531eac5594a31da4f7be8aaa833ba270308bdeb1a86ee42a8dc3cb420556851f4955db02c59df06e7c834cc71f31c250d4df6f80c6f02bba071244f7b7c05fa4a0528a46c96ad416b2cd21f3d7950bd2a473e22ba42cb03cd8e441552539879a92afba92fc1d712d60577a1f547aba1134eefe3d63b5e5003a2380c5cfeb806ff5814a525c7a6c31c0cfb4308107320dc936dc9f2d23b9980a27796fdd95d170c6abe13afbb8bfcaf48e07202233d02731e041b886a1a3ec9f92150c17067838bf863497b4fc3d9ce535ec6113a90d24a3bb0ad93edd9cabb1ecc554390365caef9849470d50a8e29f1bd5519af10eecbcf4778211ad5a4d63b54ff268183f6dfda6bafab617e4234bee6b098efb0d0c7c9616c28a1cae3395daa2a13d6dbf8575496c60a4f4d060347a2129d1256323e0b493d037a898e1ef81bbb3486048d0461ab3412b82033a2ceb0e0db22a893358d70b858791d14f556110a62154a2fd97b05b05f18257fb61063a47de0bb7c0ce2e683a3f441647db461031a94973fdae704d18d411f4454e2adbdc7d7e0d235c5c608c38f1159817ffc3fddb12025878289e1a9774825c77dc51f256b3ae7b09b7145928a3f9cfca85e7d8c3a8e42a2cc8249d9f11f517cda2f7bbcabd9aea216f62d001505a5cf9046450fb4a5507a6aba6ec33fa4829f12d68360ec86cbb794edd58903d131f9aba08cc55e34ffbe57a0979b34071b73e2cc08841f294ea54ed77693162cca11e7a46ae31df4eb1c6a89fb864e8a9f9c6a3923598f26fbb0c032a6774ded556c8a3f8175f7ffea5072f04faf63b0310a3fab2b89a7bed017b96ad1a906751036ccd72c4dbc32423c7a986276b517d90d996150fdbaf873e139201097a96ae524aecbe6bb22c21bc2102360e21e6434cf4b9abab93f759500f829b578ba23e690bf3c5a07f23e0a00c726dae3fa4b369fa0afa0e9c353da3279c8719d4c000f0203d065368e81263af2b4582c8c6acade48500eaead47bf4b87e6dcefa83e2ed5d6376c7f3f6d6d1c58e51ebeb7cf573e4d303e286719a019da6227555bc5a38522c73e282566696a474137c29088e339d9501dd5a48c3c745d8839740e1ca85d0e25e798ebad9b1f946ca6c469edfae0e626418d17341b5723e35253777a5e983a162d6879b5e1d8a8da10a218379bdd7563ce81abf620b9ca2156b572c41f06987111f7e4b6bfb9466d135439d8648e5557525c2e9ecc24fd3a4022a4cbbf19b5cc5661eebb4fdac4290fdeb925180f87993697b48d833a4fd8cc16533b96424519c8ddad68189b724e87da9cbe42c9962018014a18a7209872c2c45ff10c553595c9c05289530bde4c5b29a97a7649027bf0f1f7f5b9c9a8caf240163c81292507498d90661cd2a5bee4076e20dcf327f0a028d4981c24d0a0196f2fbff17e11b1515703fb31d98a23249bc8cd0354c91d101eedc692f966d1f0b8555ec9db05b4b221dec3c60031503789ead4fbcf59017c354f74d7172309c569edda3a6b31b06b0c89990e2780088ecb0e457ee72919c7812cc2c37f9dfc564b25d7979149b7eb576925db03f7889242a54827f8d6efc2629b52a6a20fd419c063c2d26499a8977ac571dd3a97018327f85632c0c0e1ba14eee074e612541cb6fafeb0f3f5a169c0c7a86449703b6025e5daadac4bdd20b0b346fb678cec1f2f0db52eedf0dc3e68cdf302d69c08b7623d4b95660afaa60ebedfefb4b2bfdf0bd3fcdeeed050bd43df63872d4d3c95d7b89115a89249534beaab1d8ee64558cd537b5e5693bb747c896a65bbec6053331af4463bd517b2b1f7ef55d4fb2a5c5559c6040cd75a09e4aa135850d0fc5633a7bfb7492e341b6f4e398b3b484dbbee17f37699b2150132a77e033fac2e6ade2f61a5d4001afd519fbb5f0ced8a4b181e9588faabfa709477c0a8c7a0512611dab21cdb4078307d68f2f814fa7122409c8ef655bebea5fe0aa2e2aff1cde519ab4af82999b2d44af5a2b4a663d0f28732ef7ea243d6e0a0c93692c7f80052646be5e71b3002db13bff3af7e2c52587e3a0a5041ad70df2246c9b445b502766c578e241a7dd092321238c6a8c40029d118a3660476fb756aa2fddf4f33f2b4247126a852501b08d2802f787999001f42eca59d40834c35a227f95ea2100f351c75061b22157296a247d3bb7463ea3d739ade5c6324b1652e0620e87fd20618aa7105ff0b5636d4c5ea04c0f3054d57c99ead6ffd364d618665f5a78ea28d53b67ec56a29c35ac44a014ae8afb8867af813ca29dab6b32de877bb0b50512dd48a8b8740d92c2e5245a822d1e38af8ec67ad5cb873baecdedd60b7a0faa3b4f67b8c2e51ccdf57c14d8a00500066cfe8932f4f3dfe43ca762c6cf2bf7107138cf000e6c5a7bb2d6dad571ab3831d3b454b7e82a4e904ded77665103205d13c619877dce7643449081af88496dbf5b3c6f4672462264ee29b8f1862bca938a148c305d2a3f63b76ddb8590b6c3840c8cd656c030b944a8c138922f48c49f8f1724dab4c1758ce94db462fd7260cf85a5a235c2d6dd1f30e6a03822d7d00ec207e3c8952b973e7fc51e004347950636dd96a608d6a75ef47a0c6d65898e5930702ff1c20ac9f59443d64edffcd31de32ef3f39eb8ff3af3bc1baa9c56d22d226ab88f86e1cb9e781951e84ab2dfb4be87dc054ead208d246c9c634867778199ff5516eb177af909c798682edca9ff1b3386934002c2e1832d2f9117cb01d063a7ca63ea0cf82f8c4891a5a3269bebe0797c088c8ac43d067f2dbb9ed6342bb5586e051477ce66450f166c46c4c996e9645b9d75b7423de7765e079564685a86f9df837c5a1242decd0066442a4e64740cf9920ee0040a70a2f8d39b068e4df8a8c71ea1e28c74c4dcaea89b3606d0b4294a18e6e5ddd09fe26093baf35b32bf76c4a5cb05810e11079c694b3849de3c086e034fbdf623245a64b2f22b0dd5b2eab987fc4dff1d412da4cb90cf8073c51d935984aa352ad9ee19a4109a01de6b8b251222ce8421765bb16c8542e6051613646561acf862d264bf44f4be525576ee96153a17dc5aad1474f7fc3448b44a3b7f0fc41a9fc0a39a170b4e5988140e401baec021ede3c068a3872334ed73eab23a381d62c6bdfddec8168f60cb54bb9d50bcdfe9af2d69bd9394f3c6bd06a66650021b6f97380f304e11248f7aeae8a353b34413cfcc5c6e5b2fdd65cb7528e4ad65c71fee19ec7726cc54b1aed16aed9d6a07b4a690c3e8b4d38de1459b3c1d4c77df56b36c464fd60cb18016c030a9c06934750e57f54dc42374c0ab1bd9b52627e3eb3507d910f8b0b08bad1377a6b1f5928a039c7956680c9889189496be720047e17ea2a9145325dd6b2d1c0437ac2f7aa892a0a11d027fd0ba499936d7678b24aac6579a33d4f9da304d49ec91d426b284bfc53175587043d930890f9312f9b2923df8d625a59cb7265362c6d4a9daa09c7100547e5b8edc779aa8f8c0d2a89b0d2b6a488fde8ac81a00df40bf857aa38f78aa54dd4aae9aa3583022685304d64b5be835ec36e1633e830d945682a8ef1b63f12e20592d9d083144a126720378caccdfb54bf0eb4e3fe3fcd73d0788a9f31ff429678e9ae03450110fc47b4109a5f656bc2413640e2974a3df41cc1c6b9353fceb6520b5c35ff4df126c3da6a40faad692133f1ea0869998c9a273cd54f2b5cb184e6456976822035cee95f3425a98fa2034f371e1faca64dc2ab43b6fb7addcd05fa9935314ba74008d76eb3799cc45d0b24b7ff0f5ed39ff56e616c6316fce183940916818383b08cf03519e772af445012354d3b59af996f2c1c9fb71a4c0a267db4355ac9d9bf0ffed6d4e1e3b872391f5729d055dbf99043f657b2f43df1a19d01ad0e8d5f35660efcaf0ed4d883a40315e5e1570275ad17f0d97ab62410a153694c66e50a01a80e3c565575ea60a18dc3cbd2c8ffc2dd71c3ff690a6506b99f11bd8f9eff565cee7466ddc32e6e25699ccb7e1740687ec0ed51882b7fa2b8dafca62cd88cf186a1e98fede11cd397c300820475bbbb725d3713d5ec85b7ada642aaa5c9a49e9c43b3907265afd4cb4575d265a003a18d8b7cf70a247a60e118d072c5a574d8ffdee84ca136448ecb66af1f44bbf274f12bf31cf5f091874f0ef29120790f3df59fe3e2dc3539a565de811b56ce80d8dbc6302e214b928094489f18f21f131b85a004041fe90326f9ad5e16b56eae1ad0b168b560d4e532c737a50b28083d2e4c06d87fea6a11767cf36ab91ccfac62ebf42f3f88320121c711afbd5708bf84b6cb067226e5a9dc525d887007e042a8ccc5405110a7adf13941afebb51bf0b90202d8d0471a998f32b5f3a12df08c0ee34f900a4cfa6dc2a90d888e372c5f61c03419c791cbf5dcb4d05c0e6e7559fa359dc8edd23b5595607e45d6c70c59fc4f56b3390da150f50ac054f110569ee84ea3f7c55e81c15c9ea2c85d2e1110214115ee92d4602e87d74b1c9ff75277d7e95a52f7d06478c336ce41d0d04976e1d863168eb7020ba00a69590d1ff753de2a3a2d373cd25c0aec52fde86d098539d8f9f039676b51df4efed66b2c4d07cf6848c40a23b912e886765201ec17cacb3b7ba3df76a862c747ff32d850e1a8349f555e8f002b0ab8554841bad89f2268e637a9c2ac6d6a3eb9d00ddd3e33bd9efbb6b5d6d5f661d6a5e7058a733267dc2689da12b59ed04f2364cc627a618a6e0863fe98c6563126413ff8d2f7f9d4150cb39454514414c2b11147039d3f8ac8d8e59a4335cff94dcdbc733c5bd899c85885c4647d4766438525ac34b696a1334cc832fbf2b4974c6df6124197bc35c9d0ae22285b51e2f7a2937cd074bbb73ce36ad0fae9dee2155240dbe490bcd65cb4c30e725ddcd5b435f5023e670c8377c2f38a352b088bcaf2ba9cfe8e93cc9c7518fc57c04440992c839a1b6f2660e15581df338736a8208f7af400bcf4f6e8e27a08db712da9050903d6b7517762c36d8a50195923a7aec3a72a12da5a1af49945a2d14b5741e71aa46682b264f86ba9642b39b5371f39fa055733acf8a3e447022aca0a35ccc1104fc4b420bf3f69514f1b0347a49d2a173cd3069cc9496413eb02380ca3289e584f9cbd8e58bb8d170dc1b2a877c659f32c3848a433b1681aa5c0e04e9c7215f1175727c40188dbbd24a97a0a93e3e665f4734bbd8a6b89c7a25fd62ae35850e841524088e3a3c89ff555c8c59b3c57bb89a93b4eebb52a976796bc73bfb0bd3c4b3983bb7a5acae6afc5362f799ff00d0749c2e82ef3162ee7d2d1a71e37e8da3066a8c60a8e5b4a4b3055c670db4a89514251fa80246dbf4e1ef9bf2dc7425e6e847906b006c973b7ef9e5ce9aa8f2989ae8f22b5b60af02e00b9b87d82ded43e91bdc9a46992281d99de0d6cc46060a1c1ea76bf76aefd3384861fb66c6c2c9254e7cf48913d1d52c276ba7ee42b8499b026754547a972f27df2bdce3f6d6f432713a84e54d0c0bba7e98edbe6f110a43c552bd42dfd4a16acd09447a0ea7c0fa0101aeb478c5d128b176d8bbd5ade73ca6178c06f7250e41a690773020106ba082a340284da75d304f618ed92d89e9fc24f3ec4d75b3860c6bd1232a502a6895b0db447f80f2d051a054eaa332554c1a7079763ccb90be73c11747dceac4f958df596799a0c18d89577c094207aa2c4db91e0274d109fdd102cb1ae4cb09451af9ea2b8f0e59bece3e45779aa2b3570713223fda584da025bee04d72c4c0b788fadfb78b75d8c0e328c67fe814e6cde3e54dd2d16e47cf154af1570ceb8f52e2f1ea7cc32cdbcb16f7e7e09d62cb23df30c9f14d0c345304c5ea85140cdd6d737d1a9ddb9305902218588be23b17bd931af47f9074c203e509f674dfb0f347aad5eb7b5b9c77c1ee551d994ed840df057c27238490571a1f984971bbfa08ae515d18c2900056694bce5a8a199a30ce8a12c627560be825e062a2f9e03b14921a58c3b1dc04e23b6393309f7f4359396d4aef7288558c93c257136f3ead72e8ae94982f5f2dad04caf6218f9baddc1fbd21e769179b7dd18a38b78b76067032383423e9dfa883852e72aa1d2a47d7c2d095b8561807b585e5f4c15635c91ccbe670cfb2a97e3a8bfdfb35915f712aab24a87403e9609c42baac757fba83e07738f65ddd2fa8ad39417d5a91f3824813484bf3267392425190f409ffca91c4c9bf2a2b7d914459b362e52b7caab8e1f219dcd0eefb81d5167fce14f3f55c91cb9a329d2111622fcdf2f1bd3a85eb148afbad5395df676efe8791930ce2297e291a59358f3feede87aa004ac580f55dfc657e168be4fac9ce444d5f5f426540fe864d25e6f02f25a54097b538fef65bdd530558202738d303b0950f4c4fef625a47b2895c07ff23fcbee396dc274b265914b2686f02ec7fc6006eb127bf1c077a67b6c053366894db3630bce226e1d212effa82009c467a22c6edcd0b7298c8948c86f83fcc8a26b0b4ada30baf695cbfd4d1d7c52474bc27c0469dbc2539720a9362859ffb7034e25d4d805564c326a501bf6bac9fc5b0f20c37e781a242e7be07b7145354f01736b12219c59f2bd119c5272b68788899e4f873d8b2da3b272de05913181173e7ef26d70ea0c5e20a074f98969cafb3aaffbaf5481086322facc29c6be09e49c670a4c731ac3c38ab7a76e6f289ce078268dbc4a9e5abd2227feb2cc9161cd1f2f602247883286ba74d4b4cdbee2abd396b89f030a27933ef05b806bf4940a63c369f543f2d7cc83709e62e0524608e8f9fb20c7fdddd59d3dc4e0cfa0dca13a5071355b6877022ee404470a84cb05ad48a78c28fd1602e9bf4258971a0a2886a8dfcdb26f305c516f71585c15e9f0aa7357d7c15e1b0f83ba54a22c7b1c2462a03210bcb8b7eb83ececf993c469dbaa216f410d0ad74ac9ca456bba1d3e9b168b4d84d371e931675304b7edeb117c1423ae1bfed8ea7f4406787718621e5f86724e3e1042421f95bfa493f8f4497a391ea67727e7402bc74689797b3a0a9f475c9a439796abe6af5b3780f9c3b50f6d4a37a2bbc6466b2abe0a7dda2f5002a374f752637e9e1b2066feeb4b1d6c33f73ac440988b6d782e574079db5e8f2f3e216cf26a2d0e1eeec9562ba97826781241917d7d3a2caa98cc334b00ba44c5631e9c4da4436c485e143432bac3fc05fe3addddc37f768bae2efb8aa63a2a5f5313915d7e495575269e81cfe0829562ed76e3f4c03bf4ce7fb79c52c483b7ef908978d3cfbb67b98b492cc96ada323b8eb7a0a19099832fee968892629b2106faaef0f42d3fe0646b397fb4ad857862fb69c30a5203f0f8203979599ddbd9d8e4474d211ddc07602af00b70cf8fe5e494acbb25fda5baa8d415315876203cf4aeb3926e6098cbe7096f326c09d464f0c1175e744e79ddd59cf6057042d902661e4a2971855cd9aa1fcda6755f380e7bb7afd63cfdc41b652c24d52c4022765ca310a248980e43b9c88f11907961ee6d9d92e48cf808b15d5745a22f23b53ae72150609b8d73ff4b5583db32ba745c87255ca63907f97782b86be31fc2a1a3cef4721d2ccc7f1c11b80fea08de95333aa1ad7c9575c2e65859734424403da21d13a40e3a335f50ceec87f3e4da4d4cc4185cbd3673d8bb53a61db6ef7a4821b0a25c856dea9bbef79ff36ecfab271460021ba1983b9f7b8b04355e89924de2b825d52d5cff2f43f292868039c5d5a510a4b88076a682ffc056fd21b1add3344f18408d2e5ebda65efe70b3320bd2b3de1026abc64e15a104c133ba68abdbbd5f1fc3f48d94d4859ffa76e70822f270193904aafb96d27969a35d44a8864bc6aafcc7b1ab463c9f209b65cbaa96e143665754260029b15c25d4016ac15472e034dc19c0e1a7a35b7c5005dad6af723448348cc47dae34cb8bc71c8e587f7026ddde6a3d580dc62758e1340f8f8e4cb7fb58a104b122cf3bf7e02b5586a8ed3f44c3630fc102f3f771d54a88462d16f6ca586a38174da94c450a43d116ebaf0dc7e9d7b8fd480777ed430d579f38c6553692191db55861bacf62d51ee59797bd41c1801b76d9eee84f7c4ea36e853f299aa899960e0dbbf2a493f205e84a8c7bf0920b94b95ebe786d01f24a4b13e9e98bc6c392454ec92dae37f70c4f41366e169f61cb64e5513cf8f650d6b92eab96c3281aa7fdda5eb597e5c59902df40fcb023b71a274b2bfab60896e61aecd6304ecc0a50e9b15bf89aa5c3fd490a665b044220d69ffafd21e4a2540720b55e3838441b8e821b82422839d31f98c0db30e79c7951642cf39b7c8de3c88f530108c9409cdd4f0ece7d4eab84f9c528e60e6868309465008d0627e56add6b956e8ee8e1d2b4127d10477f5666c66091f96bf77dd63b848342807df882af3025e64f00b9cfd107a7057d04e81370dc1b7d15b519e9b8fd50136511d6df13110e9e73b239664fb323f2c31524622123379f239d32dda154a0f24e3f9dc8a45a1285eb4ff562457fee28feab03c65b4d0223f686c7ff502a2de65d6c5ade78be28102435bf79495b03668280a4a03cc87bd4dbd2e75472594ecac56cf6fdee4a55c538689976fe5d45bc3f427e4fc48b72ba763136f0e811a5237d8e715a65ebcff7ef8b8030360722236dca1fa7326a53e2a9f4d4bced3418c6f81bfa199da6a764e85e5fa6660ab362c425a9389d15278d73ae95dab132fe5bca66aabb401131142b03478c4892d5988308998d89af2ed4a34dca43a64ddfa9886466740f31adcbe52c5bc9be485c0968d075444f87dcf76f927ecb7953dfc892b7afd6487fda1c81c3fed9b2b40956e6cd593e395adc8ab2fef63a930b5f229bb1e3c054f0b00331108d51ffc982759c72ecaf02e826248759adaf37c43e381e7e298236e1431747213c76216f4669d75f3f4222655ee2e26697121783a406404ac037acd899622decfb25c40ee35dfa7f8eb02d38af86879dc7189490d1fb391d246079f4f8fe5128d14dda0c21d8adc2923da814655556241eabf8bcbd3dff8383b63071974cdc2238c74ce166384c29cb3f5fd1b77aa677ddb1b9a383c83809b07de2ceb46e2b6f72f0768a001fe94fb9974c20b70a062cb2422327d17f38f27e0062753d29b6cbb2522582c4f0391900c830ceebc207b40bf229481a239a4aa1f61f26a510f7d29dd41528ee7de725e6957ab7bc7efbd45109ad0b87582dce17022f8ea00a14eb87642ee9c7ab3621d8bb6450dd464d60b24edcd12a97cf3ba6c967959738b711b3f63ea510ef5c31c445a5fe7458216ddc38774e2c857c065a619c3117763e95bf20a9ad617fe90abfd1777d87e80cd35e73ad8a44044a4f6f6d7f03791f2ff150d748f246d598da459084a31c8d98103b9023ffabb1af89919f8a9a47578a14f1fc48a4fd35d747381779775106153a2a387d0adf9dd008de150ef02a61039e8a3534e70915d74f29827164fa44ff486584297bc7e384fd6ca258b52fe6d39324bd108bafbcce1dfbad81b68169a252bfc1f7b73f4219ee7866ee783234722fb1d3ba4bcb1f2b26472922dcda0cc19263020061e30329aad7961c2a098ec3d22605a3e5c3929027a4f7d2d202fdb2a5f167d43a0e622bb24f84260c5b4cea8a6cd7bba5d9f7db085cb61879736277559010a31af0078f08697bc671097319f5c3692b088f640c83da92de6df44987500761e15b8c3e84f0ccf835cbbd110bc6e6d252425196cdf1db907fee4c15bc0596eeb2acb0a8061a0a86ed39410aea6b29ba1d6869852da2c1183da16f03ab59addf255ab307646d3a49cf692d22f5bc037b093f4eaf38071488a024a1bbaa241399940fe8c66084deb97147557f973393a8013194432835473feab169fe349663205b58bf73fae4f0e7fcaad0af74b6a84443a01c33af47ce0b9fe8856052fc25f9e37a9547476e0cd1e15c78269e6f4131193fdf2644f92b4518bb04660adaae4693444518cb5a06cda6599782882cd0d101aed4144f5c3600d4883026f5a2330aa94aeb86ca9b2a59fda6b9da5ef63814487bb0148d232cad8975f3a445be313f661e71874900bd8566dbf3b4f6cc400fd70f58930e7fe49c038070598db10cfc6184bcb059722e216826c5b7b691695ed3f51cfefaabbc633bd8148bca7ee0893359f48fe0a5ec7a0dcbec0154de646e73d72867a3d4f3b05a543c24f449e76408b76e3c157e432a56e698d3eefd4a008703590acd454a2817f5d40d82d00c18739e9230c4a0ba9cf804c6a4782fb0492cf36e9ba524180e490f24e397dfd6e0194ccb98c882fb96b73504702997f19124347fb4469890da8dcdcd8b28243733c25333e882c51e9af93bf187ad058419098e7a0171448e32dbe292eb5daa0bc374365a32d48e1c1b7b5e643987fef7b91cdd05115d60059f7d584ed697601403c8f08c56e3cec402d76a0cd1673daeb16d4cb2b4012d6cccaab46ab7f49990a425eb933d4cadbd7856830048fe8c54699b51558afed7a87b78ed5abd66e1f1dcad1c9836af12fa6a9a3a78469f2f42f77a35e3ecdd8b70f8b7d06093f8265d992ae493d717d45f16626f148cb5565a42f70f97050e613cdaf97b2b8b885b90193c18f8773a36d98dd18834a5bb285d15197ab28ee13ac713479152585c6f238a94095cc3a9d9dd0d4edf0a1e6aaa3bca991a9a9f2b866b0177e85fa256be48172193a3ce5d1495067d59f266ab99adab5e5b69883bb1d9ab687db0be8352fd6712b364514d02cc3e24ad568c9d6141bf62e85a5ca705399c23d6dc0c95724649f0fd41a53a7d05f57420d206cb2ac2862cbd504e1302c839e7a554bc8009780370916adb3fd5a5d305e449601345350d91a9e0dfc772edc43ecbe150a048c5947392ddb7909178ecccfc9de3f3cf5155b8ef7daa21d2792081d095ce6eb5743ecd7dc889cbae719fa6bbe6c3bd646f73af516529af1bb98d938b8969886a5784e403af33dde2f5723449c0c7cc02f919626f262edc92589261b9aa26d59833b1dfbed8533cf331085f98cb5d89ea5b43e26db4747e0038bcf373b1a8005bd0ee616161f88725ad11804901f53a00d6e8599a3df42eac7cd9fce8b4c420cca81304a7d77ef18fd9bab6a68a4aac319a6a4ec70725b150c7b0e2e96720047c5011913db7b148d67d8871acf61c13b8cf10a60fbccad9585c0d32a70c9dbc2d8b64ad37caa7ddc774b9a0e00cb9908d901ba1b72d54bccdeb9623644640ef32fbf5966ba92622f553365a389d72fb40de5fee28813fc2b83249a41a6fdc9161e0f6b76be4c632d65b2eab014c8989dc7c4da3b433670578b851013909822a0ef8523208741ee15098a4f60a98867e977d8aa2f92787ca59f4a7e88236671fa9d883e79e3eae2ee90befd9cd058b8565439d61c7c870ce84a7f96b4c8af5025b7c00a42b521c39645e50cddca5d322a34860d7a22954d27297519e913cbdac08d62513f1f1f551b2937e16a397527547f31300cc14c6096cf2dd3df529c6618b58784a11a49ae654e486b972837c3671dcb6103d809b61ce154fa2ad7f35f10ff16870be3663bd979e27ad91a027839a813e1e7968c216a70035eca3cb2a3a4f3cdfd1491944a3ca46d3d5fd4b1bc985fb2b8c19a22b41d627882a82e4648d06a0f0236f942c9d32fbb24eae2432ae79249cb4a20545542f2c8f64446ee89e1a05aefd803e5ee1cbf06a4e79885b0af22542e0af314c9a5408ed446a84c01c713d46071cfff5ba49715ef8a4072d8da21ec0c7071567c3f5a79cf285d654146b01c2721bcbd0f988e9836459f6934e2a2ef7bf2d96a640b0bb1b8fdcfdc5206c7892a0c696f1ac980404c4641e28fe2329a18df0fde354aa713d7293bdbde8d34e32025bceae94622efa7a2627d0e92143239ba76e64b2a112bf947c8fdb64d9b83855e464c025610cd5598cf21be7edda15b14b6c1b2a0387b43969bf767ebd799307eb5628f61dcf39130f35cf3b92f7330bdd907a7b634dfcca7ec522fde8d649973437ee8ce4aebc91b3c3b85e2036fe2defe7703254d4bb56de4530ef2436d13253c8dc4fae4f1a5d04a81ff6c5a765a05607bb60c8dadc8c1a9bae2cc7548b3e49ab484467a93abd739b239db7f4b43d5180bfc1ba9eb851fbe7514e615d80280a90345a51698dde6ae5f447c6350787a5db9a7a9af940e1b05a3d318c6469c5d0e2ddd0f600902a956def8eabdc4b3566d014213020ae3e1c9c1bef294434a005bfbb2f26d8da7e2b13f2de6e5059ff5783a7868a39e120aae310358dea36b503dc618da7839fe9ed28f55d5a159a0e58c1bb0d0e2e2c45e3bc8de9a18bd3b7a9b1cf0c4c70d1f9df7841ad219923749797e1556b6850cc9d1b209d870632b23235e0426a4b29dfcbf5f6ebdaf9893394278f0f1627e5768da5ffc521ef18bd56b10ddbed07a4e68a64d19ae080b5ba033e468767bb664623fcc65207a8447c3d00f56ea0dbb0829b2adae2110f88a4354e171276d873e9cc8934183cc32d070cb4aabf2f83d4e510556de5b905f3c3e5dc631cc2b55e762b499c4843550014a0099112f86571d737cddd3202c11bb0bb4c0bd43327042d5411f940086d0ade769dd086c0e02d4294ff696527ed683fa605395367e3c5fce21a9781e13581cc96941c0a51de27548196f0856cdab110d0e2b64bd052cdfeec55604847e205e4c4ae537d92aa8c39feb9b82b4c1388f8838ebce19ae268b5506166636b95a069dcb5b7d763318e3e4b75a510568b7334e1084db700ea0c1de214e56184babaa54ca2f474b22349ef4014f3491a549808a1f0fcecf1e34268f576db4b0c4ead8515b2192d8fea366f119b530ef3881d7f4646c2b56b36713afa2f56329d17dc7fb466d4bcd4c5e8b5db6fbe1e9eb1ca7462b9d0313ba9fb4ef66e8f9d9a12d322eeecdb2c9dc1b4eb2bc80bc20ca018bb7f9c16d3a001f42800bbd3f9ae69a92ae048abee7672317dbbb50fe8cb486edc43c9d58529b547969c30df3e3637af881a19c79d63f33dbc7008180120297285fea1ba3d306b2879f9090aa90d2cd924b43d767d62ee96b202b975e22663492dd7ab3b6e30833e65b91dbfa39d56ff7c003f84950c9a57b0e04072e8ac62ef131eca21c3621cb622297719fbdcb1ad5e564c4e0cd9f3d618d7630b567e0b62957f5cbb78002b7c9e0612c6472ef59c50d1c331a152634ff68338828a020033abb553161edcf0ce29b15b2e6f374ab2219b8c6469a826c0c6b4764f7ac23a0299e7dc479a74a4c8727a97a0061e7472270142fd3171919cde53f867f70031415e94901077bbe5c96cfe00457fed08845b22dae2c435e24df2f965637b54293d626c2516011285853d7f36b47d6e3f831679dad126928e58ce0c56b5ca9dc1f2096cd14b11f92b6544c5da2c9360d5f0fd0b19db0d9f0d689a9b2dbff344ea7f341741b2b7e42607c66c2fba6a270c389a8bb94a803289675b9e6ef8244649e2f381f5b7d81921330bf0c50baf05a56236c77df704994495e80a5643275587cafe9448e54331c085171263dc5d60f8bdcaa1fe9a53f9c01c41dc7649d5579b1ad4af96667faa860920d6509f81d7a3e644845aee2cce89a63c97b14246fa329844cc35f70191f6b866bd9cb4bcd99a0643b28b94acd9c8ee161e4f6ac85bd5a2dcb64c234679f6dc823fb6668de379634e325bdbe0d665a40a8a5a78df4715b9f89226ff3505ebdc4898fe7935a7427f0f42def423b9294735d8a868098f9019da5aa520fc131abc9eaf119153eae8894ee7c6da9409a32dae6d2f190a0fc2fe6aee90beff4878d6f4fa3ba35de442a141325ab71ac97740b5dd6683a39554d2b77e3719fd08be1eeb16dc0dba68c7b79c689bc68ed238f28dbefe083bfa04ce94b12b46173dc4e379e30fb5d93df0c870b2da43bce28c0865e5d7fdf810d7e38c26801f68e9252d1e2fd78dd755d8d57bf0a27d17614a81ad17d642360d206c98f6ba54ef8a82f33c3ccfa078af1dc07096b564554e40a07d7eb4137959f3e876063a1fd00d8a51fac1519036b7e2b426458e9e308a19183b549d5ddc36eb4b535f3e9fa7f87075644767d2dfb39a5d6324ce01ef54490adf10d7f9325d9a30e65c6248d6beb8f0c2f62a5138565168fdcd812a36e7b01cd777119ca9e3dee80d2c373e5cdaabc55f9b52691683a795f13c01117b4c26d50e76cafe9eddeaabf14531708920c64d1660dff5d883c6f4ca54a9d47da9f6906c830f15dac2ddc13c352498bded7ec99be6723df9e569cf3ae03f72e07c3ea73c14899c937bfe07d57c3e4df6e9bd37c1f83b4fb48ac10feeeb4c490e5afccbc777eac4faa0af4e28e83a2687704306021d4058ceeb338988bb0e1ca94043a00ce5f657c18b5d8111f2f7fff70958d8135cd31a51dbe2a08f624f826a0ec987be4bd238e7d4acca812a7d13b15be84307c7f52a2d847712fec83968fdc155aa06e3ed28c0a603097eead46d4248ded3d86c994f90e643af540ab419e1b3d9858bb0209c020d2dfbde60e31ccb8a188a5b52539343b58cd9ead6652fe3d10df8af6e0bffc15bdff520d91b24a30a6a5d3df28381cff93a29ba68189e794c87afb4c898b135fc63d450c16bd369b7bca1761cc1c1b40e87c3bb3f94a7defa477a034816f72f7d3dd51770fddc6257fb8cce7559bf6a74fe684dae9f5bde8ab090b85d49ecf5319e72a2f345a93196ee2053f0ff94dd3f1ed5a34759d729a1347abf96b01d17ba99fc5a4552127f2d4592e9f03ce8e5cff13d37f6b8219aa62aef1b6b5f06e0e3a2b60dfd486da1f65fba9e82a7c994d327a34f19182044d5e2f86f6260a28b0b85479f866c2dd660d3f50370f006bbdb60ffb3b515797ad0384b0b6fa194826d6b76448562f6e696361f3c58086bb02c723e0a7606ee5abdaff64217f805d20575b180e70394ac732829c07f4af756ce33917eff7f5bb05488ac615bfabdf297a973fa8f256e4e58891701665c45542d80c86c34d6359e9264c43a8f967e92a279c46670acdd751109d1cf706a3011ac6fcdfac87c2ddf483ed773bc74e136ee687c4d5a5deb047b18be4a824cc5f21dc9cd3fe43e1d2ea77a6f2c731c1b42c2c0a29fa3336d39e440db6ca320830351bf4d2c34b7168cd8e7e26e47f1747553d30aab6b8482bfd4467a48f016fc3140e5e8a9505e590917bf2bbd3599ec3788dafc31830e67a82215e1cde0301023efa2fe65ea4e02ef27ff4ec1b1caf4fc1eb8b3ab31ebf5418a327b322ff8844c6111989ac173271be963c5fde4999c475c28db38aa2b7c47f7a2c11a4b616f47ba0e49ea819aac8d587929eb2ea8b210142b2f7adcb59aebdc9e273aaab7d3d1b7a2264164b4cdab892670e9af3353051064f6356ef4e76774bcfa61155542949eb85792bdc8665f5579badd05c8fd98d998ea064741c61aaaa77bdc3123c8c4350be68591062e30c185a4f929009a8aee72699d6037514792ca5ee98f8d5364d35aa5e0dd94b56feabd421c80ee1212a13c6c26b249f0f42aeb67250b4ddbfbccbcc0098a36c36cf05481502f1a3b51a2a91ab8dffbc2dd4448f008a9a0ae00d32a9e699c386f62d6a72a778e230fced8fb515e042bc5368d170aa34d5a51e7511a8efc99593a023b3d65b185af7673ffdd5d575d81ba42e8e94a56f885caf50fe287fc828115a04add69dec11310f965192f5f865723d64477fd34ec0a557891c7f2c07e649237ffcc14d1dc4abd3e5489775e35897e08791ebbbe23517bc3214b0119bc81bd42c0cea34a806909fdf2c769ffc5201ec2fe7dfa028bfd3bcaa90351abf32f3ff3099adcf4453fe1a5b38a4520b09e22d677006ceec758eff5e017e0b93209d2dc95db31e2dbadf439b1f174519186268adad1a473fdef5da696525344bf818c51808e103f1bc07b18b28a59df215c523c1c6a25f44ca816dd42f098cf77c1a970d571d90fb87a035aef649b32055ffafaed5ad0b7d44e7785189800dcf86ac06d2613442fc1e0bcd065c1cfc12496271b5db4959f850c2c010e6efa1b0e1c1c5710039c68acc0ebf794730ce209dac14f9038fb7670a8a0ceda632e6bb47e33c23e98b8ccfa80183a5184c412feca381b1acc5dd5435c166375773d237684885e7d1c36dd2857bf3152709ae44b1df9860a4d7777858077c6269bc26f18957d38d3647ea5c338e05ea1af1c4747a63f0c57f774f9f1027a3b88afb04a127f171ef7428a3330bd9e22209bb6b239f658c35ff47ead37f87983e9cc4ad2a05b36eb9a5874621baf0439fb87a65b48535934f9a0b548c60f634815fb9c8ea7f7faaac2a0ea6976790ee616c67db268854537286a21b65c471cf1b69397372d0587e27a09091c8f4b6fc750605953320dcb8d8b73ed2493a71984a9b05e62187de296189dc53a831cea64e19a968b3d7b5818e08eb4828cbf05236a0a2643f8ee1c7112f8d48701e217db2105198e390202127f03334c66918bcd0e4f72e885f83e04435d8789fe1c5a6596c36d2cab045fd39eb73b55fced549a7340bcdcc0c624abd32cad1885c7b8422d79e31f78af0adaa623171620bfd5ab27c463ae7b558d7e9c86e848bb281bf8db5fc6a355eb87e7d24b1465109d4261d103aabe1b3dcc0aba4ccd000366e06499f38dc23c0bf5e4105d6d669eec157e4978c9eb0594a514f1f3efc4a07b3f6cdb149e3846390f841983ff3acc7816f756d121f89c2bba544ddf55f4ca2e930696518b35f58a996cdeb626ada3b63a43e5d99cbca8b52b380e43dfdbef79ae3a62b93e8e1410baa522b6fa0a6ef544fa975779c2bc16d6b3744ce055073caf50faf5b854a5c44f4fa8ea2448230e8e1c2e23d0684a821b3dbf5e614bb14cab058e92a2d9178d99361bc1a5afb184b75a53fde83d936c65eb60749577496cf6419f2e141b8ddd7515795b0e45b67822ed3bd768137407530d58318f188e096c2796cbf6a6ec9c8afb8f4b324bed82b23e3402ca12920cd26662f649ccef11878bb23d663f837014a2d4132a2242c0b4ab370ab4aa577a1fecece8a8ad322e24ed60c251500f90b791eec6c637876d5bf9a99fb3bd70c79bab726b00a4036c8cc07df748d9f5fca76a6cf7893517b03aa0ce9b01731ddb497cba5ca83c8ad1ab4962bcfe51b52d16bcc375100654c91bbfbd5c65a685cfb2b7f3135418eacd312dbf5312afde8211348ff26e5830a7f4afbee63962a1141119aa6735ab201d319fc0fe2a5f9bcda7a091f8c88d840287c2b0fdab0644067a3ed0feea950ac3869bee6081a936164a4ec4a4d6f824c988749376073be2490abd0ce5630d8d0b3dd2b66e8e99fb5e3cddcae8f4152e56466f25c556806ed421ce8437d5d21f58a037358958b2737834d4b681aefffa0e5c310fbee6309aefefd1ec602581a50eb13f2dc55764d61faf16a228e876ee7457de65394907ababc942bbc11a6ff1a796ab7f9ac49ea9369e3042209b8c7dd9154431b96fde0796f3cc8700b3d1a846fe64142d892105f8c3e07aa84e750b7f35031ba25e61bec54261023348c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
