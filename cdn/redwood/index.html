<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecddc1a7311ab77d078712614beb469c4598d27480b1af71c307d2b9e1739c2950638fb316320f0734c56b90c0ad8f2518c3d7761de40f102f16501dabf76d00bc233561d785ded9d79a5319d7bd3456ef26b4afddb2a0dd6ac52ade15fa13e135d4298d40aa3e7aef5a7a643d94df34fe7567e6b79bcfe6cbc365e5503be684fc78b75bd27e50df658209e4d5bd9c57eec16f7d21d8cfeea0cd12048b75a2dfb609c4a2dcbbe5bdac62399fdaa32dfb82881bd4576d83f396b01b5faf32f6034521877a8807aaf62f6f50678a4ca0e0f2509403f0d49b448ef65b5bc2f7e04828daecd8f156f4817a94e044743f2409d897cdbb2cf1fc79cfa86b69fa31620a55e6c17076cc2aecc0b76a877104b7d9571a54cdfd7000538e159f1bb4f4880093a22a8c879710649373c4b1a38fd81fc70d43a970243b24b33df1cbe4e5d8b867347cb755b7924c2f92f18ef3dfdfa7969e4b6380c0dfea4d4b9963930a6769abc2f83cd3f02eb1e6b01687246dc7726bdfc63b3d87011b9cdd95c451da34d441dfa3de9fe61707ed84eeb688edd07a9a42b419dbf747b6a54fe7b5ad5af5de61f2af16e583b002074333b058e0fac5d4454e0f2733a367d3fdd2b7faaaf9a9d933bfd9494c6524fdcefb4706e19e14a92092a577aa092b6a7a9ce4943d6770297dc944a68ca0d2fad17eacdb660c5149e0b06514fe3491ee0b723aec85e75945244c2b98d21abc3955c716c506eea7f30a48e5d85c1bfe242999cdfb446dc86a228915d0eaf5be66880190909b5717d08e76fd4b33a61051c5ea52839b74be514a72eff1f7cee7b976c1e8fe018e783987e31d026c25a4444434325651e0990827543f2af0c5ccbd44caf1307b2491b64b72833acef3b26042fba6c5866a565f735bc81f7b23e1c0a6e9799258766a7df5dd37fbf1ae9b4053286344dcfdd6f937c751c50339dd4cf14d5de31aee6a4221c0bcd23c100623b5d76db239f9364ee4354885b5b3ae2d5f872341ee40d7b81330f1d3545e280671fb07f339b2a8d64da956d6dc9ddd8676075e266813d3ecb1c0a113f4b71e0fbccd4be62ce97d2af1d1ee299298f057732159c7d80d6b853c0c4515969055893331f0d74a5ab2128b6f1513e9bb1e151fdc7addf61610af471b0a974cc2f084a02cf39775176ef8c730772aa450bb7ce1944b6b9ef45dcc34825db4ca1ead14280c93b95c332118d9a659d799205157e26bb13a1c9a82042c5c164c8658e2ad30cf77c49bed83285a60bcaf609b2968f0ca13e1c24a29f56fcf5c10f0e489e7364480066fa1704ddd095211e42dc32ff0050db21f0cb310d7c773453fdea737f712ba3f83e118a837bb1daa19ed8e2ac614afc542b49365431a975c5e8ef1b28c327ea38dc50914f810f875c07428bed7f7d648c91f5bcc74ef28229492148f80c1a667d111c91eaa7a7d2cebb1cad6288a96a90cd32912c7b3fb84e63d9d1ccaaf7e04b2798e2bfe243627d00c8e295f9de284d6ddc097c70016a90acaecf1c6b2d89c1763c7abbdc2935e8f2f11fb7d758b9c3c0d3b7e760335cda90d47e384b1656d53e4e50cd9c2f03a12fe0ad6cdb2bc81c04d10c1605568c46eced6a7e52f7c9cc92d95f27754d8fec2e944f435c10aeb79cf0c5d3da5e62cc60554a0787a77697dc621c2d186bcb1b67ccc07b457b6dfaf20e0403af57b6923a1f64493ed5a12e933371e5b1f34466279003075b119f0a0f99ea76be4f7507565390de1a1330556778bb39024fdef72e6eb72d69cca99594bc85ce30fe02dd35740745f7b1f2e1d8a8c7475c95148c123b796094702bd5f9aca800ac41b79034491da879c2e4d28a29f12f8d52cb0500c69b5cb2a8f90480c8125a9b8f7f85a197d12b0ae4fd29754858165cd2a451d2e0e60f5d029bf4410bad155e7770d3acc40d36b3c3c5d4c08659fee8d73bac919f77471e46482b37d901bc3c565b6ceb87087e64ad92f0fce972851222e5290b13a1743f1000c96012b6fc9baa87025b11c87f34775f7e5f6d423284a0fdfb052e119b0596079c7d4822bb9d365aafad6bdb4de88adf7a2a361b631be09f2d9213d46ee60985babb049cf144918ca40960ce4c3afe79165a5572bec9dacbd034cc489086e5148c2abff215543559dd839962b4393113463b8ec73c83e1c3485066ba24b2369bbf56834eb2f156585546574bc228067b18047b8efe49444c08ffbf3726b30d55e736f092e97a6a2410d1f45411fd5dcdc03c17eaa5cabc4ba511c0337a0918fdb0db2655e80b9b7e9675225b248d6d466268dcf2f057f03a879394a2d27f22a73981d6e0f7ae9ff7a91d7657bcc297827404629b86c404f077521cea6441bb01457e4dc5d13086945176f59aaa4fb4299fba61bedc1b1839e2e7c958d5178ab78e26b9a7cc0cc1d2c6ea70acf42be1d4998ef1527789e8e395e82beb4cb2e1895fa3deeef5f10e285cfc8a96ee3920965a9af41655d1a7087ff9f70715f6b84884e4ad521d21d1ebf2835b621d7a5af7c751e045661544ba614be177c046afba922e1abf751043f0e5c16352e97082fcb7f73d55442bd59ee8573e88110c1308e9df9cdc4ce8d57d89d10aa9330682d7639a85b631e4316fae16510bf18065cf040dfe3f9ef5e68d750b6d957863b746e87201610321484ab8d1a4d713d077d627433e5ce451e526eaf6c2b43219a442f526c04838efdcc413fdbe3495f434128a42e2f276c69ca3a6e8d7fc13658e025d3de513d3e7e980a49568572c94a6fddefe0f8ffb2b158155e4bbab595e992d8ac78f3b6df3931baacc2aefeff2e91c75446bed38dd092be28d88abd2322744832b43a85171d048f5aa3ee58c5c4222402ba2162f59db7b67f6645146051f27358bf52da8ae04d93a7436a69d63aadb320602fcc383598ca5e6da1c7efc7251b3bfe48428c47768dcfb5b55343ec66f25febd175bf696956379c588d9173f9d9e85d64cf8839b79e552e584b1d71bbfb9d8ee88ecd4d35e1c382da8c8f54db4d2262dae8e519f230218bdfd9634e72a08e23e51d9fdd103e4a7d9f0f4fda1559e86f1e3fb2ba11e2794c9afe3e7bca9c9249bce68c3497974a17d2f0cfed85fe2e454f8704bd58ecec9d9b61c391464856d4bfe06c84cd5224de729146ecef76686c2cc50d429b6c71f390c4690c99a754c7c4d61895b7207a2ecef432180d7109a127a223cc243020fc86a39a5e7852d7eef7f1758a5ef38053d71cdf3038b2d391846a979373eee7e32111fe1d564afb7b2cb9dcce97274d24b0eb3725e1b0bac7b19f6893e87af44e1b77dfeacb57394aaff85fff8301676c43e4111d28262e952e0c4b93ee874b8e7b0bfe24a5eea1b5e17a6c31191c6faab54a922ebed3905f0f296b30a283f271de0dd7aa183d47470e9ba8b7838222cea1653c2a8ea10815ad5009405bb7876ec15a31fdbae32b29daadaffc1ea3688efaba570a0e87af2175659fd905e4d8fb30c44e31a654b703f6a461620edf8c4dfe11468c837f0fb73cd3d10e0ac7d4415fd71e0b74e54feaa596fd885f6fc0c617947da834f0bf4aed8ccac6f02b3235ae187de7adf913c56fc7c91bf499dc476d10a67ce04bf29ebf6fb0d70e4bd776e6c97ee4a6ece337233f2ef4e19bd7a268a49f1642a6279867484fb4c88823d1b436fc11e66b19fbeb30a34ad48b0665ba2f67de314385492995c7bd307941e75c4494163b540dd351ad3acb5d314dfbad3c58f1b14b85c10cd894ade1e7544188de42c4a16a683db4c3246afcefb1deaae3d79962a5113b29c57b73e28c114513f3c5cb1a12899ca21292ff0ca51898a736a9c552f58f56473ea6a8dab89d44e826529ea9bc365a8b949e1db7cbb8611190c630ee54bb51b4ac9a09cb72d3b6085c011291a245fd25da4763be1997025ad70b6dd35642f5069d152794c2cd109fa2d9ee8930e69485f871e2449b2df8dad8caefba833e66c3d1d3e3ecf8e53f073cb45037b53559b21d2e8f44a312afbec7414da2f925d3adb66a5f23aca8a22d010d5ca351be0c00b7a43a142776db9b26bb37a4db4c4e4451b3873cbbacacec1102a58dc2da85f7ed94d64354411ffb8f082cacae7e93d404df1dcb8f9cfe58444aed4c492ce896cf5e95dee2004998ee44e4daa56f77ad58523ea8d40b61b2e25f5ac7657831f114fa40e8649c7be630458a414906242f516674e02e4fab738310eac280eebed3fc51280610406940c751e436c64fcfe1b239b949b9c0ee899c4bd5e647bd9e11c33d46ac3ead0d245285d68f4a2a9afe067d54477c8499d1d39b7706560d00a9b93fffc7cf5ded1feab22787dbdce9aaa0da85694289d3f53b970e7e93d263ce7eb1963c2874a275f5a849d5f6fb39c70e58fc5e10ef04c07049fe8d2a7ce4fe7a4640517327214bf3ef598ad6b34f4527ba99c6e1374a964fba07931b432a40f13a14036af1b34024703c8d04d370780ed8c40f62bd3ffa3191bc726df93a765527a613b4a0a2716ad5c333908a8d0944488b582b4055db0841643dab460be2cd20d889046d49758fa4cccad1c09d645ad7c927ab69437241d06eae818cf1fd457b7126c9cb979604a84e9c9d8a8234468957d629f1ee0b33987db89e36f058229b7beebd8a997ee3ee70657dee8363d30998338f64867ac93757580fb74b493d44f9e6968614474cafe13e4fccc74753d1c80fcbfc7d83c455e90b8150f8e4464401d68665d0c83f1a3ae10bf60775b4c01e639f1ba0432e5f73fd2a510cdeb1655cd732cd67b0d15fed7f18efea9944e823aac7b79061159e2e8406b3ad40e47aff80868904abcfe6902e8da0ed09f219790cc160d1d99a2c687fb850541f01027d48ba458526845bfcf3cc34c3b1afbdb19597913a27d7a7398dc90e6fd96040f58f06af214b6c75d7eb470b96b64765473f44c0a19732c2ca1b41671e9bc8ecaed0767f59e0f8d10f7996e633407b155725ec58df41adfd5c94404aa9b2606dd77029179431905f6538143b1c2aec44fcdbcec124ef9e338f79ea25a985271415339cf15a8fcc4dcb90701d95b64ff12aa32916536e1cd4d5ec5f8eb24fe4bae618739701400421cad1a84b7424a4fbcf992acac31d27d2cf1924871271e354d40e11ad7a53bc821588ef62beb8e063b81382ecb6122c848cbd38fa875a63aea43c374bdcc6217c1ebdfc17b47a61f5c0a08846c6c108f1931b2cf1542689b7f13dab1313c22bf0de4c8ee59730635f2e6ba7649accdbcebc131599118af076d60ce01bd0c5ce77f2f162e3df91bcee2871d93a8babdcc4038d1e9299a758e80ed91c2bcbfe629f18b42b62b795a75ec6b97ee569c5c33fc6c258690f83bde0c7496b5443b369e2b2afe19a62bd4eab00f5140a7f0816f0a3acf1a897612ed22beb3d2b1a935ea2e3727cd41ecc62c53098ab3989231d62e2b3d20e65e8ab7a6a8a1b01dfeff64c0c9052fe098096921a5f0fa3b30f33af5c13abd4d6aa93dbc752d3529258bd66c495fa2f05125e7b724f461dd904926bd1dbf91fd9308a7eb1e824545c549d5a45d27765bd1400c6dfdf6111668ee00ec09914ab3129d3aa028d9d43b790cecd54de9ae0b8775c94a7031d084d107c7d2b17d442304cb4e3f661701d41ede4c4dea70cb55e6973e37d5ab541c47543fb41481fab92889af9247352f99b8da379c10107f2bb64e058c4e7393bcc66a99dd21f8fd23b5246c051e8951d50919799ce09d962799eed3f912d76c148ee6e6d1f6110259e469ecebfa7ecde72ea335a9beebe19837d787cacb964c9822c65fe2157037d159a227164b9970870cf823d7321c6a2db4f6ea52ee4921f5d2c891c4ed839167af39a5eca4e888329039bebdb758e8c89058e543562e7b139e08fdb2890645139e4dcc2b0d3cfd3125d86fc6a6c33fa08b3c9eb279f5eb776fd0a16aa8c327b42839bb1eedf7c4ce0b0816841589d4b9009ae0fc9c00839d78269bad0c48fd4b5a10933db70dbf888a94e5429e245899f2906c3dea9e2e45c88aa597494ff3175287ed15be867bcfbd46684c6a88caafdf6ed17cd7572c79c7d59ce3c81fcd9f6342f1c698eb04198d3f16d27b46ae78b3238ab0a469b53f1ee9d7e881dff58191b75b0d3d6991308d1518ee75463c8e51e06ec9d4818275eef575993f1816d3ce303b65182dd019e28a586eed2af42cf9bfed18eb3d17d3143c315dbe01fde5e6b6d83b5e4973f3379620cec57782bb089b4b7785d3be2529a31e783ae1641d77b487018c6420b003fbbec227cd6a4b44b4ca53263ab43f26b9d3e33e3bc085fb00fb011ca8e3e433f02bc2b0b09c78cb1a12d18523b04abf34cc5a4f9b3cf1a9453f34f2fe4b0f12ee286042d5f29383c4be95b24b19712f5586ca98f3abf9c88be0def3dea1f3ba848bfd9e561e39722af33ebedfe4af6c9d2b1975eaa40ee832e579860157467a907fa4091f0099e372c16fb391aaa10e89ec884b20cd478389a39c5a83a2bc88ecb940fcefd350b29b937f3810b0829a7bc96b2d1303b74aadd86e7dc793ff62fd325a7b6b1802e755c73c68ad64da4a60d309e57f37949fbf4f7b71e4a43d4ed7e8fd2c008b02dff70c295560aad69c63f386b010a01790d07559d0e2411ab5383be0aa6057c56664a7b59522e2a3dac377ffe31748d66ad5ef2295d9f94ec3946e6b3976d8594b911d0f341712adafd7b59f733db589ae4af1cdf185f1a693b96e81e4376443ff7b20e2b701f6b1b92c33619b63a2391de92649db271258916f713b9ffa8c7e12109a97504c80e9f8176ed3cf23174711a59e4885625994050d24072d0b32c984dcd5ff1a172d84580cf700627d7e69e4d4f8b0c7a237035637fb6710558b04ed03064504b416d803b0d375bdcaf21abbe305a01242ef6376d8ae8e3680ef73bba7c6356ce1adc13df8215c2ab148927adae2d664141ca137b876d0a9b929fd74fc49bbf5186266592513b0719e30c31fb2a637e5a9438acf97b4e57d50439549720e1fd6badb9808e74d675fc8114fa792f7330dce7ddb25f620f83191fc6bb4aa292a507538aac95c7f3734a9591e8c74f6d219c3a51fdee204fbdbd3e168b329055354b5a6c54eb892253bf29adc66cd1d9cbee739b536ecbddd338691ea96f453a27dfa1723bc3763bc64386f44a5bdb48ab6c7eb1960c1e22dee714252c0afbfa027c1b16491f3252f380b7174d0c29d327817542a2d3840deb05bb6cd16801956012edd3cd3bce7d4fd7efb3b1ad213246e792896f9e0848e5bdbbba0782350a139a076649db42c0b2f730220fe808613a5939df2069d1cd4f6a60ebda3da84cf2d8fbc907aed6346602a0241d8b5f21d42dd003d844de9e2a9a0d1d8d04c71eeecd86434ad3000f802813959309b5de366509985835abd203204ad57b12f95d80f1e01757cf853ae6ae73f0c5e4640aed927883ec180f89fad9c34fff6c0b2feb949a409490afb32d2f40645eceb8af96660bf88f9ee9b1eb7892c0506748b3b30c18e996f352de48a4f85745c1f4472f38a2e1ead98440debf5e269ecb113a552db6180888dad736701e93bba047035c829fa3d398226cd51d20eb4f6d53f7af1831e9c92f73ad020863f65f8cff9da38884eeb14f2338da1310ffa7ca73534002dcad28bc4f92707d9472015e904e532df67d72e27ec62ece725d1559a9980092fd9aeca04699eb80e931f305fd9e3a5495c00dff58fbde664311f4a94a40cc9ce4d06f54d15faf9b8670b369ca84f8395f68a32168b18a6b9fda4993e443af8c9640492c03e06b3eb81fe4197b829d9bab464c6bfe5dab686efa5250a9be8859201cd99eb3675667b3c9991e1aed4716b781d4d4571670a32091adea458ebd7e8d8a154803b7aedc993e05acd3b6ef69ef9a2938bba9a21ee78a6a0aed0715c7ac0bcf27818296bd3addb7b2b0e7d137ae35dd093ac6983fedbb7866b05ba91df6eb831fdd71ae8ff9d420dcb89a9859b70e6c998f01d24995f0737f72323de5e35dde9e69e53f3871f62a43a0a31dca880567756c96829b8b07e2a40abf49fd336ee700e249a3af96a11d05feb9b677e878dfedc3f7b7f6e5f74d4afd18b8192109f56144f80e8d3c03380975cb85a47a896ed22fc57f554e74e5d0c699b752085f282298d18e2544397d3c45ed09e6e9987c9aa481d4c5f3537921ac1b7bbc239e5898241f5aa747f40f47b72913bca4ae8f496e14b778a5d74966d8358778f8074c7f80e2327eb02299070e334783f6cc2ffc7a6e9caefa03f6969da7923831ebcd6b48aff78c36782d8a424ced35211e6df7266e05fba0f0c591b88f8e09f3274ae8d7a052a9a750abc497045e7191f9d07c3d724f1060de3445d923707d2b7290eac3d72bc54a552e299c625438457fb9531ecfa915dcf89000ec548e36c74a7c22c5864c968f661286a74dfe302c63af955f13ec588ac0ffc2ffbe2c3071072a5ece94727f57dfcc496a065052c6b41b489e54d29107de1207fb446a386cef3cfc9e4d6123b20b67cbe6acc7ab91b8be4fd3070fb428490984422c31ab0c8e1daef8e0b525fc0bbe16d5cf79687241fa0dfaf1ada564b473dfe6db9c7f044f34f1faf2b738f53884f2c1fbf4691133c80fefc082d3a825ebaadf0ef91808f2ef6ab6fda838c93f3269aa3802d3e17a1fa40f5ce8f785e1420587cf3a1e82d3474ff2351658797e5599dceab975475bd7d31bcaee924e07cef625cbe96dbbadb3af6269f6f94bbe023560cd78a809f00ecab93ffc91309223d8c8a29588da2464baced142b72f8e6e476cbc26859756be6984bd46d1ebc7b897c2388a5759c9fdf214aafef7bd409fc28366dcc5d29599e30b411c6a65a24f48c73f18bb2b71a964167d452fee3df8e0cbb1ffffb5048d3a964a29ee185307e68e2d98b9d2c8889bfb7be205cc61eedbc5f8319e451f5efb3804b3a8e4da09815108a8b129c94eff056a81454ea39d9c69f8baced06cc1e2431238de5032a9563dda6e9f8ab16520b071505f7b7187015aee503a0272a81e49e0f52bfca71adcc3f7b7cc23c5ce539a449c539eb717c4d2d992b07a1a61d9f339c8a9bbebfdb5acc74c4fa93b826325e3c5b7d9e7785d2c0a92ebb0a91cbb441e147d4f9da8d7d099d3d58205817a500df201be36c9986912846854e39f5cf1dbffa980a9e6540e078f7cbf365c0a4e12e03d9cf7c86256d4c7b7210c7a8458473c71f3ffc5f5824fa48493a83eacc50c4a98a381e5acc2668f48b0dbdc43e83b3e51078c5b954df8a80c17406e8f01da5fd6c55657d1343116e54f31b7bea41d0dbbf039e3f8655b249cd567ba09d1da31dd9abe7600a2cead37bd241414578f4131fa9832a633086f3d8c4e9adef4cfba7b0e5926a3308ff8063219f79a839d05cbca904c240596c1179df2f8e282f453b71c41d7279f4ed779efb3c71ea4ad7ce7d28edb2e09a4366279022fdb7bda60f36aea35012c9e366e03b5da70e0928374472efd0fac86c642faf58233eadd9926f0699ed68a2115ae5b02ad1d9b240247a258afaed4e19a412980ca2d1532e3ada2cd291f73e2c1d621df029e6de964d9f9f72016398c0937918bb083d8772d8658545b8deec403ab3ee953172f25841e71dbf2cdd67f2404e98474279378ba6ebf51e2c65ba61c2501b03403c019e054ea7db0c24e7e4eac35a5de68fd34aa92dc22e0f9bf83b3a216a576c0435e040f7da7221a2af6f1bdc7d98dff235b6fa2e27ff18eaab718b1211c1f4e96459befe2d35599482c79b047566de5a2c95062c78bc36e758ddf0e607dfee44f5c7afb6d11b1035eb27ee4f9c1c366e9762ce4bd1eb2547fb92fca2f86855175ecab9299d71eb61d20f6f94c565ce0ee89e746360edf970e5cf83b3b57658702fc4a0c88e43ffae3490412177633c7f0ce2d0cdf12110324e066c80b308f7d228f21e983a2892f23268eca8f9c2c726007aa7428bcf83d47beb12330cd1d66f87f73bc31096ef3d280283e0416daba419a642ff673fe0b9f84969cfa69508c54160c7b121c98c109f4eb54048adceaa5c04c54e9da6dbf66eab820542f5b06b4dedb695a5e19473c61df2d8578794432756a25c2d55bb6d2cbd97565242072c37799666620c8c9305b622443d1a66e1a40795bfd61f78482171922e5220d00aae85659db6b0334c253b23f286a3923f0c468fd70ac9623e0a5fae4f3bd3e050538dd3facd33312a9d687bd5b4d3f81906038a422454f30e670580ac2207f934ef3acbb1d91f7b668abe5a3a6f9ab783bac32cf982c027b4ec579379bf73428965438285b6cc90e495a30a540b7e1f912f6f3d77b848877dc4cb7b7f159c5f8eebb8f9e1e3c9dbd7c7463b4e2f78d30f6174304dd4ad456855238921de06ae34f6147fc68e53777ec064d278c266d00658d07286276609a65e4fe9eec13f095d13c722e30c7ee996c6899a552e7a9819d5d980193557343083d8f7c85aa4131b3578da229f55cbef882a5b46b9599abd0b84b72af0ed712492d7a68f41829dda8ec11d7b9a41393b9e33032cd39a87b4627c220f29f75f4116f6b6655f9f32bb04edf4a1ad6b8f9d882a084952769256c40700ea2e89b47e2ed6c67ce4c7f5e09158bf087e6184cbd8995c4ff4b653fbc95bac9ec8087af57f7c97790426f1caa66fd1027ff7bdab351e4b4795108c3886b41f97d2b1664496ba2c5fdc1bb5b4d369630e5f1ad1fae8f6c2df43b3014b3e623686051a7c28e0d35a756e1dd4f68c10c8a19a7e166363cd3e6be4d462a40caa593b5697a16bd223ba98c8f8e8c7d4c6f6ad71710d0c4ed6a421045d6703e36ecf034a5ec02ae983eee5dae94686941b5d882b615bc7cb862b4530e2b3ad660c76e61d0bdc247af43f0548c7935bf6a3283d2a90d3e0a708e4eec8da14d3a1a60ade0c2344fb6109ee188bb1f35370c7c13351676e2c247069ca19c3145200501070423599dda5b9f7bb49828c74281be89aa7f74fb066aa8fb78059da4be31ee35d6d08e09e007f028dd93c7cc2d108f0195f0051544e8efcdad01b57edcc5c2572b168ba2020ff7cdf3e8bc479a409224c8c55759df51db88096257a7ccf357275b9c4d3103a1140fc6fae4ef9fbb531079c09d83d9abbbfda1e4e8e118c00169624e797085d9885dc8ab16cfde7bd6385853e0f13e81557d40293387bd2d71df154bb73f1d4b8db98581896a002355185d792e5ad669b021cad2dfbd782b28bc5af4cd4408e5fb9630bf537f6854e527a669f2997afa461e55772e0046b265e6e23d931d00b386b10e037f27e78b01b0072ab66a6c37a5db9b831935b9084b1b4c35d4dd79624b5cd010f995033e66d0c9bc171684074f7eb83d608a6224088a5d9ede46f835d60be9fe78c86361abd28252e4329a015dce69664cf6db6bc8f9a346d4b2214d685333d859d0a63be64d81d88e87e5c66905a997965c178f40784af34a8643f36f86227342b6b76642b0a698db29dcd5f9de2f6782980027d88b401300374143ca742e858038abb3f15a7ad3cc97e310f96aa132dde0cb41dbf2b88bcdbdbdd3ecce9e9119a54da4b50e629c26bc1b8cf7684f9e5cbae32f32ea0270321e058408b5f67902eeafad92c12b4201ff3a00db296650203ce5bb8cbcc8d0a9d2ad0c635161fee436996a9f0e8b3a52fdd48042d83bc32e9939bdafad250e080ebb5fd86d855826bfc5b3224b031679e64afb21e4c6a7c857bf3538c8657dc455363b16b5be27b60608b1c6ba0df474657abc001fd588d2038a37ae7eabf9332e452f1f57e51304de8c82900c5e57492829658bd68e191ca57561717ccb0952502c55b67567d7c34b47977fdf49c0ebafc3e98b18896f26df2107694ea6438da00a091f5033edaea10acdf026756104e7d86f8567689cc2ddfd2bc8f6cf5507ad167172adcdeb9b38b46fc68f01c15bb6980b6e5fce52faf2cf9284d7fadb7e6753548cc9995896f433f72105a7ac96097d271a1763acc4ac7a0de4b3dd942a08374dfe18d6c044e1ba21a8afcad61f65acf95ae15a2f0f3cc724fac8f619cc587a25f94755e4fe970caaf3dfd0fde5d0a1ab75534d6f766defcb3db54db849065b9daad5351e1f405a89379c923e36fa75a878c3ebde38bf0f5f329910737284c0c30a941e7f2540c118e5aaac381e0f81d745f2de887d4e8eed13d14c5dbd190c490bd3272ed1d071c878a91591001dd04154bae5a5a3301fcde1cd0ec208bdb4394737d1cf41e8b46dbbb9229c094197f9f5189c8e2fed95dd8107656988756d55ae3b3811096dee6f17dcd0f56995c14f1b7fa3c0f17f2aa133e55b9cbd6f6921cb69ca0fddb179fa7e1f05c31fbbebf395d2257144be438959e5885343b1884d5e23d080db6ecd3561873625149d5380420012db88764a796262ab230c7ce40b48e70dbb61da0cb7a6e761e047d38ef2f81c7ad6da967e4a9263aa1c46164000146a0e882bc44908fbd3d3ca7cbbe01e29cec4fa70dd48200e42a702f41ce3ac7d872a63461ca94c7276db945126496f2682055c05b7f956189ff655b2ab07d7f9833bf2f35ee9bddb97fe4fdd9f3e18d8151d3429ed7d1684b1ac87072085bb159294a81cfdc6d224d929388ea8eacdffe3fc3dd08452e2d18e66eb935973b3432aa34831c3e00a677dc2cde167f6967658d8820caa43cde505fe09dabe416aec5255479d1a2708ae0a6c5c4ae0bdea10630a6b32f5c14a8eec1bb8655b3e64d24cffd461957b614e1c63873d657bd810cabbbcb64468e2e62ae3d736a1d47a3189c00ca06f676fa1517ff714706e8c5bb9536545eb2df2b8dd8b03c165019d148ea7886f1e5d8e8f843d9c561a7423bc7e652f853044278760c089227a9c6bbd01123701714656fb3e362359e69a92e42aaaeb0c615dccf940573e65dec5991c8a771c7cb08ec040d4d96ccc02333b0905368d8bb6acc7f1c970fbbedf9eaf58b0e8e4a4b01328a60272c94266e8bc1a12085296b6309a0c14a5a45dfeb7ee76603afcb8c6d22f61edad1c7df23d5ae35f889fa1f1a10a6665cd0e13258905014608185d42b2641125fa9e0a5d8c238002cb4b2e391f6bc18bb35502196af24dc04151c809aa32f9734b1d4fa3fec6d8d91af2d172fcb862983249947f41e6e3a62c3978214ef0287d620facfece644f1d5f355a0a96158ed16e3fed170470fc32f044b4599b6c37b12afba56c1c7af0ff0c70a19f442a10f0654f4416c0b10bdf695bc1e799b5f6660f97f5f015eafc22a813c72933210e7491a7567da47062d50e4bb463d1bee17ddefba46374eb21ac974f99571dacd2d749c21266898d4b75efeb61c26ff28b6cc78c3324dd5b5c8c0d75756f20569b4aa37e7a41b3ce05c33d20e83a9ebeb99824f97b80606774aa2f44948f33527fe5ee42b206a9888a829e73ee27cb942f600afa3cba030a30788b53860e40a923cff8b3ad0eedaab845b7b358dbaa23e8585dc6ef793c52e5ef7f8e9c440d8490d743fc99a9e42dc6f6b1b2075959414e913b5cb6009df0f3a07e348fba84a12cb0180cc17c96b06cbf8bb5b2451641134a0f0d7b3c7438183a940145fcb12390b52a888e88ca49d7f144c6a8a0250b519694a8e2f9a1e09e855798b0b717eaa2c16220c119b0b82278e1041b0072a6fe7dfbe124446e5a946bff4ce5baf36af4f59da674f4509df5fff47a506536271239ce1e70f3a5c593d44a6810ee645d149ef935bce5cdc00a4a7ff6dffe7305b2443382c8f27658c1bcf99e8fa36fe976fdff6dd217b1c602f3deb970d08b3eb76b46776c2415b7f46ba148cc2b0da81f70c74f10821b022291fc4b0d9bbed46b6585bf950333433a6a51fe3380d998c288483d0704a70cc6d3d429e9fa12b82d10b96e721fd1f7252273cd4ff2ac40e14be6548f60d171a7d564dd618598fc087ac4567859c46d055e6b01a88350058e4fa4627b7f6f186241a300d060c7b9e69f7704f28a0f61833585ebc8bf02b71f8111165d78180163e2969f2d624e8d1d4c395d4311241a88e17d42f29e737aece1f345449c0d5e638c6dc13498c2e5108c23df3444e6097a0db9baf8145d0cd586e27de0deb90daae079bd2abd5cb7a8fd249a954418bbe7eded72cf2b83dd62bcccd64103a9ab1edcd04528493276ff7aafc52044f28dca0b40eed57181d4b3a050a85954fea73ea5dacfdadba76cc5ae20d9de4f545d21b6732da51e50b2065280a4e75a656081167bdf5f3e95e8f7d3bf5a3d47fc792fb75ebf716e70319d84687ee536218ca07cf7b0be654b2581dabafb7b2285d5a0acbac80e5b7f317a6e3aa6bca45d1b4ee6d5cd3c47ceeabdc9236a7c1878f47c321df23eaea5e2a9df679164687f0e5783e4c138c73219bef9b21839fcef6c00eae2581e7056555925148e43f646faf38aaa9095e024c55be38f595d03fcb7b331651e1fc7932239ca877d0410db65b5c9fb2ab91111236f3bdb9a6f40f09980c09f898d25dff429c23a2c7265401af376e8b54e407791174600801ef67562999efec95351bae7e21a24ec4912877240bd9ebf9a861b74401cb9388daa636fad2c9d42dec31bfb3cc7e22a3664c4ffe5a39f47ca94b36dee01acf0f551c713e71cf7c278024674f27fd9a7e75934c49595fd4348f898aa7e336d83d16edf960ae8e7d846af80dc92f780506e3ad90c150cf6fe4dddfe2d276901ca072510624492b73ed3a332e7b5e95c79d0fc9f2fedf2cec101de184e718dbc3f4b1760ab9da6ef3b886afaa02da1dbf7b96547ec13f38ecf61e5b9d1c3ee0e4c02b38129d61a8676c972de008955bcd0c5cccdaf0cc50e6dbf3cec7d1d5f04a6602bb5c3d64efe8e478839672b09cd3501b45be7bd9b226e0c516bc3a89ff7eed5cb0815778aec5796c6ce844e50b1c2ea2cc674202869df93f26ef44e383017a8fc2e475bbc37bbf27dc0fd65d3ca0c52f2bf553d43dfb62cd307d164df5f1a1d42ec6d3c2a86093f7eeacb8d3320ae28153de6d9ffe803cbc5b0f70c304e08c95cc8dd4b846a7e08925251dc921696530e59504896132ed44b56c4b3f07af255dca17b7a555f3b6f1fde66d1a11d4cc5a730c601c1e7f6a0bfe62dcd515aabae99823c2d0e319837ad154182ede585081ca5d4628461fa66fbb88591d14bcf31de425304c799bab92a481e87e426d1fcc76685f48db2da664c699606389bb30ebc0d0946e3d04b4c7045fd22f0f12574677976b507242a3e1d256391ad6a079e1ffc078c26ee8e37aa19f106f4ebb709265cc579ba1819b588da512217f16303b6198e804f340d55455785081978dc540900f6695f95519ca923b25f67daee29885d91efe0db884174df14f3d8708a5a7b4e2515cb574d6d9c426b832e257c502eddd850ea9b5063828f5ca704f7df3a941793f354034ff2f1331ce7ae1b9e39b9ae9b455d8af1f3ba4c1bb37e5756a42cd6cb68ead6a08d2eb2982ea84160ff76f7d17a0aeb14022c249d5115c7657cb92b197f955b8ba48b829e1a842d2dc1ed234a2b56014e0e940e759aff7c84a55c2a04770a35e987bbf23d38682e179da56008bdee3869a9376a03ab38f2ee1c62a1f94332dd757ded42c1753127e553949e4201dc6284046a9db30a4ca1c6889e4d72b081061aeea28fa7964b0a1e2d7776628d0c39eb651379a1fbfd3af10212d2d0aa5046383b0cce6959fff982db7098ce90ff86183877955b0364fac192daaf561d0e8a8d0f754c4e715ae32f8f2282db0057bd47a22099580e60b8358db67c3573ef4c6f17f451390330a9b8da53f00735f0e5bb5eb40c416c16d02aaeaf766bf2f8be22c2a487985ba3c4c14ad7c48d6ddc18831178d14e81989c43eda5c6c93d683be26a38e2acd5fde8e09aa67058bbcea6d5d95cd5a65aaa035abe5b6bffbdda297e430f7857c61fdb38e0a57ab6166c93e3bd1b2da7902ed71470ad1085b2d2ea1ebd5f07ece28f76d33c5abd5a87fb3ddc88b2a87dbb80261a0fb46c4a94a6d7a3826427bf1a1bbb15ccd770ad7237cfd9e39a67fd78445f8e86b790a4c71f71a4c97c32c7e3679188ce58dffa20b9ba5a8a5df3b0611136a36599882584f913c81e2285417f69facbc4f7853d659122144d59f10095b2e0b91c31804d5e5e4de5be7c9b4773b8f3f8c558da99755658563d531488bf23d17402a859a35eb52c17d77c433c23dd3b9f78895c9e8eba7aa61a9a9cf188d7fa6249a626be5b5a64e06a59db17d1a82be8248d9b1a5e212e2b2b53c0c69e4716f06be591a587103eea7e3cc6c266a5abc73a32560e077e2111ddf7a6eada98876eecefa3f027127a02e13ed4a5624ad4666737172bef0788b5cd3daadeffa740feee9922c9651caa5a3019a2315ac959dfd2d7528640eb6084d80512e17038229e0032d2b7fd446c13b19b43571a792209e7f47a3e7b78fd3f304a8a8bd32a2fe0eedc0e4f8cff85dc9fcdcaf085bc9d7cc9278d744ca3a3c75c023261d343dcb687251b8145d91f4ec7c2a735568c25aec5157fb024aae772a3ae7fcaa5225ec608e4257c2edddddbcc5810df7e68d7adfe409cd08db7a2c678e50c409899dbf4b199cb18fb75456343239e5462ce9efcd3d27a2b523684f61226f94b3c93484f731cc7fee973b166b4f3ba3b021d3ef75ba3a6155b0f7393cb7e976b4dcd778d0d8c351192d878e28cf9773fc9314fa45004dcc8a7bdecab453a30dceba88ccfa49360a19f901fb06d2777fcac52f4348e4936d8231900fa2da269bbf0e36ed84922b4ee16d87dd9f3631f4ffc97e2d42d8edcce716ec5b4eefe270807516e06b6fd18f8fd3f224e159f794602e94b6b99208d7d5fbd53480cba0985fa630221f63c1a665e298922fb556f558fa34ec96815def60eef3f0239463063019a6141e1769581ab1ea756bd9763a2c473438e062b7c1ad3cc9493e7d9390e316ef61c6a37313f4c9f796c350fc027d95cccd556a7fef1b466dbaac270446cd20f322624581a4b750b9a8d6eeccaa900590cd6a75bf372987714fa4ccc77d5136ae68402f43b31b9f49865dd7b629e07bdf7a171f7a833d619d1b58d01780f554dbe0e12beb2aa04721606ab7a02bfc033dfb85c76a47e85f4c3822d155ff4656007e76bd574f4c8c9492541b159ea39c7ef9db5a44f08a5a89232daf50651f2917df8a564ded55c8fb7b7905a46d7520ce5c372cea267298354878f5c61e3dd97803058991f07a72b9efce987babcab7db129f68486dbc14869127e46629446b97ae3b6858c9a514061a9fea0e1dbee5b0fdb9674255686a77b37df5d197a921930eaa7c4f95e42f9c23b2bf5e67b07ca3e4f085ae5abfdf9ebfb56b6af45efc45c7b3b0f570935f79e6b01216ac89c2b1a850c9dc16b7995ffd18957a3f22f95acbace47eb8ca00903017124de9437aae595c3078bda669dd778f3cb256076ec57a67cff6ecda9c573f8bdd789fc2ec7fd3c626c69ce3d62ce674fa2553e8157a6a88e0e1b4f79f0a56ab9b31409bdb147ef4cc379d993f94f7becbf9153ae19c52749f71f3d0e484076b17722e1aacf591f1669f3891d213c3294394a1ef138e618d5cfee3b00982edba3f387ed00ff348be88dd46d3c88974999059e812c2caa555c2434c4ee0b0ef9b917b75da00808cbdb85455c61b6b83018a1fd4de9cccf672cf5d642ea72fd24c08ac7b6b83d2df3dbfd35e9ca283105b4a801e9a60a833580f3071e2e064876ab5253711c3df0fa654c0479b8165b33adf70f98c948732ba725cbf76b5340f2467c76b2d32ddfd42b2abfb1f44d397e2f7f9cd5b6e90fec395f2f8bf6f49c6e75ddfe800cd5a6a974d1a4291c77cc78582e280482e82c14ba9f650af1ba7e0356e7352e5b4e0fb823813d974516ac40e3dc48840a7331efd40e2ae46684da2a5bc3c527ca704e99fc8873e582117e5ad4894e8b70b6cf52dd906e46dde1aa73b9ceb4e43fddc65a93a1096dbcb355b32f1c14b47c17b3eda200806896dd20f45ff3c2dc986e94790cf7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
