<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67d9f14a505690e1a66e71d05e170dd16753792e55f1ea015886fc54e6f5cd846b51d0cd5ebd772ca47ee54ed30db4ca61a8c1f85d5b100e66bd1e61c9d06ed0a51da33651ae1b92b3f78579030e8a0d7b9717a2940ba04d78a3ba26e9c832dad84912e53606d0b8515ede35cf5e58e81f41aea8cce813f3d3f1c49223398bb93862e7d0dce376734242d513a3df1e9154625a0a4a96345c3d1deeefdd11793fc2b035732735aaee2aedad70c7da5edaa20142f3188689485b27927da7d69a2d2c6e4ceed91dfa616df38fde2c61dbf238cc89267a8e3ced42d2d03b1c15a6f75030e5ad72995c6af0d866a3ab4514de6132f4baf936515604cd94ea894a65a3aa0a73623d50617cb3e9aebf78b9e5fb216e2aea4839f4853296afcbce15d5426380988a3b2c46568dbb3722b5eab757ded3871a172b9a70cfd3da20b1cdb961e91697d8cb6084d4331568ea7c48727b23a80aaf9affb4ab141b8a8cc71a4121a04f7e6e735bade682300010cd3f75b74b2c24d829d09c56eaa0ed3982c82bf1c15cced26308f05a0976ea0acb9b0ce169a36c12039d30e9b00f3de00964203d2430fa18e4cd23f83a1c13770626402b6b6ba2bc711c31f1f7fba4d0f7bd499d3cc3225b20a81b72c016ebb9a8fe416bb832a05020965b8868809c716cd1f63dd48e0f423773bc9ccd6ec711bd48e781f376f8a463cf8a3db5630612af2d5776f0860fafee4c9477712aecf9e4aca6cce1cb05c388baabac95e8d16ac256256859784b2358b328d382ef23b8634d49828ffd7e50bb04611776b7284a951e95d6bea39b9a6d3e84d5b09d2826dc15a596b2af90d52802e30a1eb1e6646d8189173315b912d2e7c57441370a1d0364d39c244b3daf5039bf562ee6d01da27e31a07c6e5611ca67f662c2bcdd9541a9b3a1edbbcd0ae2ad5311f5dec2680ea8cb12bf814520ac1585b9a122d7ccd79cf59c74847ccef74f48b7a2dcda642d0aea902b76b0485b8d53d02bfefaf6fed1c52ff31466f946c82c3cbbdf12f695b148c370f8e317f39bc5dc8762dc8d8e359a2d5c2342f91c768f22b6031502252ac7eef9c118ee4dcac825edab73d39cb200b2aebfb5266fdf57ff33602199a71b919b878192f98ea0e78f8b42c23c01625bad88171dee941b2218c5d25b057f3a1c2e62ee8b05c68313aa4027c1b0a44c977225f2426077f08f1719b6885cb7f4df68015f78f220872527e3f324ec7534900d8744bb715c4af9eb7ae276d313b50324235d0fc92587706d815aa4a8e924d4fcba07fa879d5c14aeb264f691cc7bbc2e702ae53637da23882cfc38bd2e7844536e830566f7dcefdff4de496c22dd6e8d96481995d2edfa68a0634d9cb9ccd5e4619192d55ddbb977f164a270bcc9a18056be858a12e1f9edb59fdf197446a5266762635dc8af8ef204f983ad93ddf9bcf908baf54326707c87134889795d2d739a4081b0de9eb154ed63cb9709ad86372ac4e8032ff488ffeb3c7606fde95e5368e618c19cd72ef82e358ca989395c4b130efc1323994e5bdbf97e0321aaba8a3310d0d92685a1c73bc98bf2f3cf16052c4b0cfceaa89ad3ecb1726f296da54b050aebf848a4ab6236c6244674392b182d08be7b678cf2f8aae9ff71802bbfedc0d93dafe713ecd8dc264e222cf51477d9b3171929ab1c64a92094c5249a67b77ebe724595267f86a84dca9335a060842fc39662be5c291f76aa19b21828645c9e46695ab88c061e2adb2eea931803e95d5b4b555f1575bee523e07c99a94851d07295d46ad3c3302c638fab6c87ad1a515e3e34f76507400266e9c813cd8a41d345c5112526002df6961c3040ea4cf56483babcf4f1f8c7fa98ec663f1cb79df02b6a820576e4c3a020010d2c177e47fc1aa5454f5559a53fb84a94fcf72d6f9fb290d08d567059eeeb6e2faccd5ae31e680b9faffdc83969eee0128be4b5f2f9ffc6a4600ba7e7ac71b48921112d77f3d39c44f9872121ce2978a9b33b3d584d1d5249a1922eae90d49649af25ca95b671e246b0fa05312d7c106385f28c234e50f1ed0d57edc00f9e62a64ba5fb0df7ddcfab03b64989d643e16d147d7769fb2aea0f00f22130a0c749b8f07af25cc0777d496dd6e1c31fa40a34f3d95e4fcac231909ee9b37d2ffbf1612c966b5c4c28f90446dd2ae7a90367809b7bf0e9308454eaabfe285060c43e7cc59ef04b631d7d17e406875b8a0bd9972e12c4b920563e1ada2b493c62066c94bbe1ff7e0ee0a0c704445f86f25bccb92b148615b779dcd2f1bff446e762ecf55df19039d5d9c0db37d1166c2e1fb89a94e74016a06f974882289602d2367d116b5ab57cacb7de75f694279305745fa0dfd4d63b1fd5915ba6133ddc4fdc1c8a33b73c80bb20660a7ffa13a52c529004f233882a9aa8a46ea7b0c5a16531ad97923de037d221721c8a80db574918c903d1ac1d1b9a3e3cc59bb0e071798233838d114914f14f3b393094062f59bb78beddf491ff1fb2bdb855fd17dee7d7c7665a65c53b06bddb588588b0ff3e17b553d71f669c92890de872d9d66a57eae4e79a8f99d105578134b83d98cbb8e0ccb2ef5a9d9d229f54e15c966651ac3ec8da210c37c9f3ea8c4416c432cc7ef7ce38ad4b23f3a43e5121dc024fd77119b9ccd04db6960d6339956738ca48e4ebd525f3123ccf0f58415fe51e31501104e9a4a06a33febe3d2821c3836affdc93cf1fdfc650d1cf59cf07780161c4b50d993b1f8e506347a949d039f77ede139bacf04e15f9f4de8aa0b557c4f9f6164255e302eabc09663ef0ce8e731ae6903f4d4bf75e7900986a76b65a8b299ab86cfe6c52bcf181519a77b691c748910bb0227d910fe3179ebac70e3ce3cd1a780c40594623410f89cfe1ac58a1d0c522843f293056f2c6b48d27cd785454cd3dd314d05ed74d4cdd0d23390ba04e9a1cfcc67e963a0857cd4ce489122fa4ea3ff054396a4add8f245d2fb2d88fe1c63cc9c932fdfe683d6ec33f8892530494e725115b6c6f9fe0a1a66bd08d1143e7a9951b2c6e52ff2b0e7de5ef183d819b53bd2c44baeaf19a63ec7d4813998774e44f7e7a8ea893508517587ac049a471fbdf6a10966ef090a3b96ad578f49beb4e69e25555fb155b8c06ef34ca3ee0d63f66b64406961bfd674c72e630e1f50f24b96b2f423dd9d4700014c25c14978aea4f7f9c036f1fb472ae82af42e15bdc56e06a09bc4763f8787aa20e8bd33e5b687ddfdb976331bdeac2f15d19d5d9a3d7221d6ba9b423c7332520d21e5a8993b8842102deb9e3e98a55d2e634b1b1968e6252aaee582dc1ac6f7d8d7950996e9963befb917f830e176bfc26a770aeda5da5fb207a4afa5c773dc2678b437f049c96e412c8404d23f9a5862affe52e165553180e816256cd887263f39330ed68a46a4f78e91be6bc8fcea4adca394a13bd86b7e90d789af651579dc3189b43dca8bf89bf410f14f82856d265b1a29928e54395aa40d4476b3e2832cfc05fde5a07934f01ccfbf5c4bdc2561a6e8d74d3cc1772d6d7ba21f283ebab385253b5fbb1c72cbb431408500f5a9fea505bd368a98dd4c0e2d0d6162503080ce9b9dea7a4f63a999995b16edc736b527752621aeea3e7fff3dbfce71199ce552c5c6da5d2bd9a93857a32671827e8158e0d3a0fb6927f0091668c6420d42861445289b1e32544ec3ab9bce11e6b06dad19f02d49d81097087ee99510519233b284d8fd939571b4e35ac614127aee73020eea381e31675bd51459e480c60134ba37110c3a0a4acb1df60e9fefb45dcd0631ade1e6cecd3cf94610f115f7b190988c70ae97f19c6e6508a6835b6a971bfb656f15e5f9df51e7bc62b6d81d7530f38f389d8457c970ffa5d4038b1d79ee7d8cfb6d03141cbbce29536f810c65e7c7504176ef683597510c80e2c62bc7a75a49bebc2aebdc7d5e3979e460c82a57e5e275f345f82ade194179e112b156add1c5a189a3251ad3b1011790ac8f42bdce1616ae4b533dbdcdabc21d51fda439f9ca6042015b2eb7de884fe02dc331e68364cc05bff786f322554308fc9efb16b85894c2375cec7ccb2c63f7ea96d2b4492387b45473156264159b7af7cba3fdd2ce4821c79e523e2cfdbdc1e779ce7cc3a8be8d74c3ce3e0d68c53e087614c5264786a91ee5298e19e0482a942810792d89151011d03d9bd40a93fa54312a9eea1ffa3825309b3a23f55ed6857314145171c23791b480d49e13910fa7c941d6e69ec9bb16896583352871f924bd978f8b31c68ca16648e0f3285d61f0441d8db9169d1472e9c72ed52a4e5c3f65fb8fa4059dc6ca1c9247e95ac8fbc70427825eb5fc3609770960992c833c51e223ab667a0ba15c5c8441f06d58ceca6345dc543e33a6112b14f2e9f8905da1135bdd9da2f05b3d335366c50bf33cfd53c2af0df46e4220353ea3b9fa58d85b627a5067147a84687e7b8db359acd7091ae787dfb09451ab30d75c2ff373b0d3a748e66b7a8a7974650aac2a59da6b62d8946131992c8e700c14457c030029518ad7a81dcd9215627364007c94b7e3237fbce5fe1df59cf9028b46814cc8ff843790e438a2ba8e71d010000c879a439c1e2d2b1c6062ac8b80329880e0cc14a5c3f099fede36eaa48df8c564de00543ba8e90d4d838d68966393c7bdbc2a7202beabe3f6ac90299abe86382dae1b77f7f61bfa3a3a2c9facf7dbd03a7b33fe598361f9350328eface289f76600847e87f84041ef5a35edd86cf87a1c4c08d4fd709058ae8515696629ae31bf1c8bf1e9a8c83ed29a233011aba5f67551881ed965becdf856e0d1dbdd37e89df6e3350a030ac2de4480b851b095bd45a85bae90036119d29d0798fa2de9bc0b28fe696c2a2dffa1a91b9606a57b29b088069a3a15019b206d6216eac7f2a6cb2f5bf6a6bb4d4671efb83d79be51d84dc60b24a25e26971e78ad9aba35b7b9f00a682cf9f6a21d247156d2a283e40f6d72e6796c349bfb5cdd240da00d5ff43f24800ce9be1b042463268542e72b60b0d8f47fed83f2493a3e8d7a7d43bc6eda4fbec35e95d540c42a7832353bac3176852a28fd2bfa0493a51df04436fc6a0afbe4cacb6bb878aab008344e16615ae7ca0a1a6fb9216d883e2041c292b68c5258013c74cafb4ab32c56ac83290fa74f39aadee2a0465b2327f8110634c6bb395621ff8782cc6393e0d24bf7f9d8ce286f158211ea465ba7ea1c3ac58c9f5ac266c6586d47eb0cf8ff75a0a303bd4938ddc8c74fc1e3eecb0c17c957df460dbc7ccf3bf72574ed1d1ec841594364aa5fda131d7f11efdff5b69edd7317262c74d820b2a33030471c4be64c2d2585eceea6cfa25ec5d9c248fc4580869ca5b188b40da302b84551bf33517df9180c52584da73966df274849bfd9eddf07de09822e803aa1bca77fc40f5ba2505e6fcaf133eb37427534332b141d3ac7f93dcb5d0a8ebdae31f3b79a93d847c4d7388e2f564e659007df2487ce70a9e0eab3ec2cc2d2cac265cdeff45eed78882a43acaaffe076613b1ff1293e20fde9532d6f9726f187df14aad969edd3cf701f9e454123bbc39a139a703fd9e36c51c3e40752e63d95eab9778e13f95037ac4b4b81e4d735e472ac4b5b44e3c428cf61dee4457b566faabbb343173f7724f32d92e55ed0132b3cbe836fb06ef0387c99d0347428d04df751ab0a3380edfa3cc6fc5ccfd2ecc10f97dcaee3ffbf7e3ba9419a5ffb518073bbe6c7af138f7e075fbc38545f7aef3ef7d10dfc5ad70a2645eea91b430dcdcaceaf5096fdac1f330af4b71601acfcea1c41fc27c59963657a9ef3f12fcafb71c9bc9658d8af6e820a7055a1d18d4ae5da436beaf0b084548bffff000bfe305fa7bd279e4d13ae447adacf5a3cabfa86a6fe2a229f8f15be2dfdcae0a71cc0a1eb9838edee19aec553ad290f6c83f1aaec09b510265f3f6c12781d1a6f382c06f3ed52327a6225fecfb7c2b5992df1f8cdbdfd68ed3e29c3caa99585800e6136ffde9a04531086e85af82a9768228bb7b1d30d84cf069ad68e19e1b4c68e6c6a69d352758648f8d0a7d1c8af205c64cd08ea889a56d7c3fb0fa959ccf44eb6677bcd1bfe4704b992c873a34c9b73f8b32762afac12f63340783027e413aeca00a4ae21d108682fbc02ed198ef15469cb43ef1f47efc325b77b91b1815d17609993c9ed9fecf20fc80c44e0555e606a0b2a7ab643d50b5543dede2e0bd802d83f9417db7a1a7d753b2530ddbbaa3510f3bc6d9b550e9e4427412643fe6a2a919207c4807b2a14b745a3eb93367e0bca1ef9e5f6f4d5e1eb7b29282911ecf56539a6747516ed91035259eb04fa1ee98b8eb2d848430b44e94f85ece855d3028e86515fe2e03361a2be7408cf6a1c6180b78fc9d4ba7de38b4ce1603500cd0513066f96365d0125afe631458c08389a29d6fa0b6c72e2a64f185c2341815c1492b31806a1a59649f8f2134ea29a39e10929fc08143e737125ad3f1fa11e0f53f1980c7c70256e6e14b4bcba26163cfc61879047a8e9dc17b284935172eabce124bdba105319fc3d1d8e8fe199c1d3f3c08546635f71d049764d4e3ef25da0c6cc7a9317f3d1b29df77c27f95ee29c6c6d2944a5162eb279e11b462b2b028843e773dcf4da3f2ff6fa5db77e88ab14b03e5dc2d01fc1da379df7e6aeaa1ec7ae3d52529f94c0d7d91435a35c47d36d0769ee37eafdcf7fcc7f6d07d92b9f206e096206ded61e46d90359833e001218e0435446e304711f5adab5e1f86117a992a28c0014df34c6d7e6d88eaba343e25b979724cf4c2faae592db91b0a4bdacb96d4ffaa7deabe5aee4ea4207acafb7c6b41a808f225ab666ce32e619a32456368d140f715613feb6c827d7038d69af3ddb611e26af7e493b5135b3f05b9f61cfa9721d367d2d3adedf09bc1e59fc61a6ef97efff52f5a812808613e9c693b2239c790a986e33548d2fb45bf1032a348b3e37aa566bfcb573f18223aeafa60ca41783c4d5916bd77a800abd909f325ee67a52cf18bf35fea102c842805c980e3776da3aee8f66a049f5203af16845024cabaa4f0826b3f9fbdd5fab7b3f570c240182078a5850a96dea2f68b8a3eb7a24e422834a2b05b7a9b270d2f4da46b2169d266875fdb75392b8fa73229f71d8b3671322bb7593b1163406009e78dca7319af53b3bc33a43fb1ee936e43710d4d4b1a1d6b960d234bfc17c9523194debd21b8054f860164314e1e8a61478372d626a779d256ca0afe7f857e145533dda6705f08f5815951dbfba1699ba290174bf8a771e2b281e4a951c61b60acda986f56dccf5859ba90de86e16e65faa66ac5217c33fc5e8e9a80ec81929408e008233a64550332a877190e25a18a6d4486803f4cc4310a0c8d4af86033c967bbbcc1ca2a5ebf4a26adbcebd1b55f83117df4746aa151c4f4acaaea6b2d75a7af46d241214004c384d34f4b582036491a25253f529f3b0a645495c1613e50d4f7edcb603317272d254bdba191adba9ac08bc1831708c30d08020614ee61c47dc9d652aa04bcdfa2a24de4ab99b30eed94482390ee40325ad9da222989108acf35cdc397669898b08dfbd7a34148c3308e91c90d732a8c3b7cee2f163df528246a328b8b112437cc61219d31a2f74bf94f381c0fe1f9f9602e3770fd335cb3a560579671c7ee3f33ea78923c88f24b4c1c25272c28c65139a22488379e1da00e913051472055ca5846cd7d6bea1c288f99a6731db06c227956672423be9fd3af68ab9b1f1f11cdcd4a70b59c606b23d78a713bd457b676499c8256746f79ccca5033bfe63cafedc28a8369dd54389d5afd138609651e0ad99d8e5aafb8a580b8a3d5fcebc90f51294d38d4b11648507ba78b873962dc72b0ef1331ce65871a135942408a2bbd18d60a3e51fa0e03bbf3d69d41f2a1e161ea708dd0c7586725a4e27e670eccee7bd73663e3af3ffa647834ba30b658f73e2af98721adf0e7bbc686e99d27999a7cbaad472e15243ba1c25f03355459094bbe402fc9dc77c0f6b730d59799a24285ff015927d40a757d8cb21d0ca05af4edd397bffe777ca31d40053aa47ff5b89bda6d74c12610c43677158cf524dd4ad66b55b0b58bae15227fc9e614d4a33f9fc46f880f9f282922acfd5b85b844a475f21ff6c713294797782fa0a508f1e7dfb89386ee868edeb66460f2cbf869f249d6480c9dbe14ed4a5f90b3628e35abf288316862b18597d420bbc719eff4f806b15e86a738b3d3e54dc9a62ead5e2d7921c5654381dce1cfd0c7efc5f8621c4ed17ef7a623bd3a2ea4c520437297ff0c6c7bc99d4b9d59da433c18c5c4893b78622a116918c37bac90458ea9ace2b9805f4c33d7bd4e765fbc3de4f455e747631a18590498e9a8e3f8f0739e6e77d8a1904986b38a53c536582545f0409296638168c241bf26c04be62f5bb37f3190ad7ff1041cd63934b332e98cb7aa4acbf3c3a21e0ad8e2d2e4b0de14350725a8fb98538c0e20ddc8db62193b985be123ae8b1e9e6fa79c91835a1c97ea48f134bc99d3c3fb32a9d8cb83efe1f9fd8dc1d41ffda135ba05ea296d9289b09a7238950a30a535754c3f56414c41b7350b80d90f4944ec2733c2584743f6140722800bab415a36b63c1e659354510a1bd1c9f804ad9d0f666ee59ada5cd97a8ddfd1b5ade41d48d2dc51dedc264b701fef5b105eb0a386734dbdc114321a20ab2257ebe8eb981b4a78e84af545d836ddd7ad12c8bddbc14b62a8f8b0c6d7a9bc63e4fcce6f807dd980473d1ea2b1ec8fe7c6481bc252304e3746c510f7c2fcf9116c8d6c2db8b31ab003cdba7c400672fe4398111e4150c980e7f121760fc0ea676907e9de2d28a0228af82e038f6256aa7434047d706d315edf182fc37b10fc0ab2fdae451e0fc0477f65e391f8b60643c3ac2e1b532249deeb901d70d6e3bd9840fef1d37df2638931e1397ac2e07db24310f19523588c8f853679894de4b7bdaf2cf0ea552d2b05db3cec4ea99f8fc110da3bed09f3d1f5b18f520f3a6c2d9a20f7e6c58c0d6691cc54fd98050d565880674abd36a3ee1877253f987c16a59d68b11669f9ab092e1bb9617f3c409ca7193edeb80ca7bfea13820abb8e25c519ceb07fbf0c4973c68e0578d49acc5beec221c8a313eda7494fd9ad5897dfac1536e7ea33504956a8185451d8798cbd8919865913c47be388e3156da3fe67a8def201ce346822a73bf6487cade95f394d8636ebd2e3f2b5554815204b69275079e63663ada6cf11fe1ec89ccddbd5bbed96f911ac92201f82b41e858e80205c48b1cb7eb883c3fe14556d31391003eff9552a01cc53e3f5e7ee7cae6755861311b870402aafa9faf940e1d03bab41c018279c2f3c779fddfe5d540397b442679755362988a214a4309a4e587ae1bf6a512d756ebf7ac58a000b91c2ab404b14dcf173911f57a60a010149cff696c0689ac00df4ced925b44b1df637fa7e5bbf5056d1efcdfe26231e6e6536fe966d2a4a950979234a515f2b81d0d9d1979d62571fc55479778de4dbd48c25c76eae19bb28e1b975b53e9a316e040267e7cdf5d7bdbe957740900250bf5515129ca8b1032011a04afb60bbd47329302a8cc1b9dbf215174b1405370b31e2df975b4fe89cdd595b651e9392441ab74f4880d77f222bebcba39c50569f5a2ded44f3a4ebfcd1a5ee1230f513442d27853b6408f362a385253af3c2795c95fd1da46e1a6a5c18eeaabec33a6fc354256aa582172e2faa9042c702f0910f2cb1772bf2ae5716fd7bcbc164b4b6b97585c1e4f298a2060cf741238f2db8972cd7873aaf0973c8ea78bfbb7a4992289df62f80769c10325f6cd089c558136cbe3cc733854ccd2e8064e77c4f102370540bc358abf2659137689c8cd91246dfe14dfed8ff90ce1e394624f9ba48e77769e50686a5407770afe297c19407ca7e600a7a279043ca5265f16405900e94cab6fb612b314c364129f1c337e431abf9ab55547376a9cd92753831208c1004d572567a125064d3e52c72e89b07108ed027f1b2addbdcbf5222e85241baf023dd3485b7d79d7cd46a333f7bfbac91194799f81720dfcd12366338cca0cad67a46a1a0e4c971f258f6447ab3c3f2548e13c1c59b22a895fd6ca6ecb9a72e57387b9fa7cf3e54fe01b252d22c090fa7204e837783da5b2e619e9e4bb7f2462d0550e7f381799946c43f6eedc2c491a87dd43655f69642a0471014ce636fc5cc4c84ef29ef7802685e785e542fd80b3a0e2d56751671c3fcc2b966ef4fdb22d8ab3566f3caa35898aca1b62496fa580ddf3565a7d75ffde3ccadbcf457072f36178e6394bbab9716acc8c93ecef2d977bd1b7ef55ea407cdbea70ce1ecff36a35c3f8113cf8e83e8a8cf32fd4723e2bad5caeaac372fbd6d9a370127bae6028eac8da6b002420c3b7fc80c91ececde32b28d46e793e308e40a4b7d9aa9051f3faf80e3bcdde7952e683c6cb847b73817a08522b4b797374b81736cae1c55606596755844f9b24668b73e1c2413f2e41de77bc4d1a38e4d500be5f2142c52f89ce540f115f04bbff0165c7c087a4b6bbbecef09e1be93685cfa5114f5005c65ef8e74ea1d13c21842a2587ec47f3bea067785be13a6af0d7ce6f90c01ea843d5e0cf2e1c750c4a777d2235050c1219b339a29272816d68c7230d94286abcb558d2809bc7c285890b732254316a66ead3a908000c51f2b3b407716828ef499ee89fc47f795149603d2ebb048899dbf43496ae5b546ae4f4c57eb711d145a1a7838d5da02ecbf315854fd715d9fff9656138efeae00e126a03393299f9c5fe17548451c3fd4520b209122411eb8619b4bcdf7ed59b06bb66f792cf609c6e463605236a1f9e1403f8ce5987f8e2625995fdc2a6b601150a7b1706c465e36e39780f902a1e432aece89869f727cb7a3a701e9beda3cf90dddb0db5d5c1648b76ec17be5ee95afc935e76b73deb56b00ddb23137a6417d356fa778d2169577ed03ce88808282cce0ab3ee3c0b8efb28ed53d57b3e6c23ba3fd075c8825aa654b2d5afbf5734639b7fad0edf631fa731d380f68a48e34e41c4d384e735eab14c975493816335b2900d84fc14c6f64090b83ad67d62128c75c70f8d55d22c31b0b16f2a48a86b20187af97224b0a7ed10ba700c2248580b6268cbfedfb89804d9359e9f0937ed33e896ecdb9fb308196003adff45435ff1f96c6c5df57815230193af55fd1128cf16690fd4cd86ec2ad2dc678119f7526357fab556447ded49ff7b1a33514024532c08f6734a71e819b6b10ea3187ab6b154ec86e1a230fe5573582a45727a2233561d5c5df2e88adbcd60430690f8eb8cf86cefecf02c4ffd4fcdd10d475e53ce04f66088651e055e83f9ff6625c5ddf7197f21b9423625f7e5deb47ca1382ab2e6b045c4c3bf6f007bd73859599f992636555be655db118c925f59088e25bb7afaa705d80ac968c59c8434e47668f4c286fb9b51c38ee55a4981d6696bb8e7d0a4d248842b8b0aefa075d7fd1cacbbae90e772c2c43d4b90d955918cfbb77c59f7685726d37a3d9a0b795f53dc4270532a876c7d80c4063fb831d7df1446a5acc773b33bb419f9e244edf9f0fc19db283620a114b28ec06e378af952010120032b5e34891b90264d9d0344313b113f8386394a9b317933fc6c250116402af0dc4d197f565ab45cb3feb9852b5f88d35f2fba0107b0428b5434739e4b316309b3a2c1cee8861f9a42430191e2cd13828ccd1c0d33d35c0200bcb9756d88c2ee64da8f6fdecc34420ad10f3b3c9a621470b707e05d0e0bdc46d93d67f5f01358d518ecf0ebcb110c4615e66d699d14d92f6a93fecf2b742bd2a1a79e425d5448f45c604ab710939478ad7fc8b9cdcd6c72b1f1c431ddd40e35f178cb046e63a47e72a1e6f61d002636af11fd24de2e77e479434b00d8c3d011b9c0ad8e243ad303baf1e1fb803966c7148679c458601b601b2ce5c72c56c66fc64654c7d1ab5f9a9e2f38a497022bee74c2ec0ad4adbc49bedbd46d177477eb77625d73c98dea489481fd900a53cc6a92def26a21ba6c639d0adc5f8d9a4bcc5d33863be645df99453358f576b187c7e45d258c7f8e4af9403873e5e2eafa69823f3207325ad9f4fea662798b3782c1955fc9a400a91175dbb83fd2f5d9dec09c25a6af68e39b790157834d22c62628a1a2f4591dcb91a3fb1168d6d25ad0f7652541985c79dde960518629c6b6d23db210a53da5fe67e6be7d96d1d33d7ad041a5e71311b38b4afff8cd6001a4f7e955647e506029815f690aefd5bbfe6e2aa71b9cd15d147549b53ec4e853b6c4a232a32d8a80c13eac120e2a5ff5321a741b50ff3e680c058c32b641d2860fe8872416dd903f97dbc1c699b6bc8826d368bc1823d1df8d4d68a6ea182cfe3069ca81f90d76b055f92d786ebea6c2519a76fc2e45c4861a05dd3f447a8b8d021c7f5909075ac617c7e7be3dad7840720e2bfaefcc28b8b0075949782a844120f39221413a9a21eca2ae7ebddc3aa53f412a4b42f8e01f9ebf9b292480a6554e265451ef3e07f24d3762b1ab880b5e3a24d5829e7bbdf317c26749974e645e4701b772c8a297eb922765024f8a716072601faa2705794a7be9ede116d7f98f042434c6a9f5313479137cbf5571121952bde8528fbb8be95e0488beb314142428bad585170e80508ddc622c78e92a81a2750456d305e5a38d32d5ec06b2b45cf2e1ffc58b85a8ed660a8fb35c3ef1086e94e97fff8f2b6b1de641186ef327674acf75461b37d4bf43060b64ccdb39708511a485d5f4ec85f7b58d256e6bc9e86cb1c21f443f926ea0abcbee2f8fb344059b314ba867032f40894b70e82d602c33782e9ac045751ab51664c1748278be61415d45ffbca1de11b0a3b4a0616bbf274334513fd20341e03f8d8ae5c000bbbeaf2a5a8bef36100c0ec6a75c6be5cf775d62615eb324daa85f269fc6aa49b6674ab6af5a4fc10ffeb71393c1bfd04c72203d0159222fe2c7019840caf7bd80bdc4e229c83468c6873578d8ee9a6064fbd5af38735a49ed96d6a93ca4e4b04712cffaccbef9f57f9d239200d5abd5e6a5a5be304df122ffe4988ec7f6bf67b5d185986c386cc6b1b0c42516d17354ae4d27535d764731ab206f44afc6e1cc70a11fbb3718add75bb7454d6294ca9d6f1190b8d141e5f22d2e051d52cd80ef915bcb1a8d0268803f6c665526198c7f6b47f39324b34eb69083454427bb914687a9887e78739f6aeff569e743bd55f36022dcc6713166a267c0c6a4087707dc6b0f4bd68634d16ca02d40a05619547d505935acf9e97a5d9e4c037d9004967aa0f7354f845ff54d1cbd4e91535a672c1aed58caa7d0d63353a8080cc9e36cee561c797da8c62983410e4853058d562805255b19c5b7d2b77ee1c3fe0c320bca4adc353aeeae1ffe261b956f616739f150b4c60c082519e941c7e66715a0c5f9e7d47b331a2cab4ebfbc28352a9338bc82ce535d9893cdc0e8773a35864e6f034fb4ca557e7ae6078cf3885f14ec094b62e02d910b4c100cec52db3ebd68770973a9df871ebcaa462a5d2c3193cf910379f274bc415a2f8ac7d5d19ac5ac8bee6c9f644ab96794c6fd339682104435b360c68be4fcbaefaebae80f6e49994a1551dc50012dad80716102bb88f4a19317b14732549a2cdc8114ccbef45bd6c4e75658bef1de6c7021eb98475588b0f8ff8755203732fd52ddfcd1f4fec3fe93f2b861609736f31bda8c3fc39489a127f1484296f5eb91607fa0357a72f05b1ebaa86a8ac05194e1559da1f9ec8dd97b30e9e590ea6a38cc838c8000a8e486b4274db4828aa2a7a4b04ad563a5492daa144e3d111f148b873ef9b3dacd8c57996e571ace93e557fffcc7655d343f2fa0ab776e16c16299a863560c2e348fe3668492a8b9457eede1d1717cd77f8d11c999e19aee771f5078bf74e97803ded3a5e886517a4c94e09c1832f76e8e7307dceee73d01b02dff2074b2d364171cc7ffa5f41396b17ad5c3d7f8436509419144e3cac8ea1fa1870c7b60148fa3fc51e26d2ea1e84bab3ba2c2aa53fedbc47fee7623ed148b4d98e21afbc35be6de842a9cc23f86d6b358db6426ccdaacd0b5302aea7a171485e7c60ecb1c97c79c6abb4a6322c0da55a4acdedb244c0dc88d534c8a7797a0b35a5412e30dde91782d10a13d81d8c760ee07d8166c83f7bb2258dbcd8ba5c354179e1d9f48f03dfb0633474e9cac9f8c28bf8ef7c7cb3b9b312d7f8ac86001851edbf4e0d4f0a987f9a5accbd0c36d211209444e81bf54320efd68def4c354ed3ce7abe2996c816051578f89573392271ccfa341d24fba80805b565533574857bf75eedcffb1c167773ea68f17f3cf66e75a2b998555ec4d5d076390c06f5b86142fd2e10f3c0172f1a41d988a14f308e6246046e17e1f7f14c6d6b9d9cb2fae863f91ef4cbe7a3029339a42ae7eed109313b56e244b4a73af33e92a30b118f16a243f842f36105ae87a960744555bd77ad19483631da86ccc1c43a38eead5d5ad8ccdc6b374026b451a65b91e397b17ed9bc8c5323ba598960af30e1f4ac9fd47a373dcce2684eaee5c5171da26bc740abeb570b1666e1bf529374bd0296f8a461541d5a2d70faf0534d60ca17500c4a3d064232ff6f2010750c4d17f735aa4df5aabffbc7fc7c785efb56c99ef3782df687efd8d7897bc7014437e8f5bfebed4d90112189ff11b46b99f37d645de6c19fa44fbac4965b7564663cd7721364ea1a1a7d8884e51cb4c172b1e71a071e9061d98c26ac9cda6dab2c1f80ce19595476683235507ec0df2a42e3fc738d6066992b9ff4b8d366287434ea64ddbbcf550b29ede685c8a04729a2c396e010636c2290e0c803ad54e42c0123085c77850445732aed04581fe234ed3041712e3fa09e0e35757ef34c9de0f6c02aac6f55438e7f12207fb1b932b460c4442e102a50b28aebe52f8ee3250d4577a2e6ef7020f78c4afa1b2acc6528357d2712c21e9977a292710f2b2c4d79eb1d3e328aa6f64dea43228999f32af7a128dbd5f2e8b80d0e182bb04fc7c0817d10d83e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
