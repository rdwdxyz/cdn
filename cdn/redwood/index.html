<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7314c362abacf9ed851279c4541259306f3c8bf76e1a67b4610eae310af344ba9b67653844eb4e04a1f689d2ae9007e3dd86b9f6e16b6b1d6bfed783107aa175c497e948caa44cc4f7b0df537cdd14084bea4c94f2833d6da7b815f5d87a614707070f2c27d0fac5236bcc2c7c96090b0ce0bd26336b2b7cd6365355bdebc5dddb193d4e407cb1a47aa4fdb857e11eabf1cab32823ee1d3f4c1ad7a6ff0b868f7be5517b54102acdd1bfd747d0d1b58d49dece5b4c414602c2f4cbfc0659e82282f76bca02d146d9b70fb140781ed0ef584374bd6638145c434717701eb2769b5537cef3407d06b57c70bc7689cb317e573458b9be45c00b6f6af2a1f0ff89948129da5fe1a8d3bc14a03d38e2a6c19b67f9e36dfdb794d753fb7ede28d2c4746b814439bd7b06fb68b5780349a5e3afc76696ebb96234066b28823fb7963a80ea08f2abe800ccbb26b6716d848e243dd238cd1f5bfed4cc46a02e26a06833224cb7c56019214552336d848c9cd7096aa9ca83a73b4048e15123f8fc77324977f9506a5618abfa54427b0ea14810b410534fb5e48d96658af5167c8dd97c7900ec34daf55ab5b6e712154cb9ea9bf02107dd7d888b5109cf42a411c57d642de54af1003ee1b1387edc1baa794df2ef2663874076911770b5aae9f69bbeaffcc0a10d0eee67abec5c7027eece4ecc679cf36c5dd552f0b763f416683ee027e7f9600b1485606a2a3dbc245c37a3c565f95433e4c1b3f0ca0ba57c6b6c5359fedfd52b73f56635bc71c72d9020053b67dfc35cc51e79b8693fa8cab1ffb74b8519233c546f8dede50f1d3d948e6fb25147403a10056c226664fbfb64cac92234dd723b69b7ac6c29899b2e9c4336548115c30eae4ed02d42dc57f7d967a10fc696de6c0d99bda714311e85a83d1e3cf846c0d7d7aa30f95756a14122c47682c524bcb4795bd83110c5d464095bd2c65cba7c5b20f714129e1f4a3604ac6f07fe4f7ffcc4e5049329179b9758bd0ab2c1b693f18f256e01e39aaab2f87a00785119edc445056e330a3d79db8498cb61b2e077ddcd8976698229d343f7af5c60f2b0a7d930c5f50eeee806353f297d9c5a712fdc829ba0cad50ddc4252de8517ea059bf987d03a1bf662150d246061e05c5792fc5ffe6e9d9ad9ed10b3394c2ffd73caf162fe3c740880c9de5ec97679d0ae4821cff12cb7f8d9a2c8a20dacedae57bc2a04228ac4e9b87b52721aab60ac62c2ec6cd42ef6ecefe5591e16e7a63a47829d0b93fd0351bd9d0bd8430dbbf86f4f768a159c06c8449ef81cd0a9ea7fda2efd00f007a366c964d1088e22579870c3205ff4e9840b4ac5f474f5b65139bb5091c00c3844af820da6157542cd9d1dd7c28ed9a4925625adb75f810773839d35dc0da63a46a6f81b61bb37806974023092ef2e94deca669292a6f7da6a46c2960d95e4b5ce1c14cbec08e7a15e8903e1dc155b3765c447b5423b8cd385c574fcd906f9a3f20989389782bc8892d9682432988d0f3b537f4f6c53ebdf0f73bedda001194f414430262b3e39166a7ef1d37056244d0605ec4f6d6205ff9c8d167d6cedd7c7d3d0c5622a8cd7c355c5123dea15ea81256dc94893b60cb9e56d17dd0e00405c800a0687afe389296d2ba93a95cbd31156275c21d46ead52de8728652f37ede557ae151b8b6a52cccf52ad0ed0f55b5f102c9b972520100a06ac77851e1cb662c81c11d52bb350d61dad7c9a1e036dea695ba7a1f898d280baf9d023fad1324518ed2c3cd14cd1f8d32f92b0b546a4aa791b7fd4f63286c91d7be355ee1d64938dd25e60e1f48f2d2d4124444a26b1b243fb925e91f92704c0bce0cd6ad7b0a6f6cc5dbfc1c31d9567076a6bd0a42e07cbc661c54d52d9b17685eab2c8343b1649bee9b7cfd90dbe286834fbe9ecf30dafb2750e17ad71fd23da8c8189f7b0789e7de8027be1e19ec0155753d3e16aa6b824ab3edd61e7a876dd24a2fb6dbb2ea7e9aebdadb3f78ed870293b38bb3a89521a12373ffb5ce9921693ba093fdc8ad4bf2eaffaef9aa08fd54eedda8bc5ac0eb3c5058ede7eef3df93bfc965535a38438ac78a7cb57a25bf64d07c05e68cf1ff572a36370df692e9236dc2029a0816208fef9ee14538a2230a3c1c7b5c3aea4389fb94b62452607f489160562ad22b3c0897675bd2d1540ec47ded84bbb43c47512fa7075485808953e5b9e37cbdf45edf3095c3b3f1562473cfa3eb68094913f55e4ce2a0fc09f6df1617b893a5fe5ae5431b3ae1aede54a617c408ecdb99ec8b20fb45f5aaf90c5fbbefa07d531a9b81ee49b15c987cac90472a316ea3444e07d82b0d6811301b4284ec89ac61e132c16e72242ffe31ceaad27d5fc6330c76d50db577086fec73ad956b2716badf2cde92f4181824e20733c39144249a5a9cdd78c4edbd4c2bacdebe0f2e54679deec1fd1986c6d040ce885943ee2de30fb2abc170bc739ba68aa043f8f07ee634bef1a4d32b5f5a3034c035e620f11172df3a1b4f652488d3511c8b36a80b2486f1635915da4a8b1746690e19f9c6fedecf8cca899448717b2f190dec03ba1d8854ca614d56b5a2b1596342f2aa0998fa496c9db73cba526d9bac533836b7501c451b7fede05a605d8597decb3cf6e238f82826a81ae5e2359c7341913785efb1743e9b7c327c5fde5d8ac45889b68c936e65259e4d31e28a882046fcb229198c78c7121bdf5dd2909261bc67101cbb01d11fd89240c47e35a6d045d01b68849d34537c951a1a9cd69e71553d136df1f9028a573cc8c6e78efd4d145be965221761b470f84c419a556b05257ef154242226b76040bef676d92176747d935a3a6c612d5ae531e8fd245a78f0275394493714b76f387149ebca3dbeafb06fddc148278a5a2a85c894182530e6f8a94e93830a19c6462b9d0f18b6057288ae7a1777c17a5da48c9c073a7359a06cf9bf9ab63eba0fa59da6836c9dab280bdcff4a87bb6eb4ac6432277a5398ec61d349367a807157f7afb143457d98f436a13acafa200da9fd86a6a496cf2b9a7005054df0d85db5936a3135b883198c938d03d4ea6d995d93141d506ef963c9ad119fabdc8cd8ccab515bb671acf5e92347ff30f22c1f9bacb0a35c99f2ffeec4d32ce21874665380c3712d350d8b48ba0203234dc0db09ccb4c299bc0d05aabe2b1a65316cc2c714b2fa89f954e65329616f6defe97d4f6388f9baa7eaa672e40a18b16be79889693f213934e6723284cd04fd782a8cacb713766be9674fd4b380bb902a20c11b9944755a334a4b130805fcb4671fb4a168a131e3c4b32bb5c0298ebeeec7186262fa4dcb4cd60e6a7a85c59b9823e628dc0b9998caaa3dfdf3a6054771ac28d0f38950ab807598857d73241ba3f39131cf2ce4266b8d590856426c1caac1c86377c0bd11593e130fe9d3924b2e0f6b461f9e83ac8119a3c10a04a0fb0a90409d33eff158bd74237e85b977d96b4f145922222197055aa71813103ce3b9758cb2b44549c10b3ea2c785b0261a42155409bd287d98928bec239107be39a1eade3254db87451fd81448d1d17169c912a4508a3a478940bbca9978484243b1ac5cb73fdae5048b58cd850c69a868001f965297a5e934ff206beb1e201295226c1293a7c79db5fc72cbdf77cb2c37326c633b534ee0185c3eb45008532e3c6bf2dfac1c6d3c80c8ef8bd3d890d48630de0d28fd1c387544e41510e9ff961f317f5e0291999e8eaa2d249381fa22b321d65db30e2bd23f917fefb8c2265e10976d8dca33aa4bba91f3ca1948c950f6be8491af9c97041f6042d1bc8e775dc264478df00135ad58637bc944f8facfdcbb33e745ce32c87fd94dd2543cf43e4c95ae83a71d2db1fba57ab9200e1459ca7371ebaafb5a3150ee3c93bdfdd4f9b2d844a0ad21eb7df78c515b1c57ef87b44163b67e63c062c3559c5bda06434c3be3adda6492e4ad5d3f8beefef896a379beec0d4d446a18c10d391f6f1c55405a440f98d930c44911473d4b9123e27c801b6f62f8825a4d8e56ab7b961f29874b0c1d5c324804ef52f3451dabccfa2e58e79f23cc847b9c71ac9dc1701415ce9d6c3bf5e01f7abf5d1714ce11b073aecdad4c4eadfe1bf78558cd23fe269c3a15adfe34e28f36554fe588a0d051eec1afe858ce93f69fb45d4d1cb81613e7343fe346290b21532fef8a04666d8fc83526eae8ef7347284aa616747b70074c7c57f950e9ba76053f54d16e133a5be91b48a1d87360649f0e42d5e6764fc2e7657dc6055de3bd71ffb2a3c3421114cdd9122e5cad6234f469038b9229c011012bdac90c606148deea3878451a8601594111b2925e293d4b108a0547729d337282a0fd04bf89e0ccc13450d1f39ad2b0d2a0b4247608ae64b31ae63f63274a0e43ef531727ef5485846c9ca4f570e928e0ba4eca5d1a383dce720dfc43497ed431540317e6136bc72da2530c1d5ece45b812962483bcafee5d419bddea0ebda0971955a6536bb05b8cd1b35ac1425db4b9c3d9175aa4cab3765bc53256c3542ae9d91c6f23d683d4ac93bb19cece1477fd8aedbf4371bd020e54c25cfa2ded3f9e992a9335e41ff9df894db8ebc8c72e48ee9defd7deb508ed59c523b9cd50ada5e856ada602d407af88a0eb51217d3ae22dabb5f0c74ae1e5ec2d4522e71a985b7cf2f917e4115610c0b6ca84fe886ab106a323bf79c41bff6deab59fcdf82f868ab249d8c8ec1cf2eeb70019feb5a5855db1fffd331274881901e97de12e1203b09cb1035d461296c596f4753b444891dc1ecaa465fd54c81cabb98c1a1824a24bc50c02aa7ba0229e583baa905379e789326bc9e9c2cc41f915cfd637e48a3c2a5aeff73579e02de21776137bd343a28d1a130fd09e083825373a4a72a12f0889c8185de5f034d5ed3df070a30f635d4709b3e15819d5abd363f04431af3e815a2bb895c82a4a02ea716ce757c8e3ac8cb781230feb89922d8ad2abe6d3add6e59270e8d37986a1a505cea3f0bf30b0ed57c8121f7f797f6a838b442ba722dd415d9ca6e88c3c5376e45dcd725ccb87583f877260535faa2efff7d36edec03f9ebc5d844b094e95f3e207d88ee48a0a4a5cb996b1947f872c00520a72fb16179e5972687eda980abfe19f8238e296e10311e3e79137c14e8afaab92714107c05bee028c8632f2b632ca7141f14cb08e3346f38535f9abce7cea7def1ebedfbec8746dfc94978daa819cd7cd2c26b8d12901f578dc7a491144f3549e337739fd7e6224b5b66a53cda625df965f0c2c4b6e10f5a48b2dce9af92d1006dd20f039eebb0e34d2bc30704447e8576daf559abf680d8de84d654eec4ee1d0578ed53e5d538003b92638353232d0d2d2f6d56df31a1015da4c5f712299897befe73e1cf1df5d60c1f92c700138124757adbc936647c1a338a3b3e6993a96e0c24f03a008e1c4f90b074c9ff8d3e93c1b5fb8b14c0ef7d7813fcd94c5ff8f489762dc5fd83d6b2813c076b5583da778fbfde7bfbed8eee116842a66f728b52e694a9c48a641a3538763d922c2abd1ff190f016ff4c8279b7355755b8d215ad3fbd3b04212b0a7e253b6e07a3c6e95a4687292e27a7f86b378fa37e12b21c140686a1d547c112c9076d888c2848819d138ab29fec88ea2892bfbe15fb2d587be2b5420ee2536a879a44a70d48d4236f3d2aa707828831d9cc3496487ca1de8659aa3966ec8b773a3114532dfd72266a1df773ac4a4ce87e652e01af5287018db3ff42c869e60378e0d2aed2df1255b8140bb4595cceb46689f68ae3760dd706f91553bded044ddda77b0081a4f9a6935e5a925c3fbbd4468c1af3a67aca55b609bfe6fada1e78f06578641692702439ea91aec15cc3b62da831e09e1b86f91e5bc26e7b938c516fea76dbea877eceaf2fa720ae2461e20c21f5d04e63b87bec2594b1c0fa332c30a5f73bb9de8ecd54a3748a62a368524ec90240d1beae65747138b2be0ce3812daad67d91aeaec8d0caa6aed1cdfbca9880d46363020353f6839acfe5a087c71c5c1fd431de9c50f0b11ab00fbb1cbb8f17b269cdc6a0a3381a04c0af47fee61ab0a24dd96120f2754a617f26828fa13611addfaae6409e1a07fc1e473e84faad1a35d25091d880ba651c8266f7a77e4e67659fc45a84abd36c1ed846eb983859e33b2ad7fd9231b1667d7433e76b76cae008e59ca8f3733a34a93d32737bf6ad2118a552a8468c93d80ee221dbe1c16a94b11d5e1ac8b3fc1a2aa4e0a06275ca554c1f36d0e5d45bfff708060d94b063873ca4693f579a6e440b9eb2772d0244c11e1a585cfe36e1122b0cd590945b0bfa3f9c0da7019d2556dabe00a58e5f64685277832a69e21c66b6f7d1c155be5e3e89cd3a0d8db7f8a01e107feffcfa4f306a3b445adbce3ebcecdb85ceffa3460e51a3779e0bd76fc81548105ff971d3ac72403ef82ddb6221664f2a2a8423560c166cbfd37aaf07a4fb36224485fce5a3a44540ece46b4f7a51e3c04ed1d1d0d20138fb54417126b7a04cd1cca74ecdd45a27f888c094e5df9a20df0cba790378bb9533313e406f5ce898641d7ff7127a0fe0324d17d35f3bb204b7d322ac7f7ba9f1ef33cc79e85bec443262ab47df26d0de5890972c7d8106f9e74cc8d4eb0b0c970b05479d3c9399b5282c79f3c39a0108a723c3a4d359f4a1fd6f2d6c070840e8845084adcbd689918ce795167860776f0ea83ee9fb8b408ab62d979bd7b552f25b1ee05b9185d8937e0839f6b8d05318cebf0fb0fa888958d4d6e3cc6980b95086e12d99ee1133dcb3c2716ccfe6ac953d96fb3357ff75e75c07c80f81219423610fb4414eda02c328488d936a7a2f0906f8fadd569e55668d91a10edbae4a715e543a7b7e558ff73331f71f3019c2cfb290e57b5d999a02515a66ba157792e0b6574cb4526a5ea0ccf8dc42d490796017bb9fb0649bb52f7e133b83c2ab6385cdb2e13bad764404abeb7d4bb4d910eee278e757239ea96a1e98dcdb751150b4af515d69fcbfe6f3b6b4bc58635ba7142daf75a991822e09067bb303e1ffad52705e6c4e958aa788794e30db473f7a8745f4f3852ec6fcb48352be1e44348cc8fc4ad41a5c79d8be04a7324c5ca65ea42e8f5263b09ce3ae5fa2aa3b796903c7d494c1fd36213247256dad611237224b8d0c103e0cb42229b9e769ff8213fb29387ac54829545823b4f481f2b316d71433616abffe6b57f9acfb9a3bf295cc669c3a8c04f51b7744cbd1eefefcdc1fd990c64e00e22a65578f4b8a1ec6e9289c8569784047305060006de2d89ab8f15c81bb086260bb2cb2af04fafb41b906904b7ddca291ee6c662a7dc93b36903da35ee22f86f24d077c4503171c797093c4fa4382dcbd885550d776752300aa1a06b3b0f25aa82ea13ce0c9204fdd563fd4c113aa114500731f4bb45be0835460ddae1d30d1517c03204182a32163241130aa8cf4f8019ad0012a895e8700ad15351d919212c060e7a2bd37fcb1739594568e3bff50cfaba7f296063dfcd2cfeaf271b4f4669ca3db10a4a94d70315bde46d20c10c3920d8ea3f276a3c99973c429159421cb98a06a2506473257329d31f5888e1563bd46ad0086fb43724062fc8e2ba64f39c5ff021699fc09b089563f34c01e78d5d23d6d59cade5790a0a9fa31621f21fc17c8fbb2b9f5ead05facb9dc5abe801a5abd16180517792310601dd5b74405b01452c53b9653a5e85fad639e50aae839ae6b3bdc93d8ab9799efb6ee85439c7888c54b2a93fff17547e9586f420057239ede3938335da72d9a70bc18678c594174b133377d03270dd341f3decee5e631b02146ee79c81b969486ccfe6997761dfa0169914e2048527e0770332cc40cedadb7b19c43ee7e33cf27b9a55e159760e9c82e5ea2471979d234490eb750818a6976155e697dcc7c42d084973e9c1e9e6f25aadda3a002bf2decc3dfaa4eaa71111f6e623c6e48fe92c8cc210e8ce307749bad5e7960515065362f08b832d78c42c59a20f2f3e2d862d215b9e908c76468fc39f304ff64813bf025f26ff07073dc20be3f2aeb51f82cda58324314848051e615b069ae36d749892c8e26ade1edb4882986effff29d2a8ec288334756fba9e811389bdb7144eee045d9e8b39132f5a997db1431166296b13a6e380dcac7ffc641846919e5beac3a97dfda9c20b4834f38a4179ea074d2807b2cc82241cf93de43fd791f4ed3badc18f50c3772f16b559063fbf636b15b16068d4af68b5ee4894712e7be3879bfdcd774ea5f6e57fd751db0069036588163cf600c4a85c60330a3bfaf09498c6bf4f48f0d1bc469a2e9c633a83f5fcedc8f504bc202bdc68a8788eaf7d36e892cbdef743bb6cf8d104fd665baaba316f3f14f27f56c8b23cf73e7cd38c6a28f79b817bbe13d6df626869e8f7d92e65f602e3533108646591033e301d09c251133cd92c5cf26668c10a70ce3e05b18654a77306bdb5d3091fa432131e64b055fe1ad40019bd9ef0ab20a54343a20d71dbeda067d7b801aed6b8b86f7b1028880c5a01fe03525dc9d9882690ff289147c0c2da6b8eed7d57501fafdd215b05d4f9ceb234629b37829671bfd01e1e96caafb587867c2031e8c7bc51ab716e3ae8f0eda6fc4c12e308a223f9c76bc8f47bc7ae20b7e6facf60ca3dc0d330088580b99f2c8d34dd2f581c0c9a75d42940575c602120201d0190ac35d6a25728b2314764f3c8dedc0b59282a265e07652dfb442b910cdf3d0fcdb9d2d483656d82632f248868dc24ba5818be6c879aa1be8ae73dc41fc4955d572455410acd2349d1c582d78752341f5e86fa4db7b50bf95fbca575156f0ba745411ffbf4fd7dd1e69877b5e1df23d645831cc3934963eddbf9d56b6286fdf8ddc851e8b1790ba6e9eb7294de0903a5d7d38bb5138d68ecd4404db730c5f246c47469663876ddb8dfcaa0c4d67425334f6b0a53ae6ee9d260f1ea00cae5799fd538a3efef40ce1a13ed1b42c5619cdfa2cfb688b97f3272c92e74d846340dbcf13b363c80517a4e746737f50925184327915216b5825c46fe2ffd62b5bd20e295964fdbd43d15a0bee9a152110d3daa3fcd63641230c256cf387c8f8d54dcced56502bac40c5f8340160bf761532c123dbfb333da08c583c7dca876cf291e84e559fd71e1282b4fe1de484bea22476b6c11579ca0ce45a7c379da5ad2557a2a66e47fd7053374d3de813692e3fa7c9e19c0ee3d34baf019539bccef562dc24260b18c28ca6f62611571f9f731b8ad64ad204fe17509b7cde25ab4d963652c017000a90a9d3bbf883196991a08bff2f20cb39d0bb6952f3635a7b8d8741adcff8853c19d985d1fa80cd2b0f3bfe4b8c7df657fb4ceac03ab7cb68f2e358df04ede0d7bbe02d870f8b6df47637d3d383e499fe3b45004dd8a09edebeed9591e5bd304f03ad2d7cf1eaa415ba8022493f40f62b0bed398178ced88ce5d45a2901e45852b168ebd8d84d017549f6d5b6e4658ded1c781968345d2ad0720a88cff00dfcb3ba84b3def7eb814be7f4c986a498e33a49de2f8e032231921da20c321d23e64a9b97d5ef72409485be35c70e51df6c09cb17e89cfa994bd5e3682e13932291c05a2e2998da891a3cae2c47f891a9ad040e3744f9166d454181fdb0fa5ac7460d3754f34c23bfbc2353f6b30b543ce6e81ed261c45a5447db9489df761b28c2cb9902458a375c333faaae9e587aef9e4e9ca13c3433695bcd73a21b8682a4c186b2d6fb3088397375aad83770330357d9cd4c72a287ed8e3ad320aed46db5fa0ff8a6fb8923d56b38000051365a6d6d2aa036b81e4619c438e531a81dc2bb5ecab3611a3e034e8c289f46b95a58ea3b2f8a58dd5ebaecf7a200b4428d9e02737e6adf412aa2438ea92919d94db25c3bbe9370187cb0bc63493a4b663245cf3fa35e33bfd82b33d8d0d4df15c669818c1e9f0726ee8943d65a998920f39f5eefc5098cdc0a864a022967ee7fa8241c9573d04f0304714dd84be2e6e05a3c1e978168a248cf6e36cc947e1b4faa036cd6fcf70e675cf834a1bb1de96c66c5c136525a5d1c6ae316d61d697cd8837452c8cf0dbff63d2873cf0872737d91571613d4222a3913fc9c8790b2f27b86b2cbda7207366fcae7da6f62d7bea3ca3350993f684c1222da8bc9e1c5270fadc17c8485e51366692b6120f4b848be8d1afab0b0454f3104626165a0822596225d909e9b0b8200172b2d4a53c53e07ef8bc41f191495f102bf92b5f220e869b091c715ae68c85d27cd81d3acfc85a04561e761b90a692624464336f3578fe4defc439c759b9d87bee8af903a453e844461187d6f06a43fa3ca72a6301c00fd9e20639bb9ec55f5214d804076ade842c52e76b945e21b689fc5b93b91547ea3fe0b032bc7c78a8e16ae984d67343455ea7b5b041893620435f7b5ca8df1311229e129a5a85c7f7cf578fc45baa833f2af2dc261eb6a383876ad568645d1aa671189e09ce8039ca5fb06c46591206bc4d7f1b711e71d1633ae309978236474630108efe8fd13dd924c48be6d4175b6264eebbf21d91d8c7094a88f62be718d6ad4e34e2d7e8b7828c7a2b4177fbaea963e50cff44248f50aa1d3686063598d6c212ef9b3b729bc8ba541ded15a46a07bffa91f393975c54ab86dc3c63edd7d87f6e048d8deb0634f79c5b91383f3c92877a4f5c7cc460cbf83d646dc0257d0848d18c7dced7ffe1d0d30f997cd9a49f7a278cb3fa67c096b61560e0d08d42ad2aa06e0aecdefbcfb42e51922e524fd85a9fd06242660dddd7113efe4bda1803a81947fed764f760db6b727a5c29db5bbbab199ab13f1683ecca805713f3a85648b3b76f4d0d1e9814bb381b8999f172a76a924219d75f082c3e598fe3211a8957242f575491391acfbbf82bf8ecf32ec40340d2083499bcd6dc1e71dee3c3ae6f2a66c90177482d657690ee46dbaad303fd86ae43480858c4c444b7d82460567d845e62d76a5457d381c3e9300065792fc4854afaf70416a4e3c9efd7fa696554b2d0695bb6e16497e75a160c47a60bc994052f0b2bf7b13dc88dfa019cc746768bcfaac1533845baaf28d540691b65afb80851eac08b55d566dca4f5dc4a52530700b747cd4199c2f14cc6a47e85c7f87725082d6bd6be475c278f2241f8210dfd65930aaed2eeb1e500d3541ddc72aef180256f1c9596bdc2847c58567465cbfbee82513b6e43911f80c59770bc6cf1143ca83aa643d350002033b6413c72b7fbc4ef9f80901a404b3ba84b6385ad72bca5264b25f0e79391c37e90ce793136d198f69cb2d8dccc653f53e28a0a1756defc15c76f986e457d1b7e4c981fbcb9c74fcffbfe8b941818b383f3bee7bae280867c50d288001f18d05d1bbd2a05cfc359a331fb592a60dbcf0a84cda1fd15c6e4fb41277bfc93a152d624b4294e01339948a1013061b49b64096f7bf3b5b6c522dc635cee051e11b7e317e41436a9169336a2fb690486b094d0e0cd9cca105ec3890d481ceaa3d53c90a69f8f225aa80ccb61c8c93d4a8be306b243d0f05ab3fe9ab6ab171430d9ce5d88b454f102d3bf2b0874d4f68f31495385e8878fffd19b6c6d5f51e3802613ff14a0952ce683b2b2f5b7a88c3e89a4665bd5072de0028414ab59c004ce6d4f6c80ee4e0771bdeee3b0aa14dc3f9bc154505c23bf934b0a7a8cf33552c62ebe9d2e0acbfea009ef2e88641c8ab8a6fdf46ea93fb9e7d843476e9f9db37b313f6a98d36899a6c6838761685a2b23344f0302cd59e4a330648151c0e7a82ff470034dc76b31460f445abf363866dead93acc8eeaed02a4a6ce732a24a892c79d5a0c9d7e71a5d543cf575a6cef8a0cdef6a98ef9319a5fb4f6c707c33e72e673438746368d080a3b61c0523e7f7f0de09e3fa639c244494d0677f9a299a0da1111db0897418aae03799b7949f90e87755850b6b15c56994e54e272dbdee3bd3158806ba56a249260646308a7487d6a0eb447947d14d20ef42de5ae6e7bb381059e1360671c1d405d1a3b4238340bd657c96d92e25582c716c2563a10955190d7c526dfa5841b479b33cd378dc102e80a85e6fcf6bc61ae057c357ab6c71fbc3973028e8be6f28e00f09e0342731f147f5d5e37073e361061824989f4ff410442dc5668263a7478ee14fb91b6dabfd3c4391c671b1d3d7291190b57917efdbec46ef5d01381f1088e33883eb167962eb8034595156ba8c7cf5d6e0ff6961d4b51f06885d1597945ce6c1020139f07c567efcdf3a6269c71df7fcf8374a0d161609f4009d471870e4ff5f1d80c9abf98517f036cd30181c14af55009270defe7db4135992707e84d914cfadf919cc80832f08a86d23af7b1386ff76d3af5b2d5dfa4b69b872e5d49736a8dbad2e73ead2b120235b86ad214a9bbecb76e170f9c8226666eb8a93329801160a2f08b194a9c801cbbdb521c0bf54d6645864f0c4949a18822cde00b689a46bc7088c7b4801d370b222c78ebd235c26264e02b987ba99a6b50c7d89db65bbbe1a9db160e58b9672aad2e17fcb5ea347a260ff57ea9a6e2ca97a31dd1e9840e31b45ed9887f2cf54e2f45bf0909a8cab25340f4c1ac4e72c5fb54b65d7812b0c5f475b5db41ab641c314d05d004a527dd2873a7da76770e827709fc5e3bcaf86e8d17e99641734495db3679b9578696b32835620e4002c7f6ebc0f3dc1985e615d09d6066a6ec983a03dd6e33ed3dfbba5ccfef6f70c57f039380bdeb53fb77f362ccaeaa3ba33b06164e9ac1798ac350eba856b9b90d3296e6d6af93a5dbcc4196cca3f2b1bd64e68368890a0197cc895cfb7efeea537825311bf54f9083932143f8ab5367d9fb872502aaddfa8a80477a22a215141825fed07c9a411968a292ecf080221d36e501c2e5332b684b1c6210719600e3c66e273632cf1cbf06bd23e1a8b3c03de4f81c9d44b73bf98709bf93e5f03e5ade1874765bf57a39167395a11e70588a9b7d344c111d9136f76d1b527cf809029ab53844acb2e5e954ac31a9a2a48f4263f9ac0c132d1f8254dcc36181c0be62b4fa3df3159ad8cd9c0ac5dfeb02f9475bdf354cf7eae7864bb567d093bac68626ca23b1742625e05209eb69eac06cc9b100923abcea10c6cacf9f6634da66aaf3f2fb422d567626e164797b7b1f9ce883e783bf3fb4768e913caf5fbc3b9c15046a4493d6abe306d1fd9c7cdf2d3961d72409f5649d861dd23c260d0244c0129d00d83624aada0ef39f68ab8d4ef9eee15a1124a30b1db94b73a440418f033f609b5aadb482f7bed623a667bf1599583eec500ff5dfa8abfcc377509f7641c26dca5a7ed9a274be378e33c05f9f7f6bf6df853988291ab5199b43226adbab2acfb6c4e5dc7c614f4a914b8a4c470925a889bffe61e9c2e7906cb78175d6ef3242573337f9b03d73249a8765f38e364acc26b2415fb0265a7e0bb4e6ecedb7cbf7652310968582a55370269d82b51d31de4a91d2632580d0f076b6db5efd79c56bbfa237139006f64e70cbbf13de46f5667e827cfcce579625138b64eae443e67b9914280bf60da25d9d816187e1a3b07f80452d923de711ea333d9e6df72371fe936a4ad123209986cbcb2e2deeb320dd443ffda88087d3e6512062674e16fcc9a2fc7a1482bea92142531e7f264647457ed1a30a83b20c281103b312b01bf37b623b5e28e5704c208eb5debb43ded01cb19b84dd381d8d7a89c3041dd9d59e58b9c8fe015c34ccf9c2d6f3efbbfb5dda643fc2a6ecc21217d53ebb45e3f614afbb421f3d20984c08d86e04209c2186ffea91fa24a753070a89e6a4dd7b042299b48e382b35a9b514d2f97c04d7abe175215d39f78d4c6e6a257a3a84789f9262b9723bdab1ff2983816ed28aea6d5bac9a2b8b574533e225e90d76c42fae69bbf4c219314c2e0c0273ca13dc22ce258571a025f4bd4bfb8d1c18ebdd9a6679cee3360147ed01219b48170a866edb53a5ccbd600a565648c7180f144fc197fb85247dec56a61e5af537b7155a96d789f2a1e919508e2f2944cc9ccd013a56e178e9fb4533971fd8c30f582ab4e294e94d5a7267a667db2a881b4d1936baa76e18f9e65f62c10e90187995f8a0e3c376ebc8cf86027806719a401a0dd7ebe9e2c41bce8d911824ae5450fb0f4667673fb6e7ecf0bf9fa03dc75db6764637e880621d5598bfaa3850b22d6501d4b80d7b4ba5cf36b345c8c64dc0f6e4dbd7ccc84c99b04cf77e153c664231b4d144cd313b272e67e31260167b1e2d9d43da5c801e62fade55112602732275f59158e03c72d4ee74c8254f2683026c73171fd6b4fd59b7b1b0b736563a940161337075c55862dcbbd96d62ec1ed9c155cea977a33ef48edfbc34808cd0a4f5a4b4c85bb9606bf263470e9161d3bc8ea2fa18b43ae47ff5caa1d3b625d9b38d272d02d75ca1fbdae6710ec794b270ea4849cb1c92fa3ec2075a2a4bb824d32ebdba83bcb6d98e8ac7f05ed0a77347bd4ef729223a55351f139a50f6f4e6dabdd9e6f88f7705401608c0fd3f104626a599ee23b8a8c76c9627167e2d694dfbd6fa679811226297d252af82fe9f48e2baf03d4147d2fa0d348c5f100a50335c739a0c7810e76e6cedd644aaec1dd720ee93d09da492413b8bce232ebecafe1c6c29072587835da3ea37087106dd47c329e8fe2b66d2157e745676d0e04d63c7af01350d8544dc4c4c9d121beee901087d4d7e11d97fd384651a6e75a1d80c9dc99a637889abcc956252511618ea3f0e06ac828691b1558062d01716cc4de985a1e70cf4ba335d156577c5a79713a48c42f9da1a7d0f5ed28fd2cbaa1a7a785ae1d07d3ede55b5695f32156d57ffa10a56809ca9dc06fd01e623f2fb37c7c7af16ea9c7bb570b1f647e152e521dcd473dbe9bb50b16414e1dbad2d801de7a14b55d150a267beb4600b1cd8a75cc5d2329191d2a03ce6ed57a0e40f2bdab746f294add8bb6e333f5ec705112104d8f542e96e93371c8df4bae08cb30cc1738916aed7ad9e6175a3b9d02492a6c82ba12d37d89727b91eab93254dfbbf3567789fe239f1ab70f1079d6c9a4f77587aabcb6b75d729fae0b48a0b36a6275f1eff5e65617063cc2bb6915c0c79f8b5c2df83648e330300c7e02bc2dc293cc78311e63d574c1b9f82794c2025f7172e2093069aa4b93b8d976a05fdec671dce7f2d901f11fd359f0c17232a30e71f1e7016f3f5d30a5ea3214144b22fb685fbae5e77e4ee22b8ec1066b510dc9f26573e0bf3af5259ddc85e4085ba6e5ff97ccff6214a6d9ba997d6b33e43c05de477fc7759f2c35d123669cdb457ad8380dd70b60502598d5a02a997ee0e84cb6972dca3a464186c89eb8fa981bda06646a99171ac34adb411d0eff9f7e04f3b5a55e926e8d611a3e6e92ac62ffea1f13d91f2f39692868d354f3c9869bf3822ffe83a02dfd0050a68d647c0466bdb65af1ec3b79c067caca5d478ad1c17bae8af120f1fcbfd7160cd84087b5515229df1eda3ed4167b0d902051fbb452d021f149c728a201b14bce6d11b2e8c3bd3c169085a0348982d53736a39b7cde834f32e462003d547835f0b01e9773e59b33e921e69a6eb3aeab54644a0c42e991c872f057170e91436b4550b47165ff5b4ed47c2d5d485df6c4b444f86b6202cb20a4bda977dccccd440afb4f1dcd8924f2a86e64ac87ed2b06f7ec38dd55be42a39bbd90b6499f7c7580d731ed159347a6d6396884f0e487ff807bc5f3870e9d93eb9ada1de70be9394c09e431eff03fcc4163ccbd00d5edfab56efae02f8cec5b441768c5b155c19ef36e57cda9d1814e61b43524435c3bbdd61b5b6c4d17d058c13cd8c907b81524577cd5bf174492dfccb9555d03560b4f7ee07ac5a3124e6cd00f941b36cc9a675aa625acff3991a1d6ab8dc593b4c857a5f543d77876e02e993114a4af1a62c8af3f44d286042099d8629ffe1a59e786d68783d91f56ea445951deb724a7d66ca09cc30d68be86874d16e518ba7aa73a85bda9846711ebbce439df57bf502364640fb3238bed0ab6a1231daca79ca5339502a61a9448ccab56ee8789cdf33e63f3245482c8c818b9fd437916f30c688aab019642e0b76bb3936ac279661bc1353acbc346d5ede55e9d5bb5335802cc518e5e363274004b52aa21dea6d4df63fd745fae416eaf2b368116a4589a9ad8aee822e2520ada23952c324815f6300962ed390b0080ff7b11ff3953e48cc32c478c4b7eda1a7a38c97fe8586dfc9c02e3c5b3e8485b6d95543c09047e883af5a043494a870c9c828f0f31f6c2714c2cd83f85c63896466408a21fb2edbd081464246a295f53fd516f5f02c53a94290820a10467b0314dd33ea53f6cd9c65c706bc426c8359605ab88ddf757c9d1890a3617a4df5f372559b558d3f0ca409b3004626cf7f22252f04714ce307dd8fc1cf38c54b1734445b0c9c30c413ef5909b43580c0f3c9d577bf3e2ea731622e7ca7804586cf47df40c58b31f301ed980e71828925aec88e1e06a799ddb88f649846b825d924226d773790e9da51173d8f80b986ec0c1f643adc27aacd8570a8c228639057a7021810e726956dda73a0d1a7e03fd2693455212788b324443b8816b5dceaa48cbde1df0e600dd08ce489894627d50a73864028b6022f6c517051e6cf00abe606b2a7b580e20a26c3408d7a7a35da7ef446bbe8e75b55d628ad71f91b88591c6094126656cc63b45d71e44feea1d5ef06b323842c020877f421cb9a0526b61ed067656c7fc0defbc9bb7a8f0bdf9fba6a54cca9637bdf4895c67c468f7363ea9d981b38c9b4f3ccd3dc665aeeab4da65c1b2d68355fa6d86b729e9b6227c2ae372430d08395539a883f44ce479b25517c4aaffda7bee1e94b3aba7000f3ef21e008e413470f7897cf881a4fae1b4181179c6f7bb8f3bcf4db3d68cf0ae7317e52fac5d2697410f15413562430b587c64ad2f4faab334d80aa7c2a30b90c4424bb4b2410e62354361649c0f4f6c23d0f169120b26dbec05ad296d3df3d717a2e6c4e91b565c0fdf200108a0b001e25149cfe67233aa408c8172b8e584b3a64f00999335119276a50c6d43aed3ce48e22ac1e333e589e81cce779440b4c7130ba969a4f9ea5860b89055999bfc8d1d5d4a682da623868fcecda612d62aaf79d4b39e12c9a4a73afb508a4ecf3fd31f964b2594569111e47911d202e2fbc884886d6d831e295019a7890fa75448fba3b235e2e681e27ecfce117142eb7f48d7770325575e1282097a5f7c3f0840817c0719f2fbf68db134984d0e5d34a96f6ea157ce112c727b11ce25d69f4c56c30d8d361dba0dc9d743054adfee88b078c2368c439022832eefca0656c2a220239b718a21982f9c168ab5f6739a92b2f822bbc549e731bb637334ed0149f86dcbafe209d59dc1de457d054e3ac3edca6da844e66f7f360024368eff32e24aafb4aaf2ed7fdc2176c12135a4b709441e40e6d6326d0c644e2eb23eead5171a07cf35d5fe7d66c8acf5a57dfc01fc8819e8f690b654dadd8e8c628d87e9286502084a69b027ee13edf6f9eeaec861dc37d051a11dd53af67248804c79346f34111b8f81b32f59cf6f5456c5dd0e9278c725cdad33d104c563be560fa93e668d3e95cb824334815b1ba1ede8348c3bb0416f24d9ed61b95fb92b3b5eef8356f632cb562a4241eafd42b708fe4c1762ccfc7cfa3602a2b6b778c1be2cf83d1cbb1792cb4a95e422a99744bf9d88138086301d78183ea02271e82f0f2e9d3130a51bbb4e247cfb9b50172072a3452679d616ba6e70b6addf150c8e8ab49ab396d4fc0023aef08528bbda002f475a0d66dcd2a3305ff1aed01344a1934ab4d33ecd9e67e9c54f893abc236eda88b03ae5fb817e6bf23020979d504c8c860bc43c58a030172cb9e7cca9b3ea8be116e040a15eb1de13d4b431f5435bafaa5a79d06f0f870a46b2a2b301b73e2f7c1a3b8db1c27a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
