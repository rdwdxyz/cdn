<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05f700a9b32c770044012919354b0418b9136ead7a75511ef58a56bfcb6a2baa90023ff475b1597679de0b997789f1a1bb3512919a430d77bfd44011dde75cdc83dbfa3e222a5fa33cfa4fe569cf565b7dc0a09319a710034732c345385558afde25352926338985aa39eb52886af385ae553c364e2fffbe40b4800f0a2a6955830ed77024ea8bf6e60941aeeeefe9d54af3fa99b64b1399e9c97fa79acbb5f6ca3d8d26c9f1db5a8f0526cba68d7f02586b348f33c231b8aaad18241cae75475f052031ef59ad8a8c2e74788c4435f70ad142369edb7c06d8a1f518c89f31e374b255bac6f32b5fcf55a394655f3761265a6390729163ada3347406b2bc69524d3513d3218cda6ea1535975c60ac796d2eb03de26f3cb10626c98ac4e3a8beb028d70197a10030be062d5f39a4d591c46a28c62c6b7a04e9620274517fc8f9c22b2c44a536e00768aedf360fedc5da8884828d2581dd1f19a7044f5041701e192bd6ec6e87b51e2f24a7172d98efbab45e31c0e5e459ccd5a3d9c22f76639f1789603960365d6bebd4e2115533fbd697d49e711805cb011a1c95339f0a477a8fc396c9aae712bfe9d1a42c8486aae2df722ab5534679ac4de99776d0be41a4ade666bcf4aa84d076ce77e29ce5d89f7a04c13813f62c39f0352ae7ee2e564a2c78aeaf401be927a82c675629ae27dc54c50acc16507f421ce5c0f1369649b407c6bfe236d73c063ce522b5d254a3164f58c34902d8081ab1e708983c7e34ebe2cd7b852dcf7574585e146d38aaf2d05e76949011731f3f8a5f0d01ccd7b613c7c95710b07bde78c0e5ffbb2e1d4530412a94bf1057568be492d898e7d32d5f67baf31b51913ede1e3a091fb94b78780f2069ab6e3045b09a93ad39947201123b37052bb124aa449ebe51a56c6e46adb7f5fb56f0efdacec06b0b4d2505662191baf5e7cd68340e33eb8ff0593518be3bec2937edd3951e6108ec0e1d060d5c921f88b6ed09b250f29f5e682fbb699e24b2370290728b928a71a33d1c659b8e3b9b4f3f6f34c379becd97b1b99ba7cf29dbfe40ee43d06f9b08b613118a08b28d90b4e8851ba7389211742dec5d30d9a6f3c52191772f0a842c51f3718aadc2b7e426f9bac134a02801a0e4a3014324762dc3af247a10bedd9772f5f7d5690be58aa661855124f13f4a5dfefcd7b5308fed10dabf73247f6361587c9bd7df105e7f1290cda050c9eb9c1427ddb89b9dc13c7e987e1311cccdbb8209926394d4e9b4b554a8b7f3c2f831790efb4e5a927fa5afb20f499ef2a2b0a8e833df6c668976a9131560500e1e019aefaf8dc373769b27bea70f15b8f8ef4691b01af4bbf71c1c41e124c9372b611ef0eacc05b9175490460a5dad10b897835a9e1fc2a1f79bdf15830f4f19201f7d8a4ca08fec3e1b481f636caaa0dfa5daa8fbd6a37389a08b2f9a99fbb11e5129e354f377dc546800cd5046a4ea2da5ec82b3588e6102098d337bbf6294632e030d6ec864d03d0d9593758b6b1c553b7ac0bb6a7203a4641a25e98cbd2a0dcb3689076953fd3d407b0be8946f31b50282aae6b28cc6818a7bb68ffc7f251f4196861e87690bcc0644b652687ccb9e69a66d777fdc1b43869ba543caee71c4a625de2673c60c0518eee04bb9b168f22cae7c28dde80476a14f7bfe1ab653c83402a61724d949bb9abd273d54be33ac39c7d61fdbd4b98e9fd79f839e3e1b2bdae082456c12d38965f811fa86ee7d710c020422297586db9d835f4046d5f3707df60c6ef280f6c55c845c6d50951bb33c109d202eef86ae446c298f20e4a9b04e42b631eb06a8943195a75abf5054302153d951ca2ae7af730494bf2a93b25d8026e0dde4c5eda142fc0be9bacc11172cfa327e844f881a31b0344e06f6a93dfd644dc0cef7afd559c2148e92dbe5f0d0e28bacd5c2502654654c5c9a4a3c88272c637bde16633f686512d7fbb352e5ca3ffcc07b83eda99e2db101ae8385148eb9de1fbe09ba1a3fbe6082397f1873f6e728f691a3af68e1078b092aac2de8127bd71279f8795dcd9bb66ae160afad6544bc24aedeee0e7b5c8704b41cdf7921b722043dfeb9d3fc900fb05ac9e7af9792f997619d81cf59c9bcbbec609a91654f0ae8c0e0ebffa27404a4d93d1f9c6ee72390764e2e58ed4ddcf437d27c0a82415a66c6c746d7da30ab2b90d5636149c78f57f24499f856a186361dd707f7b56deb48d6d436e9e77cf693c53eeafa7567e65cb0a8889d57b89ef57472e544a37a7e7f0c7772bfda37535015ce867e8c54aa2097769fc3fb3d41f0009363497fe49d198775c458c4c0c543f521c89915d3489e0b729a35e6ef1f93b5ec127df9cf9caf92cf5f0db4ce737cbdc0f7e80dfa2c4fcdc54b71117d4043f3038fe764da042ac865a91623cb4b76558309abcb46703094b4ea0b56ae93a0a74aae17f29e2f532dc6c8c6764e952c96713728fadc16b4f8cd4c901110e32b691c583d2906df2d941c54e7163bc22e59f5086b6a0086743b477c5ded6ab48553c6950e7a0512ac573557c8d21c386735807ef11a5717c84e2ff4e491bac8d21c2864c894d55b54b1d984238d725130cbae7435abfc2c4e2234f088def53407dcce0fa177639df8969534b4a3feebec1e4a88d963d0709dd8064570cc9817c02e276764615a30fb1f1c285de272a711cf23ca43cf0e5b741657f2b795b9ea21123f9dbefee3c6d21f9c1d9652101c380b640df62421f6f6bf8839f105f5fab7ab8f484a0dac6869b65e30fa27c584f1acb9bd3d0e6f3317f0baed4ce52c7f976e75195cb115f1344570d96311eb3bc762229f859f1065c6634cedb4bd628cbb6c62d83ade6dca222e0ea8b10f204266854726d088d1ed0f44ac909f36dcbe4e9f9e985dfb91df742959fbec8b37a1dd1bd9a844b1b56fa936b726e07b31f6e8e79dcf881c7dc36f4f21e2e6e114245b2d36f25a83e7f8bb2ef5d84baf7469262abf773b8d86dbe6bff1d01bf36a7c9db769900b9abeac779f6aba860731033a7da5aa643e76c6e678eebc2c3c21948e3b4c781489724d249a27bdc3dd842b22293f11f349287664a55de20a4bf502f884d0e05dcd0c0bf814ab187632d61195d9d10c656d6df4479faf7602d2894fcfc17d81bf26cb12b2ec7704d16fc1b2cf749e964dedd02129cbcaa6cf6b3c25b777232257005f5170af39d94c59e9d3ca902826113d696f9685a2e0d6647699d4907cf13c91912510705c46e90d4817886158f5b39c39925d990815c95bbadee43a6f38ed96c7c91c9d1fbf5acaf8484e72fa6c0b6a9dee3f5fbabe9f87d276ed6ae2ff67b70b0319a7fdfbb4da921b16da0844bae4c59a19fd97a859a1f2b536c5b9b12ddfefdf57cd4bb7bbb72f0efd25cd00fd58441694c9659ce66c09ea189473b5d6f0fa3a7da57f48be6e24f0fd131b8a4d6c8043a365bd470756859b8f58461e330a822e41e05777a2e5882d3528720f13425d817b3d05190b9b934aef10b59c6b33b75ba92b7fc406313ec37d2f64b649e2ea9d80bf39f4d66b55bd384dcf2a9cfb0cd31afde180abbd58da230e88fa5794ea70ea11cc3416830fded71898c025668133cf5acc3da40d22a5f91b8f3704c82601917ea797939de91f626bf96449b0b0b186e6871ce6c45b3fba29639e3acebbca1e88555bbcfac291a8f2a1037dea441285ec4f0dab66737b8e93f2c7420e62ab7eb218c3b8c26a123345a02ea808d5596164be63c65af69db494dabba21ea34f3a92a83750b59d2b265b1197a2d1bebb2f0a32a620de00b7cc37792df99fda3677dee7c91e0eb27db929f09241af8de1ecbbf345203c32d5f754ef7b68eb79ac4116fa8343458d12fc6ef70fc45b66ce01688af12f6e8eeced7c84f2ba8aaf460dc90a2363d5d38e1a1c836b2add247ac2a1bcbd34b54baaea7ea48eda59a961e47608f46a9946a8963c8fa4a9f9872a67f71da96b477a0a536ee6a7dc3c8e9291375dcc8bedcd0019072ccc4164d874f3f25a33994033e51ff7cb64a338a2b96200e501dee4ff3f78920630278719d6533f9598fb973349c3dcd65c8e88bdb1bd0607245fd32b2dffdbf125abaa2bcec0f7afd0726c91e6126b15e595c08f38ae8c3894350287a6f4a986b50e3b1d7a5b34c8c81c5ffc3ef970146bd3ae6bfa8715f09dcffec9ad89e8538e0737e6ee5b654a349ac606c35984d8be475ad5ebac2a0fa4bf23e1a588144abdd5703b6feff5561e4fe52a840c7633b7ff2f58ae337aec0b56ae9dd7b416772b1f1169459eff18da87f2bd2f851ec459e36bbc955f8ec7fa4de66e98cb7e735cbc5b61765283a6589c6e0962df50591bcb5ad5e4a930560b473db682bdbb6054bbc417e369a21985b488174007b8db7d76863c5141b512d5c0754722ac102e11a4d682d0197394cfa1de1558e4a6d012abba7b9270ac50c3ff2b75a4c067846b71ad379c8e277fdc31bfcb1610b136fd68f9aef3fb6194acae6b15f4708dcbecfce4e8f4129f97423e033177c08a034cb08a28495de3a230d5df838b69db4d924f4363381a256eb2ad852cf11e6d040dd0c0bcd90beee56ca250d26894d00e26006514af26ca8c6d6000dd85ecc8c9487c2f0e75998ec43c45032394bcb45088599241d7c34dcbe75c51b91cc23ee7a77931b580374d8c8f19b825b359c711267dea8c17b5e2b06de07c0d96997870bfbaaf3ba5a93e6494220f969fbcdcfcf7018ece92f2c3b8583e60f6bc945fefb90a9453dfddb58fdbe865f276da6de9f17acae0cc1d5cb897f7512370df3afa33c59a4268bb2cefafb586204258f56eae2e2779dbcea856771443ed044506eebc0474e4fffff4da5f57b826cf93d7bebff1d9776ffde4560f95dbdc5c14275a4065abbb99605cc8579c831450c8fddeab7b600d5db8f0600cc09b8532d74ff95be14760b9d21348b4e0d3ad393504c1c9655c481cecc7a4aac3ae29e68549cdcaf37c15facaac4dc8d094d4615c6710a23affd0a1842f3640f4e63a7ab4fe49c9f386ae85474094acc13c4bd2c280754594bffd6e70f7b67ff37c9ecafd452569b355c164e0ae8e9af829199590051e59d4a14a1532da9def0ebf18bfea59546641a39b5f24441f550bb9198a0d8cd7de1a7a3a1dd1f78876f35e8b4d6c208789e062f96eed470675fecc05b88cb92fe5cf866b6dbecf29f1a99c173d28dc9ee613059b260fe7df2996404faed38763f95944f2900af6c5af36d5acac60e7edd783e0f483c09cf7c6f56aa081efb78b26291c2e08d17446f6edc42e53fdedce7435ae3e8fd7296c866051927a1ed384e96d560a26b94a5780ed6227d9b939d1247d41b81bbe2cf0fdfee4230ab15da69ade635c9bfb207ae479ada86d449fa880ca6df184fdefb754a69cd501693b6e571dcc1bea76438f3949b9297c08a4574b0413f5fa8c6134eaf7443c5f84ee892cd6ac0d1703fff108e82f40e815d7e540e35fc9e8f8626556e68e6a68ed561929654d8d0b6cab46c9ef63396aca0152547b567b4853abd49f517a0fdbe2217460ecd3047e140f1d77bd92840a23e3fd711354d5edd841a2713d3682765a9a9da10a90938cd70d243aeeae64fd982e38d4ab131710555bb6edc609a57f25fad0288032db570195f1385a6bcec60390bdce3569615fa838386dd05fa35861be1af92f4159da9a57a1e3fa8b3d2290f29e7e33a0b334f359b64e3e99572a7dc392631bc1adcdd2e4562dccfa9247407e13b54c9bab8a389ad1d9cbe3fa22eeb83c22958e86225d2d11c81467bf5009653836e0541d7ddd6cd9dcf74dca00c5d9a24792190c17eaac10f9ee9b8eb032c28a8039ddc08a06dca87e83f60debf8c0dbdd8da22bd3e5aa18c33870f9767cb36f0ebe95a24780c02c01e45a6fb1bc42f53dbdbee42bed15bd46ee6eba4625478c7debad9eeda9356aaa87c7ebeac805c4e69fec169db2de000fe3400d5400122cd8bd4478ece4603368355ad7ae28ec5fd9e23a66897c6903b6832e4d119f5358830564b86b30158352e4ec87ce52d9ead99127e1b91582f48c2d05d6d3b597806aca59783ccbb10a509663ff86841ebdea4d32292102b869658028a800a939af293ac4fa61b6cbdb5a7bcdfe03392bf38d56666e19273bb178f9066346072894871cce35ab6e1483601f9ac21da87ca00a7a8e90f489cd521ceb819b4693a955fbbdd878a34588f60a437dbdd899039c2b6d1bbbbd9f8290e48726408c0e2b3f0b49bb0267a1a15de13fa0e5c36373b0427523f27bc05f578d2bfba62b8e1c05efd589ca14f281e62fc0faa84d1f370f469295ff3a2f20cb58dca16f716da4db3df217e8df9881ef1ec2bfaf6855401b694db6843021b11916bdbea965a9e2a7eae521750492e430865202fcad822c3802c9de72b09d56b478873417bed690c8899cb3f36f7950f73eb197751d9d229df50605a63320206746f58c613b82161313f32dc6766c5bf560ed7d2866418d3824aedd0a71927df845e0ae64aa5cb727862e156fb3e9338b0f1733dd8dc8ada9092de24b3b2e1eea4aa5d10eef0e4dede1955b0631efa976b1168e8d37258b4f81eaa335b5669e52e3cf057ecee7a1d70c91191167dab3792ab4fd8036dadec88b012865d6ddf3d568ad609bb1d1383e1a68194a7f58988d3f784fc5a498b7b6cc607651eae716f46b448bc988307e7fc5d6f2c56adcdf5a32052c5dbe4b977405d2400a1d0b749f8965cdb10fa9bd27f95fe4fce448be8cf2adc974622a81167cff83f2badba68db69a9f5098556a4a8958122c02c8bdf0c238bb884c7c632e8d49c7b7bc8062f91deeb11b0e7089e91eff19f6294e7c3fc297634f25884f57a87560771a37ea8e2745a178e22e7ca0b91b7bec4ffac152643265f865a75f57f6fa75c24ec7f040cd7075ca6452c437dc7eb7df6161553c8a61b89c67aab36291c02a18c05a751aefbce8ec89e99d37b331770fcdca6712da97877524f0e617b465eb22e616d1d7b31a9ee73604a508cd3bfc257efd3a21f71128bf92aaea4d83e47e1d55276fa0097cf4e85d6028b8210f42161be76758d7e612d259a6bef2748b9aba90ff7789181f11c394a95197cbcee1d233d0c9a631d68169c4d83c27ecd50143a3387a18a34226bc446aa3246c4552c83bf9b32ec4feab83d59781d40d3e7af84b060265eed2e57dc9318a07d82208f7b8eae453b632ab44e0de5b44cbb00e348999993c82e77845dd9b8a219690554e29ad87aa62b6aad50f3945d873f8671677b3399002ac08618c954ab159febb53a67e1ad7a31017c6793816f919151a6c7ac1bc1902a31ac0b94081714d00eb7e2dce12c63c4a859391772cca7133de99b6dfeec033c3851cbb97ebf2291abf101aac204e62fab38a356b2a40d14f0c79681c1651b3e6d460f7a5ee447a02b17e71180b81e23618f52d10bf1bef84e4d78aeaa6943d50d0f7806e72fb82a03c53bff71926746413a058ff49e520b77b141bad8fe2b1109f6cfb288f87ae3b75e13bf4f9487f1a006237454fbfe3835772074fe86a7a1f8358413f55e132dfb348b12f7c31baa2d32b9b326eb7057ce2922645e55af1378202ae8b46a32b7d859e7bd6ee6a55655dd9fb8eb21e057bd6eb71f016bc15316f54c0506547c5ef1e9af3f8c1d2fecd184e24fb73428a0d7a3c05e8ed84f12bd23b9177c020224aa44fff241ea92431a1de07f6c24c44a81de82b26a698dd40b5625607416fdb1796f5e24fa95213cce7d027ce5048588aaa20612121718ac0be89b2b810f480c28ee840044cba616a343acd43c0eb06bbcda089e86f32620e5189463bfa47337c0285a382fe8fc42ed7a83927d8ef93ca26d7a38f7c6ef8540914d4ac5880a9aa611b5125e05af864c765ea9838f15c3a67291e6877e89461e09e5c2905aa2a3bbcfdb061d7d718f8b10a632d6927837e9399d4c0ab4a45c619b3a6a1c799440ff8e9b9b4033bd05a0bef8b18a48fb210b2bb6e48c2a20815fa1126394927bd15900a184ed63d170c6bbbdab6170075e1a0a43842795535ea59dc0480d2780701c047935a4c31603aff4e2080c2cb49d8858bd32cbda698663479f2e78bebf2d6fb4cbcb1b388162af2eda2ea986b192663c8823b686df4c319c30117681e6853cd252cfe08dfbd426051aa7869308eb1f714e07cda48b7f917ebd7f699f0eb165eb5101e2b15176ff784bae14a11682c4cf37135df7adaaecb89fc7b888c26e18bc1b1eebbcd27f79bca01279608436ee19698301805550e51258efa62b1f4d56a6edbb8e27d72e26ec8c106cbc8a7d3b72d80c11a71adea4ca743f1f84b841339c90f609318d765a1300ad6b0373105a03fbae4a78a3ffead78ae74a15018f0bb501845668e2ad795429914ad45af853fcd5de5aae9668a54f7f9c211d5d929da96d3ce10a6e18d2d4cfc72f7f5f77c532dc2347a136d12c50fd5e12e921161ee3e08b7dd84be2b585f1592142abaf9fad7ccce4813bad8679850e2811fca713ee9fad2d5f575662f9e0a7c09713cd69e89f977f88b6276c2fa4e30fda90e3c4fa900215a6ca298241a84af0b694ff92d7aef34e35c0dd5020a81cd7cd1944c8030feaa91354050c16da05edaf5fe0153485ebb7709a81e889fca39a1866f0783469c452187a41dae522aa2ef8ae1084bd581aac05e6afa15426108c2cb851900465c5b3b0627af8a7c5b2bb5d336b2229b2a80e56ef8858f14e75f345f708ead4b96fe59749c80a11aaab17925bfc4fa4ff21dd28d567d89d5172236f29449fac1d270e7ce3711e85b02239115b660099b74fb96a29b2f091c61a20ed116b4cc2c7148f2fb2db4e4eeffaf409a0f220b7b06b5fee30e8cf46789d139ceb55328081b44c9841956d6b7fd2a4e575444101368e59e7c2c5a1e5fd4cb2c46c14d24e8d27a2e4647981a85286713d4d691be3bbe5350d8a91be19a09b24758036e499079fc2c30ead765db87c3090d525aaa01736da5655d75643ee71b6067d4f5498fb6c9ebdf93b1c28f75fd31187232c65a7a3f1ab855bc2fc1ccea7e40fb9f32a9074c013c1d32fdeb47299b2e349709085366d9b27867c07658d5ba52b466395edf1ee461d386461db82d4aa096a84da9adde8178cceb2c314c6779f29cca44d2197a3be915cce3dc2c3a7cd421d6b6acb2ab925d8dad41381ab7001667d2f85055901896e89031da637cc6f46bf329cdc51f707d1ff351fa148f4640607cb58614b34fdc5a3219e38d7cc4b251cf1cad8574a0ab5948f7b4e16ec12dab0053c2e6c24dbda096215677d76688711830c07c048f4a55c7f46aa059915ebf9ff96cf66f4024383bd455a7ed12265abb1abb744be3d0c2040d8e2ee2840cc6e52cdb9f2f2fb575cb6f50048a55101a6a7349e2edc6b2937518bef06959aac5e721828319f5e4cc9b6a5a36918151687a9d13471d891ed26c3178195ff6f1cd2d765200fee1d7f711f756fcf489658d50aca0909fb9b1de84b47794c51e3691fd3b90881a262e2c63b0d6022735edbb58f4774c14578c7e5638d5902573504fbadd0d9327a70b1caffa623226494fdefe1dbe6723fea852db7844b9ce39f7155c9129524ef75e30ac783973a669822a9ec8237437e00a62a2c22a3ef507db59a492a921476641c7be5815a7076affec2e1ad5a7067d1b7a344e064eeb97d377168339bf9f8ffe7cbbc3f22d1b0fa0c2892a490610c0473a5d270cab1ca0abd164063ac11da734c5648981f5454618d50075065766edc483d56761a2b4811337ace908356f47b97ea6d3b2ba03a68889940eac7d2fb13904dc921867fb6d5498494e095d25617c5dc250ff24e07482367a071ba5a0e75da3a33b132a7652b8f93f7371046869672c9bc00e904d38a63930a8621a0ac41655b04e0aa81be3c5ea6014c42c52640bbf767074c6a7e69052003753e66926bf64296edecff2fe60423873a2e3ad6ef0d43f49fea46debe8860dc7f0dafd505e8009667b5b80e2ca81d551969f53047b3ee6e8e3004ba27fae00ca13a3419922050b2c85d048e4372ceb40f416b0496dd87db58cfe595fab00fce981cb91099112f969c24ed2bf10a7e4f4f10f4fa601f337f80c237ca82263b0f655a831836ae718f0d36411cba98e2b9ce34a95e02e04028b4cc80c31c77f933245cbf17959831b699129b6635d1ab71ffb21b12b42664c1e4e12f9a4b7959a4e10712054da0e5bfcb3d8a2d3504509b900b0f2cb2e50518c295f7d65d4c71c0ec0601c6a22fd156482d879cac9d153d6716f2b802723838369aeb9c390ebe04e4dd2917312580902704e8ae4ac9a9a2a9604bd59f0b61f3906513a608e481c0cf53194e1cb65df23138b1bcf0956bd46aea6962347e5a0727b1e5897af58fdbf4bcc8f3ad52700430a852b40a7a50e407c209591e492e27a218b8429c390d14df05e1d0c0a7c67b3ac1de755ac27778bd1192d20f5f83e23a58773e02944a306bb4dd9f53d2d1599f83e63fcf87f26fac1879e7575c66ef5a86ac381fd4702800485fe04b52680f17cc74d3a54db013a609f88a97e215bb48067b2ced22ed187ad3c9358f32dba8cc1c45b8422712a5bf43157615a695809c950872d83b9c8f847344b5ee76d3bb7b18a27197e43eab0cf892ea2f4e9edcf1a2a11260e25578d0f1aa7d76b9f93f14aa2b026714532e844391f2271ce625898e6dafcbee8924e5d9930dacf3f7c16a381eac9778f3d883666c2a7e0ef0a416da09bce72a8ab84c5c343592e4e1207f8525cc20652c0c801e80d261abe857f7236ccf19e267555f8b684105809a8b2b26c9e7c08f0168e9544f8cfbac1fdf224f43dacf0697598ac0182d9fcb04e5d441d202170f61d0140beb27d6c1f10cf45be0a8c993a73fd91c335ae48e0010a5ec6dc16fd7889cf641713282223ab8c3ea87d9e5b9c091e9371070ff39e589990dc4869b786442e6057459f180b5778d8e2fd2e2b58b079d50ecdf6349702d9892962860c5471d84adeee814f9422e159bcde52ffa3d24712c8c4073667e066255f7d7bb831601f319c85f821eb32bd0a4ce8cbabb7c1ff07a0cbc3436c0d7ecbe454286c7ca4b2b6cd6c934d9e40452ca18a2a885345793bbde5e49a4db227b9f6cb57bb49a57056435ef3407261455d6f83dce3be5d522c31d1a33632d40a110e625eb80ab543b4d04adec9bd6adf3973b0b463d703705300b2c182b73896356fe89db5cb86c92db683c7f6c5dde6b15db2026a745149c62f917ed8761dee1a5e8cdd0973b69454d389ae4fce39c206a0b71d228d61641ed1fbc9451322b281f291f8d82a487b48027d304abfed3b1e8d2d729ea2861d6e48bbc1deaba524a9ab0e3e42e4f0ee8e0b5978719c54dc76a389f50e1d499e2e64c9ac0c8597662092b999128fa69eb27bbe253fb0036612c8602ee96e3a29e20dc3c305a71c7b5083a3220230dc87d2fd2e02635cbff0e56d1e4d0a01cb93bb6fed9dde5cd26169ca008a03423ddff995f7cf68890fcc7ccb82e403f38da148e5c832180416bdf385b1cef6fdbe033352adcdac744769c29b3b7d620435dd8b4c820ed846e01b91a7309accd7189496f8a0132ad6a5d1273262a3317b2283b89ea2db2f396cf3a75d27d277d98f1e07d0cca94adc2c4b7c47b02c92ad9ddd78fa58a4858d32d0fb8e059f53287264e869177bf49c5c13df5721b0502d979d96f944a825e1d34bbf35fa5a63c105b769774ba824c8f8af57308e9e68b546e8918ca84c5b696a346f8ac17087af298d3383043b174e0d2c5dd85841246806395da518e7c2b64bbdb2224e7ced12757a13569e94e7a570f2010faf8daaf77c01e20d5509ab5d00831314dc3e92c9eeb1155f0ecf21641ab75a8cd33cf85b994bc90f436ad6240d43d9ae3f1c34668b5fc4029f3b143f6c7f2c38e34df3376df3fd709b8192e2104832507c88e35715d102b976782e9066b1919767f2e48454729586ea68f193de4296fcfdfb48d8002b296d0596ca64de399727cac86817969130264ca080dc96d42d97f9179e2f8e47a7f7f9e7cbb8eef2650e20a892cd19f708f317ab7ed43541ab5c4a726c5853a5944b862869f876f8a9e01da1e5a9e9d0e184b9c84e96c2aedecb21bf395425862cd8704d75f46cfc8b149c797550c792f0d705ea2903be250b0a2aff9a955aefc1bb6c4ca0af2208e41e2b29a6f1744eb92f5233dd67b05fdc38510ce0b8407e0e462f10e0b7942522ad8c2d67e55807e58fa8f17d9baa952c5a8a97e69d01c2477f7db1bbb77814680e48b2878c90274e1a94a67bb8cda5722876beb912c2af674128d35a75d4df44ec37b35fdce7ae12acfe57322857962316fc82b60c49c31ca17fac17f44cd70487babd9b9ef6fd7c281bd36a0ba3c6927b5d876cd34a97419b205f4ff51253a8c773f1fb0932e1992f4cd964cd470d08f8b2cc1caa9d3b4c6c2825282ff78ca49ab4a32359e76a6c7bfa98727ececf2a185f711883a97aafbb9cc9f3860fe11622257edf20fecb5ca54cc22de707750d47ab0adb061a6fec6b82246b994f1bad4be6d027968df54c390b359c6ba9f92f4974235a6ef45a187aaa4f14772ae289bf142ead875c395c802552823d6561e8ca56617d1a0590a5b05a285a93cbe4066a8dff2c6a3109f8b91c010fcf6a6295d868ed8b430334c5001a0fc20390346006cba98457516fa0251e4c6e4e63563ec94c31e254678552113e7f94c1c82c22fa4a1e1a67fc3d8a56f80253e78d47527fd4e4b5063b48d058b3bf96bcf3bc24d9cfb40dd26ffe9fc16845ce8d0cf2e3cf8701e244a43dede958b358bc0ce82192842f8925523c7c966100348bb5d26fdc187145c4c835664117a949d859e21fb87442c5a78cd682f06f36a7b0059b421dc58e9981f56b387dcad38cadd164d0d8e5e84b15d4c3adc52eff0663bd9304fa54cf9729144c48ba041ff9b59bf4aa77661f358ead1d91e2b1ca13972c7a51720643f8d70d21e71fff08244fa82d0e928ce0a00e4f4aaa4dfa44298feb8182d60a5ef410ae5543a3b3b13d0e0b1532f7774202773731881d11b2e7a05078ac39dd6a1b13b693dd6b55fe487b3a4c371eda24ba7ef32a4d31e12eae76b3c315d83517729f1f03999d03648fc3d520433a063fe26965cc5dc25c58a31a3ed75d69cea0a798381e5342b26630203fe70e8a4b747835747be9e4d6cf58ec26602e8378100eccdba804e3ec3134d2b2d1e8eeecdaa0e2db0ce929ea9b6bf5ac428d25fd7be53e94222025f05514f6cb828d4ef5b02280ba4c989822c0f353b13905ee67e88ead576c2421cbf565b1ad85d2e36a68738e25a45f4113f4cdd4209a9e84a98ea8a1d2f4dc2a64f8188e7a4bff184abcd9c6612b9a14f2307914f15adbc844f68ee03424704f4ed429c50771cb696302ac423be9f00ffb0eeb67b374ee02bb35d1e64715e1cc53645ba6b9da5a2200d83f6a542cabd7f99541a69bca4e98ba386f3f91ebb0d88c210797633c2cf4ba96d1504ce6a18abbd193b43e82df5b14b6b3fac88149b8d9b4749c829647488ac76c5d5a36bc9b90317c901d449850b4b29f5075b8c015b6862955be1c7d85a925156330320a4944f26c6d9bb73ee4a5003896048b07c0c09196305215dc2c5e14e25ae70cdc2819489cccde02217f9881d365f98248722e0d0d2bae14e0691651166cf0b4d240b6de23cfdfee94704fb962984239cf03bf525d823b2260c14839489456ffef9598622ff3660fb6acebc81f79b3748230e3d03a463d651a13c97a47cc04cdf6c114abeaf2c8649a9c81cb6020844009b5183dee80f1776f0cf2c516380845836dafda87daf43b4d2ad530fadd2e8c8066b9871c7bd62d818be7e60e721491eaffb4daa5e29478108a9e5c1594d1145ab698aa87656f65f0542c33808eca53ab66321b4fd1e2e9db24e09cdf42d52c2723a9f125b051da093e1651f443fa1e837ca61709aaba469f8ccec70383035db23aa9f86096c35cb7bf88c286d8557c9e389d50507d14970c19ea0ab00207fca0a7b483b618a826cd87016c9541884815b86641eec8b0ece7be21e72bfeeaab1b802c47ee9bb2b357882c1ac744e6f6e769661bcbbc17c0643b7513c1cc8453cafc6134c223e1c86dca6a39a7c8b0ad0c96e17a3b485016fe43711c2fe51340be33fc14db15c235dddb816b9e9a19399b4cfdd7e61df940151848e11baa823c27e9b4358a859ff044cf4d03e26fc7d64fd6defc88cbd12d692e2815416444b6ffd651aa57315b2b753ce5ccfa458a157336c228195ff3241ec6a35fdb56fdbf5dcad4a592c88abc35e1474561ec03dc59e8f19e3037df01a8348ea1e445bc66567f890dc544ba823634776605420aefdb60d0d87d8d3021e6c86bf92c5e9da3e8b17fbd19d0b5bc4794dacd1a49c75dd5e8c86cdbd7db1fd53fd29941b5d9320fbfeb1601aef2fc233015c0194ff569822f0642aacc10052728057b3dde812d68845205e226767926fcf24413c39be7a6d9060f45fc2d2390ff9369941e405430931bf4c706937eefab2c7836ceabacaa3fc45fef6f761c2424556226368578c186da3e47e3dc78bdde871f017419773a4e84f665c803ffb4f39e9a697175ec8a59066ce5236a95eb0701e0d3090156e751b682118c24abe3526d1c97e824d40a2a2d16912515fa69f0f25a3ffcac1c526a6d9918c5170af81a9c83a75fc22098bba243abde979c9a6125e27f79ee8322eaf4af090d2eb0ecfa209d09ccca485b7a63453a5dab14ef8a157021007cc5bd0f4d6bc623de7fddb7de3a25199adaa290ed1eef927dca54c963996bf852c83c07ca901d919a9d6c1e5cd3f976ed7bd66d15861a70c03ba648d9a68f37d32d7f2a46e141445f15fbc8b2379388c249b97a29ddbbefc1d58d39b3a52e2d2a41dd38dd4e8a50485ae9b6054b3c8b502fd69c3787ba951fd3d542b7532158996f8dc857caacd98eb691f8aa0ce2377a15917569138fa6019152d027a246362363fbdd20e86fb863a769d3f6f379c7344343d4bf566e3221a69eea1f230eeb7cd944f13f1ef2f5fc1461bb667c7f77e54281a7f89c4a668ac6c4bda30a4c21faa3ec9b6ff97a1d0752771796010407518694cb86d4875e81e582c0907d92309c77960de9376fb2f1389d2b17d6e99f86da7eb7ca1396fd971e772e94ef98ca04311d2d5aaff68415b057c7eb0268dab92c72c4f399fd1e0cbb793e971a5ea59d90dc2ce93e32f591009f32aed612f4f217e3faaed66cda788bfc281f5f99db9c810ac4c20c38ffeb2c223572521a5e37a71beed77fb6e2d966560c63a37fffd1c0a33fbc9c7ddeda02f94fdeb2479f839487a4ac1118a76046254c60bf9931d08f94f035bdf4f09b41091044a4023980c57e44453b32b8d6fc4c6592115c5bef940b81f8ff031b7c28d5ae631b6514de8c4f6657a1e2ed0dc093d4f3a9d747e1b9f4a153dac5a143b66c39c3ae41c7819587922cef7861367825cdd67ec9be52af70343297bcbbc6c921605510e9d8662fe79ffe5f847c0f0de60cfce136e86bf7464e93600d29b61b374dc02c51b86ecce0fd6b344750f7a168386263cd58baa1eb5f4ba63cd3d5588fc9446732a9fb9cbe6f1e73fd7e2304ce86ad01ef28e6fd68af57ef278311977175e308603b2470c7eda2c39946121d47b9a701de0fe085fe5bd2ac540c7d0e0a11cfca878d5cde3de99ce74ae830a188cb54ed7a65476cae45a9fc6dcfb1fb8d0a7e6ed0bb223978448223f0caed00e98cf6e0384637003b859d32ba6c10f7bd5151e8ae7de06135ebc8f108c12dfa734c78b167cc95581b18e8528613dcdeef856895a3882c62d2373fb68ca36042ba297ccb86d1e328b5bc14d360a6c4da28ed8a3f6b453f90ea567cbf177dd7f79ba42ca4482cbb4508b306db3291188c7b3277b641e1b73aa7971e81abab99aeb5ecdce63fcca13dd0c7593412ad25ce31f1cdd1816ff8fbb1dcfc3bfbe0e98f868ce2df21ba8a86568a32881f6338251376f17056986dafd79da5e58af88ff46393da4663497f75df91f446c1a2589f19143b82ce914359c9cd1f5f65b8a42637a76310498c5a3b99da265caddb7d2ee86ba3732fe8b5dbf2eb611d45585bc3f08b92a8b7399f26bb2c32aeb13e94a94e7580d6793ce331b341f2f094d503edb8918c14a83acce1f298f16a1245b5180d55ce33d93157be86c47e072e237092c4b9ba12eee954bb038ec60d2eef4201d8c8039da4d5fb1891398a976cd9ee323a23353c27914af63a2849efef1def4427278c240315fef322b3ef5fbe7a84ee497de2237d6a7998f175f92cfcac49460c0bab594acf9ba6e3507eaafa9a1b2416d97bcb4b30dab09dfe22c9087513ed462b36099431ec4709c62ffffda0c92e898ee2b5869dc6a12a85946b0bc4ed5f66ccf28eae82c2e8278fefae11e20918a797b6f6921641b03d36b63eec6fc825261c8798635f2477ad4eb4658595c6d2234e0bf77dcf910283f6601923fc39ab2b574f64b0b7a39e8e74506c3a3f33bc7b1600e6f881656d3e6ac0694bf9f369fc31cb45b6bd1ca2703bf22d9212bba1c2474275bf3e5969392a1a5e4c1b3af0220e34298035c6f345b07b5edd1d89990ce57e9b11756ec06f11a88f14adafea5cfda25cba0d2a3edffda2b76412dfb34d7c2d5b7d492a2268a06362b398dda4664abc6b6192b72cda4caf591ec8b81fbd71e69d0500aa836703921ad5871a1127e8fd716ec4a0c2d806ea4b75e129312bc52f03ce01ba6a82df3d8a855b976fb634acfb3fe12422a240b7abe7cdd0de5c16e32583ed5e55b92899ce964fc459d627d5dfdab75bbda17e01bd4eb5af8d8c5a8122628b55209f73ed08a43f02b3fe3c5de9a10231abe0d0c7c3dab3ba8650e9001fa8f6524ba9265cc9c84c8917f0456dd67851b60156d091a12c9c457035c32d9f6d88d1000c70895246f16f69aa0a96c56976212cfad2dbabf254327bc6e6c680845e944e0f1dec70aa5e77705626acfd0e0f879e30734c03ac6b95d791b4b070ebf3c401a13986fdc433b5ac288b0f2f7db9be38aeb7a464b260ba475b38db836f12a4ffa24f93b73b05bcbe2621d5a42e7fe2a474a1c488d541ed7d62aee2504d07fb06342c24c58f9534ec661b5ac0186c2b7aa999b34bbcf8d8c60b1acf1a99219228c1ae5db68e1461577548e09be766dfb38f1ad9d42a1d2de9e9148097bf71b8dba4085074cec14fe5d07762fb901e26a91ca0b356cc49e381298ea1660266ad8f9f035ee0ffa69bcf33021ba50ab33810737fe6c87c02f89bfbd606cdf24317ed7f93807b7b029309861e952e355d4749330853336a5e5ab6326928fff76534092ce4e6e76cd5c35ddfd2d75a65b0e6999e2668168d039fa005e1b5a32c3d98bee92959e3d7741c2a45937f118212562b2ec06ad5752db713b07fb4f35459c1e36260f2e59b5077d5f18ab8302093733e212e428e36c4151936bb0280257b93d3e5031ad8ffedeb3f3852813f02e04ee0bb0ba375d026b59b99478a5d2f57ca540e6ce1b366f9acd946b1a978fddb34d242fb1c8b066003de784ff1bb32e25e9cb7c121c6c86b4560e1105b9a7970588095e19372fc2c666554df3caa466fee0d8de375c56269a4e998e54d80f5711788332ca9ec7984805de30d367ddc588ac6edf6b331420991674ea6055eb1865faa432feff5da942afc78d98426ddcbdfab82b661d050ddc2b75df5b0efc3de1fde552ff121f5536d372dfd6b720ed2852f6aed096d976d6e9cdebfabd72c5750249124516d8ed489dea9465ebfc72477a90bdfab3cdccce00b981f0b5c2e77ae03eb57ee22cf996f7049e7d0cd4249e57a128bf6fa49db6bc4fc0cc333a20431fe8d7752cf795f69404ac9cfaa63999252a48d4a0ba7d1c57de98ed6dbbee80edd636954eb64e5848adff3b43d49c8822a79a02adeace29c9bfa5a83bb3db59b830fe5bebcb8e3ab327c230d068419327b158d73a395361","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
