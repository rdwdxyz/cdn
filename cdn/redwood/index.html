<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcc72369ade1d5a457ab9a5848dbcf69d97f77f0f0837059459feecf02f99ab9a327b88d3c2272ab16d47334d4d305f370c29f6dffde5b7edd66981ba242db3c824bedb9795a413931821b27420c6c3b4250e610bed28f80b47292a5fb7bf5ca2cb0273195987c268c3fdc73a804e50155a13b592d27dcd5011a22856d0bc2678880ffa6aba9788e469d947819876eb6f0225075222dcf2bf6d8b9cee4fe413549dfcb27aa708836e4fabfabc38d45300cdd91a38aa834e872a6a6c730c7546d67a77b7a1c0e662c1ec69147230d0b9042493952a87a3d9b2cdf6700fc094ee5a9c756b7e177c3fc314f27746c6d525af254bf789509234cb533ced30198f3f367670798ddecaebd04246ad550e8442665e15c7e47356021bec78a6dbe843a9cba7c1b7c81e99aee995fa0e322518bd0da927bc852b4138f7d4987463af7f8805f5c0db7f6f043f91fad473692e412b5d87d619bc0248dd6cf2ca7446c52fdd56daea8a582353ba52a94ae2b1ca1b3e633db9b56a426038c1d9a7ba89d81c913e55e37ca83a410971f3cf98bf6c0553f93d46e359568d708969e7d5954477f74e44aa9c776d477a9548833744c3cca1a03121ce16a5662e921da65a0e32d0588767fa8f40c3501169237d2653a081b7347379f192d2ae06fb1fefa43e2fa0c11a2840f4cb7da0ef25b39db33abffcbdfa1c044ea8011b338090ff06ebf4dfdf215a5ece0999213ad2c23838c8e422b56f6cc86f1c96ea56539e64a7a0814908ffe5824770c608475e4d856e520b43a4dd22cd21c9654ba6809ca8b6bfc1c2cb274ab85fa39acb5e96484cd7dfa18aa59ef246254bc8b88730a3d9b559591e6809c53860ce0ec76add3d36bf262d52671232c97ee9b0bdcf18727eebde9cc77ef34f4e0ecfb94058e9cc2ae4b08fd75fe205b3b262769d07e575ee8d0e6807099582bfb270e6a9862f5d1352fecb32719bf91c49b903288956d9e34eb0e4dfe14fba5bec8226b67af583a1a09ef2ef0f62a8b62c1e4afcc8464d78f58900a9a63019d7efec5b6f9b41d8463176f3f82a059ee5977bd27882456171241d7dcae05b57522a43420af27f9a17321766ad11a7bab73a002f0e990d3e0ed92d45abd2c4cb737fb7140db6ffdc7532dc7fe1b607485e86d0e0048b046d3c4ce072d5a6aaddd972d3d5468d018c61c8447fdba82d69ab5fc5eef439449b9c1506b4a037935613ea844e29aa50b43214f39ec94ae99c64d172ddf43799aa4882c0333a7810d5f8c34ec50584dbb36262d02b2d34c0af06db6af17b22f88087c535823618a5389929478b0f1e142717218c18458204a751990f00cf4614361973b6159f4fb8f5f77dde4dbb9fd642cfeaea4a0c2ebe777cced3ee1a532ea747474419008725baf487bf040eb3cdc46d4624bde4a23e202edbef5efa90945cfdbef630a14fcd1794e7fdaed2199396a83359115fde381c41460a9ee255c5455dfda3f5cf6c82633ecaad25435c93589564936447812e0107a2231b2226c03a1df8ce5981c840dcc62a6e434ecf0578adb55a663c14ac0abb981edfffb15aee317ba3bd1534721a3e95112e272b3371db98ba5cdc7e46a54948f8906acecfde17cfc908191c7272ddf6a3b38e36cea57938296f5fc1efc4ea84221e58ef383b00e35e9fe2fd7614d9229382cde0a7e0c4ab3d61299324600915e46fb7b1dba0e8f99125cc6c76af267ade285de1c67df3f7abfab8e43375238af1b268f4f52bdb04643358bc7f9fddeca4362a69dbb67a7baea8a220846e53a854cd2f7cb31d4bf5d97f80941b287d27b01f59b02050dc3fcaac3eeee0eabd19139253fd5aad87f7fc59dac2f60b53d5af649a7fcfa0285397ba024d68fd7e3070ddf8d6900757c2ce5f766f11bf7d469102da86cd37ed3de8f406e9f33e6281b356b4c2372d0e7e9925c85c77d7def431d5ab1434c0aff810a7311997b11b2645deee2c4078918d27d341641ab4acc4dc75517d1ca84d2a18b415ac6ccf3330d7d77be864f001058893cd3c24bc65dd0246ada688cdd474dfd4f6af3d51bbfb12dc20ae9005a1c785da1400c7647942ab969520c20fbb2f2b5f94ddc0ee9d2448be9d837e65333ebaa0d5d3c063d81000a38c5c6f67a01d7873d64e0141305c65801f3974b51ca22e69ca64763454d1acab939ee6f86caaf297eaa508773e96de883aab4fdc0647fa1643daf025e314def0d52aea1ade3ec6170a7600e9f7595eeb2b9d2fab3b57696f988b0db76b8a8cdab619f97b6f63aab3f484236b7b8633c5313c89ba604bca88a455f88452b70163d86c1bf518f388800a53077fa35653bb6409497d64361571c0a7f794ca824c1fde0276c560fedb158357b8fefce3b04dc9993b7a9d413220c0bd7f2a94333016d9b0c087552e3603192a65c3f222c38713dcc1486b4f6a6914b5d397cd41535fb08b366e82d49d72690648c449faa4b8023be1d4ba59d7e70f3057844dadfd709e3758b2f3726556ddb8a5fde13e440cadcebb72c9e1082ca3c927144f9e7a91dd69e70738b7096678a9fc45ac21152fe03bf0ff132433b00ecdd34bbf42dd469f6fae20d9838747b0a465c99a9e2de12d0bc0509bbe8436193d5a4f1a03d2eed5cf33259469e43677dbf03f6ef5f852359d8c504cf46c17cbd60f6b23e0556ed3ff7d7fe1c5047b29796e22ef350a404716e8d9a9b2be377bd843a639730348c365bad12291698ea587f087626b588d413a6a3056d208f1f497b2a303873b9025bd4aef8d84640572931b7f015be8f130c9f145860bcb40ec9cea0d72f163cdb3be20d40428086d5d880644a837b6b877ca21a8750481329a014aa910f65ca24a29d17af2ed9861026f6c7a36eed6edf91313af1fc6789acb0b137aca91b19d7ef4e05b62b3169ac9597c0ed819508ba9df95304524936463e6e23e99691b2e3b53422046d448c6b0ed916231b553e3ec71f7116fb9b57d5d562a3ead9ab439c13df407b0a2e0290fd9dabd73ed516e031dcab70817534dd31f8e3b00ea2707acc5805433daa8a102906566f49637b97e841697784e6bb9dc015eafe5046abae40683286296b77a545f6fcfd61d1039fe8b380d2dd73a5af04bf845789930835291927f1e28709c3e0f618a18fa83f4c511b7fcc8e680abc134d982198332848f71a86efed116790dfa752a76a9b9653e15c4ba62b477bf5d8707dd06c7cd2db54d1a132d2b9453c1fd8df0f14da9b8ca2f23d61cf8e9192c18b232687bf645be1e685bebaf1f5858937454aa3d87d79ba8b80ddd81f566f287d390fe2dd4b6e2cb2e254eedcde324f4722f497c333171d9f585269dab9a04b8bf1c6a00eea3fab2e4c1c33347b4d4790967f5a9cf540e1f9bed81142594945e51e30005a692b01f6030a4270d394480a42ebf83851b0ed83292539117c3acc5650f066db4086fafaef4fa9cc36906916eadaf3dbd2d293f533270bd8f9c790b8eede841d86b1bfa94d61ff70248574830130b2234949eb6a7be919a07600327b72d38f1db7bf3968cf4f8ae108e306adb9e9efcfb3d5a3b7c03a9fbc069108868a14da8018afdb647262291349268a228f859e189ab540a0b9fb1bbc5e1a1428874ed58a579379f1c868059d2ee7d60729914485efd885f8f93d743fe06ea3d1b67dafe1fe27c60658fea6acedb489959d91bfb400cb7cf1984405643fda7cbaa3bbe3fd5694f9e4b78fba404dff1d6c61643058c27b6381568571b723244c041d36434c6b0d985e5de46d1c4e2c255edfb754fffa688eaf245088a55d491f8ac135f147b3e6c6725d5542f6f61e8e5f40867e2f745741ddb2cf36e4557e5f3ab1a06668280b2f485c29de2ba55598c2c9be9d1cbbd934196bb9cdf24843b6945b4f810c45226d5d3f9dbdef33e9941371b1cc6266e1cd3e00a4ec1b73cb85e36fd88849ba5d9c9cfc4f498de3195b7bbce826ee213e7a1bacef174eb3b56d15c94c54c0fc687e6a6350468d62cbc88623345fbe07b9096bf8e66de3fa5c582c9b8223e9f2312970e3e69bf6e08017103f3394a60714f110785acd9eafb95a6f9234f65c0811a939619c9e31ac9082ada10f06dacaf26496f1743aa99ca102a2b3cd799532dd5e853a3c8f30fb56a88e072cf8d8f20833ae951bea028740866c0103f0eb4c2d47f228793f56af36390e86c251bc36e16c2ecfda744910d0b84d8e6c4823e1d92ea102ba8de63168d77b3c0dbd55048eb5181fde640483901a1e3334755e0d291402df1cf4ac035ed439708d6735a4b5f7dcb21a526e709785c55cc2e4778d113647ffd16329c36725cc4d4ad91196daa096217a4db7f0fabd038a39d7cfa43d287e93523ff26e137813f4995ba25c4f227f3d53d6b78703545adabc3a8b909c92028e876bc22dabb17981dc418482ef7e656597f18e9f3d5cd6a871a085b7e3917667c3b4f698b848bc13d6c39ffa99304b0373ee28c4cf09f874c4c4b0c9bdb0c6eb83ff2fce17e725cc42f6e9b8f0142175d2de8ec9a1393f35fc7c6eefc4a5f1e953337f03f3f2d93259e6141936097afd24e6d8558046259df9a26434f936f01c289d34505c25e0ebeac1e30d11d698ef8c17d435afdfd7e01f73174d43bf3892d8f7a14f1edbfcbdd83f053c35ce1a38d4234e9b7773ccfba2f15f4ec2ae792f7412cef7ccd20702998ca1e36092d5aa62188d58012dc5616c9a75417f486d3bd0d763b5cd7d5c469886b344797d53ceed3d05882f74e0cde900088e98a1239151eb8d157678ba5f5c66bf8235cbbc0d7628a48fdd0dff67e53a448c96ae16c8dd02a44b06635005e393cd644746141dd045e9716a8ffb9f01ff295c02c04fdab4e8d4ceb58b487f4e4deee5e3d6617bb5432b2482798eeb0e4685606190d5dd89a328f575b1bc264650ce92b179c7cd5187f5678d760badbba2c8eed962579d99cfaaa7f77458b18b38d834379be92fd64b46bd8dee8fe38c5eed947b9b3c4cac70986390ddd4c4f0e7de20d0a7c26b6e87e7f77fa50eda3f3b234c95bf40c4c817c8e02095b38a04115887df70790f293b641bfacf956f3001767ef31b7a8641df1ab505bd77e5d2d1c926f849922181b61e10f7a6cdd58ceef08d310f122a4d5d2ccd3d493d39deb0fa8e400a7585aeeeb6e233ecf4e4d2df2f335ec75cc0f48f4e07bbd70780d70b071ba150210f4f10d2bf53f0cf9b052102e6455ea245851d0cae77bde96156342ba0f88bd11bd86db972eb9f48b920e1ad57377f24b797290aa57177741c4af336bbd63f11f6305d32ef798fb666f27ecc4948aacae82a48a12d5e5552de36cc84cf923f899d9ff286bb41b514091d973e4e6d792e62cd7835f4f1b0a7cc59378f9c7f0cdaad4802e7d9eae0c9becb39bc759a6f06c8115f592aa5924794590c29e0359d4a69eee9ca75aba6baf42ba81a3bf8d1afbf556ca22f0223225c3dc9ab61f53b28c2a912385c2e079647c764cb2b6692dd9c621476538c14d4b64424ad16935f11174bc2f2c6d6d9f46b549878c2c0c1c7d13341222aca8e4ad996b375bd504c7edd3051075be1dc13d5e5865a4bb488689797d336087a69fdc68afdb338dad40c5811d70e882d209af2c048e3388c31ea204f9fb64aafee5fc122d5ffba3e7938435b4f696646afbe8f742a7352b61cd5c84845ff000fef20b961fe4ee883ab51e896d9c9468680e1556fb728da7281f3bdc94fd27825ba7e4ad2dc940964a5ea258243771c4ec9c7810be6c376398913136e2f8669a2655c56786fe473c9bb2adb1a787f4d7407c8cf34192fd65c09427c72682eb741fd005ecd33b692e9d3aebedcec6cfe96889f6eaf480714ed88413dc94e3deefe0097b4a84329edf1b30826f4e350f146fdf3f35cb5e4b9feb1096380fc1effeda460a2920983532429b898a7ca628c1bdc4eddeb8a342bc7b3b39372163074f884d0d0d9a8c432dcd0de4792bd20e678b36d687868c0700198dbb1a3978b04de701178724b423f11263c710b985db83c04ce7e7e1e00edbeaaf3b8b1003e8e528bddebfa92e0376bdc12eef62f734583414fc6109ecb3e4ee71f32d8f6385800a7c791c2c8806ab45b7ea385b230dafefc11e6f6dc9ad02143603e574d64ebc542a39d5ac2c5d82c1fa03386bd92cb24ca04056a0875151c8645dcb136d07f2f83ccea7dd7323712f8fec8fe0134d5cc2c7aed46c4fa824df217b10ed6c793481f36ce8ce76f4f54b2134ad4d1cab40cf28a3c8819177888b0204747e4445903dd370e5e47d89a24e2903abd8ca16c3e68e6dc2fae64c2f16db995c4914f6876b058a2fa9297ad4ec24ad3fec94ac97aa5d72482461c5204c186e731dbd0f4a9016b0dd18751efb9f6f1196ee8114cd0f1ce0df1b641d183dec0931b5ad29997426f56f4b06842ebacf60fd106d6b3994ba72aae3319269016b5223b63fb4618288537dc0fa0b8ca68129083fa0dbf52234000aa613e764bbac0e3997a9be312a49fc6f24276dba7a1816fb91f1caeb36c0bf0945bbd84e90e940c7e5635c2a1faf099b3c133bf90fac10d5bc444c1639e52537ede01ff052380ae13761e5256622d9ccee3dce8be97ac088b8a1292a575b6e11d8aca850343c05c676d731c66d1e3c5e651f4e8fccce91b96e078b26caa98228ea91d143f38386a9d081644a01f08a0427583c9947b50a084456cf6808ba28bc2914dd3ca6c7e88f5a7da2a38ed718053829d0aadc9d271afdea348cd05055c40a9265dffd81cbfb6669220dc0d7a338df4daeccd2232ab8478f1398f796799d8dc66344d2d669cacb52051508ad77c319aa1c4a08feefa133f248c5eb72c3a326dd1c46f7a550c9e6da2de3cb6d88b1ef2776453a39a0d79804c9addd2c22313fbe42d4d99a792d4cf9b331261501340bb4a0e4d0421019e858898875f6e595240600b811504429a3945a6dc0c9f69c2907671fb42ea08af030f8a4e63b30de5bf4fedbc0d8c89a17563af78a51d632064ce0b62d7f777ca3111ab013e14043f4a46888fcf259140eda726a9924d91ae3e4ea9380af59d190baf8d8ac8e8032126ad88621c1fe564d7c495d840a3debcce90767259395072f42c2723e81ba725f0e83ed9cad2aaf33e36fee27ce2ea551afbce25adfe981bc18a57561a70e2d8ad1d37e73c49fdbf000c4f303eab3a6b945e1915768da31c7bdd0919563a836d64077e183d8d7649e8110aa9e03dd7fb5cdba3ea38920657a6d1763edfb9844f6e2531e0720f5fd6dad29392778a0a579439df6a886ccd2e137f168888fb3006475b58e372f47950a7a9a2b585e555e163ec404b8ec00b21d42c497270d7887981ed91526aa4cac4f5b07adfd31eb9ad7f6059e0d3a54422cb5c97d02563946f454fb0115c576cb05f927df70db99e4e8d737eb67adc23556ea4997a3475bb58846747de551c9c69772cb1d12f94bfbcbadd8097f2e08161b217c475d8bde7a6d03f275747591ca1974e1103eb636ada0a0d23a1727054e6ba2f995a3440b0943d3105119d802b83e3249890588ddcd75f4b5eaab4e0272071428b800b09ea413c651d62034580f504d22881ad6731ef40358d988c8a64780eaaae7f8d536fb24a0744b6f78af440fd43f982cf41bb0e1141d4c1c408036fa2718d6b7e1eb26b7a0616b8d6098beb009062565e9ffb8ddc3edc1a5691f34de4e2dd98d2a6e0c5f9fb9597e47db2f88644ed14a729019ef705e5b29728eaae2777b1c85324e06b23d58878cf53c313e3135d37907fb09bd3b06e2a518cedbfa507ae4c108a2fdfc9ee0ad248a7abb6477110201603938c2fc9cb5d97c9f4b13bc70361456e2719c903fd2630b0605301ea52c0168b81d839a9837afae1e08a2c70ce76936326e51c109b85c03974b7d7dc3eae138cbe0952af8bd9a5cf1a0689db6da8bf2868d329476d4538721b4ecd4210058239569843dd7afb2e10047a9a6a62f85198f6bd93655ffb0d966bc7067beca60e67388dd6ca0c0faeeb75bbe6916f2275c37cb8df69f4753662262dc3fc3da925075ef6c6f18fef065d485dc403b42dc9eaf1e6a81aedd94cd3662223ef0ff9ab95451e2c96eb22bc295ea91947a07022adbf3ce86da5e5d4721f0af8d7e34200bd24da1b80bf6c4d2bf4884ada32aace9f4204cd5e77e2b069b6875c7f13ba622260d72609fcc8680c273af007b8dc1fb304e58850600f6141c9cf25e59596fdff08cf04eb582e249e8516cc25cb6da61dfa210183bae5dcaa8b9bd1f86881affd062b03b3021f65294923e34c143070a7a919e0215735af915a61f16aecabb7719d2f1305bd1848f5648232eb1da6d69a36aca33f61f347e45ad415fc484b9a989489aca2f2295e43487d3654e69da11f3433318ac909cb593d01cc89c140434897ba6a095508df325c1ac107fbf45cd4e2ca5de14ebaee6853d47efb37fe86dc0db128f60ba3571b25446f2c1b767d2c755af233ffcb3ab3e0a4c1cf2acdc4cd2f7271ca1713aa838df8e2bc28e33c39e8b7564c4a199a8d4a8bb9a7341fde4ff8209cdb04ccf1894e5fc8f235e8d1430ee693b17919ca77d4c840293169a3aca93a996b3f5fc90723443ff12d092f462935f097181b3bfd6113a29404ac7b618cd606c1a4e8929b89fb4275ac0419a6e105163939cbb493d0fb0c468ca0c90b0f6366513bfa09d1b5e747e82a91b5485ef910af07cad9df517b9f4a455e968711c3a8993dbb7f54fbc5ae0c19747e64991d4236ea408e44988e14c12cf48960974aee4e8eb92d9e6926ab25fc680836f3ed34715c99246fdfba46dd02bf48decaf94fee050c85d3819d65f1c4dec1a8e07d27685ea5b20299185f8f1365215fe17281f1985bdff251ea9f345dcfff0b2424e6a4248224a4f41989f609092df8d8ed2af3af5ca3734016809912b5219e5c7782f4fe3764ba0ef4964f4a21fff15b5935f458474fad6af919e3315c565e6d27a828dd2d8934d82de75e18cc19f09a9d490a39458f8d647ea6d6fb104d4fff3035aa6916c457959bae7a0f81803394556f3cbb38fb613ad5e52134ad73612d5b49824361af9ce7b17df6bf82dc848d80018d3fed8dcf1bba33712ce6f65848a665001983d7c3a5764c9aabb575da2fa026f34747343812e25f17ff89926e8f0708b714277c885962bfcf8cd44efec16d3efa7940104c5e922def8fab5929a480160b272fc2d4a032e66be2b5f0695fd0b4502c6f9fc4a8f47ad5f66a08c92fd3829d3ec011ef1f602e178e909807af84eed868eec76be35270f7e540d5b398be0cb2030ffb1dd1f7b4164472f153993d93dfe3f580f54fec2e8df79fab87eb1fe6720ca81941b5c2746195ff3616f2e3986fef15d1b1022147a3ed8bef8794788a4449e7ce34867e61a396a73632734221ebeebfa9aca1a16f49be59169bf3c1cec5d5e705bd776ce0e37adf72f29814a0a22574d5189ffe27f70fb2d221263727a2eb74603ab72023a3fbff92cc4c2ca8298a9d625a850fb2353c27c0148d2d8b87c102098900d2e829636975ebd82e0810d4fd851de9fe0603c5c6fc2a9b3bf6a7a63eed857f7ecd650133aaaa539340bcfd1be6e11fd6886d1d2dadf81be9e3734c65c2997b6da4fa0091ce19b53176a12346b2cec68d2400bbd78032e32489d23cc80120c40d7c69b35bc1a8b46a06d4e0bd0446cf1e87162cc1b37e7811df19f625578fb412ddb2304e78cef085d6241a812b8e5b57eb6bf1951e1fd8a8360fbe6ec3f22f8d529feef4ede5179f4d370f96f721440e3587eb1518792352977410e56ae8bb2484f798b3b6b1d6a5f693ca2fe34442a01670c40fdfed8c84a0b9e8e24481a58309841f2409cd7116d307eafca3796830078a9acd960a426fd176bc798d1d086f056405a9099d11b656801e488ad108dbfa8739b394b27ac0890fc040bff649f1779da1cc5937ca6e20cfe85da5a37669753f18a4bc6368763f2b57d41453607a1e7fe34e6132ad6dfc39f0de1681906f8df1ca35320c4c5f2cd7f247088a0aad9c8fddb411c2c7e9f9e4adff5e8d0031a92a4011058680b2b7bf96f757dcf2e46b35ee0b3ed9a5bddd4976a554cee130fbb3b1b19dbf9eaf23f3a3d7ebafa277b380a7aac140105ac1489ef0a27f818fcbbff089bad7fcbdf9618cff6bceeb9ff217983e4ad0ee74dfd613bfc1276849f8aefd4e5efd7078cb71b19cb87f0dbe2e503f8b59b4746b5b706c7878086ad684b9ee64494226a1507d8b20162ab9397e0e26f3ad5d012ee4387a4be81c27b58d700f45fcd9551ec8471c1b8e6ce7c6baa21813cb1b304ddb7d76d7a6aeb7cc801964278f6448f5d7dbe1574d05e9c334002bb9f2d88f0d06aefd2ceae2200f2c8fe76c77ec1b5d51e791b81dcc641a61bed1d8dcc1a46192494343e2110744f470208fa2dbdd8258d35d99093f1d04fed0057778c66a9b3c4d447d0de09df5a69ee7b13b5fc0d5ef79f47ff8070565480f21b2b58a6609546959a2feac5ec0db0409d57e90d5c828d34cf119e7850db5e0a5828e06b93adc964acc50836adb0aa76966664cc9b0a2c0653e8890b7cd7ea4038f1d53822e5d4dad6b97464d5489c0f8189b047afd4ce0fde689bc6446357aed83652212464a1c65d392ef4bac8ace531127e117095fe806c3466e784d3a95587b16df2bb487c1d7cfb91e7f0e1355fc55972803c85c454f741ae2859012f4ff52e5bf1b400edfe82f4de3e57552071e9a182130844c6fe458cb4584c4024a2d31ab7ad98b443fb7d6ab09a11981dd7a7035d326a2f46e916058571b8b0c4da7c3ebf93db6b56d9509edb9462c23af876ec5bff2164c1f60b8a8e6d9acb69fce0f601ef70719c7568ebe56ce10d75bf4422276bc2fa1f90af78f6a9a9816631a1ff9cd401d7d7cc20dc0fff764cec70989223325fc2f7ccac3f0f4af547e3493c039253f7891336bb3bb1c76cbcb936aaaf80fc561efc1b6c8492472e760607e4ebda8e2c9b6c65b772dfadc007edcd075deab5da95b2808ea09e5d71de373ef145dde1b30549a04970f6f41bbd75dc9e030d544d3367d81747467e0c03f5598671455bfc9b41f85ad500fdcebb2d0ff3449ea4d8134a673ee8d8e1555e53a9222be1aee52d86b093b24a7c53880355eaf0e7b08b02c62f0888726fc693be774d60059a5e48721c81a3212f477c8bfc026ccf432700ed6be18acd34e1366e453114ecc125e88f970307cc3e52c761be499273e97e648933cb7a8a198ad8c8a0c8a61ddfe9aa49c1e82a5d494f3c02a56090dca463d0315d568cee1cb322fc186307ae9f61488050e08c8ca563e10926af9d1f8bc9f5f5a05f2f92e534f4f7003d8e7d06fe773e30340ac45dea47ca505ee8b394271e2fb9d7aaceac9db252037b81c8f53f913fd5dc46dbc690dbb785e78beb17e7120d5fa75874800169233f2f300f7c452d93b57001c24789103861e9a8fd4ac5f7ced80b108268d1a6074ca7e8ddbd253514b8a203371ed058df6ea613bec0efc76595fe1b9a92c06afc1d092ffe641ae1a6ae15ec4d50ff38188e5ddc7ff437451626780492b796e122987c2f76f706517e19bda7d74d5969bef05bbbd4673ac70285c06e8532dc9e98c6f95da2283f4df651613b8c4610ac481b8e5588d4596592ccd0587f487c068c5e496dc8e896bcd1b5b46033efdeb90c6c58c4c6b492135b01e4326004c1c9070f196ea4d1b1c6f18ce568166fcaa76590d5a4615a76c82168b9926b2134e2f022da5d1d8faf7a3371633116cd834d1504c6fbd0e6ac6c1e7454f7ae3365ef15d51ebda7da209e7436f54e3fa6937cf4079d56c4d6ddec158bae48a8a8f7a03c87a62429701fed576b94c53d3f3c92720840a54fccb210c19ce4711743b0f3784e5e38a14978f144320ed343e6a98ade7f06563abb4471fd834fc5ecf00d7d78c9397a40b4d3910ba4be256e0ce876207bb33d42042470b32ca525611c4bec34a56a87a61ef2e876e54f79fe09d249cb480288a892a3807718ced6a43391b94f75be117b64cdea55cee41ede6c58f7b8569a69f32c69b1a82075387fd8432f92fc9902d81c389e482135ba5469cf77dfc0d3df9279231fea1ab0d460220c2f235c0233a5feeccd52922b42ad2ba74b1be1967124e71de44e00d1299fc8bc52287aae37671ee8244a2e47f257745a42fabf5ba389a44cc5854aab4399fa9c2adaabcb23d311a40618bbcbe74502b7688cc83ab8bd6e79a566449e8ef6cfaaf07ba3b2a48e06ff983f64162720aa3623694603dd5ac2cadd61864c47553613b909e85cc89b64edd55f8e71b7d7ea42f067fe68825b216fd45f456946adfe1a3d9ca9b6210a01c39645b4da3704b181de620efbb08d2d8b6001d9a9f5de04c01729214ca7297416303c826df5e2f89866da565b9098b1caeb0b57d5d404550e5a9e0f2a935a9dc3f5eb2a3f8a768da309a2a724b1f30d5dd4939af02fd82cf6bb502a7d7ee345454ec79368622b60ab1818b298afd2b9eb09e71a5e4b9b06897edbe6ff071b3f91063debe71658d7b0df167b4124b9fad3e6ab5f8d86c92c993532a0ce0d3171e7c643b1e621f50ac624600673b126ff164f298ff98cf56a9ac42b37a9c9b34ef25ac6d3b622f0a81e009aedee4d3099572928a194a90c2731c71ab431316c255a6809678798507bed8ca95d1c5f5f65333202e7477630e508ab57f31a4b5a7c99d682228cb9a047b64cf357a9383a6e4349cf2cce87426935a51886ed5c4f34ca24622a48ebc1b98a1961abee2593245e3c0366ac6080eee712bcd34ffe9a5f0d1e23635744778c5350fe27c3c3f1fcff96f1113ae6d25a9cd0fd3bf09969197cb6f345ed99e75d48b0a546eaa226039fb120b163590676472afbd57c7c4f4f4e3cf119624306bbb7aaea150d2acac7722de34d48fb3e6f9c13ee1eb4c0918a53f6dc194a8d76bad580a84a4c771343d3e83072a29afa5d5e981cd16f079ba01d7b72be2843f0f6da50b1c9bc11458ded0d26f6443ab5b8ad2f3b724eb8d86bfa0e23def90e499ae489151c56b15374310db606ec3eaa7289a245b49b53161ded7fb5f3b2df8aee39c9092d94a3cac2c269d98a49ad05e6c1405609f4449039d020ff21cfe38e3039ab273b820622bb2a123edf39ec26a0b057997c0608d31cc83aab122fc69c8e6174e7bcdb0ce9cc484b0430bea64e0499bb8a1876c5a367bcbca9a9dcbe1e619e0347e01342de46dc600a02fac85d79ff5f84205497ceefd80b87c040611c17296736ae7cf850b8470d49713f2bdc133a2bf1cb8fc2ea55c159f03b34258392b3970263f68cea8816af3dd203d8cda40acbd18fb4ee57e42f19cef22703ff8ba734983155cf618c820beb0f89f1bc1a5815d76449b5eea2114d62900dc96f39665065447d9c20effc6629487619651ce707200480d0a7ba2d476380ec37bdd0854dc6e76d2c2b48fa57328a627bdab4631979196278120fb45d794587270554c5b6418c581d54b96ebc4a2b4ebeb8c3cd8b63aa3dd72103d5a5475dc89743d99a107a2d9644500b539115e3ae928a5eff708024874e9f612d835e9f3f62b2a56e3cafa06de10d6670c39dc68f858930be906e3104f95c437f9f3016fa1f9869a4ab95c385af8dd7566942d9cdeb2a8e8924b6e725574d7ac725d4f6235aab69947afc7e9f03b041794f84819ecb0e70247f66b2e011e8df170c1327b7b46f64c7fe5be1e028752a43687dce189ce5fd3ad6e68a6865b5e6e0ddc5b42b63b785e53f92f17bea58bd2c00b63e56292493348905da60245ba1df1e2d6323883e01c3b47fd71bd2ea5ff244cabcf676fdb81fc0be38bdfea81716632b1a9afe31da03ca9b158f2b3b5908b38b70a7db19df8004af2e7216641cc201f1ee8efb481e0d440b6f14c6ac842dce2a82541baa5079a4338df8e2ff27c2cdccab36d04f863d9772afb21e94d131d2443fc3cb019a643816369d0df8df4b63f1a9eb6ed53959d8427c92bdc2c886dc90eb3c7ea08ce8c82a47cf9773dab62ddcc8329b07efdd37381a766eda2683f6562292aa71f57ee575e1d21e1dbd938bf5fafc2c9354399d9134617686fdbeba9f31ed56546dfd92be220da7d973953932154a4c4f6e25713fe1ae0b3416efc96d72a29a040e7870036bcec5c8443d0a6051b288663a4fe540fc35c87e3654048f422f7d998886e769240524d9cf2c23518562298b3ec50dc4bf766a759cada4f981a4e5ce7129131f862b79495bcd2ca507681a96f8bec01528440ed6657dfc0e6b76c6f998e6cd670b84cff864bf962751c97f6ba267ec137a96661863e9d9258b8236fa538bcb36ed6c76ee30d3662e4bc6ef80cd6303c4c3878c31784bad2d94bfb16342ac64888eef1e153bd8424ac4fc1d69796545e6721f6805906fe4c255ef1fa24298cadb0e9d2ec0cc65aa0005f1e7477341365be4c538e232cb42113c15482ff768655e66a69d0005a15479baaf633e9debaf1dbf6dec3091ef634e65f074278031fbb4368827083238e441789377d22f0506e635783cc096841a7855964fd70f4b73f0348418be8d41f1f930bbc435e897931f1e95186c3bc0b8e68a0574ce5b9c371ad481f7a410bef675335d03be8f167ad19d3b839eb694d4c91df139b8ea0a78e6909dd181eb8db8b75ef343329126f93fba054aabbc551ea9ad1ce56e1d97fb5b1f6a1de8f2dcd0467a9d26449c4801fede49caefaa60728571bb68645de0dbfbc6f7ffe5533f91065a4117500686d7df6d24fb318e69128439ca7f42f39afe6a922a81b7b790d4ff298f75168f6230b0392387944487c143060dc3f8152d590495d0c16a84cd5e4373b0dd155c5aa664f551fc128c280cfa2d77938ae99603d19b78b8d1f812d78ba72b3a018ebfc22c415aad499ffd312813f56c847b23ed2d298000018dd64bdca7ed8a828161f5fbd97b8c80032bf1601413201baded39bb4fd1ab93163d74805fdacd2f5ad3b359e912448c2f9a8ab3ab3b25d291b96cefd0c991fdd424204550b1864c0ecb6c3d0612e449b2f5ea8520bec17b410bea1e10ccb6c4f22584837dfb9fe2a094d061cd044349d603b6dfd838e89822b408de4f9c23cec4fad6d3a4ca18c941ca0a6b4e420d9410a62a7372f8ef5e79050986ddf6667541e4c38e0efc403538b12d8c74f4a6f8bf38ed9ea5f033c7e251d755cab31f697913c69944900e1c992567421517f84566d467964cb66151c5053b9bd429272d5416b2bc9eb9aeacb2d61a0ed724734d632924fa113b9740c6514a5bdb4a0436fb08459990d0eeba7649c8290787c62ff61f77cded6cba100d206a9750bce7f53b7245b146d51eb1e8b62591ad4ddb4e20c278911bfd561aaa50c9d452ecbdb786a80c28030ada97d0f67adda988f677b948aa241bbd2064855a24cd2d664d2eda6bcf5724455d0e3f06db5f0b9e1279361d531ec6b36650be9ce6d43a8013aab9054989c4aacc5a99c44e016b63392b61462d4019306f3c3d4fff4035645e360b1dce6b1e6977913cf54c189ca2f0b4cbae809794d1cea416217cb3962b4ee518a657f35e6d2ebe05d64e4fea4e869ea848476b4981d0874a2e5cec5cb3ff0f08a3c71b93b5dda37466000999d9bc21a0e21cf218f9e499664776658c3f9d4e0223bca37a436282026fdb617d9e946364658b8256aa44c29ba97dff4753b264404dafe33d9bead30040d50503c4d4d104cec382c4c3ebcc07999a5fce4205238edd0b8121af4ab23acb549183a1ca9c6374121b63c08be970b22eacd9f86cc2f89af0078ce245d0cd3e1e5d461438b1a91f91bcc46344cb51d91dcdb82be7e4492b1848ed2792ccdefb3cc33c3794ce6ae13017898446549611aff914d6f64fd3af1f429bdf8d127be881efd4fc74fc59be9c9550b510de7590ff0732d5bf1b8e292b2a8750d6b345b598572757ef738fe5b1ae149cfe6ac16c9618e99a64aa1bc715b89f84fec9b99e5b47c91eea1f629504b8d7e5a23be6a990cda60742770aa88a6bca70d3192f94b80610d0d08cbe66639927b9efa0fb9d09152e8cddb3966052d2aa754d3fe0cd1e589e7d498f601e163ac47ebdeb6d6d0062e8bf2241915a93ca5b6f21fa881972397bcc6a157366c0ce8c72785699e90ee4591876a7c5f25158a4c6ca0d447140d4544a6d75ccf5f3e8171db7a21fbd852569bfc19b2597e3b43a106836ff32cf8dadb1f7685bfc5fda0b07a83626671e019ec39e09168737c24794a2dc534c7922444dc4e3f93ab44c7bc8d3026210e5a47db5aedf25936595b1f822753e5ab1dcd2efa69dc343eb9be1784a2527f0fcec446b424f3bed0ee6d0d29c3947348c1a91579631446f843e97cfd0a7300403e678fda544cf418a7ef7ac1c3e58b8740400ae1b11f88ef628f32671c480f5b47804c3cccdd8bea9156b484e649c55ca623b54248624f0a48bea4c1e769d1ff6811b390ba4f191eef609223b6011fb7d893d7730efdd452dedf4f9562477db08be4f9b36f8cf0680b3357040235bf49fe3c6dd3498ab6e1931e2ab800e9a90059f09d5b58837b5f2f0e05b7971bd297d9f2d8e331c937ad0dbf6aa159af9806113f118638545bcc88ea9fd1757b0e65f0419ba5e65bb46dc3281979b0d1bb3ae2b9db489e97e24703dc59250324dde6ba1ab9fcf7d3c4c0591db7915968c386c073146e0a68d0f9bc1342f728a12c5775cb2f0798814807acecfbfa7292b4c11053589fddf5f2d868864c969fa93b721bb804a6ca936d5215df3231058c4e96d78269c241f34e069a2fd1e0b8a4a1e6594467b53e9cbb85c9a82e9c4c331587a5caa9e2349566555ffa43849061469093f96ddec27f7e95da25732a031edbb6149f1f5a455f31c019cfc20b57373b023a5a776b98ad1b7b0d7ab67fba3bbeb60864999091cdcced57aa4bb820bce777b7c55b3c9571c020d476c829dbb1d68bb45392805b81e916c9a040b55468dc3f85bd7c73396cbd799b00a13593bcc4a3694244230a505622d39ea3266bad69a71d7edec58949d672d56d481b3e4d168c9c327c06d9f4450bfb281ae2e5d855172d247060a496a12881a48872022f936092299bd6013906bb28e002cba69e894c7eb61be13899f40f615de794c0a7e2005c41abc64085a79a0204eefd041aac37f1aa7f910286aced59df4d5fdfd8428e4b3fe6406007112d31d533e83ef7477923269671a9c41c638cff70c16e7ee56fab41887fb66547cd2f3c20ee7ab56a12d70ed214eaf252da44c344dc0ac538d8ef490a8fea41581d5e708960f43175871d292978ed5f1bba07591f1d5f2b161ae4415f9d37cc779a69100cc08a788d5b14c591af2d949f800d72e148439c9f9e14ecd49205c83802d266230ef3a9e1a9529391bb739ba90624ca6c6b37d1a4c6f4a2ff4940f18d891b1290defc43fe4f0e0a19a8e4870a188a94baf7883598f9756cfef883c82b34ccefe75225c2aabc54ad6679628c719562a02f997c85d1b3aca1b1e41bcfbc18da61a422bb283aa015f79d51abae90d8ef2624bb91204f842b5892166a1bb1280040a6785a5ed89bc39a03858d2ffbd03ea30c5d274cc3a61db84c9f4891264ee013c7686a61430330f07fc26570f2b5dade410e4c38a9108b7e0e081082123d56c0dd840cfa0a5c06b7654e4b42519ace474bc94a9ec51a91ccb12018eab47b2e93e948aa9ae1adda8526f00353840797044228b6b7666ee4b93e1388a3d1aaa44efa46e0099317c2d27b18a6a5fb7641f37892b6193c67a7ec416f63b3505cc1a8266246e0c3b271775434906eed9ee64a0e531f92dfd6973998b6cbdae26cf676a55903ab7cb7aeeb6384dbb26653b89d83d6f1780eaba381fe77075abf03ab226582c6a1c18fa4290d5aeb372abb2133a7b7b0969b7be597be4d877d9a66c314511eb6a030e8dc46dd60c8d8b46e825720b683e323a713a8ed47f52af469ec5ef432a4a860ba957cc674fa0535034652dbef779969268856c74cfa9eb33b82aa1cfd9b3e57fc8cf8fbc08a24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
