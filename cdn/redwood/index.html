<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b21092e9522050fceee6384cdcc1ee779cc931368d30a95d3a016fad1c44447a41f2ca91023af62f4a4a3125a3d3a51f212713e5e17c90dfcbaa1bb1810b193b430af941cef7358ea81bc17bd79aa984167b376dc0b5655bd3b47f340a9af1f8c44d427f7e41e2df8748383840ce478b0b6c0029b76ae887819efde54ac22777636cf26717963d4c776faee7d29006e7b7ab718a3e46fd88a9b23ec8e9efc7bc488ffa95397499d9746c66be629d7cbb22446d516d3c4ebd5f7646b8379faf3c5b458ba7cf0b47fd0d3e3d3afbe9cc916474f6fdbf417525075b690ee612fbb6b411dbc3f92eaf8a4a1fdf4791d945e50d3c580512f775425b82d372afb2e0c076f0aa1a5571c3f7d03a4b8ca1553ce4b507d071e989611f2afe333d44e61f6936ac2cd824a79d68bb5a0f0dca48cdfc74016583f5ca61cda8afad5996c83490cc15c1bd46f199275609001c0453f9170b8cea7be36c49bc8b3c689a886f97dabf6869a33933b0c10c1dc5c0541230cac37635d88d299977a2f699939c3dba6e80ffaed89b70d6b7613b3c45d04709c13d8801de0d0b035e9b3c39c56322ad1fd21b4f34a6c24d752b3050424119d27063eb39a094a3011af3077d52061abc55cdde131c7a9693341ceb9d917653a91b031eb1ccdf4e7985e95aad1ad650e3e6bef7844ff0f7cc8b3d4ddadc7603b1b82c7556997e4e008571c57cc1bb65c387262e3c6b07c5e19fc446ffc8549a941331fe8e94ab6ff015d4613d16c399b6ed08196903f27c3c1bd442204ad08057209787426884d7f0d555eaf60d05f8070bc79ff60e1ed2cb614de9091c3f9d8152532e984c58c8a23c6d4ac0e5d733797dde110bc468dd299e8de956e2a3d045e110e60b2c53a2b8d9d703c0b032f4e57fd28a5c35a8b09d5e256ad86df7e8177ee00dc9056023c0edf55aaab55bea576d6e70fad7cc5c32a9cfaf59d22b530b5d3a118a447674d967e100df7982c5e022947521a7da2a270fa34d29123db622ea462421be0c9be1ce488b58be5e04c178817b98b7c6252217242ea615b9d60e33e694826cd3c864131c2bedfb0e01c192d461b3d08cfab12378020579d142e9e1a6388c5d6da46cbd2b716b5fd75c4175d14e7fb5b29b89f46cf4ed468a7c502097dccc4a6001b7b34df1fbbf1f85ca55d60372172dfb14c652cda90b76322ebc13d7ccb604faa612b7c1f09f4a2edb97d9d1f2641338a9d709f20207848b2e3e9fbc851e1de6f090e37ea776088879dc6225ea370d4ebf2b6007bc0eed356790291e255c2c0ebfa1d9fc63ba71885e658cef304a69f179548c95b0d4c22b0fa0d23b0c82f2be783303eb720ef15c687486cca6ec2632a4a547419df69aad6b17e571c0253945346d0a126b007707938d04c1cbbdf9dc7be792a6b093e0ff7e3a612724369c795b9eceba6ad138660773027f32d8ce4d4623d707620f06725eda0bfcb64763ad23b7e88fbd6a18d912eb2f8595e66a2e8dcbf25587b1b6789742d4eb4d51f5fc30ded489e22aa24ffe0172f00194d570a6e61b29cb255a6b4b35961d49496092ccc95bf224a1841648d1e860d36ea2dbe0b3afe9105f25e82a59163c1df57202b69f7617fe742123cf6389ae02cd62377acb1f016e213d79bc7d6321c88167c259ebdbfa2c6c917b06ba9eed981bce48f76e32b376c69e80a3ed62d3f7a36a6d4759c3d4af2e62d5ca8154343fe536b53ba529b151b573476b0b7320b523e9d695a1b610ec88817ad026c8f1b6c2cdfa0e859a0b111eee0776ba382798bcf02abd868d4e1d607f1d68f3eb3d44e4c589310fe5e2dcb18c8c51f784236f0898381e2a169a4f9333198f5537d8d72d704d0b2e5656eeeba8ce94eb477d26295ab4259785c34c225f5c6d693030168687894c92ef1ab354166b0fcfcbf5e73c0225f449def0ade8baeb09bdb40d752f485faedde4014b5c1b3a89cbad514b624eabf530a12fbe2a3206477fddd830b8b0bc7adf1120c605406bf591dae73b899b586ab6b6551cb90f3acf7f19d202be38e4f2f45ae776e9f61536bf35c56ceae61506bd5c9c159ca5ea728e24309dc483fec6440c879945e3db0c1ed8db5b779d0d4839beae9618b04a8ce5e9de31afd176af948929e9bda0cf5cbc601a40ed01b3246317f67feeec565e8e60463c452711cfac6416fa54af42d5017df60403f67d6f22c1e79b78a45f0df9154bd85ff390a3633d2cec618ca19bc959f2bf6018d0594a6c6403b39c35f9225991ec450875714747ceeb2bce3a1be446586ff3b7891ce22cc2bdb53836c0f36b204ef56425f04b84f32c8a0d164bc46408b74386f0915f5cdf4a98982306200561f199649a2eb4f89f9776633924a33eadaef798445020110a3e29e0b6e51181fc07f317d41fe4ac09869b9dccb7131c3909a962019a23c2ff330cb1a456825837e586724c78bb7c7d70d4c691ab89d0c2451644c09c72f2ced5a8bf8d67fce8f2fcffe83a266bb697fa2048990aa5dc0f689e45312c1444aeaddc2eb9b72da62d3bc0efacaf12fe393f13bad5064f75fb3245103ee53b6bd660e4a40ace83ec3d847d9dacbae4c9afe44803838df6f8e277a04388ede54544c0a689e64ffef56fa4d27aa1abe6124a229115822ecbfdb6b8aba7eea2d8d900b6f3f8f56d9f340bc94ae7b6130f3c77391971fb6c427ad7a92f5cc649fc7b91859986e37d8a9f0a37dcb2253066a52a2503d57ca6ec3ae3ded2febda9639ab086817c637e1b896f6b438cd36033f523bba10b26833d0fa3e6e772117b987ebbd553b8cc8c742b41a34da0f1124486aadb0378800e0d7d5f212732a14f06f75639e0910a5c00db40a192cba08e4dab2679fb406a87d9c054dc38dfe5997a58a2e6f9fcfec6e2a93656696499ee7628dd27fa624af0157fa51ada77ade0b2fc53dba09fc38e061e2a47ef90e160de8c978d1de74318d942204d4f69cb329f76288da92c463078abf1cf407386899b2b93447eb48f2211bef4945d2c01dd7af55788555e4b07b9b215f9361f5660e990f9321478fdbccdaf6bb9643424ee030c01329bcea972284e0cc786ecbcc4f7fb2f36660a6341aab1610f526a41f07a89b4f79bd7c6c0f6c604f0f743741de61f58cadd2071ffe3948a80f3cdf0a3caf26cc1f2e2484ec62ff6e84b3a1c7bf682c199810bfb2ca60d641c0f2d632dcc0f74f2ef56320d84902b506156a017416fc368622178f95791770244be94ebadb156e6daa5b991db418dcc2da50e9a54605c8e9593def4c3e1d7ad895c313f4ea2eff33f28cbaf52ceeb1d6f3244dba3849739857a3b67b33dc15a1e2724625e9cd7608f800e92ff91ad05b287f16618a729211e34df69333d48fa90ad3ad99ee84f75de75ad98afe6e4d6dee65764b2eadeb9e9057e3966e8afff565c21a6a0b309ffa14575f769c0ce7c1c96ea27e39f8b6eb4debd960a9a95b5014310d350b551e019b4203408105eb98bc1c62628f0b1ab689627a9f0ab480642f9511395cb2dd834648e53391e5d8feea16c87d39db3433de79e7b7aab180d816d71dd6299fdddd551948b223100357874fb9af99dca0a4241aee08e7ff019f3448665c0b11a79b0fb1dc306bc67c0aa0862f619a13eccae5a47e9852628d4dfc4f1ff3296ab93d5413d51443c7513e48c246b9d0e3b959966b3d352f9f217cbb3816c58aca95315081736aba64c50eea7f3defd57739dbaa14bf18024ae224f790bfd6ce20d573213ed4f053841ce55818086acf850922c4ca573ca9c14b2b516de49bcbe8dc3efc21c8f0410703722ae9cf7d4a7ae6816de85588e73fa6647ef99ed8f7fcdbb5cf8d8a5ac6f4c9d0eec0a9b19f2f4a7fed382065ff157a65594669a5a903aaed7b0d28d4701ce638b801c67645dbdaabbe49c88a30983b4a2984a19adcd81735ed54eb82d7d8459c0241c76887fe6bff4a04eba4d8101330c03a16aed7d9219fb3b41c3b8fbfa05c808cdd58f125cae4b5db57b96e616e960d4c4701186a7b69a77466df448c22377fd8790a5ebdcd9c888e8ba44b6ef883d6aa6b4dc05b42f7f5bef871d9f15fe70153472b313e3bcd07bafdbb365b3f445142dddec22395cf6f54807d51cce1c0fad83ab7da6c0af9c61ac9f931ba50c396d3559692d537426888a14c984b671577783d7d1cd961767128316136e7cd449c32b18906684921c13f4cec628ddb602858f8eb92074c113ed85a7ea663fe86816f345221dba8dd6756c35052e6a91f24765478550dd289d1dc50b4e31bb00cfd8df3eacaca9b2afd6ea5179bd4d87064bc535b6a6de0837b73520ccaf002b4061e16acf6b16d791d2e33a24282538a054433970374f9f13297b4f090e52328321ef70bfe8c3744930a9b8c8ab2959e358079f4e3de9f65b01c55a6ce2d1e9cdeb45f43fb876ed3bb2d7404a38ea1c8ddc7208c742fc66a81c3e509296b32bc30b7311d1f76300c76894ad3b8481e22bb24e021ae9228bc722e1167c8b27c9270b98bc947f0f04ce43f25ab788dfee7e5f0771758a633088361b0fba63ed2278f1143df1f2f24fb7f2b142903f4f25ed6bd6e47e96f82a85e2414db8215ec9390849dbd9586ad785e2c948c6e6248fd854397408f931aaa8d1e931ebff58f51ab023843d39297a4a56fe5acf5340af138e2e8cda25440654a5710160044c069aeffffedae191796bd7bb2e9d6edfac0e45008939add80a35ca73ccf79b9b72ea0e69276dc766d338be338958d8808987e0cbc4ddfd3017fe388b19ca6519a76c0debecadd7b42b6d1bfeeba2ffaec41c17d833c9d6684f685b1cca5fe711b01517741a30792b7235d6fcc4523214e2377f3ebcafda2a8fa70321ef1f1cae6f6f0399e3cdc3be98cb6907fc8c503688367424cd3782a66476f954c866c233dce84d93f0350fdc6940b1c0c45e1cdcf06cf1d84f542ebf7e12e534c7926247d987bd9d0606af76d35e0461eefd9e6360bf57957a46d570f70480d8cefb4cfc1cfaa9cd15b40575b814a04d74ead0044eed3bcb5132ad7c39dd360b1da92f6e5dabcf0482ac34450651be8066ac779508e9a4261ad41a88b3605c6b5e6da7b8b62d9dad698a45b41d3755c90903c018b86ca6bd7814383be20392520eb51fa0d85e85f8e92cc6d5457ca81c7cd46ab31a06a1b940aa04c191852ab3aaf735b172930044b8f73379d518a043112b41dff58577b831f76515094553fce38dee033dd0945edbd7fb26fbe160586d854b6f89e2ebdefbc4f708b94f83c3d2983a1e108d16cd87edb1ed1e78c1301315f7ac33e3d0289ca95fd4d229a05115e7eddf04a6b82824e3a7467bc199da29cb23f337b3e7464781aa065607956519449227ed51a5b8c90c9f1116395f7b879e45fdd5a9e870a6c887a7c891ca6dd8d9c17c896b82681add7c1be00a9b22541b2654c9255de4e2ce86fda1762223abfa350f62116048427e2de68266b68007ef87d8d7be92cc1aec09da2bfe57f6db09c86fc0877b176c5d49ceada38cab64d691d76145fa475cbe6fdab650d61ddb0b696b4a1792a9928fd587692e6d72ce48dac35abe9ed921e387525df0f8ed9e5c20b0e44f239943fe32cec258b4778a7e0b2ccb7b7bfd37ac73cd171d22d43d9e80d22205a381d4375fba9a5d79e78006fe371d52f381f2043f6861f2ff3e3fbbc684e4e38ef1e1f03cc280fec257a8627694abf396770427b9741976e3f0eff76c789e5d59d79894420b626bf5e5ebb111039e2efb5a82c8486d0412d1e31bfd162cd8c33f90aecd7a2c55a272035656b0a8f9077fcb67a2ba6d8ad6c187a2f8e2f65177116e0aeb402b1826c16e249f081137e226a3e238baac44c49f11326872eda0b2c19fa5c2b5ecc35c36a1d8ba53077d7750332de2a36f86799d93ad1df5282bbf7cced96f204986e6ed91494a0fc57218541d67b8eaec731e6c258ef096d40e68ceafb6a0ff5712e240693fe464a1a66b0d6cb43f8b3f61f5666aaaaf57bcd7900bdc76f7f7e35f33df27618a5360c42caa24a1a8a14792bfb534e99218f1588ac92a088cd0ccd5e81af167c7bf358f5fd54ee52b3695f5be90d33744198eca1d14ae0c549bacd0459de030dc4f39a7c9212f8acfafe863e460037e141cd6a29d4885dbab71ec2a9627c3461f79a1a4899f66764ae3c23ae7b42b4c21fff80c1529a6f533603e9716d8a2a648b26f41fd333641f5aed4b8e91c08b8b4f536389f5e1250e2bc55d82f989be77c1db50d5d8cfa9804b3ac8acd2e09d595f1cdaad6dddade2d01dcf728ed5f86094133cb4f476fab6f2d990454bbeefeaeb135349ec0b384d6d61dd65b0dd42784ad1a0d765e175bd5197d9f28d38f1c46a90ad983cf09eeb15e569cee3ac9b1bd414cf0272498ed1df327f4219af779e39eaff532f5d363379d4f06e365eb1307aed7996e322ee7c8d413a9561d3e31e4a09ac734cadcf7afde233cab882231967ffeb10c2f11e6b6adb750d517e837b6a934b186ca79f247c37dc53c6ee5bb2271269ef504876452442b65af883398f10c82413cce39764cf4f09c88d1c5329acbdf5de1a1a6e9c04a985cd36166dd9c89bb658d3bb45f0828cc39d9a3c0f5edd827338b2d7db26b08a33d91710d38812649d60b330a58cb7ecc71f5b8864f83ea3f38bf35360b0440a72a4c15822b11a36a3317f50ac176279375d1b53e3521627c81c1f9584c63041278d5ad5416a1e9bc913888b4aa4a9042bb59a6eb5f4ffa6234f70d288a6eb2ce4927cd2789c5f900eca33e6e2026fb493ada9128b4080944ed07bc86fbfe2354499dc8f2d94f302749b6402afaea84ba3ac95593f921757f90ba214d914b7833c0d6c395c6d7ca0f81e5d4983d00d27caee8815ae7e59287ea70f45ca17739d33ea2ef25e4c68c667a72f14591da806d3363c91b5324edb9b65b17546e130b0ba784f2bc6674630063a28dc268eba290f55965f57ffea65d6aed0b09d5412ef83c8c4c8fc457f712a3d275ac5b57565c15499608755be81676ca9af2fd5290454ff24775031fa6e8aef7aaeaa2d08819d2db68c77bceea0a640c938329303e6dd117046210df9455d5941fe4d35d0478b6f1c93a6c0ae5d4e1a96b5a7047feffc27f83d98ec8524d71a593b5ceb0c86eaee266dbd93fa7b75991113871feaa9e96ad960778e4f8642cda6c133a964d5c12562caf7210ef4aaedb6eec47b0582db1c092d1d6c7f2858577c0e2703b65d480c96ac7a850bd98b8e86ae95767fe6034c1ad4e9576a2d7e544a513801691b7692437d3e6645339730eb0a5a25e4c32365ffdb257bfc39a842716f79127855cfbb1bb52116132fe7932e8669b74507d71a6ae0610abd88828994365fc1ee28b99ccca8fbce6927c618c99ef5779b91c777b5f029d1125644a0e96659a90cd803b40ffec08f49c61fdf1bc092ef99864e5496a59d34acda64e92d22642e9daee6f4c7486de70d33f1f7740abd1ff6d36d3e445c50be51479fd028be6d91b2c7f7f5aa9b5cebd15ecea73c8c39892313f20541d6550e82e17645e1f054c26794e9c38c5e5190062304485fcf1bad9d8bd171ace5617f0b86ba08dec11aea8d3966cda3cba458489272a8c0d8a6873fd62d0c647801e08198a3a95b8428869e7606bdbd6a994306f442d647da2aced09df90b3b643d994f803624997e032442ee3ac951ab06239cc475622bd90555243e8a0b63f6a4941f9e2cf237b41d0769800d268edee1e40776d35ff4421cb599d8f5cff4d5eb0549dccfbc8d304f14434ce58c34de9686e2d17c526e6faf0f6dc08414d97fa54a40eb6f0362db1478794981b50e364f61ecb96638bb3508da4605f4113b09bb247ee56c946ab51d7fc85410245ad990241a6114663b84b54057634929978c30e61e993ee2ed469802aee59dcc41d82bd948b5779c218edc4a9348025f9b900ac390046456602b174c5d5e9962fab8a26c69edd921248adeafb4a26679e13d13b7a666fd7cf163dafc83fdb1fc06b6a0794319ac649a01271af0f63027484bd543507208a6ecb75890d561f1802eabae9158aed758008f868f6562389eff810f3bb45c8c8cf97bd62e520166e27c2ed49d04b0c361b3a3bfd274fd8f6a4da0d9e4a0f7d59d4b0fbf217d3b89cc1af80d21ec7f2f6b25ab542857279c459a00464af64dfb04de6733b1ec73c651689fca05e9521842db58e167241fdd52487aa8c1e6a7dd10e48e935e07420aa4a15dfd6a3b02490d0e8ffcb6c824a116aab49a548c9c88ae604852354f04dfd76b5833120538d4a427a74cd1cd17f611f3804f6332684f7c2a523a4046e2166900d36ebdc6c3c7c1b522659e3bbac0f975c04d0d15346eaa45b1bac685d25db648208c58deb12e8421734599d06e80e5481b631ac7fbccee3017cb82ba14b7445cb2b8b80734e85fd7a59ae8a7b40ff2a61c88546bcbcf11063be98d566b6c8afc4e935be082b808754617a31f6945ceff5bdeae3626a4deeccc1554e326db91a1c075834f98b52d02f296b267d541d7d3b6c14aebd14feda117da129ecd59a1d73873b12fde207c6254ae7077bc04483c31f514291e4dbdc0abe21e7a77e2ff0e2ed721bdfcdf480ceebca571e75526f6986fdac6a7d6d6e2ace2431656c2b8080a13dc293ec1920536b5aea40b72de4e91b8831c55afc748271abc6b2aa3dbc56b5c4bd45bbc1c6493eab8cc3d2e6a8a6e6d7bb667544c30b3f4eb39e78497bc718d3d280cab5b70826a38979e20e0d77083ec9f8d87f38bf491950d0efba89a598aff0f568d403a24719977f5349f3d8e940c25a877214d665f4ef17b3a92707bdebf8622ae0d9fa5abace56e2a6c17460ac848c07c64b0d576009dde7f78528cc7478c641f999437787dd6113eaf23b94fee63a46666b7bf8ab5c2e7d287a966c08effe34aa0d2865aa118896b8a84684e5435c8da392b2e4a45f8a1894393b027f7a3dba5060102efbeaccf361a864ef9adb086ee198ff63be5f91019acac251cc35a7e834b18d4a93cdb48cd0a92da283bdd473a2b3e758c1890796dbbd62cb1b39714ddc8c18fda11d20c2f82d21421f507114e70499ecf1735cc185f116d28355a7452689602cd98874463b8f4a0951de6ddccb6b83b8ea59294d4e37ed634f8e46f1d4649f5e44bd04f40afd4a8ed92c5cfc8d5a77a2abc073bdf688b75e7b276639adeec323a39eaac3e4beeda7f6f03281d442479ba3e18f4e62ed4b119d68cf8ff16a53b343c2e739f9f01fd77637857acadc26c5d0baa252768cb212d9df2bcde2bcd3a1a5aa5d31a33c91c07ca910cbacb613fe8744bea5a257ebc31673bf8c57889320e713635c1ae4d4db3e53e00eefd155393f315f6873e7f72a276d31140919d8e8c8e7293a470612d1bc9735dc7b4185d9b215afddf644d88f4c44ed718215e3ede5bb2a8a85fba845bad37042b36ad2c8fc30923d920e86b39a621de493654b239350a1d82bc546bc9b0b9a715fd5ee5bd7585ec396487775bfde5b7ac7b70415d6d417784cb1a3b12c5d3101edc7dd9125b5b9bff97d3e7100f22416b734414a2c7f2e620ecca879cea17bfeb31b6df499f52a96c7fd3162464182957f53302ae86e8068701e66ecf47e6cd648bed5e52e7c7a56af848418fb0e72aa5fa602257ffe37c91ea1558cdb10b7302a7496a3012cef09561fd5c3f8dbd57bd2c453e499bb0fd4bfaeb2a8de983b6c1540fd631c47e760cc11d457c7c8b890ae491702b29e6014141f255bf716a67c21087ccbe7be415c9de2552b2d6a349f712fe00e76a4748c0be1b714a61d330ef99036726551624ba54bf3401cae8605c3b2de405c5f4984d73211212274ff170e1eb6bdc9ec77c6745c734762bc19ee07dbde11b35cd8b018110e6950aaeb6f8d64263b2e31359daf3996de18af18c4bc669f52c324414ee4063fa3fef5ccaa1c18ecef2c0c680dcefd5de2c9f6980401afa835920e550e06b101fcaadd21c0a8aacd08679668bda8963d49283466e4ecdd1faf0fc887ddfe069e1fac66a9df9638ae7162020388b7623a7a5b53fd4190b87a47c2ea6c81c58e0a35a5e7fd0610220b708dbb271485b7c470b6631539973cde7d6cc6acea34754d3ae23e40901ac41e143ff1c310e42f764c4104237523fd1867de393b09a9a9dd96aee615639ba248fd38bdb75264d44e85441b887977a838e48b7a5e072e6c866064d7fa807fbc8861f5d4bfedd9a6d388f24efb926efa5a62d3034b48679daafbd79955f0ac2faf5c50daecb7322852f1de7b927a310ee0ee333507a2aa9e196b6a57531fdc9d2b55ab314f3378ab9219cdfecdce4d14c2aaaa6c487131644f55ac7a627de1de7d226577eff2b1f0a7e2a9adfb3b282d6ce764f3a761ba7a9c76e4b75ec8e0c85ea594f5a992aa6c9aceb10d64100bc9694a6cb7d0580dce77bf79ced857097e79647e7bad7848c89e933356b5cf1bac1802aa418c46fa6baf0a5419c1015d34c1b0c437c511f45d772bcd36680aa210747980e95925fe56e739cd132867002ae8fdf09a6dec2dbc5f82f621a9434f01ad95e208fbfdd548398177e8134ce831a6607baa835480bdded4bd1873a296d65cc2bec5361c25673ef7891a5c19f0c7e8ccca949f15cae5010ed6ab2baf350ea67b7a6c13fe5347ee40e3158fd6a58c691970db77898b62086440cb2a12963e0438a65edd53bcec76e4d960ab6a6f947cc60493b90f56bcbff72d4f9114636049dae856b95664b10a33e8ec25b63277ee832d17910430368ee039848b74b7eea9e4bb1e99e4fd879b6497be7676d8602385488c976922883b43eb9b7849bc582f1d34c62d64b7fa96c61e38264d87998a3ec139050909a5da9639f540161a1c797ca90e4f8d8ff28e0c2fdfa02126f69f0e4a8a6b24c87f0ee461d79726f599db6f04f4a442f0b4836e8e1de2a3f77ad184a034cfd9c5a14a5edb4ca25b6ed67e9e669c84eed5bf59d2b22b1e482ab5df101cdd9484c0147aed267ba5df95582ca7ad840d418cec17e1af815e675de146cc933cfcbf2f22787e808e02bf50922808d9929f3d94541199c9d9abeb8889a27617baf1aa3acc279b3c95c33ccacc26d3e2911ec3ea535b1f6dbeb518e550a8b87505cd4311ff62c74e05224f518db09faffe4159d40d0a6b08d14082f3bada1db3b52502340b1dc40758c9d93fbdf67358909d406c60fe2b31f5ec3b050de5da67ee84fa5cc9946bdf5a9c990386d08a4ed64443d3b0728524384b82e7abd570a0735b0ebba6ba47c40c66c16b169118fc52e2d33d7418728427de04be95a5ae740291cdff3acb6400bff10d588f48b6021be8c02f4b85ba2a3b832101b05b6489e18703246e88ed70f36f956cec24ce1ea892c776f9954a27324862cf6e7d76ddaf306d63e9fbb42242dab07677321adeb09f751527c46a10f4540ec411ae5a309a08501699d2fffb6243c613f79928780dbdbd6ab042e3410776af5f6b4b951490787a2b03fb56b0737ce748782fb7d97c07d3d843ba36f3391a3d1ced2b33458f4ac60becec86f64dbc570e1d3e162e33ce653a7497822f53ff461836046bce502b3df230b2d8279470874f0c3d24e507a5ded325ab85f6b6ceb465683822ee5187f7904084ab53e68efc7f5d79aa51b3e4beabda5ca8547d8cb8395539a8e27781e2d1f06fb6e7e792dc40a8636157af7a08611574a5bac55b39033c70488b50b04c5a9299b57430e3f0ddf8350212462e3ebd9ab609aea0c142d7961ebb3e206e1f9ee6bcd3f6b20d0b22c9e606e0ff76620056ddba38984137133fbe0713488330e7e280b676bb63abb99fa46e812e8bbbc1ac16fbe88c8d2200f8e83755633b5caeba6cb39f0d2150a5a070ab41bb8ac38aff8a97ed44447b6ad5dc8f1beb0678a383f64124d4fc7a8228436656e53b944bde8b2aebad5041126f7cf092e1d2166173c93ac6ee678d0cb48233bc5dfd7036f3834a9043a0ba5187de1ac14256731d64fce42091e634da4b2daad17c1577b5ea56e7def3fb9fccb6b829d5cf422f697989df4caea50ffd07a72debc56417327ff6ccf21a7360e4b95d5ac95e420564a816c03a03b4cf281e949d29b26b8e4a9baebf5af6b441f0fe46cf454bbc9811bfe7be915a1356871ddc1e28513d773b843a5e0e9f21bc27713ff42d1463fdc82417275f23c48bdf69bc3c0787788678d64c0293d057b2a6e1ecaa8636150ea0f86fb648d658e08c4fca398bcea13cdd579e12fb66df6a7d538579d410933100f661534e2e3c211cf7d1e65387d3c6b18b25b63956dc379637a1899f8ef706fb68740591f3cb3c53e9b6455ee1feae03a7266eb11d573143d5f4fde6dea22b664f2ba9a7597ee5a2872954690e30c674fce64a2c2454c0bedaf1837e3cfafed33979efd03278f8eed88881af5c239a6787f692ad48eacde7cb9ef8c53b32dd686ff35e526d0935373d1c09e1955c5eea7bd9540c5143436e1f5664111e35821422d6a4cd6ea8074d5d0c7ed237901f1cb517f0e6bbb542d31f362899a11816117e703ba19e6b84bb276cb6d75825a53bb9d25efc3a8582891336aafc073a3cc013f7bd17a33ee57830607b2b58387420637f2432ab5c7b524e4a3d4c9dd4017a2a98306ab0fe02c6a26eb9c075c1124a83f64e81f55cd46f34463122bf407c37ddab8558b806cafbe25ca8916def9bbd804f80615602fd0920de484c0ee99df8c1619988394dd2ebb049a37b22bdfed27e3440c91512e44501c69581a49fe576716da744cd4cccd2d03c625ae5eab4ff9d9c3af7bee3cf085a068d36f5a63b598e5ad060b411cb0ce6b1e39ad69d1de8b235b4513fd72dbb4779eb27723255337950d5891bc68f0485550165db59c4cfe69bf534a25c8a462262def2606039efdbc4a29535b9fc0b09c48c8d9d4bb2ea3bfc4cb31abd00ceb027835a7a9e08687f6c41e16b0a952bd06962df43a457b52303e4248bb915f01586dbfaed86aa33367c89b6475c314484d7b7ba668c9d69457504fedad216a7944824376df343755205bc175e753cac17bcf2643b6832183ff59e2204e91e231b6f9c49a377d853f074efee58b1a150088fba2b2103fd817f5fbfdead23d4dfcad30a1cec72c3c344e39299bda02b857fef116394107761baef8db971ec43da3ddf1e8480d29153b4b55d288b9a40b855085a5fa4082591ec64c97b740b86bd11c20473b2e1b8416ac939351b60e72c32073551f81a4a15b25476c6fd3b92398034f82ae31abd869fe103f3ece85b805a662e424325131a91f7de0e1bb1ff11a7a457cf53fe1c872821bb6fa06ce65cd7cb366400b901aef94d9af07ae2b1fd297824412869a0ed79dd8500f41d4e6047047fabb8a77c37c96e9f002b3c7479a54e66542acb1dbe9a1242a26197d352b999dcc3cc634980292f2ce505555fb0086012d2b77ac2046fa5405dd9a59df2b4e9bf6386cca4904a96a1838067e8536ba839a0d40b874844cc2f11119f059e9b08aeae1bbfbc05f984aadc55d328d18d5c5adf1ec067b72a29254acc8a1cb455577ed512ced6b7174eeb190af1ef37273a52563999e42ae075c273d2c6e15aed3b01a26beccce25946ef1cbee7193aef6e50a4381e6ed93583480a996ae24e8c4cb3260c08971164cc29415cfd99da688f769ce8ae808d5f3e086ed7a86bb1c5fccc037edd5a73ecdac7f20371a7c8dca6587fe37636aee78b1dde4864e233b903f28e975e669e4d9c174eb28f9bac0d3130fe6f276543d43bf5a77cb127d947caaacbd57a326aa5a7c494e7a5dec6e3d94bc979410a3293588553b7374624a4ee29438a9fea30f91f2001888ea916fbc55ba1c2d96ceea5b67c67b787389b3a6af1a2b9eff4d688dec6fcfdf7a311af0509bb30642d9cb32e9c2c9bde6fca34481c094bcff2cc9f3ede90e813e493f824e4fb05f42b447f98f1744c95bbb0b1cc34ad3db699093442b1abde4367198934b211b8c044cbb32be807a5b23c083ce53d8f44a7cee3cc55c6e096b5d1f9c74278221d0f7bb534e594f93aeac74f2156a926f0c891de71f677f9878f096e71cf3e0d0eaa2f2889e88ac950d514c36ec863127708f6cd59ac7a6869624bd3a9fbc15a64900f7856be540410d878cdc007a0bde63742b3004d70aa9076d38dd08fa7bdeac89d8a5b71a91bec6fdd48b0d60561cbf2b0fd0d7db7eaf56e46306e87fee2a4fe88668e263dbe1171df1bfa399800ac491e0e4e45719266a6b4fa5ff443181d2fe4f3655fb8f4990d3da3112434b0025a2b07ae8d6ec2c923a77b2782a55f04a061fd43d46b582935001b0e4a9f9d5e9cd259bb85313573c2ba293e683a124571ce1df565522ec1374c22d508b1ea8ae29c3e6d14dd5ad0fada8a4cd448bb5fd39729a8c54720da2548497d74003db7da8ea94978af32df655084cdf957adc395c1bedb55fd6f6c57558d2ee2824cd4eb34e703a135bc84a797d132ee135a3a677736449c3b97903f5fa11378f9679bcf6d35ec22d7cc8e2af4046779ec0147232a071c7fa018d79902e62678bffe82baefad185204e1bda024253c61f73be6c24f0ae4726db2f0f1346cb531e1bb1c0b12fee620f1bb2a62236dae2ff263ce5ea3701d86540847c375be5e2c494d47328f703b50b22698d925553e9bb49cfe9f6d9aad737c3d39dc7203c820342156724fd86263a7988aea1e8fdbd6cd1970bdb24e8cd93e6e8143e1726c86abd6154668d7641f51bb1a11da7fb343f45e3c5b7cd6d73df9240c964d9a979b86737b927f550a9dfa09b371dccf1045865a9d813f3d354e2df7d5d9da4d7268dbbed17daad116618957d21db75803a965a583e23db5c8150619285aa750db3b0990e148846712f44d7ca9643364e123b90c337d0d99874c6b3e1b43e8f7cce48218ee62b446f2a3c0a3302b60c29ae3ed0d8d06909423193e2e3aaa5980ece928b254826e52d019fa0dda9be5682daac50401967e21edc029ede67d36f6daa77c7eb1fdb99a185758edea9d8737d89f4cf0f469e6685f6b54592b9658282f167a9299c1c380b57ce6273bfcffdc600bc3f49650117a7fa913700bc8904a3f9a983b9770d646af5b6bd626a02d928adad1896b869e7eed45157f57df0ac9514ec4ef774a8ed56256c400be8377ef704c177922ccd0acb55b8ddeb5963b60ee99c2b8294c685035f07f6ac90505993aaa8554cdba97408cde238d0ccb3440e32e939d254f4c743cb35936362a64aacffa118d55b00176f5bb953862eb2713158d171febe9886c26e3516f781cd95eecc2e423b45bc731b7a24a07bafa5de4def41b26f3e7a6f40f6d7dd8c58b94b84bf45dc1095f319b2b317eccc1bc4c12e3e8b1a9324a10bdd00077a9bc9bf144fe9f5f39d3297f8479d9c35cc7463b873a9d7be50cb6f94c21f75c6f75c33365441f886c7dbdf2e740720d7a6ffe79e88a8699f83139d82d43946542476851da899944d49b21f45f194da2759d619b15b1cbd616c951e44a2bcc322673d44a9120024b054fcd8da98ac595f060abb6df99b89207daa584dccf63608e539820139340374de046d50de210f434cfe40e146ae347e9b3b3e1db3d145539420ff9938583d0335598fcb25927f6fdbb71ef460d6aa3c413598a60b56d69a5f319d5834d613647053ccce6ef6a73cbd3afd59de0d6d5384619673cd9bdb02542d3142a0617fd2fdbf6ef5d6156d7b6735346b49b61a3f57c4744064ecac85325fcc6a67b8561ed1eb8b7c70e2cfe70cb90390ab5ccad90aab48e49b26d56466550e4da778214ddcc72e5853e9f4a5f7319f1cb5d1c5beee87ae5889764b51043b96eecfc543eacef5f4fc2ebba8d49be59409761e90edcec5cf1c4e3c420b67de732dff76064d272ccd92a451c3211f3496b2b6f8092dc72aca1c84a74ae1bd8d1a865b8a6106e5223bb39faf5fa7334c301324e0f452ea2750effc350a8c81b4b77e1a183edfccce81d67b11c27c4d35a2ab4bf79dc391d3116dfcdec2c623fcdd37c03a34373a60bc365a07165ae73fbf61c0ce747d369f1242f59412e6508ba12b031e5fb5466a19cc1d93f2c29915855b12c120a44334f72c759af2a17693fc8ae5a2263c02b40e743ad6dec54f8b191a59184ce4f3bcbd8006d6b27c46111afe7a4c27761c3cf7e4b541b40c4a970f21466f1a8ee7307ac4fad20216ec5479da645e94c3efeebb739073485a7b66d520655a693e3b925038a27a2d65b537c32cf048a094331fa708c4ffd5b7046d04f82c55ecba646b63867e4def7b6c7a5aeff238f682ea4562d25394cd3fa682330cdea48ea75d25c143e2aec058038568a984e2668e32c51767033be303d46c682a73d7dd5835f11f49da46c423ef27db303412d6fa258b2a80c430e6d53af2ad3f3f964b562e9b62958e1ede04d382c306a67a20b3f2052c58930e45db4a867cbfe65131a72acc1b764917ee2cdbc3968276cf434cf730b17022f9cca54899bd9bc90641d9dd7d7a1fad87eea9172500109f932a6c48438cf4d3febac09aad78a4a75ce1b82ff8cd95c2bd7ca70265fe586553227eb91aec545c139eeb1d006ab85ebbded6accd00d5c09d303016c2a0a259f8397bd6d96634e02209d62b9807b48636fd2a8a12b7926265c7b7223874a8fe9a90ab88e467d49e463d0f0599063cad3a15dfd386a80cfa705c28a2104b7f04acfa9487539ccedb218dd03c0c4e7cb3573fc666db2d3dab3ad0541136a5895f834082cd563795598fd9a6bc7325b49b3f4b6bc5f7652f1dc46d679e952b2c58e10920bcc86ade1b80731552bcf42effdbf1be7822748e01c01ea61b4da86fdb510507608361c4c171bb8a676a33113f583937dac36b13433737fc0b2ac69e70d89cbf84554f1ef91350845080dd9a067ba29cf007a50f9edee27a5437911c863de694baf6a121aa20a259f2e5906aeb3e736b4e7f8d47cc3c80fc1c8ac07acd8a18c3abde34d6dd1dae68916c3595281ea10f78f4c62816a6399436a6c93eacd3c4406d6d6029fe1e75cda2188bf31c2d8afa313efd9a36d43bef97354fec73afd6f6708c6c1d5f4bfd7f61bc9725db0424065000ea8c0c26310749b426bac03b03916c3d6cae3f01fedbf8d637ce96a892a9dc82714018b9e5c52e46a58eb1afcae40322ca0cb931dff8ebd0e7c9f912559e7c67f18c43308479ecdc7a0b48dce0a93055b100285b1db43734a4daccbb9f1a8cfae6987d83b5fd04c900ee9dae56d48bcda391b9617c37f712bfa877d2e00757b855718851404eaac8e7f03736d48cafe4bb251da4485282eb87b9666b31d4da30096664ba4dacf565f0fb9b94e9a88c2a4a793b225f7d2911309368bd21426395dad5b26394cca343fec7a97c4100cb9be38684607db91127e00d10288eb06287b5e2b742ca9f90140fd8bef0fdb84c4224fcf2cd2b25877f84fd0c4c93286f0e7748a93d5075177e845ca081b6e0739097379babfc5caa598ec87b77e628f7829b64bc6198db341bcdb59d814dc234dc7e9e37e735fbc6aa7b321aabc9845b024c095b2b72998bec28b0390f53bfa25c701aae72e2672f5b2630f389d44c5c59be915cf5950454bd4f81be47862a364756f55228692da01727497e27a6f2f844a6af54617bf20f215d6188d88cdf2e2f84ccf974dab4fad7d5717783a3dd6ea1d4da07d5b16bd40c4da063d098f7854c934fa6fb10bd191473bc69145f92ab67716af276aaf0ed75d2934e1870bc835a9dba78fdd2366ffb0dd1854b6037ea486836d1794a9336043f75bd5a1c4a792d280cb549f026f5f1fb70a6a4a8b2c6464c1fa76bfbce805b5b7fae29ccda87d0c15b94900d420808cc1381e5c68748b86c4e47d606fea41dcd46b5353e094cdd052c211fd88d0df76c1101c75704c4b24350ecaad024e0257661e0a410e754cb1d8eb7b5c84924153f531759c2c182888e25caa720c9f88d2d46504921f6655f4416cb0539e5d21f0597c89f2cf2f24e815d2bb225020c464549a13ad2ac2ca4a19c073cfa5500a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
