<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eccbc9cdc10db632ba411a8e67357728f1b49494d0f153e8fedc7120d34e5085c8f41ea2d6fbfe61acd5257ded716a56c9d568cf3a4e64ec0da1a265635dad4fb75f7a4330e6801dd0bede17c67f9b2428a60122ff6fe4d4cba6ec30bed7fd7d14dd956e54c91570fed04e40d2974951aa27f866f1325b7470e7f1b20bc19541e65cb318ba099d198fa2d1225a9803261c2007a2efe95a46b4f917e488a233f0723032b5dacc51a1369060eba1693a8c19b47ca00af656a9c5adca3b46d308f08c36564a4b61bc2ddc41e9e2d4541033950ad97308be6e4502c6a035de208606955824b0e5ea0adf110fb8e59eb39d449adc2106e009a2a2bf497653ea49ae5184224db2af7bc59bf81904e5da318aa47a524d989f2e91ccb7cab60b5bc121a0b6cb42db2b41c64e6c380b1ad41af809422e0b4b431b46a4fef2463a61764ad07e8cb63a7551b058f054e11acf9c49a509eb6a8ca8ebcf89016252e06ddbb41bb26ee7b6b55fb5ba140d8a3ddca3e2c00072b09b140441879f4d5da3967e68becb9100d807d9baba3d2e7320334bd568d6b4da1a9a9e0a0f63185a80df976b952c0f44307c1d40800f43c9ded73f13954d617a85c718cb9856718ca427e84992f6991d1ddfefc90a3cdbb28a2b112051d29441190fcec22a76f1ad2a704bf9e98d0a612b8327ec4705fa50865a386fbf851956c87486a4e18ba5d7b0a89d9e67aeb9009760797a45a102023edf245a1e1042b95de13882de654eb803333a8facc1055c92e2686454ed3d590b59ad82d4ea1d7245c84aee4a09c635ae5ebe9f97a72a4ce7f2d1d7f97b364b54ea0b9e99b25f2a5d1e5ef1594b25155e3be7df7567595270763e4ed6f9dacc2872165fa8e5bad76e32e52929c0a372e9a78cff4cb1fe1183c820a60be66e79d8485b5dc58f2cf94b40315789960d4483c688cb9ebc43e32947c93a4ae805940ba4ab53749542429a1b4d9b29b2b72b858e1502b78ba10b47008412834a2f776eb0cac9b5abee730ada5b345594ffaf274b82f91f17eb75475ff674bf3e8e461d07808a38bf6e497c56c6c5a36321e4f916532a8925d36434187bab37e8f540dfdb64f0a2207fd52f52202d731c5dd6b9f0d3d39104065c569b01675eb0e60e1b84fb9f7ce94e1510fa92050522a3f27aa57f3acbf794d798aac2dd840d261a4dd2ed3b223f3562b7dea3401597946bb816e80db5ed8a7f888f66ccaecb31e744393b21b653d57adf63e5db2e7c0d8e9a8c33553093636e4d92188f785e0636c0aec222476946436fad16c20cb83b785bf65ab21ec58c286922dec70cd1c858f4472d5957c0d30380d23ad9f868857e006107e3c303d920c7e2a7bf575b5812bce4a45c9e8199875935a26baa10fa146e1df2291783a66e4c159284dfb3bbd513b50a84cc24f96fbbdfa12498383b997ac0bfd5556fd1684f9cc6d319b0c5efb3d30ea57eabd83729753a89f2efb1576e5f2a0b16359b4bc3078b766d173b845e46569f3f1ebc05625bdb099beae0e16400e99e449e81e2cb4099b09f803bbb24a5fd60c17eb196d67b37cc148753a2e6b582904935be982af02427e68e43ecc1c8e42eada3cd3865b9bcd27841be242c44d25be4cfc96e73011a4d3769830a27043ffe51845669d5da1898f60c5969dbb4d98434bb5b02c1c804f8404a5742d46b44893fe66eb93e84cece6056e529497cb9962ef42fc71aeb4f10b6c51d29fbeed9f07779e11e790afc7c5920722535ac3b1b2452060267d44eaf43fa9b4cf86252877e1c60c49ff8a5a594f6c2fb390e48c606eb16c5ff98edba13808c9d13553a7852a3e55813decffe95c109dca95e828d5182f698190a54f70bd75f5eeda92d80a3c810c038789604cbcc934dac12a8dc40145923673d2eefdd27277c325ce52211a6a59362f717d31da1388e227937d8617f0341a5d40a290db4917c85f21d9fa06475c00d028415d1d1d12b3ea8b9454f8196046c2f25505949c91b1842869895f9f477f128052c0af2f89f74b0d98f2fbdc841bec6da829eaad7d80923990aa237a9eada0125c78b77c6270821b243c4fd2fe26a0783d3a8cfea557f156b63e559fc7f94d6ffb9f5571fa3324bfc0b0f0bea769dbec4379795bc8a7047115153788375c64f74b904ac2a17a40922b78ed6d27d5f017bfa42e611def1e67a60a0522951d775e3daac4866514caee3edb92e6295cbdc6cd20172f4a0fa94fd83e0e38cefc8adf1ad5a783498998663e7b078326b5181110dead1f87cd2b4cc28bbb9d4837a405965b662b8413b08f76d8d02b9f64bc838bde5150e524534e871e9597da9e7eb8344ac4c1382c3bddf0d7aa82152c36e5c49c3ccd1efe445dca688906645238e36fe133583829fc6fa676307783ce18020a632f13744b2932ec155524996839f56f9f78f068fadcc60c9743911e93492ca51ff13e215a0d08946f5767876cb619c8dfd491ff1f3cf8797d31e0c6a044c294a4107a112f39719b4a120ec600d12b12133be0bd5afcd089661e4116328d3fd8fe12333ca8e18974c40823e77c3306375ee0fcdbc5325e94c30d5b1e219973951e3ac88ab97ed70bfc486623cbd55c913c24438da1e225cb4380145ac0f5f4c9646a1b723c4b69c71e7376b89af1b1f99d67506f23f9007d4df5cd7f0e098fa7f9853b07674afa2481263182273af0fec01fa149a7dd916eea33a6cd1dcaefd23ed44a9727cac402e024c5432898b545631db96edf1d1f62812271d628cd5e3b870a1b50ef07e8fe1f12f36dd328fc4acd1f76aec061f2681eda6209992461e71c043397bc65dc9a772c1709437ca5d37bb5327314e20a371f35ca6e38ba3a89a740417b90c3f7c90bbadebcf957c9d4c63e675200d63a9487f8014dfa58585ff029b70fb7dd5c9405aea6c9cc6dbbc2a49841f529abaa980cb4231db5521f95436ee03e55656675628d3d186f92f5bca57279c6e271a28171659be6fdc4095508a4fafc38bea2e711bf8ed5204055d862fdbe1de21de961972bae308c4fc84548a1c081842bed9e2ff5d645b45255ead7d311af63e6300c9bdba8b21253b204b85c9c616d02deb4479c532ef6ba054a3d472dbc71d559acc45459c3026f29f759f87635969536f9feb6a6dbb356f762a31faef658f0665579d4be4fed6709a524b94f63edd69fa1e46599df940c8b6844847e0735aa8bd8c8ff1983c2720e0e75930a3b54f02327812ee309eefd181325719b916a6b50cf766d6725373047b9a40b958720b1bf8c2b37bd26c07faf8e743b638abbb2ff927ab548c938b3ab01118feb32f611df9a686069d360f253a5235f5407450c56b1fdb315959994a82f0a1bf02a8639aa3a218018a18870f9abe00ab69998c150baabdf6a5dc4d1c673a76024ee8093f07bd73267e51fef13a94e07fb58731f1721953b488e72b6a7237f056a14c9d8d00f5702695df5c6b7a55fa814d408b4a33173cbe14843c7155ac3198a630350175699af4f1d009fbd75e85c374801e8844229a8e595c364b0e5715a2716112b417d4b44eb84852d099ca7c839ac3ccaf08a9f919d8225f84eff1a80ecba96edfe04c20a62c6e6100c14d891c7b78bcea1a8a6942763398d36890e45900d85c5f482daab369ed2c76637f852ef47d1e5c66ca3f49cf0d7d73ba7920e35da066bc17cc2813720171b264767fe932021b5ec23a189bd7717f094bb53ec193c363c26eec4f7ad23edbe3f0d392a976a5f3a4d364dc3592ea85abeefba5cdc0e6d5d624e9c18a8c4c079d997f34483b7caa1a47a79bbf198a3fba0ede65a750c91684350aabb795a2a5d20f0adebd03be37ffa834df3058246060f8f5c288ba0b46e8ac995f3699b64a589bd4478ed86502f1cecc3b29356a802216424e24d6d79892ad594f3fd3224b4c9a504fc13223dffb05154b0d2e2cb2de212c7639d738a21c915ea1468b3e5ac480252a77851bd6f94988d2158e8c9e75dd061222ca08606ac6a4b45f43852f7e35d00ac41347ec21f9c21ccb2b67c837c3a0a9e4f310028f715c724cfe3d885f8a993a45fed38553d03d913a7b1246fe994e591a2304b9b761960804c9cb7f1edee1366cf2f48c003473740eb605b678a5eac4537b8be85e61cb358a7e0d22b7c8503a2eb70ab46b168c439294ee696e91922c38df8866f79b4b133c77d244f9df662640d8f2389438c00c38f93f6641b5383ac99e6b5911cbae1938349ba37c4e732c928fcb8403fe3e802d95ebd54a8526d2cc422004da6f61bf886dec49eb08cfe9a53d64a7c435291c046c638d2f9518764a33c6ec9d5e9da8b6019ce3bdc6d2166b450f47c3d3f358eef34054a77881e18ecc4ccf95243e1789864b6dc6b9d5ee103b943edd3d0d0b6b6b05ea9dc289ca31324cc24e885de7d5ac0118eecbd64f9db988a8df0489c15a8d69ed1961425e6a3f373f1dbb9fa89a2a34c775564c8bd1cf8f25eae1ac8c4e0b2438c1b514a3aef1cca332829fd2d4688b459aea815df5c8cffb0b0b1a6fec69319c8406655310fd1ebe788ee4b396613dfc359c3bffd712b4ae2292e2931c8c077f60d1d31bb6cff7eac2660d112a2e461e3a5c95c3362da0e5664b451d089edfff49c35fbe5508f8323dbdca2aae25e18fc44b93b9dae15fe9889b84d8e1b5aac788c4d78ec91b290e2d7ebd6d6913f22f7ee81191dd7e95366aed2c5854a7a6c33a718c4ce2d800a2bf152f08f78ee1badce5d873e36ed583f448b2c03162fe08700812daaa25eafd03d8d0bb7d8cfd670c65d03acec56645fc105012d1c0b33ba9817e6d3306bf2c73e8f8f181cc6f93ccf1a2f0c88f3e4064b1f83904650d91adda6e7acf2549e505497298ecfa2691683d32c967ea14ff63cc3773634447ecaee5edeeb6576d356cccd9d5d48154b1bd6e6e32325103fd174ab5f61ffc400802dc67bda651481fb9ebc1e8284e232431e0ab4e30edf2a5c88759f572e943b8f32df99e1c2c501461f4eefd32a78ec8978e691c8258f19e76c0b2e69c7712debdd6137ad968e1efd7b9bd70728f7ace93e027537c0e7f3ac328101efc540f6c20c316afd8fb7082a1bedf89689cca9c1731e169e20d8e9690252a2786a37d527ebecbe4205789841f54977583556663e2bc299646a945faad9101bf6b5ceac4b163d557eec86fc7b9c2d75de129873034d9b7236e05f08c1b8e2ee19aa2bf0eb055b301ab3432e935c84d8ea06ab0f3d474e138be690ce786ae8a5b9d66ea635dac4135dee8221644cc82dcd8a29477d7a3605f8c6f5ea4f56678c07449d12a764c2a0ec7097e8ecd44c3e56326a574d94fb35ff315adb97e3b5a30256a08e095d1a0a88e89da45d7731564d75a0e90a0038c23b5e422be857b9a94f380f2b6815407f3a602de15a6a919fbf353d3719c1de20548e43add816c557174acfe1c1aafe450381dade262b10c502eebe79ff484ce8ca422c92b8321f80d887fae61458933314e70f6efacc1b397f52cc5e447f228b19ac7f8b873189ffc31f2bb8cf5161807983115267bd31d7f4bcb5fe3f295f72678d1182f7b7716b6193ac7fe72ce0a26d7e92ef68ce80cc09eabb4b67d2df602c0e848838f1bb91119650de212f35efecdcb0cdb5f985027b422fe230bb0958389684738a5d18284b80962f4cc68d4b85e692b0d5cbb99619a938beed56894aafb05f43c4d02828c37659dff35ccc96b7cc8abf25c12fb65c38952113467e8b307c36192f439af822e61664c57ac410676f3a956fc158f65c40f8c23b36b31b3e6caa7b9e048d9a4ad869de78911c0d7a956c4366bc8038d3f8851a748d8083e0f9074925d0368a85a63f0dbdee8ab31c0688549a04128d6918f5f7573b6ba9095182f88d30b5060861e7b8c559347c48e1c07868c8b6ffda31dae76a83cdcd4717d1b7d41ddd76d6231bc65779674fd287868c398fc97ee1e24baef296fa6b02abf6edbe4c93b1b2bc33074cb1185d2c78e7303436e3e11fc60e64272e1846c518c69b8d51a042d539301298eb1f027284ad26ab4566e817b34f8c239667f97049e635454317cab81f3df634982c7d19d3e8e1f861f90ad26249a4bf33636872193c7e0b005d1662299537eb30bb04ae9fab7105a600da076f0cb62b1e7386a3973789d20fb44dd06346129f0b0a96aaef18a8651f40cc7196f47b10ae71902f8cd7da143603d30d06e1feb4643f4a8fc42b6001071441f13eba08abfa6c617a6739cadd37fdf6e42b9396cdc683e7ef7b308f1ea90bf50ff2f7a513af20703353776d9cb1af9eac89747d31d1a6cb1b8cf46057cc2f28688ac3f355caada4743733a0dbb5df3c403907a2348253ffee4a0cba8f8ef104780d6cc5e273d733e3cf7c7eaca433d9c9bf6947c5423b505b84c6c34b489f3d07a100a885bb243f6a73ed730f8c2032bc4c12ea5bd5a47a9afbae1ce9028cd807d09cf7afd5169999f1c25b1330d778f108bc8d732ac006476c53eb4efd18cb6c63c41590fde3f30f12ec19895dd7103afea86eac0acb2cf80e3ba8ecae86b5b370082ee9b6db7ca14142c851ee28241b5bd8006cfd8a160a915fccffbc1a733530e3e5916cabfcf8ee0a25723777ebf4e5d2f15c4b7743ce2cb6e04cc19d3881fc4af0e0a9d1c1c9aa0602a7fe5669629cdfc898172f6aac584b4357a40d7c79678a3844962917b2d15da62b995049b5d2435a660af5f3187ff0ea5af4cde488a44ebe21774e3f23fee5e30c2c008ecb97e99761a79c44a072dbddb336bc0f72437d94d1df465fb5011d8bcd4442103ca95eeb5bddd064e7164147db6e819d8157b5db981cfea815c84c22d3ab658a5b3d6feb2ebfc8f63a4d21378760e19e366486ab9e0914bfc689a34e8a293f85cf9d5c9dd7ce9a446c0b21c1703ecf35aabd3e0c3590545705388a3ca2a5e69a9de223bb6931b344c79fc1066da1122beca1ac7b2bfc2a82bad6d42cef5b98587749923b39e91eefe93b69a047c6728cbfc151c7e5f6aba011ed858081e412cb804365ffdcf3600fbcc5bc7fa7015aa023550a8d0873ab5b37f82869b3573711ebd6724a52aacae3e68a362d8c3eddde06029a3003a560d71899458b46426d20a01d6ff2b9fec44b73139e06eac14ec19307aef8c58126ea873fe86309507085bb5d87c0ee7580d5eff415f41d6ce7cc5a540a08745eb7cfcdcbfeca538e4253ffd478393126febb6fadf9b0d11d3710cc7b55913da1b8e9b2685190611b10f3fea5fe87c0fc74a301121d1a067112fbde20e1fdc78f57f1a2894ec63df5a738e2103f0252c4a1d5d445b97d6f7787493b745adb60b77c9a78b50f2b7d1b04ae357a274c9ddb2039e46a428ea4e7f07762da1656ebc0fd22b37e64e5f8177d714c320b3cf637697bb36f24529cfaa99d0c0504fa08ebf11b21985a1802b958944203f2d90dca287e2865130f896b457a3779dc531ee0e8ee1d3a7a0b679734122342bddf2ec74dc82f0e7d8b4a3d3dbb436fcef6f9879d0c745f7a1a3700c012f385e35fb4dcaddf62c6abeeddff231e9e483615aabc9e70a2dffffbaed82d3bbfd40c2f8e536ea0369d44012ccd02f44377ac00c5d387c6463a42f3cb7ca30718f549705772d6d2e62646008737d918fcf85464577951386aa7ec89848c4ac3bafb211847757dd56fb29d56ed0030f2ae43464b057aa20129517ffc5bd387bfcc330047e34c3c0c1013a3f607f4123e5459bcfacb645d30cd8495d3c84da52561ebfe1a6d4ec6615eb03f050c677d4308f6ab405a1243029e3d38611793fba162225d7b51c72679e081899b04403821292e99d930ec992e28c64978d2b76cc001bf8ea9f76677929095187c3c4b297ac2985cd3a59c4a0d8f6508e30f0ad8f1a882a3f3fa7eab0b703ee22e757d663638db5b40882933ecad6f7b4af586020bd1fd919d92fafc534b9fed1265e7cb436a30a531e2038cd9274647d7e9357f44281ada0b65d273492804c2d1e42cad679dab2ac82254146c95fcd9eacbf2840c62bbeb9a5ffa161d853a0c08132265c83cbf991798a86974c5b9f27a56d8e28b99129e37dc59877edc6b5a97e59ba77f196eccc5b38a15dd0eb5c8f0256d76e8e228d67cfaed3cfe83c6f5b2e6d04b02cec1769e8e73159db7beeff7c76f718a7da474079e60144a6c3390f6fcb13c65b1b370bd3b07c238842d92e9a923e42ebb00c25cf0948bb41628e58293198425727cffea61c88d346278c4ee462a25f45cfd9ad933ccd8a5542fd0af308f6605c7bccc00a4770aa0fbe6d5fb4a3f7b3a6a05ff94b2a377ec989ddac3518037fc5954dc72925a0ae197eae772f17e29da938001078ae98afeb52ec6de71dec0264746e80fcfe050a38277cf10d1a6245b9d3399bee83f4328fce24ea08a2cec2473d62e6ca9cae542dc43263a1d6a0d2427899f04b99d30f2b3f80d05bcfd875c7e0d2bc6d25ae02172ae0a862d44af478a6aff25a747bf3eace6d953c59a9f7864c3bb7fa306b2456f348260e330b2763f6b39eb094f9ca03a626e8770265bb22e84ee7974de6ba4735f9e12247f335341bbc6daf882553578d118ba10d34090fc27418c310f478ff6911f95d29c3edad16381cf9cc64fcc666d8511bafb1ebcae29ff06acd15b8a7db6a93c8a06148b16c0fa51ba047bba15be05d4d9c0e7a2ff78aaa75e42eb7f00fb87d6101cee6d398f6d3b427242f4bb026c7cd582e013873aa54a580ef5c5272f8d1c7e3e5086ee43bdbeabdc677d61e13a02751c557e43b3b1c5badeb4d6e6ad4b679f3431bd78503e7afbe7e464965cfc8b54736a648e3f23b2fe953d548bbfedce0f67aa8103d11365c9a894f43295dfe119e9ebca5a79b8799c183125940468c767be024b0d6e1a00ecd757ecfba864a840859f502118ecf98d7bac7a97b8533bfbc68d77c2f12bb1a4b94580c39c3fbdf1f1b2d70fa3f0d073af6ff6ef09b4c5376e674758a9b3563f5c84bdedb26d0e7492d202179a5094b26f16c97d5be941fa34b7c9d124aa696c5888b5cd43db70758999070328ce39c917956cb8898afea771b15684f5e42fdb7be1984d590c64e9bf01da331473c93d041022616b997510bc4e0d5ee6910f40353a0ded2e5c858732555af2d0b8e78164d4325a88ce7d95c84cdb7aa75f0edb25e66236f8389374418306c3c3bf4397d81434f41a858e1172446e8f0e11a0e7d218c79a50ee5eeb031ec23d1b99181c36bf861d3733a28c143551c03129890f0da3719eaab149769446c88632b70ca592a9b381b246c4d0bdf2a4c2c90b9cd3e75a34b019436c183716442b9f5c650af8b785eb9245c4c2c1a46ad5735c58fbcacf6da3fae92751d5586ed4ff122cbbf5c9f9a0e86c30513b68b7e49959642504a693cd59835ff0722217498ca6d4f7c58e079a5cbfa3d3ed4c6edd1c64fd56eb0111b959f21240663d5d3a157e5de01c0a97d8ad33e66a28b6ff248db2e17d0073de5e0cfc1c319d1c3364589ea48c25e1e820155f5ac0610f5947913676871b97a48b511661f01c7df30b282c02fec6e691bb90150386481cd7e6bbf2a15098630241e98cf598a01e1ceed6f7a8472d1417a3b35354b9da2b24b25eee234de2feaeb6f3fbf337943307f7f5c2f004738ad99287fc963f7644d95c7e9ca5fbb35e037785eee48ba167b5e0c310d98622ede72bd45bfd2b61f4b252a465e4e895ef267bbbaa35e6b44cbebd3f363ac1f4ec5755aa437804a44fa9481f6ed38dbfcf0263c5870cfe3f92308bd34513abb73d365f1018cb4eab560b9ffd79ae20c3f6ec6c84d1b176aaa3d68850e5e5c2e2d75cd39099f15f1dc52c579f241041aaa2c0e676907e2f921a4770f26829f17cc7c28c6d1499560568f6138b3c5e4ba15cc2201bbcb33e031382b342add460ebcd236b0effeed41b64c571427e09b2b206ab2977482371f621d43b24325eea8cb74227687dc0ba052b7614e2bdd871f2c96a89837c33bc3bf088723d3f323c22fa86d7526c5c9e4ac22b477ed1312bdabe1df9ca6b71e7fd8dec3c507291b08b570eac1d755e52d85c8eddba9dcf194e4e7831965dbca2287768bc7f74a1a4f8a23c0ec1d80f3c5a0d42e0ca5f1ca29c3006023282fd1096cfcd399462a4b7b8c4887d2f5df00aace7f3c336ae03e362debf5caa023eb445ebc4ec36973000f56ebab39d46df91eb2e299a35dd2af4c2da8c5b5a29ffba6f8572b7ff6806cfe0d967a3fa43272ff60034a39ae3cdfe0b5a0628b4fe7d4ebae168cc2c0d6aee13d8ab8922b138bf75471d82eb6756bb218aea324f683af76c5821577cebd43733c1d2a57d61f9b33a8e8a0ce98f841e30800761a7486b134dfe917ed94350fe9a2f177ec3dc7b0c3f6340876278e8b65d86480fef9e576b2d6702dce33370558c7062de26ce950c35e3f3526ee6b4ce013b210aca011b666e8f57eb6b9b5b0aa4ccc2d3373f59781fc73faa410f0059968f346944be12f0f585d6f20020b4ad3f0ca900546fe74811db6039f5725bc5199b1d6da5b772905d27ea1ad15eeb7ffcf8dd98b94fc225624a24e923b973612827a74becd3e82832012bf3f7c136d76c65c03f634402d226f3462ca9a4c6219a325d76a80d17e7208a99d2a0306064421cf80960ccf5cb74a7c4f4010f140273f310c3493eb3b74fef5a4591f9eb1577175dd554454cb359aa07469b4b6ac9d0086ec22df2df6a8c7e728e6d105a583593107762b4d89ff65d3396f34afd4245087c325283490a26ff67325ef53616cba1a31a16b401e104e9587c0985f08783d5d5449bbc467cccf7aed8b97ea40d5697e98c02e68842d033b014f89b98bc67f2c3d040df00fd649f806286594331bb8b2040fb72973517da95c60f1e5f1c67f4c5035e1328efea0697f4e402edc189e2a7e7df03e7456574504af33bf90865af1307ba8d03dd8c1a19f5672c1bab14ca5f0a215fd089bcc51654915a7fb120475c9c60634f71fd49c1960ead3086895f947cbc7b1f8e06d79819a75df12e578f42a327d8c3e5954b0badaa9f433e3072dfa6b9b596536aaf6f14a5ecdd1618f6f5801978692e8770714948b208e2902454c5d3bb31df9690502720f92fa9047727c446af9aa6a48c32baeb54620fdb756e8de50a6284da8293e3706428de078940d4c851a9692c31516f28c7a180f991af11277656066aff7db1adf05b2dd3bea01093df2bbdc9fcbf24cf04d047ca7ecc561c6287586b4eaa58450cbcb9f9b71b9f465a7f723fdc3463461e83ca293cceee7574a942b95f0006c149762d38dcf8f1e2a1129f043da60e9ddfea5ad46c52f914e16de940a3775f5c48ddcdc6d3f52b583ec136f3d2c660a4a2d07fb28ccd62026273de94428dfdd2bd2d323fab306e31a007fa8c35f0ac86d90ac9e5d3956c18b38996e904c5271fe96a68b59cdb4fc1e3ddfcf669914b001848b88c4ed47e2b69edf29b0800db62d38a2c2ddd7295e74895553a1e354450de7c1561bbb412f77d0536ed3c920054991d8f16745e1b1eee09703c1b2961419dfeb5c4912acc5a5b4c86b49d23855736f8b66318f11289b9a8a47ded6d5508452c794ff987347984f2fcca13b341e6cf034a23da3413f01e126643e51b1d14b4336c4da4ea04b24870f8aca00cd8c8d33f1b2d0122377b73baf2cb80a52dd7e207c1a3a3c109de5e151a46b23eb5656fe5e679b9e69717d83311c4054ed58e876daf1f05f61e3cb77e5a0d9149338c557005dc91588feacba9858cb2e7bdfc506a051e51692f5929120923e4d109ac56c4383859ae1ae8e8cb1c0b1ef63b913a1cf6c0a2a0f931e3c94db9a70e86ef07dbcfb288d0ddc092c189458a625adf99d806a49d77e92f8322a4a98e42fda11b103556b6b2e0fe095f8dedba981dead1f22448d1baf3d9d93f9f738dc0ee16becd4c9b285efafe65404f099aaf174c67e784220e2bef13c77163a41674e2b8f83102638aeea49dd14ba0763d455c91836ea351e51136dc987718188d85f2fff086f3d1a1eb4d7f61bb4aff850af5152997ae95e46e4f46c26d573241a4da36bec5e9b007be2d5df04f8497a35ba81b23540c70f3bb0f0196c0c820f11b819c41d671f4b422c67fb40b5e42bb18911efe2e7d96d1126577666c1c159eeaa3ffd7568873f84cb106ec43d9d04e1d1b413f07f694f982c0bcb27b583960c7cef029b3f08cc70ba45980ae7a958de54b978a3a373959bca8e675fdd49c344f534dff369c088ab83f7326944b9e224098e47a708a01073063f36b0430c2e58346f69fec440bb3c9a08a763dfa053de2581b4254deaa9e59dbdfa48d683e7f03e9e64ec556a98ed18fceb76de6fdc146abe02e3afaf31e40445847e2486f8cdc47ad06d1e1facc761ecc5499bd260f7efe514279896cc783bbb7dc8a0c76be1cda777aebe1b519998374f6c26ea5dd1048502d145fe6ab5db47106806fbc93b62038a94df0d1006ff6d46f0d27ffd8c5a002bf360f9267349d6721faf60354bdc95c8b594334b26b8ffc866a0d3d6b7873a6fec0d9a3272aaded0712628e5b5da1b3237657d72be3d36c049536860bb9119aec52a6a2762245f505502702c5903325065d2a91e2a4cfe4e32098215d4732386febf063f8140e66de9f5e6b798bba2bae9dba59da85bf7ae07c83d48b0aabfa08860b6ff03bdce02f967f2f578925dc1062f5d52dc7d3e141ec50408741c94e5c06e755123ec385fbaa0e6db0708e2449314b7f668a617b9e4da7ee02ee119739a6dc0d5d74dc27605cbb954d395d2075cb3ea9d8cd41602cddc5e64b219ad3c7c22efce873504e6f0922ce07db13ff697a533bf9ec829fba317ee3a73d4954af0122bdc3eb5c4b996bf308d70f8f6c71c2291e730c1b6f9751125027f97dd076ef4e4533f39b1ce73bc448e4f41b44ee9d5f5b0fa4034469952ddcec0bbc37134d0db2c83b4a6bdccba88fe1410956202308c2304ccef711639859984c4621426f5e129d9fe59cec755cc4aa543a1c15227212840966ebd4c9b3c23dd9d59b59c11c66ca3c2e532c12a3160ccb3483d0c95a1eb229fa6723cd1ce821ee4fc380d10025faa15028e8f9a18428b051c967d0ee355ceda292ea5bcc0c2609df6e7916a26f8e76dead30235be77ce5349969510e74f9903288a8c35a5e6f7c6a83a54f542863bd253c834fc30ac6674d8691c6a0d4336c75b3afa9f374ac50beaeb6410de16f2c7393f91d0e123aa4f5e672ddf743db00d5755cf849a307c9f1cf873bac5967fe9efad71e62e288008e701c9d09241573efb1763294d6b70d3b709226fb8388771d9c6fee686aed05b702b603188dbc584ea92693cb84643fec04ae29f3ff6f82f63f5f949f3ef26c8d0ef7082a33fee5bb31406d701503d8330fb28c48234da0bbc807c516f3506d122e870324ee8f09f4abc78bc166729439f46d716abb06e96dcf6d0ebc951b9cc7eff9887ef25c48dca679416111cf4ecabe4e5c0a283172ddac6a93965cf4c727389392f01f0c68aa048c235ab991faf713c1ad033b4dbc6c18f920482054a3962d0a60eb3565e0a0699879b686a1906e2b3bed85cfbe76c6a97765fd452f49817cab830f3cdbdb8facd61afa91d7aa90f8277f1c80d1b07321fab061379ae8d8486f91f617860feebe34f03662377379ae5799e0b883ca3e9c58c857135eb0ad7241cf6437be9816cf8786deeadd088f7bb1add9eea4c8496f9957e52f530efc398859ebf963a523a1ed87cb06b901d513284b660307e0bf2848ca204a1bbed9b9963273c79c3c054873e4874fc3eebc6ba4e9183f597778a17c34ab0b9bc6338c88fadc7a19b80b7af21ec52d8fea24cf395eaf3e6f3a11ae5e8a4bbef5d4fd33fe75e8db78fe5fe35b0a4d5523f2f59876005bbc7445169549caaea3d07b7a81108082cda72e899dc6d3d25f84fa9bf692b5c58153a691d7ae0702b56d2ec115a38584bb69d016d3b2c3e026c4df6a4bfff6ce6a0d149403d3d12f86e7345b2734f25207937df2043d0b6a9e5f6ff513d3aef2a8d9d14db31a984be94ad14120851a4dc7634fe1f58d2325e27d0f9f260a9e9a9f2495431625a4fc8a1564f9a31fd3e5870962f521d382c4ce711d7623cbfa37b15a12de6b5d6b09f0b2af967d9973b0286501d13835c1719b5a6aae514ea24e780281ed642ea8a093479823e972afeb12c7901d8a6ec9e5b1c35261224fa61b41e4323258a27ba5c73b7f8e6c6be6137fda8d30c40f5adfd81b283124ac96b4e9a11ca21890fdae7f9fb6503a14560ea3ad82b81bf5ab6a75a7697e24cc9e4b3fbeab7174a0363aaea8aa6c30f54f3fd2399186bf8b90f12b8811e66ee3e25d0ede0b6926d040032e8374222e3ff4badfbec48523a26e2bbc38eedceecc6d8700d6cd0837db8701b0f01b26aa3dff0aba82d3b81fa8278449dd87d9e9c7837507c534a7630228d24d811ba0f99844446400caa02450b13c4e62ca3e140fa82b8a625d2882e57869dfd3177b9d9faf2d7fcdb26792e331938363a11318e8d1712473d0d84bf78ff010f79f9cb510edb4050ba49a7c09d49b2b8e86ed2db096ccf51c76dc32989fbe966abc4dfdc7837065035dd919f129ea71160e410dd579f91ee1d2ab80d164e997fa20fabd37cfd45bf438546dc9b87430b04ecaec40a167f666dd93611f28ea1ba768eb7a1487c359186b9e4a9ca71cc27e2117587c04a9ddf0f6b65957229e28d7425dc82a3725da0bc1928b5dd67cd4116baa44aaedafe86bc654b6acd31b342d27d39f645655c09f987607c5027e63d6474828fd2966863f928db32fcf97e62aed3048fd99f6ff5bd6d9b0f5ac07e0ac63a7f40c6ff9139c340a57431cd817f31bfb8b0de532af2136ed9e8867a1876423f3f27c2394c9d94ca1d4d88a350bb247b5cc8bd8c9a45b1ee55c7bfe32276405245ee2e18a50e50b39f85a1ca663c4ef9a349a1c4c4d6cf8b1d3a9a7bf1c0caf706f8dd8308b2e4ae707ff73cf44ad015f80103514a39faae3a520633d7be8b18c9fd7435c742129dd88070ed7499813e8b090feaaff7062b44edbddce9619af1c374de4398558a562c4bd5248b92dc57ce097fc7dd49d45e898f823ad488e0a7e43cca4e1620a9d0829fbdd9777c2dfaebe5a203bd9c6710e1163f9dc98ee47b99e7b86cd5c01cd0788072102fdab7244bc30c8d27735191d792825f3f3a56e601fa37566493f47fb77ecde0a82d8e3759d3419a63e2a5043c439a238fbbf952618408449606a0b4e471dc5b2527c37e0c09111fef44edd275b0805accc0444af56cc35ba77aa2196d5e7068e5f4ace8151692d9d99c94253bc548d32f7a1766ba2070c97e66ec808f2f4dc8ac80fa47425b00fb39f443c3ffabf1fdd09c06491c10ecc2af4c4c4420726d0d6d5593a255d944ea8edfeab4ee2fac398aa3fbc6b40d8c75b7190c1c6d8af7c281b166a4e7c637e634601b8279518edf3d312c689f26cc10b14188af00c526679c79c60bcf483796d9d8ebaedafc941e99e00b3db4230c0bc0754fef4c612f642738c876b973859e822d015ab8e807bee3c9632284a4ee45037dbc136a26251707447f10da0f38a3f8911ca52d518446579962e321af0780cab1dbd000a23480039ff23e5db2c173900cf6cd7e980d7c7145ba96be73d62170834e094463f71650b19a3e672c031e0f1a02fd2155f83cd99542d993949c8f5c8eb330938cb49f9a2382a046f050932ffd10606da1145b2067e70d8075b48e5688f048c50e4a99f04325a6aceec0dd868dda2533a4c8949399746a2fbda0eac3f02ab9f30c25bd6aa2efe066cde387e6d6abefebabf5324e947e748fbb44fd0f4163eacae640bdce732576683c3c43ea2f3662af571676582d040c27346832f91de98475034c2062a25a0ff2584efbce98f921507a126c73c93557ae0c4c6ee10dac1329e367429d1efee9ae5971328a1337ff0c7dd5421af32c3a9e1ff70ffef13293ed9f8f7d89945f6b3f82fd122109a70c0b8200754c573b115c8992dec6f81b9c8fb279cc6925406e3ff8897d2d127acc60cfe144b0cde69457d2ceaa3ee92cdd1bb6240773265d85432fb6f5bc53262b08dddaee2b4a73ecb10c6231ff7b73e7a4da0b4d842ca30f52a9e757a5c7b3a79237954184c9c9439cf91a0ba58f1e9cd3ae1f0e1d3924d61b2c7beb8db991bfb283e93accfeed6698098b3bb0ee7407c42444476c827821960b96d460c231e5602b48d09d88c56a2611745f3dcf9e6906b4afe26819dd0353475792770f07440ddd6b582ab094b1dd2a8c74fa3f75d7762d62334c9090aedd4840df0435dca87000e5c181e24a8d7f665ba4dc6feb515c94ff5ec3f57029df3a400685bc2ac478e7dd2fa871a81e856228174e681026e57da47f17678bbf5eea0765e277d0de7dd8fbb7b2b5369bc17dc30ae83e74856ff2782796423c90f2095161c0644dd036916ffcb5f7b840c670838cc38c27e692add072cd13026f1707d224e965251fa6c91d884530433414e1c9e209d648729e40ae64b81583a4dba4e1e5e76dfcfc734c1167987a325805b08503e3b14667efaa1c8bdf58ed16c5f5fd9552e6ea3e3cb0c4bcb71f993ddb92b839b599440a9b14c962ea3ad794a92bf99edf8d0a114a43ec7f1c7c95e0ab584e061776d8f5dfe462327fbbe09e318137b11e02b391bce879b399e14aa814fd3a56e5dca57d0ad6c40c0ddfd30a98a34fdf941892ed5c05867fe09a42bd9a3318ee73effad801a389e89aa1f71cf39deb6f14e0c4cd6d56080290ab5a34c1c731a318b7ca0e1b80ff37e6d13095b7bd6d8897728c76f89766502070b9678856ab56ce8cfa1d8b5213d7968ed0dac4db43909cb41870148b4fdb03d36df36113b17bd51b8b9d9c6f40619847d4c4ede7d124449b52578cfab6a0c719df8cdb0828b1f2c7313026f7481f449849984bf27e2d7546100965efd84b0941c95f9d39b1b16a434972a7724b6ddd037fe105e021437584823817159bac1af82ca6c17ef67e22c61ee9370772b307bf28feb7e41a789881d11253484cd37f892dc2b9ab7718efdd64ce96ea1be2b6fc76e60a14886af1d8dbf643661dba1b180a1ce71143caf7867ff4307e400f37acd368bb5f793475bf49ae5772bcee3628fc452b50d37c43799141d83fe72b15e026ff3a45d5337b25b0ee3098bcd6507504f4c5dbaff4e4f0a1b3d81063f67cc9fcd076aea71aea62d17d247a121c74cfb3d4665dba4704283fa103df8d860eb87e05af32395bbc521c55845c3d76a5b3c9652c383ea8c8255f52a97c0d03875ecce40792334e6de7efe6ca536362ad89e37c4ce7c1699caf67784964a4d4409b9fb5018850bda7622d14782befd94c210d510649eeba370a391a38012b8a1e2c8478bdbbc9e4258257bda5df55cafa7918e88087af4d404c6400510283e2f2f98d01b4242afaefb82e0dd6d6b9d6c53374425bfb13660f87517a06b4ad7997ffe2a89b52605531f8816e0b90083627283847849100bec6031f5ab7f5e27782a6bd52231e794e3bc29803683e2821dcae28ed0f487d489a6996fb41d33afa94a0efb41c3eef93bcad4901482f3f0e5997b89a7cfdc2593451dd8d2d1054de275e0f38909c291783507fe4765ccd84820538b4868a652d845d91b29fa728c6d0aa10653ac72d14293d4e047ca6ccdff7efe8c2f525525ec6ec7845270b436f8d1d225b761b82d5501e9a5af4629ee6a786de3b246eb646d830f1c01e9218d44cacaa05c094497fe0fd34da03f6fd92568fa559b683bf9a536acb294f381a20fde09609c9f89074cd11ae8f02edd9915dbb695ae3a27714da045f623dfdd317c97c70a45d758c0f7f1be7ddb367438ed64b871fd1aff39a5172d75163f27ee47bb0e6aa13113fa93d2578a0665d9e46f9791a4acb88bee239d35dc7372db0077cfce8fd21187bf2c3fdab30e96cde4ef5aeb3fc01a1c7acd88c64596588427a2c265d32afcb8a21933c91236a960597d7c6dcc14698692da54152c0ff431ec90e0f469b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
