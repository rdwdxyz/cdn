<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b33e99889027cb6707ff3da477e9d1260b9ffd8bd1593309eea40188fb6b20e5bd04a46059e637b909029e756f26ea45c35a4d68a5731a2c8133976201d292ffd84c1b39cae66b5cf916c52243cd3b8f1c149987448e1057a6a820ff2b58736ee1959962ada2e3beef152cc5745e9c1a94ff7158579f2091db5402b29cc27d56765c7a8cde54747a32c659fcaa4eb2d23f260b8ec450c0fd497ea34b65ee556e5f6001055ff6c6fb6eda934d151455e54b109f5352817ca17aef7de986115135fa6902968c226328df111516ae697c4429de9950e5702ef4cf5d1641bc85f23b9723ddce3ae5a27bcd2189d741ad58532fb138da9bee668883cb885769eeda448b79796cd7976bb115daf23540859c6cb7af2d6570cc09f0563f6d79bca8ac2004862ac04d7d76c526c2a0f7c9ae80974361b409c7fd29d11677768d0c376f1bd864131c79c73d2e082788b65b455b9850934b25f98b150b569e8ab0da86611776d98b0333268b06413c4adb0ca8b8e1ec36ed6113589726eb2b99d5a946d5506de086c5e43855daac779dc4256a661c7aee2ab626dae383643e77df45f8b607291c8e317d80eff3d0b1a856ddf2e99f8e3221d4a9625faa1ca0129add9258b86678c340c7bfeda31105e7eff68cc731d079f055084f0738e7ae82c6015f490c34ec726a3d766aeb4b5a52655a7e64da9d5f3e94e2fb2d73fc8d53f468c65ef3ecbe1ae9ad0791d9d9e7738b86beb0aaa76ed1f014a6f8c0db38943d0b309032c67340d6846e409d2d48019f90f52b7dc5cf1711c5cfdf5c9e7e1d34759a770762ebaeee8bfd0ddf6597ed8bbdf17ad16b676727ccffc5f0f5363114e1bde8b8d976ee6ddfff93e92e2e9fd51143b57b0d3ee8607dfe1e1bc1af63def00d18898e2512fd8e35503c104d5b008643de1cfdc5464b8402426ee676effda621581eee3bccd8a8a85c024d1a7ef78b7849d3c9ad33d2e2ec0708022a50d8d360e521079d0c9f30aab0c9aebfda779c3c900977022c14fc48f632d5aaa8722e404f57d14a22cc003aaba22dda435bc6e11e64997757d18c11c554dfbbb2d7e91269a01233137bde2ec1c6eb0bbc63dab51697ecabdcd3be17f18e7576f700bf0e42e1c70be85e5f69e1772cf58656404c733572676b3dd3093b7aaf8624747fe3f392d890293901ac9e252bcccb9d1b1491abceabdd9f7cd711c0c5b5174975e58170a18e04a944ddd90af416885627eea9fe762fc41091f4b206aaf397b359c86fed20a1beb550c17426e8a866107db7299fc03911bb2fc4a5c8aea9b79e900adc0cd445672acb1d0140c9244dac15c86ad71bc38793f2dab7a79d3a8b33d7172899e4aaf26cc7a8b27447f1d5c1e676da54059891085e537977c3d60df2d0223a6e0a8b0414d253477a4dae3a07478b38214ade9a3d7d0668df50d3c77dbf90ef0e56d84d987eb952181e45f6edb4f4fada98d48601aafa452398906d0f2e4a37bfce98bce29d9930458c9090155bd0ac685b76067f9b191c672e73f64cb42bd4ff05f2860c22c45f1aa470473cd516c9a14f6471e6b04bd340b625b4c3cb54133d381b634747aa3b8ba36e37b3102af9ebf98a3a1a1baf465b549d286891191aec6433dd92cb1d6cf891cda1df8e0987170bb1a22f1c3eb6a398b33da3e654145275c90ffe5cdda21a2b15e717371bde792e9cc2d23e23fe5f477bade46b05a797aa730c8a4fbe76c0e139fbb7e3159df0531880000aab6b0b45ea037ba24e3d81b6ed404a1ada8cceda35f37e3d16d5f2009cb98ed0affb1ea600447ceb1a8bab4b5a752b91f0cb20e4c56ddfd3830277b9a3da7e044c0bd74f047368149652cac2a4451cffc1449ae2ed641c6faf11ecc3fdb2da34fdd48f6db16790e39364c2e10e0b4a6df91c345f49e24fb125bd769b55d9e5f60c6b882b50308d5384f630dee7328ccb257ab3937bb4a7d4d7fafb23c86725cff70182d3b6f3bfce3dcbf4b517314979aca7cd02d1382179d36b366cd020bf594ae12da35a33097174134191ba103216cd2e2ea9cdfca4c00eb9204068304e6abb128f4f1833e3314a2625f3988bf3515caefbe0679a1f62fc8f0b537c117ca4ef4880df9ebda6b5a87151be786fa146b30d05f430c808a1702226fa0b306d6d7bae92f6e3cbfcb86928475e32c8013b5d4345d9a1d71633a357deb9e56db665be81d5381b270b2f51b1a43494d22546114765400136a575a15cb270826686e4492e6566a206aa176553f9973ffdde47fff54903bb6aa123925f7f9c36d719f35024325f880274f3b6a74f9ad0da897acc2013c78802a1d788761d842c144c5254f9855c0e7d1eb492eaa75dc068feba106a43ccf9ed02cfad291b7ab9192e59d3ce7baf6448455798ee5b49e81780004019c740ceb657eb95390cadfb2fad001c7736a29a340477dc03bab333b90d6f3645a91ad2256a2afe285b5357cba61601c0e3c999fb165019d3e1c530de2d4694e4182d63682ee224ff7d6ba881d34d92701d23f1f9b0aa311bee81b63eb4295f13a5667ec20e25c76c69a830a7e815df34946d36ad5c9bf3ce7a6c6341c26282c7190219c096099654e690af1892ce1603af4a83561994531cba92690665b9c18f0e88311f0fd334bf8b994505d45f9ff1a5dbf85bb06b0cacc822c61780d25cf37728f8455cd87346f48c2f57967650afe58129030b97644ba52c3a036af8521efc887dd290f16c7d4d3b7e0e38d43dd1171eaf968742913a65fbfea6f4b642f381fefcb97c0113c11d36359dd560dcd6065aa976b25f8da147a656d503e404964321d71104617db0b1ad0bd6b09bd3dbdf778727a4c4cb9ef21a8e011f6dd6c245188d11dd35b2cf53e36a4dd12c3d8e605cde443660a902d85fad6e1e1adcd83e6e16b348cf66fbac355681e2776cf7cb17b26160cb79627d5061975de9e13c6a65ec6d397d08339e5a57aeab944e5fff854042b12147791d46ce045b7cf2ac928584884ef01e9f1ed5a3d2fe44593f4580dc257414c084d8d34941a015566a8e0ec0ef6e01f73c10cfff6d394b6c21cd794fd14b31b5f34db471264ecf881cd11be8bffe84f6af92bf7c3eded1b4fde9b795a22ce67fb8a3188df8442dcddc283b26909ab0102fcfbcea292c489ad9e7733da31aee1fa004f5541cc6da37dfd0028b08a794d5cc962cc19cf7fc06095663eb47e14728beddd419408f68267a594394119a2aebe4f850557f326fd98b3af97f5c087fdcd9ba32dd661afdb046bab54e65dbb27cebaceebd280baf5937fbed6891b910975bed8ed6a1979ec7b860c289f2a72db7486e77a65c716f3c93917ef408018c81a1b93dc3614ef641cec0e0f60ba6430b495b9e86b870ab49dc5dcfb6f5155b7f0943c7912d22e59020f1d0e2629d7fad182e0ed2c04e23a094a78b37d4c752ca2bb466a489754ce8a223c9560e0660bcab91832615cce3ac623b0f181af05d293ef5aade7f3b677a0b7031311cf843f85863ddf1a185db5efa6a1518fb917a427f5ca29ee468a85039052edbbf08e69dd95916e656b5f8a7267cb3ebf6c9891770b29b90dc6284409f00c66326b4c61933a16b5921c833f9d2c3824cdba32be09876261922dcfb47ad238153281a12668f61b7cb28426f656bacc4140923f6e08fdefec6e592c144b22a5b001cefb9c3301b2f565b70ab7336e589e0dcd50ebe3ec622e274309f5de5cf3797dcf4d0ab076d70d89ab3409faa8e6baab2972a80925ff950ad0606a23786a681efad0010950ed463e8779db00222287d5c25c78018f007e12df411ccfe68ff77f6582f5e36a4a9567bd81eda1bdf561f8198bfcd7cd2e421bca660ba54de3402d96f36cde3019f14cc5c0f81bd7e1398e6db4b10e43ba3bbe70a0972ae319629800a0dcf004fd4cdc29e422ec31d9311c4db459487b335faaa127025cc6e8ad9da098be6468cdfd4e6e0349abede97ca87cdf2ff6e87e811d7e07d40b6587f42f310b004da2404aeeb3f44ca4530fb9f38f4c49c27dd7f9ff0c789afba3fb226b72a0cd433bb7d3eb9c060ae2a789c6677c30fdad035b5b1fd5e4faf97005254c869e2ca2efcddc0c48fb119682b9e471de042563172fdbd75ba8ffaaed96ed1fd6b0f119ef5663a95ad50c01fe7cf19021c5bff2abe34855a21a2446e0a4bb338a32a9e5867e5a405e473f7b84a0f61678957f4cc3ca0dc773630db2b5a68264f147c5af787a269562c41e131dab3d406b1eb6cac0b5884b05afdc4e200e203894de3333ebb3d3e77c17b4661d90738ff09f0486b6a268c127a96d83e8d0da7caf0a7552c5571decc13ca959b812bca41804ba009ab41156d1be7483ca4b68e47c59315c5f3b9fd3b9b4f85ab8ba17fb276a57a941ec9221d59767e13121400d3f5cdf212327bc78dcfa465c80ef885d28cdaadeb7b17a6d307cadd5bc0e3d2cd38f25f6a12b35f0333d83003170d123585e3db049f334b262a028a640480113972489798f0310b55d2c15bb3eacb08971e95d3eef53dde681f5c078a5016ca1aa3df5ca19ccea95665808dbb1997eb9852985c94a11617c48df65e275ba862b8d8920fbc86df5c57bdc25d5531ae9d309c8c602dfdd7a1c3460afe8888f7ff4c323a7cf74114c1a9891a1955654da04283779e2628d63bf45557fc6408a661cdb9f55a150e52c067c136374ef8b432530245d477878df83862ac79f70643e60540316613a1c129e6ff2083eeb7bf567844b2a505226a30367aa885f1d366cb3b1ed508c431d7622323e29c51cf5d8854364013fd68057a95c6a84f0a63e16df6b85ecbf6df53f7f0860c3680ce1346b8f2526a100f18d1b5eb00915b14d5e4e0374ef31c15a2565e4c8f974b3673200d5e3c22750328a49cb65869988bc309c2255871cef17fd5d40942cd96ed6365e418e5486a30cb15183b9dc7e8880cd41961649464c99a2ae45ddb9b7c5b5b23175b015300c46dbbefb170c5f5e8f063b27a1a54c3efe9ea04cc35ce57c2f8b36e84c496b2919b68c7cd563d27ec380d42ae88684cbeb37ed92268d1f378a2a6e7b27ac0f14281ef5c449d783dfa4796dd774125c9c2d4c569c23567104ec6bf5d11b422f594f6a79e54c1ddb157a69ef242072c035e99183bdb67797e39616921ec28d7f764a5ed09bf5e81adb1411b3363efb7dcb03de781dfd0a096f95cf8e91abb0df275d6749fc5aac9e6e62c8cf9a53077c2d448decafcdf2bffbb6e95c4aa46ae6b40ab72d51035c07c312daa4e2c7264bf95afcbb99ddb32dd3d145f3ec519c283d272bad97754e992f5727c9108201df31ee20f7a293204944559f6871e507c2f9404ec902cfa8eb7d6af4e0a2342c2b48246dbc5fde849fd7c38fed324d51f180e48773ce49659406d99c56c9d1665fb33cb988f501b67d2423cd09c00e9e475fe6e634b46b637a970193105d2b5aef23e00168dd2cfdf9c4622d4acde6b5fb7e158dad4f626482bd72c6f6ea275f89eb1eb7d76ce567fd667093f339893d47f2f87fcf2381e4bebfcb1fc671336b29ab8e84fa7275e6733cadd8ec562032b0198743bb039698d015dc0f906962a378f67583f12741f25c77c2be53397dd135da2fe874af731a1ab10a72848e446abd5f0989b189e7c97ce48913f9a3b6776b11abc2bb912b2a5e8041bb7b0cd41a8f7886b26f2e0a1c23592f0abfedeb240424cd1b88010aac0bde9a8bb8af441d115c33fad375eccac1fb2650de08c9879bd18ff865e51ccde87dee1757c445bbb99883403e215b901df65f8d28ab38dee8b2f8dc84cafe5d792bd8881943492f040d863c58ee4c4994985d9bd5c1c2b45438adae783b2337f75768aebafe23d4011c38986bc7b01b7651dad3d939d04a62a23eba38fd99e2901d4a0c5ab3dac518c49e772f07c672ed8ec900d294ae2ab13af6361bc61a6c2e1b9988a3263524be4fd4b1381a4abd61e2eb09ab1718d97b277946872df301c6c467b85e1f9c3019b91487a2e6dbb9fb2cd5814d6f6853559932bbeeaabaf4a6dc1d1749a71bbfec80687642465b7458d3a9b779c4fc8cc4dc3556b8408bb5f81b4aa78ac41c702b881e26c722747c1186289e24c83107e0b75643fc492b8062af79ac5e9760686fa260cd291e841bd52c1b7b3c2bc5e2862fa6a190eb7a91a77990461a003484ec9b88af3390ec8c8a1816929834549fa090b33146168ba20eb3a6c52bb86918ee829c4e1fdadbc11accea5041978a8117963b8a4e93671bff63a3e3e17d24c727c21a4bb3031a15897ce299b008c703f6bf028bb241f93f35cc22a0501ab27258355b4d2515c1bc17d7128e6884f317720daf27999cf7f03063810bff4531764e12dd17e1c46a28f0e5ecbae8d1bab48a0928f80dfaa5b984f8724baa0fddb2e0642258076c78589c5f682bdec18f32dd87616a133c510859caf3412b98ba157a55039ab2721fb37018195ca463d7482ccda29257f04e743cc5ebf3855183cef1f57943ac23e18980780c08a5e03da53e0b7b30462ba1014d51a7f84edbe0ea6c8cee85e4ff4438381ad8de5dcf9c5e0f39b04e02b014e4219c3e182ef46811c26aaa6dcf74c1a5b99a55512b1dfa6a985bc4a9548d7577f366f420b7109dee7f16c64237040a9358f585d5b4d3e96e75de298b5ff0ab710bc19b1741f5e53d2724ed65766a079b8a5e61fd4b27d164bddec50a1dc080f5e15ff0ad8ec6e0fadf02cf76cf6e51c4ad754961598dcdef5a0763e5e601504bd22bb30413773997a00abb6c526dfde9676e5c6c03914b12e09266f3dc0e1df49385a5ae08fdbbfc8e654871ffe249900ee3006e42fa6bc551b9c326290853dcab9a5eba36967c67ceec08780b510d8ccfca498d4ab32f709f1433ffd028be04e1ed45bc0e3a561fdb355c5bf2d1fdf6e4b1138a147f0155d185ca9b4626aeaba169d9dcf8be750601d3e8aa938e89dbdae46766b99d8f8f79a5e40606d48768c9e10cc12e0e1dcb4ebf89a394fbd7694084c8542f76a62a1310522f64f56462559f6b4759eb1a6057e416b364acea14d32b0347dc51dcb9923037f6b7724463f46a4e5c6056b4a2db86692b8650061eeb0845d685334c51a8e59f21e310b16da5403d330eac14411fecfe627b665b24abb4a16bbaa2493f288075be5c5e0dd574376f5df2048b4ea7b95adf279fd03f5e4f013e0255eef3cd3f6534191d1106b17812085afdcf32dacfac06d625abc833c69762e6f87d9236bc1d1499330b3495986c38fa84d26e8803108a13b1b549287ce8f53ee9f26fa27d66d7f386589f6f2dfbc773a1fd14173be136871a88c85f06ec18a85e78afecf069052dbd51ac35c9a31541e2f3f895d0819497fff0c6e09a1560d38245033273ee4e182f508b589077f1d83c986b1ee409611842223673218ca6538f5df0fa3c0189e305bdd4b508ac518ba8da5bc4d60ea40522814f3c44a5c3afb90a0a83618b73e92ae94d000e1244c57d9e8c9f4e22e2397ba013548229f4e0acc38b569b289e080b1d55262bf06b0f56c040528f5f350f188bfd43f10bcc3d70c9a989328023658f0694e07db6313fe0b1360b22b6b6ab2507eff0c61c5792791b8d34d091de8122aad19aa4f0d49dbbfd743ef65713352356592cc857d4d554aa1dc16cc089e2333d8b90aeee4404cebe35e0c4923e07b590a545c839797b838ceb85b1c0bc34706ad63508606c803e0f4b74bab4f995d12b3e7f64f5a6960dce8e98fb94e19ea6eca3623b0b839a2c22358a74ddcc5e4096033d447436f8cde1e529e719c2ac92c6e62c0439f19bc4180ff1a12ba24e3a1c054ef258f1f9ba82f06c0de37b8ad2b9ceb0d22f65d8d2d475f3bf750b07213ded8ef7c86a6b547131bc281108c169f68cf214aec87d5f2ceeab73f02c247f4783e97412fbbb41206621f4c467fb1737703eb02ba81cbda183400dd79e1e96b4fece61c5fa6a69a573925dda4ea0ba622d0d0b8a07a27de146a3a991676afe5cc749b758e8feee3ac90bc65b4fc131a0536968ec7be15837fb821a418078f2fce82366e905bab41160eb8b306a7a4f44ca381b6e88774471143721e305f5717af32c24e329a18fa642a1b0bb4f990ba21f2722cb4d62f1fe03564dd3b645c89e601ce4d35e2fdad211dba968dc0bd37a648ab9c7b5741d81a4afb4aacb62fa1376f431b57d710e762fddd5661aad9363ee8009ff9bc9410fdcbdfd08f67ec1765006d034215ed903dad8fc02f8a09980807bb49da011ad29094c344c66ae80295d0201c3592ad0debb7608dec5b5786af13215b69be4356d3a84c04f3f2b3efa9fe1f6cbfb9cf03f6847e1ea2b453716c457e912fb383bcb030bce0d740706323d9bc39dec6541998fad10ee9d9827ec6852ed8c50a7f4d05ec5f1218d7b9c752ded6135169192bda85b43387dda7858f038b051384e1a6c7be30a51767e7c2827095b89060dc611af50435ead7258e2a239e2a680c99594189123a2fda5ab8c98ebe02cbcccf343749e7ef5e8c9eeb368c6b39a3bc3b23dcfca81750c781abd5d420bae6afcb2a98a84e3934a9da3b1c79fd62a1ef9471a5dcbd1bbdeb8d9545a8f044ca13e5db8b25bce4656880eddf86bd895c95653a705fb612ceb9c9b75f3483aa9bdcf0678e0b6f47b32cc9731531ed7fae3ca56dced03b98f2ecaea2de4517456bf511038e47be268ccdee3163ca0a5f8bc1957ea8eb01e8a05884215c434176271b3c1cfbec019788551fe8d714fa7ea59b9b2eeb74c12497413459dcae82b9bfe3e90666b8a9a2316e6df3ebd7f2b91f1dd64fd064d2d4dedab3d21ac988629dce614cd6852305102a10b6664f645925e6d521c41565452f4f77f264f109b403e52c16c056f31e700347fa11aa5fbe30155b96ea5b5547211ddd1efe757936a41758b6ab7fe21420afef98e3af22c969fe0f2546d55792f9511b9e65a74930078e45c181c0e4e69221184d626bfff0e3d7d918b0974ec095094983c80eab30bbd6561097557c10a3e79664982d5d54a88eebe276e2dbdc88d7fabc2127757536dccbc70681644b35c02010ec7517d93cbabe5f76c88dfdb0890786ad1646b3597da5f21a340edefabdb346abadec63a5559c478cbd77d873cf60e6b2425d4b18cbff7562064e844a65798c73872fb8eef7f523c276e9ea16b116a7aff5cb74b4122cafd06fe7bc629bfb2a81d2f4f8e6a21b691b03af783fbe3e4205d86d72596d2fc9a7eda93e8eeae0f025d53f2d1a8f521d853dc349d923896ba2d5a7d75db9894cb5bafaed61066ba365e5fd191d3004ede118af877fb3250f2507d48aadabd53f06a8a551fa042026fab8cbf7a884a93d86f2449fb1491b9fbcccb0cadecad10ae05ba9ce1724c11b6b10ed40ab743036c8149fc2cc824cb914a4c6d2206d4219cc2edaeeb4a64eaec9636321870509de07977dc393c19db7c4349e260747846ec36547b82982fa17942441ccca7911eb137ae4b446c6460f270524d872c4fb22b5215b2acafdd5e936dbbcc56cf082b2dfd8a362103160944dd67dcb8104c41fe0d9e273ab1320ef1f1054b69fa52e1d83d8e7b2b52bf84acb5d152ae65563404d711f6fbfeaaf48a382509cd82d9939bae2873f44915e48bf87d47d80477a380b3877411dd4a8f395c7bed4e9117e7a22c281f5762bc30b45aac27f748e10f87975c359c5c58f1d9dee5656eda5a79dd0560287ddcf031f312b3eb3da257149ef57174c581527590b8619619bb1e3e3c08460775b1cc2bb303a4db4cafb0ec3a95201bf5411f07615bd66cc1fcc882a18dc9b71457ec2578bf8cadb86222551c1636346b2bce2338731a15fbe745cebb8dafd41affdff68c3ccdfa2931c359153bca7779d978b0c37eb7e1e4347519e976bb9106c250734d356d588bd9805f7dd79d14e0b52b4ed95e56d0c25fe41c23316de7b4fd3ef41c84aaada910ddc545bc648abbb862fa2f6c05f03885206ed0bad019c355623da3f5d8428e8999d9a889e70270e213a8ac0dde701ca42ddaf7d8bc43d055fe5a8bec875cee118791b375211ec3c8d21b019932aca5c45e7e407738fb17f9ea85ff706b477b232cdd74bef5a99589bd394e91ecccf158e62bb9a7dceaf5a7b8cb267b9c2aeefdce49933bb58e6382d50fcea542e7d9c0c0fea98af5f467306aed88fce0a10fdcc003e23466401fdd1e1b74abd465df398da066dcf1295e67a499170c3f19e4971ba30dd652d82f8200bb36b3adb1fa1b29acf5b2db015b8a4c7508a7d81ac5314a1841f842dfa1623ebfe333cf0e12ea0b4dce7d3e6de1114a588e391c472b6057717800e03addbdb2f6abcbbaf6811ae61c4b243ff70509f4e8ff7f7a37699162354d066c926aa8e66007d30875f0d61c687d6565fad02ff8834fee4233da858006a7a54a18fba64f2e10bc2e1c4c54cb937313816cc9f45f99c2c575c602140e4bb86b6775e9ced085595a4e0e328699bdf5a5ffdc19529c713751f75f3beb30a570898a7ea26db02d62fb780bdfc202a8fe03b96abefce78572195e10e877d9f83f0bdf2f07a20c22bdb1e45497b5405cefc85fd4bfe498bc0d4595c7f2d1630aa25668b073beca46a839bd5078e41ee371d173cfbb94d44b37db236c740c71fbdd479384299be078f1bc271d1b85118210a7a23c53e24c9f03212f275263665fdacb7a305379b330bc49bfd7b6fe8a371d24edc9c6ec4b13cbc3ead6786f5587ac899cc36e7267fc27590d9b3b8930ed6bec86c02e9df2b0a152f9c2c5dc6f27b368520bbf29bec4f3f76ef692c22c520079aaee6f26c1238f4ff41091993ed2e0e8786069629864c4ed004140e00ff6db7bfffc574be3feb7ba325e0777597aa595af428c3933f3428cfd0a64ae6f62831061f2930a2f098814e2ef1aa4693c98ce5ecb0ec4c745fb2df513482b1be1c53b107d76aeade0f613015144abb4fe4bb7396316b14a79d0b901e43bd0f75ac0930e126f075bf12d94633272fc4b3755da72a650e176dab6b78a57901fece178c6cfe9da4dc5d1b0a395f0565b1421ebf992ef6722ccd30d92f5ea1b06d59b26552018378a28c0d8a309fa4fb42ad7226af087daa009d3e0d40468b7fc265a2592c4621d9b7b1258d81c6be1699e15876f4d47db97d11c1002c21c22f174bff9d905b3dce70e6d199034c46ce680a9d02708b562866353e6ed7a7ccfef6f5698b636e2def0d88957fb608eb56113e34c70464bc71ed3a2ea94c2d641b5ff5ac4fcd60b4a2a09d8c77bc064169b872088591926b09f614c3649b1b2423cfe7e17a9844fe5009bfba25970db7aaeb324472fbacb6278c5f32becd8f268ac91cf79695fce4d196aba9cc8481e37fea6501efae08d95f686f219ae4740b073a0295edec5422fadda6cca31adc5ca910fc12aeb84da98521a5d594175bc788dff985e67c1ed1ff0ce2ea8717594e0288e42034a38cf37550b54bced0c6bb73e42d59617bf0b53b24bca7e95b3acb829bbce18e6fd490fb5a1bcfe43ce57e917cfa1aa5baff06b09ddeec9c49a734099716a97410606daefa4159b44d2e07cff716b8e0ea9d8e1a098868a7a04b944a09c789cb10a53a945dc6e1d92b50d6d1f76163a79bbbdb207194188e42e241e55f8541b00f2d64f5651838120228d3405fa4e3ed6a49f4492c241c190eaa0e86ebb3fe62b9c3cb218e734a745765b900a99b831dccdcb45e689c46d2f3ba542b88b1ca1631b0d6434cd8a4e532d8b7fa4b685273f1ca36c21a76bc03ad4b3aba1985598983135d4e44fc4d0a704c5e257c5d4f406666129acb7196789fc7869e6678aaea2b1ffdac54e1c1f3932eb0307d0f8c4ad0e319627c5014decb9a1ae5b9ac725970b0c463250758e7b9d4d20c2354eb77c2f04e4dfb61b1c83ef6c68319983481a0451df611a795d7793dd47cb1c091f93ba4ed992a764d92e7fdefd976e345b7ed34141b561824cb02ee54288dd00835b299cd238e2a101d708b0f05306960bfbe328f4eba9a186b35ab3cbd7d69116124dde47639b6c4ebafe0208ad7dbc9e829c3b8fff83afa1524074628b938026b16c0a46084df82432ae24a80ce71c6f1ce8051e614dfdbbda09e0fa64a2dea632bed657660e9fafba2fcff6b061f3dcef237850d652344278fc86329241b585106f12810b9769df443a788d938fe3a9def895fdb0b7763c224d416c68a115b9edd12980c517f500e39841d2a7126d5b9f62cc3b97d986a7c7315fc53f4d8e771fe4a11706a2e7ac7fa436dfcac1452af6ee7ab951d3cb959f8e2e7dc785bf3699a65cae32a1b29e01f8889622d52a275b99bfc960421c991c53979c9bddea0f33a87e029a8a621666d14fee54f7cc62d0428ddaac707be6b80a5cb8c5f3ec5bfb36851516eee81ae405e93816f4cabbaf00b26a977f239ea24e9b6e5f6d56bc65d9aa9346cc81449f8c60cad884bd514c1872bc292285b8c28a66c60f31c6ddb8eae22e5a33302cd65d0d87ebf5d08bb50a43f3c4b04871b621f567096b11617fce38081425f7a3aacc2929e5257ebf8761bed1c8dd1da6dead5293f2a3e78d27173a8cb8155d2fbd941b22a1b10e265d343c7a712cbfd468958a96459d4b5d3e32b087cc43717dd2748fee5d95c1e33eea00ae6ee2cda64e420e5925230781ba799530728e4d361963746b9491cd4127395073a85560a9e91108b2440ae67c02f183fd6e08369eed96b47fd622450611a6a4c1cdfe8cbbf7e63263f599fd599b141dc5e6426cd3b76161ff10a0113dbb1e4ad2016925a9c4a8a82159c19b1b02d08bdeca2a54d17199c0bbd0a93502c57818fef3341ce16ea6191271d8f05ba1af5a39a6390744813f675e5e2703d041aafbc59adf12ddca1f65a7c3df09d704f4ae469e41b574e2bc2972790e890856b8128b6ff7914e2e16acc85bc4950091c3cb9a40ad431ff9758f766647586ed8cef6d4cc9d51de168554723846695411706c8c2c4d507bfc3da24b019db3f8dd3e88d260ae0c3c14867cbda0e239d9610ecb0ba0ae4ad26c39131a3e75cb3e04af2d363919f61f4cc022a46d4c287bacb9e0fff7853b5bde81206810336a31b274d489b61a61ae4285d6d03c84a31a8d97acb2a3b1d3d728e14deb3c9b57cfbc37300d234053a35127268b9738e9d7bf76f68d29c651dfd391c3b70caddd144012ff6cf77a46435102a7515ac1476b6eccd482ff8f32f601fea4c16a2010bd9bd948c2c700fae1a85c80959150913b0a52a0d988d2d3f898d813a45de7bcb592db3e381ffeb62fcb600f0976967293fb18573c5e018f9463d5adbf9438109d1606bfe6f643f5eafacfddd79624103fdbf729cd22ada59c02feeb74e846b55829ccfe289f2e16842b200357dcbaaa295720b62d8022ae787db69a528585462a5a9d92e67d4e5f5b1918c1fe9a29b34e25defc73cea3afb47202c6881e9933a87c881a6cbfaa0011879603d60d026211a5bd7572efd776e8d652ae1bb763e8e9da048a2aeac372e25d22d33d940131a3d5c2784df90909fb3f5a5e24ca5b25dc2e3b35f18f201c10449256206324ffe7d2b2522e6f0e6b6678c7acb89453d507bf0102c298a8cae7aaeba7f6b4e6192a1b51bfd01dd7e57b66901aff194a6d5bf71e84931184c572c8e50fc9920d54d037956dc75efe5b87b2e6d20cb0b188473e672060efd325b3cb74ccb13e4d7df28f1dbb3ed6d8f83e386b643d8cae0c403e2c1b544bbff421fa777b4f706173e058086dadacc5cadae7c0fa8f632bd3fe482e202e57362e147a4ab492a0aed240309f16bc739f4dd040029c91548ff79e48e3258cd95104d0772c52254ae2d5eccb1aa97633a94b529201e7cabb9a258f4a2ac9ecce2be0bf3e3273414c81baf192cc0677bb397e8931eaca8efd55cb3ceb30cd4532dc0024383b8a703661062e52e1a347119a6458aa94be1291dd60107893a75d5ad1e506047c2e0d52a4d76272f596c53a2e1839a7e6d2d1833818e869122bf4bd9e381b4b6e69e363f5115ebc37810087768783455bf18d7fcedb43859b827ef78bad2c64b516ea4a3e21bd1ab4e3de1495314ca6b5e3d629ee609a743f9efe6b99f6b18f82bfc4cf2e3caa814311ccc1a9dfcaaaa23a2f3c9a88879adaf41012e0d587382efb69582d0291f92c126e8f620649a7d617e80b634e1e63506f03264cbb44bc5bbbc606d3798c1e0f28c439fc0a38237129aaf4cd1b6add3316b9cb0cfdd8d3659578fca28ba01855587f7fa0f7d80657995c14d073285946ee4fe26659b88298e99395e053623bf9f42663c043037703e6c8ed10e929c078f8c3bb96d508b1b629fbfb4a539760f229ca45f245b55662c60b74d3f7160886a8637e27313a505590625443bb77d72b94e48882277f0c2ce9f17a083992eac36972fce821f3613d59a536eed92b862f33499c0119088013bb73f5bec3c61655a42ff846185e550d65b79c4fa0d516d6f23818e19a46e55894410c191dd3aa39ee22422ad227130c8b0dc2a7a644a4f2a96a8640c58019813a16050059d63953aaa737ace01a66c63df6a8e1fc99ab57046bfeecca83e90dadc1099779a55d094edc9b530c0cc81a046a4efd371a315a74adc58a5c7bb7792ae88a32e60cc2c549960b2f76236e68b77c3d178aee1db1288b4c96510041e22b6d1648551981d86bfbde5eb440f2667ab1040a095932c494928ec240b61a3c728d609d4e29faa83911d6604cc2a9086eaff997610ad1faa4090898c0b7abd8ad763c04d55ddbb003e2dc2986230b0eaeee0204414e1a54dad777675349d0cf5fecd304a56d93a33585cdc9666d5a67b9351a4613cfea4469d075f8d2242588d928658ff20248b5c0053972c7d1bb41b40aa23bc588c93592adb890e5115887500b54f00fa3da19a35f9e6c0e34350a336327fa34581c4a9c3825bac6e477408826980cb123c57d6cb75419890d31b1be8d7c246bcb9fca78e04ad6a34a83857f54327b0db928751a294023f4eb35be143457ff22e0c34c557ce72e291886f3bbda6df7e392798ad16735a2646e121222fb369c387bf3b08e68719e4e3a279caa8280fac78591a3311714361457b1e31bd55ccc65b4fd0a4d96f539cf45c64415995fcaf28c8aee0154b9a7f7b42da3c96019342290eb4ba7f30e9aad2a8abf18d77ab0e349e4b871dd40554d7156e9319c672182e7d58f65f181f6e021e0975fc811e1221a9258ded1d2630284c956324ee7475bc7602055a873dcfa67f01eb2ad59b62f3b9faf957f4184c26b80e34c974e93f60884af5203de1e883f3b29b71a687bf907bb4964cd2b2fc7e209643c9e4bcc4da6c60699a93cf1099c1c1d968a694572b2ad1a6ae1c96d4a4ab0865e736ee2f098332fff96cb7434ab628fd400ef0bd511538234404a88b36e354a044de7e7f28c6d361da3f2d794317f7fcf4d9f2675567e0263d934440e73679a8d392a99ae7284b02fbec501cfbca38c5a5deeb5254d3c3d71a8434a691ef6cecc3ded40affb0503b96ce8369b6b5c48895b162f4cce19645e4c6af9c1ae632e71aebd9ff6b636528eeaf518d51120e9b5a3e1bd30b23ade1021eb2a380c3ea69fcec0ad75738b32787e0764e889e28b0c4843be5ab3af3ceef39aa99131b7c6752e89ea3904e125b2a50fe91dc81fd8774fb5470ca46a4058343334e5c3e4bad9a5f76ce29f921976af2e0a66f7d8702ef195c103fd1c344bebc2917b53a2acb33ef4b8cdd8b4fc2cc23f621c309e2f7f180aaf8e316d002250146432cff9f02db8ecebd06fc74bbbd4d30a87cde9ca1b2f4ead771bef09b4cf3f976ab0f1b912567ef799bc4ed9e089941be7d23477f8f8c40c5825c62eb88759bd5b949b8dfba29f6e8fc92bec5e09a2f74ed00eb5f6ad948bbf52c80d946c0786a7c03b8cc88aa91384395a38764b08f19f02d6016310f392014247044cabc7f288d01145fe763b9cc3685d8d4a161310693504a46c1d2dd3220f7a212bb4e38e17735f224dd5f3872358989a6950247450add7b5f0b1b4d40739e8bbe0c986f719c4daa7169fbf29dc83e243a7d2d19c8c89e75ef3e56b92311599d96244b01424790ab1be2609b193d859ce2374a78f08bc5b824dadb12e31381330bf56074d956dcd2755f27f024a28b474e20c76bd84a92b73762d387681186b72c0f1c3f99c75e0f2d14be52374facc9d2cb0c3b474df07db0d494ebf6e30ff2fde8478923d60ae442b1a904206109d3a04df23f7b639fbcff0cac38e95227929f4e661a40b71d259924e873d011e0c618c1216df355e3c1a5d7467ea03fd73652986b6f124e6ea513350e67837a971109932bd1939e927a161e8fced31675e898af437b58923dad4957067b538e5125504fb9304006791ca7671a7aa4a57dbe16947e249ec8641a3424cdb8bef55a4a7cf87d21592bb891da5e626163c1ccafe93f55a9c4a9363b340fa4b2ea000b30844165da33fb40f331d01171fe9da227f14d771c1791d79a747533b0d81d6b2e4804db3369ae4a051fdd94abaecdd307d79589f908ca50f03fab6b246144e3ca57e96bf27beb4c57af0ce83e33755a348ea82d515f94bf144b9d7aedfebda67728e7e1831403f06c57502ff47b68bcbd92e4be17dc91ead006dfc8f54019bbd203d7f9fa9a4da2a60a9771461faca3e9eb99e7b4342dcafd8251c681139c8111664119b2edf5cc66a4a39ae02faa285433a8e16875538f20350ef6b6ffe2943ff66d8d75ef6fd84e104983f3913eb56a823cffa8b2fd8c57e4105e43e0f1fbcf55570f1b7f671b033ac44578a7faec96231a4080a89a5608a1d2eeb805dc3e99b214ffcfc05ce6d5c994c524369dad5a93884d95296c467ab8dab57e91699543dd3bb1775eea7074089d33deb476b3e8e225492dd2f18c0e9e31a03ad5596f5c4eb28831dff19918f17adad0c344527432f3969a2ba3c5d56cc22f76433ca91164c71b0784bcab50a1efc16af13278a59e79f3c2fb8e4ca5574747993dea4b8cd7fcb97a98c8b635ca1073a6a4da577f75841f2fb0ce10f7cd3efb5a6a3504858377a888d3f340c2466bee87c06d57481655f6be8a3ed46ff647c7c2b137f93599436efdfdf0a10827ad16e4179b862a4249323f6165b65f8b65ca86c9e3040f64d71bbf39034bab4ab07e6ba22fa0e67b0224a56ce2b63fc3da3cef6016f2d70794d7a9c2cac7324f2b9f05ab6b08bbc776e369bc02c61755150b71643183687d11b67202ea0fc01a49485aaf1fe8bee8770e983711ae9db670304de7e82e640c7c689a215b60849ce34fcdc29e4112f375fc9a2c68006383b730ee08488985969321b6ee892d03484c871fc39545fcdec991582d31797766216a323cf937184c7bfd2d51aa33beda9c7f87a74784077841f259b5138e53d48a3d864edc882f90f1413813fcd9a19a1727a28094b63ee2cb13b8568c87ec80a8b0838a6da8964b82e8fecca8484b17a5ef619433101cdd1a69ea64479a58f1614fbc21d9e9e457df16ed75519f1cd7682fd2e17df07ec0d88442f45ece8d2295173a3f14b384a4bcb2a872ddc82b6db7367d8e4d082c03063fc67af0eb970ceef13f4370cb0c239a080c89f724079e050f49173afe634fe869b27ac987abeabd1bbc19a3b3d7ece1842842a549e15db627b1ef31504feb74f1f65583c1afe02b2e3c4c2c912bb24daa98ceb1faa8a966bef1cdf5f3109a397b2fd289585765dab1f44075a337d34495fa1ebc709a5bd3d23d9604082c04cb3517e07f88f7effe8c0e7d3ae70c62e2e8e601299e206c530f950ce62f48917707456ab3905b65a7f49c9a2fd8c71755a87ca1bfe354e0890c3d2d99b54ab7f03601f387620dca21c5b7f40cc6f36ba823cf275137ca4f3e1d86ffdfce08ee0d7d29c6157bb085e1d0959c2a15db48a05a1c8bc3f45f694d0a2c3cf311c68bf10d9d8213d94d0e44bab5486c22f05bbc76eb5143655f6358dca558381400657890907115ae1cf374597dd33d67e8725afd5e75986a7db4fbfd6f1aeb7828452d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
