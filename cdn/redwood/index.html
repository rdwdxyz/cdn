<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26e94c31bdf8c385025538bb07269b193123f84a200d9a476054f58119924b137d213e693df46e81e44d344d221652cd2f2fe767133fbed4319b6840a77544806ab1699a74b62bf801a9c624ea46f10fef6db7abb6f5472abd58e1430ca28181ac0fe36722a60730a9bae32dc50f1873b49cc89698f9839bcee6ded14a265fd5fc1cb70c78b766541e07e7c4870aa287ee3ccc6aad010015f552038f6602e4f80086205a34e9b60a9e0fcf9dbc4d9d6dca845dde1f7105e5220ad6dd7d67930f2564e97620ae3699b14ee11c292e003e5c55998a0bab79652a2acd004f5ac538580b941c6dc139ee87714c0f5b17b27a149f932d3910833f00762afef016d69b9e9e10aa8daf1a2f1a1b7d88ce362ddc12cfbd93c19646642bc223ef7741eb2d3ad56b5b232ab3c7a45cd19de0916ad4ddac309761de194dac2e32802e3b992e08bf788277d38f86b6cd6a4fdfa53395c64ebca02805191930f719c6c3ae98b83d897d7b5a851e0f43fdb5a3ec649c41b91480f9ac5c30260257cb8e1576baf07d711c7b248fd2094dde13a77fe1624ad28e906b53b1fbda85f99f473c47e2ea54a507dddd816ce092b1ca77f47439d66b73b9e14f7b8e8c825aedf9b616036662317822f71c6e76020918eb7617ebee494f7a623815c696f013aa1b78925c7968c06629ba8946bdcea713977b59f0037db75822f85cb874adad7794212e4df4b2bc63b0077dcb3fbfefb87a5c0521fab0635956ac2430d9b78cb499702a9d38280b887eeecfb2204f7053d88b59bdc1591f9e4c0cde1648159570c05c6770a2b9916aa65f51720a9b6de43c8082ca7c02380bae61dc6635b9858b885d08ee7ea35d2a2d61584a4c9922251dbfa661c04ca920158bbd9bdf0752652d8a06f0ff8b48ae4078e3bf4819b42d32d3943ba12cba01cfc74e9e9ed89e620179ce3aff65badf222c4babea25eb8d48412d1c58004eb1c3a2d2b7d082831ed7c6740ddd323fc6f3986b6b2220a2a500b24335e1c0f50aae86c22562215c1907738eabe56a09ef9ad8e2ef519f3ded8a60df56841b981f8c4e2b5e6e5f0d548bd7e22d8f2958a5b5ef4f2705042cfa50c55eaa33b61f8bf89ef2ec8a02e1f92572d53036416c8011e7e37f6b612f541ea3213794481d8db44ca51b25f608b04a41fb61da8feef5a8ba8fb8b9f848ed3c6b36d6018ca0d99582abd38a77ce7b6f370a43e2c81f5f78efd01e1536ddc557393993ffd1d4cb18b3180aff4bb4b0a48511c1a20c7bef4003cbd426023a6b10566a87f34bf4077870e95b7fc56542a1d8582957570f9eae86b005187b399e5f7db5969b7ad0a74b9ac686d475b67d3e2adeebec564da42f5ca99ba565091fb353abde315cf47b8f1154a4570097058eef88dbd70a3a492df0110644a9bd68efc0c0214b5b687e580c4fe5eb705dc34ed19306f239ea38993b3f06de8c750ceb9bb510dafc23c5a934c6509ca5c9b692d351e278853d77defba0d69687b5c4990b5462e6609da442cb9bcf4f8cf485a888288b3c1fc8db53690068e03e9a7b862692799e8957c8efd6cbb5474a7248aea84b43e757f19d2d8601b3f208fc1c2da442be87678333c8401130149d421060a4b263398a5d898e9709037e322933ab41c3aa091bf25c16246f6031272f72e2a8778b35c82f0fbe307851c419d7653f9d85e33cbdb2f5ae950a5053f5225b75550f9211a41030a888a058ff4098bc46fad29a64304360fef07cf953976799eeaea89040ee71d13e0c5bfdfada98d535adaa30c646d0af255f37632273064efd8458a896b4bd827f40968076bd6f774ec39dec51cac6e4a408d88d36f354925c366533fb7f8ef71a4266e2f43b8375afecb0adf591bd27c5a89406dabb155986e0ad37a9f5ce487f1b3315adddaeafffda1f8731c46e6a50697764e1c5ce31535db2a795745ebd8ef45db468a3ac254375db6c4669c93ce3d6495cf893870e6ac324951db8989a8fd8c5d8301d49eae53755461525dbd7bf21261b0d2f7ade276d6dde0697331e346186e0d11b1e51ac1e8d76083b981c48581a294b3163d235dd1d6cdab64d1076e13c4ae9fa264b0aa4beb14ac821f4539fee71057b06826d4c3ef8e170ba890610677259fce460556c8283fd400de2a09c2530a73d4a12c843c4535f629df15e06bb11126036bf881a7e7188569736b0f807fbccef5240f4be1b132f57bc2bd7c7b60a6ac4a311114f1364b5bdbe8fb047772f434745d3fbf41515adf055300644825b3df81c0aa2b4b0bf661942f05ee8b02d900e6fc6d838a14209370cf608a3ccd2b8bfd7a971a03e83ba4c91d5cc44c7351ec947e15151489423b63068b58cbd7ea827a05c8b91b2d63ad170c24c7e6eaf1d58cd0b15cc9b53c4390a97610b4281a6090a0234e7868179b8da069c4683bdfc72acef3bb68bd75b780d9e9f1200de234938d4257f7610ded795249f08a6981cd6515a15c98d09674b4e8ef564c480bfbf7cee1b422a39303a36c4d76d3f9f5c290af27f402a6a82870f464acf1324449f0f49859e09998ce43a107d3fc1d17ceaf4eeef21fc925546170c7fe41159e077acf7fbcfe60830fb9ac5e2bdd7eec0f3bdc2bf0b7dd3a3fb084e28158e8c973020075843699a7fc609fecf3b5431f32ad91233eeb3dcdf00ddfe3156bde0acf8192175e7c58800fb42e251d0d565e2175c40aa2ec6f34f35e0420589b2ff4de257ffac5adc7c4c7cbc811f49b914d0d2cbe0f8597fd25995be41ac8d431ee65adefdd524174526172de59ca2595c8a18bb9a7d8ef618e4d684c5e54f496d451a304b01cad0509cf93b0ac56cdb011ddea4a18056c27dfcc99e9e457301818999749c0174b90fa1ba3c9bb1fd91580582eb0ef47af1835779116890fb0c778c3268b223dd477c8e26c52f4be5b8e197030e863d57cdf2a19c886c031e8b80d6610dcbb0120d5525b48707170af2ca386f9dbb8828b140fc61ef90bbde9d0c62a2316118c3dfa9000472291e2e997f8160f1b221ad2d69f8c6a83b8b88345fd1d137d9f555a63f52d408a56a7d645c5337f0fefad249ea08464a41b8c8c390e18b8cdb712bd96d2b93ea7e88b0c49fd4320b03f2fd81d9fccc91c8302fb46d23b68333e2b2f5b9c48f0a7e400cdda5d4b211a145d7385b4710a2398a76a8023594a787f47b81d23774b4f6b1626900957223a68644f99ff3d9575a163d82a3dac16946d2592f25d222a959e6c7b261a25bd0d5a3dec746feb6e4fd8f98f88f2fb5f45de7f0510a287dc62bf504b1ca80aa77b7c27bd25125a4f9aea6ce8fb6af16e361a0a7cc961d0e15c63fa2ee834cff55e1c48dbd9c90007cbd915a6a2fefadace032e2e420f779f283afd6c0f5da9a32c5cf4f9d80fee798b9841369c77dd3cddcc12c07a5007e172884d7e4f1c4c4da145dd0e9e2eaeeae836d08c341031d3ebd871462b133b0c28b45e5709c335d91f97bf65851dbfb55ca6cb076c12ae30edf2939b14ab405152294a4f277ee6b86e1b40ef8b7cda73b40d801a1028e7f85603094ff1699507a21060f43ed2b6f2ba1b10a2b442ce87d6a29e6dc1d04703aeda5139127b0e45952e43783424c19716ec351893643f602e03814912a6e11e44f1d20614efc3004c67d43835b3fee07c4ee410074376225566ec9e6e3d761a894150d24de5525961f1e35f96f3a913e93902ac29cd3a2d8a1d13057128f1b0f06ee6f07cf9431c663848dae4868095414ecc638587d1edd1f4c95c9e56626904c19590ee9f8af18957994670f4d84db9b9f984f86bd9ceb2125a8cab3d9c80a7455b6102119cbd5dfc4425720ca72ff41994eea44a3cf0ead8dabe7494338589c29b5388b8762812a1bd629f80436e2427b9a0b428915097e55321d6a89cfa5556ac20b8e228a396be9d5f5c390cf115a335bdae5885c587fd27922f86824740526c1584eca4093abb50bfebed69472790813cf2eee7c853c1c8aebe495e507410747c9e5c83bdc5936dca2cb9d50279ee523115502edf13080217bb921891c7495186fef20f3e4d9e13705bf135b3cc8a2edeee41e800aeb65eb2ca569f785a129e51f84f1dd42b678a8597c6a1e5506caaa0a43e1b83c88670474175edc613cd747760c0c453b4dc247512dfc8c015f7f6a559a8cd2b4bdb6ce6d8a12a0e0264bf58694fd663c730a3e115c3875a80ddd6a49c8572e0982da4a03cc1cf6aed536b550fb53a9de17ed240ee158553d3200164f973250dd6ad6c3fcfd15683a775f5938f3f6f7503430d7d6e395f25ec63ef152ecfff66c9a2bc8947bc72b8842ce7aa590b48d44b2e109da389ea38d7f62d7c5f51a1361bebe3dce056bdba3dee2a42cf6019f44966a6bbbae2f48d1d00d18ac061767ac5fa0f8326f5077b760f649be8a986a2670cc06f8df911c64ef3d6e64b76a53ae3d1d8e237a3540fb039a30a1f6b47a8f066c836355831abe02279daf0a4097b1a8c84b7bcb2ae87c6bb21cb3eb2351c929e1915874be56a2748c3173e4a12284a5196e97306869cfd5f7a7cb47a9111ae1ae334fb01b55efa4c6df62c059eb6de0edf94d515b4e719c569c764a2f295a279a047e732da7fba5f6f195028fe2cc9ac3e949bd53d1d8e93398e976c8724ce08fe37982b1d659db922b98ccfa835fd25b282022031e48f196e08a639bbbda772b703526a410710efd99f6fce33b3f247773adc1512703cd71e044ce9404a0b73827b0421c0015087c81a43b89eeda4da491f7311cbffdb42e8eb49f2f4f63d611aa70349af04195d409a103f6c4ede476eefcebc20c002253cf837398d76f2d4fcb98477fe8ff7d3336ca9f3f85c860ed4561f8fcbfe0abd8ea7239e44326a233b5ef5d96580a65482ce7b28ba1097a9e6c2ff21d8f71646f8434e840d5f0600c7986fbab46292df985750ef2ad0fc5d6433f521c85066ed82b3f40a266a12d188135bda5be030216906aa5c75d893e1df84442a8b13d966bf2e8d59f77bb858ac704f8c80e03173748629f6ddddc961969ffbdb7b8e05656572490446e479a76e8b135e62467c847c1a015ab4945f46a39594847358549149fa5ddf2e471717cb6ef11b8faa715a2fc609f65065486c808a79ce5832e30c8612e8ef362b9367df3d63988c17a00767d3e06144ced315610cce95bcede8742c35eb68d00cc150aa70c50e63a45e6ce803ee3a2f2d12181179553fa6452e47a4b55890691ab5a3fa3a568835a93d3b847074aaa028ed3a737eb1ceb2a539cc276aecd12c0824019fcb571117f61769601dfb9ea592adb6ca2b065339fd4c88c786fc331c6519051f65312b03b3072b4bf7532a035fe4e58934380087c80280267f66f1696b630d81a5d369ce314c5b61cc47729a8442f94f51926dfcc3161bcfd62c5ccfdc06c7acc81cfaf54796fdceb749ccb5e78e7488552e4df4d5898c37abce23647451f74d2646d858987b84a71cb041a235292da8b01297bf3239590bd8ccb8a890ed62a27c09f6606824e46db8d3be471f691168c2d6fa6dc2cbf465c6bbf069160b495cfcd79a3e6c593cdb84e3704486eede7b816cd0dc2ed1ff43f4719592a2dd401b8f6dca7f3c31436327ceae355ec233d43ca8d5243035e6a4ac55b5ad8e6171c085572e44522c44d16e59c0a3d6546b590574dbc2e198e56cedbfd6a5af41ebdb9b5d096b495574aa8f8525f87691b97af679ce258b7e16ff73fa8641930950a26ce87b205230200994ce256f754ebdc0721d9f98ad21bbadaeeec27ece762505c182f4839886ee2a75dda2c210cc7f0077eeb63fd5d6d15ca8eb12917cf8b80f0e4377c405259de33fc4aef711d3d254269d93d6724b4306202d5a811103ef3dfcb362b067b322e015a1503401e6a9e7ec23ec80c8121c307eda7f45cd964a0eeb19873dbb335d1f6f99078fab48856d97434920a6cd0dafd906973dc6186cb3dcd93e74a80bd639b67253c0c223848c5e962d657371cc8f1487d6658d849f53e78db6abc007b9e273ad9f62e54a36f4a27c3bad364233d3ad4bd994c2422d55997c8bea85ff386379e0f4bc0b223a5cd692f48d4c3d16c6292488438128e0ec8bc5a9e9a0c84f87397879dbb4d8b876480ce99fb650c9594afbe0207762e4204e568c920544ed4252c789fb35caa3f1c91e8eaa16b1482ea3fe8b647540655c230f2aa957235eccc7b5bee2317b5c4b298cd98b6d6db9555de23a44d16349862ec6262cef12930d1762dc3fa87c79fb6f913e02c1980758c7d33ea5caec7ab62f0389364fa102f904e1a413fc0bab29b8e402918e1eb693676758aa42d7ba829f50512b7f1b43959a2582c425b2ab9a5f90dca8452ffd70652a6c727c39d6dc606439cebda82459e245446993c9ee30cab1f7801d6cfab12f4fdb7fba48aa1916c17565e0673fab362656751d091a1534de262cb0461c3f4b9d77e962f3ae7c75a28d8bb399f00c76ef46b86e7b885efcaa8474adb97ebfc680838e742c4b2433c258c92e28bbea5d93864706ab4dc7ebe92bf749779d222de28ec2126af1df577256391d6d8724d7712495e44cbc59419397459983bb2d2fe2ce8770f78dc666f47ca91ddfbc6ce5df712d929114a7598e39626d298b5d9b563875e113515a0b7cfd3fd097884868065b39771684a5f60f15b21784c5d45ba48e3e9fa9da97535373c0fbb7a00127404a2a2cc775348b7864691e6fbaab68d753f316b8db9bd3cbed98167c253653747165c13c853a992c48b2c353db25ebe1ee64ff50ae58958046d8450db2c55a636057c524b754bf01b10ee56e627517dba1cf33b93c8f946f57b842cd2c3baf4880c7b29102e2dcc9d6b8d370512c6168a32671da00421aa8b8b9de392500899cf1fcbbd20d5be1189edb24d8b8590653a9e7b481cd03e3d2763381adc82229329703507625b5441c857834da6af71b44f8ccc597f41ec958352b2c3c10913e2eca56af1d0f6d4111d62668e0c3e0da41f0af113852d6cdec2614b0cd4c08230f8086596a4c2b8b75104beafc8bf2eb285840b96cc751f79a707b3d5b1dc719fa0fbf7b6f86810aadd0193868cfa29f350392c4aa1c0a55a610a12f45a3f71dacae02c31ee3dccf49d18526dc937b08894bdeeed8e2a24cc96b4ff094a42decea4f09d673e20a905a1bc7614a2af56dd49177c51884df13b13218a0707ced9e1ee4306f4c000dfd43c860d98b1fe1a08067da6bdae360164e90daa1c17a2f0aa248b7bee63c1271e57025f2112f514599700fdac1f844af14be4e0e3fba0b569cc76f1b8d4e8d48172fc74a4fdaf3f8722a3c293fce598b150a6d3eb575764e01ea81fe840e33d04da2efd7825dc83a3bf04b038a235d1f92fa9ca662cc4e79cc6e675a0fb0eb31a6531e7dec2f3c690f0ef9c3f56bf9af95e55024e270a10d6ae181bb4fa08119068e71db4f5b39915f62ff97cb9254e85ede39c82dfcd344af2af92f861f0a756a4e26b882f1c0ac1c16a4d9a51a915b9e33d23c162a21cd489a366206652c1a0e1fd5bf6145895449edebe37b0e6fd103919f2f4cfb00b92a8b3ef5f42552cbf92c9aaa4f26781a709e4f5add962634d0a27f151375ecc323200a79bb457ec6bb314c1e0a04ca0b076963b165d2130f978444601245e7a356e193a3f8251d3267a7ce39412a87eb1022896c2a1d74ce63048dba7e05e59614f7ff5315c21ed7b3e67c02765d03ad27dbcaa3c7a070065b4c573c333699730ab2bc754a9fb95cc7776990b215fa9287718379bdf88c5bad73d38be5575f6cb84606fe8e5a6ec0555369e6aa3a411d0f2d27d42298a202ac17fd6378a369f6fbf23efc7fde824e72dbaa6f09a91bee329f5bd7406e4cf60fb8efb92c42efae516a2c7e2ffc3968793b3df5e9428aaeddad864648d44e2578c227d2208d7aebe0b407c61dc053c2090a575ef03decd77952754b4a72023c6511a74751cf59ea1bc5a597dc6f912cdfd146d150f5d291adf9c4a9df1581148e8bf149d1b095732515411e13e12087fb68c3367f4e16238fc931cd1d322a2c279c11ce4433d4ac74eac70d9acabe84fa208dab868d51851ff7a79e604e29034f2550589a9229a3d1c1d95a7c2abf1ca6725d0e534f07d90bba6dbf7a6090bb7003cb4551243ae16fe972e0072b53c70c00c259e7a8c2054b4d046eec077aae348e2dde34cc385045eedda47c815ad70f973cfe79e8ae9e553cfd7442855dfb255c3a8cd4e664fb106b12cb1edf0130cde40741f2362c992b2bef8619f863eae62c5e439705fd7d52f4cd045ee296af9acd17622f2d9bab477760012398886a874171516441218877d9315da8917664b9ec81eed01a7af819f7b4f47da322d11e47162a071cf90c5b0688b4aa8e32d10f893b94fd184625a150b2d9327c2d07b1f5b749f1aafe8b3fe45506e8045eac787b4202255b53ffaea2c07cf44641bd4731dd382f328832dd25fab80be88edd2d14d9667a2f0715d4605cee8a324bc1ca9401c4be64107c4a0b4bfd72cdac833fedb8922c7bc7b4e4282e358b7c9894d902825a1629d6d6fe0ef34fd48d832ade1061aac92c4ef3e5c7629683118885094c36555f3bdef2b8218e939fa6ebec5d66853c4e3b9428dbd8fd2a9b686cf063e0611b971fbeafd84decaf1003a41c09d4e7c95856b81a94f7fa4525983be6220da74dec345332787ac3cc116e91dc751c67aded870141571b9f64a1e985ac25a44bdfb7840432562561ad5cf8f6f23edef1a36b4a4280b99c65d86cec44557f25952a8a51e66ac9e123abb7c5b46adc5c5ee5d93ede8933d7e0947462810a0eafc226bae74519cffe7e7e49f2b52b1376c0ab714eda73e3311b714e31a8d91a83366f1c595fe2079c8474b83179d641f8fc2e1fb49da60b58951dccc3b0a343879fbedcbecab55636956a8e732db56e0c4ee7955d9279093c48c82bf2ea3afad6ebacb5415ff2f1b7af3b7d091a810906d6ac3c0acdb1c2ed06a39eadd7fb20cb343150c5891712af43a0d16ae1629cf0c2e22b31758fade80bc846a5ac5c2328ff490b0f8ea35ae45168e0e9005dbf318cfc949ae82e591e6e8a7b9667c90a0e4e6068b59c68a2afdc8578088c111595a6a991e19e1e1868fac114ac2ad19624a9622daf7874abf2effd7715c40f4ad1aade1d588609d27dece74138d33fac21c38a20ba0ac50e0d0c32f5edbe4a28eaab56ee348c43a4fa9a7df320a0da2fd04fee63b5be65ce08a2e21f8528b182e54f206ca0ab4031b52ea5924441b811fcfd6620ab0af18b6e95f871908b03c84e277ac6e6250a24492e6aa4dab65c1652649b9e2d5af4430d2daa55d8c45c1582d1f13f62ac183ef9a2cabcc11f6f4f294f70e992da5a2be9ddeb40dfcef466a43ad9032c14c8b638ec09cd23d488cc20fa28f177d27fde8108fa54ae762811ab61029b427203a8ce15bf8d05cebd0cdd001c406045d01f25ed39d31c212f5706b5408d68d881ee5e37fab672c40efc595e0ab7e93bb07efa61b19f78710b441f1ec6569761b401982cbf48412dee5d4980abd5a0d16f84cdf0326e16eb4ca2f65390fe8707e869e0a84ecfeaab9d9468a2a25cbd29e2e8dd1aab9c51a70153d1d630ef5bfad12528523e2280fed3d5fac8f6d38edbee2fc13450cf75a0318619ec7dbd4735525d95e2832dc279adc787b40cd91376fccb38b1e565e5dadd3f3b3317873c85a06513f64bd71ade1d60a9e9e6e324c3704c744e18d66ac4a8b739deee9b426f4d1524ac8c09d9e37712ff18b19bb891c608df70c11160cd3f05208b109de4264a040bc1cfbb0f832cb703e74d6462677f66157b96108007983c10879df4b232cf7928022bcdef6f163b2660355345b9073d45687a6879238fd9b373cb2857e450a9170678c88051f834365a37cecedabc8340f0d24df410ad33afcdad35f1b067aea4938695a02c109b4e111e00673e84e1ca0da00d944239f612b9b4232613767d390a38eee554980971d5b7b755bc9bc88dbf8bf71771135b14d37fdbbd220c78ef2f4b034b6f6af2cc2c94ac2d065a70f71d9e083d90199dc667935d73705877dd00677eba46621f0d00fcdc77707736ca31937b8f954cb07e637b1eb05a6e00bc3f4bb7e41a505cdfd295c49d7913275f41f63e995130c0cd35313fe10fcc9bf549731c1f94ad1fecc1409f6144ab448ba224e445224ac7f94e32183969852fb694d23c0502b8d7cf85450062230414cec9e27b189a55342dec63713d2b9e07b49d86099b1d4d9727c2203c246aefb1bedf844a826e04489aba30e90d0fb710af5579e9c8171c68f0d220555f80864edf7957014a5ebecb39c19dcd16d67bccc65a0dce5727e00a1b80fe8c8385c619261a309523dce5e85b967e575e55da9c053607bdc6c5a99bb8d77f805972f08d04ff175c941a5ddcac0264b97651b1a14b9d7d96617c735d8ff023fb5f784c6b3f9eb0968ab684081f9c0b824bfd93ec8bda0a698df3d71bab6c9fb10966e76245f130ee76ff704533bf5216ab3c289b558a0c9080423ed91fbfe3477423c3680a63b44a0a26a54c3e38f6a6bafc8a501051b2ed20349bdbddee50f32da0dbfb31385b1d9af7177218b6e2653a5579f6489f9e3ea01c717c969226ea68a4c58a53c36e9e9af747f8e37c42931458661ec8f34576ee8d3e4166ef7d828cf4be7a7f2b6fb69dff8e51b61dca080ab4fe5373d8a426e0d4ad8bb979c1f2eaa85e6215c620d140243956085425411255cf0a5f7b4d81240b61c2befb2188b62553b28a21c61ad65c6ca7f108d556f4eb52e33b7c99de9de7717680b8fbb713cb691773535d62eddcdddddc8ca33aa53d6577c5a85fd397f760005940885b8ece6b652dd0f88753e1ddb4e75e65a7d6febfd95370bf714a553451b1efa2ffa9ae7dbe3663e7a148fc02a68881e5e043e17f53e94a6a9c564441a77e36950d32c2d5c03000ad11a79902bec5529962d3b3a1778a8a191ba2c0e41203526488a31947e305c89944bad5bb30a4f2454a4ac8e4622f09fed446279e16bf0340691114f61f37bc3fe25bfad100eb25dac846a4b9c41fa173ae9241c681278912cbabd2f3b3fd0fb6d8e361508c19a6d32d5666a6820e4ad862324b818a2f1d0b5d30c1ccb9e81a027b077ddc6f4501e667689aa8d024d13e045da57b83e3900275e7271d2525364943a1d8168db15412f41895ff1ef172122520f4cd09c6e58717a25ce23ca3811438b508af93073040fe0bf3ca44f654965c3589d39a39b40634c8f6b3df0d480a578877fe93d4ef371963560f5566d9f72ebb9cecd3575f45297ca80ebd647096c3cfbcfe0453442244c4219b9ab6528ef35b4e0c9f734c7bc34fd3c1895297136ccea2290c844a18783c966bd87008e3ed9e0d3cf0fa2bf2122ed29be9037e7baa6726377d168cf3532f5280df9df6aaf56bd43bb4e67af266ab985ed7ecf364b0bbd14b16222429125ab1fcf1c29753d6b3cf464569928628ba79b002080827f7895622d50b48740c30b0a0435aa18edf86d5f0a2ffa6bb46199e66033ed6836a311b22f8d2026365363fe29a3dc17f3f1cdd624b9631ed2079340209712e6ee7f64f2292839961095e5026f19a7534b6262e9cf94a9ec59be7ce19064ffba0281b38db4687b941f70193599480b263cd6056364b23e5300bf31a78dd7113b3403d583b2ac11641519966f2b1f67346ded5a61425c3abe4df35bbc16a4e8c97423f921bcd7be8e6c3595d8acf837271d2dc2da21dbca17b7835408918952d817c920127e3ff77e771aa29f853ae634a793d6fca3a579082cb627b7102dd58ff7adbf57491d40c9cd862af965fbe5c572ade00968d40931cf0dcfa01c7fbb6d6426a7286292ba235439608773fb672c1078cd268ef88e80de6b022ce69f701709f96585d621015e021f4861e0895d16d2188b5e9bed368dd1140cac701c82cf1470f15a0929320cbbe833d30c3557de69838504a8752e0d3f1e1b1840df85e57d4a1cf638cf9c5a09278d0a9840bd905f11ddf072b41beb42eb204f6a139e942a2ac1dc1f2bf14c6ec95847d793d4d4c0a963effa50d2039560a52d334b64d1a65d04ad066e48530b634f63fb4d6f6f1bbb42987c60e1f8a71093b94800d965776eb29c2a81144088180fb0679b49df3d6ae3cf2f90a53c29b03fa52bb22a882219c3e577409895423cade60c344dbec820afbcc014d045c3a9cd4252cbef33f4b8e935409c13177474a1fc42fcbdd92f1888896bf865942e74a1687f8c78e35b0ba60b03ef35ff43c8248c85cb3f6ce2585a8e16b51dc0d3b5ccb1b3eb035846f64dab3b26e2b703a811c51a283c5208cc0c8c56e7c1c21970e9e1512eeb19796393ebcf9314c11453a14e22169a1063efa72734c195f21585c04c488ff780ce5297d7c8c48e931d7868d5ec84233fb67d8bf4df737ef79ee9ae5551bc58cd01ee1dee2721caca9c3d0e8687ff0dfa805c9d973a5991256da230723d92aa450744df1d0b5b4eb4e76db0e9f7b2cfffbfd95fa07b73cc3fe83b4126672dccabaca502120bfaa70ae5eafd6e838bdd95352e65714170f062621f06e1fdc613ba9bcaad19094013dda5302c8a35b91390d0e184444aab865a20f663b81818ee9a30da149a910e104228207c562529ac9fc902d61c866f6ba031de009694c8d0e398eab751110d86df1d933c05a01f96a876f423fc15ed66a9c734e36fbcbca6a5faf9ab56629362f679a909268cf3aa27a4d8e43047ecaea3a7272b03d6d63ce878a518d7b9a316a8be1e4527519baafa38e1a3610975d42daafbf1ba80b383fd7e29dc69342d0b9e26024f7d0cd3b9d73e30e5f100953423ad1a60f73e853f8d8de1a7e7691cca3b118c80950002777efd0038b4e0f2764b0d0a5272fcb6be62b65468b7f93539617e7988054d207221173154fba583111baa989a7793f7fab8fd5b6fc592f83ebbd330d5a43ea60ac8d413a511390c440a1edbbdc749909c100b587dca98c949d5a90608e3b19764f48a6565ecc063e47c8f8d31b925dede9a7f88002418d34ea4fc0d8f5d272ff059fef6c9400dc4d2cfb5f1c06a10def35962b8cc62698629ac8a99b743f09ce4e70b94887d4a34658239e5dbe33b80330952c543fe97b0684a607faf0f6c56d6ad3508a0bb7fda9c476b364d75b15862c80b78a49b6b70ca715b2a097103dbd9c992c8b5ef9c0728545522e572d6d97b4e71af9151b523782eef173a3e496cb59bfd8eac0fe9a200e9aae769143c61f3eba690c9c8fc08b3bde7281afe62aadc13e2ba1ca90bebc2af6d8f31834e82e95437eb2286e9b8185a2e48637a4141d61d9240cb52ea31f0d5ff0fb65aa534a91e5803af226519c1e6154b848550e01bebf3e49158fdf0d12c5d77ba7f1d8cafe0b22f2169ded5449fcd34b903732d28ed3d747c2f7c1d4bca0eddb344bf6ff3e7dfc58a4ca39c614c6dc30b2a9138bd9ee72bb442a4cce202224c6854c8b65358dc49552dfd1d3db3cdc1425ef3f826ccf856ac0b5e70146585680fe7c106b598eb3c76474b9eaa590b9a0cb660edebb113da3e93265036c548444501166a464862033631a28b05e4d27956d931a379e57f16290dbe678b5eb7ffd70df2e8b34f3e9a633090d4d6fb79404434d172a29fd03c0ca31dbd9f8f6fb7b6f5bbe8337953a9ab2e60219ad129a3c5a37c1bc3b61f0e2c3e8cea0ec1889f4a697e04fb59b1ce87db856babae033697332341e46656911d49d0aa195ee521ee1e1be3902529ad3475e4fc87a31902d01992f9812826d9a319d3286aa489d9c206df02ea9d9809e91b17074e7ba0c110f1c85dec8aa71e7dc0bef236aab4c3469214014f3141c28a4c56604233befb298152499883dbadf8dafb850ed2eed2460a0cfd58414f7f3e0e0c13c96a7b6f61c53f5a63bd77285059be8e420793212c6f54ec31e4b6fdf83b644b38bf9586aea5d743312e7ee40b58d32e36b707daa8902be9e13cc731f1968ff8dbeb027e83c05e3285e0cd79e7ebd52f238f34731f8c1e769f16eb7a5541c27b7c982d1a0818dc2851465c532c6c5ee9d409ec8f335bc1db42b2ee4fc2061f10a325517099dfd810657e59f8527eb315af76ed1c51239a824538511ff0747d549784ebec41a879b0f498f925535051250db6cb13b507b2ca9c9e70bd6450b7334eb3a9f9c8eab5d5bd15880fb0020f03c695d0376145cf312d3687d3483f245a874595f379a251a8cfedc838a73ebaed9f475b09f5f9d93fcce8a33e5207b60d03fe6fd1429c4f218d345f828e371f5d7912f3fbc49b3e951e248138380e4f3ce7220056cad9f7739d1a8d818c2b985035ba0af6c203299a7a2c75147fdea6bb0acc89bf09cf98b2ca976094c77d5d6b99e171705828f9a65b1194fe0a82bf4ad5790e0e6d1ce42d5b7da9080930a81aa13c0d6f8c258edc4d64312dd6a9e4a5eaf3bde1f7b544e54d6d8e11105c1c630f9668bd19ac031c397f03436d7dcb62a5503583838637c0838e701b7ba4937ec619500a0344fa3bf10a104eb250b2819ac8eb431d6106c22b5bb08a239ff06cb3cd9d8a73d78f51f539e307d211320c313b0492ca2048d8e9b4056b8339f46cfbb4d1a6e305c268c8a19a33590fbab4b0e3c150ddb538f7eff721176d36788a7cf7e540e0735900ac8d0beac29f914fb169fd3aa3f630c134b77ee2ab7a662c967ddf2d7b1091779cfeed46243916ddcfc48e25ae8fe95db6d176f3242a446c56a3bcf543cb7cf141121bb2019b045818e27c626bbca6dd8273a84f273f1d0ebeff9633679faca34d8e72e041c6f521b2c3a585fafced53178be9746ea100f4bf138ede625c49d204e29fe046a792b3b1e03b636e97764efccbbf5db100cc9928533051c255adc4b737e243ec43eace6c2c448976762ecfd44df71a93a35e832cf48f5b088891ba7e68de138ec72ae7b6311f04e750dc7f50e259a85c2b960d2104c90fa7257b847d8f49b651e3e77b7780a016edeecb08387a1fe43e6dedf8f49d3b207e4796acdc68f292d614f160a969c15bc74bdd68882db437cd4e697e91518cafc606ba03c1a7e280b32dfe0423389c462460efa44d8fc51a3b28f2807f446c67ef3891c760e5f01d7a8c9394ad28f34161f80f08bd90d6893d31918cc415231bff4ffd29701e8573947f4810d6e2f49268282ad017d4e5d4e7d07c316aa6875fcbf92a9ddc5ac0abc5aa21ce4cce6e49f8908398a6ebc0262ad9c289a08ce77f1379a882cf8f7f88450dde832d7b7a8df561a4a4b5702de46eebe9f549f292eee3a81b5bec38b86b7be0b5ed28e2eac2032ffb9590c00263520ec6558180d006d3ba6fb172b7522fefa98938310444437100548abab54b647e580180ad925cc3250ad3f24cc867de264f8ecb27fd93e5ba0769c1825ba1250cb2b1613b89152a003bf7738230bb0340827ea0019bd61a4754e0614eeea660a439b573c54522bcb3dd20519f963c4d1ac14b968dc1c8530b85d8cbf0deb3add7e4e62260639429a60c1fe2c760507ec9810ab696a4861ed48de45d71284b970e228338a79478c81ed79755b7e3026d3ce5e29f37c072143b828a4541e334dd6e337edd93afe1719d65eafb21304cee429f5e15a27a7052c6828a963dd952b4d4a894a52ef587312ac947b3ac662cafd6beaab6ad2fa5fd23afd85751c119ebd82d345ca6889f9d0e9131f92b0287200af6816f27c089e14cbf86eb78f638b0cec26e245ec0bcbba2951121fa5d6178acdd60301dcf247278bfc4a043853a5e3503fb4ce9685285b7f540dc9aa17ac9f1c569978d1053e171bfe04697b1c908cd34815f50b6b3d68365c354b990c4cc52f96f603676b03e59e4955a0c42d9de279cd8988923ae23d6bc14ec781dacf7aed33bbd86263bf27b0966d7dc62c570968ee42ebfb66501ae058ec66d983d849681c97795831f8162e8885d927d6d3bb71e1b376ac1bbf01beaa381fce3b2ac83e20ba9d881c1139431e6839f92f0f3f724dcccf7e09a808e3515a33912f407aea71281eeefe6efa374ef02e9c746c0063d0edec1bd0e4a991cc26f7f1440867a3c3239f6ff646282262dcf3c34dcb25967006bd4931320501e4324c80d347e792b9bfd03b649b6b7c765b9696d983b43445cd6159dacb405730d39f092cd99831e9c9a2ed5ff0c8c1ee04a1813065471c27aff93274063f95a84ecd955104c5247294188982c7bde6d0ae3a74f1afc8f07c74c8bb5693a427c23f4229cc6678992c190af1584df659956f01756a003d3b6aa5d1b8ffab826975cea8fd7cad4fefb5e7b8e44ef26324fda54b3abe3cadc026398e6e4d185be6060179750fa26eef602203d0d7008369c57e2196d83aae50d1470040fc6d9bc620c9de5993fa87ca91b7e8cb91cbb9097ad7b27229970f6cc846f4c45eaf65a6ca77b2fa24d1736e38ffd3a1207af0ef8007d667fefd9ab04ebef1745cedc7b11ea3b995dd270a007a70b43d13b737b00b8b59d37e960bc9bc62a73acce6b66231956fcde5800ffbf4ce7fbd0ad88bd6b2d042aab94948fb633fb014408e72822cb721cfd9ee02c7b9603b862e61e8e179cd9f2bef141dc1dba418f6e1b200bf32521e69094182d6d9af36caa54e5cf21b9063d233b16f4553793dd15cca018323bdc3cc9a92b7f25c5bccbcc52fcae6477435d25d59649c3b5d03fecdc398e382ecd818b9afaecd612143660b734e5d7a42a4b492a9509b2d381fe46018e6fc4cdffd999d0fff133c92be5650bae8349cac1b0fa181c0b72388863f35455354e16a4c7b98efa4fc00af30bb555dd10fca40bfc6fa2b867266674a0218d0b84c82a9dbd34ce192f247e83502bd79ee5d93cdf90d355977bd34e3a25c32b722b9d6b754c48f123d93cfbc1e369d95921de094ff751623851d0598037033337485632775c711d95c135ec12144298c72f553f4b7658903b52635ee33e7b6cf1c7c8fea175b542885f5670e23f4b6ad4b2e973ed5a6373ddeae27c3af9f9e3a7f49463a9b6249142a70ec2c8784cf6c07d57992d04bd414e072bf4f65277675b76cffec2c2432d68fa9c6c05b0e3221db810096a9598c1040d39326bd7424383965a5733d28c1d34f7755a1bf9b602511b096d4c44380602007a1683ef75430bdca0bfb8cce3dfd384f32db1d8419e5f8171e369cfff9eb4157b3ac4f75ae5685718459b2f959574a86784b3f8fdb61dbe7d34fa67781494057dfdf6aeb717651feab1090a883ea50efd4af303114a55b5208d244a23e0da25b92033e4540c52b33d5538583e257b98ef5bf77002ff78225d387b4500c1fba62a13948f28a87e776276d62d030cd59d0a0aacb7af31f46b01bf7eed4d78eb8e3a94a0894848324df9282559cafacb7452f1ed8a9089815336c22ce2f99d27f540a354a023f1ce5401129eb8bdb111cb274b17b92007169df5e69aa5475dd94f1dae731070fa79449d7d635fb370f38de7a4cd848a4467113d5c3543575d443fc4317606f4c7b86eaaa63515f4a4123a1f21607a8cf945a55d1304af4f8639f7ce04e1c19710550a9c72ed9c4f1ad7eda761d382340aba56f30ea65443491d2eb3952b1e59ce952dfdadd3ea1ee2c45766c5f78503ce2741a48ffebf4949147f5e6407ab53862bafa7bf0a82a17ee57888383fc71b69c92a6ecf2a2c76d4fbd047ca4145e02882b6d2427591b41186e7da75c144938727835b4396d8f07c6d63b57f72b5613f2f9753ffa065165d8ae4aa374f801945c86767fd409b9a164d6fb6285a8254eaeca677a9ae9d3701316fb8527cf598fdaa33808cd2c2e68c1b8355e479e24d71110acbf3f5b14dbb5f11be924ed9f826ecd0a784b347603b02901c0d7c0c120adbd30a3b33915934071797a8401b7c428ad989ac31856f0c92bdb2bd265b0a51ecd37b48ea68dbb2751507e2c5ad1fa448963f209b40b71bd0bbe8490251877dfaed361f48585d5549e26d75694ddce6b2e764672cdd2e49bd7dc8379b7a0aa1571f9353ee60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
