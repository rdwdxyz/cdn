<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc2cb487dd89a6aaf3add484f3452f7237a636c8a2fb30711f16b2eba64c7377b9319b40409169307af2aa6bb745796379abd407d947cc00df9fc5895d1cbe66f93218bc12edb8ca1834d938fbadda2bdafc79061180591eafa2da6257e46192d7e673e4db034469d0eecd7baf6400591a121bd4dee497c9bef3964d4ffcdf7fb22e0e8a94429ae52ed2207685c0b4d8a876746ac85128034c7d85575f4dc4cfbb10eacfc46d12a29d3111d0ae61382f4c13400ee6bfb8ef7635606c7e802d6b258e1fbeda1aa8f49f23b8e7cf9f4b7e9856719f297e12f99219b06828775789c80c2768061ee03cf4aee6badd3431cde8baa03358bc559b6e4fd707d8717eb4531fd7c1b47dfd946fa17b0343e246fe8c59fc740555f4315fa30da9fc14e137ce1ef3467c9659b7eee7501040bec839a46df656d4334ae2298be8f17a46dbf541f60b15f06b0d52ce5fa8ea30f8e0212bc70c0b86f653b4b431c14a4a044ca6b3054a92f1ba4ac8460d28f4c7872e089db036738114e9135200fe4bc717bed3bdd1c3ef6b2d43526bb5a28965348253e4bd271bcae6bd95f3bafeb26b53dd5527cd69a26271a247af9ddc8a8566014664e6c3b343a60d59b3fa896a26a3ca8673abcd2022e5faa87865dfffeb05b6573016bed8d93dd94c675f9e8507ef2398d519e52ac51bb024fd3080700f0732f036c86466480dee0bd30610b67e90b4046d9bbfd11f6307b7f51258c4edb475e199175c40207e25779260bc92afda0787a6d0016976f576b7b0583c0164703a36dae0a48b80d587ee96b0d8f536b9a0dd591c8a48e82d368cd55dcfed73c644863e6b82cb6721f54ac93a6b2a24551738042e8342498ac07e3a802f3823bebf6c53a0131875f52fd78ce0f1923d9933d625d035f03f00e62027450a0ecfd99a802eb281301b23ac10de106c5d6d4e112023b0eaa9e3cd1333fdee6c934ebbfb9bb8a890db50cdd23dc875dc8dbb8659eb76dcd7f863bee9d29407a3e6a1bb5658898c9652ed82f40cb1ab078c3ff8d9a1ae22e79260f088e46ad5fadbb24b1a64048a4d8264c54742ceac7a30af3d0bb4f36bde9c1711947807864f1a48e50f0eba90c24470362f2ba3534ee0c9797c093bbbeecd8997e5ec36226ddbc0131e712f1c112cbee4b9dfecb4e3fe7ddb1a0f5d31afa9f9cbdd1d35af2a0afdd1717478454181306825b5f3778fbe868a24c08a29ae272a09ab4492c27e58d0cbc5398b81f6985db9e44ffc30f4d424014d3d2dc9d0c327b481782370684a4307ef2a21dc058015521b423d90eee01b7e0ef49caf5427c1650cf1474160a287e38d625f17bc3d38a140305c6a2e74cc1ddc96f2f0b66c42b35f63e836ee5ef98b8be9909293aca98036c84378fd4b483d87b47cf3375159d7c5a7faf6b574ee849c51b7cdeec5656e5f62762a356c343211b10ac73573e3017eceeccce76d83ddd38a25b866747a8e571d339e3aa01e9cad5d42d6445f664e2d7af01379a0af200a1be20df12a1b38d7402d033b398c8627f45401c0d23b6a0f0a85b905637c70c86ee274ca23c2ba741e38ecadf91160309bdc46dd5acac3a88c7da2fc19789b216f0faddd71597dc4460b04e203a737d176f0ad070f384d71aae4121ba7771672bd24c904ef9bec95dc5a3e0a6e735f85c0b58b79e57304b23090158295349e1e44a854bbe5aa708b2042696896527c96a7522d22f76d32bb432e0fbd7f9bb115f9e25d8ae061213556165bb571511c4b9b0e9afbae421145ed0492c81fe82ae99d952f3b594dbd7c539ce58241927f8a60f5c1d71b07648337bd901cffa21c0d6fbf228c25c0c12604121d0542153f2eee0ccb4314afca3ed7ce738534bf6938772eb5bc7ea351f43da37ab2b593965e18a955e296dd168f8283cd3f72ef58ebecb13d33da598a8f31435b799c0268aa53a8d67b49dae778a1217807e9155302e3500fb42ff13628ba4bec2b924945e327d51d31423bd13a58f1f433fd215a663c188aeafe7553371898eff522680dc6b395515e2d10847d424041860b064746043d98aa351decbef57b0a7369508c56e33749f41ecae0a3b8cbf803bd73ba7be48fe5c8e3eb057dd72630276a0379cb815f0dae6ff6c22af43d682643d3926a677d42d29db0d4dc5f05d49d25ba43d881e12e5835dbb6bc84900d33ce158cd977d44f2e55e25fbe923a37b5e8bd6b3a5c16db2052d454ee34b2a3856d2ccbe3778cac3258ac8af3bf0e9952526fe152fb9242e5d01be2194bece0929b5bb7fe18c2b1ea173d8c0e7b33c0dd6b54e27a2376fd427769e80247209e6d5f89570d68e4216e29962f89f2df8dfb4400ce0f65ca130287313a888d04a96f7773c8dfecfa0fe5b45e416749049fddf0de7af2217624bd6f936b965cfa5fe91c3f2985f80710ba0d50b89cf3ea0cba061c0dab17def1c7c57b734c815cd3e1361d14a2e693022d0f6071e858534b852397dfd55e5966264d5295fa615cd9f06f858d7b78b49598e66403269b35ac695852ba5e368baeec4f05c0cf43abfa592abc7b4917561f61906be87e765e277e68752ea626fb27e09fdbfcad42bcf422671885b673a9b1f8fc05789f5e31e04fb630a927e09d73fa5e4f8e033c89dc57fbd9ebece17105b7539db36a4f5e3e245a56a992f91ff662b6470834023aa607ed074508cda18a9d023000e7cb51c730034fb2107584757393a2a95d09055b8d9ba695879805999057c9ce9885cf05ecdf68e7197a3dae79df36cc3d1f93241c516e8b7ebab440dd3b8eee0d3e5bcb75d9193886f25fd96f43f2d522e0b33fa767459674439725d3f1ec770dcf7658346cb3cf02880a2c7b07a08bf2a7ce44beb111221751c3eb3645d345981a4244e8d301bf8ab551a93e081fc181bfba5f3719bbfd15928e4d9f0b1c251afe447a7130d67e609b77a70d3106fce4470f037eb994c2152ef7e6d95fde4cb299891eee0fb230f3a108785fc8f34c3294d620b4bfe1f80e7d84c88af546c07d838bc35c857e5ad6495837775b8aeed0f2e893d8a08ca6eb06f23e7f83456334543210a931a7ec5e5d727aa76dc2ab2777cd5e40a7db6d73039da8696c231bb04fd8b7af7d10f89f815379b37052a62c76d830bb1b05988d15dddb776e5088041eb720e9edb7590ca9a245db8099592de8fe960a45850cbe11d72b9c0b0844780e44df4319d4ebe091f2db885d187b2cd0d0668bbe01eae0ed90a8e2e8bebc68bd5591e94ad0f95eafe78109ff62c588946df8411efa62fd969a9a1251235b133a446a331c82a81708f6b18932983df930184be38c2c60c516788b71a20451d077a46ebaedca42e3e2aabff4b369575ed83b13be78a5f755ce35fb9cf6fd1673e2ba7c62c3ffa2b10d1483c400d19b6f3a40cf08d94a6c20afa26d725d1ee95e047b636a30ee3eab90a337dcbae51b4b3bd1c51b7a4ae847d1bab4c2b711acf0f7cc2d552935c201fd2fd34f0cfb89ca64e77f22b60774826116c27d339648b124d630529090ab4c66f7a0eaea39a2b4f6fd17fed2e7ae3a9bf2aa53dc1792fd1111c5b64151899ae3e9947dade81f007bc841ba73f95bd3ff2c99911abbbedc7f9a0865ec6ab883f85d57c7263fcac7a8539e8076a4d12586d2fad8dc99c511484e7f9ea760a5a8e668c0dc007623b7252c66a2911d212b36c72ebcacb2ea0f77b94fd5fb8ff0206e311f367609ceb4c51241bc073a43a8579dc595912a30f60b1a6faa9931dfb24b74013961f167d800087bc78cbc32d2e79b0e463de4fd9005cd3c374f8b5a20e14b9119031b45141e9f823a7d0f1f93c5abf3046cbf018044396369463e54627a7599c6f1bc7048c3622105f2f6474395bd28c792777470b3e6e64a35d693a7a043dacc7e07dbe069c6f348741c3810d061f5283873cdcf130d08aecae0a3293ae58d03206fe7c7d52538f330a1a8054300ebbf5f8d9cc33945df2b080d25e6e4219cb800a511211ce8929e5fc9d90f75b4cfb0528cf20f96c881d58ab5d5db5739a305f12660c4b342d938b3d63a20c34aa9e9ae53ab560b6cdf97de7bc055d56a29454033c79d959855e51e5613fc8233a50837809b539c9f66868ce7f24fa1c142ba9080512b392f0ba5728ddd6ce7b3d706e50568f3484f42f0400d098b1c2d45523d233c6a457248f5274f0776dec18386237040271d2f791520d8275a1ba0fc442054e5082a5ae5fcedb84cfc78aa550de2ca6e7a26096dbc129803eaf386dce958fcd2de1abb961083f5478c019a619ccc38ccab8bc39047ff097ae4a1322d78696ab1480c838592f446f6af8fa64e4a179d6660b99cd6a78567bf0f73318db66ddd7ca0c400f08045e961ae4d3d3b4191cff7b8dda3fae01666570080c760ab1f3ba1e16e9b52975b0a888d04f0db700f868054e5c0bb1fdf9bb27997bb952ad8835005ce81c5331c6eac93381af3bf2d4866a94b66c639e4f25547a65a4335d961ebc57161055bdcc5cbca2a44da7c0649f6dc52dd3275ea13f1e93aacc6ad7e79bab2bcc071b841a7c97d8937986f2fde7373bcafc23982d7dc5934977a2220b5c0bd96ff02290104944322780210bc477371f30bd0eb31275bdef5c1df532402a35025392a692398dfc0169dd0d64d0041fbbcf81307ca1ffc32f9e7cbce06b0d6504d84b4e01d97c670ad1b09acc7fc622865b6c127342839d7e1a7288ab1ad1b23a0b99ec39e6c9371e9cf97ae0e3455f70ffcd47e816c88574648d480a11ba83121ef0efe0bebf124b96e95a70b143dff59470c579637ca8bfa3efb83439a84c5da098440f121ee595a0e1ca76fa9393649ce4bea3dc095c598597fe52c2c57fb61386441bf17275a70b5085db873bf19280e6a382b2d1ded567782244e2455c0f96cc2c55d4da351345ce26fbf2bbc14d15d6594a5fed95becffae4333f1ed6f711ca4159045e673541d3eb0e9165bb54523605d62c20b01598c1294a5957d1ba3c9435727a2eab142f5a73d4eae8716a0d2bd26377d23711fb6682765115882c227c80bb82a5f92258d382c2139c822aa7061c4502883c86de5de8cbb8b60f7a884d8241961a4d76df583a86c1a8f4ea890a9a03f36ae67be859e8e6612f7d35be2ae8a2b8bf0f695f88de926efdfe2fcc1542ea498f015ac67eda4c24888d0193328aab3bb3e429306d42d54b73e3b7c536eef24e662f17fab387f662ea3abeea42744a0d3f35064caa206f2321e1baaf5fb74f34810d68734a4254bb019ff6c283c567e0ce0eba974bb2b4d400a5b19016f378155c6fb269ff692202c34555fa3e95578a7a86aff011075c0105fab94fd870aaf007f3a31cb634ff0eac839bce2cb18c748b604bcab96a7b4eeadcd624622c6882d2e273d0e84ca3f123db0241a1124292ac18efccb2b566e74241dbb5310d06bffe4335150ea96d676370a8bbfe306203818e9841ca5eee6655b10daa6ede9a961bda78537809b10da5af29d626ef617423ce42e1cb3547fa2afd4a51877482aed80c39cc0c473545854c5b0341fff50504409b7ba4113888b1ff136896631e248fc3e81c31f6896ae021fbfbac91f72c063ece0a61fd1407a42b1050a74822bbb825d1d1b729b760300f3ec28d419a4088934dc748df22084945d80bfc1c9771c9dc535156f7bcd9a27058530d9686cbb9d22bd95b1e52923ae0cb62e9b04d8d91079edb569923d45efa0d6cf39958dfff6a2251380cbc16c55788f6115ad927984c3013366ce2c8d90baf90449bc3728dbbfba44628a2e91897e9bf42b9e6932c13975110ed2b6880e58484ff7e119fd32142566f9529108dbab3eda1f8647a3cad94b6dd67ede3f477027ce1f26d26764780597e759e4bc617b02154a9d64202a9548c097ee3548bb4636e2cc6650f88eed8f1592a6672e8acfb7bae80352d22b1743a84204a4e933c4a688fc9dba6baee036c5486382448bc88ef1f28ee55ae10a6d087a18af1f2554fe0d298aa6a6a6b5db57327108a3cfb8cf7d574243d029d1af10f52040d6e5c0756caa57a4c65bf5552f36ec54dbcb287d207a563cb85e23a7a9c23b98f32ceac7040419ddaa500bf79bf9537a014c5d7aa46e9d42bbc13f0e6e5b77ce0f74e94f431be86c7e3f818b49fb721c8a28046d4d609369fcad0448791efd5896e4d1c175ac1c50cb4b03a7a79bf4bdb382efcd57c4b7975c2174fe34813163b39c37d27aa8ec1d8739006378546bbfbc6891259449e08edac880ed4169d966f408f1175d237be99c15d9d77ce93792af9ea8cb21b478994a22834a40b30baf58ef89bba30a96e0042f1d7c5ccd892a7cfe5160bccbd1872a74f6c9b6d8b89cf0ac2b7a997dcad28a7529067d55583f776478aef37cfbb21742e8cef59685725498bcc7f5467383ea67d6c6c8e1eb9e813a68fd41b1720dded936015e9cc3735e14b152f45ddba76a8156ea7bd490a8f25a1f8f3d6c94c2ac12c717956d8305634b92b056eaccf6f83414cfd8642b85df27cdf08c827f3813416b12b88b6514c2b288fb1821629c905ad2aa219d985e8a075c039b70dbe083d640616b44d0530d77ae697ec1bb9367fbf7737dbb3fe6e8cf36c4550d71097159f06ea3a3e40f5664f1b5faa67886879c66421688a9422d666f43f955a3309380782c96f5a8587b55f33a6a13a26c0d17e573885d594ae98ad46a752f619498e9e633bd8be8ccfde86bb9707bccdf0e2bf6ec4fd4b26d51832ef3baa02f56df881c73de4b6cbceedadf8c3b1f05c189d8bb508ce7bd51a3dff5e1c0484936115eb3ce4ea12de14251a638dad46753cc667d4549ef80ed2e8b17ba8b341b2a23cfa29dd4c967368b4daffc3148722aa976bcd79837aa1cfab38a41646da012ec77d1a0580f58de7d56f64acd110aca040f29abbe5f9eaa808e15b5b3eac0777dbed08dedbbfd36c3799a83c6adaea0255f01cf6f479a2b3721a21b514397e7e44a833015beffb3d94733f74bc47567483b79202c46298c4fe90d301f75b2584e016e75e8e449f8c755271094e83c52ad469cd590a485ae0c71cfdb54698401f868be4615b05050cf17a6f4315ef9c8e7ea5dbc6d27aaa24c73d8f6f55b5abba9dd0c55f5f273ebbe018a1d6b13e675a3480fe746920c865383fb438d2e20e5c173b1bf16009252c68c0ec73eecaa980c696e155ed890f4cbd0bdea7eb0ea4f403e4ffdf4b95441abd00dd90cba8a29602246d3240e9b728b49fddeadefb42b386ca766d498f0df7db0b7f6afeb93ea3247177b2f412be731776b46089d9461faaa34473329c10414cde50de556a8e98f27a1e0bb291e98a83ec5c1e8c5dce55786616e6280abbc7fe15e4fa7d1e8c4d024964180b1397b8b4c4145cf170536632d8c45d780d63bf4b2cf720b7d0ceb827a8bc4ae3856279305a1d98dda9d5402c23461f1f2bfce426ab04c1a21b8e9f3c18eaea9cc018a78b0c67bef1bee92ef4efd24a9c23c3631f1c7499f4ad913f0ea9a91973225473e8916365bd423619075a2e8f7ee74cc730c09ce06e2d70f91207a1d88c8285085f3ad4c0b6f75ae3ba2af74e833720a27bfe121c356d754159ce3511bfb78624be70120863793fef315f9e9667a2d71f9ecec0bad2f391f2d6840656e9b2a647cf81c0c0ae22ea7ed8c31fdbb63ab229978894faf99204856dc23fb073c73cca73a304da737ba6d59b4e08d8d386e1472128b225eb331681d3e60be46db4bb918d2cafe464ce9089ab75a1b719f8e88511102e955e04fa2e95019b77d19196a064e4578696542d478c31b11f2d5754c1efa11fabf9a18a9c252f28aac9ec0508d1d83aa5f40c21ea153f782e470f9d8a7e29205e082b31627681c2f5c59d8b4d3227e409c15bae299e7aaefbaa2d9883d8a8ac40616e8758da67eaa11e1a4c565378a5b52f72e107e7b4b2b24076b1cdcb1acd29944713b571e6c9bba1eb5983e2ff2e1eb77f010f983e252c0d0808b04c5efe50f7057e82c0c4cc3fc6d15861bc7638481c11c4973a91b06b16c38871d9f31daaf3be9c94cc62cd1366fec657ca5c695e3b32e847f9aff150cf1f2423c311c11a6eba350ebbb1e08ccbc5a4c3d5e190c7d17fba11f88f9607ab5bd20a550f1c2ad8d3917d1c96298d6bdbf7689499cbc6a132b5fe7a5f12640837f7409c85b11b2bffdbaa61f047095c9be008fbfbff4e7195df07a7a8988bf012bc4b8bc0519a7b0b2330afdccbbc33b0d29841697c70c3586050fc30e345d5503e72e9d34cc44f5754df94dc3c05a8876c952242bbdd052571d4c7b3e4505e39cb331c7093ea28d718dad9d89bf2e1a6b1993d6754be72c994b9f2a66b945a25c30d18efa1b41848fdef9792232e51253ccbd59be60ac0db5a643c10045adcba668e71ca0b8950feff55b983dde8335072f2d9ec83fa30dac6f20a991d2d940292dcf12c04a4e1e7a09c6312fcd697c38e96d293cbf442fe902507ef3673d79674ccd8312137ba6048aae40e2963d8673799093a79815403fb90ce6c68b0ccd4bc1c4952eb4c5a393ed599f7cbea9a06ea81e00444f401ef121ec7bb2a1fa9cc6dd133bec5b42469800c5b618b8b6f098861c1375bc12834833fc9257df465533f19caecf1ad87b8362e8ebe628c87b3a4406193ef0ee35491ff804e170a0811c71542040a6acc1709ad93a17107c0e95f183e065f5d6eedbbae0ba3570301d17b98dcd6daa495faa4dc2f0fe876167de6cfdafb228fca0443f9712991b1a176312a899b0faa5edab38d73dbb354ce99009bb1d98dd4e8cfc0a91f325336c7c8a79dd7577deea0558e0a95578f7ba66027521de3ab8d24e25b4d432971b03046b0dbc35bba127762891ff7ac2280c6591eef9d6d69ecf5173093cb1b86f3dfb48dedc8ca650e78cd70e0b2e105d638beec01aaafe63b9cf1b94472ce87467a2b6083565a29e5f41fd6243fbd2eea679e21b29660c1868ca67c83a05896734076a13b31a5b505dadd9251ef16b4aa2d732ced04e104f9077f51bf7aebdc7758dfc74b82df0a3ba24cf640af8b48fc2bdec2051f85637f82c61514ff0f4e8f51232e5dc98ea09afab58a4d8eec580964d5c603c9b0663de5f511f915b67b95468c408e0b47c5092ed1c2ab0a7fe7867222f80c8dfac408defb655da442a922c4b1b2b81f8a3f5cb673ee9ab7bc0107bfabdaf0c80943570733482971d75ea3b65e5c1d2da4887babf77bbdaf5ed592606948b1f7fd7ce3405029c37cd7f449c084261ab0f6f1f79cb77a87fada8852afa9d943ddb320359331721c9c963f5cda26feb8af16bdfd0faae1b20d4e6a1c0e5d86a0c1e984f364a1edd6dae69ba93c48cc4f68283ce65ec903ed907f2d14fc8a7ca6f010ed34dc197aa7c0a0be6c1ef7270b38c1134186dc319b4e21b2313efb66fcafea12f91c0c4a9ef651e928c2c626050e0057d51190a786c6c20065b54f9a4552584233a05aff43711dee7655fe5d22ab8c4b1acebb704dfbd28e99b88861da456248b212da2d1f516f968508e9ce84c162b44881c2fd70208157427dfc62ad8238db081fe0e478d78b1f6fc35a207d332a72ceb9dabb47a2fdbb1cd4a8085938b3d8f4177571ac1befd741e5dea815015d70d19651019e6e3a9b53fd002a4038a55793c5d2214ffe9dc092603d9e7e970134cc904594094876e845b4e29a9e9099e9917b61f2743de950cab3c3dce0a9ce6adbce762405546b26150ba6b778573063a07091eaf09ea9ba02aac8f50c9679618a50415a31cda443e6866593981f4664e2d4eafdc74fc5556e2a400cb76c7860babc93ed9f041ebba508ed7381db6afd3e227552aa963780ebc530e44fd4df561284f1db961faaef5c6621fded5fd13d9d9f8cf13eef069df5c63365e2f22f3d1a30ec6ede17339084247c0ec172c51bf36e821e56fc8cd2f26c03346d40c2617386631a33ba1380b85aff238101d84b44ac60cd383be2d5deddab35d64583c806511d7b9317c6bde622f255164e0d143b050d363cb3ff70a71407710a20c623c720133923c7a76bfd79f8e92946ae4e62639f908ffe24bb9affa017c77e8f097a38ce5885c4b3701f98778183f6414f3e9e567ea7c89c44797bc5a6e1a653ae51ade4e341a650c14b39c32fcda70034e39441238e99710510e0a5202bf805d5fab1c331450a1b887140bfeaf3ddd1d66e4c800e6dfae8fd6781989c6794dbf480e0e9db4c1160ba7d7f5000cc88f94e279c4f42a5bd7759f5c3a6b34f4bdf870604b1ac9ab9a0762dc82d9d1407492faf3c177218cecd7b690b676083fcf49a58f6c9e2f3eac135d2e6345515b5749c8a7534a6c03e51c4689ae57c82f7478978e7efd8f1a0a6526537fdb40d1716e9406fa9500de9d7034bb1795368ff490ac475fd7b669df4477257d1f925baee141e5459eeab20bbeb7da2f6c6458e1ff27168d6f698c1f305c1c8ac3e40ec520fa82d4ce1fb00432b7b585ac0e83466344eac70b478bd17fe688f6da56e0abccf2aaf4010b2807502570d2ae6fa24263670694a2510a390f0145301ac31ba4165fdae6504d220d7818719d81f4e42b7c4aad240a6eccf1f3e6722d54cf3c631d2161be39a20594923c81acad08fa34bf0360cde01c27ce174596ed282baaa8ecc821d9967b5577d877099370b877f65f5d383d932b361cbe3488f7137e3626d951272f35cffae0b45ad6f2fafd497783dfab6bdb3ed628187c882d021a06e171421b09266c63d3115dc325bdbd7897ebc1104e3a8842445004198848ad2cb01c9a1cbdbd2af4e443e2d312df4218e279f620fbfa64debef9e909d81fabeaf1cff1b21c4e661f31b35920cb01ae171520559926735d6e9c9681b43ddd3467088a902589a8382e3abe72cca207b365320ee0bb52446a4445bf971da6a5c0c3b3bc8a8cffa798bb6be7b4c3ac11f1098576c4026bf2b82cb46a76268bb88e07c03aaf8cdaaed15a3c05122e60fa08e761c1374b263071a9c7ac31dfc1f3952293ce6ad4fd06ed825dd9b848543a2e3c8ddea3c0f4ec9f7ad222c75832af9b91d74913971e07c2849b8af11597bfdd9e51a5fa62da810660df9f2374599ed4ce1c8ce8106d3ef4b763828f56294b36f6367407fe40b2fe364f57dc460d7f4064d3956a22b1d1e4888bea7e7ee4bc5df2006715975e6a4090e095771fcf605aa86de1d51db9804e1806987f885c7a8d5d17f37ccd70a37293c17027833a44ac239086a9eb3dffe531d9e6131930655662576537b4f9f9ac2dbe18f382ec4952851fc49f8bfb2df213c953fa6655a4c6d94700d2495b0bdfd242ae5a5403a8f1eec6e86e60586ba9d101894dcc66dc0e7ac150fcff9152961cba1407a9ac312f5adfd5989ca8ed6a904c670c06c8d2cddf370249cb74b281fbd21b4596d1979e7bd6c16af91681980a51514bbe3963285dfd186d69587645061161f83cb95c24edbcf55e277294f81ca2aa4d98f02becb393c7703024f067cf750bd095ec7a43e855abce92bfe6fe6d0f9862f15cbc356e271b39b9ea9b185afd146003ff5f5ca8861c4ca4490d56b4721b16e30879bbb48cbbd4156a844b7e319d89b95e5386ff1619d2401fb0e5ec24c84057c527ffda9dae49f8dd96e57125fb2209ffeb978c10e198a3956f63cfffda75e2e1ea9dfc8bae9b970a1eefa0375dfed5f065144b67326e2fa5cf4078d57738071782caed66913f8409123ff4730570d5588e1e81b8b9392f7432a3c2c1da39c266255d59c9eecb4495d10b56a870e5ce71f9e8d1d4511d8391df288f995f1dc93f5247b91e672105aa3d742bb38cb90459a89bf07264e4f14a26d8b4b6e1da3ce1bb783dfdcd15f9c221537eddb254b93a84dc57810a7b0700bb4e5aaa131f9d226fc218db11a428300d82d0e24447fedf5513e664232a0dde42b0b360896dea1bc05c405b6db456e694f9c57d88fc3447b38aba34a0cab4b4bf638ab73150ce7a24f3dd4841ddd696740a3850b48eda905982a80c232f3457c9eb02f534e2346c028cdd15d412ebb39eb9a2a4e31aa499387ab83f24e097e5f3b858336dfbeda9d21abeb74d255f6262d6536905730d8862fe30f9a3c75299037f998dfcefc40fd5e9dbccb1ae78e128d2684084f61899afa17a84a428ac37633139042dd0a89647469481cf9f96aa1faceb35fa2d8b34f674b2ef19c4868747df501430e40a105dd792185dc0ea06eab131dcd097a63fc1d2a46e14af408cafdeebc0c4b3b7282eb31d1d6eef25917dbb60c42a97ee0411d9c698ee70c65fa091bb992726eed075c7f576f6b6c17e06d00fe132e40a700a48ad977b1e23d9b139eee9ac0b202f04d32cbe61440eb0d948b5ef26d12758cb733fd00db1a3b5dcb7d85e90a8f9c30d035087b55766dbb54a44a8dc0bb2f5760d44d1361c557a619fca4586f1ebee17669b54ecc76e9d7f8dcbca93ee20193a3bfd598aaea1f80ea7393825e6c6cd1e7cf988805da5f57de974389c2cfada6b28958811b1fcf7fe9b756c497d6dd7e9617f7dea601b7abd860c450b2604b64b131da0c0de94674fd8733b915b7a8bc508717cefc21a5975793162c16730a04eded0f2ab806862fa27e7d109db6e00bc8077c22ba9829c238b6df48d7cf834d6c33324886445a074972d536556661f9b84c45aae07368d03edfe7f4e8d4e992a1bee2b3f98020cfa6edc86eccf7885e1230f8fd1e425932377438f41edf52ef30ecebe1bfe5aa0af1f8d03d3c5b919a5bd050c5b2ebc04d92430d5e8a4969ceb3d1d36791aa85f26ec88c6302a7e2fb877607a73a8734cb653ca0b0ed957c57b2f978577ebcd4d74e9c781584ca43837427f25c79383d92608365c0e48495ce859961885fa7850f88e2d64435aeefe4049a76d57c2b7a591403024fa9453528f6a46acd59ceb89d1ab7a005bce457a9c5eda7abe2fd4658c06b597a4355ee1f6eaf2db8458768d4e32fc287d6e50d009db137241cd3c02948b5e04ca7610044eb5ddb590d13997de46460a955aca105847074b7c1e81f0c92f90a582e2c287323e720be6a485d50079597ec33e966138b1a780b4e96734599e25624dac8fd3eaa842621764d9e155cec7468df67acbc0f843e63f7c790e48c97bca749d5dcf4944bbb3491e27f436e2ca916cd9db8a949ca669e18d5cd3c565cc7b58fb5827ea1ec218cd7d8a66d8fac35a8505830a0e6ad7da24ff3f8683fe88d79924bfa0843e4323d0318038ab47c5c44dd2546267a30de9fd443bb91aa6a9899a404a2b30874faace32704adb5a108ee01f3625bf11d02d1470e98315313ef455a404c6001cdf0f7844cefb09818f38fde37f59167ce29a179453e2b4fbca460c18d4ad5ef2c9a51896d79925151d2016ef9b91f44280286cb446c7f5a81c93565d59bd5a8953a7f4299bac8aa0f421cd5a08b616a3af645a06b48ac86b2c32cf9a043b74ceff5a4ae102e2084352d61992a497c18d56b48405d315f8a0cd8a8a1ac2cdee2c40dc779175af6072ff441d0eacf20c8b5234e1a99519d54ae4cb1b6abff620994a157cba87fafc709025789b00cd85fff4435ac374a19bed8e2c4b27e240cc6729b51be7adec278c9cc00a4220723a2785b47443f83904b639f15f3f4dc1dc098787850abcb550f842d26cbfba20bef12617407bb0611be1210b8587787d1c20246a1c290c248011b35a46d31c7aedba5fbcc26579618ab4a191adbe1ff32605ef4f90b97c2052d2bd39536ff800531b4ecab71a566d5bdf837281df5648f162b81eaf1fad9b01be8a7076751a127b66ad3f50afc569e5619e2e86642a7255189514abc7cc9fe32f6315bb39c7d90d8dfa1e46cf7999765d52bd0d401c6c0e7112b6b9f34d23fb14106f7bdc0bf15bd1fc99e1097e60950021001ff3f1cd4d65432de53102a9b500ea57686ee20f236d7feac84eb2d143fff07dfc5859fc6fa0a7134780c6663b4625d93392556eeb53990b0fff0bca1b31a49a34d4e55b3a053fa3fd9df6ea70add0d82d6e21f02922cd0c18ecc1a929cd3682d1c7dd32eeffeee96f70e24c42c4bd78416560eb264bf42ec905f3ea4fe5110d5a70bb3643d404614e9cd54c510e5b56be27054c69f8fb63375afb86fd337c651d28008385a07f4013a183aba545e7542ce6e05e7d5dc2559ea57f3f1d8f94208b4d143e37264df054062c34e9d7f7a114c6a7cedbdcd3bcc3e2e6d4e31df663c267e7b068cc3cb683c20fbd950f460601dcc62e48bf7efde8cfd3f015298c7a57a8df7816f4fbd75f2f68de5f6bd843b769dac4536e3ca9f8db7df6501eb54fd993b8576dcaaebff38b5e13311807e30b1bffbad210537bf54a0c29e9847a8eeab8f645cbbc3b163103b2cf5491c48ea86c562e9b44a1851c6c1fe4be0c1f16d367616a747a30624d7ef9515b6906ad5a741265e5e0155b7f2384b0bc2ddb283cf8f7a1c01854f2ab3cff93f9c5f9971230c462c3b566ec6888bfc1276a7361f7463a5750ec7b940e08a969f1b52221fe073ea0153a07d717ab83a43fe28298d160efa01ff910a9f218a6e55936791e77c04a51a895ac2a5fdaa49a6770f64ea3a0510455f04a21b720e02a61d6aad12cb4091b4e136b116b9de380c6130821d41112874df4ddc314a3586eb9de951709d78215157f30e45a50f7ca16cc2e35e533f4bd276fc3c92b25bb3a5c1d17b69e833679e175bb0d5cb448f659c45dedb2c1ac08a6d3482fcc2e95521a674ede98f01c9fd840b4cf2d49d6a69afb254c6821925e0b6fac5a4dbe6dc4fde4efebbd76a533b41a72dda23453139a9ee772788dee78810b312f61d5d61f6141ee59445677826d210a29ea157a9a4e082acda4dff443d268d4868d2869b911a6357f787c5dc79e9ad7cee8ecf985b00a685962d40db38ca93f8cd5f905a1edfd410a628c77e7a537db38cc774754ef5212718ec7f1caf2ec0cc0d40f139bb0510c5745d8f949d5f335a0352307dbf5f8384efed26f876a3cf69f6041283322e54425dec1cc3f1683d0ccf4d66d503dd37df11d6f415e976e265e48a712e574344c8027f28a2a04706e3ebe013bc4d098d979438504bbfbaaca03822d566afb3681ac508d013ef1efde0544388709b590ce8893ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
