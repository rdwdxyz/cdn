<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01d8b43fd07e7240f2becad2b6a84d59ca6b1c71bc936369d939d85c748f71e8d9ce27f485e2052786e4a5b4c3c59fbc9c3738f8cb4e4060888f6d3c624d5d729338b077ccb135b725a56a864d1ceb98638af4bc0cc0f5c6216cb9f878224985e91239c170695c987a879a5149cb30588e58b86922e41d689cc4650738e8957f5544f091093847c96d95f0742659741b56e0ecde52f8a10603157308ad3d447a8adf5f1b7c1c817cd8a197205f8e963c3b30fe48f6da536a487875ea7e52a90a6e622ddb8f491ec250a26569f5502c42e4af1bda5229a65ee04802ff485139f5bf8a2699489446b250efdf1642ae68a725eac038e3d211d692529f3ad0e7db0c5018bc0b18254905624ea6f784a54bbe5a747ddebdac7c560d49488a4f499f55b3f09555e4c6854ac2f1f37e9f8d95c5e17333774eb5e38a02c4c711a8a348e646631bcb33db328745a4a21441f7cf123aacab457422b58844b7215e42a4bf385ae10b65c0a42862555d467a3618ba383af477c71d49a22bd893591e6e6643d6e998eb5bd5e362a5c9358367aecbed0fddc2c8d6dbfe28a060f9fcb17034650bcb9580940f1a59575bcf14ed4acdbc1fa13a61e751a284fda99a3bf2e965a41bc3da144419e87c63a8cf50662d5b40932dfaeb364749e49c8feee35781f46f1c452d60c55bf89ec955a24dac2a93cbfc026a6dc27608dbb0d74813103b63f5341ad3b7c5870466d1c9467e84dec592066daa343e747c30d5080abbf8765e3429bb8571791c5ba499de2441627aba4067a0408db8715e6414ebca474e18750331d5a73aeba1f0914475f38278ce385e18fe6a26ad5fd020cc81c9de5da1effb93dc82e3d777b9095b5998df4ee819883a66de72b3ffc50a7a75a61d73143fcd5f9719340dfd8c2d3ef9443eab4fcdeea98fe15ee30d01a61b338e116b0735cf63e287805b29d66806ed25b12bace735c14c6c3c8eb93f140062c88296ed2cca08230c2d206a1d268c06c3b3322ff06ee29531afb705153003b87deb3bfb4743c8b3d5fe01717f7b0d53f3f01246dd58eb1cfce68f310762a45fcae89a31bc11a62eda7826dba941440bc5e117de1b2b3ede933910ca903da86c5ca581d585956315020e830da0c040b4b889540113aab73dd56361fb4e1074de264dbb90821180d81d86878eb83d12f7b94f49ba94cda56aceb739294bbd440da0e344f9ff424701d020832e92acdd39a5e79548dd3a05dea2a70af04c6ce1799875410e30ad3d806ab6c2be36983cb7bd163436042871e24da917337be12ad3e6a6d26617e085c98f373fc36ef98906eb3c3539fd85d2a6cc4e618169a2680774bc04d814c0993ee1483e238ba400b4d58def9a58b964fc720864e903eba579c1c00eb997f11dead85e635c90a0693f3c8bc5f4bfe98a471839f7486cdd6ae85a07d683c22e68d6a7a14a9e6683b58bab1f5d3fbe5890fe7316136092fee3dd8c587ed228246cb1f50e63617369dc6cd5f76711b0cda38ea056df39f8bdb407be2b90536f6a27c2f4624c2953f1b93da737d0b4951c3931a190d50a053bb04443447a4808d7a063ca960598522147944e854c2fecb0bed8500ed4a4d37ef62237d802f92de393ea9eb9f0af2ce4bd2521877164d2956fa54901b53198be19e90c0a575d619c76effdee415b66f66b39afb1c56851b02227d609b74eb7a518928de90428a0a8daeca5cf1583cc196b1ddb88e8e9e605bb1d06c46048ca788d107ca713d1a10c7aabb1235da5d6f6d7c33db143020ab3071688b84614748aff164c95df95b011770f09ce8b8848e699db0a0028afc0a76e1b20d0e47c03722f5d1b84ead948875f36c55f0e8160565ebf037e81f206ac77158f3d4cd6d72226a9e85eefaad07fb2b0fc7d2ad8c767d09b02ac2e2b399915cfd2cfc24d04442bcf510bb429a695518a28c1f741ddef6eaadbe120baae0bbbcb6500378d0c315b3bf67a3fa2d8124f4dcd21011808527f3e02fa251fd41c49cbb0a007e94906b98b794f4fd004dabdc7cd7b58df3077b6241e794ed1acc451b5a1f2e9390f6c2e54d1fb9718294d112c00aacebf2947743d87433ee3956169dc726ddeec2d8ba9b583f2d2390438fe0324334001bb260571b7316160fbd6ca8f1c474169c60e1604a04a78b01d08857c75fd47a653c88cf305978516824a84dd67cb7c2f5c1e93f2eadf773d3e6d264c8e07c0287fe3a7a63f160ca889039b01dae3c20057b48623198d0769d485e598e623ee507d4b6357d5df121c11178bb0b476e62ca98c8e58bbcf4c9f975e1214ee89fd554dd37cf19a25d2cfb7ac1e03bc7deaa41344286610180ea93dee0ded421d83eb39fb36f74e100655f199d6379d4213fb94ca5ea9ef0ea2ad1f41d0c107cbf3ed90d1513266786776233b975f4588a270182ae4926fa163473212878ea39774bd83e941ba177b703a9e941eb6f1c38521be8c68772aa0a19452f64adc42d176faa554316961609356e41779dc732b87161185d5c43d0e07bceb67689d40102757eed871b6044e592b9b689daa0a4f37003826815de12aaa97ade022f4581debf13b8dfdb3d368b4838d6b1bb17106deda3cb9ea2e16d75a3c5ab3280609be7f41a3177fa4e0a96229dc0a75f407983c734c47c5f98531abce37c0fb1ae8e571259667a8240fa1ddee5f4c804c79e64898524da159f823f81f44082663e04c44c49df40dcb0a2bc9563818610c0ee335c421a8d2e62364c1d3c93238d0d791f4c452f2a32ea929f5bb16021dd3c01190598be63164ec8e4402b43fcb4747d4a97a43355e9b384ad50dd25d96bdf41c8c6de20e5534a328be29ad0bd536105326095377987d4a383e7abdcdfd73afb80fbfdf4f1e6c110aacc8ae0a2cefe6fc50040f4c3e0c8087ccd0cf106e1adf2692cc70a48ca20f37a007141b7ba1ada1b6564fecdc1c0b320020c109bbb4e2c1ee7f3c9c4209f669de99d02cde6a4e91239d4c78a8530bee3b14aaf522bddf7d0b9170280ced7c42dd3df4f301785336459fc5224e73422241a5f89e4833ea991c338b990669abf9a0901778c9b48cc1818c5b3de9101a2f47060613bfaa845208752395058b630f54c26113f42dd0cb3f97c2e2f40e61d7557820008d589d3d5388bcf6054239b31af232744cba30913c2ae8b4962b89aebf60eebeb479d75d11fb5998ae06ac1802aa8916e7a52da27c57493d5c968c7a6c8876a593a6d78ee16284a455ed938e6c27e2a66dfba682f34e0d9b53c0a32570667ce395491cca7111237cad1653dc3d89896a284682f1d3ca427a9ec49d2b11231b3fac5cd00a00fad8c95b53389acd7832b8fa8d1c3f9a39fc95e9e5b11ad69c844d8c7111050933a00be24049b2e1eb401708ce7592038a44a100bb5cdd8727f3b8e1c75718d239aac696e9eeadeb3680e8ed6315c9ffe93c15292824fbf6ed933f5122fdffd36e27df7797badd75fef4405c1b4a7fcb93ce8e403f568348461e66c680bab5197cff47cb9fd87810649f3799fbfbf0142cc828ecbb5369b43ce261179b9bd9979330cafc3024393cd0b09e7d32e6a4469651dd03b7e1498ca06d9484ed76ced275264054da220cb2e49818460bf0cb6bdf793d161ed814350026f3e5eb6ad55b14b920432f41dc8b0e7459769d9d78be9398ce244877c621c212853ffbf9ba484b2949aad603758a6f94078a03e1fdc9f3144a4ed27754662a78cc9214bb874a45e2c77f6b72c397d1c80a55ed7c3f79d256f3564b5db72e9da7ee80b12fafbea60acb24dbbfe0c70d7e8d3a781b0f0e2dd2205e3977a46e79b605fde1dcfa7efbab304d95afe10c47c98f1d185a6ff666de3a7b349e066ea21a8af2b23d247abbff752550feff9ca1c7aba135a5d364157f7e36512dedf7f760150e2ef6233fb54d84b809f004a57af4425ec8f230bc320dd42c1d400bcad8fc7c6678fe019c916bdafc29afae4f60b4724ca6fedbb893e09a59fd073b779801c1c705025155eca8be084f3b8874416675f520d48adf61e17d8a3b263c7d4dc5c38f58898fdb7a54d9b28a24fc9bb70dedc2d20a5f9ec63cd097579cbb62b8c7f65e24a5090202e739b1048550625f51990f2f28f4b6ec376c59a9e15fd91a005477a20bd67db78400f0f28c6e3a8163c7c9857caaa7923911917d6450e0296ad0b0469d57102ac274646ce273efecb150222f385a08fa6529f13bb9ca7e4be6257454a5bf65ec57fe8a43b95d60f18b3641fdba860381dc0e69db5005ec6113f7473082b8164d2e8b776ba00751be7f74d52ff997f558ceb5a3f08132b552dfa56970252523ed38518d075a92df2ddf9d9723e5d31f8277ac06dcc1c157f51cf4aa28680cad36bce3b1127a3f0483502bc3386dace36474e624a40707d7dd1ff3d9a49321165ef85ab46aeec37b9399e81f2c849a66cb6679feb9f6adba5db2af4d3e97c8b43575c8b41eddaf30648659bf44adad904e885128cc7715dbfe9f5dbe9145f0cba31fd33d7abda3a422a96dfc4e22cc2a338d57c77b2eb9e3eb6ff8dd562173c1f103ca79a2ae2f63d7cd4240c6381ce6f93ccd743d82bd5223d0f00622d3992e95786be9236282a52c8798d3cb594cccbabf99b68a64457f92034f74aadb659416fb6d2920981432bbaccc7d2e9ba42ed3833e217aebce1c4ac0a89702d5107496b95cb03aabe067c9f1228e41a5c5238b7e83682e9dfa2876ee0e69d4432280301c6782fafa6d5a40bf348b4661e330ab5b019501fcf082944d84f886293c3bb71c3b2e8094633636d957f607dbfb1ddde1396cbe9c04245eb393fb9b96d050652993a3f2e448bf4f1e9867ff2ebf32ea233ff1358c1cffd0ca89adf633d02b809d6a65cd0b703d0464986bb2c713dbb618a5c8c574128c9b24932445d29aa15e240ea318b556a1d93ae07b9b9afe0732659e1849e5351f803e3cbfbd1ff65499cea5cee1989b8e3467be570ed0c0b0c4e5708aed4a03bac81224a0a5e412cbc7d3048bc3921bc737985f87dd34944b33e942d57ca29953932c9796101fad1e58fcf082658096bf63ba0202ead2f7574c6aa7c7bc51eaed549d4d255e4a4cf73abb127aba47db4960288fbae392a586cc7eb96fbdf9b8112d986f18b4d54d4695fc834ab42493beb4ceef7ba9e37f1f6ae1f39fd230843ebbbc54f6fa4c4591dbc63faaba2fd723be1d9ebf743e7112c9c96008de2d6f7d4cdf8e02a1ee93b493a56706fbbd564674a0ca90a62becf2f59e90cf6d54968e0896e50ca9764a69b4d4d5a4ab30d6fc7524eb709225a7906968e46e44e644984a966091a929ffa80ce005ed6227b307e539fb244d8ae31f39ac0f5ea4a4fa21973d622e03c2286a633b48389497446ab9607c4db716a91edefdc9d8440d317c7ea3023aadae7506025f98508ddcc137536128de5aefa3bab4c918a402dad6e2fabe9554e8cf937605d86e5500cb8195096363cffcbc62e164c30123a9d5e2443f2bcaf986e65c6c70739a19be99bde7801d67556dd31c35ed8a5b75066029618f94f0fe1755fffddaeeeb277d51eb8b78deb12792c6796028dd266c040fc49ba1554534d5834b7480001adf888b60fc2e1dd5240c399c188e5f5f6f1e4fe2eead3b9f649b3e95d6982abac5f3bd1f493f8531a21bc41b8f37f3e52a068a9ce3c248776d7396db5d4156024e65c6a7fec43a31d78439a6d2211db3171928e37efc84bdea765377d14080c7ec151cabe1bd33fb3e5248e2065a0a18f3c920e8d180fd263733e09a44f7652cc106fd4dcbe53581731701a483fed8a771d595ef77b691dc1cd0a3bed9636f71fc571c63dca773c97d53a389a58d418cfa0bd0f45e0e572e3f0b21f3f29e16c5050ca896c2f1867eb899dca53b701a8a883e268b1e01936399323edc602abe9ab73246a3a5ab37ca5508fc6e3ea90a8153208291490fdbe5dd07d774fa3c471f2755f97f7c7f22f81f8d2305a3d887c6c5b5ef6906142956d19dd3d81c6b3c17b0ad2c9ffaa8ea29a28c8c9e74f0d4ee9f8b4bbb3479db9d184464d63777286c1f5e9b1672a8b4f352585f46f1f2bf6e07adf74fedf3b34d1f51a8dc7b0815d776420cb94f4fd794d1bb512a40ea40a63c144ef801c9a62757d0f0762a09d30c70d987b1657ccf90045645988a87caf97db90aceda617bd8a0728814324981a06d78cc822ece7e3c7e6ea424368c332bea9f959c7fd9d592dd887d32e33b2982877664f756782f57905bd47718d6ead885ca1b4b45b75cc90a002d0aa1708d3816b5c63f67a06ba2a280ff9ebb6a6302ed44d21a156a3a2c090a08387604befd8ff24697233170941d19bb637755bd1cf633317cea7843a4430844172044830f1544e00aae5fdfef4ea6954bb49f752d341b6e28a26c765975180a7bee9b20a63e24d5dffa65e9e6551fae1ae460e9faebe1d967a1a4155ee911658d4186bc2bb5618729a4cfc7213690ecd8bb469e00a108ee72766c43f10633e4763af1ac6f208f05f3764498e9102cb38d0874c06651b5410515be97c4d094602b80d61efa32019d64b03eb54bad15fb6ea5343b06aa7d11189d15af57bd1d9a7815ab67040036b7b9f8c644a29f591b4df267018f9f5203689669ea7a3dfd3a17ac06498c4575ab17c5b129e45a32d916751baa05909fd13b6b0cc9c7bab9db5a1a06c4fad89bac068a0d5c60e2656d0e84fb9d4172da424870a78fc2553a0e474783cd02f77eb1687d518125d5f6997510fc4ae220b48fee9ff3843fdb800fbf6e7fc4cbb5561d861a99dfc337cc5b03cbd6dbf4560d5bb2398356d3e9fc54d8447290ae0d50fd3fe6bc54c311e23e16b17b6c21f53451c116a5d9d4a46e267e493bb9d839a41dd7e39b8fd10fd21b53a20906f540ff0764730fbeec7981216d9328edec8c29abb12655326dc9c619ec0b99e8d1c68200ea33608538da0bd86f040a48a18b4906665929a3fbea9f5e6fa4f5966a1e64627032493613908ecbeb5103b31b32f9b8b449e47da952e9eb09353f12543a11d948e31bfa36e741db9d406caba34884a57623d37c205c24e0055d19dc88d8500a7f35d886a49939841a5a5cf8528e8cd5f32b7c6028ba60e13ea9ad1e4e65556ccc6b0628d2bef04f969e94efd437d2f178ebf7872d5c3658d59b475f2c68a093d768e9ef60de1f9083bf4f2dc7060a9b9ef6cea5050ac3988706b512921c0798c2f6788392f168c16aff47d40e0af2d4723068ddf01ff8069c43d30b5f44a98c38b63826f8a3409684bf5a5abdfa07915107e857ac472372374136d44bb46f79548531d139b85526dfebf202316b4db74d96c0e46c681e219c8fb61bce6e10daca26d5c553e2cdf85d8f9c687e2e6d42f2fed60b0e389b30c92fcc6be1ab0463ea0d25a36248ffdcbb7a2cd483fbe33f33ea10041cf9d52c4dddeeae3367ac1e55f68587cf2a947c15c4080888a3bb4bd2c5a524b60cf1ff9bc3359b8ea39c00de630b45d7bb6818edb0cfb0dd8a2d29ea70d3e210bd9b681eaf9d3bae95eb81c987863d972ff692acfc5a97bae5666e7826d94c84a9a37b27fe89c8586c8c31895b307270dd75d8a59b8f22629d5a59323199a4d77e61110e5a89553022ab6e8a634f974de6cc6557f7ea989afe9bc070298c4da7f675f6e8e8541782a83b43efdc2b7a9530175fb0f5c14202b9691ea09dac112c639f9b3950ce4d7de6dc4c78f2c9fcb06c81a2492b16757feadc942e59d312e2a98d0b21ed8d1f43d48c28f32f0d84d899affc0cab0c56bb3afc3e0d74b13c32a70be4c17d5cbd7fd9137e0cbe2022500ca66d10dad5dac4aeaeb35f93b1aa0267b3f974ab8e19ca10e20cb115ab2350fbe83f5820c9f4418253d541f5e050b4590299e086ad79cc937b77828f9c5bd0bdd72242f912f046987f9efbbf009204a0bc31bca93a9a14d486020dafb31350e9f9587efb1d758ce941368cb1622f72aba4254c5a8952bbfa270d65b7bbeb0848723925955129dea7c8a0923c1ba16c7927b4b17460094aeb2bfe758a5d7f17edee88068ff7859e49b7827d1fae0c305271e0bace8bcc79b14ca9dd4ff41a38b0123058ab4240e7f321a63157e330444e42546a18aabcc321251f3c241a70b8e8247213462d06bec7c73197dcef568f70228e9ad0c8461b9f10e5c7636e39639039d63bbc1f3130a0e88e85fb0c955453e2e2eda3fe3511cae8c0f225f2bc3cc69869cb6af21b08c0c018ac577ce258f06cdeb40c72abd71094af13957baa2798a9979b93a972045a81a5a5bb708bda489fe6db244acfecd73fa462f09549b9b1683f79d5c501b936c7ae0b54f76f43de3202ea7fa49488adac78a1593cc756f4366c7a5029f1a1601b74d4da79efd8593990a4c00067a5d2ad07c4d43ce18528b8e3f10def4f1a41042620e41c73520a9458d29ac650b3220a1d5c4404a8ad6d2fc6cd17990eb152834b05c5ff50b49e6cdcd72ec5fd329e542626b23a786ab1bb81da0eb5d43477ac33399ca9fa8108134ab520daa269afd964a8a1da7661e9453f6325bae5f718dc750ebc1d4380300021d94471c25477e5e1088e23e2b1cd6711ac2849b5d7a16f96610c791b228382a2569eb3430e8b9994818aa0711c92dce23909d730387bc38001b3c5680d77b7c3889e2f2d492eb800dc036bec920fafcaa7216979a0acbef91fc8cc047351915b69ff544404e2dbbf816f15db02834370c4380601fe73c474a36898af9a4f37fad7bf11d086094ece8da307206b75ef0a4c11d47f9ac8d52c791ff44867a1bb0c64e0b0e766b6f60bec28cd91f8e419622336ed6eccc281eab4deea7440519febab64a5a1bc9ff865e2cb092f941a38f6f7580e4fc2d5caf8b19dfe7f0afc3fdf8a6987e52d4a318ea9115b4e5173411fee1fd6b7c6b1546a14853e0803b799b429bd4ee7c6f5ff3c9baf4102548634cacbc3368ea5bb523dc6a96809dc54ddb10675a272b22f37b800d8e01917a4574b753642832a2c3c7f47b095df67f8cae88920412e31c2f83004309ec80debdf946d5a28dc2d85bfc985fcf4c0f8033cb57aa23e935992ab3ac9969ab0f2fce54867ad3e17905175a5b69f07fbbcf828551fd00907fbac7545ea2947f6628d9e6856a68efc62c43dc91cb807769f1fa129f158802d02c25e89c1dbdd386b8ef6290b5859ad7b3fa608730ad04a32b707ffc9f0711067127dd7a4d596d83748e4dc92c346c36ecbc2fbc4d0bc3b6b526b18bffd55ce4503e119baefef0182b1c7523066b837020aab7d773b9178cef686ac42f3ae720ce038592d9b27db4e3ee432650a88e6f334ad72b939d8b985da02841cdaf1fbbf7035ff4f16bc9f090c84b3483594a6447b59244dbefe9906308286a002950a572b06b14bdaa758958d6b9195a398d6d6f1aae35b828b9afcb325b9aa6fb56e617eeab8456df31eb616ee535ca789f08138861eab84db6dba86d307a3017692157b904efe03114108bb13f63f2d5c313a7c16377be25765d63f0a4b08274312274db576deda47c4ba0f8283894fe07beec5db86c602b1e731cf9fb85f3a8712fe5e5cd795f7cca928b1aca978f6e0e702f99669270929ade519e320c681c5d3ad4c3a70525f6309c76b41623699fb56789c8501d91ca4612bdfe4824703b861767f9b6ca959e080c7e95f7fca6339a901dbf2ace0d14b9b57c35e4c8d9db28d7286c1b63a9830ef4af8829d838aa4ef30c6de9414d0130ffe6f593dc210e20b72c8609e67912108b1d6cbf0df1b4b6a4fb17bddb9e148136196d68c71e6af984eeadd423eedfda4bf5547297497ac98abb6c29051dea027efa60899857f690baa359c44c1fbff0c94820664d1e4e4d4acc56c881f16c27cf6e609ca65449ccfbbc288c5f857bdb899451caac07382a69dc83290a89a4d249c2c962bf83c05a466fd800e5b3adbf188d63245ae2ebe22b40766b52eaecf1b0c08cce97bf91d1637b9e3dc1bb0d6f2949b92252864522cd12312451ea9a09003dea74c06cb7b754a8146495191c1761f2f3905770813b52d640d6eaba2fe93900c2403a8e1559e3c5f619fae72d9e1c46076eac46345a4986aa95990122b965917fff806984aefb7fe7d46ca294e29400bfcc6a87a4485902bcaa741e93a1100b0595918ce4424c8fdc7e8644958e0d12789d9ba790854d57df38e287c7631e9b8f0b76e12267ce1c8244d86b9e866a66d855e43b44987244f1550462d111f554d41c939dd608dbebe238fef482289611c7576259969042562bef255fd5e32f925d92f2e68a673dcb64dc4ef96c63acc3eb16b59510bbbbc451cb765009ffabde218fc6c9196eed32d4e8e34cf2c26481ee22d3f07ba28d9266693a9389fe0c0605c12851efa2ac7d00cb807af231ca0deda02386382eac3aa7062edecd2e34920e541ac07284208483a0397b099f9c7389948f111f154e889bbac4aeef5cdd870482b8ecb8e54fcee604897b8aa8e759af2058a6589804927fa7e2c5d1bb0e0e58df30c97e33634d33c90a6c608396f2cf12ea245e310202a15ee78c7008ca41916ee756a81d0964b36aa01abad18ed94f9b69bd58525653887be47d57b95eefa184b1a02467ceda6f126bf42f52527b78f738c43d3e178d79582191a719cd19d959a0b5511403834547341498101983e6459431a01bccdae1fe4db52a71b728ead13421b090ae701a16eab2c4da445cd4e43cb8e233fc7bae7d47dbc99626bb906551f0aa738af3d471a761f3b3fdbf495b14e92eff4d05259dda4cfe94925fb4f95e2aca07f0309db03714dcd30d4b58f84fe747af7b10e0d3ca184500299328bb71d6a932fc63255ae1a4f48d771869901ba6330fcf4c465a3ec4da31cb75e2b7af5f389b4394dd71d5201fac8161eb08fd68898b862c46136f17ed48a2b7423c0b95b7032b7826fd54afe70cdcba10b026020857d4055d93f4bc059d2af375b7df10ac860f9fb7f3f8f67fcda10d7479f2a98e6b2695cea7e793b9f936a9f416ee7867b027d2ba37f991796255de2c5ea862e27b372c1b2e73eb1fda52aee757e383a97b0ffb1c3be8f180091b6cb30c40e9d665454867047f971b0ab3cd6c0869bc6adbc33a2aa6e27543470b39da752518ea0760bb9b2bd6206404ee2c67537ac9753ec51f9f0b859f4c074cb19bd0c069a1ea4347c2aad65930db327f218640e7c62d1e422450a27e4cff669d7e71df1bf1ae8054dc2c5cc581ebd619308abf0a41d00c3f9140bf525852064fbfe6408a57588c5f19d68a9c2264dff191e15dc62139dd3a5320ee0cdb35c4dd52079dfae736a2c71ac1b2f5089532bda334f5666747c6f65428c2b4891522d1d5afe407c17fefefcaea17dad96e115a383a465b77442a98b94241c1d74e35d0746a929541095f5e57ca6e84b0d13205751d8d65f080401b075d622a546b4bf7877c79ca17684b2528d081fec6dc7d79ddc5133bd2b4df0292c17d2be85eccc213eab61c345fa71f8b0642cca8202f4a14c4a9284a063ecd8e435d7728b529687dea5fcdb0594398806591bba1d9b9026f4ccf15b62f443163f8b0c5439667c976120375d631dd9f367f4c1b3810bfc01dff46897bf36740f74641d63cd72b5473762552a4af77a07e4c004df506f154a1891a02fd8176c73e1dc36f590d6f911d003c4a64a06c37cf3450d960d81265763b225461f6a473ec5f20dfe58ac333c7e30321cdd34bde2594058f6b9f3964538d82b7436d0aa21792d2f1b3a5d5e1b246f34eae5ad77fae8471fc4a4eadc81cf4219671035bc2475c0dafb387659118b2c129395631fe5ab6782ab74ec418236153250e96440d45eeeadb8210d4f2cb29c4cc1d2371f65f592f7f8f558e4d9250298b8de42a8641ec3fc1090aa52c6d71eeafa57adcd1a0b72bdee5e18f5657fae9a6860e34d776cdaeb1cd0477b58a7b54a7b8d92119894153ecde53d4a6cbbac53d8f9b2743bd96debf3f7e6250ee6ca0d561b6800fb56aba3305fdd079bf6b65215f32e5d4f222af75e9cacc3062ec38725564cb36205ce1913b6e6c715f6405e0c5a918f9e712c7109ad717fa8a5af66f1ebcdcce58e60b44e1e6e6682fb84970946b548aff790df817acd276ebd8bc06fb52726d05f2e23c55c80b2dbbdacb0d1fd800cbef47d4b7e8a04909af84d1e1789baa568e1c3e5f4c69139a60f4560d6ca938ca11257eb144670d774e5d252b374a3fa00f93fc0f986fbec55004fe49154429a6cb56685db0fdf37b7e0312c0728e658f0d81040417b5344c3a381974042f644a5cba6b28c8527c2288a5bb7da1b1ee2c9a43c10c9310289bbd80071e837ca12517dbb421816e24787cd6136c4199c4da5404f187750febca64ca8f54e593c12a9baad6381920abc4de9bde8de39f23efa9b569fb6002d5e5de3f3a4e2c6c55aff68c1a20607d31c0b4e0b1e7c8d9d3c1088df18cf2c34e42bc87b9e01aff45735906cf35217090032ac121b706950d74b1f723caf5025100f79381d0a419fbde8429535c523fda7b101b68ff7110a90f3795b8e6acdb59c7dea6c205b9455e277f47ec083e55761dc409d48f6ebb6ebcb6a421a36401aa4322fbdb97fa19c45dea557978db190fc46935169dc2563aa98cb7a0a882acc1fd138b4a5bf42e438222a22b721941cb92ebff6f49d3b31a05cde8607eb9f35bf9dcbbcc3003368e3d556f592e81ecb562c2a1b3f0f73b17318c85758f1df0afbf479c9d545ebfa215dacd5ce79ff6ff3528a4f844958451c1cab840968506af68888c9e5e070a4366b562861376cfe90009659ccad509191950a14478bb5a05baabf85398998dfdb97f9a3f0303b4c7f66676c5fad357033c2713aa6fdf6aff0d0dcae70a54713b2ae5c1bf59dbfac9c66543b74a00fda4d2becd1f39f26baec015ed5c41ed47e8fbbd0aa70d33f81e162ad57d7078d28dfd6f67e85196cfc90a03ae8aa0e01ebd151b1a50d146974559d7126868e846dad3849edf0b01509dc41f74fe2c592b7e58be2d8930f30980033224f3411d554a3486c9089444e4afcb92c01567c1ad26f861166f85a1b9352b6fed2bc41b3b954a51aaab1fea54e95e128e5420f6857bc8d2fc12b98fe9fbfa6f8d076ecb8e0a00099c96eddaaceaaadb6d669c6cd52ef86edbab7cda9937fcf7901f7b35b0bd6cb485d3f830eb0fc997dc446f015d9d49625ace435950041e537a4caa10c9a329725825cfdce4be1fa991be888c3f54cd33b71c7ea2b24fb2f7eb4bd6c22be8fb1d8cce0cd48dca6933ad1f49afb792c6989b79db73e6e19537444548ed2cdcf0ac7ba36cacab2728b21ae87931c29996f26c37ea9805ec7a9be22e634a0aa30d6408546112eee245f0ab4f8fbf4b8928ee0fd3e9fd9ffad34a29656eac394ae2766684491a2299b322bc0283cf1e36e476407e17b32a5b853756285a02d22f5d7f80677d9c01cfe648d8cad6f984296e31260f9abb31cffbb483737248de5704d834d9d4e1da13e57e6d1a8f1522933837ca5f42346dcf19e7a85a4be7efc88516d068a4da5805e9e1646fa6cf2cb3ae9f65e6efcdbc0aadcfd902cd7c687fd9bd2ff564d5a83d73ba25e9805239524635a88e6be1fc4ef1d28aca31e1817edf5049dde2b601bcce10dea3a253b403db3b75451b1bb9561bc8f1d4fb1d49a76b881292a4c6615d50dd9d864d8a04d895c7dd5e7202f53e7875ab23cd130b77ce54cb3717d4443580961fc874bc1213b25beef1ea4655f96b0b01550746296b9fb1ef57400c622f99ae649a6c22062c6fdba7ac16aec0e6530c6810f71e2e61c5c1a97fc9e87e3f9a6e7628fb4841032e9e6f062f4adeb63983056b93158f8c792ad1e869534bb23a68b7183f4c78d5471a20f32c8d3ecf8533bfc7045de4f949609be28e18ed1bdec8c573ad1ca18c85fff722bf8c071bf230663fb79984f916f66fdfb4f7228c59d3ee9a7e1d467ac3c41129ae6303d1fc1b571ab4db9f40b23e6f9ed7d61d073c378f9d357ba66c4175a8edbb71e437458193076230d255ce6c6a1e1dfa6d4d95f48ccc52b9626ee1285c169fad1fda493d276dd68f4766afa296617317428eeeda538fde8aead0c482d272fff6bc35202d3c278b35b39e8c6328d0a8cc4566abb681de6ec59d07215b3ffee4f2eeae924b46e4e5ba1854898119514accf01a53d6bbff8ebf285df5cfa1d37aab241f54e220b75459d23843c119ecbabaec97711ba226491b5d56bf1f9bad7a4b1fb8ef1ce5496bbd9386ef1b4f2426688682f94a310920249d4ac26ef2cecdb34f7dbf8d0971fef640609380787b1854e6817b76296aadf7f7a43e5add26e9192ab044e812306fbfd1d5bfa113a39dcc03237d4b064688cedfcdd04a2e7faad7f81f5997b119734ff47e5320d6bcf3e9195b3639afcbd516f8412f174bdc56d91e61c95ab40305c1869a012e4e1e265f9840c15507c5e820d512dd154b803105489129164fd3b5f4b8c0cd95369c7292dd2e71f7fe1700f1163d4a3e5285cb9a56f93c743bb48d1e14014c566c80d27e713c35b9558d1f6764b2d665de54fa1f7ac8e42842e9a5673fdf81404f9e964eac4f0e02a8a2c4877f34b31c5c4e1842465c2326cfc63b496b83db85724af7addca65820d9e9f157a2f43d8c01cb775330071b9bec98c0f5381605fce98a3cd3453ec1ef98dd43c4eadc95b5d8f43af79268014b227f0d72a4f95e5cba7f115bc5a5cde4ad6fc27754e15cf41972acd2529271ad88a3b54e34659bbd1da164704851fc700fc73e52814beb797e0fe9a536765e49e8a3375ff27ffd63dc1397dd9b8a09a4224cd78b99f271b945b91f2eea7dd3a95e86915fe8860d9028eb92e70698b6f9910788d452a9ca585b18d86c8532bdce555b5b6918b560bf6c9d8e077643c5d02eb78b6e83b7e4939e724136e8e893c4010f1c03ea5a982a0acd5761722464aa83f536832f668c0bcf9d5783bbb1466764de3cde8875bed2ad9d3a56db545ed0f0a4aeb2160ba1e5b0969edf09366da897df846d555efcae8d3b9b1d7cd1c199c76092191229942da575c5c5cc4e08363875a806e876f4067ff65cc5b7fd0eb9fe57b96611c5c2c076a13d2cd5b1106011d8daa4c2ea727485702e58142a9da7b03122a225daa81e0d2bbff70ad4ebc460a80e983f125f0e6c4fa4a7c78be35d6dae949163baa380888e254c5d3ce5ce1a249d36a1ddddc639a3a6178e566138e621ce9c2a1ee513a15d21ea3edfc555c531a6febb4d9d2978986ff362f5c85a4df58866af886e505044357b38a4b8b9f3ae2df400a73d3d417b9024a364421e5c07ca40cb9d8beb5a16437c834d6b0a4bdd7d58bd9f418f779cdb2b43b5ed2c0564a34df746846e8145b126f2811306045e36a83a7f6bd3d72b76589b910682d41956277d2c545e0d082a378cff900f6ec0a11d7f53201f0783cc2380505bc7a1d72abb065059efe0153c45ceecbfecc88768b02a1f50ca4c75e14c2ce0fe8d10590095b77620268f6b476979e500b23e67a0ce449d0f71ab4b6ea320fbdc7717b195ad50a6fba119c7d06d6efdbb5a196f19e163e3a5d8bebde08ef1100b8d30a48a8091dc13e5b8b33026ef28b097ff4aec78858f55b9e20f80ff048fd778bf872f68f61fdecceb4ff14a115c03a2418ab6c388065e36e0b113a8f973c8b22c857cf0ed5dcd11bca3c6ed2ebbefed71c69b8158728e22e3109d3e460d3d7a42c3380b5ed13e3fe91eabcdcba6ae21e6dcd44da70efeea68770163b5e94439aaa390971bb1cd20813432389ad4b78261e64034ace6262ccf0926602aa69249d930247a00a7030e99aff609d3c53244e70efa2965f7ecc2ea942eb2a5bc8dbe254827dc6030d4475c7183ed2e502ca7b500246af38bc903c0051d41a717fc474f2b6ad6095ce1d52dd17f330cbdd5bd370fcff27d7f066d12ece908efc59eb6941a6ded435012e7773b679d20f9a95c93ff5a5ac0181044f50002f0a69321811f13cdb816ee817d30749fc8a1307c55abdcacf16bcf52fa42e0ccc89eabf5624f95ab1d63dac1f9e225a63ec054ddc1567ff03f092069baad65cc71d012c182eab9eb8bcaba3c50168f9396a16129b9b0b21d844104cebe7221e84c5276c1dfc6e7ca1eba5842593ddaf99ff3a0d224eb77a5ed81f8ca893732740731f326b57ef35267b70f143fdae822879cbff0d661cb8bba8cf99e412545a581c2abbb00eb7bd37dd09c212ae79be94338397dfd8388b42c62fd374c9b41818eaf6e62aecc903847c88e2e1c190f081b8527dbb7c7517a16d95c66a2b71ea2872b6a694285e6dacaa0d296d4dccbc509bd51e3faae4c73c1bc56af27b42678b2f8c92ba537ef70181c9f4a0cf26402246c9a7b73d2df6e12bc70c6c7b83df036187cd29549c931027ec877a4bb8e2c961c89d2092a52c5ecf27befadd37f357852e8b17c72b752e4323869ba1830ce059255209f00a6111d13e0be86845d2fc8b5991f39c34fc18bc51954ee80edab4cbe4a422230424afe8f274da183478c2f6bf923826b7f2a5c523e4f85c5e7d91502ccc20a5b537aa0acd56f045bf67cb52f7bdad7fd8844da08ac7293aa7a1691ef4520c02555dfc5bdff41ea23130ba3cbef2d6979afe4d0dedc88673059d6782aa0119ec40c6070bb649dd53558c44aac49404355d51e91017bbae97163f6e98421f5c8f2bfa680d0d27ce1588fbec4c083ca70c25e67c3052789ee4178e444e73c0b1885538956edcf6404c0e8a56e9a8cfbca72e0fdf625892a2262caa53c89332c479b41bab202bd422dd309b1850b3d1f55f06f67b7d283017b6719a7158174488e2a3b3b21172959a4f67564d8a7c016db6eb64ff71ffd4a95cdf2644a529c9647890bc688711bebbb635ddaf95f7d9517c4f4e419363faf2b60529b12b37b068c0ebe87bcbbb02b73a94013cd62c44f8ab20256f491f3a027afd64e2e25b17ad830b2c5c3dc594bd5d825f49d36f0ab3b8d1fe040f04fa6969c54d32b1b61075618efc85357358f06f3d8afd63179269ed1ef43e048bf0c433b064deb2918c539f9196a3ff8b2d783094f9ebf37c156ac541a11fa2f8abfa5b074a1f2977d5ba381b6677bc2971fa39b52f3d3ed17c8285e1d25cdd54bf5757c977b74511795a8fd316b89152db0824cc2fbac4c7932a8e77ce4c94bd8241d2201dbf9524970505629b674cc0151d6ffde15a6f719c7139006fb6d6528a4c5f7e22f14a941c79de5312dee46c28386dcdac461eda275eba2aeed701285e81f2488f61f5a55a2e67272a2e56a403b4652826be0da7cf3d0fad9fb58a53a0b7315db4360795919f0c674785163f8f1b45aec72f05d14e4f2560732adc15229e83e4db0c06c480abadcee90e05cf8005255d33e3f29c9af33161c9f54cd4972d4eafef31b6a78cfff8629cbc3f7e12965ab1a01b05ebfe9c1623861f76273a64219931855e313f77d32475cde7f575368825998769cbc6101212283c866894c375019ce7831ed0636300c6fb0242e1408ef2b4745c3f6135b37c7f67472f5e36cc753f517cdbf7b9a7fb49b4cc1922c8985679792e60c049f89c1e321bcd4edfa8c9d710a24555558392346e01cbba9823687301fa3cc55c9b529219fbb2940bfb1e323c17ea3b70b8ac815ec731bdc9fe667432adf05dca3be3de35221f6e1078249d476b982ac3c6f93c14e32b7ee1a6d4682f372fa1bab0b379d3598eb42435da0926d64daa2851ff8cdb37526f884e625ce53b3c27db7a0319aebe8a1a7ab0d6fff0f27170079a41db8298cc7e63c80d191f2eee30fe5805ef4340c1e6e923ebad5568ca0a5a8ac6cbe00a0225a559a4b43abd7e85ebb7d7572e1e5f0f54f5342d1b80fdc78af6322641ab004587c9b34e9620aa6b7b8e26f99f46cc847282ca165902fc2163285581eff57dc772a5acc445499e79294633a12405c51e55dbb2dc36037865c5972ad77eac0f0596a922237435c012871ba0cd5d73acad2cdeda4e3fb2aa54a19c7647d0710ab92ba5f2b0b0f937d8b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
