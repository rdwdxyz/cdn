<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57ec3f14bda22a850079df710c5f3f731d5eba54f76f9dae0a5a6c828877c4020a049fe13ca01fb83dc97352ce88721d3cf9c1f2485a701d347b862c5354921f8c6b99c51d4c48f99075f68180c49424893fdb6217312aaf7ca39b5f284b5c686e45a6e4fc0e323321bb63d8c94d68b29fedbe9bdba1fd28736bcc966a6f9d19f63a2e5df9927872927ed55470069ff94124b759b740735985a538cb2acd394f9c2c63f3c8330be707992bc1f2fdb0cb59018e6c09eeb272cd75e8340757ed3a221bd6cca4ae439bc5fd1f8bd31e545a27b24d306f6c39c3a406304bba643b060acd6cf48ce3bdaea311c3adea32f62ee5536252808c7d8114e800228eb24043db02d10b43fb391ec8e1bd81af5ef5627ea1a034820637eec20d0cbcd430dbdad01762710363b328d57565ceef83d94c940720d84905ed8ee8e6f6a8b9bfdba7a1001665399b5f8c28cc57763ffe1b75dc4ec7b8c9d8e79837ad90e050c15dc968abd1326e6b6165ffcf18b26f8a7197c374930027013cabe218ce096313ce6f6dde1643b76fc7279aaf381359d133a1f5d4f22fc15f329a57afd731aae46d97afb77cc3a5e122ab58cc830154a512732aeff55d75aee1ab5a8ffebfdec151a77fecf326516da3ce393dc7212a0985d09707ea1dbd4ffbf36e43ebbbaccf2f3e605162b97937ee5171b63d9e14ba45e75fe95222dc75bc4e8c7d09f66d8cd5546421827cb66acd75178716a6504f4e6011f040a164e2ab29dd715d8c3727aef5908def2364a3fcce72db65d7dc874d61da61169f6fa46b87d39191820d0c1d7f7b87d7cdcc6a0512e9a73f498d5155d3613b222e7c82ee3e1283675f7e845e7f5033810e01b198750db0a8569a08299d268a27969e9263032ddf23c49e8b53859ebc0ba9b81f31e6dd719c91de170f1ccb9cef028f2e21c72d666484b29741fc3703344c376fa1bf428398b24d06c2ab6a85032485c278e9513d12adba20b28af628eca066a946c7ff4a7598c792f3336b4a169ba4974daf83035cf30a89857f75e4e6d413d500c43c9041254ddd0f18876d12920e0bfe1f1943392820fdc7a9d2782ca32432e18fa519e79fdaff203133681fde14e634373e3c360a9c6b0a200d520eaedaee27b9cfbc606a2cd0cf329ee273472a38780a51c4d5871a9199649bdbf83ad4c4b44e06c1a97ccebdae2f2eca41f6d89e898286a540322f5cd832e781933fcebbaad0a8197bcf5bd8cb44d9f90657508d4f3f691e41fc6136170dd15a699324e130130f19ee3a6fafe7da24b0a6d426d0a5d5f85eaf295e3a4f29ad38b54c6849531c66de854033931f39e7bf3ae03187a87f9cd90fdc7a3e7c6f50a53ec5dd1665a87f6913344b9488cb4d819799d90dfd72bb6f4ae981928e679291c8ac4bfa8583817403bb4a45d7b9b924420d8b59d7021425c7767116e6a0ba2c3aff9b99e117993e2e55a6563f4dffa5971fbfc4615d65c7bae830e57dd1a72d33f21bbb910b01a62f8d1b8c8cea8009799dc8fb710af92f8e07517936079493a30f3c9014664343d2dbe63de7e2483f26fb4b157f904d7e793ac80971ab5dd743537fec66ff4193cefecc8bd65e9ee5f4f73747950cde301ba243d6aae5ffa37a3500f2dcb783cf1de924c22c85387b19564dad5d81d2963f6bbb0d6eab4c01507396b6a6507aaccf792ce20f9859d383afb1fe43bfcf269add94ac960b3f1d94e77fcfcf235de537891c51fa9de650148937e82e15e046b8e7ac993c0c8eef620a87d74d619c619dc71138e76bdbc89e756f4d694885ee7e43452a931fb5155d38fded117346e63d69d1edb8bb0cd2020220115dad8c915a883745b4db474327391b5bbde84e70efb078569ab59b27f01d288057b54d42a014d59694a55af9ade2b064ea70d42199db814e98a8456de7d5f850eb0d3f6c8d3978bc6d876ec35a16e547bcf4d75d4d60ec8f7b3880af8f69f478296a74fe0348b7fea8a5dc0f15f95c24547cf0ca35e992131d6937dbf6372d18dd23c0ecae84ef6d3e95c576a6c61eb37264ecd303bcd93a08bb4da9f93a535a4c0946aae30a3db5232c7dc97572b4731bbb43d7d2afe735ae778f87e660418098f75c3b2e1d2709f251d227da8176d8b3012e347ef10f168deb76bf114dafe83742a995c174e2273f5debcf065006b4c93780f36a8d399f3d7b06130c68d88a1e987639938c68c3a503dbef5c910d65db98c4aea0241ddbaa5969abb4eb1630cff8643a8c33df934569cb0c4547c1ed62ed93271b7a08b2a7cc66806d5bb6f4e8ad4967c21c12446c09b68d197e6e8ed45359da564d21cb465d6b5cf2fa2246c3a935996180559cecbb52f177c3da0ba86712d3adbfd64b2a25ca97506a85ca82ad20ba6855b9cfbb01c14d189e2ef62597f2e5ceae0f75b8bb45ede56f00dcb47d09bbf388b327c4a814feba68a812a67096263dd800232daaab930172550ecfd172e8e310c1281bb6bbb5351bd26fb4c8ad2681058fc4ee24b22c24bd5d6a6da7405838014480bb60cd508ea7ef880bc778e8e82285409af2c4f907f21b9e07a9f64853931ebe0f1b48cfb6ca505418287d936f9e8ff85a908a3b65d126b9db244d9c98b1b3536b6d722533e281b977cde980df8a312299eb4a132f176db612592d09c5b0a4d1df7f3b6f71072bdb9f2d954aba103ebcdf63f22d5a54d83f3d9f384a8bb2de94596bc50093dd51d970049df44d11735b064e81d047792b36286722b8e23a5ecb44d1d80babac6b270c1c6cf2dbe6ff3e07b1bd7a89d964f798821177af9acc3dfb861db198ea89f95b383976b9ccba3bf15d2b751886410f09fe49b6b34aaee1c390aa82e51c1a329ee3f6c0f5347e04e40738d4a78df020cd62a7bfa3f7164e9d51a602eafbe5f3d3771b49b2c0162de5001586f17384c2b648d096085a3a469ccba8b74eea949f9ea94226e39e20ef1ea3e5dd83b3d5823c95ededc1a69321639e892f495a2c650bf99730bfb86793fb9aa3dab292ee34cee337718643d0658f0d5924b6f16c803c365394102e7a0f3d1f7ec319a28bed2f8dca8d462d5f3383143e33d324eacf55afca6615c6a412d707892e879454127d091091c373248aa46ed6966ac39c2f5e5e5c7519b368eb306d75a5c86b1679d00da9ce725085ec49a619b2160bc71731b4f790cb019ceca0808fc957253bbc280b1c138f6d29bac6a4c3a761e57c066d2abb1095563e03bbb65f0a3aafe5f653beef1b1ba1d223bb06dc714f3f4adca4ef9feb2e97fc40b2151d0c416366755c883ef49f3e187773d5a7d7b7153728c4eeaaebdb8808b59af4970f788d3b236802363f47015c306223817c756f3f9cac543e466f4158935654a09200a7c79bdb92a568efbc5fbc93d7ffde225b5e89704cb984b80057a003be18883a5a1cc61ab62e7b113c2da77eab68c33db5199a041e20a592fc041a7641994d46128df933d8e70041e825a34c74ca74ec6be9e2539bdd3c262f565d6366f29f887a0746d494b38ddaaa638696faa6e08ae911d29d07cfdb5584eee6d2b253dc79e01ece036089654ecf9d13fa04c99bffaaf3910569b9622809bdade04ad137c1b3cd293aa1dbcf78cb25ced76b8407aac963f60f40913bed5f55fa9d8d17cda09d3d71d5830f8c00a5f04e67ed0834025b382644fa180262347f5b3aba86b9416a2ea2db032c3dfa62a7081b7b7e1263c9bf5a6eb4452bfbdd36d8d5aed55e47eca4e6c9fb08c62b6b7306b1d84aa208176426332c97618c7b7f0136c55965137cccb5b2fc3ca259687d3e2d975edcafb779a7242f438410fd327e07292cd5bb905218381c2170f9cc046368ede5b8b8e132553c8e7df9ac9c150db4e7ccc66cc8d0bd03a3ece3297d296063c7a18bddeca7c5134e48565a4c594e9df1b47676eb35009b474bdd6833a51c069112823d17e00c60fd54b7d4272575038364b28912c4c4f5f57eafaf18eba62f44d7facc653a264aea0cdd47a9aff303f7e54033bb92fd1f3d34b09f607e5b18a20f998acdc2bf0215f6e4a0c36bbbdf71a0c8801b45fa360a448cd05ef5f5cda0c87b7c901da2174681d8af8fa588c8f9170a54f48d7c7a51e63c93feb8b404fa793602a5bb427af1dd87e0b4ce8f7ae308ef066befbd0fff5236b4ef2232e899994525447825f33d5fb445e376a7fa1ea86045b71319801f5020421cff5b29d5108ae0d099cb16f4a2f4847dffc4921e285f092ce7698938e994047613da68dc4223c934e4d77668e6c97cbf8e5adaebea65547eb7eab2a384ed08cc5d391c4d8243cc5f78130f131f66f8996dd993399cec07b4508e4836a51fc48f8b2b7fc4d73a32ee89b78b7ffeda80e5908119ffa9b1c8dd631daa7935d420ca305dff55eab75f79775d5c5cc0dfef52329b0697504d2628b85dc9561185c54310599a1989bf0e6a5ae1f694ef4f6713eefbdcfde7e4ffb991c958e3b911e7bb2abbd69610a202880c8bc866b14e158e849c83012d215f0f92d2c771ddef3f0e523dc97bd42662d2615e4e08d998b214b04a2bd62e2e6ba3e02a2425e8440c7d8a808d02beffe95546169dd62777110c557aaea7fb35b5dbef378d57014678f5b9a47dfb5fb63b3d807a2beb022df0ce06521a04318874234a8ced044fd15f75fcf8e2022420ede6f39bf11a0155e0339c22a390d56b75167df871372c554bd894c859f79427e7694e9c7f2517c7c323a1779ee188710eb4cdebe0317e1f7e7c3284845285fe0dc3875acf5cdbdcb692cccdfe64527728bb6b843c4142ba6fb491119c9ba659ac452cc65ae884f441a67c74a3f12107a7525df936c385f44a400408e0130e037a7916df5ce3fdefb7ad94cc3d92f403ee34c9f85d3674b43ddeb91ad6e7d0b93849f6a750528842be331ad76ef47a4637a63cc8927a42e154cb09833445e08bad38432f14fdb77b65d99ee35694ca834f60a32dda02355e3123e49e3cf4bf5fe27fd51d01f55ff3768a7af91f83cc5714b1ca5af3d868e4187913c040f0869baaf6c25a3f73bce72e947ed3c0d7f0dbaf8ba57b4772ebf68d740930f4045eb29f8620c7a0cd4beaf37c3d5bd1fa3344692ce84975e66decb23bfc264a6ab9ad3b3d8e3d02f2d7052c0129877568aef9d8cacfee72629bdebac73314aee35074f7ebd5af5927f504dd840278dfceac928597799a6d47fcd97fdc57a82021a6dd335c4977ef58377b802969e7325d3fd768dbb8da57d5cdc8bed87e740ea4e889e74b43923e2c404a5eeb132a3384b4ef5900de64f99e6de4e9e58465876e8c2d2c87d53d95a26ee7e41c53c52708891b7888e21549c43afa187dabf9f41d790f315eb0531bc7f916da51124eb57acfa22eac1b2a4c6a5fd5c770426f25001d10933c10d37d810a7ea3ebed2539cfc4475469ee2f8ea9df0cbf506984055849317d97a9172937b9b07e8e7862c6e9d2360b2e02b51a2bbd45c2d4f552817270139895ec129d0e2ecf588839e66dc3db5510a6ca542fa1d631853ea904a72425815170bdf52c6a42d5018321aa088c9b5027d78eb42dd5ed10bac450e4fdad09b0b9f7d7e878679b7056517d961f80595244d2541678e4378af811834d287381f77b64e91892b3fc1a6b866dc0ca7c51d26199b9f7866ecd0a32d563295577c1cf519294e54306bf8be028063fb57a5826dc762e381b70b577462a868e368a988c6e287f48dfc86bd867a8fd331e518c16de8c956b3ca770af8195e2c2f381b801e4dc01f8a73bced4f9856660ee427e7dba9e8bc14989d5ba103479fb6e0625a4c46dc7aafdfd1830ce2ae78795f84ca37a75c1c27570ef806211458cb1e9129db78be0237c8e8552248fdc1f5cc1326426df06a198d1f9978910f74f4583b25f796ec346bbaead18ffa2933ea923945219fb5358071b8d753ec8cdb68d0c3446ce81093994b9e17a070097624ad61200e73af9a76f32f162ea43dc711d7850543838713a10d6c6aed81cc15d2489f49c09e30e2d1fd95816dfd74203faa8d9cceafb20ffee03423dc36a41729827a2034f5665e15fc114eb7d3303715ecce45f17a5c4aafd4491060362de7abdd9521cda31c1e8123267b24375db47ffb5e4a664e52574a79375fc193b6a5a2c9a28038ad73d7b2f3a3ce34309fb758fbb62dcf3aec9b7a73d368417360acbcfa34b54188139c0557e152f73cf996c300784d47711b25e9ebb22e4bae1f6945cbaa055914d2c19362e1f77c56cb3403633865da2808343062a84a460c02a5e10b376fbe9be4cfa22c8844a9b59b7087558731e8b00dddd3702d9fa8f826f19c52c2f2b9600eac3c39eb85cc2bc3a002bd87a792327a548e762fd3adc0d813724c938841ea3be8f3e518698a33027a42214983211438041c9267d74720ce60167e31905d5518910ee8f30e7c9a5448bc116e9c54989b8238aae3b2f516e8626db93bacc644ac98429153f5e7c35f8c988fc8513374f99c4cfdc9be55ddb9ac289c19c0d17df88a24ede64ab74e81eceb7a22f16204f7b11ff516bd206d73389da7d6bc360121e77ae923284e5dc91e3a84fcfb0bea576c60e294279af61c2eba285f4cf3131112d9c98cf7a0f3b2b857439e5f613911c7a8848364e3ff0d75f61344d7c542325cdd75bf29ed8d7feca09d009b0f0c9184310e49e5e00d87c0d90440ed96f652934bfa768832d2ef02a71e79a224c0846832a60f0c57d19bdb210b9ce020ec19cfafb71a1658e0b1bbc28c489def3a0922c460b351ac32d3d6d10275eae9360a3c95e1ae793d66c8dbc89d7b29758b82ec30dc9bf2381b9592bee00e66892b41bffaf795e6d49b568aab7aab756dc5156ec7b1431cc3b83739fdc7dbdfeaeb0e3a2051698f052f18bae655c9f92fd3a303c7b51c1677aeb0746e04016c1eada8b2b29d5f34212a38452f00a4d3ab16ff3028d5d3f2adade6e1acfef678135952d01198a19f04e5d3170ef7812e3084c84207e0eb7046915357ce8969f45a7e7537abc392b233a75e3daf7c70dd02b69abfa9c1fd02fedcbe3859f4d097ef3c25e7e57932c02dce8cb622be73052934554fe586b5d0017eaffec960ddf35119aa6decb46ead7d017ab3473877b7dae27b71d4be8dfe4c84b4e2f08099ba47c46da2c14c3294562433dbcfc4d42a9ac0244c5053f1e993f862235fd86da311892f18c9e6e5596d264bcf5267995c79af843d77e9a9ea086e15bee3bace1baed4878b187b68812dcc2dfa99b48cdfdbcdc829e92a9986060b2d0886b7395d78c9c98349a3ad358956702ff24cd10ce297fcc4783273e5ae768afd99178b0809e754358a547accb5c6d5fe8ddf336ce05579b7e970d287014a9eaf5197d1eca33ed7cec6178c13112becf77ae2106ac6ffb854dfa137f9cacfd4eb71ef25ed46c32dd6c343300707919c96152da8870f15d67f893d9998db536aaea83b94e45b4bb40ea83f5d1e42e8472a93d03ceb1620f29a1d18fc9beb575a14c8813bce1a24645ab62817b5acd6c7a14c2cceeee3ab11147f1d78f5c75c2548ca43b6625f1c200a65e5125c9d8fde36801824c487dbdd180fb11f068bb0372b68e5efcd105d6b3b7ec78570c07be2fd556802b7386fe997f22b48774add1e084679924614359f67efe9e13ea96f7df89c1b8f262d4f8b6c26b9af1c54832d9913fb42651bce3c292c1f835f078e93cf6f460ea7f37e265e8a5db192b01fbe6ebc7e02b6b752ad6ea65a819ef1ade9578b3c535766fff3e11cbd61db07574a57605c9618adbb6725b55f6f8135b6e2169deb0b3a03051e2b350eae8d8547aa4dad2f193aef60317380556aeb2788dbf2d1dd125abc4bac6c2a62216db4018f9498f9521368c791734912f3e59b66f48ed8d8615d93bb2747c965ddf55a4c7a5fce8b86d30809a150c6028da46a403db5b3aab755451e98db24a32501902ea1a93112e33dbeb60b462d7a38062e11f3bf87a9005d60476522b103c52210dd598152be9e4d41c3f1012dfd5a8dea857a6e1101c4e35ceaa90bffcbfaf5a2a268c4adb92b109b32521037bd830f01a2fb523cb6131c712021b64af446fb88cca3ef9ca9754a6a4d27b61a9e53b692a8e0bff83c6cf2de619fbef21dd84dbcdbbebe2f8ae903215b355fedf3995add902a092a5bdd17d28b36aed8541f6e160b2c9e97b761fc3f2ac9d94ad3bbad3826b6ac0cfd8b2cd032cc03fba2fe71add4c5e157ecd5f1065a42ba9a5a399a53a9f7389524bd7dde6747d8431766e1b37b93b3452d32b7d32b0288a284af53b12441932ee847da6cd8c41f0b98a075a3b399d2c475852f1763ab3bea0202007e5cd01eef1874fb678c25741bc0a55c2ffe39d6674ea6a70c8678c4efe8cd739f10cdcae98b8a1f0a3b184dd6b7228153bcfb795ca6994f0a72eac4b347ee235459bdf309d51c88c8c2b4b16de12ff55320e3a6c374cfe849f92bb6ac7f194775b6921b9fd299e5f897d6ea10dcf31efd02d35a2c2bcfaf1057c9b9d8a9c2f7aaf630edcaa1382410cd93270db0e28f959359890d23342077929ef3d7442c7f3b5711208901b2a6c3c669407ca101852427b9fb542f5e42381b8b00447af882d5ba0f7794fb832fa465a9193bc4ea87aec031c0985ab7f65b38ba88c5362c1223d00ffe8d20e1b5ba1d2ea4a3688b5e42a9435f3ed04fa18833cb5946d53e405612c684f1004d57e05bd989ffe6fb18f87406767683cebbd5e7e4616bf45e354ab5d6409000a23e87ebd7e285903ff0024e91111bd8e44e7d190b15a903dff8bff64811eaecd366e11f253bb6b064012a7f69df533c8f2d4153c23b00632bcc7adc9bf8985f59e0b1e2d6699c0e4b5254b23f296c45f6ef358ee87d99db5d6fdfd43196b6feac7f9f798465a8e35a7e95e78d991a8b1a6e3a1151a9ba41eb67b018e99777ebb1c56f8e5c96c893c4d58cbd6eef3518da839298e64f95b93d35eeec43c071a3dd2345f78162412d8055fdd22fcece2e082134c6ea71b48017777000225359b5efcc938288bb429a598db75e147aa90abc2f73329e2124e19661184875e57874f53f426f159719f2789c0529b02730d8564e3a7b5ea4281e890a7d3f66530e1e7f270384dd51842acc774b5341a89772a9942ce29645f6c9ac2b21cee94d01dfdc9e11753d3fce25ecae3e22d85d1b18f516e75d35a128c773f220f30d9604709af2c1002ec0447f3f39cc44c2f21b7d1ac0ece8dea7a356fd2ea03cc00f7c0abc664aa89b46553de7489cdb581f2851488571a0ec67e7371d4409c6ca36e0691c0f92172057c72ed6f85f0814039b680cfc98145c2a251c83baf64f083d7da0bb648364d7688ce77c8d74bda4447e3fc922f9b45f48d2dbef589129c66134886c572ef426536a57254d54c6a0c5a5e1510396146c96915ab7648d1fff6fe1c49a05d32ff2a0294bae182927bc4f6f7bf092063305e288004667b067eeeba5762e733ef6dc79e7c838060b2616ff0c12f7006b46b606b9971cc6fb880ecf54cfa4d327759b716fc6cb7bd6e4344e096a5aeefc606e388f698bee650e2a0587069278e3f0f5d90cef479b714e15bd23281ba87bc0645ee810934938503165a1876369dbeb6dcd13975820f6d09373e281bcd662cc87b4e2f314566ee88b65158b5f04f17a6465c03f5e9960a6a3379b176c111ccfd9e72bac0d7beee41b8a1888449d0e3246a92693847433054f4fabae16a24f9e968d6f883ee357bcaf041ff68c08d2bcdbbcc8a98090fadcdd9aafd7cdaf7e78843d78e7a60e7cbb6232adad095ef5c28cd8850be4b94111b4d83d60086356eab3fef52c1a2474e36ff6f96e0b99246ae5cf15e4923878b6c898b74f17d699365a206f819ad1ab69217ad58e53473a7f0f4c528fe215d2f6c4749da2db564deaf96539be93bbee434ad34c75f2e68382b35d3065d11925d7ef5c9dda59f7d2189b71b3a7c98c4bc6af13bd90c8ab5559c0d930cacff1081ba03a19a5bc3b3a3dede99c684f3a2075eaad8b85fd17f3e6a7d2e8b301e9b109684af49b2fdb32f3824e92a2d7a5d272e5d604b47a28e0b7dbc147dbcb936f881682fe0c07201390e5b13f88e1883d0c3e95f231c1b91df159072cf1cea1a8b25208620fb0fc711f9ba0052ad098219d7d1b05231d5daea6fced409b3f0d313fd7e741b25dbb4d606f8476d5132de6dd4e383d4c4b1a94db7f60b67e7f900e62239bda407738260e9926da6bb164b5b875fed2cd6c82a54b82e59456ea9c9253cf3719a01d9ca992870641609d5f0878d49129ffd4c8edc66ea77a550ed0738d6f28053707d753ac1792f2ce1d6b7e9df908e82a593c8f6a445cb6e9b0f3592ea5c5ac9f618753dfce834cd94edef4371cc73e4d6c637aed483d17d7945d72988a6ac419f57026309106196569b9f751d2b8e895e3860e808b05aee49ad638f0faf9084d22543cc47e448c56da3de942952979ea3c9b3f9a46103a6faf0420b5d6634354be7681a4fea2f4b825713a3e5f991a5efef3e27cf5b884636bd44c486662eb44ae70354589e085add22df53117740e6a44ab1af4f4c253d14b141f1407a7325b8f404e8769f1e182d9fc894c2bda00d64274bbc891c8ed14602f6264db51c7540e8e1dfb5c37da28457c01c23bbf656f370c7f564103e8b0c21e6d23396febbe97d6a1894c96f8aac1fe08b22eb90515bd6c15fa0829c47f31537c4b8b8e0235d1fb5998a7030a33ddc076bf6e10edc4460aa0e2633811a943b4102fc09ee570412e5d19984bfe398694798b49e05e1af7a2cfd25d1dcc246ce56ad4d635ed912db97cc1e53e80c7e868d99c88decd4d2490ce0fb235c2ccade150615c98dcde73377a1ed9936fcf5e6b3cb186f3038acdead567a63256d8eba86ff51b9fe9e30fc97289b85ed5b6ee29fd3265f5a32e528124cef3bc3688d67176d54f18570dcf1799054e936744876bc0992f001a2c1efdc47c728ce5c61f77a7e6d61289b160d27b881fbd60f8c3a47ff89d020da8a848a3152fdb0e466355f4a3f190a7b94c0e8f2c459b4b58f9b28cf3863367bac3c9050714323db7624e87cb87a61ef3f6010d9bcadf03616a780e2dc729ab205f4263d72fee4fcc0cc3f784225f00fec08f7cbe35dab63377a4152f8e12100b0a460a548baefc4e9669081a249a9495c42f6105e47236a48bc082c8d9e612aa625be3b97db1490f8247443ea1fecb3916c95afa460f08110f51c864dc22216605b3d92fc93cfd4ac0369e7842ea80166552cd38b1e4e2d26e598d45081b066fe12bfa1bed5a3583ea023ff68e56b7969d9ff483abe4971d6ab9b3acf048ac9388fb7eb814228b3b2e6f4c3d301730bfab76567f578fe3fef546ce87cf107640f050e7c6b351ace4aeaa14e8041b690f403dab8b0c3e4a37e3d24dc6514e5fd66809ae6252cb8c1fea8a5de913a90638e35c37a32352b701800d9ebafbf4821ef301aae731520e8fe501b0da25259c66eb7b94df99d6af090b2f84f389d9fd89a4248ed1cab98240713aee8b5857f85aeb9e657f323f1aacacfae931d0307fdd1eadac2fb81c23a76ae98c15a0edd4f3fdfa520433eb04418324d29567dad83f9201673a3bb385a4934a12e3ace137968ef56d6bfba78a81d066d1d9f1e0c722246fa52d6044610b5a40caa129f48e206f1f693938cdb17cc5211000fe39a9204b883a9c82a37505d902c69732b4cd8fa5e2048f089f321bbbe587f68e80075b7cefe289beaa31cb155b3b8b1cb8ab63c9a1ffb3676b536f04739f903b2667a9fbe884f7aba436ce9d0f111f43dfbd95ed60aad2da4ee0149bc0729555784a9d104002b6ab71ffa2a92e251bf2b0b2880aa0c64c5d616b76230992737656890dbf46408c8152f5381399de9f4e350b100c91059557aab391b177ef5581df45f347538a433f6f3118fd9513d66795585dc7e37d87dbc88f68e22853f7fe6a26c0f8ee4efe0e70d9a91b5ab2a3560801b0b0c0d8823306cf3c68ff9a36a6aa449f8f9b7a919bd727788682ffcc1e6f1dfc7524cc442fc50648873ddc5f4ce27b4377d0122b39cb9e2a9216d05357717ab68b9bb9f50f6b706616018d8ce62061f64f17c7ef51da1179d8950429f84168753c4a67a6394bbc74a77640ddab9dba0e9ee19fdaf0b9ad03da312754c3fcb1e6cd7d06a23b6070852eccc2bc94fde7c9d4090324557b262b8a62b418c223004c34f7fbcd9d30c00c7b1b620c431b2a1b46f9e3097e1302abe47593fce43083bcb40604d8f15fc1db0bda2606db2d1b577ea6f834eab9449b317932e2a35add7e42e62b918e984e51149000735ea72d7022ce7feab20a59b475bc3f11d9798291cba3f80af8c8696b3ddbaa45e3c51dac5a093d5604967a5bc963dba51ef2eb0643b77005ae9dc9fd54d68c9d622eadd5b68402fd9938031ae1eb2bf462c35dc97020c0173b6f92978b74511c4170344e2b1a607adb628a28632986f963a39aa6ac89f00446bc37eb4da19c7ddb241ae735c4ccc28e1a960e377e9e9124e5eef16b48580dcdf4410f4a1dca804800c2c1ebed92049db4970de0db72dd3b2ed6ba331c9eb67105f358620ec8dd023f516668f9322015996dc93b13cc11855113367a36d260bd6d003f98679db24cbc96d244934444bd00b15258f4206485d49b5d551a9b2c7b995a83231e8d96b9580b7d9a66374c328ee649ab9c8592b46e3340fa83f5d24a5dd755ba4dc93f8e61f9977a1bb0f29e2bf04b397e2aa403fd338806d963b3d8e4ee9e2983bd57d58b49472e90b9c5a75061f1c68f0d1c04c1b7170c1dd0e010c6365cd77f32a09d9f1ecd8c400b1f7191f832740c3c4006a1bc002c2f782d51a07ab7a11631cda4f92f2d85f38d3aca18505d7598c81822467574da87479399c61a55865481d970e98efb2361ba37c59aa15d7c32fcbf2235e1e7254811b860ed893f2d2b02a7fc4b1db77476276dafe1edf8db3d86d007c540e2b6b5017ff8ea8bc101a4dfb53e1fc7e911cd2d72c399e8f812cc7e1825865a521b254d6469b217ee8da5824fdd5c66b819d061d9010ab6749d09df362dcd6b854f3b84c02e5b9a0b2f747857d65f76ef39377930aa3e818db542b0ded5dfbb608ecf09af2df3ccec7bb6ce022e3c922af9e4801d8b5fb2819099dfb3270459a5e3e96f76b2078d464adea943cd340fbbd1f1ba4afcb520b22a5498486f9c8a220f6e5945c44021a035128d7ffdb07d16923e4ce884510e0279d6b0631b74d6b43659ecf5db97631c09654e64b774fbd2814908083d815c7a37ff46ff931df5b7169b50406193edd5b57f16ccf65587fc7f3b430c395d0589920fe8af2fa9ec5c9095483a978c91d1f31be38af3940b1050adf654cd5a70438312b0a68a5a3725a095b9a4a1b36af7951ecc59dc4bd4ba4d201df20905600fd24e9841bbeb0dfb987e7094b50ef82e10b38a23c5d0c0fae5ae1b9c2e0cfd500dfe27c8e06593ca3b8c4757cb51eb1fb6a9933f7e492b8772c3d27758ceea33df64f3cc3de5984c51c6c37106c6a77190a3f7216d3e9374a9aaa1ff3244e736d890906a67d16e45ac1fab71e7ef3eb152450a5b33d8ec10b13526a7c8a72e04b47bafcf6d9c0c2bf597f1631b19e3263f3c8db2707b638ec138b40230a5080ac619a318fbdf351c68252f886972d75df4febd8c6fc18ccf3fdaa7ffab97ba3193bf9bc473bafc0e923ec62080f5ff2e3c1eeecf1033cbea905e7a549902967ca16403b5ac9a6cc7c445fa850f0650ceae3388092f073700f51c381ab9a9eb5ea19aa3cbec4b6796b308793d910f935ae56e632dec9334e79958fa7323e52b337c3a6a4b225ddd7108ea2dc11c69279261ee156644367378ac70f0645b662f530cc7d8dcd3183a54135734d00ccf2bb2e700fa3c698a11c9859d6c64afe4b288c68aebea2bee014bd5948186e79da3173e8669a470a8d530a086757633fcde4fe08a9f41c5b6639081770d27dee2a69c6ff06f478d1ae3c825281f6584609f137b508685d52a25fe98e5a685412d6b9bdc965b050f238ca821d322721764fc5a618b942b0c3706b680d518dbd7e0019733168062992ed22e8a205d0803f1b78f685b2937eec68d9b3c65a06b4e900a411febd2cd58777e4543a8d1d64c4a64f798d2e2aaedd9e65fc33c461f5fcd863d11f7cd2679464132f8407d19a57c5d68b0ea00b2a9c973644174ff8bb544455f4c41a662413aee55c53ad507e93c9f9ddfc13aa756a49e192edb214728247cb23db2b7cd5c1719fdd28682cae999ed6553f3c4352844135c08895d3304fb67f527ec618e23df9e94fe1ac650b447fec019c610655d0d7b94a1d83107998873d13bff89400014cc7242cf2a704584b552782738fd95d2732df44629bc5b6e24f60e6273cb69528b852616f4377c5ee1e3cda84ae58dc4b76bf73bb1dbb50b9a680112a25df15c87b2ae30460a85626e465ba268520ffb7e0047be7a4cfb5b5176d7050788718738937f8cd1ebf7f45b63bf4f53ae6ecc8effadbec66fc1bfcdc3374cf97ff3a61853503c9c0afa1c3f1046af5ea2e82d01391e6bc143126c39c69b693fa768e439e825954d8c6003280436894eeb68686ee50aa78feaefea196f3f725ff70851f5713cc14983e333196b9fc2b672055ccf760edb4c38177ef9307bd4192f7c001195d49eea8eb5dcd371c6c1b37e760ebafd10bdd3580a56c6a92285af982d41e4715b94dd89915856db3e0d512c8f0a38e942546d0a6fe5a9b64920afc9e1b44e5e98bae3ccbac6cc40c6072f817e11b30865cb7e94a48ee45354d68a9d20826534bccfd8bfcc7b859ae028f57d2fd905ab88cfd3baaee853f1ce19f05aff0d340e632fc974d3eef512a211809c8f9bbdddc7c21ec546d684401e6f13616374075f954eba0ecb058149031f01b98e57e0c3f1cc24e3cff3a063e656e22c196261fcad48ac91773fe2a70e7fe427d9bb8eb21b33df72b8032da2c6e12ce91a23be6f369ab2b766d226df3aff7848afebea7cadf6774c598c67f475d362b6c58b1fdfeec865efd5edf33b547846a40e0db867082f66f55af09e0e57ac333347640a07a298a774b0718651eb58792b58de1f290","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
