<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b000562ca4404a111d42f1958e50ff2cfb1e7fec41500d7acd43e7f18b448d91c5262f9cb74d06d3489154fbe94361b581498dbb66145a92bc634a5fb798f1085c101957b5eea0efdf9279d5d351fe511e8fea5c548f943d1357b1b474256ea6113180e4e12335cd7cd9adfb1c69ecf378d7c3002de30696b482a95f8b85d40a38ddc9f32d5008e6db656079edd6abfd022ba1564b572d23e0d21cc20fc67ceac8903d2d4f7086eba12e6164b2d8971b48b267bcbf86dfb50ba53bf304b1b973e811c06c278a376fad03b4c24ed00c5cd0ae90035089618fd89571bfea0c0d98ef7319ba3faad029d51cc4aa9aaba3125508d06fd9c643c44fe864b1c2547ef7311632008418a59a07f799142014c8b26093ae6e6bfa6dd767ad7bea38d600133e9d42bdd6f923097dcc868f9c13d80d7fb64e5b1d79126836a9237945ad17434f7b97f8be2dc97db8fede76c4235e730613077fda3402ef8737a92ccb1209d8bc62227275c2da21ccba93747bd69bdbb9dba916ecd0bbbd4099e1a3e49731c61e59090e20c13b05b65b78c90774063ab30da1295659a87b6acf8bf1c24c4cf407bb88970f6124a0387727456f9841e5ae1bfe0dc99909c6351e8ea3c93e5fef3be92e224b47f0ebf4ee842f0f5c7b6964a4fa1f51182fb3dbdf3d852d51d0e9a82e8b0ae3f2c9cf67aa2fe1158b0b66cfe0d3bb43ec2b52156bf22229746e1ff3120a368bec0ceaad547b277d1561fe6851ed90ca6d53c98f502864d0965179da1a150e97ec2bdc9e64b01e8176a93c5ee0e05e95a53731b8f49e3957f3cd525283ac2759c0ccf60c9942cbbbfdd10f8ce21514b7df0f0dec530b5d42fc2c246d4a18d588c81cd4f6852042332af77aadf94361d885c02df00927e323d25ee83306191fb9b822f4a1d5be78ca19bca5c1b972497e7df63da4a6b2060b3c4c92972faae007eb40636a8aa85b8b8b84c631480c7512032771f8e279ab74422ef435376708ba457e3b87e3fb1aae33ec831263ca3b877dbf74701f42ff8689dd452f977f549cc5a7e8a015d435fc0a93b02cbfc7ebae67cc4d0183c9995e168cc80ef39c419d23aa04a0684960f199b583f02bbb766b93fbe3c077b25f2f6c880fcb27f90b909f1c44e7a6b4a35f586011691bb8250a786a7982442c2856503edc857fb24da29d4541e1757a31c0c72d619abdaea635cea82540b5ae82e024fc5c2691f776cd20e636928ca864cf35cff9980d8af33e466e84be1565b7d83c8e2190fca4884ec9a81ae9e6fa547ad04fbc7d899808f818924b44a74f0e56b037cf06f5943e1ba5f256423f8a8d2947752b2aca5a8930442328d6dd385446b9b36cc9d788f21bf42c1ac6a19caa0147ea27478e12c9941d01f5dc9e9b64f795f616f84790c30fce88af8f03c03a80a11708ae2caecfe36269e7205b1758ba021aeba49d6179012d92a115af09d4fa91420ff4d81d1a53a2c4c661d3e6ab4caf0e4d0cbab274a8292bc393fddaa5ef80fd1020c0089303ba11c5af88330228950b8731954d624f352198c62e8207f70cf69cbf861180f62c1a936d3ba0e1803368cc45f9113f9ce38cd89ab3a4d133ea3479f6ac1fb5d0089a1245e227708fd6acbe4fc09e4e8b8b54ad1742ddb5aab319cbbb8d2d6bc09e4af68de3ed9906541d718e010ceae9e89ae0ce3f66a7637fc0817819bfbaa397d083f0b448e3bd6ffd424d348165c6fa7b4ab3458777c5246944dd08756726f30ca4eaba62f6aa3838f78380343fd9c21d170c22ae243194459ab9c76176e5e837f09d46706c63edcf55a6654143fe3cfec5124b26e66f04f4cc2ad0c1e944104391db31adac5f061c5d465479d077084ac467b5351deac87551e72480d52d9c6a739cee6f58e4a95149bb0b7328968d80b30699396f8ab36f9f7501f08681ddc26ecced38cd13a7ec6252b3e1118a589b65840b582372138d15f9e9a504ce3ae4e1e26e18525a9b34d8320693093a16046d6d7bd6267fb6b779b57c182f3f0da2141d6f8a6b0da58e3a0cfa1b11f5a4691ee61a6396cab8a98160ff2b8dfd1e803ad5f6b2353eb94340eed3ec373454c222d285e86a761d460687f1164eac42c0f5c81aea6b319819695479a373ae3d4e59011e06b877a1bc49bba0edf9a2273e822eb7dcc9956fe8d2fa31105f41e0f4b52496f862813f64f32f46b9685b621b1b78b539ce9d44e3bc6444c356783926575647e6ad0652d19c5d905e166c88bd562e04f7c26dfa213726306e5a1db9d3d2374a201e096b35804c324075929230dce8bdf939b0bbef507485f6a052d84ce60d6a02c74340e87cfb0e3673a23d0a1d7a0f67f9085b8d37453fa5d1a8035070451489f2f4fb535358987aba5cda8e24a0787e268a99f2dfc159409ab250eee5d3ac5024a0e41516a6b90cdacdec56cffac6cdd6bd9c1255905399175a2d2ab6509dab66b478fb9a7c5d0336b444f1a257a09f5e2d6ddde32c357cbf8a9b5e270ef226c736ae70cc727b3d69ad3702fa2fb5bfdcec8864b71e7fc95cc0b006d621f25bd6bf0d63425b26a03fe29e116e225419b09b66d5de57758559fd5a051c4967cf5afbf0fc5aeef38539e90a02345abf6f4f10fbb8c961063e1cf3a60b769a3ba47c5c5502e81049c48620e784479e88f8457f6ef91abd7e5a40a025c1a306856f594b489e763169ea379afa03df2b9b1f6e225287a1595281797d357d8a303a394f29072995dadd8c5a1c484e818cd5b1da6de2f39edb0bd50c1029b027594e1664010eaa10ea6c7c8d42eaeda766c629df742c7945eab9f9b62ff2dffc08070eccb4d9fe2791605bc48f2b122478d93a968d348a656ef613f1a64c04219a05d09259033c46fcc1ea4ba91e7b8c7c812a1bcb00d5d1f15bdb78fef1f655a295fabab1614a2962c127f481b74c32db1f92628f87e758598c49c565e4a0b32c41d0840c8eba1dc12076b7b45c32b53236da730031a241790856d13650be7764ad9a142bfb621ff16f1674c26e9169995d937daf04187df7cf48255aab889c0c3057516ae6e4c7fa53a166ece389045544d40c98e00ae2fe2cf54251470294644a159ea889068d6b87204345275c79274ab465ceffb92bb7a861002cb345b69faba3a93927b37a6c0eb9db8f9a6e1b65c7375515ea091d26a5c3b705c0473f0bc77a06167d90461b5667759fb3bd962632d797552e0d826b4191acea65a741faa747395b5cbbdd3e563db835c15ba1690bfc5a7999181a99ff5db8d0e4c0afe943a655ff8d1278f1fab51cdbf7f7534aa96a0629ee57189ad3426f5524325875385e693824c91d8993320302ab69b2ae548443551cde2717f840f3c2dff8e5844ba8e71f8a0ed5215a0c522ea81ca85f43ed3f653a6e8403c54091b876a95b2adead017b8fcc2cdf87cbfc6fabe1c1f9ee068fee8e392bb7b95cb698c04dcd7eea28af515b4564f438718252ee61a466eef780b4731f87a8486eea3b35af22e93aeccd42815e35e56965e412961086cef5873c9c1276c0e2a1e33f0427220923f9ec48df1bdbd1af234939ba16c327aabd7c8e0ad42288cbef14a4795b968a59773f90c5e47f008e02e72eb9e6691c3bfcc13f3e3cad76d98c6be55c8d1d768aca6ad68d5799b0164c8b92cb50c34bfd9bad54f9fec8ec29d1f74efd7192a3e4c3bb6c0a65dbdc027f40be54b29aad2a4c06648681bc881b7f0e3d0b0e5ddf92c5a121802512c1c09abcef114dd640a9da34b6dc167c6e0dca605f05ba266272026d1275a8e262274d17271eaf1b4a645ba089eccde2d99678f70964c974b3826d23d6926e0422515d0a68fa93de2c2220f6bc82cd22b60f93ccd27060586a3a5ce51cb4f7495133e4043efc09ffd3eee3fbe1b4bd5fb403fa45ff07e76bbef9402a282fecd88f34c5fa24f228d548b3485c26dd000dae03e1e3b11034648c68b6cea70270a4c095d5307de14e89e11aacbc08e4a503d9c453cc7762999d976aa4b601e9383983cdf731929e8de09cad9b617bb2e4f8ee38647b1b48185955746135d302f6f7ea06299d6866615d469bc661c818cc04e4da3ec7a97c38fc238d291f7abf48c9deaec71ad18b491f73f9127ccd5f24bfab7b6812e9592a0588530aa28b41b3bc230a9c8f471a1f0ce88ccf0e24c48baaa4267b061ad95050aaeec21073c18148c38732769a6757c61d1dafe406758ae3927ccba3cbc7fc469d3b9a9e4f391b15c6f93283eb986211ae9a2da007c9f4e5e3cb3745cad6cfdf0607b35ec735361967ddad1e3a09fe472e2f9c5fecad49ef85de2e8bd839128474037238f54d035329b29768c94ece47d51774e28cc7c356e3777e3597ce0f6453faa2e3e6c02cf1eec63ec82cdaeda0bf18265f5224211e560cce8897a59fedbcc52c16fb8ea3d48fb8560f5106619d1ecd670be479229bb7b3426b165bf651b0f4604d96ad401d4a81de0bd5cc67b4c9498e94651fefd4a1ee003b6e1d02c76e736540c8b02cfdeb3c48e8d29afb0dbca0dd7567afc2ee66b2752afe0139b1941617b69ae90fe56b5e51e038870497017408038e02e644cb502e78f2780e176e4315ec6c5fefc309d5e25af1d2e2cd4f15a79340a2df54b113fe25c6c6d278c8ac88c76760cab6758d6b537717635318f377846f4b8a6ae507bb836425444f7ab8d3eac5b36aec4082d48f58d3412b80a9399383652ee5f82439f5592562c54a519c4248663fd65334fcd30ab268a358351232c1b5604638585fca7dd9fb4c890eaebd69e700401d49cae988aa0c80ba59e79b76e1a794d4df001cf7e9b803ffe604928714e074517fc2bc7ba213dab3a04f97c90dd09ca3c777d12bb57e8cde666a3d3fb0ef617e9246d6f6e2a55c09addb816b2fc59e7b6e64a0bb42ff63526649ab5ffaebfa37601be4b0c60b5b78feb074965a66d913fcb4abdae06a2eb4c6f6d30519feedc4c4453e10da3efb2087d64ded5b656d396933829ada716dfaebbc1ab76bd8eae875f5a87f2d4fb0115a581215ae2a0eb51f908eed06b66ee4d0592fd2ebe7d3100329cdb68f3ddb23d0d736ac24b16f7b201d720734599901ffbe361da54c776f1df262ac8187316882d15775a78c3c24b9532b7d03f8a7a0e29f3ce200f04b49ec130cd47af66758d7d0de80c64df8006778c194d8dada67de3ce5b32e11df48f4efcd68539c210f51e4215373008df8cfa559fae2a9631c785eae5cec04d737fee91348c24d4e900930f4fa8b57358dd67f104115c2abf509063f50fbc719b8cc352c37f70b0dfa0ed75117c32bdb7e07906c9b23cd7129deee94d42d1f157e0333a217ad6b0e30f98a2490fe1770f9de38d945c04fdce3babd12a3b89e9b8286e57feb14557c32edd3793fda2f98300b4eb33f8f74949a12f639d20581c14d19c87e238414eb150af27646ee87b0d104db080c62936ba1b330556add7f331945ee91dca26f59dc78821573eccf2e12ad48d5de1fa876e7b7a8721f24af8bff4cf30e72a999a8556523b3eae0291217ef49e0fc876a433cd5926721c66c2b484caa45d63b0fa0a4fb08c91e5f8fe6f37425c8149f3c19608d7f583d851d9cf53df031aefafa2426758f77363fe85b6cfa4869c05c8e90f9f185f3c4f0faedd8e660242ededbd49415b8ba15b373d49463d6540d72a470d87627b1799a180233917dc37c3286c9dbb03c281300f2dfb1c2a507217bf7ba765d394e0573727834c170641995640a9ab19a2e4095cc15d669804538bc9097c228796fb4f3c13d35f21570005b0d33a28bfe887302e3d4f0854c72003e4c1c144eb405ceafe4a40f0c8d77046675db70f72d7b08b157e45ca9ecd8a4f4736a30ade53ffd8f402e19fd5e5f3368a94f3abbffcfdccc99e8227b17762d1b406eede42c3c29be5edd11f58cb40755e338cf7ee6cb83182d31a78d073a41a16c2585fcd6d7ea3ab8b8b842501b12a0d65905602d0b9c8b440eec5d4d34e09b7c5577d26794498cc4089e4e44cbc2923481ae7363b093d4776c560d0b074e9bfabf1299c1b076d19efd47b0a9899257e7696ddfe4a165cbe139cecd33739f9ef930af81e6c7d3f50a903e267c7100df9dabedb3867d7944fe3a5ac4d53259374cdac31e4450dbf793620082dca338ae41ff56a7317a1868fd13b360e4fc8952b06f4777913829a4a2579df12ded87a955c15784e14ca8868c58367257a858816d3fba18179ac499d55b9d5b26c48d97558ff1eccf800f5c9e726028e52a638745a8c250548c19d1b4a0e3cfc840b62f514d41aba31470e60e1dcb1520344d9b01f4405acabd91e71db5f2a9958343f030e8ac958b192e0e1f0ff61b1af91151a2389c99a98f8d64537274b7743c4673f1a74e0f2c49923c3d46ce78c616f954b3a083122d721d2bbe831126381dbf454be3520e70dd8d28037dcfe02f78f95459e545bd8c01c5cfdd75ccd21c478c77d968a20b62d42a344c388c8997e0b680101fd49fd557d310cf903f31cce0d0f10e34ec672e4a05975f74cf6a8c84bc386a83ef0d3f7e6106dd9b7d5ea759f313778489ac6e4be0a66643654c4d241e9ad0b4db3976fad2451a5782b1a59d75c67bc8f40542b4cea2d3e9c74c155d1f7bae072fd7818bc19290cf8900a0ea9068657b2f484d04c17190db9f9f5a9c723e75dfa5cabade38ca9f57ac9e34101b9780ff161fc371dfd32c4f906de3e558558cf562214f2b2392e0a1a7a655128bc80e234eab4ba30afec6ec52a35fbf5ac639b8a6ea3b46fc53c4a2ef5f0df20439922216277da5deb80b6c1e9d86eac8488c529a2254cac924c0b0dfed57492563da472f0658df92899893fdf7f4e2041b117408744b253f2f0fe8a3f2b288202972d95fc97558ccee0149907601d7b0d38a575fdc40fbce387f015cb66576005b2668658f8a99763855d5e49b784188932217f4061bb75a8ec50edf783f981c6b6301717731cd5b5812a59107b99dd4e74364076366f895e9c44ee3658440ac36d2218b3bcd4064e78fe6eaa5289a2400dd5a31d4aa17280e5a37f1c77ad632eb29448cbf777092af7bf027c0ae0f2011aeffd6661d02bd8125eac90d44012eaf118f31a74cdfc3696ff5db9f5e0518d5ef7847ba571f08d64eb6192eeb93cd6d936fafe84e5cda0e270db7c23a18a6aa68ae47e26754844f1fea4d0b60da473fb9cef30fff8a93c23d0cdeb8372319e2576fc78b8f931049c033114d0f4fa2579205897adc7f38a579b1c6a2db5da31b892b3991d09810cb7975f640d3eb09b2133b5abbf31e2f225108d20da3379ccecc35d9825fb778661a919d7aa18df5e60b042e9cba6984b3e0e9b0f75e9b6468eea20bc5e86bafe7929e615bed8e89a43a2b6887469051e2787ecea3b4f3495535fd0eb2d59687d0deedf1826f749f09fe11cff45f48f321913e7f4c1e818b412d1fb23434f42dc51733ccc722cfd37fdc8d9ae1f87200909c87e621df89753972678f73361d8309d93528f03796287c25959636a8198e041a82809eb4a441836529d65fa96a73eebb112a2b9be3756f3d213c3bcbc1730dd2e6c5925630debd7363258aead4a54775a54b09aefa4fdb9fafbbca7d307b35a63cf703b00336c59426005fe8884f5a75ee6d5ba98ebe8aa2856973d1828ce05f8829feb50a14dda49d222cc08a406ccee851a36e3c8f821bf1f509b215f3c0b27ebac41019c1ca19fbe40ca9bf673a874eca48eaadd108f01f71f0569c1a6971f1dfbaa6738bb35857f6df668064d5a3a67556dba8434d32c4f38a96f4381f41a900b24b87c6761f26e84856792c5a4dc416d758ba668b04a73ceecf7e9e1b04354979f05b22ce66bad0c147c7dfce86d6d98ba75650df9e163420d8e59ea62d1774e62388d8fa642d7be7686e64fc0a01f5759ef81bb515e5b87b24cbee2df919440600ea40c63d66d3f45ad44c374ff4833be1a41152b0ac92b01e244940d8f667714eb158690bd4b7b6380bb1deac67e0342ebb1deaf56311d7da93e2139792b31dbd96e1f47184771a2d3d87197b7e03ac61e19ece909a98188e2aeff84c988393e9ad3857dc735be6059050a6b725c23dc1e7b8cf23536c92e4ddd04a4f4a903fd92a649ad3ba6dfbbfff22f4cb4d1832dd6907ecfa27bd5618b72c7d9713b89c063b129caf3b7c40dc8d1cb74a8e85dc5349169616b8c3bfbd28920689d723966dc3de8e3f00c6a6b52df1616af168fb63d6ebbb163f447205aad2ecc1b3d9bc5636b1aa49d98456bbedb16c1865ace29a8f864ef1f00e8156e9f12e1f5de2f2cbafa84b056656c502266ce83a73d5ddfe67600e258da560019d051dd2b90827942f9309fb47260d92328e45a785a7d7c9b7f268672ffd3e316615fd3f45c3d4f850bd789f2e07908d58f1af7c3ad00fa0b5a9bc4757c67b08d49e05a8f9db2121153e2373b26ef1fb8c103828bd100d101af7f2d5ffa6708a0a6ef2b6dbad5b7284200944b83432c3ca0616196d2b45485a7eef09dfb05b99bb8878352b18cefc6161dcb492bc476f2e08789acde5707a56a606cfed9377456bc1ebba97ecdd188a2b0a0119f0913796357f2004be7eb88d6e44adfbb40c300e4bbe419a4201f31f31e837a70bcaf71949d978b6cef153ef14e584fa5b4ad46081750934635429bf46b997cac342e353433cc5ea04a9de6a6da6d7e1903782cc7228d287d1ef6666e19d8c05d070e0e2932428c63ab95c6088b7d7402361d15b148c51e58b101e6221e41cffb6d31715633fd4858ebf4c0828cd77e88187d7da13f7aad4bb16588475631cc4dd2e0aab2f3b5f91d72479d9eedc4eb00119ded4c1eb9ead6f5341feb796964f22fdda560ead24a8c8f4fbf73f0ba582272923e5e4697282bda18b1764428d0a0b3b4467f44b38a36a6ab7dc3fb3e3d6bba758dd0943d3e62b02ca35fc59a6f3888340ca329e63fcae99bc33cc8cbaebee54765082cd587820f9a1b55aebc3d4d050280c681663f0495740e5f6b3e585e35a28a67207a476a57f10877296032cb511b3cf21f90342ad50f0bc1b7c7c49d5c833d5a977a6e8b7eb644b202b2b190e520753d8065ad47e7a89f1dec43dc6779d7c7b013edc2569496c9860e3074ae44ab56074571ca142ee4eaa5ad4c26b2d19ae4657ab4ad2a6c0544b0df03a0a59d1e4ae7c3c9162a543eca84f85d3e27ac8222f0f7850f427aaf696d1f9b0e98311a84b440f94d0bebbfa8cd179babe78aa8eb954995d0557646dde855f82adc0560f31b4df54dfe91c5c5c3de0ae3dc5643fb4de214fa4eaac3bdb59daf82247b563c9883bcd28bf9edad7bc55c749ff2251848ca0a37f1dcec1faac9867c14ec64b11e1107c968bd6a8533f128b126f130a8b182d4ecc65d6a9febaf1beb3ed3473c4943b4af7b582cc5af6b7e1494069586bbacc1d635516134cd95c06e4c0f7b112457261f41a3a0cc2a476724026d1b8027dd4c9deb817554f1d4eea83090bff01ad196878b3c663e92045f253e23506c59d73106ee31d528fe1c9d46e3f33bdcdddb810dd8ef20552a4476bee9b342045e48fd3a14cea514fbb71bc717fd302a5bfebc64d6f4480ca65487d992759546a7a704ffd151a7aba0277a5f81e1fcdd004b412376173ac81a9dd7f7f2bc37023f2f8b32e1cbaa4ad95db6f6e631805b37439ac7f258edcf377201fa0df8d7b3d04911329f7fa1ffa148638e9fb9f18f4c3fa72c34866ed3c6269ab3f596def7e9252e371981cc535e05bfa21c52f7ab62a39c80f1f516441866e4fbc165a140e2918f20f34af9bfbaff9272d1da860f3480ccc671414fd8f83e13f290955a9f2bdb5eb034c13c652a3a63feb085083b3fffc5d61034f3168f0f7f2fbb8fb2d836e53d41f64236a90b7b7b79418ca4e07d1a83749aa004238ef824c2c3f63a96fe7d655fccbb38e097b209c09cc5f44a3418636510489101c1f826e14dc9e442467bf9d789bb22ffd074bb525b1decc8053da3d4e6fc01d67bd65fd80e96d1c6238083df6837ce1be053005998f4bea6f85879a1472ad5174285f59baadb4ca82c485df7d48dffe7e58ee0f09171bdd13f422636644b1b5f0661629c4194adbea257b30a7a0afb3fe4eb6344d6c33cd30c61212c9626c33e9ee62cbdcf53c56516ffb909bf7f8e7d1026d258fbaa7ee290a5313b2289fbb17a339633938693958afdbd1961f93f6fb8c4f146fff54d8637f886ee07b3c3f22ce33cf9c3b988bcae70e5286dc74500f1bfc70714bedb6309e3ffbc03682abf63d81db106e1c4db5179d520a88b7893cecd1ded69bc8c9f3d5f4dd15036b6216cc0c37db4ba1429e16045659060fe7306ff0b21a6dc836b32a270560d53d076ad3687302c33c798963c48bb7086395f13ad4c5a36d36f79b92618d0a7c9b2fe33bf1ea4c74ca5740c23c1a01d05690664b98a488c93494c441965dce543c0b617683a0b7218e2cb577d0efc851be16290a7dd1391243e7e6f1cff575a267c5269914b1f6646f040a9176eb2bdddf0c209dca5622859562dd109fc083ec8149274e9b1a426c479e8c5c0c320f41a9fddfc0120f2872afef0450f32b5acb9013b75b566dc555887ba48b7aad44755c7fb3bb8dc9377fe1bc242e2ef076420532a5e1206e301b681a7a60a2148f411f09be95ee7f0347b04ee5900a0f67475174dfbd543cc216c48b300bf331b5e166b1ef43d784147ac9435d75b9e0423de607e7ebfbd3e3928e571213fe2e11dd5bf34b8ff715198962f20f62fa18ad2183babd50d8c04f80a589d4b77396e6446de73a05b4703e97a446c665df88386f2cc1abd4535330ab41316dc31d39f0bb6a1eb2b9af085508273dcf31d66e0a5a4626cca29c0b420bdf2cc9831d6d0121c8964006a385f6e00f5237339d61c0ea6a30121ceffd93520df662d1a761f31bc883ff8567aaa190fee397fd454d2fd69534c302aeb3a1758c7c971f72e6ed19db731e6c5b203765696e9d821b7e1dfe61805a865cdc418c7857ee5f11ce4a92b7bb681711459349245e94b087b2959f404bb7bc80a1f8fde81e0aacf19560604f5ed900a22d4c7dc68739b3606cd55aca3a068cdb08da28d53a7e966b443606997ab3269db678c6f8115d3e5d22faa591a4fa22bb63b4d6aad289a5c66c8e260c5f05a8b8e752b6de5acea5216a0ec79b9da787ee5b6db960a7813bfad79429be60052b27e26fc043e2dfbbf2388e655342fb39f6e42a592addaf106fe1205bb89f9e4909eb040b757da7b87161bc751d1b14386e61edcc627c803210cebf369d9d5693ac1ef30c36d58a384ec0763c94ef8eeb519c14fa8f5888eb545d9db66ebe63d40f60cf71f41fa8feaed21ba15d31acfe0b38e95976b56b39e151b8dc390f035ba2c20309888bdc5c56a5e5794277aaa677020734f425f9765ff14e721bbf8ba4d5bb88cf1d959e75878e94ffec18a226f02d9ad324245f04a4fe05587b494f096ece5529b0559a7cb3ae2c93c6c3f014a947094ad4a9f8e3e6aa78e1f3061ce003dd8e1d21579888d493218124547fdb6e8e5fe924cd5d44efe143bbc4a049d760aad1eadc385c05d77da8851493b4aa9845aeaf067b0be9d3cba8aa786c4a17200d1b756081d77391202f9b802b21f3dfcfa2e602e60a49e226c09dc5164872dccc81b311e27f035f2ed1b5adfef251e6b3f0ed68d4eb662aef9095e9caa8bad43689d23f386d85dcd460be924eca1c1b6eb28ecf513d2a510ec458a1a8ee82e6e922b921a654bbfb9edd85cf6d19447992e9fd80c0016093b153326df052e6a69c609ca58780360bab106c1c39e61ce105ee768ffebd88c37b7de8afa68335583e13206b29838ff000458aa3928b661dece5aaa4493779bf6c1eb73559d57da4ff2efd9c89e128df5055d23dbaf256786c3ce84651bfdcb01be9dd859899729369f0cc6d3b9dea67a203c85f2a70f7a343bf172f74ee1babe2bc1298d14b2fc1ef6b17aba89ef8dc1696253730a97701f26513bf71f94712f7cdc9f28f833321bc13bdad0f0a765a086d1cbdfdab6056ec3d70fa09fd70382a5c3125554d6211caa094e4919da1b3ef6572a8f5c2f3cc65262d3c493d99b252ce3badc3f38810bcb0505918ed3a54870957406dfcd0896bb26a2aa2e9f23e725e79dc178150e2a4aff847d922841bfe2df213ed3ac248689159c0d03bfed7e4aebda9ce7fccabb500d9a7aae1fb243e7dbdc5dd67b613c4a80a8f7ebb07a46a6a82180c6c8a448b0fe9a9fd4429853c596a0a32dfc4699d106fb4bfc539ca082f1458296d1b4f03d0bfb359a36100ab69f00cf9bd672b14255b82737cd0c9af4086e823af3aea2ac710a70e5268ea8d3965160bab20d56ee913c22802f9cb8b4a5e461aba2590f620f63a7996207230b596ee4e8555b3de770245446d9e0c21b133534f690ec97cfb7d8de03c842a6b9b870ebe845bbeef8694015e23ca2b66aea9336c668aa6ed385678c3a9d9c18df78b42a4461613ac7e57de81946dd4dfc5eb4795c388956b0d691905e4253cce7ff92c5cd669898a7663696c4a324cb7aba531f1f328485526378349349dc5eda220f62dc215f133675a1b4017c69ea65d032c8cd985099ab2f202c18963e571972a2afc2434fcd68cc02540f7cb07e122f3ad48674607cf0328bb0e693a0f0315fb1a3fe25339641f5505c9015293587dc9985ed4466bf9917ca58ef33e72a647d2d008662677e21dd04a165b4ef985ad0b300a36494b46fe9433451ab7d1a68044164ac6089ba75b658fc463e1c6ffa54ea4b4a245d014ec0f723ad3b138da036d513c62f4b054e32541ebc2e6fd493830c92f000eebef2e337ebac93bbfbca30e0ce40e6b2b9bd8e283ea0534b6c39fbe73c4356c50822adfa54a3fadddc9f9a4e3c297710f538e58c3faeb42ae67c419005014642e9469d5c9ef10faea8718e0c28aea203fe182a9a4dc15a8ff6d242eecfab933b1d2b6c6557a14af31abf15efa2f9e2f803e0a79396db9e57a7a559182f5cd0451327fc5f28631a63db5b7e8b87135cdcafd4e201724249e92b784f3d7ab7f3d7719d9050d7674b8deed442f665d9a1f12f96932ca4ddabc3338c3ec495644dfd30a92f48cabcac19b89a85acd081eac76fd74cc40bd9a4954a2255e4e0602c2ceaa16de69c4859847fcda664739133a5313a4fe61bf034233801f797d3cd439fdc80c36adaa941eb28c0833fe311404d1c1c8d8d3de309633c9e1b03e7ace135ebdc75fd35fd853c993e4daf501e3c0638281529ab54243eef5bc9f5ba0f39cfc1f7a12e4a97243e4d27f4c50baefb3daa99a30740506ead94c99774732c7d035fcaeaa0276d3df1c7b1a2da2c5d1c739a378110849bdea874d9321a4dfa318cb6928c878cc6988ebf8e667dae1409051ee1aa3363727c8705bef25c696354c4fd1299b20a5d94775fc4ffc494d7566dc3e9dad182cebd100b4a44494432845c6be691b76925f7dd06397cb607469bdae5a948597603ced4c2353f94d7dee4984daf0d1d412b77ed3cf8df186e8f1d7c9f6ed6e9e1368dc44740a3401b73fbd6ce2227317114f721a30c14c1f8fe923a3bbd3ab03221afca1a67edb414734fb59e9466984a6618758238cda21a79e04f4b83aac80caa380a5b10eec450a51433087a1ba168ff8bf7296f72d0d1dfd46dcd8b99755933d36dbad28b706d331136833500bf651dd443b19d86f6a506a80c3b51568142a99c4c1b36bfa3a0de257c272a9f136fd5c9d61cbeb102669614afc60b2c2ae3434d4bf8d37165bb7ca9bd1d7c87ff5b43fb9da3a7cff1825c0d866a879a8754e704d2e83030a470af82803dbdb93d46a6dcd33884659da5328ec76b8301164a8f9ba63932c66b313fae5ad778b10a122190cd4bcc0ac80ca06056114dc31d8cdc7ebad706dbbce4f8f4c44570a17c767a51860404533dd71dd8f02a47a7192ff3d4c5f19f47024cd6fa9737c772bc2eda96f1847f7eb504166f2204bf84aa05e7851ea181a015b0d583dcbaffe41f8ad361d7dfdfb2f17c42020f33072cd07ab065617e4f1d0838522939370d855426437844aff0b8f1d6a8a0cbec0b547b748510e482f7aa088a2b959c7d948700835ae31bb98304d93f61c9607d64e5898630b8cd581581b69f37d75774137605f139a92ace5f91ff2f34990e72cc306dfe8cfcd4d0a017ae687c010ea0f8be582f8561206a82a52d01225102bfef3b667d3567c8dbef3d0f8461e8eea85e23d0edff454a23195250a271542d0a6b3598dda4ae4da3a823f23e42435b27c920128073d837c3fa8d7e5b8287787c00925710ce7886007661b159360bb7e4841e31b70c446612e5f1ae6f0a3839a1f9070f21598dcf36539a227df0bb4d8fa10bc649fe5388d4cf3ff239e632f76cd7fd75a78db5a305b72394a13ea58a2445749d263445d3b921948e3603d9401aefd7a1459396c2ab18345ecc985e2a6f6f906c3066a5508944c669775a118c2631f739d4ad7ac3dcef4066e5378d07ea893be72209335c1b8e28253e0fd0c04299e7a3ffc7c4252c6cb42afaef1954647a03e3dee48d3c8f677ef790fde3e4c170bfdd5174a6761055afcf3b084ebbf8590264dae834ba3314a00a0491c10da0a8837ebe0b902b3e34c80b736ebf7df3082e4c02f125980f1c1d8846fc34529767d433e590492b968543e0fa16739f6bd475a4a7378214104a31a609da93497f79a05bd8c056797cf34e25311686a9d8fc60cc634b9196c8a0fa108d459ba79e7fa1819bef59bbdcb00f25fa68ccaada9bc6f0d3bc2f5e0be0ca72e44907e9bd7bd0ae639048afc120be5fd787ab9f9ef63551803bff403a5499b253c0aa9da626dd76c32592537986366ebd5ffff278075b0a3518aca1311434d2ad397f6b38984b22965d60909d6854931328f94dfe7891ba5b1ef6761f8a85b9b0387f8b0154ad88a4f03efb405175b2191b1097bdff0ff7819cf63bec14cc1a9d00915f084b0814bf14309ea01d7cf9382f47626a2eda02fcf51a130946cef857c6d758a76cb389d15117d4809ad51f4579dd8ca1bba8be43c2d9b1c5062d2ffcc145551cc428f1e63119a88652c8fee9153cb3de627649dcbe5b07178f23ce9923d7fcc9f3e2fcbfb4f849cdb52323adb50c09b8e41a5f4d7a6e8373903aaf5f1ecd685d5e3f4bf8f097de61a1062fbdca02446d6862f9736b00d906b97538cd6691197d1ef964a561f493e67e49f7a0efc050ce582cf66cb661a521d50a5b999fbdf6d1739206f0db27c3b08504a0d578e0b70bf0e243e0fad26452aa4fc86bee77516c575820724f17546b173b365a1c3347a9bfe192a4d83349dfcea8eb6aeeb4583c2f05f4ae7c0d4d4be6c18c56cf0c2b1b2577cc9a162140aa445756179bef96e649d5e3c4aa2c0e93b4428439e69d7b530adbb6d0568192510882040af2d1d02fef75766394a89e032a1349be8312b25a2aa1c5e8269f6f4b9cf41860817ef7e74f20186ac3fb059042220d720455dfae177975a5f2b825a8c8673eb7db61ee96b94be61bb6db7f452557acb4fddd72b5860e327dc5cefdfa73d9bb8f18cd60c54ab634939c24a8f3e0759a6efb9bd9223de1c00b028bdd92b771fe86b02682980f3dbae77b30eeb1e6c77c06863e8da1140a71451fd001e12524e2e33ab37d9e24b5e5b3345bbcf58f6efdc3ddfd8e657b8e0ac4aa2744c20888b015a0692f41f03dda99d9289786cdf2fa0df40681b91f1101e136d3d1e84767788b1bf652636c6b6c058b46bbd83da6d74d42643b622853518ba962a455d550a8c60a0859da44cd6f97a51f8a37080f0946976c8b6c7f4ec01a55bf5da15b247f093c8f9e85294c70e8c3ed9d62e53a30bd15db14b3c78baa135f0d9ad98d4839e03fa6dc0a151087a7c02a98852102fb1830820db0c6635167a5e3472ae2875fbe2e647258e7b5ed8cd4a1a7e07844ce02e3a68b90cb7f174e6aab1ed84b456b02fb6e3e5b076cf21fa180db49f0064105c6a509c1b65b99fc4121e7274f8f494e974727ed7d61204dcf8bceb8f8c6c589556e6af24cf255c9b5d480d07d2350dcc5b01f260e27d4fb28a7f928b2441f407880b7aa0cdb4dc7dc3a4b8f497c58cbda629216f448d392a479285e672dbdfa4679eed636e2f84d7d0fc39764163e0b23cc8a167fac79962ea1385e6fa3e04fee1e8c68fce370a5c740f25de0758bf1e2bbccf78c5ab2618dddf3616e85d5d48761378c9cb3e716c53bb923186a25c63a257a759a1a226457a7c7624b81265666f087a49ebff60f5273eb9caa40b941182e9079254ae274bbd8d38a0531d99823566ffa8e6372b4a64ffa9520f74cd012aaef23b96b1e7d6b6436b3bb3af7115ffa437f24dd7520dd0d06ed45c18c4f48c06a170287e086bfbfd59ea341779500bc47bba2c696dffd23d056a60f77680c435e48a479acc46a6b120f83033c4e44cb16e95d95d090316fd8d0269fc984f2ff70562aa954054ba09693ad5551b217a1c15ed665ac544102c8229dcc93d96a0ef63c1062fb8e207e89b177d4f71dd2bc5586c31ace37c827c5d56a8897679ac58b1a62f1dd6ea9639db9bcc68af50c2485e13f850322a88b3d3de793fa5d37ed5070f66ea530800a6a6c4676177a9299eb1669fa83823ac6501607d6fd4083cd6533eb052575f51bb4fe2b38c39ac927418a49bc9c31fa1531c8ac1580691b2c31fb0db9ca2202e9ac728f0e3f3d6723acb84def67f0e5ca5d5e6dd3acba1fb0d3aa1f03fa216692875a33eec45c6daa3f43f932966378d8787e74afb5a4594020de1188a7743731ee70670cd8ebadeee743f4b7c7080c99eb1a57cc2e906babb7c4e1b89a00a4afba8344c0656331da0a9f01b1290c7b4c86a11eb737277ec7870e460f4110508e8d74ca4c3e9dd89be4a0f95a27a955fffc47b0f09c54e0205387620fb691af1bb84d593129a72a31cf61ec68f67d000cc7c6742a79354b5cf9dd67a4e4fced960b9025194b7ce9f89ed33f35588b55f154f52e915fe1a93cef7cb6cf43828e1921446d3f7c15bd511fb2912e2407f52a25ba84456c1bc64fee4732503f39ed7114f0001a14534a9234fe1e1c46e4c95f996440993a6e469a3fdf368f0c4b3bc628ce13550c0e7ee31ac5bcfb221610101a1dc7300fb752cc086194114ee7bb3cec51569d2f0ce2052cab940c7b4f43fe39834a8f83040baad62cdc0c87dd00867c8f82c80cad65dd34747f8396f772e42a2bdc506aabc719c95d9618e576b6aa425baaaca9250e77e5a6635c01ed0c91c5ad9ec025466f8adf047e9a72f3750dada6496d23fa7656187a5c8ec0de13a659e4cff50b4423f04f8bf6d878b48b7aebbf22f7e6890ff86b08737e8ce97ed77fcf212e40a0143baca07574114828fb58c2b180397bf711b4f27ca73f7ac4b7d894e3d0be7dd745a35d201edc880a99b4e27ea324fe0804eba423bb0628ad4ee2970ac5f9077d232e3c3a4c28c6c61e10388b2a6f822c09a034b69e4c4b63dbbbf4722f5f6745680de00059b57bd0a94ba34aa662e13a7c9e7ecf412453100a2b58fbde293c95ab8fa144664fe2d21367078bce4c1570d9873004a8a5936f62401b918eae45187ceeaa25cc9cc2387add76bd79ed3d70eaadd673451ac7974eca14442faaf565b09e5b9a6a7e6be4221897f63e01027bcac922ea7ff08eb4b7f8410874ce342d1b98af18aae3cd53d36205c50836ddd38cdef42680cc2aabd926d2de7e59a266d3b6af4746caf3a0f3f63ed74242f13a68cd9dcd9cba887ea01c72975bafe65225925c0f37f2ed40b4e9dac74e40a5b5d89dcfe7841e169ca642b7f3ae1f31c70059cfca784efe268eaf0006e18ba903970748a9bc24a5897961a8689326329ccde895907c79afe383de692d740ec626d768f5145acb0eb3f5f5fdd03fdf795b3ac87b175c3ca16dade5f63d6089896681d2bd7e5a488d1e8fa5a95301805c729c93f17db836d6947144a971c462f6b3f197a1f6bec1997dcfeb54188dc56fa045489c244543b2a2bd8acedbb12","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
