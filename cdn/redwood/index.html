<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a25b4f64c578506910d6ead0e2becd831840036affd33b4dcc97bbc09acf3ba2bd6aa789a7c90931df52035fd3facddeddcc46d2674fce332330d87109802cf2e676e54675624b4ae06317e40bf1b940cb63f0e3b16479bad560adf384d755c57cb7aa2b0cd080fb3a1884add760e21ffbed02d74ae57c07c34535630bb308c0478149deb247a0e214cf92b56640c16e35aa9186d234bfd860e8bb832384d9f474e96d61cabf3e803f71f02ba717e9cdbc58d5d544f6dc649f68793a7049977184984e8935a4f8e9b4061121acebf3cfba8e4038652c22a396ef2aa8c17c3621647744db8f77b1a0a8422e69848c10c0538d7ae354a514fccc68aa97a12fc3425c550886ea0d58d5871bf5e3cad80c4855c341806b74d690758eead46abd8e0dd462815a44cb8fc5aeeb8033d88cf5e82141792a9c30800e967ba5255e152a90cdf34ccc23ff051c57b22f3af085f079aa4a4ec66f6e52fa4ef6592a4d15d37977f344173603e6040a208c54a507e24af9c725969aed72ad908b65720cc664a83707d9d19af3bead85cbf6c649c221d27c2fe9c9f3276023e325117fa744fead83264a9efe6196b479f661fb814a20d1fc43cdcfc45c9856e1937793de20f3012ca1a713a71da543e4e580e52e7828ac3f32515b18f07ff95ebcbc8c9a26fb955bfcdf2450d5b17c7abc7dca8a1b059603462717adc13b4ba244b01522294676af9d49bc6d8d7af9b17081e5fa18a26ecd7661badefe33b991177d680b8f645fb197bc60ab5b07fd4aef35a2b348f02d19ed72e3b78afe5ecdaf6ab35e22560f28722065f88665b44f77d7f3148558a1431e77879fe5f14cc9fb0540c70cb70f172b2c4720ea2c67e5707dd5364adeff27c1ea3f253f001aabf579c9284027c68aed15d296cb79897d274774534355d10bea70461a8b76cad58d2c70f89906f1b4c41b81c193bfd86f8032d62e1e5d113cc50018c776c68feb94ce17401c392d5de089985817f862769b5af50f64ea7f08a74969eba4ad922bdf7245547de3bf99d52f061d00f5c0f5aa5e27c3476c125b477f2cb45648f2a58d9c15281c6fc3b1a31add9e06325c0aed6687f945ace85806a7f38611652dbe3d9271a85be4504085402ad3dd112b3c9380f0085ab7cbe59fd1f42431336a83933211b1bafe64e667fc392752d779be6b9ed382cfcdce89a7b82328584a75ce35d6dcd911c4a35a4104c60264cb60ab189f9ba1f52e66892c0c6c79ad45fb2a4afc53f5a4cb59cb3b820c3fa29d305f2ffa34b40aed0d37f4fd9532c54ee5fc3e4845db6cbbb722b636cb7d7b1f8ee2b2d52cd592d21d6cb47d3139c14f39780acdffd16c8a4ef1ed7247f7597e2d5e25cde7485f2135459cda63c1d8b3110ed0b76bf0f28971b9d9deb67e130ff53642bb9c1089593d77345bda810a8f0763087d0930478d6e69890ab633ada750ada0bfd59b8fc1946076de117a484c6d819f30b857440c0e9223ac0cb532c5b5a155b5dee6a3f3278cd8d830e1823357d8996caf44175b86e3b0984871d51c3efa2a21cba31006951bbea3ea3129b39edfc2da36dff75471bb8e5cb72f51c7ba38ce99c81e35da22219d3238ad572b3389c1925ad2e6818c2bb20f5e969873ac50a1d8b0b80e73ea830d84dbae199aa29bbb0453fb9de17563b94838f1acd4027b30d5576e065f88cd801d4154eed6794d3a43fc8d26e4ff769eae027ea5f062cde48642afe0cf23a04b632444dfef8a73d1058dad44a29cbe47830db17ac4e00cc2435bae2cd00c38b55b2210dbba0bf425db556ea620086c2085242a9cac5457a98cf6c6245e4f43bfeefb191c40b666adf4fc60752ce2109818ebeda5c3ab9023e63140c9eb1dc335df77457e76ee54c551fbb5001db78377048f4888bb776d77cfb8fd18e1ed8c9a2111ffac2febcba5b1ca030426bc85c6966082dcf36d0474667e24876660cc0adcc387c2fc40cc9c00c322291404beb509b4bb279d38b0aa24c9f54dcc8a2672b13815c2f533fc44549fa56514ef4b17effdb299029b51f4ad9501f70b2d3b2bfb5d96a8fa991a7b3fd870e2f0c0b62f1700ec923714491fa0373b474d35d9f808edd62e5aef624224c9542f00801c9bf94bcd9943bb85d2802dd8f4c04d27ccdf5077903434449e2b1666cbb427e11c33fb02f1aa1f585e4e385edf311262a1e32795e037ad53df00d5f76accded2d8c46295b427d25fb167c96d56f4095371fd9c706f5e3ba792885fd89bac5ea50246c9f00f74fba522c6af0b42425196c0fd0e5ea12e8f6318faaf4c00b06f07f3ff7491fe8d22e2c42aba6b80746576218558864e5fc881a04dae1ebef38bf2a42cb8a3f9ad04c93ca91345bd115658dc89d5691205ec8d9926cb8c048f5bedd3a3d3affb7407f0fa94f16003c4a5873c67c433c3a2dbd30d51405135e4ad50efea66e70bed87066508df6a5f9997d4a6d0be4507dea916a7de35fe7a89dab902e6d9d3430c5694879244a5690abb61e983b5b3ab4d4dec27c8bb239e1e73edec25d8bc2d2e4708ca88ff42cbc9e22ac95a6190fa5fc69ceaa97294e80c2edfa59af68327a907509c19c875c7de121599894f67ae929e295eba5871244a909b0423f487ed2fd610fbcfd59a175aa698c80000b6f33c8452441e9c3029c24c02f70d231e3a5938425019067ce77751b279d6202a2e6d5814c17d7e08cc3581d8c22eb0ebc8413ce9828f24fd8f429ae074cb8baef165f3f6b672c2b988a570024028cc63776005c418df9ee3601916eea61a3e5ef56a396c469ef504d3b09c79b940c9875d47129f2364fb959766e34c278a713c300571601b41796f18f637f3efbb81aab4cbfad68ea911e4b381c0811509e8b8ea913cb58694d82c7588a4fec79a24678dbe17fd5b3b9606ccaef9f5f8d1e1975f3c460cd50b02896634498d56d5e47ca17333dc1f2e114e54b0306fffe542f960190fffef6f696cf990b7a3503260b98e578a4b61bf862abb2b582994139cf3c8cd9441e8b2cfc462b24d1931362465bebf90da5a433feb9640b9d747f5f6d3d9ba5b38cf1212de1574b833253f5aca93dcf0062b672a59d76861df5bd33b343b0140aa417919f63f34bec4f32caffb06c9e11e3e24027275b4f3ee53d7d26d1f87e1bffcc808ee8581cf6068183c6968e0ad96465d727d8102a6951d593945e6af92f3b6eac3cb9f1385cd33f34b27699c99bdd4972af72d056a278478bb7883a0251b6ec6b04ae7ab5184d910d881ca7019db193df71339588170147bfd30085afedb59bd016e099c445e86cc54dc0a343dccf84aedd7de4615b76836e3051026643ddb09f9f66a21d109ca901ad8f7ec27968c008586e631cf43bef6700745622fc66ffad2ad027832561fd7831960a32c037a9ea36df7433e397b68195413caa2d35774853654e471c385bd84ae7fcacc7dd5aa8589866011d6043f016e6af40cb80b05b10908566db244fe53d456743ef226650473180887a30028af21c0300c6ab9562f36fa7ba7962d1aef5095be165d7a36ced357362a0d83d30a326963ac895d63ad2c34670f48477c73ca87569b43b055ef5212aeb0546a5ec0c69ea8e1fbed478b700a3152f26210048df689f78e4c652238e13982c6022d4543095a12a28898b57587ce519ea6168076ab8fac178c6af3acf8d14d99f6a1a86df0db38542cdffd6b5aa79ee8e2ad72c1894a5efa5a7ffe94cc3a57fccc95bdaeb2b49ad4153d5ef84a75e515801d7aef39ca9c7f92621e85b81fbad66253cccd9fe83b18a5dba1323bb068fa337428dd58df7e233ef77777a54e2952361893d8c6f8feb07b9ec8a1f179d35a01e789da85742fb68c907d9001ca5f006632c9e2be40ac9ecb0f9569d470cc2543aee79402792b546817c64d4bf1824709cb0df6305ff5d2577f4448da40a767a23a4825ae3cbd3f52f89ad1af45590e33085fc139f92811850702b32ad6618185ef6adf59d127d4ed5ed535df64fc2f74f05b309f10551858ece3d2b43ccc7cd5e77b48273533d0c1791fea3091d93ac9f72368e72fb7e3bd821b5d5485e32c0bf926e08da1cb74cfa696a5c3a356b724f0b9426e5ad6834f3604df23bb351ecbf2ebdbaa0c58fc8054b0dfcd321180d501abeeda41e73f38ef3002354ffea099219a05535329d3756e57713e58c1ac7288288563625856a0825ca6212ae690df69f9e69ce191917c6ebf4f2d5fa9fa8d7b394677a0883699b271af599e0004624f7baaa0ddbb1cdb5d5d7692a68ecc6e53855508c0143f087d58ffe8a46efcfce4bc159d51e06efaa395b63a7a3081a3db5ae50786614cc5e31b5f089ef58829c65d6e00d86bf09736888046b96619469e8e88d1d416afa16247f65f3c9d1405880f42eb1dd1972ec2875b88e9036a654a1b4a8c2a83a46be6d12dc991ee6496e4349d7cef96be25cc5277132c4632137edf0c9cc0f317fee22c840c9c7cbd12aa1cfc2225803d43198b9ab6216f8f3562bf4b914b036019152ae1d879a2a77190b61a2d6e0087d5e0ef6ada55c51dad8f2a6e21f04d09b418b1a8ea6751534431660a852c355ea227f87df89291cb680e70e4a6c3a7bc25a9ec840851b3bc8501cfcf2b0973720f6abb8d3ac66a2391e5aacc71894d84afc7c51153429d17559022c2e6ea18ec79f9e6f5b4945faca5c8d9f26d6ddd7c8ce3d397585b6b0e57ae8661917c6d5352e6f7617fe2c9f36fd3ac46c28f3cdfc7ed7ad19b7e641766d475ef5be824857248e022049542d5c82974441c08eb016926dba32e85d0d95c25247c48562b50e538ab136096791d4dbbf1414b9a8ac820ea4dce7cbd04d020bb7417444da3a533a8b8dfbc1f4abdad9e445ead2880f97076e27c044a3449063df6fe47f825e089b885f4f1a60d580d2cc779029f7da17d00386a27a6914681db880e906e0c39bf1bdf7d6a07089ab18e69919a54d8eaa8fcbf69433b1c276c1519dd5f7d7a598170babed0eaead118a164a7f9cac8e1da086a79063e016e33eaa3033a9b83687fc2a3262520f987ba28e5021d9ed8dd7cb55f27d03110a9d1d0d3a14f66b4a8db478eb3333c37cd4ca2ce0ea2c2d4cebe65fc5f2fa15b3bffa98aa8e7ba3f8593a9bf7fa58f664a3fb61e7e00c1aba0deeffa6560d44362ec63f5f2d6a0e29e4bb2c40891628ffdaca4971b88f87ee812e465baefae5de3547869a57b5390b645ad426742862ff8e37536cd57e632a5762d71ecabb89f5331cc20a44f466f61287b0de66d1b7988ab8188be0e2041e5a4560732b89466a83b9320328fbd98daa8ebfbdb346cdc1395628e714a3821e5080fc15a925bbdf17892c4b06c10801a79f440ef348ea5d680c0eab074c206bf93d2bc4f6b0c6f1b156fe47d68fcf0e9e5a25ef58a578a6099f9ef1b43ce82f56fa09807e2f07cdc0d10fe8683e02cf7b0c6b959534292e4349a407642495b716c10c7ee062f2e4ac89c5e40093a2bf851b638c8236b44e746294f93ff944e69481004305f624f6cfef0ffc5ffab369742082b7c16548963320d30ce2b66f01c04615d18c6c67d90f6aea25c6e4512250210bbb439dd4421f9f503211d3368560df68010f3bf03f489de79b3c2fc626fb9853bd2adf3516122d2c786f9062ea36d21277f7d8e6606e5d7bd8d6e7978aa482f1d04bc76735d9dfea04b804bf891b913fb7f3aa1c781ce33d8dce3c253859d50fcf6748c0faf3aeef553f95fba6fe75a8aee487670e9ae7d0ce72e6908bc353a0f99e6f8b80d3e4d17f9ef9c09a2bef37a7258ca232adf03a1786bc1146e0faa34594a9dd1a6ccd874438cf7407148c48255feae1c082d0159a8b8ffe6b43094c2a401d72000cec353aac8e297d98d6427230064d9ee11c61f294367750adde07d0a1d431c584aba5f095eaaf1ae75b0c5f64add4e7fbd416073af7942560deeb950ef5b86f761ea1b8a5028ebeba9bfda4070395c90d5e5f771032bc50da57747221d72385cdf70b839ae49b8f1bf622220bd4bc1467d7c0a50898f777e912cc5ec4380d69b5ac012e6b435456bbb619b353962d1965d509c53e24b4e73009e3bb05266c25e1e229e54b04d771b36675961a67ff9a066377b86cefa6ed7f15ddfcc0eb35399c0da1ee425a1265705ca309965955ce99cc41b9e7a1b92f65f8517871902c72b25bf0688d4dd643e4de7f9093bde7bf74ecfe5bae006737db7ce7c306364305d2862237ee177b727035c8f06e9c6a8fa27b014b05b232310422177ea2578a60469e1b14917e9412432c5c8313064eb973fc0cd6f84e56ad4dfee6931cd6bc39a75f11d9377a1294c3b1dbff8d5ccc23dfc946a49a5f4fa6f32a93f136458c3417747be33acbc6a2b028843089ff96e7f3395d0325aabd8fa930e6c66577e4dffddf795dc8e3fa8eeb5a06b7c1029e269a839cc4d6338b20b685679230771c676336f02c6857e04a7c651cec3d597aa366427c1fa33c47925e64b46b3654f6fb43cd79dcb4191486dcddceef4eff66b37f0e63a0095aa4663d81df1578325f47e02d65a472d616eeea40696a75214762b33319180cf2b7dc416a5be873d29b2febcd1d88bd8e5d84e4bf10a65ad3df0785310646917c8e324576da46bb0b57b45f1a3505e2d00fb84b5f4a423e064e7a32a9b3293c776fe6a37f332c54de783fca84dae3450d80eb192fba3d494c7983d051f39e666c429b3fb1cc8685aa02ebad38c21de91c95002445b707d0d7c2ce632444dab634c5dfe04de35a757d4e1ae3b11949eeb13adb67341014f1d06d4273fca1181d3881971e475b010783e5521b6bd4a012d956e0d8a1fca05646051d6ae4c679008ca0b0829a7f5a2fd3c0fb8f41196dc9b881ba5f18b420998b5ae647a8e84ec0c8d597dd69010b72d5d4312dd9d0b38baa74c6fdf6a3f29ffe1b271443972845fb3620a55595b70152933c91eba32507d7dc6b3d0356a9ae058fa34d8ae3f9cf5fda7fccc949910996e2b6a94d2554c537aa099f26ad7d254f2cd18677905e6c4ebcbe66c78cee0277f5ef8f5d7947b5717490f24ce5db06987ec6db235a19c8b486c7f66d363bb223a1466616f301a4727f2e1a9b2cfaf8a9f3839e7ef4a00f29487edb6dedefbcf62c506cae3bd702c19fb68447937851e8e668f094495e72437970ee36ffcf401e2bcd5a4a5020aa90629d0dd54a4de1f807a4f4c38b7b91f927e7016a9672653e59530123c532ae0e3037dbdd500ca376fa041baf20df4b49d4825fd8f901e96b56440490b472f5142e2c54b293417c96a3299a19d8df02f7fc40f07d48c8bfeb2ec0d259985ac0d38a79ed473470dabdc7c9c174ece732f0a1beae0f40d9e0cd7e0c2607ddb22d35445c6436603947b42db0808bd6dc47d37034b5aea29957f2c0271e0e4e712a77d60d3d8ce1c9f0fde283b365d86cda03d2d3184a8d2c1f5165aeb48b79a8efc4816197e24e7be21f7deb168cdf6942269074eb42e648fb96914cad0a24c9fbb821d08a7f8853fb6262a933f8a1e0cc8a03134cb32f0291af3b60dc79b525d737075e4610423033cc6067b4e4b18f5ecc3b4071bae8a7d01ab471be9ac795bdc3849de61c92769f3ed937325d7756fb4404208e9bc0a6a51873e99185c57684a76a5f13f0c7c7b85b4c1e000890585d3d4e8af463bb4eb708d310bca512a4a99360372c39255d354ad0ec2de937a97f2e25380b9140b5f0fa83e1339ac57944bb2cdd43b738990ab6ff6e112e240c7a9f1b435f2d84302aac9d08e46aca7bec3238ed7a3d8a5f14368cc7177b6c4b715c5202151265c7d84ee2b45d9e570923ef12d6837143aa777e228656ff608c8434eec039227e738e20d1432f28377ddc1b3e154d8b5a75ce77f7254d82bd93357cfc0829a45ad7bbef494f3efde6498c3be80a2e6dc8b3f99eea2520a5fbe2a49fdaa4fb898fdbb876812c133f45415a8723b769a5b8d55c0442e81c69a8ccc9fb2c6a98f1de6d5b76139bd501237292c8550068d88911ec63f77d04149af0488ab4d95be031c7701f131d50db19c56bd593dc2a89b7cdd8018a5603e5e17dc467e0622a05722cbf23b9a90064633d28f8d9e2e44f08714503a6fbfc93ac40587174e01ea03a66c44beac075f751ccd0c170c27c6f8e6112e6a377349cd9ad279a0843f219d99049beec48a8dc53058df339045992140f62979d74257ced705a46ff9d7fc2c5a6c8c608f9590f6dfcd33a51d92dc8ee4018fe9149879072088ac9d19635236941abd708f209197f431a2b2fc837bbdeed1c3bb3427562cbb3d8c153216a9d15ae32c575b1033495f192d4eef2639f677d86d3ae0af75a7829fdf11e438319400a67d5d01be8b5c1114e74bfea60f75aaafa342c2b25f1bf141e2eea51ade948f5d21fd81d3d1aa117906718cea74a18ca37507d670d1cfc770a8104df6b5bd09f83b94623fb50f7b536856463b4faf53a5aac6ef19df8e13c10267cede502b12293c7a430aed4c7d50015f39989ac2f1843c66a8e15119eb6730e7023c8e366f2bc7f3bdf3223248c05e2f49f2cd56933e90bdc1c5025ff9155090f92e1e39422834c01fe4e109a00484de646879420bf3c7f059c078a7a978cd21eee685323c5dfae538ce955f4cac2df2619ee189708b51018e5731c2d411827510f32ada8d2d9315e516a6f75debf0f532378ce816aa8b3842c511a2f83abea81664b54195526b1fde5daaa58d3cd847f8ad826191a3a066ebdaabf8bb15190b4381d0a5681fce8a1e85aee806f0d50061a8cc27aeabed1a0862a58eb24dd19e58f24d01d030b06ea199725c89b8629b63992ae09524d58b021fe528bf4662267324e6bc4b4c2968e02899a2ba5dde235e932835682a4e1c5b2937e36b03515e744a20b4e9633e3d40daca6f81bdd768584a03e15babcac114b4eaf286ac43681847dc8b9910eb11bcdbc1add3b4685b0356566a83864e27d3c4aae480abb20371c9f43d207c823618c8eaa67d1efe6697abf78a3dce0909d57613dd16206a80b7997f9765d0c04e944671249491523f520eeb27db5426580e289633190ace71603ca4f1116e8cc2fcdfb895747b444dd1dd397928a4b614ab7eba5f437ee16375180e6bd18d263f41b54ccd767ca76cbf5d99fd9baf40121ed2d9a9e390dddc12e6f3002cb9192298cb0f9ef4350adb75aaf1d6f576920ded619bbaa9dc14671fd0e8b35142c5e0f385dc955b9b7a66869dfdacf565568ca31af7631a4cf63721478e2e92f7ca77e5e01350772028ddf07ceefeb8c2ed6ad41c23fed1fc2337f5263230a972f4ed657214d9e746f25ce92174df67cc8ff07d8a354b8b48cecceea245b55159c827e497018482b911ce74a8a8433386fe5399eb2ab2af7c21683e190e09c044a6e097b6db38ec35c36c31c9e62867dab10e70dd5cd5f4bb9adb1b529f85c81488379d24e5481346d03faeb507fa7dc40f1ff2228314800a811fd1c3a5ecaaa3218abeef8db950ce960a1cb12c80b7fe5f4db51cec1b39da38cae6b324b2325e034e3ce3ab00c2c08d95826a2ad1436c498cc586884306312eab7634b8d3afcf008fdd18e5eee3b936ce520cc048ab3537618a51fa50f42d2d83cdc1d4c6bda49d913554972b77b4f56713eaade261fbf2af2228cf3d955bf50db16e0aa3143a3f58cfa43ae95b4b1238224d024e8059aff82bd14c94c5e6b2796c4195e89a3fb4ffdb1497d00a27107da02200553fc80954fd9a7e98798abca7015bc1f1972c66ed4b17f247042be5728c497e911449687acf1723d3e29c9600e69c105f8cf7d9059a73a6474a99187ea068ba4879858fed854148c6c8d118ad139a62d8dc1ddf9e9518084ff01444aac16e7ae0d17df247fc94ea16cabc0d99cfe848557e7c07fe5143b4edd3dbfd3cf26711e92b532a073f5449837fd2745e5e353f89ada2271abe021aee0da5efb37bfdf467e063e267994d92b3e9bbf7733df319b58dd23cfc0de1f71c3333c6ce212671dce3b4efbae71c0bc6cd397e12ef59e70614739984bfab528ae0a5824c22bbcce268843dcce5c0713e377aab52a079beed076859ba1562a292059ecfcba1d69215bc1cd272b851bb51905dfdcfa645a67bf17fabab8f54e6ac76e59df4b0ab1487493710dbec74166fa22235a6345d5c481b34c2be2770c5d21dc4bae95c97d3271a46bf283327c642604d61996d4e9758f8dfe95964e77b130483620f961f7beec5130e4b73542d20aa09bed849aac756ac8769b72bc75c635877a8e22db0225976b6930245209144d97dedad9f3b40be5a85e475cf57d09e8949ea8db486e0fa9b84f2a61bff9650692b91d45c22d50cca0a0c473afc00698887a4de7212c83b1b12d086fffd6b8e97842634dc977c97e9407c43ed055491c7778f676b0506910295e4f45fa15ce247e5c5b3c0e6ffb0637db45282c5ccd75db8a469b3b7e87853ff2109de700afe71f0cb34dbfb9cda5d65ba2a906e612ef9f49691e0a565f31e707e20495df5d88e068b25502aa66c7fce6c9c982f6e0b37808398eaa22025f7cf0839507dd47aa80ea8d307c2ff0749865050d2e65631af5812ed333ace4fd4e1a40ce04742e1c261816272271f58cd1cca1f8c45146e1092e401511a58aa2b1c2a8b32a28954b0e0bdd57a3048957a8094cf44de927b787197e51ee999f71c17d70c0ce8bbc6baeba50f123ce97ee183bf6935f4fcf5ea20f8d203cfac9b52ecbc7a5056cb87906f644ae20b6c56186aeb56a5f86288dfa078c08cae6dc62407f27135af68299ce6c508e70728f6c7995ff65eeaba22f134cbb5c43b7ada10003575ad1ba4b32a886fa87cbc8b78944f9e0cd4b216d10dc376d43c4d402fa28b7d8eb9607c406dcc43008df8d6238f94d92eb4a81ad62b6b8f889e5b71be6fa5fcaf0cdaec71bdd3120bee638f9ba919670285599fe7b8b46e0cb0c99f31b05d440f62056a4fdd07cdc4f27bad293f5074942bef481ca2250e78118f1de3819f21b1fd2049e8414351de2f7123677ed105726ef2c4c0ed8bedb1cb0153c43dfea1121e14d1504153c1e65522d76d6cba914b129d2b42fbcb82adcc159801a58c118773ee903d4a962ce8771f2dab3c65c79e5e88cf4c469bf2ccda2ee021a86893c96654ed015a127323f2c9e0e9035a5ce661c812fcd786d13257697c62b303b1574c05fc6dffbd6554112411584edd4a0d95c6c8d11e889ff47c7c201cd6fb5ed1553320dbe007ccad26a1365c396e4672fb54b8925002f098e367dd19da35963d9aa8bbae753ce3fcfa846d47a5ea79e83d2462e9c37733fba567248a5f1db02e775b14652e056249ae80a423957ce26dd33ca2aba7ea08f063b7f143df991c53d9194a8539aac1d48e27faffa087c4a152058a8311c36fa6e64e372321e13650680c28e5115e9f0744585bd2d728d2e4ca18ceb08d5971506d32b36979f79368034bcff8f4d39ab224b21899576f637cd7f685e0cb01277e958f44aaaea2eb579a517e73fcc1e928a1fb92e61e0af4b8bb4e297bcba30876c8d3f25c7ec19d2ccfe1c690632672654d563010a1845d7a8e5c028ea8cd076b29b0a3be7b3977efd5595e59b0c5dee64fee366fd4a4674b8f884ac8717e71ae50d8e69c7beff85664c88887422923daac8f9d885ceb0ce1ebb82a60cfdc03956a6f614a76f58c75885bbaec8efa2dafa23649486c222540b428a9c615a72768fc44cd211bc3828bfed81bc8ef97c8be8b0f162298af138a9d93530df76fd91994048277996063edbc96624bd5613830327ffa382eefe7bb99795a63fe3191bc3bcde63b80d00f6429fce0263c6b8d8a27348cb168119a436435a139b22b14582131effbb2e394df30477d3d81709d6dc21bf99f3b2addf75a805a87c3d795712cc1e3f97fef9dfb8642e3bfd86b3aa9d7126afdc6832168a91f7a635be25765b4f85687abf0d3cb331d50ed444075dfaf874259b3335ab0d0b563d63261e00f1b0d222045f8b69d4d10d1de1c2e1ac8aae0637630e72919f3db81e5dea5b8811cd59eb5ef8e1ed11d0198736dd818a61eed659b0e1616fb4075f77e2b1fd3295dfc4ea1c2899c3bc5c267fc2c9019daee7358197e64cbb9f795a7f455092f60737c77bb07193ade91f1ba2fe0aaebf789c36e9485c6291f99e809d2ca57acd5c999f68a8287fe7ae98a09281a9293bad664719f5b42d9d0d2f4b527d018da0480cc7ef19e0cdec5d7e13cd02969dbc093e06b8aaf37ac3de287a494dfbf76031a5d0bbc330075bf397ab7832c3598fe5b19b4f0349a4ef718e708dd518e17340ac22436e609e0202f14cfc014398c3bff5f1517f89d2858729a5743946ca8f273fb3050a5d4bc36bdf276f6d02f44430b332d388f6ef420622912ae5066130c5b3411140b0a4650bc4a5ff4a99b90e53c8347775f6d7d5562409e02fcd97de9f0312cd078bc520f6ca17b25c44ae25f43e36023e9adafd513865ab858592105affdf66d09692e5f047b1bf54e167a13c018fabccb76d36a7bce1ccbefe1bb99c071a822ac3e0b109f4ba7ccfd4c9db4a6317f7546090f51207b8be0498477dbc0b408991f1bd2b9bfe0074d00b45ac321d008537ef2bdc436baa8414e7aaed2a85ca0b070e1c6c23c6beab1a6408cb67d0d88d5705b4fc2ab78b9cc48357e65913e6c013a183189c5002be0771f6dceec8946c697e16901ad98ef984d775c5b22c8030e3edb8f31d4804ac2877a1d6f4732a22b562316d7408ab9631a5a1e5390df5cfaf9979553b8fb8bf63b2e391ef130d0a336f8927edd6981ae91511d4fa05676372890d06fc1f33da5feb2284397eea299fb8e96261138ec7083c68cca6b3bbc1a8738c686a7dec80c32b3032e303b26b0831e7ca6d0c47353accc4a01104e3a2695dace8d8ca612f276e0c7e933a7e168e13072837925ea91349808727fde4ddfe0ef2e099b469b8a2319cafa96bff007cfa44c63689fea7ea73e617d692743472c0f91d1d29f697f929acdb882f352c597ee5657efd80fc2005bb0aa9151e09315b4222bd1ff8eb5b4c5e541dd1f04ceb9786313e57b3063689fcda9bcb272437176316e63b2fdd09a638e0d4415063edb6b2caf07bf38d0f0120db26160ee2ce0eb5d773b9afc37cb8e376a443304987f04c195c33aa3efa01e4f6e567698b16f6a29b56ef3fcc1ca18ad7270337034cc80e0c3533be1df701e9f4e6712a9efa0146b0f644a4554b2fc02428abfd65fe2faa8297b69d0ae6e4565768757275c3b6aebe7fa40de70754b0df9694fce80979d6446ad32747b9a16a61a7e40bd73e89dd27251d0162d916763b1166f0d8f8dea2e9e2a2efeb601b08d5b6ab5bf1f8d1a7a2f095ebc2334c7e73c383f366dc9b5ae85f58e18915e6d97f92ea6053aa86660d9347e4793649d65b952959123f72c904095ea9868188287d67b7f0a47626844f9e3bc0465ec68ff03212d6baf2eda1e89fc8ce02ea8081cc3ea8a622c9afbce5e5380253246ab7574971a33318c6fa1df8ef628c0c31e76c09d2a47bb520b83e9232deb997f02509e3d30b5fdc08ccdb4ccdf45fe9a32fb3bef34a756714e9c2bef2dcc0428ea34b25d16a13875349cb25b51739d4a546b4d19a91e6ad4c0332927afc7e9870324a4a69c3c7a295bba780e83845b695983fa9260759e32046666a203bcdd478040f119dc4be8917d025004ac57a803af261631a08e6dd6af7efe61d23e650175fd123b537807943ac93905cb0dc85e3acc1728a725d63a3ca9c29d49b5f8a48c8f7c599d4322a37543caa8d31d13ec34a56eff4051303c42864788585218cced080207e67e00491134b8ddb97c1691ac0b560f95a2890931ec43a86c0bba09c25e73a3da6ad41ecf94b7692b6cbcf639a91ade224dfb57416030de67f29d94ba3b3ff49ca044edf41a7de8c3f79afe7fee67cda4bec153ee9ba333ce98ee7f6a570486b31471ed9b55489b5649fbbc71c7a30f55554acabc420e257edd13467cf75949b7986cbae5f7630e337f0e3602295971f87f3d899b15c7ba24c6542852e86463318b7f704f600ee6c562ed7b60f6cad93c053379c325a94b3a99f810e8e39296787bb8293ba3939d7a9f603da5857b279aed7181a5fe941731547535837bb7ae0c37294ac58303c725ca84c7afccc8fdd5dc10dd683f39867673f6b63e9cb86741588758f97dd9569db29feb4b3802e2c8ff3962e17b137bc0ca9e77b8d640ee6d246c11823b83adfaf51ffdc8d2964fcd9bedaaf7e977f0ffc50aa7a01895049cb51e2879e7a74305245fe61b25a884a8466fbc611e489c4e0116484e33b82e024a3a12a948866a55880aa9552d19667fcb7b043cf53fecf1a2c58f13c5abec9302329a7bc1d7c65ba1be4be33abfe1471f6d3e2b2ec4961b18b1036d43a55ce9dbb77aff3358acc548706919b9b63b027f961b543c12dfbca7cd45389356154248bfef3ec319262e5bc2cadf73ae6c7a53e8509a9e8351becbd0b986ad4ee5b5376d1769faa3dac061b0be8760f063cc743ba5a2aa3eed6f65c80e6a7837608cf2613e1b2b6ca0bb277b17b8e72810ca003e280e44571d8a0843f7a6ef75099c277e99d7c4a9d90755c852d51ec23787f6e2a95ad524cb93cf657a59234723be255ce0d12fb952f22449ed519c52ecff15c4faa42b1924fcf8a439f24285b8cc56f2f2e13d024ed1d1ad8d3f3ef8a640c60d4a6b55080a23a84bef1e27b76eef37d5aaa8ffb322a89e5d774c358101383f28d76bd07f85d79c9b1c186e66b75be772d301777d534b6f1771b1c2331e1a4d1007aa8802bf14590e94960a46dae0f89e34166162eda85e0d561f60f2149f5170c483ea98fe929fbbd62b1a178b71d33f56dcdb57c5a4249c803ac0ba9277377211f75dcd0012bfdf0c521eea11a2c7290a0409df03fff464a15dc3bfafbbaf2752e0db987ee67593c215dc43cce4d07649971eae7902c18506d4e4c19637d1967fbebae75202ac6dcc8b5bcd580ad6baaa311a68fba7b8301532317adb1755ce4e2de7f094c132606dff64fedeedef60ea74cd2fa23b3402fa66b415a8120ed5e020f9cbfa0dae065bf1277ccfc35e0ea971d6493a5cddc1f1fec9b0834e0ebd0bbe3cdd0340fb1273224e4263a22bc30506bdea8344b4424fb0aeed7c8d0aa29fe129f9502fe2549693a25e3a2821b950945cb812cc2ba84cd9d064fac8f53a87c4a38efec024c863bbaae54f787e82cac2c26576662a26c78ee50bb129f754e4cce21c283c01deddf161bff5faf23765a422f9df23919e520101c563a7441a9b30921c0f336cb04243df4021f5c9364e423d4e3fa23377ad091cac260dc04ed0fef871fc5fe503004bfef20ce797964e08dc8728e3d89825aea1eda5870a5aa5b89d98af0d0b259eb028c3d3a16904baf9fde9e39f6488446aeb7a892c6f3b201ceedfc0db2153e7aefede7caffa26e060116c54c1f1b6c652972f1a628a6d12302710250de596b085e469987109bc0a7b9b7284fe5001756182082af75917bbedc75930ce2a7a95374a4516fd92e64b13b610dbac0c7e88f293562c8c66337903a04fd978fb1289e174c0322a33008e1be69db4cd32c4eb156e67b2a904ba8a4e915d3c76d374ea133cd6c3521ff860073ccb0c3f0d284da50fc7b7a140268c58b373ca7870bfe1ae659c4e058e3a52db9c2ab2e60d650f15c77bb48c5405cb6560a2a1580e173b9e031437734ba199abdacb1955b6ea9e5911703c3473ea713979696d000904c033ca54f6fcf26c59211acb73e8920736ce4b4617c66bbb872fc918917936978ff7707773f9d3105378e98c9df71a0936ae91ecc34fcc357f8450bbb23ae6dd3641ab59182e9a582a2525de371c53fa0b59d59e902105c7ea78d50c5f23be10f60f4fe4042e3856a4c0e13de105cd5199c20b7aeecf19986abeac2930abacf6229468a625877b9cb59c68415fce4109ab729bfb270e3d5139632988cfec26d0af8df8841969e47b1b5c6626b54430d23ed731ea9a9727f2f9aef787628ecd0144aa58d64e504e79f5508fb7bfc0e71cbf6ec45fe13a3572534fc31e333567e52f648e924106ffc2ee37ee389a761468bafad3e9c824856cbd9e38e29e3e9679ff86910912a78408d39084e508f3c59dae82ea780e69831405805a4e29d9f3c8363976a99e2b34ef5ee91bb9aac767d2fc4bbe5d153b0e6f5b0552b0e9a7d81e01e2ddf61ef82449fe69a97e76bc818e2e34152d714a424c853b334b7a2f7cef3b044861c3dbd9e517174d1abb3640901e7105ab6352d646adf1033328e76eeefc369674a9c18131190b6694e34e037442db354f12f9ca2a99e0fcbbf314c03b16ceee86fac1a38457c2c1f65abc2e66db27276d68c21bf58ee85e25e08e4f599779466e8a4a05fb19a17b649cac4d668898734d5260d14852d343f18481f37b0914234b2b08bef90045c2c6a6bc43f3a61dda2a2945f5ababdd2fccbda0d51ab3c72a82c8a535a881b5275ddcbc7f79ad3436b2b3f8f0f5d08dcdb2924f9fc16e4f0b655775696d4bc11785fd403983c38e1c502cfd7011024ff3b0655dd22ded112bf9d64b3e0be03342216d2786c532af1165408935610e35920b259c7feacf7bb436c8787df629c17d4e76c167b64e707e3dcb357eebaf663a415ae70d8948e2b8d7c0c892e3de08e5738ecd61e18a258d5af03c768faacf5ee63f9c982434a3b09c035b76a74859608e2fbee2321c068a27277e4328465aaf26217aa94a7ec84dbdd7bf43878805cedd402168a28938f3d3703b3108df9fcc0f9dbef811175fa9c4d1c2f5a623d7612048b80388624fa147117ef6157bf95bb672ce818e0ca6d15604f0f3f6bb36c8c9c63c6db9371fd298e1fee84bf7bae9f1991cf1039c4bc0a5372beb48e700dc807ecd446d8105d349554ceabdcad9229abf00b57a9ae080fed8b9a2fa3609a7fd7f1f9d5eacdcfa6c133c1c4b9f7520e993058d3673aa074449d016ab77263505e0cd36d233ca4ba95d7afa9ca7ba2691e97d37d4b7435ffd9196ec610ae9f7642fcf27b80996d1a2547a904ae9bbe7814df29c073f36b989ee01aefdaeaacc12b7a01378b0481b063f61925dd6e182a4cc0102a6723d4c39fcf45214e50d986404f7f7dcc52d29e6fb18cac0b4b6b8ea3ee00587febc95ba6e4d43de466f7be8c2012d23dd08d7efd9faf758340c69c4f90a71c9d3c1fbc05fbc961cf924bf7f863e4effae77ffdd4e513d1ebba7b279b1bf9bd2e5f3c9ab79863ba3e92daea2289f43abde331ce2f6392df9a1ec618e8cfadceed14990e68c24a07cb8e7f6fa202f68054afa5989164f731c575a24a29e129797457cbe3fb07639d6f0f2bcdba0e25b51bce0068b478407e31a99ce1d06785fa9a66f86181941ef9640fc8c827b5c0194022fa1488843957d5739a0d81118633055029677037dee13097c38f07877e268c452396bcbb632e35d13ee71e9268cb1507f2b93950655762837ec0d482c0998de396f4cd21f494c6857f3636d56fa98242b29d9843eaa496d415ea431edc2e14873cbe946d40f09dad4c39632e5d82569918f83a08efd3714c29daf868ae886cb88987a92a9a9d4de11b4b67523d27cbf7b5a891ed79eeeeb9d773cf37c376859627cc6541d1cd3359ee97e27d32edf468a6c02c5af551e1d6f4559e1179778f3b09087f606b1381a68abe863407712aff3ce23f20f6c3bd966237492b925e926c1dee331bd1df0528f154427ff5d9f01c70726315612578ab0e6166924e9f0ef67b1bce4d6710ee5bc486030158c025dd7d8380c2dcf98093ed70a48796ef41fdd54607afe24fbb3ae52e2fd9b94006a04b6984075bcafd4cb8e32671d364a42788a01f0b0f6a6febcdd4b855bf03cb9235c90620f0432ac1b1f23d4651dbb3e0b5c7e0be14bcfba3e4e79dca6435ce0f21365ab57799b50cd419a2cf4fcf7918408461cb429f656547fddf140077ff1468a50f5d0b5aaa457673c2932ae093f7988cc770fd790dd5f462add","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
