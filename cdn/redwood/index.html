<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50963ffc8f9c96b3048f6d34ab5b8612f1e80db1ec2ea699976e0209849037bf059592bc0dd1facafa7f505ad201c1d447bac987843c11decd97b8bade628b0899578e020c50f4182780a8f86066ed0016e2b029da39d43c36240e13835cabd2375baa28f2238df04c683dac7f3ce5bdb6f344e9344c0a2626d2e5a3dfe36a8a213ff76a9945d692fbcd834b9cbb0418df7da7ec20d5fe30f5ff622000cd5eff0af770d6a469b1361a503e2a34f088763e664c62c10342a4c904d17db957becc81cf80407decd547dffc0d1e84fc689077d3a9c22a9a8886ed371dc9507c246334c21b5c2b916d525a31dd440dde844c2888db37595b6764c1359cb3838e8023c9180ed0cf088378eea34bb776bd3cb3c9dce2047be63a324260c391a53906a0e5e02f072a2cf21e009a5213f3da78746ff42719b8425cb143ab45c82753969b24120c378604aca1b92c6a1efb4780c35b1bf9f7a55a730260c1bc0e7f621afef683b1a3311859bd191b4d59eb650ad36e9d837fa43ab5b47cd40f320be1c9a5938e766ab7fbd142e71f81d9cd48e2c954f2bcdfd596dcc95da5777597ee972a9951b0f87e6883cb2f9fbbbe8bc6d72218b4536132c5b19f5f6366e63152faa34aec33b2d1385ad4f962f206d3ca8adfa28708aee153546dda67d9d620c940a980cbdb982940d0b707752b6eccafdc488d7f0eb5ee81b3555437fd375f461aeb1fe405da5276f08971cca20c6b83276010fa1468fa59dcb31d5993691e8b11ce7170eb33d42d332c31887253e46e78b7635c4298946c0aa49c15319a3ba0ad7924d0c6d1a1c6bf318f6708507c6dace79f30ab682a16188266804afd363b640e4bc0c8266960bf8d007fd9e144407fba996b5bca4048720b0083779dbb29ff56d11068f2a8fcf0dd9468c26212c5889972747c8fffa95b63d025ab795cdeef45f57d29f22a80a4cb74de300aa986b28c51613d530c1c0ba35238b60ed787121ff1f79fd49d604edbba5770161652f6427e2523ec5efe8d02744807fcac8c2ca14fc2b6aa1ddaec12d6f1ff9d71eafb57655f945f42564a3696dbef871d1413e64767299d69b5879fe7dc4632b3aed90c213c9c6df6204ec004f57a6f1e87efda3e248cf34be96285df9f7b1a0349e3895ad62a7f7253ee7a87dbc368400adf200392247043df1d70831dc584a80ae02ae0f6aa3c62215f6d4fad947fbc5ff12d77797ffb7d7c8cafd7eae0526ed70c86af27bdf70e8d04db6363b6aa03cdb5503f4e809dd8dd9bdb209a1663aa3c4a8f6f5e754d94063ad8a97066b870f8c86e8d46279ed6a68bf310e34908ddcbf1706eaa63f3ad2a1bf4e1bbda2c18ebe8fc428c6f9a120d606c7e849b6d712942b77357f48643d476fcee64bec36b266c4ddb96de398d775984bfd8e893ea60ea13871856fab1a32991e4fbf76efff642212cba37bb04abb2f12678c7f62cec37e540d53c7895ebe15127d6e13f79c2d84b46787144fc58d4094740cc7239d15843f8d9ca1eb3d266938d2fc833b09961a891908ed1c5941e9b86b449eae321a6ce519ea4f7c4e9990c98525a51198d196441f93c2653023f7592cf5c7df64e7baff47885de73f5f9f716fcc96f0d97ab81e21f7554d47cbb84e6a454d36a1c5b03f3e5f333d308a333eef581281b4a8e8a3624509ba57194a0099f02ef0ab92b1329b8ab6b85faa642322bc0e064d74b07bc2b670e66f5d1dd23c608b9658f1a604b75ebd3048b24eb516513a2ef6b7835db46534d2e89c74240d5a19a23de107f255bf7b347018d7373d783214756917fb3e212a003dcd85dd1f3db89b51fb7abeb65ac75d328d867667f6e4abe8e69ec075867b88da00af975343f9d94694b9ffa214f90b0698f3cba9b01773604317941862ef20a3daf4fa3b3d4f65fc640bc99302cda748a138df3345db71a6002828b57916765a0864df4c4d13c44123b777d7d958fe47a55179911bcd1dc6ec451816516e0c16ee4101dad012af0320faceeca205071feb2fb43040b14c32e93114f4c3a1489f37b20ae615dd3c4ac381659f3cabe7135142acacce993aa93875eb058ec2782b1690e3852ce5a7062dfc7f3a2abb3a6c040c5818e5eff117a7380c51ebaec1795e4d6ddf3db4601a04ffb68d539536565fc9c85bcf77c16c8c7a15f02374fa06bd3fd6375bd0f355566c666de31bb875ad0c6d745ba87cc3a22e357d05dbc06015863a343d3e3adbf6cd3bf24a5043ba83de3f2d79052bb380b6e91142838ebfe64a40ec6c9fed642550d37f69f1046eb3945714e8fcfe4a7366e4cbb7cc20fa38f7d536a4aa6c27491588f5889034fc148230c032ae9967a853103cb312f416795c930e22039a4c3aba24662fcff126e879887f251ab48b899e64eee46409ec7f1badc6f987c34dbe8f2c5c5abccfb4f24f1e2a7c341663e18d66de280b2daa23cb2e4f99420519060ce04b158a605d291430e265bd87ae3c06b5a13819fcc37cfdbbcc9eba6adf363ee4f5e5cd7ae47e55d925f1c47d5a8228e487304604aeac849de0b0cae9b08f7f7d23f292c35c2eee07e3fd0a45630e7fe61cb893b018dd65250568b4e67729f85c913847482a4097f3ef1e66d4d9b9526b6da6296fff2177d627323d56ea24ff302afb2a3ea313fcfba55bc684ee8624f057265da2a104b7222cb7a689e3843cdd76ae2f1cdc59a9a77ec4479ed2d20c6b826ff44f65bfc5e4db2692b26b9ab9bca6a2a8e370e8c6795340a548e2c7393edce6b9242e6fec982efcd3aa8a842b5ca4e2c23688fd0e141fe7451e56fab766c2e33bebe9c004b54f0501f8e6ad094567766348f62b72dcc9d038b866b6832c23312ce793be9128a2c64c2a8b84868ce7895a47a3ec42aed3b3ca97a3899cb14a96f4bd625c816b6f8b72d631486dee2d58aae68543f81ec8f089bbda4cdfa10c8181d63400252944d34a7b0454b231c382b100cc9fd4d0b08d006364cbf79dc89e7fc8a1062e5794df9b9a5deaa29bf37badf38baad0a77a7f22add0d06cd43a778a889f28302fcfe45c70e47627177e9c4a26a36d02e8ea73154e28a0fb1fd412635d5f90e4e7e368e744c604c3fd9e10f5bb4e5be47dd20314993326b119e9be2d18424d8a0db38f988ffe4896b90b203bdf99d5782f9c60dfb2c8d35f6a62f0b55abcac87da54ae4c306de0406307a7bbc3eabb6204bbf995b434166f03ac429272232b01639135787f9c9dc34793b83248e9a501f2654ad5392dbe6dda996bb59a4dc7ccecf7e4eac669ff9b928c0a2cab485e67543271d581e87ae33b941bc953fd59262dcc9871005ba05670885796674f79fa1b0f6f5e4393a4abf271f1a598e4966d755bc9d482c61a9738b8ec0d47b84e3fb64194c05ac614561f94505a00ada9dcb1e89dcc557b6c8ac78c6eeec3e4efe67cce4ca54944a7660b925e0b7798e8fbc3558cf888e6d07396c18ed90925c92fb36aef576957293ba53b3df03abebfa7fde9e5508dc2924aeda63a21c3e981373b14d987c3b39d2025095aa733ecc4a7f5a10b321a5a4d21ee70ade0dc61d19ee285dc15efa3dc430990c73a42b0409b1dd929fe1886e2e8a0e6201b8205cc835bf6a680bc60953d91078d0701ca7ca9f2a709e17e1aa4effa64c779e0e574c108dac3197e5f49897992d4a3dcb84f11c55909a5842f2741fcff4cc4cf57c3389ddfc6d8a27ebca609ef5b5df3723188d0056fab8d9f6222f8261460a9e38afab9f73e479e781d400392d7e35cf60e4db68346c6f5a68aad4c76d07e8985b678760112b94a230f77eeebb7c746720bfec13f59d0b44d65b0ac889fb61333d6eb42de4b620a5a3a3143d0e0494e5fb279e7bd1c90cc7fb0a69f4fba134458746b0332af752c67c5bbfc0f3898f8ce4cc9adfea759f4b8d8207fc56981fa3e66da054214b3b7cb23f2c8c1ef38191728c8042947d7865df1cc50b3c1c102206a05fa17b78d72692af90c90781573016e64455d91367141f997a9a5fcc2d3a3ed55a5b0c4a01ea2bc63d815a5efb3041ed686c0070ed7d87521517ed38c08af257dc66a09ae1ca6b55f846df664e12b54b96f2b55238165a75537daec4a3b3cb626bb2dd407d42e3417042e3340afee55fbdf586601da1f033e6947157105f6404fd9ba8fc88f8b69c1696964c2cfcaef59dff3ba2ec13ceb280bb6f916d2de38f68931cfed2892e9ec0aaca2cd6ffa469e4c255d3638ae7fdda14e3b2a1f4407f1f84551c99ed8a010f46d11fadfef3c67645272a75a40cefb2aa5ff0086f63c378260a97daf43e3703c7bb41fccbfea62e3ff02947954f6f7a3d52f944d697e4e0a5e15f51f32a12d62f3f6b275608be04bf7deef78efc3fb97e6c0e884de18109c8399d8f6e901affed993deaddb4ec36f034e3e8998f18c64030fa83eb837c5437f41db73142d76bc87c5d462b5d08cf64b7b0a59a990ff7b0a7334204c1ba7e2d47c4549ac4613a8564b6950bd3666c17158f30e6ba885c943c1a103dead9f5dd85fafc79a0215d922f10a372e4eb602d1f2ee81fff51e3f6fdae38062a1959a99d876998f2ac5e1c4a1eaddd1a9af81b9e41784e398d46398abbedfa38302e7c433589b5b0e756e085afaf609b4402b9a59ded877cd013d4ca439c440d23a2e974466f703e9e9be61318293200c928628ff65cc155321a4898e2199ebaf6ed85d92a0fd8fe25a70d7ce4addb8cf7e392a32c9fc21784031fc02bbb4f27da391380d9c9f0d3103a2415925e8e186d8a7b80b19e0dc53a480d2b1f5fc62a2931fef48e54e907e90ecaae6de77d7993441be85c923952f8d28f4bb098a0d728b99efe7ce3dc37b82f3dfa48c5505c788a00fbce0969ea3b00a2656d0252d40319844a88c3acd6de0c9c153d56b5a1e78471631566a77a22d7350dc26ce59b0e05ce3febce73aa0689293f43f38dcb755bca882f24afd13c0d5fe10eaacfa57e06bafaa916ad5402d2265cee95de16ed030cf66a3f09e409d14a1d434a716ef623ac38039c6f95b52548a907d16561d33e3c7674e100ef6b3916b5ee35ecd0e8ba6e282012b93db18e1e1654ceb0d85c9cea1d65fd96b20756b031bcb57b945fef5d3c0e89e3b4ee0782d1292df198d7a55dbdffa22892c0c213116f648eb42078f9b95e61b3ac1149278d9ca14fbb83ee5b19c248f21eb5aec70874556c684226906363b6f137d7f1c96eee674321e2c8d7c8425fa0dcba2196ed6a46a8699060cce7c848ad650ead71c58a0b124adf2c6b1d1fbd64cac100470fe3d7cc0644ffc10e5219e92a3d86a5b48ed38eb9b2bdb635227af4000a6a15af76362355a2f5499cb38b4cb3bf2db6e678e378a76ef9e9c893cca65f00a5812d01c795772d6dc565d3b07e7c3c92eb6bc75f7fd7a305367c72fb586c7375b1ec241493f15799842a549f163610102c2bffb521d2fd821a52430a87333baf412eef5c2ae71b54e74c3ce7a2ee8eee31a4a6823b947661c8732aec2030e2804ccd772b0b6424eab156016ce0186d58fbb56776a627f2c540b3698c2e24fb4e2ce6eb795e0aeb7a329cc1afbfcce1a598b96cff0746866b75e1bb9a35a15b612dabd3d1d63cd9bd3df9887bbaa0e3ce1f85c414101bfdc34cadcc562417a0b2f926543d5288dc693f94c30551743bd77134a2b5195379c7eb3fab6cfc2de7f3646b8c32a85158b529f5487c55bfe9c91b7483ed24a7939c027a3637d326fff2c3d6d26da95d8f80c580762c507fa05f72ecbb4517673c80def92c314c2fe4a93048554a9215e4ff5d7668856620a3f46fec72603c9feaefe942ef773052f184623ec628f8e6fd0172d4a3005a3ee641d4f2ec5e6b1a30ae50cfde8654794a494fb14cf46f485ad181a235d5c11ff4b56d55ac1f54f7be209c744edde1b252ec0c5d8586a5b567b98477fd8750450a566f914b92321709d3c7627fa77ba9657b042f3a62219124bc81a6fc699567e7b28ae5f7016f1522fea8c2b369d3dd9b98c3156d997ff8fb35314b9477e015645665e5b12bae38aea60b6bdce3683a42e00ca2185a885fa5ca9371991cd980cd997f035390a336f8f11d88d3b71f60d9a137080868676ccf7e8fdf086451ed00e5937196d7c0043545ea5c0df05408d1c9514baf84ece14d82c9b313dec23987f68a26d9f2b59f9139d2cc132d6f9a6a5c7f483efc6622b8ebfbadfef7e46f618cfc4378703ac66abb0de2567fcc5525a77a8af99ab558d97e7dd2e07d3c119b9a0eded3737740bc2f254ef6340a61f02ae792c2428f7acf896268a1f457aada2d78298fcec61be0301988b0df6852de8d58fe6e37897d3e7e0a033323372583ad726d272d03488c67461b5d649e2c4f366676a9ebd00f306567a29a0b7a7898d8a1524fe932d0614511fe00c9d8b0871e87a0b4268ee845f5f5c1bfc118cb21d3dd6a23c94afd4cc09d35b9e1ccb89a8d8432f025feab93de950c99868512ef214f7277601612e15b86f86fd027e77db2ffc2023decf692164f8abf958ba070b5df1cae4a31129d654ef298a3b3506d5581d4c6f41becb9de4d0e1efa55336717d1227ad39a12814a03398813f5ec0f76e4c4e0c803bfb2287bb43a56b8bbd5096e3f4325b6287156f8b17b340d8b3a83e5921c52de6808a8397ecb2cd16edbf01d1ed81a2b3e5e6b6b1f3a960353a3b9cd31dbd2b723d4f455cc684f2c0bd9b35d0ded1a15da0dd3702d20e13adb2abd4ade4eb05b555dc0687ca70101e96122eacdf68dc26b2c2df5416128cc8760998ef4451587750706ba5eceefd9f6604b12b9083c515f2383e854fdb1e63f343478cd1a047de59af8724bf45c796b12bf8744f7c3768c33520e9621adf85cc6c700475cf3b96c45086aeb8fbe29fc3cc0696128b9ac498280e747abdbb0e73ac9e62279c2bf18e08080848a0dd5aa9023199d6236b5fbd4986267a5b507b4f858c992ddd45af7c81c6b328a1f2cbeae0997445dbce5b3129b7b967e85e1b92b6dcf71fd323acf64c58f58fc22a94d8a323a3c4e0544ad4f77db73bb6d8c260fa937889d5ad32cbc70f1b28ee8177ad649046fd7aef2813f9f3daf9889d2e42c90777b1d8f0bd38b3215ea523aa8d67a61298cd3bc3741efb35eecc32270623abdc7b2e28af4be7bd66bd4ca85ffd97085742da24c13878f920a1cfd92a9f70b399909ca12176eab13fdb7685cdc46ad49cc044324fc84979be000f2b12e9c89744726d052050ac49a24fb11c1572012dbe3ebbc9b393f2d900c7ba95ed3cb7ea61aad9ffa9c891f3d183fd19d50e63a5b1cc5e6c7518201c9e75229d277e738b7fb31d6ea1736b7b7001db80b0bd624374147826f4849484c2cfbef8f9c7acc5766b8d8688c7be3ea32958b5c20900738adcb89ca699574e028b5aef864e73e73794e19304cd2c11611f38cfb75e07b46ad835c5d924c21a2a25b028eabb2a2b66a3acdc95d7d3d5f2f810ac13c8be0cafa1e9fd9ef02e68a18453557114a0d48ce1f2ca8477e800ce2bfc01cacae2f113ee9ef17db300450eb6bb3a7257c6a60ca832c60de6efa430eb3d3a3b79df571be766a063d9a4f449398234d7c9af93d233cb2f4e0563ed3c0709dc99833fecda1ba344b9d665413a494aefa52c6b7767d9b56aae80dbcebb56ae34c67698e0e4895d78fab7583a69be24ce001dd9bfec0717e1db9ea02f009854197bd543ffb9ee023654d5d418f57239d55e6eb30da0958b84eaa095a35f2bb3a840bb0092fea71a0e4da0d3ae658f85730a97953b8433d5219bf84619edf059df42a34bd957131c619aed94a64acb68a7a82244fff85e8aa8b74ee6f8484a9b4229793396d1acf0a54680147302b9d4dbf60fd4dad530652da48e42a7b1b4be020762fe4cd7e3f1e7cbaadc9a3e1b860c042b34ae3a020beee61409394462ba88a9001b617d072f79b92b9a7d8dff8cdd421dc3a9236c0257a50c878a3e8d6285a0a74d00686574f3cc0e2abf27009f1418174646bcec3dae41032577365879f85906f50de95272e0d09a593a7c91ac5e6249b7e92cc4aa9974558865d1f2b82536f0f0f25df6a13b180ea9bd86a82d9419c45cc96c83b15c370b04a3218d8b1c1c295d539849ef9e765890a8a5980dca94cc77811ea431b3f84fe576cd471e3973ad8748386cca6e5817831329b7898c718a5274a7224f1f44fcecff5678f1394b4429a6d39d5b6228f2a4648eff8d62ce4460cf0d23aa1ca1c80df3e6d958e8f37a9f8a5747894f89f19cec179effaedbe55d8fc953badcad73bbcb86f8748119a6c268a10b4a564994f57ff5fa8ded8b0fdcc59271043bdb1c873c1081e8a0a6bf62cb7777798ebbfe9a90a66ad3ad53fb9e7a26bb06d22474caaefaa4964f6c3d5e5c7e6281c92943f13aff593339a2eaddfa9f1c7da07270d7d926da311e17918485c3c650468afabd6e20c5fa56beb7cd6b8cac0d6ef1669dab59fa7302df405cc9bb54f751510c68fe6ccacd0e8e409f72fcd6302789aa2cd7d06f5e8116b0172c7fe20dce85ee167e723eb9171f31f23f6ba0cad09725fff6d5f11d50b2b9fe6da9737dbc5ecd17c3a75559118ddf610cae80290143dff8d6b3a86f08de5cb9eb71a880229024060e500922c54ab0c14aa36d43e51b436b4e99cb015f1bd3091cb2df9420d09f6f590862c0d9553b32250d4b629eff4b3a3696f216cac1db52477699e98ee1f8a913846d47553a2e9e3a3285d861e60978cd52290177e9ab08bf388e6367b295244d60ef89cc15bf643a90d0eda9dfc980f150c7475532ba9c1ce6b5c4adaf2bc92c6e4d2907b6a84b9d35d6926b99e9de4b67b99b6015a27c33013d9eb76be43e4d4dbde16253db75270985ed66b5654cc81e650cc660c226252195f4f79e434510f45ecb4333bf674b6e37ef8db9eeffe8eca732e55a331ac4f3d9d8b1b7d82b86aa58d0b0302199005d7f10d193eca954b9d3d3d4090fe8fdbc65010e53788b5fd034ade9f20e38810c6a495477ba4a7149407907682b99d864461f580edce505df68079dc75a6e6cce88a9ef7ef3ddfaa837c72d84ebd471e1bab781d59eee3a440f0806814d70f90ea8a360c259189494c867c4afae4e0e5cd718f89b6a04edde6197cf361dce4aaa668e21b5f6233cc208817130b5ad8686f5e8f8703126047b091df24caca8dc082d34b0fe6c62f792f6223fd1c3ca61cf9ce631fe84271111e7ad1bc6bd939dcd4bcaa97f2bfbbca1a74e5edf86871d91eacb84a0c23a35307428b05725eaa1ff857bec9ef197dd6c61f6c5ef8186c1894edf909fd57bdeb12af4f5984f1d887020af6a0f29174eb4e929295d719ec3df690ee32762fea7fdbeee4bfdeff7dcb4b99856e5d480a80f98e8e0724c1e082863b03d8f9933ed09959cbecb31f57afbcf841a5333719bdc686ca208c55f35ae79c25c2666aaffe48a882a4b291f8242e2ac675a5746e40863fdf7911b3cff8f9d2499aa75fde83aeb0ba729f7fcd2384abfb0d38de374187a07ea34bbeae01c5f4bf0dab1da256692604bab831358de37eba199621c582753bcdf46a98cfeb77ccb2cc97a02e5514a4683062215d8c987dc1d389741ff56676de5273c79d25e2f067cf0e44547888daa35dc88fa2f158e04370b5f4864ee156a4ebbccc74b66335ae7ba014d3316c945d8ac9de37d8da4fc63a9a210ff008e9da00d798139b77cff8de42af2ca5f84830226787e87c18e8e8c97a4bee9b52cf28ddb9ece32bf82214ae23bf77c3a4703389054cce0471bd93ea8f5ab4f3d0de23bc098dd8956a4029e9cf347e0b1e115d89f68572ee842b32a9f50ecd91d69f1953c57cb3ba6208f72566f56586781b79231a83a95620f03d745e9b8666bbc8f2c949cb1dcc5c20bc4073e4711e7e6cc345e3caf9e1b39fa9ef0c2c0eb995f236d2b429c8fe01662683586ea111113ff833092a9fd0253fcbbb8d2bfc0bf3fb461f9132213b959845f7b29166acd478942c9488a67f1b5d7f4b2f63a705a78e24b4bfee81be9e49001377915cca3ef4c5a6b14b00024d921860ef6be4c511177d1f76275b9799707e9798ac636a8f09c342b18e6c044b68ad15f3a20022ebbbf7531fb186d75a8818d3337293a9aa23dc21f8de9eaf211e14fe7c7ce2276b27b4326850ec0609a000f95ff3cec2f6d2ecfc581cee908a347e89ac09cd4c986c278e200127210565105f04725b923e20a8a62f461cc9539024d6b898fc5fa700b6e8593caf989132a1542ffe54a6d2277d83a63eb3f7fe346c29848cfac5c2e53c1995e75d1953c4670a8e0e190bbb7f9230c17b098950b027eff2b6ad07b2b291d7716eb4f4091c0723e78acd86494ea6a91cb8457a816cb9a9981df3b14dd9e2a72e0a59aa001808cf835f27ec657d4364e679d6acccd2ede4a7ec48663e0757840bd8f304d555de8f12b5f5002e9d3fa025aa9da4a20e708c9937c6b77ac738016ad875780c973e875ca38db8cff78d0f3031d978ddb22bee043b1a3ee7cdbd28ca9817154f83603b3de53f7ee2e781501f3ad30c20982b963560a854e3a6ce5e1e52dc78bcd75225ada4cfb4d8055293fbf04e4e5a2d148595e096acf6e4be8d8508c0ff38aff3117380e8678ce8149f91bf11d5b9489d741698a162029c4fa682801818f21e889949a077d89b01ef17203c928edd8f15e81658bfc46cd097e363bb4330cf6722f9d90cdc04c3bf2e0df62af2b9afe393c3b96b9a083246fc51a12993a2e896511afa253acab741bacc9ea36c5a344f4769d736621b9c095f9b41a69d6581e8f8797cb9138082f3a11ca5f468bd555de1e3b0667bbb64b81ab430c0a211bc1445444840d29d5130d9ce5597f5a66d12a74c0d0fd14714467ddae786ad41c01f5e648396a25c51e2c8135f6340301ecf41c57b838f76975b3b78d5a30001589678c306103e69fc42c2be0d6bead88030d58cebdf9da9ab2fd0feafbc5b708abed81f8e1b576123bb862958c1331bb9ef01116f435038dcd9b82273d90ead9271d57867eb113932c9cede7a16d02e56162662ee1d9f37979ae2f623aff5bffd390a7ba358cdf0eab8d660e8c987feec9e0aa128388be6d6196816e9a020ad49a112bae156a98cf5ae7d5a61f473cacc2b057c8d37ac8e2dc148afe58add2bd8ec63eda71fe8005e0d39b8f64a96810f3f0dfa6fdd62f09c5b965f7b56c79d3aff98cf6f1c9179323300368e8cf629f73e51bec11002f0f6b64a5bf38dd92aaf01d01b17296710625b85b04d7ec0ce58970ddd5580ae509c68e84b4e6a24d60155b1829c3dd56ded302bb2e9f194729977bb6e41d936ee8b9c9dfd7ade619b80786b4ee7e9cc18e6a8a6860c9fd4446a955013a38e0322071470033a7fef6469415468cd62114593a61e03267e2e42d27329e1507e248831d187466649b3c27c9b85c5f26102cd3daa95cd67883536d1ea66dd625c66461a33f2fa0789db770954cf2600d8b607f4677e05cb237ee2918f974e696e5c8db475040b764190fedff69c923978521a3758ac0c673a8a1e455dec93b055480b40305a92882448e6657be0b09857b2860fe536c159c47f71329ca722408fb3986021baf7c390131aa7ce92306006245f51044f86e5fba41e02b55fb25de446cd7ca21d856e380bd3b78d503ab3fde989289621ae147376a3c3edae3aea470ca79c0dfa28af56a21f3a762cf53902d40feca5ce2766838f485520f27dfa53cce0a3c447aa9f28b92b786d357f75af12ec6abfb188ed8981dbc7d826905df6be3107add523250c6064789ad633edaf16057c0f09c2f345160e7cf36b173e0e85b17bfd81adc5e685bf3f708ca95e1ee33d22a5bc14290d9a7d91048fd0db7616227885c9a71e531bd716afeb4c5e7556b5ea15c1c913aff567c4f5bb4fa4e3b27a0053bd86cc6691b5619112520e917574d56dc1f5ce0c777cc77c1ad0a64a9c2e01665c23791d5b411d1c51e6c1ae406c65cc596cb7ea800bc1025fa79495fa7a8628f1e6d0221e4e217697e940a036a2ca593456ecf425bbe1ef2ae3abfbb54ea5bce7ef8cf5456da2ea79627f7895ce9bced1debfb9db31ce3abf9b7fade2afa27ca704df8970e10f7b5eed70329467bd954f1584627c031a5ff58857f7c5c72f57a9445cce7d2112be567d79e1540183158f9db16c6ff3695616dc09283d275198e42a73a2b692f971c25104276e72cd27dea7d64a063beb8887d4eaa9c93f72b0571f1294c17862b2ff72a979e12651e0bdc471621c4d1658a8c802935c926323f90657f5798e8f101b01a3f436130d96c74b098172298988c675354618f432b5bffb69547c7c7a0a7c2de4ff63651656bde5662aa334dfda3e32bb2ff397cc90b32fff315f6330720324d840870d12beaf82cb644890a71fafbd9656a50ebce6d3d30e188295aeaa81768c74b66df75bed775f13b23efb97a061a993c7fe2b459f422aa9e074226a0b52e9a2355e5956ead5f2a3436c2da3f3e77ddf66929cb5a9dca33618e228ed6b5d408c5669dc5f98009e7e78ce7569e8bed4aba8c011bf141b303850d351093c11ec6a4c59b442bf5a4807bfb5253af2fad707e4a67ecb57d42cf2ea6209529d5081318e027f8c605837f2065a86ddaceae89bfd7729cc062669f3314040b05a6884de9db4299dfcad22e7cc1e1288d3fba25673e6729c443348522a2a4ec3a74e1d9f8ce1d019d92fbadc7018fdcff9945c81fb8697f76cf43f37a0c163b0928985438efdb04b0610cb086e4cbe49a980c25ddcbf7e8349e3ae42438692da76219d8bb6fc6d9971acc0f69427577a3359abe24832989f5163a2e4581e7c32889069d9bd8f1326e428802d0c35f82476ffe4a44de98bbb12d6696780aa6693ea9862346f8bc2edf191dee0ad8166ae6debf5248c764048109f58ffa9d6d7760bb86546dbc864dfa0203c21a42a12ddd551df80ff3b79abdc5784f35013f607911f5d79c091f487109940daeee9fad8819139021a1c63e8c0fff492fc2aadc6835596ec9440b08a31ad8c45b116c7aa360c1af9d195f24564fd02a882814d1bcb589f3f996ee293e807759bc37970a57542783d3875d80e783adfb6ed6f38ed9e29788f61ac27107aa6c8e7fafa84540d6d5df138c0a2435c82075146b9e87107c576402e2259e2c5ad960f883bba8463ad8ba2ba8e019f29c49f1bf3d727025325d775cd91ad767b663b12d95fc954e2cb4dbb61268b095916a0d6b4f718a3a4848095db25708ca901110547c79ddbf6949b651df9a6f9072a926cb89f1d7a733cc3042ce1ab5c0129bc5a012ebf10352f3c8bcc51263e30044e2283758bbc4a70a846d0eeddcb8c059d2d6c6143e21a5f6f51bc421d9d16f48cfc5b2220f588c7164d1bdf3bb6178a1a305298cbf2cc69ca06308af3fcd7469b17d3809df2af48671c4791859fd533421e9bc91a89feb2d6ea09cfdfd0156d5c77fb0197c8f853fde344b2a79b2c4f637f47f0d44897fa540560f7c0c2f2a67ff1bb9a1ba7337236f99814ce1f80fd9cb198094e108eefd2cb72c69efad0ccdf344039e8ce08f6f3ea093bbc7a38eee8d8292f28b945a0144616739ffc015f0df24d8ea54813d8b896bcecdf335617a89ad8a5600a6017d75c748b05083446c43627d9ebdbc4d6141c7da8960de4ef161e6353249d63565ecdeeed86f4b2c03307aaa4ee10a8b50b61fba68757663af8d68c0fd0fa9390c6bb02b00d0df63744834d6fd0c52a0daee85d4f8d6804f91a4e5f3d6c866f1040a077ee7d584244f37e41583dc3ec9d91165c8930b32ea29291e32f6c8411f1c3ec6c0d05bd601730eb9beb886c63dd0f784a90f3eb741cb93d067761378aca12fad64d7fd1a0e52d1cf8c076621856622d6845d68abc081915ec13e22e1fa40750e7f49109e4d8a29b1a2e97d6ac16551d43c24d5872c6b19f755fe22b5003361b96769dcc200805f88c1622609dcdd890e590f97b82767fa25908d974539696ad4ec241bf1fa223d63b40178a37f54f48722c875178fe98aa077b011cef52bcf00c75ab48dbea0032071b822148f9c8abac13a1c08396d2238f06ae88302bc71986c87e3395aa40ebe2ed7a7f7bb001e2f9b3535570823b4b7c546bb4578ada3b544a9439f0af087265da16bb9c23dd33efbff0d56a660af1c3a776f16c3d09dccd8e661d422e1db2f0b41fe037fb58b9cc27a2601c508171a0a8d75452e532bd8eba28aa3285844da838fd11565cb6661682a76019bb3d0385b718548b011ddd44de64e3ade01f64867f1aa258d3f13182bec4c9154908d9da5cdaff533125d5c12e85a0614c7e90b309df3354452d2320e09d93c79f5cb000e0799fccdbbdff18191f78d1ac0c1a8ac9907856777bf570c474401f93a1c5c99f72fa3d2414149b6ca5305b9a66ec8c6bea9a69c227aba01ebd23aa7d1b4f192c2db4b22cb7b129ab2b026fc9ee7205f6b0dbf868ae3d32a6f8e86a4e584a19d0a3fa49ef6c0e2fa39accb360b3fe876a2658a4d545c3a9b64d4bf58a329e3f9dbecd0242524d6bbb2f54b08494f157d0739b1c007fec6e849f40f0190fbceb916eeb439ede6e30b9c717cca26929c1b2aef437b062c2c2eb63735964f6486f238d8f99b3023daca3fb0a7cebe8d6e014edf96f9e54631dddf054e0df82fa26a068ac64dad1e1965e6c30d4182c1617a82851eab3e5b00fc3be58cf7e34533d77c869bef439e1e189ab483758f31d5dcc10b6a625426290d1b114b8385dee7e2fe23798633e7192801169e0242636167c890c6a673ff9b18be0e210ad6cd8888b01b51b802ade078f1531e3c657b01e803438c18d287de76899424e3386dabadea68ccba9fdc429e848b0fb47bb620256b9a7963b42a60322af99cf1ed701e02d390124ba2a6d5f6083553b7c6a9493599d6d2f80545878ffd20b19f8f175450040a0938660ccbdffd77ebfab099ac88bd06a5e49b8525d799631f982ed2d422384c6cab7f8eebf0227328a210ed4d3f1249ccfa7d2f665fb0fece6ea1cfeda97884c45033c404c1840ebe6d6b74252ecbbb55c6f202bd0d267e5b65e059f43f1a452cb492e9f240e7f598dc5bf1d0be9143ccedb13fd83eb171a1712784d6a91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
