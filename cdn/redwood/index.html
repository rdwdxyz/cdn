<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6c081949ae452ea310ff8a4d109c5d9062de6fd1300d3fb0b91db34cef64012df563212f8f4eab865c3c77f55433ff8650d2bded62784b6b9353c2cbebb9a1cfe22ddc94b74de6e7ece6ae608d398305455093c7bb4cdea4f0ab99895529069c3294c5885dfc02d8c8f68797e2589d20bc2af47830fbf64ad6bea831c88b98ca7d1379920f60f80fd1cb92b6576e5805dc3715a201405db85df3534e1d1596cd5bca342214e108da518a983fd078cb432f0607d58f1485070c6905d066ff4211414832115dfbaefee573a2d0e18814fc5d1c34230d660691231a623f492f4ac53ebda90903a8800328bd1a74b07acca30a87c07f58c895d7f058efd79bc9187dcbeb165317974c2ec6864e093c67472193126832023e885dac531f3575430da4eed54c64fdcd9f8f3534cfdceeae4efdc2b75a258ef5207bd96372dea5a3f943e83930b1f7dff94feea670f13121f24e9cf9de9a12cedb803546927997b24c0ea91405d8299d1c6c07e6356f80507642770680f33533f1cc9ba2d6e92257466262ac95413d702873fa133cdf42c3c240371d9be13f282207f5708d6b09fac041302f7af4ef340d6abcdc259c9f7b823f22aaf2b351f3e47f47850db35ea59630a40e54ab1ce24fac821bbe0191b3f8b06d21e961f49d3099ae9588922e6e69e19db0481c437d0315affd122d65f14ecef9af1eae1dcde55d79628f90ae4983a9652a7df5d759871d088cec5092b8596be54920fb144bdf65a647e795d5f4091adb74f1382e6b5119dd520132268b0c48f9398ceaa485a375a7d1cd869e4a661fe3e4be68388e9dd5b0b196ef47ce2728481c7c1f3b58b3a9af1800099532c5f18d821273e627bcdd32e672cd61e7ca178cf9f3720b65d0bd73fdb58b57c1572aa07f30453d04c6e98b3a44d2adc18579bb879d2fdc62d02f4060d1ced135a561b61d6d84a4ea4f8713d4d31260721bb6b3c51b74c235bc2a53b2729d87bd37d838e78e2d2356d89d4b650a542f32e76392ac572872d4d85e8c3af4cfb42c23a4f6edb72bcf688f5067a5ce36e6ff418780be58fd716e1492a410e2222bb818cdf8780536a897c7a69c29ce008d64603d5efdf70ffb810e96441b1f5e7ab067b2e60866e41959d2c10282ea3922f686c025f9d60b4f22328df3b4031eaf93d375af9e9d7a4dda0756824e69eaa57f682ebbc71e7f2ab7f49610ac3df22cb51e5320e42001764787c00f29643a248f1d7a71e69fe085762c937d22a63542dfee415bcb7e873527a06329817377151616fbb96b5982cd511b94e2bb6a15d2bfa1b58c674b5a32277695aa5910f00574fdbca3e9cd029bab5d98cca8816a92ed3180da7d4e234b70120b58bd9c72eddcfab2c425bd96ca520011bbbed7500ee0123a170605919bd3dd270791d90db354c4cb69ad0e571b07f7d65aba960ad2fa382b8dc4d3f7d9e93a8f7126d529c5355af1e297d97e72441ca5aacc676a20a202013461e646c26beefa04da4bf9cf5edac15ed83e2d0b50c488c0baf04714d9991e9d01592c54cb1d1985f8bccfd2e53488960ce74d744bb4e32f6f97ed96c79b5be0e2ff0aa4796531e0cac7ade31476fd4a7c9ca25a974b7be5edf0473472aaa4a17fbcd0bca9cd1475106e634074da9a1e4fbc70d4af8b27d8daee3abeaba40d9c0e6e01ab5d86bdb78e4bbe7cd8e93afa6f13cfd87e43a63885bae33e3a38c59ce309280adfb66a8fc25c5a997b49c9f9e0bc90b79f87ee7def725423b176bc497a25733c0a8620e075367bbb9dc47d1d1306db9d4b0643047c75db7c1642440850ba9a21ceafb826e9a1162fd530acc0a1a085b426066cd871b708cb87b89317ac79691c7551a321765fec1c7dc74245836a903b5088469dd32299671f514d5672f3d400e6144550216c225c289489fb03e10356cc02393707f2cc0aae0f2d0b859b2e948ab200f5ccf116b4f68fc94a0019b93d384704307c634a32a8fb1c011ccffb00b19c87f37125c6a0456ae755245e694a02c4025de0f3d5bfa10d5b8b7629e8e9febda02981ee758ac4ce5c4e77b8039df8a1e19644d62a2b5153bd832586ffa2dd36158a3a741ea5284c243a7be9a271d5b44fed28dbb5a0482a232af5b1170fc5643b21a466d0f113226944b4a42bb6873ad823a1495e1f0729d6abfaad570026592ed1ef6cd2a934af1c6ac78006a658d75c9bec348baaa5152a5f7896d011e8ce1e282ff13659d0899ffe1a62393b6e59fd40706e536ad77da76f35096bbd4ce91923e03c7659a0fe53b3ea04cfacdffdbb1fb31d6fca3fdadad291a2da4e68a71d9fb10780a03247969ce025659599a0f980bbaae5d22a4522e9fafffb9661c02ac2bca89e637e8001d3798b7b4d6df4896baebb0eb8bb50a66634e28b7a7cbb44213519a5b6aaba3d23c18657c14c0884d3f8bfb094de2890bd717833bb01e4ff117c8418d3d3a608d9c8894dfbcaea386ff3b866fbb44e6b3f906ecc5985a390139b915c5ce1ab24f5c85e32332d2842fc85ff3cafb2d6d950a85fd43da59e1c91acd34e78fc1bebac8eff95f40b146a6369cc1881d08221a7f4ae55ab3d3bef9f8b766629d9088877dae48545ee1fcfc0f39e1a3390c8aafc358a595b51613d7ffaa3ca6c7897f7a8da1be5360526914882351c762b81c9d7894eb7c290343ffd999d699ffb37417e28533395a50ba935938fad991cc0b4e6fa198842d96977a5c3d37cec8f433ca8bc830b5c24ec6f0fcf73d48525eef7057ed248a6994ed414572e1afe545da543d4f98662265703ea3f7dedc8e8685316060f4593d5b57e32b65171b16420f9bba7246491d4aea8de16fd852ee076824acaceb00e7e1fbd1dbe45c5765faa7280e5f59d5ab1d4af126fb0f74bb40bd88c591d84c904d0d64143d0092d4556342c92355724821daf49cd62532609fb635d8320c260c8deaeaa892ce75d3088e9131d8b8f5ad09a2127a1988d739684117388d3171fd671715c1a9a225f7d4d2ee892df31264ae60c2c26e005e8f0893ca6ac419f3a6df340892945768ec2e5ae91e8eecca2d2bfa6565be079edeecf7a7f5e585f55e675e22305a4742f525fbfe1acef27c726dbb8dec56e60d8449337ef4ec8e9cf90ac578893230c321d3b61775e9ca1876f5dedd1c5d2f5dea3922a56f66415779dd6f156ea348a8ef95d08f604ed6da422012cb2d8f1cea55990b7f0b56b0bcda018e78e41199ef7fa0971892e402a009ad9ac9504ab6e7855db6519d0078bb4616960744bf8c72c6bfaa83a23af37812aa6b39113f6a83340270110aed629b82900736a4d12e3d956a616bf45a5a79a48b4df09abb8a532093221f93d55cbe0984e263a239e2df83aadae67c4f77cd1243d2800762a225160ae78c6fe2f922ec1fbda92443b57b8e9ae1e126279838923a7056b132c562094aff363329e0c4d72fe1b85ba455b66b26ee7b93c0cfd7b21a8793061dee5e92947f4c8df4f3098a2befd65a266b98746300e6bbf0c7d5cac6f8f1cbc8ab7706b035bee9e3a8b8e77deff8d2d6845b1bfca817ed9580cb00b77a3741456b7a2d384847ec479139214d4d51c8116c096a34978bce2f697587491ccb6b0fb8158e869489c75cb8f0f978e9d2baf2828663fe16d9990e96b1684b8a6de1ce8474deb6696da91da3eb2abfa5884ac5e5077d699bbf1cc1b614c72fbedbae5db3ec2927e0dcd29236470dcdfc43f740c7c92476470bbb32aeb4758b811b95574ef16db0160c2a7d52816ca818275880a13c9206a7ef3d574c35aefce4a1f70f618d9607fb62c14e5478edf458bea10fd5fddb62efce3e16c241f761898bdd7325259c5ab5810d839d2b8f9716cb3b1c5f77774e8a5bd5e2921b8a077ec773adf4540d7573f7ba9baeff991cd68d4db92115093743b463ee49dcc9dee64609b480755272278a32907b9b94d5d7eeb4e2087a1189e308e0ffc6833eb64307b0cfb841c8974e37520542012ddc213ff246d05ec0287102ddbaace0cc97600b83a7018bce2f3f7a7e8fd7623e683bd228d484a756c1da443bd3dcec3c95138626eda5b29f4e799993e2e2f6147f5a7af6ca87e51a05eb77f598188b92ef32151489564e05fe2e2a00bba2c6a1a5a49e08391460a79c34c986ae8443dfc6e4c8e8f43003bf66e9a220cbb03846e54461c0cf2fcce5513228b0bb858e44ef67c3e70d042ebee62cd26230a18444f5286b8f970ebeda8c38ef4c36454a6dd34ca33b3cebe5f7027bdb89adb7ff50db40e11d242be34f89711a4d1a7c6e2cab4ec878c56f35f0e5d7a1c1b53af1bd05c24b1d0bf4cb9555a173044412277e91dea87e6a245d9029ac0fc611baa99732787cc7a7aa7143bc816b5a45323f46255c5e49bfeaa3c1d7d370b5e1cc500e6aa1313b4249d58bb4573cc2711dcfff5abe0aa743f856946aaf2cab11bf6845d1fede09348dc7652b1fd7084a076eb8b218ea3dbf91b8e9cd0578ed115eece029203b12bfe81d8d2e2098c2d779c18ca4c3896fe90f84acf5b178048a3f3cd155d07f089db6fca5f21916a157e113c55626f01dcb2e9e422e9f856d73087aa7d83acf8fdcf1ccbcf178e19cdcca9b631b399a8e50c102ffe25d3b732c816a4896d7d6084c79e2c5afe6257e2cc7cfded512b0edac77ed4eb213ce969c1e60fd0e28e5749ab3cfa4163cc0602b412c29f8d4dda9bd3822cf3a42ba6614567168846bdb39518e968fafef26be6e799899e1b69aae53ef6ae741b0178f641424a3592724a8331120143b3c276f0db09fef8a00f01ecaf4b3ab7076ed3e070b051eb71273722b0e561dda2d10038a20020a77cf0ad89f8aad42f2e2f75bc8f15527932c295b92cccb01571f878ed22d291fac234ddbcdde1791090ee3fe75076fc77645d8676396ac2f100815df09e0659ed92cfe3c084d865a762dcce3d6d128b7a76340d1e98fac7420ebcd771d67a597c27b0924b5c152df560f33274fb60d567a65b273d7a681af4a346450ad0dba11546a744e52c6d31ba1fc84dde74968a9be65f9a7acb8d42c32c04f84ce839f36e339b9b5c6117ca535054cc06bbe9e8ff3e7750fee701b9387fe00a9f62bf5c7c12fe59a936c43ff2a5e1fceb24354816fd53099819f5ed702b0f4917f5a592229815f1d2745a281d1102ebda7949eb2262c22199c801dfe881e3eb4f623bd7df3c8e882fd2ba3b744a93cf77c395f9b51549347891e69a8c7d3e5f719ff017b74595e3c2894ea7fadc0eb539aa7274a8774b18b0ca85069ac9ed1431911140167142f3c2fa9fee7974de2a5eac1ba090509ec377dcd4f4aa723cafe61c8ea2737e04f5d188f341edfa9d1472ff74f3051257d996b68a6ec2ebf3cb007cd5c475187d9be9885882288e5c58ad7389c9e143988ee7c26ab366e67d10875471b1417dbfa6d49c78461fa039c988ab17d04a4846decf28bd168e0dc84aa87238b9833235d9e1303eb80f39da5929f2da9fb2dbf1b6fea43ef6631b32da94162a94152c82786cbe4b6715cb3e9327096eae70f33972e3373f6e57157256eb828682730ea2045c1b59a3ba568e92988656a2eec6b8ed726d972f7458e3a32dfd293698d824c0412ebb5cb41d4ea7a2d85cfb963b44a809722198cdac183f6f5581cdd21d2a569fa75f9e48cf75d65046c3143e5137fdd79397e8febe881fd98017fbda6467447eef0a447c8b2000f2a95ad2090c2cdaa76b1f6896fd3cdc253764fcebcc8a094b34633f67681eddeb2bc54e1fb3ad7342724635461d26d71fe7810556f121efe5b63628a4219e63409692783892ce753054fd29da8c0f1bfa0912bcf4900a07a4d3e5e9b3839896424acf1efe99fab95ed2c8cc6b7fa6e333a268e485a9242cffb8f436d5b1761845e40681dd1d43905ca093bf3841829dfe2526284a69be09b01281e29fcf8b9f9243edbcefe05237813c3fb59e3cf78a1f0749d308952f57215fdebf699d32a8a0164caa340b3c33e08093bdb9e5fd49b091af3f7cabd4c1394ef3fd19760040940c283f48f241626509a971b415e629a3b2e67c8dd032d039716f394ae2636464b7e2c8fe7cfd327d645ecc7c7e18faf75e6862af34a7d88d401156c9dd1b7000225a53e0b413de865776a94ed16144e9c266ecbacb0be0fbe229e1b24fad9173e5daaae860e63dc29b91dc1c18195249b003a85e827c082b20c64c44631cdcb96834055c61d546fb1a06877bd30e80bd87e67463430791b339445e33a6eaaabf08a0ca28b02c95ed5bbfa5ad7b76e2e4276c965b028d3f97be175b8d7b5bd8c19640f07f72cc330ac82aaef3863246fac25af18cc5b7786eea09d0b1025982ee416da5dcb783c041031a8ed1ab7d8184ae7b46321e851f85e4d3dfa4e8b2b07aa488ccd1a38924420f6d4083f21e9ef99bab357c98c7ee8fa6a1f6f95b95fdef073dbd4100ae7362e8bbc8bdbb3cc9a6e72e220972ebd172ca4b3dbd856fdc153e5c77c5088549b3eeff73a39026fc2bc47d0f73f74984fd6d59d7819716cdd01216cd31d9356a2c805976a22ab74d794fce2738e1bd9b1581dfa6a51a6fd502ec57860bac1017290cfa8373d4f62194df15b738baafcf02118f389671a8099b67e8328b78f794a80399beaaa97697039d0bf20fc6c739a35a07f4978ca81fc0e156502425516748a773cbfe8598b66319b5396f7492985972e2c6cd9bc2da1fd9b924c6e6c6e0d7176d1c3dad61f45ebfd7f9200a945faf73aa08fefb51194ef2de72a052b4e219ca4066ad711b8bad3e5e1f4a083aa2cf392a0607fe714e34c0d839ae952ec5a9ac6d7994304aa121b2368a9a13cb6c7904c4b265dfd201b81168289d621140b5745c520f8b249b991225dc45100b741e52d1ee45bcdda9dca072de75da84cbec47ab71b74ac065937cfd341757ece7d32499e39d5eb81cb694458468845e099abb2ded4c4381afcc133b009dbc666d8f72b4024b7592ccd1119412d582be3824719c26b767b8518323aebf0c7ac2057c21c5f0f0e859b297934c7de040fe26e26696367bcbb3bfb087fbb19b7694b245407ed42afee9ba14b95841ee06b7f6c2f67b8b588c95e295cbdc843b0241e9da961a1777aa390287260454b60766d8fd2e58bd02297bf9eff13350f2c37b8b3839aee21a5a7c7e01dded419d028ef963cc997df10fdab1b6332e15c02a34bd92d7fe5c18526b29fc6442f73a4ad4493ca5bed05c619793d79c7a7ab0a20f1db95503c02ee310143fceb50680871d422eaafaa193a98710c537b72685e2ed98c7072327feefd2a791e59b08ceaf664d94f9ede227cc3b352b05b2abd8c9dcd0e8a522f67fbb8c2ade62ee0288ee1abbd9fb0e76c9ab8b8138e0647ccdce752ac21227650bb82596c809ab7f3532bb686c9db63eb2b7e826ff800dfdf5a669865c8d6a69764a8e9f9c62775e3dfda8595435343a4272e2565f498d6a5e27f2aa2083649c10b113c6f10385e0ca348a92314e7e58c51d442d1c648186d94419951b85c7fb896d184f1e21be2de94d28581d79111669db78ce60491ac3836c18e59a33f7059f67afca86e75be02c16051af1ce0ebce2c80fc9e2d31e3222e0e5a00b48fa6a9fd818f24a973a8a7f8c9408b930d54c8308f409c4ad1a8e0b1c33571801b47537de7af87024066913f2c363335ec21b09e65cf7863df6d29afaa841dc31b8c018abaf5b0a29e03b8eb28070021ac9572049c2f4f8a02a3e87bc13eed4cf818285887099fa7353f9dd45dd8b6ded82c10072a9ccc9a99c3a999d6032913e18f4733eae27814e799d7940e148c3d07941b6fc22906958355510ea9d9af8b589c0ba7c6131ada01da1d954c72819d0a5b2f968e229d4cd870ed4af9534d4337b64be6af10d5e5c75b884487080d44c124e247ac47dae87f8e93b7d914be90a8513078944f795cc8857ee98083abf6a34a362e58b161cab5ed17649ca5c1411d1d647439c991fd7206402a5f968cee39c30323ecb4256ba5ec7956a5f725cf34edd53412b91eb031b4db3ba7ad5e1c9b4612d089217379bffa0d266f820cdfe28a7ac538f8d64300c19e00980bd02867cc91cabbb03320953d822ef12aac0910156ad7608aee2f7f705dd8bed55bdda42447559989c6e7a33498258d9394ab0be6dd82fef56dd7b3412bc3a6dbf16abf115f4829ed8571d3b6eeb25cd71670004c1df461c4d4e2d860baf6cca07af72cec0c21a1ec7a0a5e08259f7f92b905f74da048376dd58998ef77fa815cef590991e3ab679410cac749dc39b71a21078c55a4fefb6c24e9979ab4b933736cd76b1124edb1bd79702ce398fc6b71133b070dff73e3b6838dcf4ee4997e9f10d0edf59691c021b9e0883dbb417db37b80f376afe239ba9e10d16ecf0407afc82987b51ff691dc6ef12594bc50cf8641d2affc21c85f426887c1e53720ab57a4b3995393af23478d0ad6c10a4484329aeefb4fa6283405858ee86368fedb5a0a837c15d61cd2a33bf9fe5c5db654bc74dc198438b4684063dcdecda8feb386b10915c6765d59d1e08b828d328bbc8af22df50ef2500c459f3d3d730496460da8b05e3b9821f585b9e5b579a5d4e42f24893d0fb1d75871b022b635ee0be3c3c366f4e7cbb0e5323d442c519866c342d88ec2691f16d11f16def72685e9998d08cd6861927cf2832ac5e815d14869b4545fb13fed8ae00d1ebb9ae14782645b98d188e7d4b943e06bc8888e05ee69fe5f5811605f36570900017055bbcbf47d8e4008eccc1ed97701c1536445010b5f99e1cf7b71ae2a77aabd24eb9aed56b801801adf3e28deaaf4d274d5f2acbe2d1c2fd8e25e2ff58b88e12973f94a81376cbf81418cbb64c2bb898f441fb2136ba952290a79868941c395eb3cbe37ef3da213a0aef6cad03ff84643f16e167570e378c5db48a9d20b8ef97ae950861e0be5db7de1b26f43e54e2e6b1e45edad6d52b9a37c6e2216d4060b7e01e52c04a22029724d32219a0b5ca315e27158c54d515a706bffa88cb731fb8a79fbc579aa638f97b0fa7ad7179d8cb96ba7e6e8a032094bd3c39a3876eb5525ae8e70f3a2bbea580dfd5c86477765f0e4366e39dd70a5803dea6adeb62cfd971751977acca8c0b3ccf3c15538c2140e87d0f2f7689eef1897449d4210b9a3226d4e4757baa0c1756253cfc2c811b89c6f98832ba50400ee597954509f342e637aa5718f465c85d024b231577bbc18026d7863249fbb19306e2f992569e9b4d07a1c0e21f7694d4f082332b69bd89f22b53cd9e16860edde65fcb961c62b7fd6307531844da8a29b2c8af4fe55cc683ae7b8c34a817e4aba1fd0cb8904c62a2c98405b4d6c7fee0e51c57bac7741a138f1facb1872b5e51e756b1a30c600a73de2d3ccf91584af6650bc5f4dc437c3fc40a232984afa0dd871496c78fe722a8c3e29474373b3ede48859efde9d2cfbf9b55c5620bb3dcf523a6104d04103b32d085c0f0923a90d05cc14ba7255edff3ec15549a27f7b72f611d2c6e2a81bfafa7a2a65fe0b33515eb54c213b24212f1bad8edc6a8e0e08d60327aafb8bdd85a82b9e8ff130e88e3ce9016582743b6bfc546a201b4b010456a0f0fcd38e3255a5a790fde14d303184fd6922d1e9837d46b51937e294aee6ae59f639c4f6ff85d0ad5c2e8c49031581590357da2f3ee5dd62be8cac0c20db619734d9ea8ec653e5bee90dbe2bfe9f2f994bc85b2982186cea87d9eaa296042f0841256b30b2658c3808df8ae00f81a05cefae939ac5ffe035247e60acfdeb2075eb5ca9b0acb9e31d3f096fc1437f30ac029b5788a249fe1ef4bdbeb73283b4883ca5abe76659dc3fea6e670ed40affdd14a6ce1314d640020580fb75bb19d623fe35629004c1fe8b6fbbdcf5cdc76c555dfeebc0dd426e9c04529b027996f6c2a5d2a563073dc7c9a466f9d6d6f6f1232965a2b28b6172ecc06a1edbaa4bbd5cae70aa4a3c879bfaadf4c1f5d84ca4066b4fe766e0e68251fe9773c4d523797376138d9d55e026c30c3e52b11020bcf7f8493f03caa9a77645feb279d7dbc5fb9b74726d46246c147dcab3c2220aec17e65912aa2db4c892ed8d736461b1a3063ee16f3a279569bacf6d6212a29cd5530a2ac8a49e28670308dc1b024affb729dc9657c201020f066d39a7f8d0d9505a8d55c3ede0a9d305eee89747e0f05a510e317f6e7c6952ed529cf35278c88e0225e11eee82e684d3d2ed904f95662d0f63a331c6f47d44309ccffb32bd04bdee3badca5d4443c48e400a82f57bb53860ca2033152b6d366804a74d7da0551b09319bd3533f9ddd18fca0b3e6b53c9e945c8b8fbaaefa1e340a5fb0c7417f953d7523ce0dd50e99e746c02a85107d6d58afc2a14e5ba9685caaaba9a9890f2e3e53b14708dc719ccb159c4c815e170024a2e6297f977e354adb7bd226e5d5b110c396b073b7b0a371f2a81ca84eb71ca64952e795ed9ec42146a54cc97db7096169110750ed49a59e26e6cde5c1aa6cd341fede9bf4318c20c0b1f285a5cae99858628428cf14c40fb0d781edafdbcb6fccea9a50f7e87bffc61e4fae9d2117f9d48c07ec9e16da27386205027db64bfab28c52cf8c08d9e641400272f1b180641310f4e10d4959da99cc72aa93c34c9599abd4722c04357d502405909bf5dfdab89aa7c2e428783b35bddca3fc6de9e45b81b938aa2387b473bef2e85fd088dd4fe2964e514375aaa7d772df6d0c511fff475b32b134c5cb46aa1d778362c588da7fd08392213fcd9d84100b999f483831985717ae94096db15164a930ad81fe0e67c8c0b80fec2dd59d655568dd52f90e6e1765dd1477ae0d9aeb071a43a660fe1bf022c469cc4a97effbc78d053b94190d1e316e09bd9e9b9432e251c473366693c6d14f1bccffaca94fbd2b2c69cb6fbff95d40987385bf533319f703ffcae7a7baed50a6816c5471fa110ac482f68978019dcdadb755af3d500948401033d4bf65fed4a5f7d5e0fb27d83e9bf892a5b17548e0de55e072a3ce72af16e15a017256935966df18e57d318f88ac832098a3d8d8b47c1b4b7a89efd2f10f2d031e78b649d8ab6b93c00d552c80c69f3307912f86ef00945c5d07f3f6d83a07c5f6d2e199960e0286049d3d572c2ddb222d91543ecaa6a62a63d15113462384fb3c9f3eee5e24709e027e615a1ee9b38b59a098658af70b83e5d8916f6826fe5c85bcc1142736635228d9c831688fe85137ab2aa933272d25599084b556f1aecd6c8ce0cc6055db6941d05f1c26ba8ff307ceef25a3f9b0b877f1864b421c58288dfbc5255b7200130e58ad905d5fe808b10780688ab42409b4bfb1abdda356d4abf6d362c462f10e1d2ae62c313e68eea15f1bc0aca017ff40d2694990d8a44658cda603bcf92517caea92321a32337a4231c411e22ef63e66b9b5d444aefd89313edc7e82bc491c2b83ebb9a9449169d6ae82dab850c5a9121460bbf8c80fab9992490adac7f6ae3c761ead9e29fc547a535a41f79fcf2af25bb09ef5e2106d0a186971f192ca3852c35a582aeb76186895b1d5a15ea5b0a6c04ebb291c9e656985d63f875a90d15c2c4aa166368941ec85f8dff5ccd0f3d744a9cc7463488ab0a0956977be05efc4935e16442978a783187c1b5e14b73bffebf862eb3db071fec6b60cd3de61e2936d1a0df8a5e293a605152504365c7625da0e13676331ac6b809cd3c183194976ff305ec1509e3c95a8db5b6729cc18fbb8e7ce495bdcbfe95e8824bbd864fee17b5ae05558f36309632391dc1b692e1b2a6914ee4ffb08c2e4c131cad113bb51bb1b1f08217731db8d773f3a28b39a7985f3af2ccaf636d617702397c3ce01039d3144aa511324396fe8a9e43506462171c8f26b6da82166e5e36740e3a37a05610260dd72362375f72b74f79b6c7f6685eb50df2c70c677793df43aa599fa5af5e7b6b75d2b1d8dca552a70b575672ec9100cd74001f0f154d89215509276ea87a411b0cfa36eecafbaa60aeedaccb9d131ff6f07904c1f91cbe70a5b81da8fec972b6ba70ecf739972311d506327056a0b1cff7fea8a11ddb7941a0a92c2329b8d825b8fd8e25cd3f45a649bb7dfa3b0750a23b1e3d3fb3877704b577c464e1585717d85ccb15b5c04b1fcac5b1206de73ed22693f14ea946d9ac380cc1eb6544a3c515aeec45527a36c47df8deb9b1f07986567b7d7d382013e61fdc22437fbeba697a51013df8f070ccca5e45b98f9c5f98fc0b12f896e04811fb8ef9616eb2de064f14b852b3b610909eb90ac238067e42251774f6fcf4f5f2091a73cb93aa79ee24242b334f172f80b3076c34a5a43823ce57d30b57d62d6aee21874b4b933f68cbcf52890a864adcbc9e6f4a8229d8f2ff894b59ecc70c300b6ccbddf1779b99df0cd1beaa01c60b834d930adbaaf54de32860eae65ee550f9e31dd10c6f937c50615ae1dacd68eebbbd5aa35fefac1277f003c2a5f4421960b8851b141bb08a5d757a09b71319b1d1001c0fdf9078c8f1944cd6e53abbdb77313b55ae4896ec73cb8649a859d492fbf7053764b0c68246dfff183853a0b456071299712b05ee1bd837ba1ed1a590791f30e77feba886981a59f47a09f761f98f2deb753114b976a2571955ec0b3ba7d11fe5b7eecf17654e0aa6d234c4c762e208d44bde6065fa752a8fa061ccfc267490e2d8ad4839db4409ef5bb1737ca05183b7a1966dfc6c9fa28148cf191be6965764e74fc891a79e7ce1358584d4a99f858dd39797151adf1b95f592056476a767d7ca0f2f547578e9bce6e9084ca50dde5c326d8085f6fb8a30d049e7e587e72639ae4a9d55e8e58ab8b817df7a463d99195b69423b12da99be615c5c359db2a0c7818858a0891516a283c69706f4343e7e62b789ea0d7952a78a6cf7e4107368c6ada5ddfcd776179c8a9951681109ab148ce75ebecf08cbbe81296d6388450bccd27bed68f832ad2aae3d2eb080f08b39fa0aad1e23ae307fcebb5a8e537aeb3a458caf467a58559ef82ef92bcb7bc8795d0581fa5126e77e8cffb1d4b6fde8f6f8ed68f609e6efb0bf0815bfd493d3d52ddee2303bac7055e6d6477555b65fcfb6bc78ccf95058f86aaabdacd7045dd104d5afa77e1b3405f42853437b055160aff5aa98622a36c588b747c7ca228cccd6272f6fb45f47d6f6af09834134ac98e5fe9fd780f73da99177ccc239bbded0d5f9f1ce8d2ee4ac510ae52a635d146381692b468251fcae6bc438991a9a4cb9a5878b9eced4d1d3f370b5439bc4906f085880611fe122042065838d26db5a4a5b26301758066d245dfe279c742d047a71e1de584c73283de1214952f42981b6cdeea0ab3b5ae1bed6b41e239ddbeb794dd465907c593140decd7ed1ac15df2896c4e1cd14b1fa1554c1ba4fb8426177ad74db1fb872b009145ab9da77fed00538a683632a0938338e40b80611eb64fc371fb650a87d45822fc066833d48fa8808a34888df155175899f982ca08b4fc5c158c7ecb09ba47b9b6a70f3a0decf2eb89e1c411a6cbf24cd305dd09ee6a2ce5795b8b2076485f56cd7c5153ec4d574a1f3d3fe5d741c5068708015795cab1a1285f190516ca796f6915d46e9a520d156685e5bbfef5faccf34dc2815da232e8656b329eae909fc4b713f30a3e780061ce381fce725e72961e1595af946037f18780bcdea30c620557c2240f430ec65bab5a66f399b801baf150fd9317afee159370067e740d1be13b1b338476178b64cb32ad75679504fbc87ef67fb6460348456ed23eef71d690049720bc17f09a87c90956e519c939788ba8e15f190d41975a259828ecbdbf79b47e4181f6ad65a46d58dbf3e08ec79ad136629473f6cdb57b18c98f89afc0ce28dff4c0e40f8266f0a7660501a37ecc35fbbcd6e3e7bdc0001e9184dbc46561bb9c1936190a5a21749e3210f8913f194a25cb16e3fb670f16b48b5ae3fb0a36a2a7c51397ee4729701409169e35f1e27d9d09bbc4a632eb569da69cc46b29fdf1aa42120d17497005cdd2b9b46264dbcd485326536b6522fe961deff5a5f3ad2af958a90eb270420333add1548661565c78e9c18e2655d72d233c7f333349534a1981b5507982124887795ce1e8c785568e1f608227a40cfac95d22cef3628056512e589873502f7226a188293ea62eb3d943167f91c4c1aee2bb2a37a4a376139378d2cf9782510def0e49a67cd79f9a5b764b52e43dcfaa42f74ce7ed67741f6ceef5aecee93cbe172e2a828ac170114d8b8e61746973687d44c27e65c9119fb9a55d80923f7fc626d2339623503618597d0a654c83cc14bc01ccb7901953b6ceff4a271754bea8167e569782d5fc06273230646b53ec4908fc6aa2198933b6f09711f7d59dd1c87780b5430626eca1a8a0f891b4f25938758f3182208be22ab091abf1c7df91b5bf1482c9ad44e33de2eb8254b2d908dd6dccee19e89dc822c11106e56d4d959eee9782455135e3ef1cc8f40aba687383fc53abf961371172d4ebed3fa8bc21b87d09f99f2e1110e00d1db47fec61b852dca38abc09fb670647e9b692c0e89af1a5e8e33147473ed16162d29ebc510b8de268ad17014fa3cea034585239b72aea33ec221a5d1519183bf937340549d91f6598c817d48d4af11a1a3d76a6a8c403651e17804d265a329d93b3c6d2b94e1a865aa18f104b9bafab9639dcf459606998689b53e3908bbf9968bf60659ea829539e417c5aa10d88f7aadf0afe352ef90addf8b05214b33f301caf6d3ab2dfcae02a34571fd6244c179f34ea54069618a98250d7d80c017a4cad72418249637811f077a34e9200506e59bb89786c11fab6b4a536a01acec379d143101ed1a000127f887ebdc50142c34ef714f9b21e77f28c3c3d1f9e6b4e307b56bee9a76bbd72fd44d89aea55d610d7ef9ea6a0dee3b60c0df33ff16e5c3c417c0efdd7ba5946dd172b9bfdf8ccfb9731fb2a5cda0b836f5aa99bbf4d629016c090a75e85a724ddf05d214c8c485a88982224e1ead55e5c89abc1d76ee97b40d9bd1fd4c3530495c4a82e593fa3080ca66b7406f3358b80e117d542af0196a2af236a05442eba0f458d24a12fd655e604501aeaf825dce58d75171f65b8f48fcfaf166a257156a319e33e33094f0a367690435b9f6ddbe56e2536410959fabf7b2df5deab6e19282716d4fc26c11d5a82991e08b96bc591ea48caf5bf2629a0f84afaaa002deacd92e48291c44769528a2ffff7a91d46e4ad2a502cb75c84b321d31ab227cef953131a04abaa8b4eff40c796df3f54f606b5f16375e11e8aef9e36bd8fb3c52ff47f66e116f6b3ecbd11300357ad580b0e93f167a414d89219fa4fe4654901a35c5a6de0851620d42cedd296174d5ec7218aa2effcc8b8a16aa32f37e7ac381756e91dd6e75f6e5b75cc386f9add8d50c94397ff1e86bf194a2035dbc3d589f9782fd54afc3ca149c8f24c97274794a34154acdba5d36181a89245a933e77be7973310ad5dcc61000fa5c864182c5aad97b6ba79ea6d4f5b9ba70b2cfb774f9233c648f14e82e8ceefc9fa831af76a7ff13f13cde70ada71afeffffb27d3f1f6b149cd37befbb4d8934c6d3e98bd35c98f82568288e88bea71d1bd905dc2867c218cd1a1fb3ca5b676403ecdf2618a9bcb8f8477e66d9a5724458e48710d6500dfd1c48ca56230e7a3f191b35cde8f839f31f536f7a2b62b1c2497b8173d935683dfd50eef7aaf6893cb393cc4348b42287cbc4703f6dd9da0514324af25a29c71a9cd6377c97d194d7f916616cc5515af66c6404f82a4a48df648f4abae9b7f66df0146b438fbad13c468180623ff8ecb831ae957bf4b24bacaa53b6cbcafc4c89acc7cc6fcd8e7984c860d6cec106f2749068567cb3c903cbe95d5d8e66f2dc876bcbaee98ee537b1e571d3c0fe1b8102ac75b4f03a676ba275bff7f9cee8df1551334c51cb690b9b306a4aa521aecc233743ec7d4339477f4a60c39511018b12e0aafde26f6412b3dc2ddd062684dfdb3644ed5c237b6cf245fc95fab95429016617e1274acee204e32d23f8ac3e4eeddec3f6b8ca8e8b02ba33073965bed68e1e78886f9923aa11eb93de044124482dda9d458526552605698f00bc20f11b93c4042c8c5a930511ccc6b651f8d3e7105206dda1c19293988dda0fbb91b1e23356c19eac51212cb2b8d209cd49f2f16063c186e4f64fd4273a41879dcca3eea621d4283e504cfeed8d9ad8079cd96ccfcbb42a630171528800b3015ae1f58c0417fe8c5785e34108e0bf6f5251772e0f40f9eae1923f461ccd8d2162142d7831648f4b9999f23d1d440c4e53fbadd3dcb346f81944d7760858beb09d5832397c99509fd6fe01e2bf8852379eb8260e9228c6bb908b0e96db8984cb94fd3eabf77530dba25ebaef9c11dba5dd0f17ebb7f5fe9c5185b99f06b10cdbc23c5248444b7ccd8816854491e15e940a921f25e429c4072260eb6232190a8d6835fed2241a6a9369851263729377edd1e03cba4200a5f6a33d6a7d153f4e86606302bb2c2b1f014fa890e2c5ac931210f9c508c488fa947171cf918b36c3d5fa14fb36bc85c2e1494b3b43207d06812e09158fef7976a9afd3ab57b9162c4141137d2f4ee6acd07bbd30af52d4694bbd3baa29c8d0bf91c2ae5f4778ff1c0b84554b90206e17a6db9a3b1d19b664251873d7d288a41b7a9ce2562e076c0d914ff554bc43cec9e217870292c6eec2397481427840c686878e8aef3acb64a3ef6ac72af420fc5f13aac493c904ee867c5414f5bacf2ea416fdcae38d9569a273c47a52afcd9ad208aba4dae64a4f4532411ea998c6d816a67d83aa155c7eb66b76f0e1e0c5b5cddbdb14023c312ecb7ecbd3e0103a154998fe20f7c14d4762b28b03fed21e4735caab34dd26d47a2e70325787d8c27d8b4fcbe10fab292e02b542f36f6f77c947615e61b3c3e276fd99eaf88032a4c4b20ca18bdcbe2a9c43fe509fdd5327f063cf4a94786a1bc7b6cca83eb01f7dde2e8737ef3fdb60ff0e53ea73015b85c984275e3a4b10d5be05cc1768ca5d88b8ac8c72e1b5e0da65b2c8ae06826a3bfc969fd5ddcc7ee2d586c91338ffdce45bea17c6ab66182b96db9947e5154bd14302e97450bcea790bb3d4556ed5eb5c439d897e5ba2fc03a401def50efebf1dc31cdd3b0b9bb06e355b6ab67618e54f9c2f730a48f70278d73f8d0b56a139d079029ae70ed3429a3f274d6052424114a104be5a9b5bbdd36dd6ba68d5aa4a88a668ebfab66f43b86bdb444c84f8f7f16af1df11eb9d20e17bf05e0b80b00caf45b88828427ba82e4c41c2274b775d2aa144c9c3f233a37c101091594f5a6c1b721aea402cd3db6da9690f3ed2d81601f03af525e9a466abfbf9b4c3d1be30907312277f71d911661e38715dee96f4f1a0015b342b759d9b574b83c54fccf9676e243648ce32fc0569d86d9c1683b66a65a4d0256cc7cb37863c5ca18089bd884add684a35a2943ec723a9c852d1f80dae37b91f1b8986526c446cb65a0540dc6c95bd1ef68fe871c2206a5c351e4563168779e8628f4ced7edb145aef852df31a89de87f45a49464785ce99a89f074a19d1fcf1d052991d40c83f068adaacd76d2b93552dce29e88e1643c36fa61e6968c4e38bf14de5ea0d5bf98711e59db8a69d63a66150e68b23690dcbc0018e3cea8091e7a2c38a7c79697593a404bb35f25ba662385cf23d72f8ebc748f4fcd307bf5c061bcbb663903c9b6375b7676a0306240a67d7dff6fba95590cf486fbaf2f42a368c1d0619de188188b2639e3bbbf682c27a1c92fa5bf9ad171d59ce5b89813fe27aa8df34f40df9aa11d22dae27b3263d10a136a06bbf96272c1a21df602c9f845c366856450df1bb37ce46532c0b8db75a38fd8ffd66dcf8d52e74a61d3e8d07d1061bb4586c9cca2d89a7bc9b293584f8965b9a71e8fdcb175f5b8221bf874435dc804a2e73812b14c78316cf94cab224b26eae9912e42f23aa2973d4c585b006593","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
