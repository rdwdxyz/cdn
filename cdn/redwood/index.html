<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36d4f92f48f4b06c3d6b8dc5c14d47c4a90e2720d56b3fd90bd1b97650c5694dca89d92b25c5ec01d00dc4f36d1d9585b6cbd89a2ae88fec93e224156a070b8ef9e95e92abc8b6944c9633d37d6f876bccc03532b47c1d58a78f013915a939b9d7627bbb468dfb024ad73ba2c5513ea93c7fb2e77f1ab31c91d0b5f62a522cf997c09c2a2bfca6215edb920b4aacf479dc072a70e13fb4710c131797bb17ec28beef6696ed4c9af2c57a5d6fd9376d6f4fd0a3f2f8580fdac9ff8d245697910bce0a3d165fa020faa63d8da83a425468948404e149b136ce6639e37eb84e2df718c8a0f9a5f952f54983d80cacced757ea49d6aeb42ba5d348f26af39d1dae3e4f0bcce784003129df10c0cb037d029b652215ae76bc143afbb9f5a0ea9b064865c3a9f4d4a729a72b8174bd1c1d542c9e0266f8f9d67bc3789fc7c749cd67cd6d14d0f20075fcfb01c0ab5b5d14d02b3c478c1d55a16040b003deda05e0aedbbea7c06b7ba8da64e9bbbbac4d0f8410dd57c88fc711a20580a251db9d30d980f068e904d753aac52ca093ce37d335a5b30559ce1832becfcdf14074238892e1264fcd2d125b50dec79c3a2208eaf5a4e4be0665e74012d12ba7e0bc4a2138119153855925f0eca543e02fb03c342e7853d2dca560b6c7c756a4d2e2d1b06dee00dfe1b8903e76d33c19b46198dcef79e126984004cc1bf73954a8223c4d21956551f252444fded9369cb770d000df9ef6a3a3098308f420ae769485bedaaa6b14a5f7fa154919d2a9d38e5f92239c7b6984b1a03835e1ecb0e770259b6f6c7482084c34348625c9ca0616322e16e3c02a56380f6e118b967d3d44914b4888f5262ffd84a442a57e67f0dedc214603e1f2887870cdb26513ee79dd0fd844adacd88440d0c4a32bf128de41e35d26595ef65b500062ed8301485e700c69933e584b351156488b4f471ff21788c6f5d3b0a6ebe9f44bdd2b7ce963d81334654e278933fe55bc01a0ab7d08db4e9f2b22fafd41dc9d93dbfa75d9893b27b9eeb2a73e59c0ffb5e5feb33c08889a3d248d50a3d3a51966be3a89070bf7a2cbe90d85b109ec736112965f767430ea66d74ed31337d42a6ad146ee30e9abc01729196623ed73e9a6b2f5bd74f034a513ec63e102f12914fcfeee837b1d7494806ccc18e7293625c3602721fc38dcaa0a809bb61e371418056a645292298291c8867b2a04b1683d4312a75c01ec8cd250b5029b8fce20deb3904ee25ce60166c20067b5ddafa60bd6ef038936ca28c80e9ea311ecb618c6a91794a1e80d57450ed276bf2870a4673f23204ceeb806322ef4e7e4c2ded43da8ed4ab6e63f3efa6d78b297a5b6c5fe3ac8d1245583dd52f62f335e5782b2a2a8a756e9950f6b2168fa1679eb82a3b1930d9feff2977845bda7c0ae834e2f59108b21a3e9cd9cffa30dad8ec670f22bd963383d6908ec028ddb59d7706815749b3a9b1c6c9ccb427c66337ac3f1f02277f55293287f0fc562b63414cd60b6ccc42eb3740137e147ccb911348d63fd1714cd49c4e2c5340d0bfbb5b920673e8889c412f033f3aaf4d4ecbcec6a65ece18f7dda49021bcdf3d8b7c20180e74a290ee538904fce93188636cf0d37eb0a5500d9ab4bd24fa6f23652ff6535fedd5d71337743f3b32dabd2dc11a183f59005591623a7d7036a140eb111ea378411f4b479d25e15502a89a0dba92aa4fe6bac7b38c27110c6e06f242eab4018585f7302496ad22f2de5d1028ff7f99cc3f3013eee9e50ce14a437e5abcc39450aa10833f74c6a7d246a77c1811c34b7ba583917cb0182ad5105b3d4d859f2fcbfc98023127350707d592696c2f5385a8885f1e9301674ea8930b8725eb38a20d55845190cdd99ca8187da8344bf0222c427f492b9c463aa99ee8442f82e85966f291466c7f54ce882acdf1508150b037825d56198438d11c57b8e83fa588aaa644dc7bdf251fd33837cfb24d6851a5616edeb58f218fdf5c612e143676ad6c496e8014387dbdb258b35a64ae5bd6c0a30b8b08db54bcb2898f0ea06a49c3a025c0ea5ae78ad52c493c56c5fe020efd067fe69add9afc535b9ee7b1814f80b539771796b2fba97e1687a86f018dd8203eb2b1d1bb41629e75b60696e381e9fe08aa82912b91695a4690f3d814db441366311e16fbbccf907737accc034710a1a6a5ae41214ccd5f21b87e76d90d4f8f5feded2134cb50332ce83f14fb9b557916a105c0afae3ba823e535ae76ea6d8c84598bfdafd08c1529f15dd57444580f0785899db6dab083904a9ee075b8e25d8abc7610782d4f4f4d9a632560e65a5824620fafcbf5d0e82dd2b8865f9aa42c22c803b95ca702173aaa79af22f893698cb4471cff9ddbafbb9186b9509c59320ae2ea9929b551accad15b358153b2cc1b55340501f7c37d1544b0186768250b6050fe42585d3db414ffedf026b34c0bbe6f4c0265447ce28764149b7b6263cb9eacc589330ca4f50a29ebcca3a208dc4cda22d49b2d8517d708103f8e86b283efc7c8f87bf4086f6edbc7954385e44b599b48f88a51b8756ec29a994c818f37292bd9a40c0e123083b79d0615e57a80de200b7d4a74eebf12dfa0fdd54205f6b5b5a68a4c57d39e2db6898e226c0ae19276aa516dc4a65efa535f1a6c822a2b8b3b57dd9386da9bcc3a0c72ca68b2d4ebc706e9879397e9a72725da295128bdd226e0368e7ff3e70f915195d918e3d906bf2cbc1a0f693ff85096f2dd984d848568be7dd225b55e79be98d06e410b3321785a8a9b7b51e9af29dd07257bfd2c43402713989896cb3b2939c11f29236fef915edec450c242d3782f748edf950d7a1e1869ed7ad9d922cd3ad5c012912713bb0cc3c5ddc562c36b2764b9daaa626093b2ae6b5466ef6f15f97c64263723676be6161c83a3e82c5c10f1238bc4685f65e1643fd46151771697499ae95832e7029903500afe06b8709a2a9f4f84ebee8f73104659c3be90bfa3d0483aba0672761687a850d6b78ef2f6f861f7a78bc6364f87b047a39e5ee96964e90e203c6f4721895d1ff6bdb92a89c419b19d4231f7f6cbde74df8dff20d08d5609e3a48e90bd697ce117252d9680c5f67ef0dc48519ae143d642858c8b3db437450929d65763aa3d6ce7b6f7e1d8b006e9ac658496449fa7d05218a0e65b971870527ca8a6476c3a5811c335a2fe658def0afc61f6ffe979e267da7406c5e699b6782c0a38cb55594f183c403f6a3c4849fe225ddee09e29f706b78a2832368f015029706f7248b59b30dbf5a7eea1ca097eab5d9a01336da04f5153bffefae1515bbd73c642aeac555e6ac4ce280adc2fb7ff4e156cb8b0ced2d7275dee946f912ae0f6243ffc8e89199d524072097b5dbea64bca8edf48363c631ec7343f11251355917949339f33c69544d3c34395afabe0e255f865509dbdb79edaa94325b00fb87b96401a929db89fe2721bb99f217fc1b752b909af3934434ca30f7a4816305ba3aa15363cf5fd7a76e4ac70839e35d186421ba38a37c49abbf98454b82472ab276115bf0b7a44be48dd53b479656846f436aa693ceb7c52a1336180ff9c3835b0aecece5d90c1a84ea18617fd12adcd1bf43fca220422f79bf445e4b3769e1873099dcc85b8822194596f130a1d3a8dd4d688a8e17edf1e4a366b6f771292cdc428626ff8c8c2de16d15767da6a5a2b32d87c3d723c30641a0f9034a7ee2a341ee0b567746f09079cb0c73a5e03a950e7a7f2361e7c41a72565108a44dc494a9bb2bd7207dd599cd75cff8c48f70d38e3fc2b6c08de69e4d4f6f0d022348d7cb0ec61a1a7d10c2e37061a3c64fea8570600133bbdcf4bcb7e8b653cc1ee1b64de4cf8e1e93a108b57011b127631f408324d5a14709ae9a960cdd4b893e67514bacf7cee0864f44b777769d3d0a04ff435945c12bf0c0eb96d415325b7e812e9203ae201f47fb2dd8fe66d2125c2a75b83278207e92de68c15706272fded88bfec903a26183ca15598143f7c9414931cfb96bf306aa6eda45b80643c820497f2be7064ab14e400c6060a889e412cf3b4b5cf4b196dd0a1abb39f9c4034aa9ea630b339d3d59204b38ec8e4549c773e9a173095696561f6a4eaf71be627cc24a875d627ddbab52ce951c10c5e38dd5e6a9afa7a9ce1157aa2201833db0af064dac0af400972ece5e81c674c29b82c0571d04d5e905f03f6f4e10e357694c3c6fc6aa96b0d56bcc8235a4e7c712e004644e8ccb9fe9520b954c405643b4d746af2c41c9be6af89d450680452c1757eb3f1422598e15acef275d0b302f1e6a940c4e2f48719d5f28c6e67f6d3189a6f82005c4ef9bf9df91c781ba58bbe945b5709186920f545defcfc33ffc94f5b5d9a046b9d77a5462cc7c118fc5514a843eaa2c4d2636471e395c47ad9731b9cf997b6798ae2ad7e828821590e225ddcfc21b94f9742df75a14b1f82d2b278137f706a1ac016767de2859df5521ea30e19d2e6f258b6bc332a5c344d6f629f2ede07f83c0bd74406a55b3aef20bed68bd41ccca091d1c3940fa5873ba1fb6b768f371252b1f5ac63fefdc912ee67e14d9630e4434bd443729ad847a5fbcbf993fc1141f1e79e756322673cb1bca95e304e4c86eaa20cb3d77cd0f901cf81c4dcbe5fbef6a1337beb18e9201cba07cbb6a7d863b2fd92c4c53b8848f427b937efd7e25be4e44c1e46473bfb6cbcdf1af5f3f306f27072960e2fa03676c8d209d496893fb5bfdec23cf659f8e949d9ddaf66d9916abe7f6584790be1a18a92ce37f84115207b16496404b6520f4968e64321f002bd4b70cde255f733ef71b98774185184076bd402d3a7d076c6fe766e372a8a27de23d3e42208b3b01a857828ca59a23da569b9644c4237d5317a07cc0916413f518993537e9d9fed2edc990645d88099ba312158fe30fcb9097dc2549fb5db368225bd0083f27a0156106a89a0be63964ee3eb1e5972c5be3da1a73244e4039a3a5fc9aefbcd309eda77ea5768198cf9b3dfc2b017be6f23b21a17b3a4904753bfe198770ddddd25887854255102a04c03a518775a9eee7d80dbab901de3d2ace98a7c849f958b89d87d6bd5f36b051aca44dc94399f6b3b0e24bc1dfb95cefa37a4e72652b0037e68101f87a08722b880fbc318823a591272bbaceee26cb7ce5d13ac3e92a9827c7ab2ceef9ab19822a5ceb26b42a7321168637b331b6a40ed75a5503fb5ec6d9859a4eae6ff5b1dfd797721a5917d684bf871ed399f4e352d799e74fa0793c4f0336d9897ad47e1959a04f6929ad39f380dd1ea01846ec564f4fcb1c03fdc6862e691959149733d203e4108c60cad97326fd61f54ccf0b6f528f38412eda97eab5d49565e9cf254018500ad0d9b9a6c421bcc5b417667b24734b876af89a6a666c976fe0b5ed336beb00ab3adcb38e32ff1a0a3ca849469e8aa3d86b01ea1bbb93630d8e96dd60418a8ce9e672d2fc442e7116346f63ab4bfb107f888815515f6fb646072c0ac3bf17c13ec1160fc230bec60260a45541940d2b12064f162afd131bd1cd19e87e70665989ff28391d09d2e91b13347d03536abafabfd1bf953c6454c70fa2b90bd1abb80a570bd620e8b1cdd91e332c4248c24c71c15fea0df23ae1028562b20d37d35f3241fd2bd41484ba6071acc4eb0035865dbe34d6fa3835ef8ba709e20c17444def7cbf4090b8b1be17e3a2089a7b84c922ccb2e25a47049bee24942c6cb887455c1a49483e5cefd1ebeab79eaa0fcee9f4be96080ee8eb4fcc8ec0000c11b9b7ddb7b98e71542d6e6793004cc9514d6c09778b259421b241e90248d505df9a0b6afcd336eb10e226ed0a8ca79b93709b9543aa10742bab3bd6283b04137884cf4ac885dfc8efce7be7623b55df1e588eed22986303aab82b01dd004d7c7d12e63cd8ee06c92063843c4df142c91857b439a4a3d3a28cb3396d324b7f8d30e9a70890e846b3664e3c70a5207100a4f254a2eb6d998f9835ad0e4f5df8178c634b0450f7881c0e3d54b25bd5a133989b0a3d07cc6697d3ce10a178d7ed6fb32920b5601f88407f73a169d4221b5a52d11440d2488d0b3cd2151cfdef801035ecbb6886976c799d6f2a50b49ccd01c1101818159c10874a91f90c4605eb0b805a5f1114255c458f3b43a99f35bad2f67846508d473a20fd88f6f1257201d7ba21e69cb0a485d1ffa3081d520ba7775f5de014499de0e18d160bcca455593eb0f34db6e0d0c419e055e9164f4fae02a06ba37e5be44e37ed3fac862e161be3873fa01ec6b2210e4bc5f6024fcc1ae12e46b5aef5423a9f5a66e4b3b42e9d29356399ba10e6dcc86e8ef6ee76ff0d6be90471d1f21def49965dad31120e414de78f55cb20e44c26f188485b83e692e6cf3abab5e69f6ea24a12cb4ae5fb6dd0d48a6ddc5e56971a95593e64f7fa2f1546670a88c294774b24a9abfb94eaedab64b961a389e248f86107720d0692910da66c6c19603f4330ac8d3207d82bb87c070854167b139e8111942c28a71fb5f0718bdd98f0c81b06541fc009f07be1ef49702047fb1e3283beab78467b61e31bb3cddd9980fb05cb3f50d85d54c9f637cb021c26f708400e3ac261e80edb5073c173c5046a9cc34b35dea973abe00a072b8819d0957b2905988b134fbf8bed64bbaca9ac30d40e82adf49bfddb289735d5fe7fb89678aa8ba157278b7ea3b38521eade93a9d39c09b020b8bfae82a484e64061a2c36aad0772bf69d465e3e5f0bb98b5aaa2b12854c8541480d2063a2ab8e2ae2b9bd9faade65eefd105692bd37e3c4b14e0a90ce0d86389fe82a274e1b6e85b5a9e4f64a64c1bc7bf987957b889e1a28bf9c76a86443428bdf7f10e352ab221a735549dcffd0882ba6263662eae7ebfc10442ebcb611e193f31adfdf4ae2de296211e27f0f74cc673213a40359c75bbdd895888fe3ebe74fe05a5bb6ef8ea32f33b3a1a04aa708bf04297f9505d4b6e311a0fb3c49e27653951e3f4bcbf36365f932d31408f64e80e1b9a770c2da93c0e77fd7c63456af4a9dbd9e19f279182d9c59796ecd73adc0db95dd6269a1925d1437351eeb6076629e00e6e81dd429d07819f939b9b458998aea7ab1f1531afee919044c08b3cf971f666fef9b1305f245ad39f6137a1572cbc65ef67ee862f2f21c7c12982324ae8c06cbc6ece6e233b507b76e27ff9c06b4b1bb4abeef63ad9d25c08e194b0eed0947cae90bea6b7df01eef9ec14fb128e88a71ee7799154097d523f5dcaa3d00fb0eefb5f401b1e67f567c70c794165cf6e5fe8538b3b555a57b23de71eac604fbfa81c00331ef9d2ddc24ecf15cb94ecf575103c6facb2fc459c2ee7b0e2c39b4b2851924c9c4b98ccfcd248324b8fca54b3460e2f57ee9cf5e8fe6ad72e399f194881d5709be4cae544651dc8a73748be12ebf20074eff21c03a5c503c4bd5570439b6a3ecf413a4583170bf061d038bd5d4af18bb0fd73c90896de4ab804bd74c970a67af0ac351b1d7503316bb95698cba03794ed3d80e19a76f354929298eb15a48b4c86f3aa62b3d4c4d7aed8e19bd615f3b584a4c85216e3fb64b85e6b3e6541c4d5987116e61120469e8ed673ee50dcb2fec11d76ee8d771928f5b4d2ed83222061f5da31046aea32610b35100fc7bcf5b7fca3cbeea22bfe48574850971d25244e40c7a68318bf06148841913b956b964dcfa88465c74274eb7543323d056ba63d8db091f106182a2cee8cb1084ecc13c8bff2ea0dfec443f79fb06010fbe6c216c20c178ffd17f080325ded159ec5e461a4a485073a2894215a5b51adcec948c2e668ed3c7f6d1448f5fdd79f1f097d79b09f9702b0ef3d199ad77c3bf941d6fdbbdb76fee6e6bc921fdab5a9e494aaf02df308732ebbf73d2e0c9bf8445ee5eaf6b0487598f0553b6708a2244540138d6efe029ddfbfd2d730699af78a35b78b52958352c45a27e844e392843aa9a052f4a21a9a4b2c2bbcb506e2ad0ad2b13fd52c8e2c1804b1d1d32f86162c93a942e9cb8fe97b2d30ef2c520302d841674c965eb780cd0e6e46d678e44a569a1c97928e7e1b766c40981fa85bd6b0945776c9197240daef20a6749463092b897080a9ea91da351789780444ace5b1f27f1461606d2a6673a59984a452c5fa3fbb2311b1ac830fdf68e2db67ecd8f235f9e8b16d69c9c4257a028563d29a40a2d01ae34fd95a9aeaee8882a0471698a257610181cee3fd57ab3aa9e00a477b2082b8f7cd0d1f397a3616241d976809d5df5e1f71a33f5329a2b4f32429dbca48bff09b398d1bf82cb3b631e441d255f3e5924c52fc99647ac878633aabcb43c3a9a59c4893917d2f3eea419fede758c038f79d99720f4c83e2baf3f3e23de903b13504c5db8423262f8b70f501d8ab622514d8a1962d764d6b41db67573042444679ae2c458213df6359ff79dbfe8c6c146ed94109236f607ecdd8cfd1c934c11efbab86d0683b524c26263a954671e7aff7d3a92984980fc3eb46620f83643af68644623363f5be2dc1434419cbcf189ee914ae15c69080e1e12a8277ea3d6b4dfb266772173e46c9da0cb5792da000d6840cac0ed1ad704f66c8fd27ee7f4be3a85f0b36eb211ca8e1b0738b1503b2f4eed8420b078ae4879af9211056257977f3877a781031a7dcc1154e15302b757a1f4238a26aeb55aebbd554f8da80585ecd9802eb6561855b94d9009d94aa3d2ae77c73772cf20fb9c8d282702c35f011eaa63e0396278ebeb673d461d8d9e3f9cae47cb452f81e7410c6aa9d71d7d01d4657b7286d9ac6b01ae4ab97cbd3750b5fcdc533caff420ac17f3f509af452715f4b0b5fa98f7596dbc2d96dff21d3f7173ca07b185966de870dd067140c7866325b7a64281342324606789346299c3ccc63060d294af8f180fe18b2f4184f04ce2bf1771ea13af8e8e5eed528f6354e3a448a28f3fa3126e16036ea5bff6fc761ceb728893800d6b301bc2287291eb5cdbe5d919f6a69553f2e28e7cbc75f125b0d5ef3037ddef3f247fa34ec3867dd54ab9d736eeb025bf8728f5e66def71c5a42f71dd64902ff0fe88f4dddb919a70a6ccfc5f60b5e8bfabacc3527eef14eaf2d587485a23e06b7f4cf6d7054b23abe767b857b127a12b8333a6ee81b2b09ce3c8fd072c2848f30ee37c3745a8702b36b3939e91475ec2b04324d62681c8707b192e27b7479fc7bdb2035be1df522f9778b14c8ea8a972d181ff33a0e5568a1375e4145bcfc654e30efdb9a515705431f3c762abef301379b762b51bc2d7b27ed894a77640ab37adafa15cd2b026a0a39e301c22acc3eccccccf94ac982879bb69f3d6132051a0cdf6fe0c3ff09fa3f2c96ce1ee377042700e72e654bc05529e0693b4fd165080f8e211c19361d7aacffa1931e87da1a2d77f5d7e8c1209e3e28d0be3d99647b3a63bc186e20aae065e7c0caff9246ba32233cf5db10a83648db3c034d6e80ef93184658996950881a042c99b9843d3e2fc46975b5a88953f7b1c63b613f5e3610101901a08d442de08b407ff91003646d7a79e5b1bd21c779a84b6f1b9d61c7df6835c24ddac0c25ec1647e2cee513ea92a9c7dc9f1f1047971965e5f0e8ae0744112684882a3e72b5d21acdf7179de368b1dac4e5c3dc0aaa5e8224989422d5aed084dc83ec18a93d6ba2cb6f0b5f225e45c10e2248118d18d4efd70b13b3d2d8c0eff09c3c5e3fcd98f58c54d4bd88148d332fa86994568e0ddac70c81a34c67ebc0987c07f2fed81410acff7fe9aa5684ac43999dbcd3da0654098528788a93f495e585f635f39d824a1d294c9fe06f65ac41d168da55bd7157557dd907662cfdbd529f08c2cc681c3a1e2fe065a3082372ec07788b486f32a89628da074c7db442a81bae376c3d185c17dd4ee556da64d8b2bfd2790b55a5e37a67e9b288ba5c3dd8d32652ad641b7b72a8386c4e20d061f9e02ba3df2c81a553e94d12754edabdcabbf6e877817e584606bb299ac176832fb750c09b51228ee58d644bd0f910e0c8c243b31a77995db036626b8bfce96e35e0c481974dffe59758587e589915839266358c46686735081db3681982893afa0425d88aebc281ee30c8a4d4d58056db05e3716079dbd3129df5b6b5cb64c4b40ba66eb50ff23249ca9bdab2a854e4b89bace15f336d7c2ac1fd7d4e4ac380ad9c6d52e9152ae4b1e4d8df33717adf37c826ada55c2b775d62b03252134c23b38fe8d137401bbc4394e9c51213dc8e34ff736f2dae03774d8909517dedf4cf940f92daec6ff4c3fb3b44016cf26fb8960571b6f56733e673a2b097f7cbd2b6af91d26998b0bcea407ec344e0d2a481b048c6ea707229a683a95dd452764628b7cd61f5203ba85e9c8b05f9e80d6008cd7bc1a14e03a6a0c4d8a93ac222983cc7bfb069aef76387ed4d19374863a502cbe8cd9921eecfa750efef22f1d23d87d1dd69052652fe4158599ad1f9b50f32ff3d70c3fd5cb9a725e5eec90f650744ad626f7f230243ae7847eb77c86fecbc2ab4b82ab7d229d33e167b40018b20088059e624756295b0026fa77b572e020f8dfd53152ca9c9a218bda8d1f17b184cfb7d2ecbe1401d720d3b5e6dc3d5a0abec35320e5464c6124cf0cc0a3d858a0a2528ca00c02451859d34f85b89c6ea27e32ff437c2fb428478881617765d9090c55e123133313a655389ff6ad41c1d1f5514eb38eb45541016596b70f15f9fbf8e7f2ee94860e49affcd6e03957375ef2369d6d35ebcb9eb7a04db07bdd9b57227cebd4a4a75e8e7930b67868e2c5e3e12bb84581544a91599c08be46b52884fa124978f304e748c0d3dae79379eb8e7b6d4d1c5f2b2e75df0ef18186409ab9bbb5d243cb0dac6ffde17f7b0e487b1e9758fd929f17ed491ed989035d8d7be9efbaa68d0d9fb9d5c066a69203f030c1d81ba3da0a6991de5ec98708bc29213f80b49c882b7c964fc277493670ca137782b0df773528ed96d3f2f6e72fefbd1cf1618b56cd6175b330ceb3e48427bd800319d1849e4ad28128638f184acfcc26d1551a01546661b548b5d4622124cd056b3c0c9ce503dfa5ebf83db54a13f0c9f49c5fe09231f9bdfb5e05632d88ce2239666665dcd005b151a3a427fcd978896f2d23024d1950cb207a38641ae0b8dff0bdef1697960c45b32c5eb97a2d169d04e067d74557569478d784107120daacc505570242fff2820a6b518323f18d248aa487936fb8ca22267b6bdda0db416398e475dbc3608d8f2a682f4eac75fc15dfd2884ff332e64a312d2c5738332e463b8e8e5026154b7e59e500255ac46d099cfc4345dffbe5f280a11f9bfcef291ea1f3d875538c550b9883a50b545333aed66cd768974957a899c41d62703da875d7cee5ebd94723142e4a475ed0df65c2664e3b6f8821148795cdc1b27f74f3ab10882fb604e7954ea14599ee08b8da2c444ef0e388d277dfd54f4b836e52db3e4aded7d534e5d340c255674c61f972a83ce32a6a951c51a17d7000719923e260582a67fa5e1a0d9f0db067d9a2c07fce3b1d1e45736c1b8a0444115fdd10609fd6da893f77c2b2b700bbe42bd31fb932d93aecc7a8b58013ed8fff5878ce28e447873284c59ac8ccb8eb108250174266953ebf6867509f29b9555ff0845d166048ba9e78cc31192c7373f9ba466f608adc7281039cb94caf9f47725090bd232cd0eb0e8498e46562d43cb9b546120a42e8aa35dc9b11602ac5e812f71ed29be3d10f313a44fe12e8cfac20181b856e6303428b10e2963b4131663cbacb613902ac2f1ed9e48cbf723d8aa074ad94aa6ed34a04c45b4e16d16400a55c4bd2b1eb7ea55a6264477a4abdf3da19bc4455afccfb513c8c8be627d7318cd160cff1573796009a56db23482cd531f4dd24ca59a6d2a0f1468f9a19c10d8129aaa2d4f886a935c0d1b228cf07c294761081e7e94d693ca9db8d375d197d02ac49ff3a1d46d22882ff22fcf30af2f9a29495090819e38043f1255c8a6b115e49641d6e4150d5003e58d6a59c5d412d77284a6cda420eef784250bbe817c47b32c8f08ab0ff3140f37d60fd19e3fafc66073a383abefadbc9dfb536f175a063c05099d905bf2b9350f528479a1a1a5944095531d09a334498acd7e049999b1e18f20d24ac4ab3f52ad2b2437c75462d45f31ccba0b09988b78d3f392d1668136ca35eefb9d43e4bc6cbd6b8beb862f396f0bdf7b2785917241b584101ffd1cdb68b555e8d259fef0e28726650905462096bc5cca58a54e295bd0e88e3db60d87e635aacbf08c0ea7c0d490ad7ec8b4af7dc118d40ef0fa66fb6a1846a99d547b85d6da263d4fd11c4085b7f71c61e2d2f6f2797dc39eab311071a4112f8d18aedf7a2f74a5267a21898a725cf5b9af9276ce73fd2edb9d8dbde8f049e0aaa96c7c097074bd5378461356861055a4593509fff6dbb00a29569c8e516c082d05564ee879d110eb99173a07438ee42ea93007f2582cddffb0989b7d8e2185fcf7a020c2b2b9004051da56354fa968ff71451e91dcdb1969c47597321c961ffccbd22892c6d39af4913e5f7cb0a41f649d96618f569cf012177dfa47a396eabd07dbf69a43d9028d6b0959a0ce3c5e40f469f34cf672cf2db46b2172282eb75c5772fc1a4df65fc7359eb1ad9e0d81869a175895997957b6ae538d5ec815f601d0ef14b843495dc9db9c69edce05d858f1af88f1878ba7f319a45426eb7635a7bcfbef8a0f030b90487b4d2844759781f446c22b1ee13a4c66d6d56c8b69d4f65ef70fdea0af2da9dd4154e5810a4c05f5c840ed216f647d588e8edb6c03efc2c2a0a464f34622e770493d7f2344d92c433fe8ec76070a048551307956be035cdb8dabb387d86e48717c8932d568027262b670febccf18463ea2b20d0311816b376cb38758a4fdd778521e2050c57395968fe73ccfae1ebe3eb8db08315641b60720b946dc12f919ff548858888b4f3d541dd7180fe7da21b44bdf0427b31f52ef2762f7a4e25331c1f0582b9b43311addc87598d12474f645e6e07078463fd7885acb4554ad8c0fed75a3da259fe9eb4135337628fe0071ffcca170d4cb0ea72fc6f72529e841082b2035fac03d754a070bc91de97d2b5a1f8900cbf1f8e7680f8f527c6392778a3ffd23dfc3dd543c0b5d93e329ac6bb473a8aab1ef3c561911670e0e9c830d014ee7c223622adfd8519f3fadd36e1c91f8704b3121958f1fb5d45ffc824c93df7659810269c4e645c1c77d732d2fe154481a9a6dd3b0c3257f82095b2acdbf5ba1bd222c9bfcd06096e435e5849ec8cf3f0c7b3a748b9974e00a4eb6506d6358d5c51765d89d358cb753c2f89b463fa573059f1da8ce05a7a650e4f76784c22b23b529a4c993533704b7776e5ac303ec2bf47fd9cdfdf03cf6342b1b8607ba38a57a66135b2a48519e8a07f83bc8d049f1063c2a98e63626c74633d5efae3945563c456cdb355fa76517c1d1cea5322ca7d46267734270b8e55ea28e7bbbfa530902b1a872713d16f19f1b2669726d0b8ac032e1febd882afee1a40adb7cf301e2df9752d61f6f445ea4bd40f581beed1be5964889859f44add35f2f7fddfca4eb265d794cf8d30724545a74167f40de419a819134b235e10422442ca82870d73478e151d83b9eb525d17f46fbdfdfc88c87ea09dfd4bc30921a7083d666ad28bd145c0b5dbca7173d0e3733685224fb0bb0c9a65a9f3a5964fedca8c77d49a1f1d2290159691ad7505c95d567720d8c73249e666f0540dff6ae7db2e36f6050758cddcb0371957034ba135a3718772286e4aaeb49244e99e2fcce25b5a30f4e1aaccc758fc8f23aa66da54a0ebdf49f213fde658d8e98ff234e289e3e5ef83c8a0de424cb5e8c7e30c2942d15c9c2f6ef7fcd37c0c862afd681e6cb6e14200cbab3380fe2d416e0de4c38a5d7e184524a1c43eb64d4464cdfb17847f3797bb94f406f1e2f24dd2cb7cb324156bf9cb8c571dd2f56ce2c757ad41b4c6c0aeb8db884fe3e6e9e9a5bd72fd1e2659195a9464fe5f3bb42a89e0484086abf1cf4510cd98226ba047f09996ee63a88f7ba4f74437096fe9524688e6a5aaeb0b8fa6db9dc607af0fc419cc55ed2fbfbc67a8b44a9f5b7310a7bb9162b398f7c2844f526a61fc3bffbd80aa18b7b70188a8f7a286304d2fdd7b355af2165f8de54ce2ae01bd960d7f82898de8ffbfa78b3a3eb32ed2e8753429c21532374ae4baafa1c757edc6bb6564d335d869368ffdb42bbbd9ff4da890657ead9b6ca0c891e97c4efaf035d5c76db7c5f6799c03502631341d9cf3e9e548282d5814cc2825920a06e0d757b7bb145dfee00b5e1fde919d80c3f4f25692da86d3d5930ad75263a563504357b5651d8f4d6b5083ac6d8903b3bff3fb9d322130d42e4f4f99bde24ed371ab76f5bf5ee14adf4c78ca898f617d7d40acbf785a7389005d27791f1ddb90b128e13f9f6f299a282b077e54ea6aadbac59cf1e847a57cf45d52591e3a953e19cbb183a9b8e2b2b137682a33771473a57a7d5f030fe3fb68ff8cde79b6ffc327491e5c9d5d7fca94bccf2c807caaebe9b0e0e0cf3b8617c07067cb1ce09f74fbea09e54b5e3ccdd377eeef1c0a1b4af63aac978d5769d2ec31c44354233ada8f335cee923bbe0547294938de3e66f81bacacc0986a768e38c65dce19a8c57e14a42f154e3907e80f7f1fa739f18b653c8f6145029137f8d1b0a9eca77bcc74d222d3dd073beabd35adfbfe10fbdb6717730b7dc731e6d2e60814704d462c2ad39431578fbb7cf83dc3fe92357b35b973eb48b07ad627697bff80013261c32293849190f32bbcc3e1921fc9912f370f9b5e917f7c923e8eebf86bdbefda5ded14c682c2344ead5fa4fc66b94cadd2223c1be3d1d489c60b120b17a1bd34cc8dc81b650c2aea3f2167233b0abbeab72ddd71972216c4ad60bf394bd9259b69c993be39d63f0b099624db24b05dd2c4ba9a7cbf8bcf2e0edb797c51339b166b3f6f0628d5cdbc8c95fd20ef0470677e43b1a1122a9e08caee069d33920aa4811da9d6d6185285cba23a6e5f73dceb02a404afe10f66f3fde9a356fe1e6c989d418c993ee08f7c343093e3f5fdf44c7625e6fd3588a08a3b6234ccaeb2395b76b2e104ddd263a2e9907761a4c33cc71f5a8de8537b9d220f05644646bf8f1ee4edccd5ac86592c2993bd2355affc825a4dd9fa37a2421cedc06c811e51c7365048f53eb326d8c67c9b20d41b2908a103248ee170412d45c7090db3ef7121aa7821ab8212af39eeb1370bdc900fb71b93ad720c932d4965b4e98b0a033c9323b921264e00810b8c0c9a8b1dba1efbae12b499147b4da895f85d92fbf06ac18263d3185be13c9a96136c1654f233863a1119e5372551481cdc6d26d2b553818d8fc5c115532d9d81742af49c97c79fb5ac9ed111cbcf393fb1319244e6952d2c2754dee963c1fdd7d638065f42ad1afb8bc9b9c0c105adc70995af95980af74880383a084dfbbf85c9a00cea6b262ead94e52f0f2d29dbd160a3d72e3867cf1326dac9a009c918766257001d85ed6c901d9f70f813b870831799149fde412f8d6f0fd66adc1e5cb5831c5d1653a80b49581bf46b3bc30904d8d518f3a98dbb67ff44673de6cbdfd4ac63c4d2c7fcfdd1292af227ff238baac461692ab50cd58c320a59ee76be0410edbb5d7e6342c94e9481d89e30814ec9b65d53e7c1b2cb482a8525aa414353e8f748948e4f0f97c8c1dc2cb9e39b6fcd10d925069f4f4cb491cad07338300412fb6817aad972f25387d7cb6bdeacb4e1e34b5a3fd646a7fda9d49a8cb9c9c182abddac3c32b7b338e3a0c7323d48223430a140a88fa87cd94a3c2fda476af2ca86b75f819f5fde9aa65249cc82ec1365a838fbcf7cc22112f414c8e9075237ac5753a6c7f5125b82878b9c10d4f0cec1b075e6d46b731d10daa18f8c490518553c758779ba6eb00291811e68c104c36aa61bba6edbc06e3355ac4e8bc14fc59d45446989ff8e0bde95b979b211e3f3033f9119ed78fd72a04aa428543cc471b6c87c9b1bde48cec94cfe0ca476c55879050e2b2d764b435f4acbdb5b2550b7ed3211f9792bab4d39b48b005cc2387de4f7e438dfb021232bcc2bdd44f8b4a6e7a99645566d9da55cc57ede92455126b58dc9919b2f146ff18befe686bbf3748bddca34dc0735472dd6daeced2973af6a04862b6876585e3d662b2fcabaab9f9b50c3d1124c704cc0ee00eed9b61194b65fd76688f7ea1b86de9281819d77f936c58162880cc7598b5ab8ef6bd85a08c7a69e00fb895ebed1effbf9dfbf30aef7a833b85490350f053e6f4b955b4d7aba6184d024c58a8902127592468e396e3f1d4fb76cb7ff4f9b2991c8b1c17a6f2993a5e6a84cdae6e35dad8dce7c7b24d7f6c31c3d3c7f29979b0d3a06cbc13fa49a4028f370aa5f24332ca17d809bc3b3244a11ed99f20ac14a45e02dab2999f87746c64d57e750845411c55b796303d3b5422a60ef7fc588e9149939e06c9b543d97eb1186027c0a392b218828660d262826cdaadca19d770017eb79af8273ce4ec8acf43153703d96c58deee7235e6bb038d457bdfb86ad4e833ec15289725394df4c937602583bbb2bc8d016e0348575ef69516581c0e9e9808c7992a6e0fe5b6becbfcb9822633dea9057a607fbcdb8fdab3c99ab74c3d60fedd74d432032ebe6c75c3d71e09b73381093cf713df2de2266055747f666619725266deb746dfcc71b84bdda32299c04b43b1da60d4a8117ae301b2dfc8a1633b2349154f37782e47cd59d39b6383748c8f281bed71d58f047ff4d36be7d20fd43e112de9d9aaf9ee840a2f1a07b6062ac40102732bf93541c7ad7437233175c1f538d0ed8e278cbc375c4db0918da29db30593b35f6d148a0ec0427df23b1336958fb5c57e979f2ca70469b341a3998f00234c8abbbf8dab6fe28e209ffa1a6311fc7bf206d4ca676f208301ddefe6538bf0c8ad3181eb9aa1d9516ee296b471527c9140012b937870bdf95ee1f14565a9feb7d91570501878e5ac04bbef83832f733a68ec06ac1c16b544583cda1e999868931599a9c97b1962bf8701654cfd426faf596ee590c4e370450dab1da95114fd17eda5a27688db881af4eec87e0c056ea7d8f2993929a1aa30032f3829333f3b765a0ce3c6ebfc66590225ec5c05cc0ce320b519d841f4549d733425b074f04fb45d66a3b1ed69a93ff8afeb696d46de421246d3b9dfeb84172cf82f9a6df92e73b2d91ee8f3a419ebf7adac395cba8959678dcac23a4aef8eb7adf58a3cc46044d3b623eeb6e980491428c308ca5d8541788f8cc9e5189d77ce83eb6cc430080e3e62c0b5accf33ab568f05d9b643f529a7ec49aa78ae8ccd88e4996b91a9a214df9e515170137300b8ceda0796472a221ee66f5131a869907bbd1606a879813558451a4a3b7d12cc381dc1c2961a9063799d6698bcef7eb2603e31896279e6a808c8a34a269d1c1142d0f02974ef6268dd8ad7afe7e4c5642261260f80e5a344d2f4d8933fd89e63ff747b9aa4b7438a022cb02895ced58ef7e63f40d458af952b0816393a9a6386956de141305df37befb893a80585c8a4fd54998fdd9d9e5e71e9182212a25eca2c54694b7081ed57745d27502543e0ab58d0a936a6461f97c48bc2ecc1c81d1d9dc58ffeaeb5793bb2983ca9fc7611f947d7133c5eafa1b8a06c754b5432618b342b708727b7af097db4e09d9e3c979e8338551ccd0714d03bf032b59adbdc3c50372e7882086ed56068978c6b4f090386e64583eab69f675249e24012c082d35ce71d52ccbb351500b90cd6396392830f56eb35b548b17d5660c32b2fd7540aabf386afc64915d643cafbb2a25b8cd66eb28f8dc8ad17ff8218a3bb5d005cd7a93fd707b036ef58d9246e7efdf1efad1858fa921e28dfeb772726b1d752df8a684bab98b42dbfe56675f91a6da24f9bf2141915ae7028bcc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
