<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8187716187313540b7fe1bc4d83bf26435d7cc069466dd2b8bbd5eb75e435ddca47d0deb312df42c772cc319d93091176f36df4d0baaf02a4fc886363fe759092e5877dc10dac9f2c01b3754c38bc42cbc4783b00025e5105680f1f7beb06b99e7e3e2c91b65a6de39bb416274990eeba43103c757a40c32590384cda9ec81106eb2ab591f7d60c1079e1a59edb777a5268dca6b5351ab3008ca0645499171b9c3175ef84577dc796d87599ab64fac0e493adafa9a07890a3a835d6085a873bda4a74fa62407fb9a8f8d5e614ff96bece4dc40217dd58493d04cd5df6354c2c566a2da78a6ba3e8a1eadafb7643037c17fdf10e782315ee234ad9aa1dd2a480d1b870c0711a134541889610c93282646971e016441d0d3a890c4b2e9387c0d4d97e051cbe935e1b5977aa914e3fc3853aef35e1c308686e92a855d9da0b8df749d92dca97715f70d9aee03345b5f372f1d80be5363cae25d19ccdcad8a9feb1a7d87a24f0ac24cf1d5e0972c592d813c0df6c0ffe2b494e47a2ba32656baa2e9adaa414195fab087bec4f6e7f69330706ab88b8427fdc90c187309f5dc536afd9a71dd2e9d1a0841735ce9ca967274a263ab8d52a420f60efbbd0e66547353d37ea3db8dd9dc21402d900b53cefcd4c3810f1e656eda9c4b3e515799407fe6ec80f470a088bf9900d755733b9859fbf865d4f4fb7f5b8b4bd7a02b978df833cb8945c041d883ea57f2ee9f937f5bbeaed0e06e7676a3fa8551f5db45a260b90c098400af9c12e6b1f130bb79a7b2fdb7388d99b91ef042c66c0beb6a313e535be207f336f57076ce8f8b1f86342f611d754d121df7e7b2be07aba16adfeff84f8815dafc6fa6d2d8743a83ca6a8ef45549ecf52d9a8b02ada4e95b8713803a7f3d9d5ea526b2c7034268e717e7e060e8be07e38d3540bef51ba6e8726425a142ac57b7eee3ab5766b41dc7bc013c8620897387ff0e16d7563d61917cfef62965451d8dd3392d912b704c6cfe899a5e3ea46b291eb7d366678c8f07706fd45fcc5b1859581696c35b6cd93219e22658a186d4f33dbeb3019e420576ad28414856ec3fc00090fd15e07b3ec3460fd1d0eac23728f04af8a3255d1257998dddf5a90382366756cd5aa07e0c03ebcdb77fb2fe8ec619f61d2f017284ef4a9720561dd9e8861e681106a4765d63616074c9ea25521c439f1870a9f23de1743ad3fc75ed90b2efd1a3c346c10f15288e067db8b75e3a1fa0003bc8ba87f84b1892e3f761b743d6de4900d76f3709a61e2ff588be615f36c6f7ebebd303d19fb1305d447940991a3f5e46fcff49e8ac153a501a995795465842b9f46841afa5dd2b2976ed23b24e0a5d7ea791acdfe79af119eed67fde72f26a9610a459087652489729be8afafe692b99f2252a4e93a816b98b5941f09bffdece92410fbc90ffc7d08b68771649174f5cf36512cb52c9d8564831c3bdab76bbabc7db9eb65465946a6c297b00f2c55323d8ad11c0a36fad291d3f332e1b8efe8a9ccdd72b0da3d4dbf458d38a6cf34c901a249249b90da08fd266f0df39ac6b201703260c360528028ca1a13b9c875e622ba237744df41e9c3c7eb09168be86a11648d0fa9080ea6deae623bfe177de041b1ce91c286363a1ec716f94838273a64930e2350a830e245794e0ef94df66e188216db979a3eaacc09584e3378f84a6fe8f320532d029432cba4a17e21c4e180ba477ffb58be429b02a7870559e3e253bea473c3fda5fdc7ada6d178137752ecfa3825f975ee44273b10baa81054f4b9681c294e3b7ff02c2a2e6f5aff82c997adc3f6d827003eef2db51a10892dbd654c790854a7ea152b756d910007de2170dfd15fedae077abe058612110a6698bb48da551277050bb5e201c8319b9d73feee049b67346d78cebcab84d66cfcdcadb54200ff7feca6e8ef7703149c4f9927a78781dba6167eaac91f5f1c812a34ef66cd4dbc3cb340a194662c09258b799456b4f2e1ebc9cfe764413f467fbafd1749fa9c7b1c555907bd180f7460b28c9040ffb04b2cee2e4a0dbc430966eb39730b618c839c1d8a7790f5035e19bb976f85b375ba6294c7b7b09152c78e04d0d3124a50467aff018828b03ab47d98a91e1b207eb6f52ba2ebe77b6c9568aa3ea9607732e0f93fbc41050ea3eee3caf557b02d51c0f894ab768db010a9a56aae0a279674415f9347793157cfc2fe1ef29c3e882980762d2432a1e103d162cc18f6f9932a4ba1769c5409caa5ce20c890b9261fc00bd7023536cd38acbccb40ae388d00b91eab40bc0404332a27372e95deb48e24c92ac95959cbfa04b07bb645cac44b8a316385ded13f36ed2bda4287b10a1f5d591adaa55256df29351a3bdf66b9329b307704026ed11840b9dc07447a9b1715caa2c72d857e64ae30e78b7dd63021ad2cd7e1c115cbd5ea2a3f7940dcaff76bebfc55ce8e62235d3f70af956faacd77d724926f04cd39595cc732f26e2d6691051467f3b4ff48672f6af94d11630a00545b11de79c33959e1558da1c5537bb4912922f70a02e23a12c0f5d1162601bc43f3c28702d314bc80eaef753b1b841b5572d18b10bd1fec06c47f1f62a26a7e6302d88184391ac804b35ad5fbfc4d2b060c286c41e5282c2d1d6599a4d4c597a7e8e23c02e3ac41659769ff3447c9ae9edebd432cffb32285bb82858bb7d5028d0bd060458797f7942af010408309dcba37de873b1d0757eae463b6e3d12614139c4943bf7a81137ddc8f0b002423abb59e03cf50b30c852afc940dfe0684be53b2b0a0b7ff3f705fba2e584b93e42569bc3fefd24fa41cbb6c82ac74fc230af7f46ef0b5d744775cbb21ff6e28e01b53eea3aec672a588f2c207a7d6f1ed3b2a61434a3995b2df3cddfcb090a68ffcb8d5156bb2307ffa31d00bfd674a99d3a71df6d234e7c30c8cdfb4d84eef59b7a80b8b1661fabf1756f96f49b31598222ee6be8e7dff77993d500cb348dc7a47e3fa22e54c06d4c886335c55c7a5b6be21d39bc5396e45f2b13f2f222a2b34ea1cead858d1f70fff92640aaca3a5487dad08a4d02f96002ae6abfba1eeb0d97d4e58ab9fdc1c7141cdea90823e2a4c11992e3356484dda42e2883a3fd1fb46a34d9e3e4ded1e8e679b192b31a1e6ce3539a9ca7ecf820277e5f6350dbfabc8d9bc44d9f5ee0296cec4eef9142403af0d34673f613a0dda1b0d43068e8c22eb5b124933be7764521ff300cdb294c6b64e080000c312bdba549ebeef0a11dc52f31570068157b590beb6b1c6f58b6f4d9f556d677668eb1aafb5e0fd64feb666d7edb0be11a8be995ee344b8d79db74ca5c4e5bd1c257fa6486df07f8254d6c3f3a982b77ed669545969d6d34cf0972634ee86ac50e8c15fdb6adf6823426d38e775f52e7d1a66a2a9801267020a43760bc5dc8b4433a671fbc95f74b3d0fe5605b2541b26c63aaeec28013dc492cd8bcc7bf1a3001fc306e2d9610a7604f04aaca615b7afa52c969f217a81ff4f132c96058b8cd26020623d8e61412bbaae0e7b1eb27b8bf99d09b9af3a98694b86b55f7eedf5a061423cf0bdeb0e05f5932aa704d14caa173be3d34da20ee56e12237d825d3441654ed2f83cc67b2b07d53c11a58ecc916705899fe6bf02fe774fed233f67b3911a636f7511098b141cc83de35bb1f21c3eda6784e509a413fbe4b3c471c9b070133b347ba4a6c30192d8cddfec39b57fc9ba720543c030a51d72947d2ff0f935527900f8cdf053aab14d0889fea88daca5532ab6095b0759810851d470002fdcce7167717fa1d85c04b28bd10e987862194f8c20a8b7725405c100324a51376bbd10a267019de53a99925ac6319e13e36e164be21a5ef70a147bb6fe0c1b65a48be1ef982cc3b12b4848f3c248ddaaf89c4be7dad178407612ec9c7ef45eb44e0f08529d7e7cafb87abb5a48de480cf58a4de8567041629bd0580b940a27ccf4964aeb54f1ff650dac0ac707b438c397ed4dfcc3eb73ebc8f9ddfe8f3a4a4dcd50fe9ff1144734a8fae512405f2b54b5db91f83b449e51a63627b42cc1287d841ffeaca89a9cf5bcbde3efc8eeedd6559a708f4fbdafd1557b8b2b740a4c6163b17b7dcb0d5977eaa7c2aec65b8f56f023feda01ffbb13045e53b20b4911cee66d26a3b47d962ce0314b02781a131b85a38bf94534edae4706bb1ae947d569d0781a9a016fdebb64bc15cade092dfae135cc943236dc882060cd2b352374c3c1c975e2acc217a1aaf8cd65d735a95a3d3eaed67b66b57f7d00e2941a73dac19cbcdf3bed7622c48eddd9fca428074edec19f53ef7fc4f88f78e8c45bb441b9b282f84b2f5754acf7d2355ed4e01df2802f57495db17b81719d18c52f38854101987178e61f9a97cd9bb7bfe4a6f54c750b94bdf3c0a28e8cd092ba1554988e6b3c66e19f664a12f59a6dd460c2464c86d56258a188789bf29450d9ecebbbeb611ac500cc4b8a290088379bd9ce9de1c99b56106ef6ae75781cec7f924f35dbec798e9eb6361d10fdb2fdea02247c043c534e5e8357385a6bfb9f3315eda2c4b33f1d85509b6746324b583b152f6b81034a7ed34cbecaaab9bdcd61bba018307e77c57b6e60a7fbc8cb4b271cf10b860f3195fa1e8cbd58fff3c2e36fa2927bae3f5b53d0041a04037bf6c2c212812b3b250f3890028fdccd8c75745c71587716b22065da252a4459548e19b0990f87668dd5579dbeb7bcc1cda420e7da7cd039a75b1d313d0bc62f96b013014bb897299484f729db7ee4830136101b1a21a1cca73ae991ef29166e841f7b5b95643d841bb0c2954e79d4178ce783ee42341155745d10f66d57a13297abf04fd2f2cee981cdf46f5a4ac39e52bddfc87cfb131462b2d4b2a4167ae329e4e3566261579c272d142ce98738fa9d66eb434d10e4f73268449713f92fe7c0a902b81ad5cb7e8f8ce7ac31db18344437b54830e4aebfec4cbbc05d615da9997cfc478197ad14e872d11eef56df75af4e3b2f27dff91f732e4c4bed33a9c8a2d9e8fb51b69f11b7ee65f272eb42645e02c7a846c04c08df462166d4ce273b3424686cec7f2fe5e92d81e61efdec6e0f67569b50fd8ce3d87706919fbbe03e1bde8247d9661ffb79ab6c6ebf1d636d33f30086ddfef2eae43058df45cd6d14c7733b75a7a77e8eb36e16a3d132cd1f3965f3fbf2a0325e3ae7c7d73d9b7daa058ef4707d7fef98be9dbe217451229ef4ed7fb86c93117769a09dec6d98e4c868f41f1a4110e468562aa825f02c292166348c34eb031069cb97908f85f019c45e7d3837057be13dedb6aabef00b522ccf9ece24291d7f8481cad110435e52a2254c5abd03192f85819d5dbdcf86de714b08316c01780d1b7078eb30363760d035fbba292fa1d019aa0b578a6ad5f4f49484ed598372b3c3f6060e14074370d4228502be0c1c16c5f75adad3b74ffaa60cdd3ffdb202e3b50442e86e476aeed26b5caa7d60ae21a6232c2316678466fc0747745f34d6431503b52cf61c2c6437d43c372531c9a6fb349014df013637a321d03e9ce36f31dedd4eed26b51891826342ebce69ee2f0ad71ee0bd5d2ec86286842474b80109d1d18a9e383dee0dd1d1677c54880a34d7b49231d88e9a81ea73338bdc3a8c9def9ba08b9ef33e42a732e78e7b2ecf518322a6ed74767123e3a15c91beef27f94a58c8ef59351d9f692d1a7e0cbd2db4b8e36e95b3c7897cd2b3c47dd12bf20fcaa2bfd8eed0fcde5a59688c934a0cda0eb192526e5eae66f513e31c6a683013632eb7f3664390a6ccc6811fa9a1b324d07b59324ce2c1332ed781f02a2e49bda444f40c8c59dd8dd704d682c9a899350156afb11c905f801ed38780c2d8eae29e746a4c9061bdd67faafdbbc22446cc22c78b4110181e78080ce46801218c0d4b16d0ca2fac71c5230c6b6e1c66f3e9e246ad30537d4d62fa397a9714c16e437bf2a7d247e26c30ec59c1bd015576e4afc2a8aa7671a401adc56830f6cc21a2971138405564ed9d6aa705fe9a6a29b03d52a54c58b031f032ad38b8a0b568c4e395ae7ce72318b5aaec6da3725676dc2b846a671d5f17b98c8c1b3f75754c5dc70f2fdf492012a25c8507318ae61d9265b956bbf000d997f08c20bcca060e9d03752e3ae62870362966e4580649840f464b2b4c1526c78f1b3db7052a8993bbd2c0d7c1ede153e5c2b796550be6ca204377980deeb6f08b78516515fc1bb2ca7be0a333cc68e93a9d8b73d73d01d247226d666be1075abacd7b39b120f3eaaf9e5e282db53c3e3d7dd85d343a4185ad1f38249411fd81d27ffa2427befc2554551cbbdc5dfb49bac0d95484188081173eaf42f5aed45cf01ff2cb3f08effbdf3cf8ba6cc952fcc006065b9b176e4bc74ad9c89c2586b360f9f6faa74d3cf58da14ac15b2e66322d471162ef6740fc87c7f3c141f123949b90a2fd7c390a36ad308c55458eff766546431a23f0253fd72ef648ab7aebc3c206ccda2b1bbf593ebd38cc8d58197bb2b0076f5c6475c6c05fcad9a60be9d1908726341eb066d003a2222e1bd041f356d14c4fecb1b8d39e4df094581a2da98191cfbed86a150c0828240ebfba36c9229bf0630913622fdac73122a1e02b011dbefc14df0cf712936b26dd37a71347f06b31dcc1040dbc7c5fc3f101abee81c438dae12724cd5f0a6146341a22f5a5718702e770bc1333173884f053d0617fe8d83e305824581bb8be8fdf8003e47fd92219e45d03d6cffcaa0fdf9d805643ed436149acc67534264df20e6e047ea5b3342881289e0ad8be388b0ae9570d78403dc0f8059b0f9ee99271e8ae0de69ee6bfce9e2b7099333840443c0427195ee269cc8834e999faf8a6d2c0a269112050b1bc0fdd122095a612b5f54f6c5e8479d6f0d3cb2c2b3fff4c6a39e04deee0312075b1e5badf88290dd6b7c612ab8676213edc5c4d69d4668063f9719a1d01106a4b7c463523d80a18baf99585ff153895a5a7fe1e6b86d63dd9241719b7413e8f58b16980b43b5a4ac8105dd5bb60b49193c5e87faae5fc7d6cb3b0da5474ce68b830b58949546d2f7f1977016cbc73ffdebe9db3d3753547c4d64dcce59a4fc9251074431d4399cf049d79a65aa8219487c4f29553636b1cfa058f46e7cb92c6acd1b8edbe553b4667621fd399a10092b081f45095b6848bc8930f739f6ae90bb2207976e8ab7ad5d2ebced8a39c7756d208e9ba4aa4f0af31b489c0e0da1b19d34b8b476c4185175d65a9d89aaf2b705d92cc12c5a827854972b155d14deca0162b6357a07958a4e28b865603b7297792ad860d9533ccfc8185881b85ced5ad378dc753e2bbe7e81895c1226e2994012215033f8c38fd478691b2e55157539c76cada8fecdb3711d577e5045b9c4a6f97d86aa84021e4c4f3565a5487b0a73fbe5fa32f2f18150f9f7e216f0f3f9ad9ce920fb5834636c52f2ef1af3a0edb8eebdf3037c9613921d2ac1c07f5899221c7ca1010b1dc3bf38f5e6a5116b987d9b067a4f12daded1f6ed6595cdacee50c00607a4e2acd39def0be628eb678ce528ea0482a0591912079710863854d1572bb6e10e42c70fa750ebe08860c558fc56fc2df354a1e977b6c27bac3cc5b299e2ffae68c17ce3e02044fc0f0b0e2d738c25b5291151fe2d6954bf39829f8720890f76efd1a22b8795824123c6e787b2186833240a3f6696452bbe55952ce4962f68e512752435c76b2d2b087b689fe90d228b365b6732127fe05bb7cc7c9fc626490ef8ee07b3901a9c47308c1317e9a166d7ae449d1fc8261af17253d0e2c561abc9640472baecbd4ce584e8fbd0ce277533454ffef7cb15f9804a6b2ffe12041d4583de139cb57b8b6a565e56c2569f976e4337059d8f65d930d831585db82fa667207ec2b19128eea5075ea9620c6bc7bf5d9abc215ec578aeabe3cf9a33190e2061fbc2ca698db4c356db03171642e35e518a755372c76e57ed5d6fb8765238eecc2aaa46876882346f87c6b45eef9d65f934fdca7eccacf718492e6d424425bd37cfff28a639c354ddf880fbca6b81fe92772ee0f7783876d992ff61afac8b48b05af2cdeeb82e35cbeb792ec30c47488ac776d47cb5f0761bdabd8143f835a43f2b5f61b494ec1b3bd5b317ad4c7bca85b7b13875a4e87959437e9744ce1098bab27708daadc53ad9ba16cfa91eb604d4d4c0e27a0e71ca2162515ae4d61158b20b33e42757f7c7de6d3a2c44b38145e78b5218d807e5ba5d2e32f5f03f482145c3e73d62c456ae4e901d413ca68a147b3620d87d2f3931fcf7d3c9a0195df399832499f2077664ba9ad127237a5c9eb021f0d9814367697a5a0937651f2fe371b5ac8e90155e0b2c29d288ccd4832c803a15ce7b5455a4e4d24541bf4b1d06b35bab42333755d1a8e1e45714ebc5ae3d35be390a92dc8860a5ebaaaef8af0334b4cc17ccb387c7c4952726a77bba822add71b91262e5c8e984bbfa1d596c3d70a28588a8dd278e567105c691d866df2bad9f551fdd5ba66b9b3897b767681bd4e2c245fc2a175bccec17f8ed150b79187f8d1df2270fd50611efc181e0e8122c0c9cf933f7c1f32a3302547a1567667f4488b375c884530a14b93ff42c3287e0ee06816105cc364831d4039502c5d3e313650a44fd685765722b0871c4bf537b33fc5f607162c6f6908830229f29bc32db2c20459ead105cd3b643e7775a41e80ac2c0c304cf06d00941bba2f5ce0c03bf9fa22bd59f5f5574f0738f047bf037d3b3b234b8ac76d1acdc0c9fb5f47a5ac301406ae682ce31873046a1a7094cdc1f3f64b13f29dac58b3937be85a420312d74f30ea7b184ada33decb26c0eecb5c571ee5e792a6df2e30f25dd960e8d39b1ac81dd5e42042354c824dffeef8b57cbc0261bdeb2a6e607ba3e28e00d1d293b11eff14cdad3bd8703c46e7d80b6e9e8900fb58fff08b69bb383c8dfbaa45eb0acc5628c1d4fbc6fdd4266bbc9972a568bc7f51a129d430e6af38b7c5764e427b06672a6f2db1b16845c9e8a68231fdf54afbcc6307058627a32155d35fefc55d875347bf44d042dff0462867c5af9916c8b507c7d5cea52948e72fe6a3d54568c08f4f6f0d691b94f5fd706e0169c52fabbfc9c8a97fcc2b984305b15c9b8b1dcae6e5be9d4a943e68337eea720dacc0da451714490f186547c6558006b15a206fd151e22e5a28d75086f61b7a8bd472a25d541ec754168fb4b6555c3e0e6789797ac7376d8caeb9e2c83f84836f8feb91097863a4244d636c3acc188b6775d28eeb3084ba37301b9f7ad0c3b698cc7f17c1be77031b1f5771851ad7b5f45e9841fd4cff6305d587304847d9026336f9caf8cb33ce7a51c923007934aabd2905a09e1922ee6ca06879bfa10f01923af3b863a71cc74806a0875619442dd8691f36670f8637a74255de87c45a0499a253bb4af6532837870a0cdeaed81ba65a482953e69e351fd555792001a95a14ed15729f3248a70d6d2ae1b6391749dec8c278ed825fb59c0abb384d038f5c25dd687bb855cb0d44e82de4df54bfb60afccc035dcbeb376c1d60fb8b09c069cae6787e1859de700a26b3d922e37a99295995c4d13fd5634a96d1298dde822d60ddfdd23543c64db998bf41702d75b8d1f6bbf4510a7320f43d3fa73e80c22c996513a8b68080d2066e06c9c5bf8cccf2331178580947b279940f5db7a54dae1f1403e4fbb43b37d47dd5e51f20a8aafa3b3c8ceba7e840dd19acc88416d3851f10160424b630eb04f6e14ffe2324f200e5022d4ff42a7ce24893bea3f8d3c320db21dbc1ddb1524e1917d906db5dd13d4be4f7264d2a76dfeec7f8e3b28edc1d50545263d40a69c1f4d68d754e7d3232e0060e52a98341b688fd5301da87f4a8a8576a309c9c4d2becff588ea09e748548b0408252c2a5db3ee4b1f36dfcfb91de0ed030b37b2d208a600a19bbe66cec39a246ce2e927f82cc3174d51f32c172c283d9e32ec3309b0674c0e9aa308dcd229f4d971fffbb023423b34601847e5f366e21db980beb509cb566cd537764e3bda21571440f57a52286558f27c0c5100fd35b5a49e32838799ff689de8d66ff4995f77e4030a4f7e5fc6605c240d89016d11ae95499e418f098145bde675ed0406d8dee1f87cc0718388ebedb4578e4f3e08b9def95b59be209175c6b97bf7767279f647a9c0391d9de28aa8e3221df55fe631a1738c2a6b3c324707f971b7d9831bc41209d779d2c6889b3520121daf8830b6b57a29a7b204db654a18099476cd61e216e7a89ee5a5a2fde00c1b23df9f20b794bcc4c6b68444783b6ae291f5fae6598a0ccd378f1beb555d0278587bf4e90625f8e881b5f124c9ef9202e413b3e3c122746fbcbe09fd677ff578c7f7244b95f067fcbda069e48ebb7fd4b502f0ddc0f694e85c59124ec9da42345769860eede4d6d39693db5a6488709a4b289e6b75d598edcdc109f046c36db99ebcaac0ce7f6b74e41c51d3bed173b345efda486fb3379e716e374fd9a7329fe2d16f4b3fc95f6cc196f154763be2014f117a35e757843634bedbbd10192f6b4d34eee73d242383458513fd8e5fcecc0d55a6a2146e995c6d68c7dd0b7d671c3322c606cffdfb9653e0dc02a3f502feae7ef49f2569b1d2476f53a44d7ce583a1e30342098b469fd73e0704b5c3f7dc109469ff078c18f4a05be63a7617482bf2accd430badb2d32ca9093bc7bdcedb42a3b85534c3957adeacb04a6277b0a19a3bfe57f17868fb77bfc0abcb7cc7ccdc8cf3c1c2855ba8b8a92ff8ceb33485a8103d0cedda86f7c4f1f8cae4ae449a6636ddce08f0e37dd3f08bee85694f4ddc501edaa8e6a626f86900e3be9e32afed4b2795641823d44fe5aeef23ffa02543f8c88804c70f5891eb810a2c3c4376935443488931d22e0dc30c8095ddb42f475bea330d20484927d5b5bef2399fa73585bce820c605fcfd858c2e6880f5b71e5f8c7c5ab9fcb375255fa52ea73905bb27c8de0896782a51ac758119d076559cdd34755f683f618b2ffd294298a247f4e87de4bc2b9632a53450ed0c79dff225539dd0726001b663d5b02c4135d330d9760645bd8a6b7d7d2733ab949bb7c43881d4dfa55e509e1ca80f8d6506689b9cae124fd1d9993c1a4b38fc15a8d4f2531e4df46c73d67ae6214147dcdbb70d8a6ba50979b759a97216d51165be75449c0eff9bc265c7b92479c459981a79b6182b31385ab860f44adaec56185d9a413e82bc48a691de924228d495f4b1557a26ea3fa4b0bd74faf974ddb317518cec41db6b4517186f70b42b9ecb6cd58b77e350c614e09d466fe417c0984c5b3da2deea896383ebd289d1dae78056db4b9ae6715c0f06128b225f8972bbfd1f2fd413c2eb771d4e1551d2bb18255df1c8d3e6e064a7fd49591c796438007fabf5fa5a76c7ce82eab0ca4c5100a476093333c6ff79a6972dad04fc4fa4350fcb7d5fb7cb88e4ea8ed05e029ab77b3c9ef0fb4c2d67685938e42ffe2c5b82dd2f73729bf2444a4325ad9f67f681de9aae8daadda1ccaad06b7c2557cdf00844c64e7897e0f395e5ba23cacd3c4795491f284a967302da2b4b019029c1f13ebcce421c7a6cb438064cb88558e961feabd7e42f284b90939244aa77fd7e7d17c9862d299a21a9410dff287f0ef2a7a2e42084b0e8390a68014d4960126db5308ac287dae1d1fddc8168f1ba73840533acbc001a4d43491c1dfb51dc34e0b44a5bf85bb4b4515ff2e158cf77f3b324f4f75aaf6870389e5b82214449a44ce46435c77eae6d5cb9b0d3a460e981b37cd627e3d1ac6c53761068bc44e7e992b69ff687766da4566b9c22ef269cc321d702c9640348aed174046671fae91416546fcdafa9934fbaab45fed0643de97283bb90d1e493ba649af8da5c90bfec75cb2ea415d7fd564768c974bef094a262dad0f72174e4d55cefb1a4e3d73c5149e467fa14f5c8b2ab62aa7a853fa013ef9ddf575d7384505d69737e6eb0d0508c5df54e86128f16b9db08acccd0954b25761bf9c3f303b3b4f23d00070a565a5827a7404cf3817652bd0329f9eef43a602dc22020404066595f7e6ec2a44bc5d3f7964c7e451837d1c0d237719057148680ba10f2f8ee35c8ea3768018c6c5f68f60a708537c66df7c5ca442651b579e10c5c79acac672cd73bd5792adda76a68f15bf400983a5499c2af3c5dde2db5875bb45a5ddf2fd261c0730a408c31e831c20e4661b808c1ad7c7542298dcf153862580fec35398580f7cbf9383872573631d437cc99f235df8a9a5bf465a78beca6f0acd7cbb0056e9410c990058d84010e304c8a5bf55d2297f9de0b811f8c16579bf39e347cb07b18e0ec6162501c763732bde5114f3af2492c607b37e31a039aace33869a2573f39a12e09b8d8b97e172289de0f15fc9737e5d9bd21a444ecbf797190c8111584d1644ebb64551c95e89cf0f4dd8e25528d057ab041f00065d9d257dbc0ad6fa6c5aae7aae08fb5e01269106bdd9ce158e1e8cdfc73bfee66b20d6532788c6ea2e7f51d61b6ed8f810ecf6701ce15e24035473e4cff577da0c11c4defd375aea71d6c5cf47c281ee7ad606c9d9d871039c55f04ee3029bcd0186da9889d01632f3610923695656f0317355ff37ecb2b592f23a1879db024948a0d9bbbd9d5add4b45392de815172e3e9cab7f67a7a4d84a5683cb2209749b1c89609ab68f41dec19ba149d4b6f7659036a0887b7b7a45e31573946da336a9626c19bab35c32ec9b7dcf5466d8bb21eb57896d19391df8e66e1122d3b45316b99c2e38c4ae2a39071a96dfa06bc7d0f212de345744f36fb4cab528e2d6d7dce92e39388306a435890f0607fc407c419f228e9953a3a5aae080f7b3c98e5f5f5a0bcba8ca2e76d3dba897da0c7ab49d9eb716305cbcca2d234208eb46379a09b7e3b51af43690526c99546f4f3feae0ee24b6c2d853a112798c8cd7a7ec701df0e0ad999dbffadc1e5b065becf61247cf44b4d89a563439d5c95c88131e49374028bfda36930e06e7a60e2e24367a53f2274071251b755219535835dbbcfcda2339ba7dbe28386a8bcfc071b4ce21fe08fd516973a6106698738746a8e595570f5c2c87919563f81b090b13e19b5d0b035e270edc65e9ecedecae4e4996980bbd6e447a111f10592fb1e37a79d065a2df8dc383e7ece1871687ae8bc819a293d0165d66b308586ed0d4fc2db9feae2cca79e0c2ae6a77db71e61c028fb424b89f3f754bdd4db4d8b700bd604f95e8c4bfd0d9cd5b9103c9a4d35df2f6ad4de4f53032826f3b284cb62822cba644614c6953f11154bed7c0218658690c74c8f00d58126fe0d05686c00b77dc3eddd1d8a1535d4e4e500c2241ab65cd1d35e6839d8fd1dde029e856cc750af5e0bf136e6faae653f445740f6035e041a88f541042af3bbe96fb1c8f8cecc8e658b3b23390738dcb0593540a250203aec9586197b9e34c7add7d77fe0952bd80aa7b79f929952ececf74e38106915cd38c52674676bf891e6f39e6838fe8fafdc083e9d716ce574e83a516ef95b631a06cf45eaf6ca74fd999df52601094f562a613c424a20799dcfd31d2eafe0ffa6737b4b288cb065933b72400bcd79f8ca88a19156301c942a58c61eb0292a5bee02c36abde0f694d5246c1d40d802aeb7a8fc0e05bcfb74d20c23f74841e77eedc8990c5c066356f8e1f221aecf2a29d049efcde7055797f1af524a4a870ac5be50ff981b447dd5873a826d6de559dc97cf689b793d1aefd846d3f1be870a07a0c20ca6a00a48955be467495d63fd2396efe42cfbc6ac1c6ff152b466780f64b4c8dd603dea08056edfa59671a68c5eb9ae1e12a814195f3676cfbc12871aa6b5c2dd4480a9d25366e15f65610f071fb81b34410a2d9989582e53515333c6d85986681c2b1faadc1540e12de77babd06f2b89cbca6bc75c8cedaf2589eea9dad22221c22864b614a129d08a0c8bd5ff2551b9b3141f70bdfb4364d562a0b963f875e2507cb83152483c5237003a00dd75fb008d8eec1e3b11c6217a9d03d2edca18bc3ee6fef904ce50e2973cefb4ef748ecec7c5ef07f0bb02cf4b7d4dcb1d80b51931f38782d20a011f16cded4d21483df9fa9d52c8209f539bd093cdf6196b65c0e8184ae39a8dc3d7237c7fb4cafdaaefa2c98dbd10ab8314e54e44e2d62a60933553506e90ab6ce421ac74b55f9e07e6f0f213181c6d6844d0756d2998959da69c4826519adcb1e301af31eebf1bf0f2c71708ba435a079073133b40b68670210a2f7446ecff4dd2270c9b204744ef53bfbd8218fe8493754ae4cff48b5d8ad196dc11151fdd384d68b8c23036613d6944b1c32444eb7834b65091ed6149faa9f859fad954da21a93de50d5b595bf5c05512a6685f162c262e20c90a717f00631165d3efe635d28efc02126758d4f4f3ae98ccd29d8c95f2f833b3cd745073cbf0002d9327c6ec75064c8f4d2d7a8fee14780f1b96a840741f5ee02f0f68e1a203381b7796d9edc468392e06039c82d42ea75ac506011825529b629a56ab63840f94ab2f37f79496f3e6f7e3c111e0ac2d1171e48fcd80f6fd7ef5b33d4965cae5f0febffae384ee7c7385142c5d5f7edcc8f966304ef1c3cbd16824151bae10c7089177e55b923d09580b60f93a8ff3b536e1a33dc35a3e92dd4453115bd174fb8a1f113dad4fbbbfb3fc5135f9d75bda54def2f1437fbb328daabd608953fa429f41dfd42b93e6afae3185860577f9957f396eb010e65e532c381ec7430b46d416f7fb82565036f6759ccbf2366f30aeca138c270da10ea6c2244e78982faa46a98125acebc730488b57932696b716994fb16adfdc05ebd2155c56f5b63f591cd6b8a568c7f2fb0b4dddde37fbbd482dc03d2bf23b0048e3146104d3b06dd353815432cd748f68bc69a42712e17f84a509247c06ff5dc3bc245796ca5396f5d3ab9ff6b67b28fcaf2c4cf2615b9e931892fb3b8ead3b73e6e1cde5299d3649b89ce0c60ceaa19aef8eae91ffed236dac7d2a0b2645a0ffaef5b133a59d85ee2e378c68e4f3734d2d72157588b0ae37e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
