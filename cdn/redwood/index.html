<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6227976b7b62badd961bc22a020cb3ae46386a8b577f432cdd962e8978479633dfda27b8e86d9838d6d2d024c8bffe4a32973e38424d4113c7af91f062184503d04afc2bf8cd50d0c3afad066df74ef9c6ed5711d6c5365983005e98eca4efa02928950050347f86a55b08f30234bb647dfbc958fc283fd004db6a6aea9bfd08bdf7f6e423e93f0b17853eef08f1ac662870350d34bb89cb6605624c9c193c8c22cb6a44d81ffc72c0d77fe48ab2d2fdf9629410fe8ff026f11fb8aa172974d9b6aa02c3163db0adee3b66e6599c883b7aa1714f37b5519741fbf2da1c514bb05df399bcefa2dd544ebab42587881eaddf5fab912ae865135c068d91c3b9b2a3de584ea67e97d527e3021a1a4becad4943984a7132df5c1eb31a474e0ba7ff39376917b7a29e7e41d427009901cc452c612c82424864a751ad65f73695caef56d2da02a447bb0546c634d39e8012823e4e16fb874a4e78b911082d53b6e08b992a009d3ec27a0e4a9c42486793c29fde11736472c43c06736a99c94eb98721882f3c101e849c65d844b85680f5f7b60b3983265f58c0fd33639c351f22d288246fbfedb71ea9bb33cf3bcf70bc52574824ecabe0d08ebaa34f6be04771183868f281bf3757cef9b242ac8935f57df51529923093dff9e853de05d6bc9e90ae2eead75f98a3935410744e9e4fc77d85039232b0df9d02302fca01d5b85204eb1b056e6939519ee0a3863859deb3a2c87d14d52c02f15c7f10fa00658decb98acf729d742d3eb0f3354579b1a50adc8922afd3774c03b9756d9af97a55ad991583f6e809078d367a95cd8ed2e8e9924626cc95a719198137e1f04ea811370996d482051d521c98927e389cc074ba90015e418b64dd38eb86da89f0727e0c6d5c94cd9ed19ac81770ec7dbf80fe35f3684b1d44852a96361adefea805acff37c2b8dbd92097e26cc33bb3b29d915e05b9fd904cedf4d1216253fbc0cb794a8aa53a96ab6b50743ac29666b3604b5a112d074c6e82731ba4bdc33cc6ff7f6689d342e328acb236f06956d5785a7cd92b1afed1b779a1d148b29143572544ca1c7e2c94ed70474a7d2ffdeec6b3ad89fb212a07f660f56fe6d77f93a009efe208e3fa541332106df91c69390a6701927176edbb2dabdc5d57d188d3f0d3ae0ed5870113d15209e9597e3a3bc4f3d118cb073667228d4d0b82a36d96dff6da84f52e838881a92b8d66917441ee8f8b976281ffa619ca9d36daa64e5e8844a0e479e22a59bf4fa7c7d2cb1e2867af1c5224669c920d0eb898cf27e9d2950429219631e478d2ccd66e8f17660da65da5cd62d9a68090199aac582b8204bead6680bf5af1d9cc502274b3f832ac8e157f3c89c8844692eafd9400e0c3ccf9ae0145e78604f02a0fe2b259637f7b528432789a793c8d1ccc8277a95a8f8e164fd12f1f50fa029451fd7823d29fdbafc433922d14fe18cbed961f7d1ecb0323c8b77a77c9010d53a43289b42c7a124a3432bac8b6b795f4a996f36d2ecfb4799f434051cac84221e385ab86b3ec4f5fc6fc602a3e1d6c9f435b9c2295a5b4e6cbc2af66efbc8cad7b6c869af68c26bf672fb8899726f7660b8ae4e08ad97bfd217be3195b155220a0190fbac956a9a9dfebf82d1f7e87d6a18e369f4530111605e79e3dff24e85fe77ecc6f17bf4c3c05f27c21ecd78de30c51058291b2237f02c6b845225482b58c1e789f0a8302fdbed49969a653f40fa576287e7a2cba02d48b0bab497a79d9cb7df5e8eff02594c0c76f3cc55f69657481967ecfe14187ee407fc200d53f451a864e16b957b1c6dbd5f9e78e3d5e500f284ff58436ad3d39849408359d307a23ff06bb8e69a97d49d588b0e987719841f45d101ec0426a99a675ae4d1f6e5cec15db30ef4d998538fc0678f68e1b0e7a52ec70147a7e5038023acb27cfbd138208f1527416f16c7fe13373cf459d814063de136c2993c1b152f827a9d296f14e25411173405ee9c54dbef79da8b0f9d4f83c1f9a34038bf07ab500d5a0174808b33e284f05f64c8c812fe1221ffd22a6f047e7c0597936890a3e7225326eea47a31455f97255e2a2dc613d084337f596c1174a6bfcc2358864046a557d215956f522df3686dc3af13b674d51041c284df570d4cb8f9f7e844b9ce4b26afffaa683b039b8f55f58e5aedc131e09be8506c348b4f5b4771f92e00577d68e08b683467821925bd185e68675e6e7457bcceea31f408070b8c9afaa316a2d463ef76332d05950d9c0e42e4fd304464054afc857c02551fb5d241aa88242bb3e0a46c97510f475cadcab2bf6327d4d880c03b7d588f19aa957c77f065739446f43614960a876beac8e4cab3d3885d492a77e3b90263231dc878b0e19e241b3db6a1c358a4afc10a6401fd4acda61605398521969c039ad09dc54ac39087dbd0209548c0907a6e27a723a9aeffe750d5de03a08d26a824058e67b336d4afbcccb36fc6ba613af21d60fed6ad29ee7c49738c508f21b45ee2395522e824bcba44a70c1ee7ea4eb27f36bd729e75a1f0009bf9006500fd17d37df7abbd15d2d5c7902b7c470f10be178a42628b57e3223f7e28d9e6c5fa27ab26c8d95b199a000589f96be8ef1517cec70bb3088f6df1dc107d89a354f5ed4989bd7774dbd1717ee8bad61743751c0f338c825b4318efecc991d07fb1a8a8a49982c2964f96af07be2659cb9af70a0dd248f0fd79f5ef50eb986944c945e0c071387bbb3bf51a2b70b9c9467423e70405c9e20e329804c6be199ee3937e9b0df7e907e65c4785448bdce80692ffb5513bb569b3bde08d456e35f354b4239bdecdac5609af1f9bfbd2d5c1946281caade9fe23d4cedeac52b5b487faf74cbb25e5492c1c96e20973d4d94adbb4220cd306e58cfbf3ada448c476bf99feaf1f21956cc4c3235f5dfceb7a8371775d1a0e793e15ae3d98d67529ea6f9d3fb483b1cd65d1699dd7430da0a907bba264c7a3441d6fd9af9d9d4ca6ccd50974f4debd18a1d36e0170743fb86cde0ca1eda7bdc0ba4aa21d75ffa9782461fa07777d68cdfe8d6117a539cf7c59744340af5c5e9dae7ddf91adba5a0f5aa1318daf51d4c37503fe7d34f644719b5f505ac3b1013792d6d097e9a75243779f035929186a812d5039c212c8b5d1e26ad334b7a14cfa1101618b7c22947bbde06dbf8d20ce20900ac5703bd2b9f32399f75d1f5ac15bde2ea5aee73f9dbece5cba288e0e73bef47c00e72f125096cdc32550ef8adf8d5b25e5cfe937bf6fa057836878751b2388d3a0ec7f5beba273f82f6879c69725112065e02d70f05999885fdacfeb40a5f73ea211a3d6359a14c50aea47e34320ba2a3a67076a3bedc634e0eff0589b3b9df870e5f639445e16c30c7f15bc6b2da0964bdb1061cd3f6f2af78a147d3d727cb9c27f9673b7073b30030ea9c3ce21fbbd61ddba3974b17447ca40dd3ddb132d0d5d440eb3b68b212fae5467594953ada91e53367d7693f9aa1828077ba311fc873c6fa07bcda04fe5dbd15e266d604ea03ea3a405f2afa412fc8c08b3f32f77d4346e1d27bcb7ecf6b6f3b15b76a4c836c1155bab6fffc71d791822c271f093d4acf1e3f8285157393b4f35ff40e7fba01d99461d9e2b03bb6b3ae196248b1f057cabec0c85b5b4b9f5966b777dbfe431caac03e4041e5678ac2c49d43e5b4d1ac07f60e04c8873eb84c25b0ccb071cf987adbb7c480b49cf26cfef61ede5a2389f83549ff6848e5c12a52ae05017132ddca61156c72625b8a4a325fcd96d8233aa29772c9fd9aa0a6604a8ab58325b40eb373f5fd943daa3790a40e15ec5f36970189ad5c1f98c0ca68bc4df2b06d07387b52856b471e4806f50f0ddc530ad4e971b013a837ad63d356cc4e831aa579c98106030897bb37d19e358995ed59b3caabfd72b0b14f3be76fa14bb7e8bce9538d692f9b2a6461f54e02eec6f703dc66409d5b162d0b3206324c84bc89f705eccab773f7a16eb8852661da87940a5a1df2c382a7c1f0cf0d4ad450caf2826eb49648aa4a4d7cba616f075911f538f5944cf8f834d91fcab134b6755b1fb97d6045afcb929ba54dcde33fbc0c6dfb407eb1ce4a068f89e647d9e0cad0864a45e9c1a025285ace904024891aa0321544562e14b4620b69e17414d17812dd542ee8f6b81f43c951f020a31af41b61368b5c37b4130b9311755a5763a9ba7aede10828f9fdc7e52011a2617e570c971204a6a934d14dcdee432b0226fe1c8e20fea3ef5fc9800843819ffcf0400c003a5e98dbc63586d2cdc0189247f95f556061e2838de3073d32b06a6f8258e15044b4bca2db467d2c42ccaa520aa2c0aa8faaed0f10470ad37ea26f2485317f0e12421aa84e1aa6db09465672f00750353a68621495a9e4f784fa9a8e0501ffbb75f2c8c81296dba1da06ecbe483ae6b787edd86ea4aec968bf1267e3dac59d315018dc43b40bc884b4f0c92faeeed44b71f943545b6650573da488109a10c1dd5c38cc469647e51d23a6f60437bb613d65b8bc89347f5a876370eec581e67183939a272ba257f020db779f24e6ae70d7a597792ea825cef46327feae444793376eecaf938cf6b2a9b79255026f3687ec3a064efa92bbbd9e8c078a0bd635c720fa86efacab46fdc132646a53f64a1d713ec8fd0d5493439bda8fb9cb2d45c10c7552890becce55df73087d24a983bcb13922cdaba3f4947ec3cf8dab50a1b93e87c62c627c2c9e40488fee6b58ece33aec14aef8af2f61c8aff8b51b2fe6d529998372a1df5a3c01b6267cdadff553d84f4da59d6c0fa8f0393479a2b894344a38656b31cb1f823fc0b41c64d8268fa704ec8311b48b17a3c3fcdfbf3703e1e91493f571580a6735f16bf81d6aa3e43d7ec4b9892b3a30d7be3eaf86d2fec0fe2d8eb53edb5c8d236d693316d2953fe43cc65b80e2f9404e4e07294b25348c2e219709ed542b45eb7a388f5e3126e2627f9055d8a0d6c5ea3b35749f486c819031877d807d4b408e784751335b55fc985ace87bb48365680276de1b5e869e2145e546ece9f3e70dcc2550e18cd8cfe33b3c3395b6a0cb7ce7aad771922396751e81098d0b0e0b5d8456c23e78bd5195b939a28935e101aa349c21deb97ae10a6bfbe51f952a752a183bcc441d682947138242ad03a8874bf8c75a3233de086d0d0a48d9ac8ff94aa1ffd4d345329eeebda8df9bb0abad4f94355e2e642a6a45274df116f2a569142b1dc5e3292f1f314c2f73720347baac07354995fe9d4b96879b44a1a203131d34abd905f458e5fcea42da2dca46d95dd3f55dc929caa9f18f76c47306fe5c4696d81cc6bf4312c8cb773699dd3dc1cd761b60b3dd1aa5733943e568f3a3ca43f4af7aac0d39e57e26aadf03fe7b785466a530cac5945107850c301103e23d54fe7b4618b1d0b38b00d705a595bd1a4005d2711f62ff2d06b2c5996bb828c152b55fe2b4f5dd4220fa99069300ec3a43c9633927a11efa0d021757806c87716ddf36b5753a94076d5b08deff2689a216a2a2f1a43ae37496b371ae271adb169f5bff3f6730c6e0b0a8bfcb18bba63811b52b5c3f9c0cc2cb1dd53c6996b0605e5ba5e5309fba423217879b8e0ed840a5fe4c10284296cc7f69769db98457fa3c2b069b0dca14a6776bb015c24aaceb5b740844d7de51c0ceacfe7ab76090083e64b7cfb613857e8f23e663867223c48cd3101153f8efdd5bd0676395bace455c03f56e21cfa6a8e57a72d6a781aafab8be8fa9b59969f27c706752a9d3760c1a204b2eda6b6a39ce2cd1802ebb03a8482570da2b7fc797a51c44cb6db518f3588b4841dc481693ee8a44b2ec750b4cc606cb58859b35700e16b18b8f2e0be6745a90750bddd896a0a69e5f93c58580907b8dca295f4e9a7f96e67b5eec32c0025b19b2ed0b749e92a66a70352ac394c5d226f279cc35da3776ebc8883d29c193da28ae5e4ec690109f5b9ef72a0edea98b01b10f496fed50461392c26223db137ae1b9fe7915c63bdc4522c89816b85e656a3fb3f1d85c7cd6f4a7ec6d69f352c161808d9cf038b559388255da620a347cf050c9450cb324b7b08ae3e62dbfac0cc97de82d91da597d8db55cc424bbc9e9bc50b6dc873e27612efdc057e1df3f27de61e59d1ef4e4759d9dda27499d0b01f0c64291e45b17d866a9be7a845a46e409a76d528db05c82a468c4a31d4181f9e1bc8b5ea83015c7a8a620f410219f8bcee8408d2c607ca23e4319eaeed9280b1043b4d2865374c83be4b6ba2d7432c03c1f41d23d230aee73320a191b46bccb0370effd7e036ca7f17606c3e5771eb28c08834f37150fb806fd98a03ebf0cfeb47301bdb3c6f9e8fdd726e8a920ba1d659b97eb3b393c2c539bc656c8b7ad97b33cc3ba123eafb3a3c46e8ff75108bdbf4f8d2a7c6d5fb4164c91d2d2d7d5c7f3063d407b2815a6b356792f921273b601c78098b3c3d13aeafbede060460db9e0ecdc1c08ffe193aa42575258a02996031a335262ec81b054dd87f79da250c4ba2a5ce87a52cceca4a2a6e576f7fac994701c13098ad49f86b3413e08491fd5d3edd270d0d37143279dad823d0dbbc2ef8fb915d5b4bc1ea90b7cf46c3b9271724dc14145146d43901d578defa0579d7bc4be22e0b006b8b8354e985c97b97673a7771680eabae8118df6235f435d1eeb4733e7db3fe18a4f064a6f1f40a6904ae647dae3896573700bb436e7bc050f2a3c4f94cb7606a29b72fe796fb6ee1d1500ef43d29a7b79ee9ff5a5eb51589221b112d307df39b281e29d9285d47dbd193d25e26ae1930d2df8849029b91c7287092d4d24b8245cae3a1655a414b0af71f6b7433c9e562baaf25c4822a35223c960c76c510943d944f8b3a54a55dc9d31605c579780f87ba62692530953271b0be3fbdbe96edf04ef2fef5e6e940ff8c6eb6054d3b441fae841eb667471e5f092a6fc9beb40d4c038e41a0a953c4ceaff672eaa38621effd9cedd4aacff9061b1ae55156a704b6a42eb8ed758968dc789f481a61966b865b991ce2f87fdfb8bcf012b88c5bf29088de9ac4d4a565c7dfcfe6a88bc094adc9f74d4f0c82372aaf0bcd98cb09cc0751cd68c2fa723d69d159fa059cd370756ecd5f9d88aeaca3ca0e90fa48d47e50e52cfae1c27bf4dc253f294bae65895640505baabce6bc7dae6c9c8482ecbb1a343fc55ee607959db3a6dfb6f748e651831baddae0f6f1ae3a4629d86409027142737c82a3a4afd2dd4b3b627d08d13f5b8d3f7fd3b8e4136e7822e6a81d353b90ab2e73e69779578cea4b2276d787ff58ed2021f233d3f313af599454737f1a91f00ca698410935f57da801624fb6c1411bb117fbc2c70d0c37a6600fb1384e15fd4d8b4247d3c98440620095db16ec4cc73f393e6129da9c8299d2fb16db43adec62b30ef16b3d419d46e9cbc10daad8a06bd565a0672b6af5597aab283c7bc7cb3912d2e1f1b30390cd2b53151b4d2b86bc66758aac51c7a507c0915562d8cb22e26191ff0d731a34ba7234a79a57e36d4dd234c712114b4f7d08f9c8bc91dc1e5c7b51cd265e1a28d7c1cdb8633dd80bacd6d54255646cef9d464e694e61114d519a8be72f237178a294b6546cc7d238424f47fc5d54c55ff194138a329ac47b930e82f000e0d7f18be2295fff7805928c77e581410813e7b682fd90869417c70db566622e126383c617d4c7d25f0ff859f3d27453b57fe52acf4c2ddab4986a9b0b3d13b5caa442af9574fc4287a7876fbbd7904b3117e50d8484987cdf41b7c35ce841f1fdf142eb2c897597b5fae48c511b03d75f251e6f24f20c1a95deaf78190b358cb5485c99d5632fda9c3cd9ee5d3a7b5af4c2cd7d89f9569d41d4e12b04b6f4cce473ec2cc2c8326013d70af7a419a63cea7b8719cb13143d63757ffa3e650c94707b622563bbcabb1a4a13943bc8c886ee8bb556da4543bb78215648295b09216711b0fd29ab0a5c3c02d8d3c4b0c7908ec9743eae197c06887cdd0d175fe7d321e1f1530d0a19486a137ee1c833d2242f59192adc18525b1cca9542019712121e492ff69c408b62725f9cd79b7f951faf3e87983bd23ca67fe6576f73307c2274bc1367e453ead8f863a36496f36b233a4388a77799ad78a39c2f65c16c7c72a61f1536287a8f827d19d9270176490e482a8922b953e82ff87fe71719cc125df728d4c89aad466fbd29b484b61e559ffe4c531238bde9b74612c64319dd987b8da2ca6264caa7a090d5be2c8608339b7e5fea7bb00da603ed3b6a7647d434ba1aa2eb097bc626da96daaf8109bbe0b41fc688205f47ba9627fe5a6c3ca910369185e3dbc542f58ecfb34d18a206ed2cc343a51371e6d818a916a34a02beddf7cf175a582a61f02ca6596d1ce29fdfc576337d4a7660747fd403ec44f023b6aa9b70846f406d97b6614495cb53a72ec1cabaef5a2289439429f0f78cfcbdf7ca2fe1b1cde89b69cda06b0e2c3e5dd743efc5b5756a16313ba138de2186e927c9bd85af3180e82fb02a72fe23255ab8888891d791df4085bd4c9bef86f5b1b42bee18bf80bbb1df3608b99396b0f27239fe9217fe505b066e889f76d73e0bdb038eb0449b6041fdbde7f6dbc9495424681671ef881d85b850bdae93ccfd5318fcab9373eb96ff397aa35792209a239ea6e41677bc1b91aa8e5bca8e24d0b351d4a679682dff84a9007d531e740e7885d6528ffab426dfd66f88a8473e51871ece69582e88b16d408138953cc5be8ed760bf0dfd7eaf6f53eb499cec3710ddc3c525b264efaf114e41500bf5a881c1da78c4401888dd48da1e658b07dfb7fc6f4082d7ce050237ac031c350ae679c30c351a36a8904a416e7858ac7324a6eb8a13df7f226843b2363f15f0c5239b77a4658bc93845ec510a418421e21839b25e9fa3b40f0fc7a1663b3fbf75eee4ab585253a98559ab36886a9040461e9056338292350572add9b764399229c397eabfea680a441f0e85397ce5a3b3724b2346efb1d0d5326c26bae277cf4548ea89f35c90ae3db01e62aa412d2ecaeb45bebc3194474ae2ccc6547b2bfffdbd261e139a5db24810ec7e30c5c16beb847ade750f5a123dafc4c088dc06681259ada29670ca83eaf0c8ef388502a31b84cb4c094ee5df53b563d1093a83bb16cd9fe4b75b27711ed6007c1b843365f62822ac4e10412ff610c468691e0529c2b28a547f6e45d9a0cac33f58ffe01593e3c42b8eb5e20608a244a0abb5d1ceef4d6e4c09cfebe82cc773014fae04f01a256909174193f9bf497bdecf1a30308eef74436427d4da32da4ccb26707a26e236812bb3ba91f5a243ef3e2b24697fb880dfb5f86532fbe0b135ab13de1a44255be114c61ef3a353ae4c81676fe99b63a8b3642e35bfc0eb463617ab81699de0fae972c19b6e6819f41146b166811018a226ec189c4719d9ad99225a882e93fe9931ac9b8bc1136971913a8559982de1822870f296a81fbe453eeadd7dc40a307bc7b918da72436b6b217be6abc9223df915e83eb4b2b0aa24141b8a96d0636115fe263ab7276c30c0c9c4c5289d35bbfb8bf246ddc051e00bd7411d452352eae8272e967ab850263c452bc0a1f711c538838875647211be7d25d04ad04c663de2cd8688b8182cdfefdf1d4ec4513df32e363c0d040434a053e8d0e037d63f0f169f0fa3b36afc2822a8e97c17d7f6558a3590182371ebe64e035b2d73fb895132dc16d45f233c29065772b902e3c84701a33167c858be760316f02649d7e5a57c9979542b65db252de14ff52b5216acfc9746c656ed6f0527f7025e2e561c6ebac10a756e83c6ba6190e4ec8ee98b4a5ca0d2bd242b617a6f4d73e7ca9b2342fa64e89e98795dc4c6b98668fc3b5f137bbf535c73a36133078be08f9b6095f2e0467f4f68902113a5df4c65438f298f65942f99cef8992fede265f6fbe8e6bfc7193396072077e2b6293bbb4a9dae586749837d6ea021fc4cbbce4803e87e713644770189b073d123cc6366d39766139dd0ffa8fa6b640f987fa3f75567ba2f9d8cfd48991d7844a86d2b4c49e85c701b0bf117e486fb7d68c3de012247ff1efd0179ae09be06a139441adc221a5a919c24382bd110b2b5e8ce8dd3f2aa7325bac15dfdc211414ba72d0b73094db179141879c48470fff06c8e74ff2991db06b19292c046240c4d94ee9896247fbbc435ee87f0fd8a280032c430a7d59d4129ec3f875f1f5ccc68d4f58155e3ff6e286863c7c55607684a0178b85896b83f0be98bdb9093a2343e73c138cafc3972dfdc356d6111ed82944ab22c1deade319efd3476ea5ddc4fc9891f7d17090d132753030617cf6169212c9c6236b14585964cc5e0a64dddcca9cef50e48c7f8b2f81018efcf302fd4cd58f83b3b96f8cc97c753269860aaf82aa7331fa8e0dbbf4fae6f275283e3ab87d28179727b067159376af30f7e021653a0051d9d62327fcf7b39eae2a1777618ced4c74cb4e2ab650c1f036bb8fbb23ad2101521ce7d8a9e833efab344ab0310e1cc4a605ca3c1d7d3c899de57503e3b252863a8065ec61eeb9d678fa680f153dbe0c0d799ecb91c315be0189cf4e2293cc274f02d48fd278e12ca5b8027a3d8fd03173c20be34cdd725f090bb2365cd10e16b7e888aca72c80ea1f228858e9c7a54e3fa4497cf0c97f7c3976c35033a9458af16da25bed3ae8b263433c2809d6d33146d413c9f21e4be4803e76076a615d4e9368c79dff1e1f5ca082152d69b89cb0a540531ce5dbbe67d644e48786bd664de2b5fec7167dba4bd8e0358024bbd6bcf57b2e2adfcc2bb4c28d2b45241c074afdfd9c8c6cb1fa232ad4c41bedcce0f96a14913629f245101178dbf2ed10580ebcae10d2426a2c4924cc00496e3b61fe20f1db19d6bc7922de2afbeb65aa1ce0fb86d09ce06dff71908257798f805096086cce042faafae608b56d16456de682b0690fa78ca075b5cadfd8ae6fd6344ebbba39781b7876213b7b64c2217e836f5ad1a7893e9ecc8cb9aeee53b0287e39c47380427723bae6cd743c2afcb3647ece23a945d0888bcb7ca8759a11e79f90c271e7cd21c6bbc3f78671a46b7e6d7257d728979db64390b873704467dba56173854afc7dbeafa8bc2b2b4457a1eb249721fce30cf9b6aac222c3c74059b5141a2debe5eea5b9908e5d09e74d504889713cf96c44f1c8f21a643117976209f4b5e99acb99f7c026226d014855e06e1b1c54a92120cf4eca86fe2fe15c789f5b916ce41739553dd53497fb0d37dd99feabec37bac6881e357a02fd5073bf49e7c8776b76fc3387c6bd854dc34b2cc3762ee6bcfce9c4c2f43e0b789f78d6b8ff900e8502284de4a240b6a73fab6621aaa5982ccbdd7de22edfa8f641d7698dddd26c0b36e9e4ab22509fd73c43afed24d45101bbf87780d966ac7535c473b9b807d7fae038c779428692a567f27af07b809451ab8919f6a359850c05942b857c89b76eee6ca86fd4651e39aa237b63294633b1ef1e4a4130b1f19e47ce5065fc53027417614fe9bc4b44b46314089b09907e0a7fd014eae64e23c02297a568a0809243b79f93b53b339054fa0d87228b5afd2fa41da658d068d5c0477c30615d4f5a517895cfcd8f8d1e0bad2236888785d35659ea3b8c6563c36763f39b04d90ac50cef0e188f8d95e6501bb39e10c1594b6eced1acb2d5c0a74d11733dfc645fee56950f5eff722a6d4d97b861eecb4e6ef7d00a4b2695d9a49dc84e4ea25f09e19eaaf4cab04b27d9fce3de00bb770dbe8bf83d3a7a456795b95eff500eb90938a2ee233b2ef08e41e50314f7b7735601cba4118d2285e91386e23a778a77a0af2864cb5eff0bbdfec3ddf319882d5f89743edf7af6561fc3533b44a4b22c33c04f99f40b99b00121edb0ace2abe1cd18e2d98848ca55a4da9e274b81fb328acc9a9a3d0e8ac59920173eb5a2425957abbbfa9df1aed37317a78b116e84cd7db3ba45b860eb9b0547dc08fa0d3a0ea036487f788709484c0577705e54b7134fce3f8b6cfedafd00e32cd45f700857eae74f7bc1c2be2f61b63c9b5eb7f949f3b592716ba28f6d162ee9df9fa7377719ba255de518844e44da13a732d35924fda5603c6ca0b6e165f3c5e3d55833142e1e0ea9240c8eb2cfbe47146d67a0fdac3420dbea446c3624aa677e54864c86c7ab29593458d90e2a297c359d6a6a7184fd743a9489cbd0ea391608e3359da8ef78b2ddb1f61e25a07400caee3b1d5c18bfdd10486487e058d46dfe4553660cede379f2f805a1681d8027631542a7a7adfb843fbd4a844580f884d7f23db727a2b786bd1e1843e960710b8ea9013fcf07ed1c5242e3ef2664076cba4ce4888da4485fd8ca0c75c369178c9d46c82062cd6b4a6670b59d8c0054e5c2778d073391e89b92efdd890d658182e7487410bf39a04272bc1658b99e2da3ef6baa9bad4f1d61a40c696b48fb3edefcf4825592088a1831d2530f2161735d5755bbd38126c40bc579907998d3d36c4e2c34a7e88b342d83152b3b2679c81748b6b7fe9575b495cfbfc5a3869ba6e2fab7081c1e950939bfb2a7434536d66c02064cb08624ea71b55700a6ebc9e064f484f1ad970f729e3cbd98d9bb5a25e948e9d539290f9cae84735094749def1f0b6aa6e1a7825862ce180350f94598c5fdac6badb1ea5b958d8fb1ba5662fd8bca95cbc755e824b32f8f6645975649de2805b66a5115c28b55e818224433a407d9dd49d7fe73a0e6ac3ca6a475da7d930a50b31e781c9456ffa4ded3efddd6590a5078f9b1f55c1c13051a6ffba8b9b4ccea85a436a028ff66da8d68a3f8e9a6284994971ca263d95ed9172f7adc2e09c78b514956687e5194cdcd4360fecf01819512a7df109fb71bf2d4783c5fa9bc9aec0c589d7fd47054c52949fe717a6603e6408a7b2343988c0385579b804c70694f2858dec5f2875722daadce6eb3de8c87fdc4cf6617c6ba8c8ecc3f4b974a13e55c573096effc20f6cf4c25b5f32b5f9e2460ae5226eb89865ac4aab5f6ff7bc3e71e10aa36040d5e40c1a48eb4125bfa46b89a18d25eaa851feefb87574f6ccf1973cc7e3910e95339ccb5eae3e75d7d148aa533c56844768c4a702d0a03d8349ffab9a6ae7b734704a05e097dde5d644220aa2f9b5dfe8fe4b146dfb71c528348db8068bdf06fc052af21a64d94032fd4b043bbaef5352b45581729110304a0a408148433ac1c40dc89ce3eebdbb7d5870cb3a600920aaf799f6bf4a1d33c3d4c53e7732a36214b4530d3927ccf196315283f77c42a6de77c84a73067c482f2c5636d0206403e93fd813655e52ae37c09c083e2e70415b740925a5d5dd56c4d4c54a24cb9425c6bc7b013b02a47ccc221bb15f0fe09f651e7de8b0b51d24013274cb5b8f7a9c3f4c506ec753fab55057228da149ca568fa41f654b09aeceb81fc4c816bc6f449e16a8daee6b22da50ae1acb42c0e02b5447b006451683c6123cd8c1c62d0b2360cd4046d53c26ff07d293f4a12a743147414cab681c9c3f037e2f30d72b9173951183d85df4498f77709e80c61ff989cc248e5c46e01af736f81359439908d67c9e7cfa4e203a6edf16a2c44884cb0e62c94bd2e55cbc664cf37439fac4ebb7c9a6c5ff15ac89f59ecd1c2b67ef7df3932340ea41b5b7bd1c1b2e9367c9bf1f0bba3b984e42c2723507a4a4979057ec798ad849f2df53fd523d40955ceecdaf3582f454d61c7073613d0991016822e3a38f6329f0a016a5494b01ffac649f4dabd276e6e26f0682f6fe76fec949042c536984554bead430dd7663e0887e8968fb36128a41ad060614f619fcc044364b03f7d9cca2753c40f63f340b759a7a174ed0f6e25fb4e1daef2483a05833534f2f6a6c601032dfb02d33fc73551e4ab2d88101c7b8ed46d70a384b9b84b3b584b2ea9ff2a540d0190807d0f31ba70772a3edeb29a5b8abb56feb30d911844311ed2447d4ea10e72f04288683e43bc2d95c6c103e5e5e40778c863085893cf7c0d92de6afdbb98b4330b5d09dd51e490ad880fc86bb10464c96f0cd9c3c50cd54afbe057485e261f2889b1f77dd8aa8a1d84ebe6eabdd5159dec1ad9bd29e311beee8e660b99cf214da02c4956f11b2a82eea6d6ecc023b02337103561de10c0515a07fbd0400920c7e77257a07191ec31d84a70e40d186da4f7ca956646629de695e97ddfd9f1dd8d85e8653daf5f0dd61471b1eb4fbba626ac0436de2aa7e671949841cf37cd614ca6046c7d87df4ec9ce1dd182a77ebeccc6064fc83ac5e14d79903d1d75c16b71fe85226d8ea6031da5b201b43af2f0ce44dbc061b58a656f47c5a479906e8b65ec1b1bd04340406bd6fad65707f69c468cf884f78e24336111c26225068a177ef4b610120332faf693593b35b82a3315c3d911db5bfca3eedd04cb78c1d003511a7047f65b302b7fccaa39221842c1dfdabccd40cedc05147057cf6ed96268c62d13b66f9e147f20c290ab521f081d414f958c2408970845509fa114e13668a749556dbae92be7b58da057981d12163421947c4ecafa899fe1607955d17be51e8c985a3ccc4bbace54e787670a370e21a5def3fd5471ca50b4136d1d98d7b69c89567c05e66f37bfd73c3c75b5d4cc26c76cb145dd3e391b24d4a422e0280e5a34936277302e1cf21e66421e17b8dcbeb976c785307b633316e0480016b746fba63093947c038bdab47d973c65bfe6b429b7c722d5b210164ef8ac84171b35833b9b4a9a4f323daf7f9b70de43e8843505e494d34f47da87dfa9656039ef6c12491ed0090534894c3f262892e685ce5011a05dcbefde9534718c38066e39ca1eb3b1c35aab7ac8627c34a23e2d8dd82819d18a0f6ec0648b939dfc967d1c21caa6c2b23ffc10e3bf05bed6dae7051de6b22d5ece99ab31d796a9c726305beb11590566cde9d9636e4f98e9209875d9a36f159626aaebcd445ebf085c772cc863eba9d8afb145dcc6f0490e57d6dd276dc47113f6918d1405b0191c305bdc6c268c78533a0c8cf433f1744aae60eb1b8f341e0add1003cc05a1e7be9422e9f366c6e52b1ad9172d544a8fc78b0151db279e723f7eed5e37101a3e89b128b7177fd20f44c9734b439ed55bb3adf3a6d72e2d044cfcbdc84935c1db96dbe59b4b4bd0be99123420b933f896a986043b993d3d0d5ec1c9eef79ac92b96dadf022e901df558da4639f35cac660e0353611b5144067e0797882c2ff7d3da33f4e41eaaa289c703cde3969a3a0d0eae39b38f35eef74a59a7617dbbaa22a9af1042707973272a42b779b77ef2353354572230d87d97f50b0be52d67f69356103646ee8aa3a557d5cd8d818e5e74e1010a1f2eb32dcea737ab2f25ffca242644452c0c2f439d33d70b1146f61911f1354bf26df4566d10dea4597fd534c51bc035e242729f65d02d10c8e1814aefefe88126c6aa150169d369f9a25ca94b15f887d7b7fb2579fc360bda177d37c784d3eb83878f75c5b57e9002c1cafaa7ac756a563ffbd08e5cdc98b370173a723158bdaa376e5d861f800f3bd4d8569dd1fce405268bfeaab04626390f462ba415340d83a136f779ff756020aab8bc34ab0d17a3b90f66c9985d391d0be38ee9e6c67d29584d8e11a6e49a14c1109ac579787721cea8371967e47c9115b6b9cfac66e22f9393d7f673557af423bfcf1f5749eff22373404cbc86b8ae31c8c2dd08238909ce2d5894b780bd3fcc4216a9b1aa41fb0eb3dbe4121eac6ff07250d36a2f31e3107c3e4d957aeee03db85a89eebc8adc7a7c2e239c8d518850b2478a73e492dfece4d232215b6844314e4102e862ee41f2bdbff59107d656e82fbe7918b9ab3ea8f4fc0f2f7c155d2e0323b218c2af90cd8653c1629ee0f07acc64d7b683d3ca465f71f0ac04573fcd9839699f5eb593c5bac8286924752ef0cad91ba270538340adcfa7628bc57e210733b05842d7a0bc8d2ad42936884e581f5d537cc66ddda8ca41b57c785bd5a3f46e738e1c54d7ddb88fb51af97a8b14456dc44020147e87d753f7398ae6f617f00962f0ca5dfd2366113b78a64d818debcae8fa7960124acee6884a2c13744d1cb810861eaefd869eecdec4dcb4ea4e3f05920943c1b72cbab956a01ede6ac9aba6c21d29d86957c5e001e4bfcec80de750308031171cddf478eaaf4327e959d925000f87d4714ba069412b52e1d67758231b15659c32c9d69c21fb8f07f66eaca254f09455323f470d07e3df7dec781dae4ea9b9f89977c6f67295d17b6398e243556b9040a1187bd568b7e69c6ea1496c020f1cfc350136470c7a0c8bae65de476701e0f46cc346f1f8e847718960451ec027708cf43d968fc53e4085bb81df7a70a7d9105bf9ff43bdef0f8f86692524da51bfeafd61305816c95c40559493e697bb0da29cd4842fbf158d563ff7ad4049b65e34b19a8dcef2e62c3ecd383fdb50f07a813948fda7e0266630da8130b38a28faaa824086e1088ddd2f30cd97203404c7f95acb7a6a898c94efacfa8de12f27cfd7512ab664764303070148b9b1bbd8b3b40bad7d6b54a6fc255d3c27e9d0d484a4cac903a7bdb98614ae9132c38430095484779786323455b30095223f522bcd96428b12e367a9d1b6625a80d7546c38cf7c869b111a055e7c28ece54ac54223e1866533f6496e31c5fed4918bdd3fcf011b7d9a7dc4f50784afd03d6bfac24bfbeea1692e6e33ccf674657434c2e978652e70b07d3f851696bd6465ddeaf58a217d6491ca1d503b779e557497ab75850bfa59ec29866bb578eaca6781196347e290f763b07a726ca2300d9c2ddaf9823c70a539abbede43f67c7fb9832e1b756d0bf4aea65d166ba5d4333e81c28d97a67ad5f57b07ea5abd2c8e2fd1f3a7bf9005c6fb14a32f4b15e8064b7443f73680ca42753270f9b9356c95e879f56aa990a66968962daa75bc60bc93986eb1db14c2b5bfd17c06983ab80cf413bfd2681569501cde72f60c8ccd2ff79eada34ffa3c67c0f0ac5828b7ef73c4bbdddc0148b81384710e44e47916813dd2b5fa705709ac0756fc5d90788e298135b70c09e6f74cea81ae2db3c0a97e3d5aea66f86fb58a9c0af5f79f78d31b35cf7c0cf2832b26d49117925d5f051963d7dbe0f5b3147f5b2d2a30ec07395ae6fcfee9a733dc8c0ddb3e4b5bec12b2b3ab27351654d9795f4217117ff751ce267b1bc5583d8f53d4df8badb28861c283df97ea2c43237b84eddb82a8ae27dff7986a5eda1a39472ffccdac9df2c600857905039e64d65ca671d074639bf8e5ea990af8c0a2fbbe166affa537de112cd9505b4542989b85fefc22f87ae4b21eb40e73779f3b5c81d25b16623724fe996074af9df3d2e32e2cd4fc4909e6e493a619836726cb44dd34a5049deb72107297e64ba647d992089f9a7237516f540fd2085ff5a8e365a5b80108cbba5744bb8e929a03e34f66bfcf9d2a318352fedd9fdfff3da6996db4611c1ff0155b2aabb8431fe53a64ce270498178710049778b586ec001dfc8a914c14b27de27c1d122c5a340d17f44692b5a4bc7f00df78f6a6b9d6dd6fd1538d40af5b558a1ace5e0706132522c34c28cb89c406b9f1560221cb1a619a26bef296ac70a16647a7db99f329351b234680ec47d64ec35423b315f49647511e51f488a34492b6ad96bf752d6b0bd582927b786fc9e1a7049e984d601ad8ae63e76f05814bc4e0ee88c3734d4ac5932237e853edb47207b8a155c9396074edf5f1e22062d2efa5557861f2596b5c799e0e383552eb509dad154290d94dc2dc8578bf97e18ae7f7d4a4676bdbe3eb67cdb510cb9a385a8de7a3dc2a764b73066ae5b187166b2ea83d75444382d7e91030b54b498b4d5df5f9a3cbacfd91a2074ba101a2a2d8a099279e06f89b19c974a4bea2a9506bff57c9cca4b377bbe63bbb54caedb317c2531c3200ddf68ffd310e468d21763062ff871db1f4d329dfc55ca7092","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
