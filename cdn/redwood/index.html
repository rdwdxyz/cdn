<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d42e7b63637962a5e296e1f977774cf3e61e93607f972e2da8c395cfe985f5647035afff3529845d0ab8f420f2c49caed9f46aceb87a7ff149eefd400f6168ee6385f0234d27fd321221505da523f93474af1e02747611de20478375426e7908310546fd0819891249b378e6d7709711f39cfc51d400326e8991c2e40a17748266b33c8b079da03cef70cfd5caace3c61458a0867e61f794974d12fcb9144c0f68904f8a767047aadf37a1d0ef682d489c1f6d76420b483d0732807a53f47647998e2722b3a99eb1a6c25f1fce5dcf23f738899faa550fe034552fcd5fc8bfa10d8441aec160e5b9e89cbadcc4980b466474895db0f834d6f21ae153caae687bd0971e07882b2a1cada0631ed97235919b5ff5048e3a1c522da65771638927a9f1873143147dfd87f86ad2acc7f840e6a3ea3ce7caf8ac2e7c694ff671a7ee25319728c940d370f150f83d4a74b4127485033ba5d33f519ec78ab69f5d3703936ca3f006446e870458a48535407b8e5e805de87da7c9dc513f1e63fa3d882d50e80b90800ac547c56f7f4ed2e5995321c1b41ddff94f7b45c0c45f11fe789997b9294fd928103b6f97ca029be6824965c4cac86286d55b6ca732f587c9fa3170cd53309c9498535de367e44ee88ebbc5ef3a6b61444f3af3ee76b313166dd2788c8b5e5990fd1b8d726a2b78b3bfd3dc783bce90961a1478d4bc187c345d862ec68b978b4e2e9a5d1782cd7037b440a849ca2c7829e78d85b4d7d56dfac410197de872f3510ba8a70d778fcc1f4ccfbc55e1831d5c26622627bdb9c0d099b956aa20b7bd71a42c04717bbc71f7092ae7a188d8c6301c1f9bc1e36055486a0fec86d8e59be52fee69848fba3182bef5f9d3b676e3513ff064885ea2f88ef475211b3017356d18816860611da35d9ad9c8786b777f6391bc0fef726747e73d155f1385aaf0659357c050fb22cba27ed7085bd1a1fc9a84caaf9383dc75679486993d43ef23baabe64ecd99b6fa49f26acb06c29c64c2dd66ee7218cbfc7a4a942eee1f3385cfdc78f1284db57355ce2cec2b38e6707921803ac3df1d2118413b2a412fe56dc1884edf4e1a13270fcd1ebfd703e97a9821169a46aa06e026f60c061b71ee29e80af5fb1a219e31eef75d9934ecdfaaa680b0ccd7fe0523c13e00a90ce8c8e34157154814f40d817d305e4c1dda81f877c29b1fe98600b98e03272415cc2dc26b0253576ed3c149cf252626b6aaa6898d137e277eaa8860ee38b04953cb82094dfc4986c409bb1319f167aee904d669778a7a4209966296dc936db1e9298acc4d7e87246ac2281d55309f6f555a84872e96dc203b0d65c22c18de017e6b1fb956315800b3c76e0ac15682a26cb22badffd12426452c91c6cae788fdf3d6af540188a83747667425a87e39e66efe4ebe1caeea0bc06dc9403c8e9d0abe79c0f817347d28a0b7619ea0bc5ceb535cb1b52b42cac6827e49a71648ab8fc380a19f16aa8ca3d0b621789c90057e352cb66633ef559b10920b47b06ace1aaed88e78daf245c8588dbc5fcab98d01e0024e0e3bfcb43ab5ac53f149e6a27921652a4fc1ddfed47e379ea9779d17a378caf77b5521b6533d05382b5eab76bdfd336049e86aa719c11703694551b01cab9e840f533e8460bd6eddf5460b29e106eeb68725a68a3a1c14108bc436a0c91f1fce83aa7dabd8118469f11eebae1107aa25c3ce121eea66d0751536c2336dbfbbd8507edae167564ea6763ceeb8cb77933dfb836fb28a376141ac34537859146b62d628e8ed00ec99677813b43ba5f305301faae1a81ea7077f43be75e8863754f07201bfd37a821f3e68ff593b342e14e33c92da1df9d48fa9dacbaba91aa6636268ec8946b81e6f0696ec454f41bdbc906616037520b639ac2d4c92ec371986f992950bc7ba9f4776498726451c6d8b19c5ebbdd589ef32e1cc29fe87e5acb901d98107f1c61b8479dc34c681a6c6ebaea74f35482c3ca06594caf19c1cb0522b547422f8b43e39eebfe234e4be2bf6898cfce053f52e5b85413c6dca50ce7db4683f25c29841b546d6bc34cee2a26dbf60ddbdfb3eba5c4554d312cd3ef84ebfd8925211b4f6e5d025a5122edfbcd91cdd30f9a44249e264c4a7a7a7bd8d22e977f1dcd3bd4ef6ef2f181c14560f3eb0de225e200ad0db357abf976384e948083c8aa4bdc4ad771d7f9d8daadcff6ef3345aef30c6640c42714df0b9903cf3c5c49933446e73fa80973dc11774fe3bd957505e2ed11982b59e2d8b9e34a261464db8e49533a8872a5a965c153d86e08e4f38081126b3b553c2e508bd7eb518aab1aba9971a86b1f87b42bc0efe7c12e22272a921496b8bb64b877d80fe3f21cdd67955ab5d9ce47920c67d664c3120d4b040656937ea2bdaeecc434e3b6370b137ba890fcca82f91d6097621575f9aad9c57d84e45dbd31bf203548982ea59c35dc5bbd4724be959af625e454fe92438e69a5b881707d53655fb9688ddca132356623161f5c7074421cf17dc02082c6aa5b129cdabcc5d2f21758c3557d2011c22a23084caf6ea7fc7d81dd99d7f741441e91dfb5909e03ba54660a887ae85b338a7e7c00543628a01c855c4108a9ee11d45d87cb9701993906c55dcddba3a2e6992c199ef5453e4c8245f0533326b4849871c9d8fbfc2ecf0c9751f0306c4e3facc983082a0b01391758dbfb8ba0fb8ee59ec160248f6017ce3df517ebec4cef19a4d2926e6f2ed053bccf0c165ebd416ae194a3fe0104770abb5cae2383aae61047c863413d744fb516bad2ad7253e6c42a7b74226a2607e09589559b5f9a3d2cfb5f2a2f4dcf65ac62a990a5b3a00b2f956bc823129365164b8843b250aa084e52d26e8600ba0d1aba358a924931706608a2d57d4f571f26e7bc7ed0e76d79d80403ae408fd544ba2ed5061590a1a596e09d5be22358a20f1aab841ab929f0bb5863f01c6509a60d83cf1950adacb47a062d5f96d8f977fd68bb968efbaec66a686b36f441f865942be384b400af6592364b857adbb32a7da9880bc96165fbd8bf1d145b5e7bc0c3ac583f3b69b1594bdee2abc6c29bd299ddd47419254c240b0e5551b9c7a0759b7f34b366d44ce57990250987f811f12eaef57c23f1a405d6c02b51fd4dd5dcde600f3d4f2ff95ed8f95e85acdc01a85ccefe12bcb5bc1934f30f965025bb3af1fe836f6cdf7a69a596109da88828809b8f8e31d4f0e571dda5154325da15834698c21e09732281ed1e0529ddb2ce661c1480704c8ccc4668746a1e32ed4f89deb166226a4266d4be8cb656298c3d70ae5738fcf614181e3664fa024eccc07524cfcb5426b64d0219a082b1bc8a8d3f12c86638dffbce3fa9f36b7985fd22e25a5165225b5c9df91370a00f90f64fd6a37f49f9f339b60cfd1ec343acf336d4033617183353abed5592e1eeaeb6941a372320f20ac7387fdfefd871226afcd97521cbcfb2b58f11eef61dd88b3372dfc0c9ae2c9605753a014bb74a737956d93fca0351e3648a2c63d68ae28fe2ccefc2bceea2e5c2b3f9c19c84ab1766297a34b93a9fee9f4980fc9800384dd5f69cbefffb11683c96cbeda25609531191d5e084017496e090cbbcfb97b705e1a383462e2bf1b42f9eb10770e33c27154fc5b0d02b716a909ae4afb1f1f50e73490b1649f75a412b655e150aabdfdcebc4a799ecc8f689347c20eb1846b15aeec97487ca63cd3c01d2d427713742c49b69b3efc64e45400f5103a7a208a7bce3e55730b4579333265b7aa19aa27d17a7dc5280773a0178a0b96d7ab7f72e673414fa482e16d3a9e285cf4435726e154e8113136b4bca597f8333793c9385081a672ac171f7b2040b751de5593ad7cdc5df5fb872f5feb61f05644d6d5b5d551837f9b1483d91b77e2c10d1b3caec412e4ef7d7ba92b06de13be5411b488b841a5c59b9ca4bc8245c234f224408820530399def1731f16c6f4cd2533c341380ba07d721087d6e30e91bc364d6bba2d6ed8fca469ef694c4f1d536efcb93f1b157aa440eb9800d478976a1442d0982ecf4e7860c323fd60b28b1337261ed3ff91d5a7cff2616663bec8144943137e1cca17172b782444e074516e10819d8afd1ed9161d6a147d9ec4610b242a080869e5e12beb485feca9005fc106560a46c903641c2f3b3d9b9a4d21b57dc233664096f9bd321e1f63e1de81258aeb7a50252bdc63528f74bb10a3fb600de4fbbfed3aa9edcd4c2f4312391240041e4a6bbdb04df7c1d68fe160e0cb8c7df7b0f99621fb1e738f30db2b993fdc73a2b0130bb9734409af744f606add493f379e5087751afd12ce1fbd69df94ad8550a77ac329c3fc9b26dea18d3b2f88aef94f14d22d35cf2cff180d6e88d0505c1c1cc143d537f289ebeef2223bf0126ddb655fe2cd24f2899ac91aa5ca20b50df35e7fb582bdfe3ae9047db6bb7f4b753c77a7dc6405f390392da4bfe801db8210a6ccd2277b81568a38f5a3ab3f251a6c718aa9da35e097d18ac7bd60a2b9f1a84e69d6fceddafa29fa2b223e09e971f4ee3e9a7394de61e20d014a97845e91a01bd3f5cdea39eba3665a7a811d1d0dee2fa6644311f939a93ca7b6d6ef4b8cc2eea43ecd3a94cdab479d1564488557d8c8da9832a2982f0e766b26bd829468719c248866c8042b91c8555f01f899a85ba8be90e9091c1f6f213e759815fa89b9b1672735bad517f9de2dab49667ebee283d53f2b48ee67ec9f39b6c860761e43c64152212e88610e7f4961965b632bccdcf083c1f679e47c68f7c93615a983b217c399f1009fe031011f3bbde6517d03b8ee7575e4e4a2bb682cf3b56a766615267c9a70b4ec025368106475f5dd7b93e21bb4c0c1f3e754c54acbe70d43196809eb84c11eb3b7337d07e79199cb49ad4d4cf79803d4a1a1d85eb54bb19ea99ac77c747dd818e29439c4b92fea4d9a8219d08bd2adfd1509b48abdb49621da93d53fd0a4cb92938d02f5defc517e2c50a62be16084d97a43c82d6e9b8d70409f851ea8060de2b56f68d76256d3ff9b25e42f260fcd48d8e83c386a7031c9aff824bbfd5bf8138f95ab7a31d59b6f78944d18512cd4881dc930edb848f7453ef26511c040b7a2f09342341c17a589dcaa95bbf0a538ff6bac3561b41170d5b3e15ce29259342ddea6c99364f382558d58fb586d1ce1e7068e3e52552c3f4039af1c935fd3635baf1e9bacf9f57912a99b28666232512f90d0aff7c771e7b9be1165f4993052cf917b01e9d75ac780f3bf66c676196878d45a24b33d60697dabb02353c3eeb83649c54e251df915d27c14879c02f637f1c6c9f7703891ec4649139726a2497aed39f620232a9c32797ddd1e2a4c8ece11f8da56cdc5757e195e38801a873d9351b2f5df2de65e381e1608c8a043959351d9de496d181bfe71604a4a134324696432072f6b8f71cc603c80d8afaf8775402db17eaf7be908bf01c713f958eb38e3afd246c36496ee186a893830a3068989bf983110d746d75565b433ce997c05e8de77d057afc526955226cd7547a895b6da3fa04da4436016a1fa78e82343e0b0fa2c0d2fb698ebbd7263afafa316fcc121a1ab66a9ecac51d8e26237eb0aaf7b497ea111be77c448a9d7e6fda87e5bf5e19f24df025df8de3a3dce608922ca308facb1e3501aa11e3ead1babd6716fdb2994c44cc3078fdb79e22f3ff0acca44e106ba984fb45f7de97e8e0e7d06a81ad4e037815e55407ef4a783f13b57e1410a88e2ff3f3edb79b0e8366b2db0fff67ca21db1b33bb233fa523858ccb1cebef3781c60f8aa0b85e9ddc446492a949d41eb9c7d6f22ec9ce4331c21b03c23aead4021fd713d4797a4edfa43f34c9e330065bf9936c6946f15eae382970eea5714530dbc38c8aae94271db3ad7ec9ca09acaa0a3607f54d8d4346b4bc6cb734864a3b653f62999156583d1c775b9ec641ae88ad1867e3fcba5e6cde0df1084dc51f9e64c15e0866fbaa613c0ff9f431bb14ad9ab990d685a107a809b216aa9b64515089a3aa0106696f950564f6f682be6b303bc5b237a8e204961203f6b847e63998063fe8689169b079c4672485e4dbb7c06c8c54dc3fd9cc346e60605fb26b96e633fd0d7ada7d3e4ee0c441dee98b1ece7de0d36b4f16ad15fc180ec8478d5d6b1c26046b9d3faab52f5ebfac895ce11cabf01caad37fee1a081198712b6e5ed9925ee3882901cfb8f817bb83ae725339509b485e201b433acb3b4afd4db21cee278f6362c1ca164a5eb8c34cb338fcd7058e167f0b2800c8a9da86bf20962205cea1518e7d7037ee9eaefc3fb2a3f45b8304ac91912314b121cc015df5be758c2bcd3bde0c275f493443349969f884fbfcead32767e5c7079b930f9b7482deac22a9db8a1bfbd924f776c8ee6922792f5eb55dad3f77f8f3b89e414bd3b0e159e95b8393cda89024b237d0b7711b89da7ba358656fa21b501ce6d9ab95eaa641f5701764b6da1f3a45a3f46433a82531c3b8e72c1cc4fe420d099ebe993e0b9ee3f2e13433ffcc43c5f4f551c2378d4d6ff26cf1ac4a1b05ca64cbb25dbf93a3c113fcf9325447b1e6f2168dc95cc6b2dcefffe9460164683ab94f0c16902a2764c3d96e51766b56fd0b2b9b35471bc5706def0190225446d5e61f31011f63c289e9c46d34417c548370485439e69c398107a0c41b9cb7722214d3cea0d90ec3c03c388e0edb3331421521972582d706937f22acd57eb8159fbb1901864ea309d8accd5fc853ff32b23a7f66e86db7fb365bb68773d1132b75525e7bbf0082b486a4967f27ad2fa0cafc4e16c43578d4839991094692fc0c3c7575155e580653675d8006385d4ff171b4d915ad6a90ba11d1cac06fcf5027c0f32a765ed8b435e479429625263e2a98416ad70310989d0d0cdd5ed9b5db4c21d0a75fecb25f439558cd0507f7a19952dd86f2e8ee555b052d5cf7a785c424c939df6c6a87a38a564283cb69b38b85af0e7719fd5f0a4a81af30a457999ad47a2d8127d4d03b9fa05804a35fc3978fdd3c38f8a0ca30e7be9975f31b4a884e3c8eb562ad3a34805d878101f8ffba8df85bf8b021372557f1137c7cced3003f4c43039ec26587d9241b14aca3bbf462601acfe7903d2a88e936a8a8e8f4c16a7c8e4d501c1afcfb2a3666294a9f6c91ae9ba6451ec8bba2ab7ed07ecccc0921d8bff5df60bc0f7b6f7ced9d6479b321447be7a6875defb4afddc3c9a1feb96f77c48ef61ec9262e9650b6ba18c84e27591c5779b72ad6a2768a6e84d2981ca9f63eb4a1389362d9716b9a88e4b4391d5c488c8c18409ede5b5ed30cd1bbc0fb6e903da37d10c9db83a36d397effd8fdba622ad7073eb918c18ceafcf2b584500a66045a687960bdb13157fe14c595068fffb1d924f3751c7e5e7213ae98d4505f365709933c018aa2277dac436a42d2f5313cc21960f8a2acc9711d67be12cece031a8dc0856e4d3891a1ab208e8246a608145a3750d2e150b0e0f94b2187b4a211d477f2bc54a7d640415599652879e8ce56303c3e880f7e2a3f5c701cc0f824e132ff8591165ff498b3425f700a0d1b5c87f75c5cf7bb2291b2d6f3c99e182ac1988146bca2fefe37e5c2004ad1d34edbbfdc7e9ad8e3d7d6d7095f5da88129477c281a8c4b48cbc076951f10e83afb9e593c775d3acc07afd581e41b9eee576fd09edb0d8c847851522332c2d4b6a1feeac405b1d84b16560999fa75527022089750de37624f50113e77997ad917fe26cbca53d25cd188d295f9f8a661d55b133e25949595ae32b12995049b016a59b0c80528fe83c1d78eea541b2df122f9127f0ae2d4325c336389063ebb0fdd5a87559b9e80a9783df598f59e12ca749c7e8d0e132453dae3b6d6f24cde6a8d3421df8b67f3a2fe39dc0e35e32b0021c204d6c07995f3a8e28aa71f401d1bd57cc320270499a51c76d5c7fd109b5fa79689f3636d860895eeafc69762db36a9bbf6c3919f656fed69ff5d1a84d48a80522caffbde8dcb52b20dadcc710d0ebe8d1468ba9cdc341ec4411d618507b8dda3f31ea159e0e29361e952ea2d5d65a092aad18373cfa6fc48017359496ae07b0209612003736dae3efead2d314a2827f535b723e79af1b2b8d043c3d721c9d6ddac7df19c19b0e163d86cbd3c60748bc223e99951fd4446c746815a8ac6cac5ae770e220fddf63f9d2e2e7b7b3989bff1da8e5dbda59746d500cb277a901fe630450db04c370ec6ec908d4bdc05abe0b3110825bb6c160671cb3b14d938893b13579ba86277dd6342d78652c18d425fb1002860e1b71ffdfa359ec642c773c284aba17449b367927f530f2936b98f18a69793b550cb6277ebe9ec65096c29049fbfb1bb01c5888574223c169e226b7ce6699c65c87adffd297d460013292b95548a550e67c8197c76346191c63e9423ad4a53d33584563bfcc19b93b2d396ee1dda990d7ec4ab40c76961d2343259d41bee2ad8695e4fe485ee206afba0f2b794941da5c662169564fbbbe383f22dc593bf64b2c91ff147743f8c2448e6b9b1873a097dde69242c2f82f21cb898068f27bef429646b7ad57773fb798a18056cd050077f1731f6cc37937a1f9b76d467a50253c00f41643085f7bc45f7255e1f8ec5121bb760ac6d32bbc3a33e3fd445008b8377fbee03e9e9789e47d3fdc9ed1514c5eb6da004ecb1126dda64b42f58430b4153057afd70e507f984039715e8df2b2feb631cadbb70735fe15a34c331a9af4f47898d7a4ee47affb226a3b2202632c8faa10beb914a164806ecced395f21ec50600ca4473f84b01f6614456de091662470189823b1807a1c9305eac776b2c5ee922713c78004e01c3fe8d16e84ddbc8e643e28d38a2fb224f06222cd70fe8ebc7f25c148d319344e624d8eac319c060905c9dc02272f5de59642f94c590cf1f446ef5750827ca2080a4c1eaebe98223a205804d3662e75830dc6001085f2874a0b8ce1d26e4787f314e4a55c4fe87d4236290a3f62f88e510c2e06a2d321b27ec220649340055e47d3bc90a75bbcde1b99e154c89289c2cb7ef7d97aaecee72bb43be403102eeb3ea450daaec2814e94b929ada139d145c6ec55da24425ebcbff9c48c1a5c2c45c2dfea61cfb921a178bc8301aba3e275a1f80853c8e4b369b40bf9316d6b4182d392b34331fa469dd1b372ce3b0c22b1c022b8237e947cb1d84834d019d5a038f41035e4b4fb13f007c64e1beea820141247b45fa0b74e2f65403ba46c8f992fbb46768cb57944d05bbe8f175bd8f3188fb661631dfb63f8871f2b08a501187fdde26c0cff8af44f92a0057dfd3c709de7edd7aca1a71dba2f7dfccc3c66ddab169678b6abd82dceaed10eceddc7f54475463e26675b18c463eb98f18600532cf01ed06c67002b460cf753275409611b3ec2f9028c3ef772bddb7f61f5ff210715fff53c702470c185097de19346498ef3daa93e480875b2dca7a2b9c333259d1e775f50eba1f23fa30102b0fd49a96696439f47a36ad84d52a196dfd5b630d8e7182b2ed044bfe0a1fac8e1565005a10172ef993541de08825fce2f20ab75a5c16f57e5410aa3c0976fba614ed9b583424df51a93a26fd5ac83dcc2f940881824b99c82e8259ff5cc38ac6f51134c179d0b573f2fad678e042a59c64b214afd9994a70e8b4c56428df4a8951b4eedc76895f09b6732fd6fa9dbeb555979e6e79c0e23354452a6649fede26248fb622e6a8b26d4447234323e319c6291dff57236cc38899a18ff013c13b26bfb61ea6698827402ceb802f215a3e1accfcaaeb21ef9f5929e619a74f166f9159a12d780274107340bd651c896d3160b8be504af6282e03f7504dec5a4c75cc6360095db7aeb571df18bbacc61fbf29376958e2c894960b7a0929d3c68348d7016ce9ff9851e03eb44be47ae9637e01ebef94fb96c4d1ea87dac07dbff539a2472354186895b299d478eeeac6d925d6f976494253bcaaa47f674bcb262fa1d9d8ba5344d05c62136094f2a01bf9f19442c36ebda7441bae964a01a4f8ce22cf5f49e3d89395f66e257090748d064a17559be83dcd4f1fbe20a65672a7734cd1a0bc93f8c4dcc5ac9476e3c2577967206c373da7c4fab24f94feade582b82153356376e8aaf1e8ec80ffc0d532a279465a03edb1cb4c0051b0e7920307f2ce309321256e6db17add7f47566f623ef3533394101867f5a5acb9d4ac4c1511a9223b67802d3f499514e71b8bbec6e2cdd4f448446f253916e20c4921e12dd093c736266c4c9a976af43991220170fbce563d259f804100e16faeae455e6e4d4ff8dd0d72f73d80ed5e09a09c558b97c2fe31a92e523fc902fe5a2368a3fa24d4b1aced74baffb0bc95f2855f091d1990668f62a71df3d6f952ad7823cd3de8836aed4ee03c75b1f4bec3b6fcd72f1b7c2c1b70db9834b0c3f4e8f077202eb7cb299002f8de900ae0336336258846b47bb1728c88fe4f1888b2add75e0c40b4100e112138832a6e20094239527f00227dbde906d321cbf12e66c8ef3e9806c3fca873b9ee923b62f16a6fb96e96186b7ee0c0a9f11ea0051076ff2122dc236f7526e8d581140b9bda3aa07a65af4180d5a04bfaebc38c0ccc6b7af4ad1b56a14870d44093403498973fccb0f57217e0645ad5427a05bb7c2ae00bcd8211986f2e8ad92013410343f2b38dff159487d908715111d6e682474422f9f8af427a67ac0677c6b1d826507f6f8a20c7000b86b29957b40e4ec434453d0ec6d1e29c19938d5496aa93216f3da72f515b1675afccc7befe7ecdec70d79e12bc7c5741424796014566304a001ea0b662031c0010201f31bd40e8b3f277927220bcb9ce81f0365b80796d18ec508cdd3f9f33dbb4086e57229a047b4bb3601c158c9c95b8de895e49b9a655044b7106047871bbb5b3f2032643c5bb1757cde9c0157e18d005350e625a1e20f9234c8383b2d09570834002394a7d0ea364df407732a5b294ecca7e24772a93f7768f382599af8e9e1f2bbfd7e4fc31eb1f87daf0e02aae3ee632d0ab1e28226df7f4a2f5828a6f74999ea38445305545dfaaf48a8a399ca8c50d9bcbafe7df946cb055dcbe637b3d33147d43524b3e06b6fe1948b8f3faf2f1fcd7ee9f184762cefde453d467086cafe838bd0e549da0e52fc29af29f17c0b3484ab70e5b8a111b74a110fd8301f86202f23bc977938b7cb55275552efcb6951bc2dc857f0a2ad833a87c89c108dbe1d27b08b0531090914d0153feda5556a93ef8217e93367526a5233c8994e32612738ccae5333bf1d51ffd4d52af10934efd6d738da7b2ee5f4f52dc9a19258330eab6170468354212bb671e6206c657475c373d9b708aed09dda9742a146490943206c43d4c5f74cfd1afd9455839b315c0b67ffaa3a32740e61a14291f0853a2b7df7af7b6d8cf724f9deb401117e5ca0eae7a1feab1726621a2cd8bdddef27597a3f59af529af58cca9d57e247ad87daf11b1faffbf55b72477e9cb17c53a0fe83663f76b95cfefb434df5322a91de0044e846b76b883f3838e0e62fb5a9531ecfd278af2da622902595807d76d1c0a7b2f3dc5b05263ce2e233a22630153c241205bc6f3146c9587f1353581290f403d960b5f909e5a1633f022b9ab6004b526512deb330bd124347c761b3b61a4789cf011274e0698908b26f4f71edaceee9f76b9b0587ccca6816656f296b7e4afa61333721b86c98ff404b589123387f2ee4f2b319c0d3ee0f371ad76453b6bc415dd8ca70924229a59f4a6c4195bac3d99f4aaf465dfa6462f6f0b2726b278eddd44605f557a8dc1d5bfe9cb11db1d481e2e966921c63ec9a6bf1c4b17794c69f644c7bf2a5dac2f7ef90fbf03165f30e8b440d5751c6ce452b85c332e81ab2a8468d05ae68847995bc6a2765e2d4586869de0177c151f8d642666c6ca45afbefc2b56251a2dccd886dfc00dcc244d9765e0895f10b839115f0565e6830f0ccebea75ea421ef58cbe0317f51e8f77c4c80b52229287859f3374880cbb18c69ab86e3dd784a5c32494f668bbf7395f22b46a89a90249b744715d1be589373fc9dffe1a0da6900f8d29eca0902325c645f4831dd8fda07399219effc599a8c4b2fa9f9f316b64cc2ff2afae759972b43b29b4ed917bf8c15713186739263893092153aa3adf5be6da60ea563a2679f6d2747461c037b48a5537ef2fa12883937a4efffbcc2d031e4cba7292f67604cc9fc7bd7f003594ff447badf30a4314f8f3c468dae7f13a488921ca9936284c55274afeadf884f43f5442d95e625664bac28c8affb7a836302d9141d786f076b498e6d56c9c7f4f76c8c4b209323831904e7c943f2edd600003cb289b596dfc635ecea4d82a986a838a6228ced093462ff63d4f966c7f0fecca9f761df678dc595dbed0dace84c56bf3d71266b9dd1db04d11c12ef43fc2bc468611b7eb7272d157b553fd9e2355d6c1564e57bbb4d4325966ee8077a389c629d2d0fa1376e9a4ddcaa911099817b9ba56c51f763bd32da59f922af41cda67608185b38fd9d84630f2bd84a3d56e6808822bfaddc1493a5e235022e41127655a31958333a10dad3127b0d2dbfbb3bbb4be1daf2667e1f682dd7f152ef804adcd9fa4c91e284fdad7bcd876f4c5a673514b5a118f5948eee24c9e845ef4cf0644159968a4a93fe2686adce5985af1644876751d74a8499d5e2cf4fed15e32e754bf7c4e25b84c759a3ce645a573c99290945e74da7ac9fe9aaebe8b5066dff0b01a6b50d8a239aa74c00ce69602af5943f8e262f6b522e99250d9bc091bd2020bcabd88791bc459cad55cc121c544f728c58d41bf9b165da36b2696ae04e7419274b60c683f36417e0b373db22bafd397784b4812c128f1efb429495854782bf35084032b9277f9f43df3b5db49d208800a5c09c39ff234e390593f3e7b7d59d49fe05a88f49f59827e4c32ab2d7cb67fbabe30d627b73943d913ec60aefed85dbf81c1e8395d198c44388d9b285d892e8d12f4c33fd3b0c3f5d9204f366f9146b9c4223c540226493273f50c153f055fde9d5d38502f88a05ca2b6926a0208624d291f1fe010130ca0fbc47d550215d92bb26f227f4f666d5f40488865a58336dd0f8e5ce3b75c41dc23a93053bfd9c8e71d04da9b6ded6386860048d49c16dfc47516def007ac0e675b4ae00af68248f9b8302f4a81d0300894ec387806e444190303ed6db3a61ebd8ad36bb33dff2379906115d3fd1c228183b85359167d76824c32fa6912a58c3efd96387d17e6670166614d07f80af78a6cac41f35e6a974aa69a6dd71187916192b3f08880671d0aeecc734d120476fa38001a3993faf49437097960b846cd880625a01725b242d17c594b4449adc3a22c7bd711bd5bdbffeced6e04c18e531cd578e7d5dd02d95a434192dfc0133fc4f2f7a5a72a1b5f72134945631d91a8c0a0b268459d10fc9c6a95e6e7b97b50b6c845639d94d235e78558dc909734ba07c9307dd5f5c4633b6665f356dd7a4b8d828dd1f9857eef2f27c01726c42e524ec2d616650e1d28e1c134d455d2da4083bf84299131195041f82fbfb23961a96bfd9758daa860abf0e235c87c04dbbd9fae9cb87318a088b91c9453c9d458c5572cdc909580e9bdaf8f3f16fa68e1ddda2ce2fcf7d56be6d2a6e6dc0177ad7d43a6a66233c94b146e135558c92e36e4ba00a6fb8a21f28f2f9d96c3497a0f2c53b0d4e21d2f5ee0941ef29b51cbbe15456af3e0627d89aee9d91c47334887a482226ce74d239b122018a82913d4a4986accd9394f550ec1bb9c58108ebc0b3b9fd6e0ee71031fecab1a3e443aaca7972592322162756a4e33ec09f6fff8354f76cd0de4dab884aa11612f446ee59b40f13e9ea92b442f4ef2a477763fd9af61370e65c3806fcd25e40a14abea1d85046367d9e52d89f573498764d398454358551d92b38642f09cb9ef84a8afa7494eb466c4a503b92c119dc851768003740aa8774f71878bb082d075ead11438dc605e1640fd8913d89b1361f54373a783305ce55d9cb32a68dfeba8471d2aa82730dac447f6ed0e6c96fd7a0d6933c8bdae8b6c35beef6464b6840fcdf522032781b9610129db3b74b83b0ab21e0dc00ebc4160744548edfa85b79a09ecdf055cb8f9ff2f1ef00191c353c43a116f60861415f20077d2dedbd488eaee3242bbf1e6957a517c6ecb8cef984796e8d90b50493a560855ccbd76c130c0764e10403f93c6da6c9995d01fa347eb9d29c038648be5f74156c7efdbff0dec8219693dc7d69decb84f21f854cf2c31e4c5c47d3d37f7b93fb31b45ab0117514828ff6519f8873a4cb890a1e22df7885503a3d90b5cbdbae2d76dc937da00b0bebbc992c93f8374e566e280e84fd62f1273e65ab77e74b38900f9ade82472fcf5f7c778be706de0f980a0dfe638144a754c931c50049b6f87880fabf945e4b8268fc42ccc379733c43dcab59e9a9eb06aabd59cd54909fc6469fd41c88567229cdcfa1366c355393744d50cd6556eecad0cd3e2baf4a4ac691e162fc7e47622a534f390b87b7de51ff37646e6a6c95681f3af61a41a9e669750167bfd99cf43e3e8d25cc45738a47ca1621ce9f274cd799de575573bb4b0c9ee9c9704e57583f9ae401bf2aaf9364d29c0b976bbd65ee52a199c2923536b93d52b6e3467af76527fb0ed8d92c3fb5fc3eccff1a65995115d152a4f077d762668d828d0ab5159a3eab23db5bc91ee16cd1c5a3e75819b93912a5e572fd8b9d1ef635ed09da42600301f924d238004d1198b3b5b2b43a9943de9ad47d1a00306e0305cd19ec550ceb8e059b5513d913881da43054b10eeb2e0c2d16fc162363e279157d8751abaf21791b2765a0425553e4aec9bec52efc93f25296a64dad2d5565773580fcfa62176694d2e14457db73df4acc284724a0ea7c655811bb84a4d19ce00b8ffb2112c7d8ddc84fa4f1e6800c112fb7d4b40a22cf5087e2291833a8d39141237c231ccb51dff808a3aa496fab14dd0653b0d4fccf90307f8adc52e5e3b3af2b78de0ed9365ef60e8de15e2d2f9d4881cd45a726cfde9f4a7487627d0fa18f29e878bdf76517b5ece095aa46a335f79f6e49fb0fa92884e683473e5a30b66e35311b5b94dffa38869beaa08d73e606f7b766146e3a74e4c0877504378368664cfa8ef4042020129268457a2d0579d098cb70d358c77ddb70b2d373a5343e4150ccd5f6ea05dc57305cb58ba5a68d2bf2ca7e0f55c9f3f99d2fb40f46aa14538507d9fdca9e3276ae495ce4e4069f64b5a7b24304a179f5cb53269b801155352ee0382e0c28119e0f4042fa0f4b634f126e6c7c20db2f347daab49e81c29b12df484cb0b07b49cb9b7b2b442e659f337706595798b72bd305f9906cb61931a4447ba811ec58077a159bae8f85567360e19606bf3ce2dc9a44b4cdcd3e55028d6c9ff5133319b88b6039c4afdf2eace4486c9b2533026edb4d8a040e1d06aa167d5252ff573d69d3700b731420ba43b3329a488626e28fff27d6c3c34c2374d1d042eda6dd77dcdbe98afa9301566587ed8e16d61c38a91d7ae1e6a5dadf4fc8a1a71600b3bc99647b6449e706db0b1d96b4b3abb1bd3b4de2ca3216fa521604f53a7d6587fc9abeaacd73ef94de6d9c402cdc92e0521b6ed446413cd1b2e7085821eeb428b6f10f32bc43ad7c662e07428510991586d7f803e6293ff3b1cb1629ec7b13d05ea44bb108f693ab4816e2fe52eef941af9e99416d3fde3a5344e4f990b3dd7e8783f535ab0f3ba954ae0dce5dc1a8f2c8b6283ab44a9db13b6c11dd4551656f967e044ba92935ad81d2f03ae1ffaf50a959f2751c336c2fdcbc33cf3da4104d9b7f13d62931c3b311c59b730e941529f926deaeeb93648180a7eee2d83cc4b9c25144e7c6567737732c8c401c90e1c05981ccb26d385685a164c30e44188416e6b4bb48105c4a748e7d6095039c67eee000c5e104f5890c44788455a985c2dc54168add3cd190e4476704dc920a04b942f77a31e1c8cd9d2f6bb9b8688c4aaa5056b7454fe76c04ce1d72d3b8f229231df68ab3711c0b371d7d990c3a5d7df860513a280e58345c072ab767eb7bc5416ba590747f0506e6428c791e92c2d27d6f640751f5010d64ba9674ccdc80f4d6f72d474bbe223731348c3d30392402fc2953aaf9bca7732b9cced8a0b5b5e6033a440fac8b0387d75e327abf669048e7440df51f957f70c72c8b7c500c55b4d442a2623971fab85a08f3a53d961883a86930e9bca7477ab916e40aebaaeff5c1801dbc0e94e3b30eb5c29dab36ba8f5a705f44ef07f1f6c95c7d5d439de6e28920f4e5fec80d2a3687bc6c363389a3494771cf556ddbca4eaf7ff401a086925de17304f85faa381ea49e35af0df64179c106d424ab609028729ac2eb199909d99b63f9b35b85705c3f16281b80323d13dbf6cdfd903524b5dd7b1dd3cfa3cf75f2bbe5705dac7e6d3e0e4b1c532ab0f5d31d9c47d1eeb14fc756ea833f7b3b0facb73fe1ebe0f912e419d837e868ae83dc2715c8061bc7aaedc3493aaea8bcb2ebed7d35ed1973f7f7130bbd673423c08af009874fe9785694b2e5bab338503db64dc1734ceaab836a61b07be429d38838b1ed56b70a1386bd8b45be3b3e2c7531d37b277f3ead66eef4a5395b7fd6745f03db68e6b35a3023c78e243459d42b7bad7323d7da8300e5e54ece8a37b2cbe416b7b8a5e9affcdca6ed55c91a789af5f2a3e58e6c250450f1421d718eef02ad0665081f8b830f8829516582aff774daed71120e84d895cda6fe02a85f7b7b0f0a808d18276580350755e2a2a4cbf6414f9382e1b0652db049155e808d51765e86c219b43c22c6de034cb7722208be7e5e4cd706ea063d2267859851923bd58b00dbe8b21947cb3ee4e92a04def6e0f1c364c08dd6a57c61aa4a6ce320c40719140d733a8722278ebe5d218972577b5c172594f92d82eb6bcff9c2994a554836cdea55ef65fbcfb9d227983e8ce91b8ecbe0b11c45efb25fa5b6905f58ed15e978c1e31b25bf3debfbd74635dc846e8961b07940b0360af68d2d3e0e8164693875c88a8394bba2318217280daef907628474db314879f3f8c9d8b50d2a17c9ca178c12b58e76e7b6fc0257ed2367c507c89908e40280a68deb4686af251dca2c24e403b7189e39d71ad4e1a5b2837ca498ca63db71cf02f027e326e4d6a97946e16d45172a75a1644d3d72b66338b0bf55fb98542595cb035819ca2819f10d41763d17f1933c10c14450d6523852570ffadf8c841e3554baacc96d50b70104b2ae4dc6cc5eccab31bc232d86bc0b4f90b869bb40f3577c4a86e16abe559b62abc1ba7a57d5cacd6cc102d34531242d15a20785187242b6d0768af34134302d511a2d7b2038bd7f0f64f9d5cd67cc292e3d80a31311f20b61bf090b5474260551d08b2d77fe4566fb07e1c337ec1fb8272551154e8d46a412adfeb2a1daf67b1cba9b7796d6110d0e9f79e52889b8abf5674c633b7e9e5ba7c2215e644704d211c0422b51e89f7be1fce5495701a73b454d5958fb55f0ffcc766a45dd03123de3d81e67262b8b53cf6b4e8bd82000fd137cd695b233c1c9a9de5336f8808c2a7891a855287625e6f8a49cdf9513bbdca99f668f11cb06dac5c0ea73bd2740c0bbeaeff66160a043a6d684044da5ee30577156ce6f5e5bbb5381297e7dec9d029877b159c26bd408b7640acc2287e86c6f144d69d1e93ab41f51c554267655062e1293cbdad0d257b4cdc795e2a32158674538c3286696ba496488e30c548ecf5683bdaee036e0dd7a01bff9dda4e77487e6c7fe872d3985aaa1934d1349bf360acaea9e332da2cf2212dbbe2fe5225ccd421b73596d36cc3d07202465c413a5a5bbd203794c525b9261295b9903447dfd0dd810bad9d033a025a08c1a56dc6b09f538127b729de0ec15e120a1dc32afbfc399a82003bdec234e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
