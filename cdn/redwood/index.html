<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eba714270440d93824fb2129df72706138d50d9c89c6189776b9e790c4dfd7bb4c491c0126ababe4ce5eab554ed23297f4e6c22a4f11555d770f97e134d7f84579aa346f8f50313d5f53c130e18b081677714b49c111677bb4ae81bda54092493f4846e1cb8031570f7fea0801f459be40f5fb84ee2fcc9e1628a92c22c1567710ac1f057050ae630f31d0c20727a14ae2d3ccb27c867887653ca3402e9287161c6b2d504fc76a610b1c939ddf8f906b00ed69b4a4fcfa3b02914743b13010a56c5b4260e3e6dc7d5f6c790b211ef2a8e7006af852b99069234b74e66759e9d7d5b6c1f843df27b0afe0105ff84cc1a587f8c754a7206eebc71329bfbea637003722524377277cc7e9f4d10d6650377e741734953355fa3fcf6f4e47bb9f7033d58845c327ec11ecf7085ddcb9036c3d19c96b9b16d361ebd6fb7ddb8f7422ad6fb0959d3b987919d08f7359b35673d2da93d5156fd1a0e240f97106a8d1b77adb8094442fce0cae6aed69e975a707c7c77cd0bb02e98538e8f8406e56710824d9ffb97af4d14525e84337fbdaea04d969b579ddb2c226c2ed80c57eb56d7c137cb03c4f18b07d6ed45e2fd696da1cafd094ab6c36ae5e8010ef6fc89ce7e35c472a36684859d37295abe92bc8b69ea6d84edc90822072e9d0e8d6f815c24846d87ebebd1de9759bd217e3fc15b260c1743355b8f365e3ff2ca002de3f3c75c00a88733c57ff8f64f202d84fbbf17ec09ea93925950a006771579dd0d96b53f7dcdcb86a16a82974b724512276ea8fd611a26ed0b271bf1fadefb27ca1480081e26cbb0e7299f56d4e4994149c090edb36304385fdd3e4a9fd0998f4f7ad13e92877e891b7d6c9e7b2640e94ed8058ba4b6ca6f8507e87859ed24554543c632992aa5f23b71a8f25c1907aaab033607793e9a5f6a1bcfbc8b8d717245fa352c9e3ae01f9050a6532b2fbaa6cdf587044a514e390aff793c456ea10b003962de089e16b1466d1e9ec83a2c81955cf3f9a08ae2459aed8f336649416e1ff70c92f5cdcf86e7d943f7b41c2f08c6e15fbfd5af3a7a1894f9588b7b1a8557360d708c1a7bf78600e4c9652f681b642b395af35a6bffc36dafc4c90afb8829fb5ee733fa1196cac8a2a1e05c42bad5e5402669a4689c7be943d9ff73faf68d7aaecc2e5864d4aa3ab249ded3b6f6a5bb3349417f75f506f8507664438475f7ba9fea130debeeaea7521b5bffc52b99736717b665243b76939f60f1463ee9eede2e714b00b1bd512d1dda39a9d9cf46bd9a285f0888f3c611a6625596eade9c7cfbf2e92b1b94dff0bc6f643911b051cf8f686d067d0babc918a9cc1e73ad20b1261f3ef4af2335737b4efc772fb1a88a16ef851ca142f14b09d085040d1360ce61d3e3041ff24e7bf0e1144483341b16bb631a4c94817efe062a5c785cecfa03cf806773e55eb242047a140f05c8055d79d34dcf66ebbf82b3019c0328835e7d821ce20f05b21baf33478418971eb57cee6ec3ebd95c8c9303dae59bbdf74b5e481fc68395e0f697e53b7bd65237bffcfae80e66981c21a546d3c0afd541b739fd33638d5ee8393ebe194dca2453a5cd30ec82c788aab42a5fafe34d3afca94ed971e90e7f13b4efd59eab7f8f285b43698a7437585523ed001455a8b762bcdbc6d9c2f14fc9281a1f66df167c37809e27f3e656e149f61e39c0d80cf98b1777327caf57aada0561605f2fccd5672afea105b1d0d6ce1d9e868300758aed0c41c7bed658b690b7d029d560f46154fa369220cb8a7f2d795cff799435b68e962fe8e3af9bc03de8533c471c3aff2f4b720f64084ec356d1065771512886ef4dd875e0a3d8b2c8fdbdc86f58fca2752fef50aad28ca669a8513e4cfdc3d2df543ea1ab6e2d52f88d4790d776bb28d0fe2fa777869d5af4a4fa290e57ebc9acf72b37ea5b275a1f6a6907a0e0b1406adb78dec1b62f7086e41036bcb92dadfb510c759e544ee3bffb0db1632e46d95d49d6b5136fb995906f38f300bc88099b2895422e2b1bd15eef828198a2101a18730f85029bb6e7f711f21436b9711c1ff4271a2781d6d32952f68a790c93995365f6c376c09a5aeceab60b232f6c6f84a0e66a15f44966c4349e5fcf9538f17df58e392e45efc6d1a8554b3daca6a6265614ed26bfd132ba5411c10d18cdbeaf20e15f6758d84643aed4d16a3a31da11eb64aaae522f9a03f76d8c92b377e0daddc6cd3d2e9e6bdbebac90b79046944d475395714c7825949237a081c438cbfbd19b4e4cc9fbd9a64b70f4759006c1295a65ea271f9f5a98949be0c38584a41816d79bc266112cb6b5ad6bdf97cf6a09f1f6e6c444edc8bd43c0e28f4c647ef4197e7771afebf40c43dbde49143bf86ec81de6e0aaa71f4b99f5f60ca86601ab8ce10a874bea566f0041daac491c70ec59bccccb2c6a87dfce2c565bf7d7792c2d756d5a6ab08646840e7b925a154e94fa2ac3960e173d2ca5ea86ba26d99aad3188457e3fc3c3bcd8735e78d02632535c677552f1102fd49fa3c104474a49325b5dc034e499b9be0cf8ade65315216dc8b34a0ff7b9a50438dac09fed46a88af32383cd65e50c34c8ec3d5414cc0f64d206f92cbaff2c7514949d4971624039cc75e39035bb75205fc235cee16037378af9a6a33394beea929a1a6cea7131a489662208f57cc8f55a8edc4df58ffdf9cca07973bb223a6ed227f8bae32951623c654f605315028aaa40f2bf755f89668277b41abbfce5cccbf9d79d4ada77f53258b6fb7376b701f3a2b2be238e59201bb0f64bdbccca4fd7b8f8cce65beafbd1204cb90c70ac23d02a7dbb03d98d343484549766edface9daae530da01a87b5ddb1763c3b5fa4226888087335d2b45a9e7e7cf4b27e173133d189752aa59b5ea290aa6b3a0ab600c38138b5187252de036bf2f3c54b6d2a9ba610f33a3af9e21de7dc73a9c6d0a2de0af35b6e53f56cccdb95776c3f8af6bfd9a81b2ac2d152857ff141566db2b6840847d9b3806c173df9a0e1c0976dad3bb33a853f9b2397862ac2385cd205510f51461a89f99af257c06a1d3d5f04e14847c35a6e16c848e51dc1ff369de6843bfffa6fff9e549837ab799d2995d640e9297a512274aee0cb2d3b0615ff5196ab10f6194cbdf29885ba0f36dc12c4e4abfc6d7f1656481faab069f2e22b1f9d74a8786204db163a748687f12fd708cff64b817e59d6213caa0a638658634a12d96ad36cca5243d19cc9963456ce6b2539ecb51792bed11df32ae346d4f5080b5284640505bc853696cdcc9e14db3631dfda2ccc574b0ca614f87dd006e6a8e3ea4b24e215416ef2090595e012cdf9e4bca917cae5aefa372fd33f1d1647c136e6cf190c57e621e8af18b8b9294f85de821fdfb407f8a98f843ea79e4af8aa0d5c7eeaf6ac53004bddd8de3f684053d7df65544b35fc81d9bb0662f1db50e860fafe2d3bf3bf7e653e2488fe0a68fa296dcc386bf2376dd6d5ecdd3911506308bbec62701cac1ffef6a760863ceec8be5df77bdb2d340dc676b9a8d74c291a04b3e3c58412f8563d5e30976fd1d82628c4c9d3f2803ed9db7d95b40bd4aef47b9de6878a1acd59f7386bec9631606c3b8007351651bf70e15bf541b559af2a72cbe84fdb7f7db743db6190ae35558dded3bb65376c7710add0b5b69037c974484f9ca91de7400d4d30105a1b98b0ddf81caf6c0247dd6bf7ba4d9a4827ee503f53ba327a86877cb07b3da29d0f0ee7a31d93c435f72a4f25e032d6c0778b70456d497f1fa9e1667489aa400991a12a19fda57652044f2ef8a6e6d9a92bee0a02000bc4e3ba3b095078f0d7bb71f1e5e31cae292b7f7043d5d2f92dceb9ce4b37ae61cdf00f615677cb05c2e25db238ec1055aedd38da7b5484750d7eaa90c31223d0b4a3c543bc190bf17cb96f8b1221ba67d22936bd89c453e4f9258925d6f58ea5a44c8d502a940ce4d2bee4577ebfc9585350687116dee2a23753b7d343a31d62613861bfe7b5bca31c03733073d7bb6480bc1c321ec1f6d4363b4dc1c687e395fd7d542ec5b29fb14dc1f8ce8a888f289bd201e53a4e616ef53b3186fca87cca4d5305658e286aea7a00a0d22d5647a00b3ee85c107ea044cb87eec77bd1533c11ec6e1b218d09c5d07e9fade334dd2015ace87aa40f272cb155d95333401b3a8455e5f5da9bffe65a402aa994de5205c0a164e494614b6696b174c762fb86860132099a91ee6f08ba05c5c8850e93a74845a6d07392fb36948741988fc42f3d940bef8a9b92713036f87b15a815dcaed323e9fa4a06f2959d2297203866dda882c06f4bb684e80853e498a592627dafda8bb808abe939f2bac75190bd3318783b500f6d8d774759440a74a809f327266e8192e90d6d56464c5679cf3ac0f1bdba482fd4d2d813543b563b8c00dd99b04c0487a883c0c8d8d37ed5bf2ecf35217dbcddeb07003d5d86830433277fefb0f5bc9662d7371cf34e36d6b91c0cf604501034b5823868a565737a3f507d2e3140435d778f0510902e177ba03cc11fb9701cdb2207d80bae877c72ae273eea615b86fe94222c7dbaf5a6577f22a5c5b3a582f3d16231fd78bbf8a4b62b066c3077aec999c8a052ae486cd2a7ad2ee56144a7b066df6bd0b69b3848e2fd0058990eae7d2fd77fcd13e0c3c1a865334e9c32467d135fbe6c282f71b17440f542bd33e4534d37351ff303c087e5ef0a7f5d1f30598cd6d82dd5f59ef192c5263420a2505e162fce0979b2f47f02495000fb7499d5c931d1ff173034e00af63abf9879dc9ba9f54d3a5bd97d8291496940df8edb2c3387ae9f5b68c0cf68c7be772a9c703329024d16116973b42a193e2ef0e8caf263d251cce099b45a8406dac0322977821723416f53b231a1aff98c84a624a91f035226d88bb3ccd91c73cb911fa4596018ffda796ab20eef4f0e6b8cd79668387425e1dd90713d01a8036ce2140af5e228c6f98376aeb684c86ad82f5f9a3848e4a7bbeb7755d5521ba0131ad84a86cf8c36af6398c97884c85f0e0b5ead545484d3517281863cbc1d1fd770d0cfb7055f4a4bc8d432428e3e3dd365834509b04155bc0248b98903824fffd3428179bee5ee525456fe58a75d2545249e18bbd4a168f330001c92ef1f10cedebb735b63f7e72680bf3ac3196d89da7fcc73e319f2f224fedddef6ac5f7156abcaa797b22855e991533b4ce69464806a0c3ebbd19ebaf61ca3316e57e9c875e60f6b213837626f31c58ae2884e52d446f1e3592e709d579338f935f14135d7b06a59dcedab8e5d6ea1b03f8f9934dfccb9022e85411b7d8c874b25b8698a0663fa3d8caa8b832ad4e10869fd39daaaf4ec3e573cd2907f736468aad361fe5f9f9fc8cb3030d34ccc5313474b1be76e671a2cc8498c9931541268777cd0acfeee2a05ac55334e58a181545551fba7a5757be0ef974201231cb70c5de7faf4820fb821c4a49ab67e0e5a37f58e5ff681cd260c70890d44caed70d3bc8a243cbfc4915c62362f1da32daf9ecf42d7fd1d4ada036f56dfa73b46a06fdcb9e9ebdde3c78dd604e742fb6d641a28eaad3e93639945c349b329910c7bdbe752cd56b9cca4cbf73d1fec2085f1ded034fa05ae205febe7d8294ec6b950797cb2785b601217895b51ff36062f20f46e56147caa23fb7a1c9b70159427de302689a3e2f398f6150ab9df7bac763373c21a98511b11d421139977663a58c4f9867f772c45c9335a84c77ef6ca5da8657401b73e4ddf344d544654a49fe58ad8d185e598e87c46b26dd0d5c733aaf1dbc1c7b9a2e9f6de86152e9d237a0bc91fd415bbc947b2acba7e8a4b6f5235bd1d4b8227cc0960ee626ec7c4293de61fd5f1bcd5616bb1076e3b87274ecca578cc12de2f56237d89c5789521cec9f64d73d423d29d6b3411a3e9211f9f68e51ac7f962d9d3e6a8e87e9af57c548a4ee8aca32bcdb1a255ba39c698f99f0faa492eb7d053cb1821a6fe6e28d29a8a4ced8759f1c674c6984b321a4dd51ef93b1cc2414e5fe98d2826dc565bf9de05b12417d43f1720f8745c4153cfccad5d2030e82bae6dcb76aca69a2306b192905f320eb87366860af318d77165f40d9c8316d8b00a9530eba2ded111cb1c76b3104db472cbec5c3973964f8b4a5473d72f6eead1a1b9e2ff3bcbe2d90578e738f05ec4d432af2b304618c9db0aac0d5b849ffb1f2f7ad6cb3645626711943a981c22b9e5a1ddcfe26720de1c70139c44b2ebf786fb930360ab4d367f9ca5bd05c8ffaa043321f713af2fa9d449b29fb3d10f71f9dd6c243ccdc6f0641625e28b93108fce17ee8d12cfca0d0d3fe8c6cb415b26efaef131c4be415e0012fc739fb4596383027e6cb77ffba6aa3a2654c0afa661df36f46463aff5a5d03ba401c203015183944b5655e1cb14e315ac08105dfad43e3716ce02a862adba7935ab7bbfa4099707ff21fa3846617b16c98d11277aee8d2eb335bb6c0522c7c780fcc9b0ba50c3a7604fd7fc969c931bdb8b3dc7108e5f378245c11578a0d75e2124c2b544d3d14c768d2387b7cf2b5408bab32a82d66d95000e690ed1c10600fe0187b2be81c0ef6d9f874ae4788ec580cb1e7d7fb5a9481a277819d8d4129c75daa4bf00f63830b1b6ea698754ec6dfb5598b39b64bf14cc15e0e597fc4b32f8db5a20a82c3d3dd50193d386c5535a50895f7c1d5983c5395e9d3481ca141e8409c970b99b985cbdb95934b963ad32216e66af5d07cb062b7e2061dd78bab31bae9937a3a534f1ba89642ad2fa4518d8f47d9dbb84ee78bb78115f3123596574c985ec36287ad12cb69665831793e0d6ee93622a8032f99cb1c28545e21ec1be97793c47e85c3275887dda315d34812dbc5532fc4f69b602767a9f3548f19c1f2ef4295f4ecd98c997fbb2f08e1f976e2012ada2106b1adaba03caffb4d3301fa2f338f16f3cda7724e3fa59f649053792db6e0fc802ffd7fafb2ce07c990a2d9a91fd8d722d773f3904bac7f6b8aa33376297bb59aa2be1e3074cf48d4414ab0fcb059e40d4b2c9b4a3671e78446559ab28d713ac353be71690f4219d3433dab4805b854ad2633ea6a6dacdf24ab9463ec6c1f49af93c02218888520a462e1f73d4f966eaa6637fc160376b9e7d54ed7b6149f1b0c740bd8c1615f274ad76e036368e048c932dccf36c3c42a794bc95c247c543f55a7d4a6091ea17452d36b0765d38b023b28e27c49b7434ab53e66424dca349b44afb2ac951a6832d8e83df5883bfbc6eb17f35b933abf5fe82a3a5855c610d2721cc14290860b8b446c1298a89e88c40c97db74a94d81737f0c033ad4768d99e0715843db9222afa644ded028a4edff9232250f20f055a7750ecd77464347968ca4220dad31fdb2f1f32c0e652698b7bc534d5cc8699a1dfdeaebf2f5081032f6e3b69d5cf99041fdf146aa01fa427511c0a616808016646bb8d13d225b93bad9c163b74b252360d2c67e1a87c0972bb8006f5add7d0bef18f53e83ef331923a71792b8786f85167da02e32656e2e938b78b3c6b2f19b6792642293a7ac86888aff4fcaa8dbacd133a6096b6512126a777b1e2ec2dde824ec05bea050c5598cf3e59e6099413e7ba5b4897433173dc2d23019836f7ae263ec0377233bff67bcffdb7970d5651ebf0c1ae5f77756245bafd9cafbb78d3b8a3f42fe79460551acb28db7da55ad496388195a666e49df490c38440a1db4d652185323fe3b56f651e05ddaa57783c00f5abd2553ccfcd7b39a00ae4221b519ce49fe9b22e5c11ffa65efef1c4791c847cf7811cddddf12740a2304c5709efa32775a1b26c7695c1a40bf9489eb9e720fb6cd7dc3af3e0daf100fb248086fa964c6a0c2878938fadc24724cf3c9c839283aa32891dacfbb69eb10a78e7789d09cf7d6094f22eddd0f09425695d9c4c72ff9bd6709173536950a18de50bce223ed20a953fa1a66f3a3ac05cd9ea707cbaf9e96677d3bad0377474b8f4f0d774b4b3ffc36e77a97c077d5c195aa201b7c245b609d2c78eea7de04e5a0056e675094370b98646a4a6d5515d90494d3c70f015cb862ed8affc1bbecd6092859080e2f59a9e327de080fd320e9ed83f7984cf4e1e1faba9eaf543162d5d80d8567ce2497e0e7853abda57108444867e623a944cf0c3d18e551f41ece9191e3c92048dccab417517a93bb8a786f2e8b5867cacf1f17cfa02d6e238c37912aa99f2547983219c51795122fd43137f23d1c55dcd3c728298a3c4db151c46565910f8926e69cf290a4cec01ac6a3fc88f4689c470fbe0b84bc22b70e62e50b506285f2f297062745e8ecbe9fc039dcf8e25c1e31a1e9168f42118e35c0164dce5d73188f1d87c7cc0e225cb0d3eb3cd82f1f5d24069dbca2dcfedd44c6da784148bad2e47f6c8385dfd6d793221ab3c156f650d55688891b51a8c96525aeaa496d4ba281918a4cb32af9dc671c8306cc5d27730bbfea745c769fa666711d3899447a18fa820ceeb792558d4751cf9c13331c6aff9996b14e6f6bed8409c165bcd37aad5667863f3f67a3ef106872d7e9e6fcc58db6abdaa7fd45d9de0798065a3ea29197abd6d758b184fce6787775b9e0ef360deb06fc3b4e60b49310fcbbc5c84277d8e1d9d3aba0b151bbe68d2e17e28c25cea9a0e403aacee85964dcefd6d8c9f25e897e2f684bfbf0e7d31284b2ce54674a3bc9de54a2ee83342c268314980c7f6b97a26e306b70a3aa78b639c41e3e2f442550bd9626c316d6c622176179d717a8241bd629e7e45ad67d2bc875447d0e22766e58de2ccb79650d6673d2afa006191c86deff075f5ed7a4953a8ed7498cc3b1ef8844407a22d96f1598ac668ba4f9cee29509487727466c61712cfa2adb7b65afdf150ba3fac6ae42ed50e6e732075e7aeb2aa3071ca46b389aaf5d3fcc07ebca8c462bc2b79fab418cb87775a620e32ce19340748004daa0c9ebcf3cb1b1a63e008b5e168c1e5b2825626404df2f9a230a1e5faaa324610334b68b7883c5ba838c75dd73224074f7a8f8efcbbbeeb10f0b390f10e9cbd319de99f1401750822bfd3332542447d0a92cd310cd541626cc5ffdce62f01eed9bdea405ce3c85033c82b4c474b8701907d72f01b400da366317cdf4131d78c61768abb94d62c9625b43b66f151ee510b349b33dc38ae640ccc16792f38bb32b73fc2306fd33deec7e38391da1b098423e5a6856ae029c78b082a44c8fc4f2f18fff3874c79b250844201535282e7ce17408e384f32701486f7528f326cb162935276d647a90ffb44aa132bcfb6638e1491a7815f05b6ad4013ceba6791732b38222d9f0772b0efd17e31a56a83862d9a3dd8817be92ae93d04991162f87d123f77a09a3f00d543188156b2e0f7617d6a25619dff9032f2e1d54265e8f29d425d1c6dff30a2c11559b150ebb1ec39ac384fd506b0d7d869ede304da4c31e72f27fdb86dc3d4f91676e9cbedb381dd804adb5355de6aecf331a30f93e7f45fc45687f18438a8c91b2b0a40818bf2ab92e4846f4cae1d4ffc07d88972c865845658845caa0e226ebcf6805037084ae54a3e61fd36368f91c9b411477e9b77cff8d8a373014d2cce2a647c7b0cce0fef9d29025229764a0b4260bc9841b8652372abe0e72e0bf2c4d8e2727bd28c3242c4e6a8c31642750a2e56173515f50ec9450604fd0290903a6536e20ffefd60adb057b8a13cc87deaced53a11c85e4032253fafd5dee9ac3c67f79507d90bac7bea13e817d983adcebb361a935cc03c87c385feaf57fc833fce1900fbf2dc2306570a773f04c5f934b973f208ed95f26d27c8f2cb3579359c6acc7d6eded27b6dde963d07eff56ce0e164efc3ff26f04463bda7e20febd2cb8b161857af7088e90dddfa7cee7f763dfc1872aa008eac3e64800d25e6e77ea62b58be1f6bdbc1c39ecf01bdf00022ad8c0120c10e77d19faca774a2b2c5193af2c48d7cb14cbbc67f00bb13bbfb45a61c1b6431291ba7644975b2f72ad2c5175a4984558388dece5ef188f70b90d8f459d9af940b0c70a3b45cc6e3fdbe6dced9515514d3eeca2907b9dfd9ec200c7d0f7eeb48e5c6811f40784ad000b171f3c33bbdc4082acc47e293c46c3910a42cf8bc286b738d4c4e20d2ef4a883f8b673a61e717cae16e59f60363d0da51ba76db0c017938806ef77392ce62e30b3d39bee206a3cff04608fbe9bb8f892126c7af8b414c7925278b18e86ed1500dab25f147e75843693b315f72a8d490040add12e79eb90dce48b92bc64cc28bfec4a769ee6400b36dd84d226c9ed0a6c39744332847efd80130759273e16250a9d717ecc378b3e384e14b35541bd1c3434197af1c0c9cf0c8f3d3dbdc44f9114d413d73e234730ef8c1ea8e467b5227f0589b44f7bee9d35e68672448f58b0f1b8557a46f9bb7993dc1ddaa0745b786a69cc2b446f4ddf7f1a0d2af48d565c50aa11d0eb185fb1ba5ed759246196d365cbe6f46551d0ac77781e6927ddbdde50bcd5ef2124b7191e41fd3ab2b0fda5de8003c9ffa107f00c29a09e1a2011c0f5fe8ec5d49d344926c13a5dbdf3317f47981297a54f17c21ddf4cbc4ff67e4b3ed9a53e18835335d55f42f5c504faaca0879a3d9181d31448152059f720ad2f55150861e173c8756ca74c55b0c1facdf3f115d6eb6e7bf7d9cde999c10ba799e1b7af09d3eb4a2bfaa05926218738ce77fded554189ff82451b2e49061d31bc2265dd273fd2e333652b89ef9343ee2d0243329486c49c0b43b63222aade3232ceec4be2d385985104fcd29fd3e38269299d3781f0daaa366ad6d368092bccfd57ced8e1b0ef70f36e00be8eb26c70b149867de277cff5bdb1fd3a43f04007ce534bd4cf91d2e9dfb029a8e817422577f9cfac0a85360e94af72dcf3a173ca3b5f414fb233238f8e51686b70d2fc25957dfefa1ba9c016f18ad2953d151a44f7d09d75c83c3be90c921f698e478e10f7092cfe7dbea1da23ff6c181cd54227dab60594e5fa7ecb8616dc64742aaea701ab16148c970c850960d7306bad9f677686d7ed58702b9c4ca3151561629b9ac46560435693289642c13cf10f5b2e0c9b0d1330cc47490e180de4465c3ff9abd5ff550d52329ddda00f00b853745b017635b4cb1b27e7d079f87c62524fce7acb1d1352e8d7e5fdb4a5859766e2b87bd1174dafd82c7ce7c60690d1fc8d6cb6ab7feff88570fcd757b272f052499b2e15208dc4e0bc12fec877f2276abd7013a9c4154f1fb9da5fee7ace1818cea65ac63afeb12912c5437604ba491a58649c7fb9043d6efb1cba597eb3ed5a36da296a50d5951286052dc85b399dd4e383f5b43f97219258d8c2d95c8c7bbcaacf419d9fbdccb3cb699a1c99d17a6935903d29e30aacf4dc7ca12c299ca21597829b78528b1000ab76965ead5b3797b0e31cf49a3ebccb696725fcd0e5fd399da1c1cae073f85e0ea561f9619012c41db58a053dc20df176419f2257fb1c7faeadccad3b2026d4d40636f97b450b686710d273bae1badb87b8f45ef7b7454d9067dd5bcdb1f67e1d1cebafd933b401a5e3f4e88387f9754aeaa99230776561a7e6ba68f780a4c8053504935d3e9d88edca10dd0e6cc06a234c4425c55636c57cd44245bf90c3bba0dc73313db3533fe3ecf0668ce1e7d65ad1768ddc00dd096222c1dd1add3eab32d1e1d2e95815d469a77e92b9ae1515da1162ee09c7706496df4cee885b8908f44cae218b869f839e8af9989a957a59695650f643856f30bc1f5ff03ee1a33f3dfdb564618c89ce654c90e58bb5db6f2c6cf1f2da30b80454c209aec73f107696c884da77b94baaf3f72bed55eb2a1909924fbb2188b51a4a2a1d1c13e970652e9277cdd4c24d8c62f058c58a9ee8d4b28ca4d72fc5eb0e3eda8d78a5447698a4fff0314822f35a50301fb6d7741dc1773c0114124c404de8a0d29a8318c1f8fd86b4ae87b6f1cc3b11d642a3afb80103de156c67fdb3b497942b2984ac446bc16eaf4fea70dd18a9f7e1b8a094047539af75104f3f253fcace60c7ebe89cc6d0e1fb774c30f705c37a5d3d431ae1120f9935d91845a91b542d6e3c59944d99fd6899f4731d96f47f6bdb1d1ba15bcd5646fc8d4eb717d8ec0645eb052178768c096a6e90d198c44bfbb633fa518fd0f7f1fc716a183569c708c4e2ad393d47ffda50cd230dc67362c644aa99d77b439b81c7cd51286c138f523e863a72f99863aeaf4f67e368459c259fa88015e2fad92052933f51c6a544c1b1a17b705dec8a01d9e74ba17ff57046d413d0b230b999f750907128520cb0047e2c4a89c3590366a16e5bc3d3a970901f063e71d71fb5d2b382d910f79784c1b720cb210224c094d844fa8b565bd715c170345f9661e48b1632c3472f2b0eb309c0dc0dfc590b0d16c2c3d49b293ccb4c576ef7dd80f459301cf938afcec822fd7b334c7d7d1d79105323082a19694ecad96cf829c71a310acc8a6b2883bc2fb5af900fd9be0702a2a85be9bed2d8fa31b8723c02754dea8f1a8e175fa78c7de7d44478c5449110dc2cea81561fd1d0f7ce5d7594508356730024c7c00cacb48c6e0754b8107087b27697f0166e1ff0e2ddac6de0b482fe5d4c391c27a1ac62cea1ba39209d45893f910f47e8ff798d45fed9f748b7eb896d0aaa1844c420e0b215a5c23eafc6c2a4cc9c3d7ae3de49f01715dd9d60ee143591e387083119353bfd6a7c5ca469a99636244dba7c85733cacbac9efe9c4bfcb05adf91a939e178291be93d921bddc18c70663044fd538c06e45c7311735ec1ae0be7ed509df8e88d44bea99f9bcf0f4a2f518b0d9d8bf28132708977febbee82585a4737fcd0b764b61763c2c13ffb130ec1c9613a87b077b9360b5b6434ac1ea188d5dd9f20e99c12103eb45b2ba775f4d759e405b02276733804a0a4d10677ad338334113194f9764b3ec93ec025accd1eccfe442727bd26c49cc2662e958ce82775d066e40ae34e9896932606667088f093e957048718b4dbefc57a2ce3077569a0bbc315ebff6d773a124fde4a9ed9259c89efba0da0573d745891d7935266543deb1d32414b7034f56822f5f52e6ac69edb437167f672740581ab804a64da4d66584f49cae1aed707416e3049bff1597cfdaf36d9f3a59c009739bea6445d45944e58de696031ff9e684f2f8e608f525b592cc82f972651b248babac1b428b1172d89e65c180340fed40c3ecf5544eeaa5f4f5ce236573a916680ef1d05a1bca706eeb4cefe444815520a1813345f410c5a0c840bbbab123d0df7df216841030e825099480dd3c090a1634fde8b1ff0e0820acb482f8ce77a01975363b73d90c547a1f39787cd3f9b1128dfc1ae31d5c48cfb4f550f89664d3c0eaf2d97c0058c44029e4e119e2aa92b3d13932fd85bf1dc50914395f94066a9a2a024ebf6f0e3973bf8460efb56973ce28037fa2350d90c7b4dfa3a8e0c93430df7935eae7552907d79e310115d8e743be7b9b9f0668bba93b1ffb47fe59f7fe0a67148b7d9b378865141df2401d92fda63fa9a5a0e267d0c19738fa070fb13163194365e7e2db92897cdd4b3120af7290175aefb689389c8b585d88c6f51e792a37f18054a77777b20782919fb629fbc113489104b8e0d6b41d9b18c39401602fa995c9753db2a8f03a3f5f72eec863a2c4d53113ac3e9af7699b0fbac09951d92f3f84eef32a8ef1b66c54aedb084dba2de36a60fef4c4b33883c30bc510f4b5d9dbbb3ca8313bc92f1982eecb3b6967cc2be7ccb1d1aaad3b2f26b583684c3942dc066e845387aa0cda0831a44e9b3207c9b69ef38aa159cd4ab7516bdccb5562e379483477ae3dc3b5050a7eb3de9493b45cd39d7184cc7b143659368b97db5bc14df0c612d12926949dfba37e8df09d9149c790a640ea7d08bb03596b31f73077bf40eae888260b121c2c1fa96e7014c37e77f4a78efd7314bb3b6769d0bf276483046685f317dec92097e73764bfdd30fffe14d0d10db254057f09f578be63139c333510ed163774dd4a769076c922745dc1f356110cf6307595972da54d5683aadff7e2859c4d7ac096861f3ed5bc3029b7dd87735814120f3df864fdfb0b9fea1e946a5ca4e9b7c3f27b6a82cca0ea9204fdb47f2450c25ca69af365ae9bd67b0a81b68d52a86ab67145aadf546b1478a223b21563a223f248bc8a9da9c153fb3745c0474e8b81c50b00c4a24162179af285184cf42e157cb827353d5fd75dadb49154985c08466113e48e50e6b56fc01006a1db7514a697826ab4507a2cd04561448de2aad66a31d4a239aab98392c32230331d9d40a00af002d1fa91137830c97d9ab1215e5566cae16fc84ba8252312f8ce2464f2a60976b1a0641c5df76d68ed2f7fa7c307606741076ad09c2a36b31b89607c0d95d407bafe81b02cc010e4b75fa4673a7d60025053f193cb4b117a1724514d85cfbed22416ff2b71745874711182c94a0b4f285694f234faa7a279e8680ffa8c8489e1de544c75db23af46a0b42e8827aa4d56e01c9597ab4dfad8102800f3d7a319c6e8e040c67243cc17d0d2918b6de5993ec2cec1288d5ad8ed6076c23dbfea5a5edc46911dd41fcfec0a3359e917969c5f674970c3eebf1c8ff3fc2aec8be6321042ef9825f3d47f3e1943f3c0fb3135ddc97f7fa22c9a38849d58a5b80592758087a730e6823a624e8eb35c08d028b47c7170b02ba046073aab2d64bb0d59e3d1c15df9330b7fa7a1c6fabb93a1f42008338f5e4a8c9c83995233ba33df8e501b0e66bbf60fbaea87cb7611e8db32e4b3f9c09fe12da39bfb444d8c7dcc96ebd8aa0f9d52843efc646186ff5c153181a8ee17df685acde8767068bd33c34dec6399d5395084a45528d17f3567d9d0f9f879683ef64441b37151a409bbc8813bc85e0e85e94390c7d1b5ef5521b724429ec6f05d7a5732578291b22a1b562e23a9c6074703b49818d66753b523546fb0106c40bf4440a35c38c19ea2b6eeb28b73020a9a2e1c97ec7521ed8519ac9f7c5e4960f2ddad578921f223f65b5d690d3d56c33316f2c9c5514adf89d5b7a3ee6c66d96f97f675776510f7e36f24136c477889b4432c0257e71edab19f4d1aed306e3b2b964a4637d1affa0ddb880e39ea9fe299bc153d1d01ab4a3e46e64edabb37362b3947a2f3911e2cac2d77e5e052ad544d82cd16f11720379c970b6b2f9ee588b41eaceb0b3eaeeb0e86e0bde2fb798a22a11df9016c04f540f02c5e56ba3223b931cfd901d03a2044ae8f654a84f2fa2d2d8950e4df93405f2f9a8413e683bb99c6ff0bd72bf7c754d7b2c1f29be7ab29e7a4a015430379a50221e04e2eb4b3783cb94bed5f3a4e8943954850de92b259cd8a36c2c1117e2f311681b02122a37ef22ed8c0c154e8dcae173165799258a10dad3721d7469bfc8d224268d92e2dfc4c6c72a916ca08017ff900d8abf86875085a8fd106792dcfbf8aee4afc718f0e5058554648f6d6607bfeba77eddd59c2a8e3f4903652c3e3d0f0503557a892439305ea9b334369005bbd86dbcd9f353cafcae6ec12a01cd41d84ea4c8cefd3aa7a83b5d499934960daa22e77e2d0ad608562b00a0b9837fc810d34abd06675fcf5cc4f1688d43a0f44b8964e53e44108a802d151e1da358e7c91f09560bf9b37be2771861b372e17916b5f90f403c0140fe91a7f303be2324543bdacc197d7ed8b0c998459a7847084a2a803790e1e7026c1e9ac4e792a9c0181a58d5cc588c8fb76aa8b5ffb3ecfc1687baf4854b3043a68dcd3ee0c6d7f41a2bcf279a756bc09dfb10241c055e0e1cfd3ff3cc3375e15ee096cbbeba383d29bd2af400543b17d4822d7a98ddf3ad264940fe4c5f508c1be6638c7574df589b19f748b8b2b542cfa4f48a488b05f1130c2e8c8b04baab86c7f7de90d029ae9f3d74b57f2ac32907b0e91ce72f4ffe388a058a828c79ae7500ff4e57d620118f1a20a8bb42ebb135f73186dd2c9eb50823ee27eb543e1b9673f4273e158afe63bf6876b3e7dd613eac523831f116784863016b2c7ba936bfff32d3f640cee1376eebf3dfd625a5bec23f40677ce21a9a138bf2784d02ef7bb44d91f248de3be3b19681f4c0e7afe34fa3747a3cc0287808c7854afa848e641d1ab8d4aa5361b9ba2d0d3c6e362a9f68f3debdc20f4c3b2b50acb094c36a5272f05ab04a0e34e90313ff941484f80030f1afd114b99d7c06774c736ad60e5514a16c317970dd7a48f466e0e26adf3ba8a9f9839311ba3c70f4df9d73dcd2ef638d7042f1bac79196f49ce682af827d486ec3db5d7328d6940bb2ad7952961977b7ff1d6de3c8a34c3a95296adecb7d11b4acdb779e9261b1ba7c9bce40d5649e61124e53129e96ea22e48d8282b5980b030174ca28160dc9a83bb82c8afb936aa7d24b454dcc166092ae9ae1cf6eac2509ed4a30045044bb8b718d45d5c9836ca150cdc45673fd639b15f5af28f6b3ce636d34353bafe36115a91182948df1e0d91f6c6c22b696ccec6d6429d976d239c249e612edd9817fc195b895f6b192ff9bbed9cb5f1283b006c01294d6a1c8de7cea4bc2b75e3321e1c0431ed831cd402cdae92dfc1055be4de834fd367446a71978191c264d6a94298390ee77e6ce06e749f3963e08266b3c18e3dac055c75911f6411900ff6f4d001d4b64629d3797743d31179eba66b692944db94ce802c59de8dafae781d4f437e8a30481f7b443f41a690f0d6aab150d254e919ad069dd2476759b321fc94715328fcee405b568a7d197b3068cc7dfff0cdf35fbe40a57594001fc729910b44a0ac4dfa54c768073eef5102d458c03a08706b8980937055a00d27ebcf123c03a20b142db78aa6d089db73aea70659e8068d2b24cf1fc3734e5ee760124e3c9d6671ebfe9f7bd1232df11400b2c1ba3cf74d90b12fcfbb00060af8f59b30b767f8c9928b40f746b8aa5647bd285e114e8633d328948f003e92e2679b1402c68ee1ab6f96cb56d634e0b31eb3eb59eeff4329586b0c46d69ce45b3d8ee41b745b8f2650db290f0c7fe9fc6f5f13a2b51e067a6bb63be972e675d2344800eade57c74a84b34ef2e3c978ed60e9c7df735ffa665bf8742f2dab6f26d0aef237505df69f34e7b328a74f7775b5d74a9ffc00181aafc07177990a1feeb22ae6dc29b86339e14919bd5c66a509af0c74207dbca892ea6a15fa0289e6ef57b4e3cf98134aa609e2b44a01029468a303f1fe846ccd2138bc5a6fb220a1613a2c82c88e856c677847a77da6d50e23d557d71eaf6c4b6e891f1fadd5875c1ba35ff636b566a03b492c5801ff8591f4346a780b1aa3414d7edd16118aae6c643f043f1a99c368bac2bff3254137fd9e7b6d3dc08a0af11185f5b8f532b2c675866c4800df389b9412772b07b9a15ba2374bcd7d9fff478a3ac025a3ec7779dc68b52a0799b10e716c5652aa3aefe9910edbca104c46013c3a2da15299bb869b9aaf03afcad72b2946a220eec1ed9aa727d283c9a3c5bc91da5b39e7ba9705a839c870a96168da7e584de59427274ecfb962e80ab7f817db485decc2fe00e2dde91948970c096a4d47be0b3e74f1d39217660ab4dffce44436c8651204a1c6a8e7ef1596011c2b0d28a9db8a43d90c59c2e12fb5671c14714f126eebebf216f9298e30c83ef785fd61ccec3b25e07535f6390bf1c3cc339fd1d9ceadd2bbe0efbde2001c09fcef4ff00b410e32b156274ee74a8b819e052bc8516958d6ea85278d4b3eda244dcfb64210a7ad926c4c5f08e666647d4891816e0f1d235ed68885fbd76129d1a6fb07774cd3ace696521222db7a13e1f6b2a890a5411651b94b32b6cc06165081d3114bb5097b47ed9483e5cb4fc42e01816a5eef0b9b246ee253ea5aaabddc22af07d42683c0117c257025e3a9b7741151a6212471047cd1c61ca4e5edce73f36476fbc3f3c0921161c2e9450431d3747149f82e293e342302a2808c3664bb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
