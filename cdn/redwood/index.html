<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ac664bd236fa92bd56326c97ea307d4d4fea04caf928977da5cbbd4df5362cd0485daa34b23fccc948486b7a6a31586e94a8342f4691626368fc949a8803b2e06b7223d46ed24888cd4efb27a8a557554a38d262b4e1187e58e2cda22314911fd454a0cdd78b4ff1c9371226ff64b1a016dffbe0323bcecbb9407075985ee3ff0a04796cfc8140f9012311d730e5ba0b5eb82c1a2dc8148c1ff45ef9e5bc996b8554e6658dadac29d275887ff2e74b743443b933925c6267601c8e85f1c6489188b7b80d9d59e77cebe7db8bf93decfd12a42d164e256ac7a5efa2815ca8aa1835d770830fb5a9df7d421abea03ef5fa04aa9fb50eec62eba5cdf043c1ff98e81dace05976ec04c3abcddd2ed7f7707a8eacda7b27d86229f46991d803a1c5a464153d5221838069fc57b32a6946e0ab03f1d2f96b07918788bfdc40d71769504e060cb42b5d91e88687bb5fe13c8abb2b85e14d3309e166648b63f81ace275d7df242e0cda52a751f6ac4c23906ba8f8235473ec4f1282ae79147c2527f024563d76bb1456458868c9ff58df59465e1d3802f080e5000fb51d1a08a486be5d945a134ae7d9facde44337b67981bbc9dea76be1d3c401ae30435ac487639a462a87e5233f2480b87165b86c65e0070f769448b9690a67aa44ad603e434e8ec21ba7835b0c3d79416cb8b9f88fcb1d99e7d0cd4f255113ee14691467ac90e16676a3f26c8a42f17bb76110a9e14a7d72aae68235f84a2ec12cda7a5c0e30c8082434a28154304b4588f1f50c3a3811a15f02bb7aa14453c69c3df37d3b1d415376493ed9ca11c61abb106e7d58b3bf2521e07e7b8223484d012175f08796598c149982c384c997c254ee9527667366e6f6b1a465338a1e4cb189fda9e6b5071e84143c903491a306022e2fdce617ded5f1d08640116f010e8c228e5325d93b43ff0ced1b93438de4ece0fa13ee0e15aa39e73ede21813462bca3537d14b3af584ca1b350c06c1f5d0e9ce3bde3663865b39cde2fd9b3bece6eafec5e31a05e8637f95923294c4b796b0418291eee7dbce14b0a61bcc560a4f10ecb168030583b4bf1aba03f818b49325dfd5f9e9a84719baf4a4bede92d41f0de369032c02accda543724e23c7190de600e837df3216be9bedfe7d6e827087e28b62489bd7d54f37fd778a1cbc72581115f3d04fd80dad44a1fa013a79b958eb8d5b332fbc9c6ffa0421e2204e016c9f4bf992532c5db4ad77be4d393a87fc17a507c8735ef1a624d916eb15655e2f7b1780876068e21420184301db6d7b805060c27b12f1c27d8ab3b37a646f6e522a29ee76ff782f3d1bea901129d0a1c2b500f066598fe80763b7c7f27ed6c231ceec1fd390b897609742643e49b0e52d6bf2e3d9f01b9a501affb52ff6c8bfcca142cac5d481ca4035358bcafe24d037fc60c3c4218b41d31cbf83f695ed7bee4c924484a0c0bc63fda05cf351f0797dd715caa267810e5dff623bd89ee3d7f3f40104fdbe2dfc410fce9b834e24e58b435a16d3cbe769881a9e5efcf7b0f9764a0593589d979c246d0bd5e1f0642177bf944bceb54826350dd37ce751538c5009c2b7203696bfc062125a9b1c65e39a530db4c6e7da4d6de5aca346296893b37574e17199a89ef39ca46c4f06bc95d93baedb7d46f59b94660ba88538008ce2013c1d1814a7fc490899c09c543f88bf5aa1a8f0a177bbafb1521f6a3edae0ccf332f9e2e42a03813993a261c60c7094f1ac7ebc5bd1b93c98df243b975588cc4f9ea9cbe443d8bffbe7b1370387c9719b865ddc2ff7a808bd27da2b31b21049a14d222be4886e3cec3b2452c39881386d960155f03787ed0cab85f764603d8cc141402694f4bbc2e139019017ad36af54e65edede239626f1d257d32982cce1af833c3f54b2e8eb74512471aafbe64a1e43ad751fae00f238a7fb75990202048c141125cb7459a901800be810ec8feeac89150b22a96a9ba5d45314bdf38f35dfd6e264e506c4b1094cb37f1ff4c8dd9a8b181f735995c7b3118c0133f71709c4bee68340cf752dfb4994f69069b51d678ea9d265a5b0c014f797a1823e156b1d581fc0cc080a02e1949be7c0a1424d6f5204d9971aafdc34ea5bcdcbbfe8b2befa7446c16fb08fddd632013b19f0343642296307c2da9a6f38dbd30bd6ad442138de7cfa56a8b6edbab892b7147d72b43f2219e86a182125c15345a60939419b01cca034d6dedb7cf832026a46325cf31eb935b2687d56c3627c9bdb4de79e9a5c0df9f468a44c6199d981937c872a7430e8ac64512494965569a862cb999b6725aeec1c9a7e6df82f4e14c106dfe42680dc2d99bb059a433437e9080a0b14cf78d7e970314892b6bd5b60666b6672ab1c6e95055b2d28ef2abba7a6ea92cec999a7f08dc1ac6185008d322d1925c35ff47dd7c46ea9c23d5587fa93972f98b2b92fd448bacabb641676adca957db15097081bef96dbe40e8fd97e062a8d3969818d738214404e48257402c08d996b8f1764cb8a1ba2cf88867969ffd0a22a036d6bb3a35a9260fa628d07810ae8a418b5a16754a35825360fea65cbc54680c95ba8fbc9fedb4bf960e329a5498ed660b368e8456b05b5f75d5e80fcbb1623f9df05b1c69ae2c1e145cb66d40c8bda8c4056f5df684e9808d0ccd575f818cc5b608f6c51f13f76cf5ce9e168692f2a30211b243a1f7afacd2a6537490e862163c6ba89909845770c6a3ae54f003e59d7077fdbed14be5d459a039a55ed44e98cb3f9032272410b8894b73fba627800eb995f0ea140e55365ad9413bc0e3cd8ba211a4c46b22996b50ecc35060c745a317b1a4227d7b1bd8a03397bf6a7b553147af01805f696879101fc624bc6f58e49ef97333566ade82aabc49268b06b4f9ed82a0e9b6baafa7bbeb32524f0c4b54ba1b7fcba79adcfc6bbaabb8be402fac97dd2cd2b483d9aa5663817a47a27a4a33674570d084d8bb08947ff7c4994a6ac1f4da2a99dc9d139f2b1bab579acfb26f7aa758e04c1786265e3980a9c36857b74d1c541af83581204d1dbe8fbf18f8e97cb9da32afbcfc68713bfd1eeca264dec483a40b19afea30bd694b15a18e37c6f66bc1a8cd6cfb3e6154539f5823610043403e8484841f5ea4414bda279817b3ad284a5e87d4006d92d878d35be741146880f397733b7bc129a9a8fe851ebe70b7139a02c0b23d400f273075f4978502b681f0d552677833c5551f134f7c1cfd478c29d828934501ef19c10ae5b1929262fa6bc6cb470fd50682624bb0ae692e18126a9b548a09705c866bfc147fb07737e542ed6efe88d5b8553d27052d7d871275d0517e93d4fceddd887c69be475dba64ed33c77b74cf7e7efc3ef289c7e4c58082284a44f0fd32bd1ae858887afd00aed48845ef3a2d196ff1331ed8d15725a9ac768e914dfa9ae8e806c2a2b7d685baaf73b0629977ede290f6ceb757aede1f1aca527d927648c0d4db708bf7105b91081fc5c6afd51180f8be963f0a2918d61fab674d86c2a6937042e3add1f30850d6a6c625fdb9da93430df0bcb73b7dd1c99d267079341aaf7e3a7129b45ef5a9328480e400b8ca52c6ab708d3925ab142bb6c1cdf3da395768686efb6ae5359ef08d7fcfbdc7fbf9d4d4882f71a4f81c330fab523b29100cc76fa2363a6ff9ddeef5df29d969fbbfa174ac79a9a6882c97684da42946bb3dab020c55f401a36e73a024c4e6c478b52949ce8bd5103d6ec66312e383b0b4bb6d45ac89664134c9075356dcf66764d5330f437fa663916a4146211a276ccb86f2a25115a02dc9a073baa8164114f02006da5539e0c05ab91113dfbf9af6cdb888b409ad7c6feb17f9f226079a3d44ce1269f966ca6423dee970bc2432db959d1119c2d255efbe70248915f35716e5cdd7bcc4f0d844e93b573eb4868ebedb08517670c541b69eb086459a0ec22c11f120c1f00b6cb71960d7dd42da24583590f5c858c9dcfa9f84c43e034e6e82850b4454a1d988299d6c0383a9f427f1f7058292d3833204ff173deaa2b7e8d1349edc72d9d2a4c01cc030b02c61383bd3b215e8d34e950566dce83ae48c40e13d3005708173a13a8c0026e6a82b15e0b558f96241d9f9409fa193559b16d86281de90fc2d550c021bc0c03c65dfcddd4e07261bdd65d786fb8c69ae5a34fe30672fb409c7ad8740d7c46b70655cdcd7c2d08d9c91db902a41df50ee7794f2aaf0954327d647fce04d633d4ac77171d3f9278a485a5c0c341dd2ec7ad650e117e693741807c8dc35c738a5117eef95d3a4927e5104907b0b8b42e8bbb59f2009782762dc0110c7115402b0e84a1e4422122a6d801e23bae39bfc7abcce687d0d7c25da2e509667de6c17c8b1dbab948ac370b9506f789548f05338cefba2b860bb065075521f962a2416263a17ef55ec548c7cb3a59f1a3fc45f37bb8957867a5388bd94c7c870975968a1ab2e9cc6eca1083422927058a1ca6ecef1db7af84062b2539fd5ac88588355501b614535d79eff03d78ba1a00a2f1a13ef81433b5a7fb8f1e58a5afad06223cc186befda28116cea37d62b2483652b43e3babcb1c30e188e70e890fa73f9a6590f5360fcee5d05f80fb3ca4f3cb7ef99e3d61f8919c8d2de65b2df2b5f0d58bbd91c92a01eca5b76dab60a6708b5eae788dadac8b4d70057752059b4d8c4cacf6a9d3b74ced594cc4625e6c74dbe6f98f63d82b4247630f0d4c09e990c7b2e424b39d1e2ab8d9947cfdd050144ba89bfcb796b70d66165cf8d612ccde1d2e621f738457d21e3c8b9a2a317261f8d30d9136d5266268e2ef94656addb902d0b28476fd998c614ceae300e52b7ef375cd1a01b7d0fbbb4cc303849614bfc692ef5997eae6020f167b7fad5f0fdcfd55127bb58e0300a8cb6a51e82c8105c96f88df18c9ad707e36267ed38d4f4781ea2c084bff277c52ce7d8af02cedacbdcce048851fa5975a6a225fb4853466219b69b11d3a367f2ffcd423cb36591ededfa3ce9ecfc1041354d7bbfd73889836b12ca150c511004e8ae324ec83e369ff9a4d9f7a6442def5a9ba0332af89eb9549b6deb1e2c429992cd49420346ebecdfeb2ce35ddf68502be99684b13f1be1a160c61e57b17eeacfc85039de9d4687c86b5dc793785ac3dc92d16552e4ee1ab50c8d5a52cbdd711a7f2052ecccebbde1fd6b4c311784dde54d7830b0545098121847a35a1514ab3ef5201fc047d14ac70c9e91c8ef758c6f29fceb2585e74de075afd64f8fb944a947e22fedff14e02c29c263ba952a522ad9f8a8e34b3a7e083ffb7bc6d192acde9711863fc259a5e3a316fb80d528df2479930af0d15a152951b12599448cbb5b126953574a3d224cc30bcce8bbb6333681cca9d7470248d5982817e1098af654717de6fc66296fe6fec53cf6dd1c1ba3a7ef2b0e8d991180ca95ab66c540403fe214d3071eb5ab04816248550142b3b6f6438c6908a9a393a3a80390671fd89f159871745e64f1cecca2fbdba693e4620994d2f4aac1ead8386e44ce9ef51a883079c51f28e4af020aac0a6faf8bb91be98b40ed3339ea539cfa3b36919fbabe4b4559131ba2db51a5a3b780b1de1094150b5476faa5b61a82e966f2c5b8f1bd65b8008544961f5d0bf6a49f8c352ab4024d4daa076cf5f65eb5b99b25aad6d37c7ffe9112eb600795c93f258f0c3e22a9aa47b820dd0098d3e3f64aa5a01ad31a8bd8a378d584cc5bc50d8db77c7d597155cebc6f36eee512098c21ba2f0a3dbd70807ea91394b04df714f6722d6863fd3c93a62f66ca96631b0b1c1f11354b12a175bdeaa5f67ac14c86a75cee6706c2e60981acab354685d29f55eae5fa40344c48aefa5734f65437c2dc8ae6095cc5bbad2196f12a70e5090b73da47554a684237f11f1e464b5837d2be34aef5ae36aa2813750bd11a023c969632328a900d0d2ff4c3c503c17924ad4058116720f8c0607b6c4f8026c94d4f04f54ec881a37c8ce571b3d9687ad01f8c70e4447f8de37a46996c710d31e2e09ddb752d88c3e427bf127103071f505180fffc6c33b3b253e8304bc949ead2297f0d61e092fb2be1ab67aab0aca7bc97bfbc822a95a1ce4d69e1d3679a9f65aad40a38ee0542987c33a4befc372ac59e592f9207d3103c3fe788f6d63207e15329396365747c7fb30eb6ef938bab93ec580df43cfc35dd761a0043e585119e1bda1aed75936595d8604316784e6d417f4a7e98af7a88ac0281fa51fffdd1fdc0e1a41b0e14587762472c762d088239e7364c7e8c5c2e9b927954430e1befd563f5f22743a4aada075f65f61f157b53398ecedbeaa474dcc2242c47cbfb01a3459ad80883b4fe3302905b33dfcc0cd9f94440bb4bde56b1e8b9a8678c0ebc8f3bffb0c9af162d04a04162c5894e1a387f1d5a51fe2c7c613f1440f60bc3ccf48efec9b2a3c31f8849db0ec7cb47f0308fefb6b85396970ecaf0ed93ae75e36fed7d74512b9d56b22502da17f906ab2897b63bed36867db048c09a6e5b048d0e98e025b2e43fd48b8431af27c00d41c37dd00264613834053470d2740eb78d1c95527f8dd0dc50966348b585eb462105c78c7b7f95688f645623746646a6f5716802ca04cf6ab56f73962a8a79fc0a10a9ee987b6b56b5442863c7f36d9bdb44a13ff6dacf6a77281c4cd597600c21f60e2ad661408065c106fba89460b455bcc55dba0343611423df7b4cd3730bf86a1aefef61e9824ad5a2e09cc2207708c756c6f2ee209627c4c4fdb5d3137f81b8a2d0b9d94d7a3fedeec69da536428d26d52dce85dfdbd854cc478e049526dcf26120772dbc0ed50f08703baf169c1520900b4a02f3394131d2abac4782d763ab3694fcf313408a68beaf0f4f38754f53d745989360ead9385093ec0fbe07c2bd62bba6ad96c6b2aecd6a460e95ec286d7488660fe1402be2cc3cfc47b54b927c3cba03cf358df8b4acab280d01da75e08bcdffe36c25e055159d77d1cd184fd3adab1ec56ff3d5c7c749ed899988247348d1f2e1e0821a1013811b0ee307bad33a8fdedbe041308a6fcf408c63a1cd1042b35e5617ce4eec0ced7be41c7a0289bd9f9659cd86bd22db0133c27e6b8e02d9433fae4c583b269ce683fd3a71a182760dcc67d3d012c5b7ba141c47bab007e0c8b38e7ada6bd17b5eb898bf830d11ab95e87d4eef3142f87ca4bce6d2e5622d9aa5dfd73a6c634e3c0e18fba945652e2726ae04de199d899890fc40544e008b17a0fabd857eac1a3a342ca5cbd1bc0bc8f71a6cf1f720993764ed2ec9c6cab6260506d9e118359cf03af71f5c512e7095cc734180dd6f0bf3e4ea2c3951f2d24e93e0cfb021081e32e8053afe6733a1fe737f1c8ab6ce5e9ba6e7c041336445d23739763558b7c13cb8b9755d1c27caff8685693ce1b2835a630ff2156713ac815d9cfb9dc42d38013232a56683700b81924cecfb774456d255c20dd0d23b34bb478133307f6f9f4575ee76c468dd3cc709ee94d5620cd38d0e10d0a3620d000b4be2b39d43ebfce7927986487fa75cbbf5da0a0a5c4befe949eb9799631ab1d07e9f428de2115b8e20a01f7d93462145319d31bdf3a899801170fe59e73c65382a610d8bbf403dc914b12dfcf9a98958aaaf58bd459ffc6a3a976525121bc433d3ff4f428a40bff6c19725251ae8a87a1f95bb9d24979eed5aac59b1cfe7edac14bee639ed14212a564bc412ecd51082a1c1d8d7d9db6f41ac02eac8d6280e29db4602a31e2bf9ed976dd3e9eb7bb2715044de1e2de0cd7c2aa92a0aac908b4a1561d01503eb4da7dd64580179b14c4143c811e232b86894d4eefe2937707aca20b155728404120a2c3bae3308f02b667cc5740a376f776d86c6b3f4a9cac008ce6716f10b7d880220bbf4257699695c23fbcb21286e0c0a792fa57760c10747ef90576ba932c2aed6eab4b2657f1fb9deaa0ff6bba60fafe938c2cfb04f4d3fb378e97aa76bdc0da974c569f1768291c86dbc536ebbbdb5d43637408e70cea41a0c4fc897bc2c6f7f9a94d4bdb9a8dcf837726f6bada261b9657da0436ef40f9fabe309b85adbb592c06f812d71bac29cd3e9abb1d13934c626e50053a44cbef0887f9ee0a1ca309c11de6384674742221ad29055f647790a59934c48defb63fe58b2023db79aacb35f5c5633a07eac2e7ec9b8f26b74cf69e825ed363bf19581988d2b52eee02534e9ab6bf0a2442b4fddaeb542d6ddc786ee58ee79971d5d481e89226df551ade707763882b094941f856c31719c0861136b7a3207d5e93280c4cd436b83b0f3c8d8578dce922488036cef0d14fb5d4a07e98371b5b1f22802f4123ff927966a31969df0257d08d74bd9c70c689cc361d2c47f627f290441c5a56a3e48006000d9654d75c2cb4e679fc8cf7de32fb226962e120e4d7ebdf0627391af58cc3e16a787c3d6a128e2b54709f297b25efbd592d20f04962eb44c76290d7807bc2149f53b6e069c8cf3ace0c7670a83871ff47453744c937b4b1811b83833ae8c0489ba64067bfd4697ab09d598e0842ad3700df648ab069394347b8edda6b23bfb6613e7f2e75e2d26c3274eed950438e57e244a98c6a22ca73008d52453aa8600a7f5c569023b0fb08ac2e4f0920fa1c686de79e06f227158061df1a627cbc2ba1c67a66b31792b825638a34eecdb1917a1422696b497fa9300fa4a128b1a137c1bd7657adadd699e161b631b1d6c96cc25ee623ebed15a36fdf226838ac881437e788863c4ad3fb8400953a2e6c187b2df1e481eb6abdda3e92f0589832f9c2c16ff2cf8519fcdb37694315975d785b741d2e751df5520100eaeb4d671e87ef9be024a46205b90c3410dadeb28b4bc7e565d723e018d268c6fc6da66c9eed13eeef311caf5ce092e6ec01e7c6fd0b8d36c74bb28c739af06fcf875b2cbd46fe5358761f9d9d586e636c5f5bd088c445141f31900a75dae69ab4a6191dac747cac6e48cbde1e8030515849deceed12940c1147d5a6114b26a813b2cc6d76fb570757fe69fb6b6002c379a93bf6f24c715e4e452018a871ae63a07710b66e7f18d849c4fe8c147ee2f0e470f4512f851e923f7d1903300c41eb66a7d26a517f016963cd9538b2fc772f5d93d254eff3df283825f277837f5afa607d5c75afaaa6ca8be32cf62d6807a57501469f0e69304060eb76f2cd0b81002e56ae0e4aba6edc2738797a822d3cbf475fd5e1132572449386f0a6ba5d5269ee1976ee54e35c5886aad03b1195f044c182a1eee8eec3831dd22b98cabcfee4438726891a557929c17e65479cf309510a03d5313db1c62e9727a824de19d91e153d9bd317b06020d134c12cc1e16fa2e711bc37cb7486abcdb9d60e2ccd0e1ed012dfcfeb963bc4ca4ccf2380bc3a441e5f0707ebfe23c19c9dea29b331f6f90b0ab4d726d84d5962d7ce0ea98ea7c7ba6908177629f59713013d672df48d770f56bd3eaf0a39846b3d3db4e9dc593e6b91a23d8c25703f70a142c5484d493fe25545167d819203ba08244f0d169c16b5ade1ae61e264a5c0d41c67eb0b366b19a6124fe7375509034347de43c5161abd9a437a842b133b503291b88dcb7d6ac5ee8a584c3f7fe2a2da3e2b80033eaed8bef456a306907b1606a4c2685f8eb51748fa80970ccdd32509f56ad39606df2943327257827f1a70f9b4ec4f16fb9f945d3f5973a16df847a41d4aa35025de1b0aea1801dab289a26214fd5c54e2f72ddd4fea355234aa144914c72cf8a95d4ad77c08e7638d53168c7a11ffdc7bfedb629ccf3f1321bd1b277c0d672db76733ba4edd764f12462e875f6a8c0bc50f4932ee6ef317558bfff2f5e6b4e24bb0a80d5ec5f054fd5e6737a7ba20849b179aff069433354c278206a8bd804f1bda48fd32e8098d948a8efeb4724b335f0a39a5e5c55215fd6d44183a1cf8d37e9d1d37b1b39b75347ca81645a80117d173e94f528682f715234e092c21f5f4638d4ded5c0b2e57cd0709947689e31d11e407955cb9de7642d6d93d16262db4867abe795396119afd6c990dfd4f4dc4a7e25e4317ceefd55dfb30a2d3c787cbf06edddef9f7498e41497541db0b3b059f94b79af870bb75226ea5692159acf52e78160c722f46a5a2007844da9d5772f9071406a4068158fde1972b26af62b2a74809b243976b1142549f1bc2d5e3e15723a606adb9cde0ab3270a424a6b85733f8182167eca71c196c211d9ad13c7b9eed2688a236e136fcefbaafc65e08b6f23977e7f4adc317d51258e337b5b01469443f3dc8f391f2bb063de47c18eb7e313ea991894ea4ce770f39435209dc6840841627bcadf0f353693ed6b343cc917605b27ebfec7de1acebb57426ac7f182a67180537be717319a2b0a1c5f8d7b00e654196c0e5b6024b3fa8145cd8ac88f5277515faa9cc7b7a925919a53c7ffbebf28a4e82215ba6f9419e6d7a6db1fb3011ce0e05f6d9708e83ab2ff840dca86b59581e6ab2ab6e378790622d2bafd2c6f50b1db0241d9df4d9be2c3d1f524888b0b5a65630fe6d8809b885c60a5c56ba6dc9c6fd78912c06126ef8c0832a2870623bbcbc5ccf577fa5e19da248d3dc9f84db72699d50692b5889ba84d3bcc6ac21c9032cbf8c9470bcb774b40e65144bc1763c973d152a298a2b14acdd5f470dc9a7bb0c876e6bfd2da052d4956a26715145223dab1106ce7e02b96f3a6168139c63ae666289c1bef00c941f988250bc3f44757564cec8fa78015c27c66a73f54d16e80b822b689ae963bcc6bb95099778c8eaba1228fb12c43cb0e4d777c680bf9057545b6fe8b1155ba6d0e5e278376cff4a40d4ac4a79889c45e21d76d230f4759496e8cb87de7c7edfcdb28d2978bc7a9b4ff9556649ed10ddd68e4b56ff9fe2d18746d737d88bd5789e08318f6dff0997ca606631b66c628a6462506f69440196eab2ebca5440bc12d05ee147195e181914192636fa4a2b8c0c8c005df072fb2b6362caca51ed200471670114be33a2902490ef587c51768a10fefab0db73b68ea193bc4ab60738a96b349a502c8130c9d873f6aa13077a4b8f81f091852df16753630e0764e6702f91387cecaec31a163fa4ac827d21e0008075ee75c275ccdd6902210f07e3a3dad9fb2b5189953d0e881c6e32766cccfdcdcf2c96f633dbad94cfe162b68b7f370de4ae2027ebb3166b449770952b41621e055a06b9eb48d9db6519f2eb65273c2db0fbd8d8847759bda8ae90f73b186b3cd57545771947d0946822d2f57d63330b614c205cba98614cc96570c6d87c9e51edf864ff305823e111d7351d0cc80255d0b37ae2b8a90642fcd028a85432ebb032791fd35f5c7e77335df2477867e672113959d06a5e5f6fa1130185b96568ea9cb150ddca8690c8bfdf57918b36219d7e32e5e0f04a9106d1b81c257ee69b99538dda0575f646a73db8f860adb5935862a9b0da0c89576fe880766f875d07615a405a740f3e80df30447e632c1c7a7568f8d6736dbeae483487e4e95315b5288863fbc2c223a65b4c7a4522af0bae6491c83335cc18b11f16753aefb44fadf12b67711810cf891a026f7547754fafc8e727504680b348299ba5c556d96ce72a96241991a9e044306c00ffa7b1fb807b72c3de16c742a49472bf4e2c5984fa151f60d3f3900f6e82edd64bf6176d38d22dfe9aecad8556f4ca72c501e43cd75b487de8a263728476eaf02174df6f5eac9698a15652bf1f5711d6ce7586ed5b805bb651ee25619288ac7c6ce76d0a5329ba2550a4e7d27c84110dedf2b1ae29654054a95ea462c44d0a4ec23e9037a1d18b74da309754b362672364c318927aff7bc368d7cf678ef6827405e077e24575cdd632941a18b5268cf2bd17c1fb4c763d58bcbf9cec1fabf5167b3237b74186258e1630bca1ab013301a59f303793098f0d0245077c69e5471d6971c4f2a4eceb0b767f83381aa8fe0aebef38232e4ef5e51600cc9b8fbbe85b45d3f72a2023a59a3a4d30425957462b5ae0b67ec949dd5f3f4390d15ff06a88f677c6dac69f86f50303f891eb36f69a35208dadd7148e72976c91852a18c259beaa84a1466202169da9ab44b020968e987f78fade7132011b5cf904a35275469bf05121c7273053d7b04baf44fd1d2884477b7c837dda720ecb848de99b7a962f1c476d965219082de7f6a84bad4d4415f2f88366d6b794b256f5c32338aa18724ff0290a3717c0fc934b02a0f835c7d0934f35cdf89d058bb80ba25bb4403d1ccff85bcf5fd04b7e081d9f7d670c734761121b80bf4ae1b37aeb693318c02eca097c25e5afb1bb557007c89d773c4bd40855ed96abca233d90ae31a1cba81a99dcb274f57024d0c7c296373cd943e2c0eddd52ac745495da6afa6a8d5d23c4b77ce026d0c3c255718dc732693234a55213fb465cd38689477101a09de00ba723923d5126708b973617cdfd20ba9831f06c8973588e3bcbb19e059eddddbf70c19da8294647f6eb05b93ee59d3e0e98a8cd70fa187df41d5e41c05bfa922a6e7bab2e23366eea18b1c952b084f3dcd11592f2078be9bd8a23c89166b01ab5da84d4906d2079164cf0872f5dab4c66faf474f0dfd362856da19b94401872d6d7fc60973733e10e262317fd5170ae634b98374c03fc058f025a1777c5d57dd144a2bca58c542a2ff7160173228957bcfbd5998efaa27fc0246dc182e05d5b110b2a7aefb3fca2ccc97a13df6b5756b6cb9ed98dd174f94ba5b3aaa5124414193b4cef77c58153a009077155c6c6518eddc63705e918563ad3dc40156475a3a15a0430c61326b905cee405f1e2cf51b6ece7cb3bc29f8b0becf231191e2d11478be6e12965d46b7b4245fbcc67acd3a0c0908bc0f9ec07e75c3c0e5b79d77f87240e69eb1ed3868e08b1808adc13342c32e0d18f80548f13394538fa526d033e43fa8d90f7e27bd9b7711327351f6236d031256cfafe57119139006a2ba933cf4021ec47d89a21a54d85bd9a18a30db05a8a34894340cbd02c659959ab9dd491cb645c57fb9c8e4fe532e585817ef695e7db82016a6e18c952bb5d545802002cf8eb0d299af9fb88605f3ca2f746851a2f83421834edd506cc4bfb8c7a3cfa306d20ccfa50bf413e09f2b8fcff7d1927a4c0fe554cd1a7e8f1bcdaff6d4724a9cd69ddf79d17cdabe16cbe44b757b9d973174226e19a499af010f92b4f5d26ef8ac5d499c01443e6bc0f2046a183a76194681f5741be6375e0a392b2a3178824290701fbf84393d1381559d5550c0c47328846fdf76f4e5583e25cb3616f1b4997582710730551d94aedd6ab3de66e788d14d6c9316fb60046b8035f2f88209e943b95855c091c28147c15380e48660128337e2ee5094e920e09ee3f714104635dbd9801904e752eff745263ba1f93f13436073620886c9f058aff92121077cbccf6e9408369e4473404b3075eac24e3e42c0e364c436ea008e9932622bbd22490e4029f5f99959350200bac2a59ee79c613a823261039bd6c0cf29f9b2f040138c56bb517d5f5e5f37324b7ac471495d23b40e834a529450eb37bcfacf37cc6ded2617e00431e02b5e1935cd04e258bc9a2e360f9ee9cf6c144613ae2e3eaaeef3f882894e48d20f3f63431f502b0c13be9db6a16d4bb5b5dbe7cabdead929fa1e2f5e8fd97a9d5d753793745cefdd307b8309a9ec0669d9aae2f7a58a674870d94435d759f0e8e6e25bc9cda7a1ae18dbdfc57d4b2103f667e38427518f5be3765f0ddf2705c4de5a8e457a267e85c4316bd5d0ec5d3699f9e98ac608fadfc13734d571a551eb2a671839e4b10742776d4b6b0c6ce16e3b8bd443254aa6278d576ba455614397288ef0b13c400a3084f6fd80576e1e65532034524878f6132232d9014f72a832e6ba58605acd72220e170b301ffef0855b056ce27552e5cc3da1810daba725782b892c1395f99a204482fb555fb1b46c34ba8950d7c9152a0de64949f24c9e537b8a520d9fae39f6e944b198716d67cdc3ba7950564be3a0583be26b8f96015e83f0f68aaf3ed4d8ed64381f7785ba7b3496880084a212b5f5200e52c97cc7a116ec0b6a6a92f55e19f98f31a646354672cadf07f5ec2459448617068653b78c6772d62a9e3081e9cb990e925c5526a13d7dcf5cd4256226e31058d7a989a677132619079b963b5172978c725627b6075cf100096b6076d0213b6c1b8ffcf5b3cd14a6503a89ac795b6705505dfd4505be566fd435c758db16dae3a8caf1b5335d64fe62d012204f002df25fca0aea4d69954c26465baf532341e2f0631f4e862a6e34b56b9af7db4818e9f96a0149fd2cd5f8befd36fbc721bc67f5ddba8c467e276659bc281060498db9e89270916db231dc78b7eae54a5890cfbadb317e457f1d19078fc716595dc727ab59973820bb032f4cb5c056d2e0bc204b25eb2d842b99579b3d0c3fffebad6cd50ad3d472b895f1180703cf2449705a39fc67ebaec90e60478b5f6b4bc9a8e22ad171413767ae53781a31a9f828ab8832fbdc203884f4b6f9406adfe4226a2c6eef2e0d05fa9ebc248b607ce609ccf7018b38c85290f3e3416c0dcfbd30a33a7d4436cfef80712609efd17187ebad180b5b89e81b4a1e8299a386b94199b0f4f2724c6ec6f2ba5685319ea8fb471207c86f3acd5542b12116114a69a0bac464feeefbe20a3d5435d8a6c60d56ebca1a2bc07d28ac66fd80a462a42213c7084751673587d7b5e225148004ab96f881f5824b5d7ed517c98869b1dd6b62b8f1dc6a2ff2fa2a1195c99b8b0608f13986f0293fdd54692210f87a37a01cadc8edda76e4f2330389556c8f9bbc4e943eb0d50e5e0ac35a233bd59fbc3af51b46b3b18b0ab4a8722d0b03f89a4dfccea76bd41b740e0170b139d71b5438d7e99760ce11500ac772b268d8b93d21f66c6d0a7f65e16d4f6addeff639227729ed713f2304d142edbeee426f07837ec59463b164f19b8e9e42af5f35ff7e3de6c6ad67baf1493437a9754ab120439f27598989947e477c4d0f0126d81ab5add7a4a5d4896fe98821b84274c0d62de001f235334619c6b8c6004ddaccde1c8eb0d63315b140042b1f7d951b147c05cb7ffe37a0b076d1963e02d5ef96d55ff5fa661ba485615971b05dba566c00c6b71d65d7a0dae499a721b26dfb0d227dfbbd57511fcd84b66695ecc4083134965aa51822301f266d6e1c50dafa81a14c5eea1545c807e1672e7cb5952a121937caf55657944bf1161dfa7182dcdb88e27997e19fe310dd9949938595455a2b821b676248485b2ef59d876616a702b45ca2e6f651bef799268e0bde8fe4e5a654ea1309981c56b6ac26a02307e9c423d799bbc862b91e665f97317cced5c89e5a4610bfba3e64607fde65d522fdd3df69cb0a7301b8ba3c161c8592bc9e83c1ba25511a1e27457f7faddc425e87aaaf30dcb06554577ed4f23b41c360b17d52ce9d93d3040550f3b661721b54be13a852bb7eefeae8768f445007a3a405af58a171ad9ec4cb1f9c2ad60fac6c33529c61ca91b9a62d141e6ae3713c52d899b08fa8c55d64dc8aec27bc3b69db262ec3e68cabb191517cb8c110774e91f89c80c36cd970b1ecd21f089a93346c9fe95e76d85827a0faab2499a9f65670021176f5fb23e06b9e8e89f3dbe950c0b4c9d020e20732384de4b99680f9b90f35fb2c3778194c4bdc2fc127e71a5d0fda66f5562b22800d2bb098f8fb64c68f3fd714f24c1473dd85f0fa2d0e76a454740b996015bfe26a33ca0f785a86823ddb11b1d4721c27892003af25d630a9f0bbe34d1e24e9c8c900362f30256d45aef056a00cfeb2cefbd1b8cfbd9a1c05886bb963063ff5544615d81055c9d08a5a8f3518e2cb1a739767b3ef9134b6cd615c3551cff9899fa841f64b74201a72b1aeb5419250316d452f759a61e1c034f62b4e3920e4063f19e97ce0d4cd2cd755fd72a62f9256dc5587d6ca8e69e1a26be46ba8516437c3920c8ae671b401fe186995757461c97c817046982db0075fffa37c7f0839b13d5efe62be3dff49d0ffec4fe7182daea4557cffcddb1d5dd24f647a8911462dc2d76d92e30706d3aadab28d744c4bfa8a9d1e0a7f7d0e00fe04f61eff2359a8ade0c11e62e753343d9dc88889aae7bc16941c4ba0c41b31a3fbfc94bb384a401b7b95ba0e2b4989bd799331ed461d14e65ae5da62470aac845fea23e3ea702073969533376cf20993d1636a111cf894be186509bf7f5fb417e7de237c19babb144ec9a4fbd6385484f2b62b945a21c38df8e7b438c0ff37c2b324e24790271b8100a2c12028002958c3ddac7315e3e384a2c3b9b809dd240f66fb994ea7b2aeebdb6547487a0220c8df31957fcbbfa05ece6b22dd23e4d23d89ec909ac7033e68641d170721575306f139ec8ecac61466496913180f8be98c1ca27a229ddbf5e01f22a77872045f324016a42aa6000fcaedc850235a6759292aa5e4b0d38dc77fbd13ad33d2a34f1854216087005bf45ca8ba22863df244bcc2fb6269a75be81f74cb4d10d4902991ff45ff5fbe3b75a0000a4d79984350c217d8f05e12c05a4497a09325f823df99198a9c61da9aa09a8acba0a4baefd8b5ebb28fd0ac818b0e16919fe42c3e452e4fab6ff5daa49fd01083f863554322f72fece10a50a261411c3e0c01922a14649f689fb767cdd93f7a6ee2c8cdcbafa659df2560ad2fedd625dbb7e2ed87606d1e92389b3c954e9ab564c9635a266cb8e6cba01b65a2394594c328ae35c333dcf43de8263a39de25c05280f85c4af2f518d626391d4bad4eeb4f9be7f0a514a9f8394b5eb91f7190c954be62f659db2a4a9470483d0fef4dac7f9b50044ff96c5cc4add6ecf6f455ebc7ff45757364d816dc07235fd77dcdaa21789391f7f38a3599a94d0789dcbb60ddeecf1a9da147c8ad5b5ef64ddab0b86a14124dc83a96191c0b7c9d2a5fe1993e626a074f20de0d2dae125db3665b3dd28108ef9f5722dd8d5c50f1815a5e23ed2411f6e7a38c46da91a1b685bef5b191d9b250df37f30945d4d5b925c720db37d4dead4e73b40247598351320bd3932f363d87d68e2036a27de359add8ff57098da13ab0426ce588ca3c8b0d7c5f8d6fc34299d51e608e1055e0b88224473d806f522dd94f5d8961dd468cf040cf1951bcc9dfd384a19188bda70d6faf18e433f2d4ea264e65ad490c4ef811d68477feffb393e022870160c7b5ea8c25c4170e47c9d1c23c0befa0ebb1725063026fb495a804a14184cdf7dcd2e7eb7cd27bad06672340d0f2b9b4b19bb5917267700c8c1e29c5fe6fb61215ded998b1ee9f3271aa8d3a64627e3c8e6fa1bd517602b54c7ae26a7f323a1a0411f23454d793d82f9e84c49a3695fa16a0673224735371633862ebe4a4999934dde8f0467686ffe5bbc02513aab137f3e0d8293fecce0167077288f6d817ac5d956035e9ee3748659e180fb90c42cdcaef3e7c39f1b62be0429214b5c4f907c8d13b8ad716f51a10c89a4a3be4c5d71e30b0e23af351e84c51f749c54a45d802ab1cb2ade20dcc9af3bd23359b86e8576cc4cf774b43143a64037d5f3144a50bb89b1ba3f234ad2e24312d138e51560c1ce9e1e9696eb36b5186ca6fb0ef63a03eec511883942df4fadb3f9103684cb75fb6e4678493ece6377d50d421d21f737a5683c3c9639637f5bf503002a361627812863979fb8aa0f9de2a00d2bebaaa030695a7ae8f7f3b0bfb0a1e4c22784bca1a994b2afbed7748bb44963c619b0e173a76f5f7a6eaa16cc3a3a0ce63cc23759ffd08881c0c2b430900141c1b206740be1e8dffcb8c4367948994002974bc5a8aa99ab9005427f2a0438a2f8054876da871f2db98ba875aa32193682bb2b9ff8540aaecbf0dd0a146e5949d52c9c88766478ee48e2d4504d645f7ef62dcb34ef772142102f438fda2782ba4f4ef60d0f67c151e84ebf82ec850ed0151c8dd75214c99e75e76004fd253c479d3d22f8d57b67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
