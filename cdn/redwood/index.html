<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd12af2de0779fca36fad38358d8859fac3b0a6399d7a7a36d239f9b2f53ce309ce4e82d0cb9f5749c954b5d05a59059941e39300c53aabd3936f94907a94ff918a6f2e083bf2f811d972e732c5f4ddbeb0743f03b85c347c031805958f60bd03d055f1d3d114931e89fdc6184af47a22b323d1859fdf936b07d5453cfd0dcef29b5d1bc474125c5468db494da50f29f1ca595a4f1bdc349bd72d8783fb801c54cb5980835119a141db910469eed32f453867cf413613369ea6aa60e405118e9db2bb803f59639f40f06ec839d6ac32cae487e64a2b200063bf98b2bbd4fd558a11f0110b8c5c2bf723bff270bf42b3693824e70c0ab8a06de5fec6b4835ccfe9a810fe1a3eeada0933b0c14998530ca9cd06beef6772e7fbc5c987f88b0072400809b19e58e602e1c9b25b3bcc350228bf7a9039365312efb41c31ab6290cc5c27f49cfdfd1a0ad9afac90d3cf0542235fdd9fb529489997cb39f3bccf8cb75e01f8b59e5b37ccf7ad900025634752ea3ced4d3a6b20437cb33c13e88cf69ba54e6ccd1bc9391653d384fd33697f0d1b0de10b33b9cbba60df9e96bdf88b87e873b016f0ceb5c59d9ce632cb161f213511d55dd9e687cbce865e3d9d45766a2d91fe94586ed1d62bbc9f21a555a1dce81d7866312bacedbf12dd4667fef513871328b476c7c9a01be502f6de71212f192965b65948be806d3b0dfc726a8fe08a4f68cc2124d2d1bf6379b8c75d9d550889fe154ab35f6a3fe023d6ed356409f194720761a92681abe34ecb03e61cc996d055feade719b29718193d239d9bbe8cbc58d37849116a48d64d68d01bca48f8dcd245bf5f7860048e5de403bf03e44e60b83636ae38af6a66cc29c3eb2843ab904e66075c8dfb818f303749803db94437e4b506c5a8769cef9acb249a87d246e0ddb087e939c162ee669b7c3a3832399f9cd322b7f95aa834f37eaf0aff1200d908f38a4254b51e0316b34b3162af836799932918b8b3fcad1a4e4515cd18f2ea06594ec6e266d3bfaabe05ac2685e80bd56cb232851928e02ea969953aecc856aef942bb20e3e787fbcef398d12b6a90b176223972363492d17bc2458e9616a41a873df420575a35d2f3f0caabaa3053639587e6325d1f64a2586f9be3f5aa0f273d94bdecb1acd83c2fbcee6a294cb194f1419301260da16cac24459f6f3b3fcfcd95444edeade6612cfda2147234a7e1c462010e830fee4ada8d7c77993cabeba0547499f1d6e41a1bb3857545b77ee144bb30f1342bf8e54e7acfd5774b36633b18c15ea6f96afe295ae298abb7eebe1c266631353471ee6631a92ed465bb1f24da956661f16b3c1040c9f847f52399cae1aee1398cde6e9bab6f59471041e6094ebb164ea6685f80107d4a523ad98b57074d2d2d230c396585cc5e5952a011994ddd70aaae1b4c02d86a5ece3a432b23fc27ffc967368790d854352d0fed98279e7b6dfa3a6e069030c5b6a1a8c701fee60c86c3fcce3cb452bdc5be0a68755aed6b4b782e5229a0cce91060caffde43fe96a01239dbc03fe7b4a448a79543a2b1c05e838df827e5dbccd720fece733abc41bbe06d85548be2d867316ffd3f608bd40fcef283f15eefcec579e2a4a04d979e4817e5b5f8cd89a2615d89a34984a0432c198c8a2ee1126d7d2354ec3be548a9fa18610283d0ef8de8ab26e02a6e23de6b1959c1dd1bf608c91c3176b8e3f0e29847a3cb41ea1a74247c2c77b2cc4f137cf3bf0a0940ee365d5c8ddd62631318e2d87b204e656f27f9e81a4b585544f0fc37f9aee740b26f3b0db7908860fe2fb4a45459a52303d6ff204acaa9b545254e5627d0c263e2aff4ecfa5f1a6a90b65721af9467d11ff661ce04257335946cb5f7c2a69be3786600952faa8e6f3365ce67584177f6cb485c54d7b86efd628618b1b3a72a8a376563a33654f04dfdc7a2f40100ca3fb2233fca24fedab5f131bab9c2b9164c62849c7b18893bd26a9461a22c72cdf2a7189ac3aca10be30a19e3f598d31c168c118249f2ced3a32e88b1c3fc1f755c266ea8a8e3c05a5e0112f84623669358044fbf88552c541f3fedb35179b2d190c64a2b481bd1c8cd1aa919d332402ef924875f3a8dadd398378e5bb79e672e5117dce8e2a67b20754000d7f22b9d5261446ff7b00f5437c51c98fb100a63d089f3f978f6f5c326f351fd50bebb43d5099bd356e7d77c03a2af1afbad9668ea41de74b4614ec7184b5c2fbb455f14e066b9259292181900cb0f499d9c99af66f2261a899a6d941004310e6561b3fdb6c3d78f883000e942fe1697dac53d67f4a09ec1209e3ae193e9ae3a730b83215aee80c72b10bc1d620801d4193f4ce5242a761dbb3e00999abbb206cb53827693099d3a8d898ac9812251d2d2fc067e033c218d56208d314b1f36f9615049d9d8b48382541a46e0a3f10b8006febf6aae68f0e4c917b908ddc2925d8c11e63b78a9f5889e03f07f0a063be0d6ee43199559cfe7538ceea9dd918e97cbebc2ff75b1e0ade1508207b56416fb454d9bcb8737adeade71202893673d6ee4660689f1687037e9828328c59b9626ed853ea9de16bb9765b95904bdc5e40288c5adc0a04d0a0348c4ade02b88f9bca23b635096ee361d7153feabc95c2777ad000b38387c3a208eb874d7834ea86106e9748a7d0680eaa2b54f852920e058b8e932b1ef04385bb0d3559a97cc7b4d64ba3b9d003fc87ec929289d5aeaf1fc08af79858b475e4af2f5fb6f02071f06e6e144c3ed3c3348c642f62f58a056abf8c64a4440caef24423401d04887bde08aff93e1a1e0bdedd43d9d8f47696d18bbcb34eb893d02890f53c50ec6d2be91bfa9f36c0ebbbf95aa8d74241a87e4980fbca129859a30f333d2bef36fea815299d3286a399dc3a71cfb6e6addf9a85e5f08036926b6345a51fbbb889582ce98b07fe71c54ffc1f7dc2a2b0837218f5db1ea264abf82061ae1ccde77b54ea3138568c1061c8545e40e93d547b0b4cc0cf86ce8f1637dd43567dd5af5b5df46e923da94965dfce41ded852c2080d6f2559d979c17df1c894a49f87a303e5746b040a1d317677af7cd407e181d2fb8b9de34bdb809e0a4fe0742aa35519bf1f8df4a242199d23f2ddbd29967d2573763e995fa2350a9fa966b52e814dcc967a5a9eaca53520430fa3a326815bfc00814b2044226530f567a16c2ca0a6817e5dba85fa924624265c394529dbb823fea31c29e4c3fa1cb7981baaef406e0cdcb88f3f98ab589cd4304b548fb96c3fe2ecb3b3b2adde72f63ad74b7380fac71481d9df0e9497191d9727b44bea43ea6ad2963022121f7d8a1d0004d98fa154b03e5edf54ac29a10d6d8bd0137d58067f9da651b0af52e3d4a767535dcc5ec8b6cdb23cf0392d1938e83516334639dcec9d638d10fac8052729232e7c5deeb953164466d885f5d153bdbb13d577907a8779dc6bf39409fe917a282d2cd205913025a1a01af8cfbd936073206d4422c7b0c022e146030e9563c5a355300be51b8a823d20b49c425691a40ccef22e8da98390df0804ec55d2e4781486d76f9b198d2cdb81a79ea33e184a91bf85f34d05c9fd463aac8c11dc5cfd3bc0bc017c243f09ce2fe26cf90c3457274b12d96d5ee13e0139ce0be351678f2240059003333fa963444ddaafa99b4a4112e15c014592d8784c9a7c6ffbfe21cfecb0e0860dff7cee6a70c4601e901504bdb275394061ada47410d07e883b35b4991863e2ecd9e585277b3d400da28698eaf1ceef92c6f96f317e271cf86eecb263dd14b5e663b3bdf821a5f1aad3cd1ca88980620b475203ae23cfd002f4a6eb8347cac0981cc960add9e72c0f208e6e27deb8ff744c6fdbf879d8fc853b51237ef8de2ead2904ec38faad7b9edd15a9f75786e55a15969077c92bacf0f09be288cc60b519f412793cb7e7811db9c6fab0583d4e95c80bc467939ad02d2dc1ab632860e704505d0a96f6a642e052e682150354b23bcad292e5f889553d3bf50911d55b03eef172e3236e85b119eef4c6bc5aa8fe516c81391833c8c705dc9e582d7a974725e694b5b7fa20d145fba699cfb186789e4005bd8ea7fd0746cc60a178476cd9487ce132b92e3c32a6ab3f69cc92acd13bc19b3cd640eb41d92c1107b73f3e4e289ac757c1547f061575e64cc0e61a86288840d2dd8ff5d6fc6c0368588adc3022bbf08f1ce2b0883e3472ae2feec79ab947e9d2e0ca88c3360253a66ccd48cec3bbd89734e39fd918cc610ffa2e39c751b9509deb972767ed1259ec35ab66d489adce9c3e95eb9968080576370c48c4b2b86aeb096ad064e5b5d84c7e13faf1c5443dabafc0d5fd895dbb40e5b63539d45bcb60a5be0eb5ab8a2656fafe7b0ffa4167b0f97ed5a5c01ff8c0dfc5c460a1c4df4af3bb5d09f6f041c3722f46ea49a3f78d2a7027cda6175cbc9540bb7675fd1fe6fe0b61439812dfae21ae652a50de25caf14f8e8bad65779f9fdda68791116f571cfea585c9dc01e3d2858bb64066a47fa717b4fe1b826ea8281d362edbe06318cd8bd3b148e8903cd3042f203b7c5428399aa1b13645895ed1c7d14c76d5aa672e8c024dd4ca9efa7b172c51bfe210d9498d7c3802f8f5a270d34e4f6a8b427d24e6d1bc8e9a8afe02afdc4027ba68349010700ae0dd3d83737d8e5bea95f4247cd4566cac014dcb98b7db471aad0b74eed877678dfa2c019289eca5601a9554efd0e1bb5fd256501197694d68c5c398698262923376fc3d0861005f59c2d5a1ac36c68913067157b2eafc0704ac087825c67a75cfdeb33a0a0e9e458630bde64ce11d00d8e8863635e6028176bf71961de0f8d2ca9281bf79760d0ef12d382c71a5cf175131d3b80d7d3c712c7fab95cb31caef53c4252274ac38ee0e0e22fe61741c0d6b77f0f1321b56f628624b585a9ad15b86cafb691e329b87f7195fb9885ac3ea60d5c730b4d8341d02d50a30540dbee666dc7b323784e426d127abb07d34e44a956e70b4c7078a650e8593ae5d016c308544c46e846fc89c204191a58e18747eaf78b6669276114d7b7e94d8e5b46c3f33cb848679d6a098d49ce0e057d271a02417ce0ccb279f75486e10ce7fee20a988031ee858c6df64c307811d9de8fbfe4bc8f694643158ee9c909bcc127ae456902ee9fcfbda807ea7eedb6b01bc59c0edde925889f4d827e73c308528ce8a5656ff3770568bfdbf045e8a03e750f876ea50e4d18b2bac729cf92b7da11c2793c6363892498499ac2dfb2bada12bf454240d4a45bb3c4f0e0fde44aa85e24b3412323e7f0645f5b0d6123a2f9ef8a83e836f027582a2047171911e231ecfcbc61d9981c5c9799d766dbdbcaa0268f95ad6d4874267dfbc89e45b48ef4133d7cfe99e500f61b15233a55bff8fd69b9bb8f69491c687bfb74b209b88c21ab19a9b24d51aa6ca8fc458e94d2ddce01afd30eff9f496f7cdbffa54854f6e23b88a506502cbb633960414fc5f510488e5f9af7249bcf6d9d965a6bffda32adaf74060118fb4e648b21a307bd5882b5e7f7c0b839394ab5218071a5f4f237c7f357130de1b26b3c27e8f0f74191ef6f88014398f48d2821deba86d09676153f8688538e5cd345d1cf21771513a069ed32b1a1e2ed6d474efba7dca1ea5d9cdb025826dc1b13bbcb56261c6180991ca9c2aabf41e79b87329843bc9ef88c0da1c65a73bd11f922cc0c49ca7ff24737430d4c8f394ddc7adecdd23b52593fa014f3a6bdef1e6a8813fe021b7861d8d72fc3e26f3acfed509f3f6433b0e69473590c55d70288e985788809b5b2ea603e413739f84181e47bfed06a0b4d1728624b3ab2c069f36fe306391ec452800e21b75e4e7ba9f9542ae0fd65d218d71437bf3c909b6fc367cbaec30d2b43cdec58ffeab5f2c4ea569199a38f3d49097a3618df6490a8879f305952ecfd598facfa80c4e3a8533672be43b441ce3214c9fa77d9158b2dee7f2b3d8dee31764403423a1fe6b726d4dbfd7f07be9a40f1c72ad59fe55645fead75359b74ccfba9866720e88ae09e4b69b827820b31b75402530accbe76724dbb29a02c8e1a0b85fad52066ff2ddf41f560e9da1b1c813fd03b257e5e0eda2c4414676b8ff721a1ac1c69946d463781202ba258239afca68f51628e2d12e97038a613036e0242cd641968b3fffd954e22c8523694d97d43e3c92c5c08d8865da9302b5b76c3b78e82c327da16ccb3de52c17e50b6e1a85a17d23c995bb461e490cf5c21348c62163b12743b281b6d08dcda7844a14d95a21e8b66ebc7d71819de9c74705b3b27c4665ba6d5804948c9a4965760c9ad18127b58f40f0a466ee3f39f5846f3aa0f9c6902f8e5f150b860effc87ea6857d847c1962c809323dc41920d6691defd02f1ac4154247a2158a5012a5a269856c45aabab5b37be82d417a67ef9d82b6e1e6e4494d600ebcbc2f3b151abc20be684a5d4dc80cfa0f440a6b06fbb134b9862545c105dd20e93c7ec2259bf707daa556c625ce904ea762b04ce4eb3af0a2b9bbc40d22e1d9e6b9c24342867676ca6ea7fca1567940b2e3371ee9704fe467b057740b6d2cd63fd3580d6fa4ce6f2f9539df22f2ef4b593d5914864734134e954d6193cf13f55493f1532b3b49bf161cdd85225ffcfe3e65323ff293935bc6f5bb3f97dede72a1b7d081c1de18f58641e0b3494cee50fe5e5610e2a0485c2bdd2b605aef8cfe72bc68499ed2ea941a967041f33f02c015b34948d177dae4c8d09de389b26911b9868b7c3177e0e2cffd4af48fb8376f19bbcd62f4582f5dd337e8bf77e164b2c1e30d0375f403467f12ac991c93dca9c79dbd1da11e80ae479688996bd56bacbafc84ec1f84a25ec045dbe3a31d6e48ad8de06318ab00bfba9c5cff0c34d89f4911fce7cd175f816e7ddafd35382e883cec0f67c03288ea760a68f5b0ece01698d5321053dd69869f393e3dcfde0d72668f963644d230a757a5cc44ce00c9de118fe984b2c6762f2df6a76dc1c518f945c37145b142fd76128b53bc3b9f1af7c0fc87c7f196592d5ab734610bb7be4fff3c1ad7450a9106d03d74f1c0ed17741d8ce569aed2f3a412c6088dbf35ea232653e246c7311fb53c663587566d98718deb621eeff0d0ba47dd8b8e57b396d9a10d7baaa5680ca4fb7722d57766e7867059b163942dd70350645aa67666707a7cc1b6dc735ab295be89d14e476c34b9df729cd50f2f830d2ce827a2b0a1a52bcfb9f0342378770b56e2b5d675d8c2e69a34bcb5c86502bdcaa3aa8b77f007f172208da85f52d753a03d299002e0b67c82bcaadfb6d218924ce331582194cedaecd9fa3b8536955e75b02bd8221623d07c5f473db0b7e7652ee44d9cfc5552e7b6ed682ed309694e8dabf0775fee4b4f18773c2ede95ba817a949df06c0c5b018c30329b3b7ae5d8005c6dd3f5b13c26f37575a15f5bab0a34c6797f2c339e604367df932995f2923491800f5533b30cdedcc202576c8ddd7c61634a2c7013bcc2f7a111bf076c913bf93c2c76af15d77f5d704fe1296fe52a216896768de7756a851e3b7fd58bad150821a36a3bb350fa1e39aa74ae5a11f7c5d9664d513ce5031ff6f4b1cd0a8656593aed2a742e962d8f84c5bccc3acc67e3001ba12b7581a0946fc099b9c29547fb54288ee7d63651280105fdc8dff88348098f07b7ca6958dd43678c73bf29b00916ebdbea12ae8e70fea4780f07a94d32270a847c73ac38de97ec2247c1d87c038576f3824a1f6b6efba4b46c80cb6da64cb2c09117fbd1ad299596e78ff4c6a86203c0e34ff74f3e08d2e2608457bbea6d1bcb22f47668230b0fc6866a06d4a99e91e69185fdc54e3b90c644f278b306cf7b4f3f6053d803c501b2d34959d015af39f711210831fd65077ea684c842d3d6d2eb862cdbcf8fa3d05c02054006bdec7e872b256f09692d583e58c955474da6c94ff63f9d5f1f4cdbd50fc13a84483607ad2f47b910093e7a92d52940e713edc7d5b9bbf7bd91eab22fe04cdbb65345ef77cf35cfbb467b04e61772091ebeb1a0b2a624aa37a2aac79ced5ceb9784e28c6c3f4ce2d448701e250071e515b528457e4e6ff0b18a1df3c675b5f665b12493f115aec2bc47d21951b3ec48195e678eeecc054288782f1a684250c61077c6fae3829b2e81d9fd1b356490541c568e4eb1927e5f86957a0f4aa8931c5c2df6403896b79c6141638b92af3078688d635c596d6113ceb46a9e4526ba3a0aa80a9f830e41a3ba653212b34c293b01fe92f87f904a2e23ef100295e10c55227410f77a4e1639e1aa05695dbf24ee19fb90b63c923a1ea30fcf707d734ad05b480265b46a4a083a9c2ef124fc713e3356616e18bd7c4a5e4307b6be7a8e0082b0898d0a252112f4c7fdb018ed92db72b9d8378b29d16995dcd2fc77f3e11c12eb005de76b0139b2adbdb60a74b87b174605e3d0a67b8c3a01737f950e12f80029fda712fa292a11da05b2aed91e264a4645c024a8a54702f9ca035b288d1fb13a2e689e31d30c9808d9ad0d51ef438a620ec3748ab161a2f61aa92c4484968c96b7e228f47389e95f4694bcb3e517c1c8a83ff4f7d3f34bc253983875ea681339391d7e5c947b155238a87779617afbfd68a9255539a48750063eff64c60c7b54572686aa73f4e61335c9c7c79922a361c8dd0016f32c56858b38f3ca206a1b51a869a44c5f05485b103188aec0db46de744330425515255ad31459a0257809b9e6e17846c7f5be3fb7b7c1069ad2a00f658d8a5f479ed7db777ca697a0e84d4d8c17afa082f4ac6c5d7c98e56e624e9237849fdb76d312c01529090e9303c1c0b22fa60175e8723c10ea7c82a18cd258ba9f39c2efb735b6534522695225d3047d467e5fb03ab69a78ae0674d3ce48245988996b4a40fe1fbaa45b71acde97a45556ec7914af184ff171e2f93a2dba89512ac41f1926eb3d7c8e298b82aa8887d7309f01ec7b9a32b67c1b2916abef548ec495afe47fdc8de1b8bb4d853036fc71b63d17c0de18c78c7a28044eff796bf111346bb5a7f8332eaf99e4a5506257b9f65349b7e4e3219d09b490a7b7b0f66bd2b0ea106fe1613a4093c48d6fe8d2534d20c6aee8c0f8036a89826c60906ee406ebca501e3e84ee4cab03ab0445b070c1edd9fc5547b3785b198feee420f9b5c390e5dd53b8fdf13a52a54e044238d314a539772c9990a1c6b1f63021526a6f06164b71cbbb23d30277b6922acbdf9558aeda6580f5067f761a62983c75244f1076c1a2def5e1857d0a2e578ce35bda1b8f3d761bf1d6f7e0c8476ba101a0a346237055f79d2baf1907ffbe1203833bcffcaa5d57e9ba241e63dd486bcbdb9c19a41337b55d23a0a3e890e9baf7bd7be20f43c92872c31abc0104bdade96fa811a178eb873fef23b3760faf12f8d88924a5aaa272b9a30fe24f6417b5965e4d3e627868754d29ad8f542da38014ea87412d66183c1435318b58f321bd75066db4bb21dbeff4ade6a6c098cb22cf50c814d2847deb958615f15cb3659761e51c89ac693dbf617a54abaeea98a8dced26ae950ac033718339dfb12492f754620bb2bc760af02b1fb27f754a537c53953fe5ce9d31fb7d756ba2bad8e803a5a891024edef6f004a44f624a8dc1e7794ad8d4cc6343797ba794bff4886ef5fae6d787ee89aeba94cd7f29e640c9c44c3287675e82a8f1b6c239a6396e73eca97a172d17dd3789188b7417037960ffc5d3f05e6eac0ab9675a10fb73f558b1f9cf8e0e1fb17ff065f30d3cefcb45cd31e6b96bb33c22406e0d0ee80cd157a17ce053904202827a0cd83afaf31fd8a35c4a1552efa1fb15623a1fa0d1d4f05567c1d2710ffdc455acaf781004b78764d95171a4a85fece97838bb7de07e476d1a5da35c2955364164044bd1ec46aeee6317dec366e3852c4193589c742b0fa4128eba63bffcf348d8e1a3454aff54bf5fcb4268c3775c13b5cb9f5725ef9dd9d949ffa1f1595683511a9150ec8170dc5932dd9f381791a9036b35e524124079125bc35ff6b3d90a3903c6339a8c481f069af4dab8ec333cfae615b91be0dcf95d1075dad72800b1508ddbc5fdeb62249c1b84aacc20d4a7d1602947a7070fc7456c23835b5bd11ce16ed6e70c2ddd2343b64435f77dc4622c56e6d3e6c7ba06104025a8dbb0b1d49896c741542eaeda5f78e5f3f4a91e82d1a95ed568ca35c6a21cdbdeafb832b7a8b355407a516c8a396e20cafd0244376fe668b17ce1af6343ce89d6ff5c4ae7a876549d20f7b8b6ca6a29816c8bbf60ef00139a9dc560c4d5817a5f124a3f5260447f2899f1cdc473270e9e51501e1e35f0656e146b8e9d250a3eb3f6fa6dce0fc8e110171f5cd1fbd34816f17ffbd6d5df974d6063719cac1d04223c986820ab1eafdaf616baf642a6ddf7985f16e18160590089f04e5a975ad412f8eeb8d73baf917656c561370d97687743dc853027764e17994a59f7063d51d9c02039c64965e360207b37b8368a0ad1cb97266c43625deb8c95f28d362872ab0ad9583a2aec91855dd956cc0f34317e872d5f1e1046e721d541f87ac5a0acd90faa60cb8a5a092f55da0f1749468310b9d88d99c2a5d5014fd27458c3713c05b7bade28c3acd4179ab352387a93010775df404b52e62019c7c3d8b98d847cc95bcf921357647273b20d29302e6a2fb10d1f083a08ed88f5542c7d0e528bb7f5df05f1702e92d104442606df0551dac7767368972a92bf946a047927e818dfb885f17605bc328b4a5a1f90979b6fbd5f85d61db6cca16414d63c242cc8e847a727140007d683a00163d41c1e22e6ebe92f3bcdca664b96af935dbc1eea267ef437c7ba5198fa64c0b322eca5dd8523415b1a28fcd8282b72f204e8521c69edd3a9d8b7b126358d04717d17f16968000624fddf677cb37badb466a827bb2ed2e1118bf8a7fe7eceb8a6e2642589f212d5cf8ce702e94ec2266494d1cc25e325c6c33a98559756bd5273751138b356385b3553a56cd119e466b108aeaecb30295fe295f368aaa115304126966fa9a4d9a6cad681e9b0495272a0cc4e8cdaa92a1b21b92b9402e77dc888d75c4da1342abd7d73a79c70433e39f3b98ea899a187f05d458a2f8fff4637bae69ad432d4ae20f94703742fbfd676b9d1086b9a0c20ebf35ae5ff022fdeefb075c25b4c73d027193b62f7f65f8a0c8028558c719c321316d04f15c2f5c3c964f2c3f708091b570814d514fd97cca7c7ff2ed3f0200be6e5edb8a1a107eb3db35f5fc7c7bf329b30a7105b382127e842096729af37429a594bd0c1f7a7290c2845e9e4621839ef64dae0ba4f8da92af6cf1498b48f05d69e459d41e2643abea07b0498be3c1549ceaeaa9764108475a8115935af4dace70904f40daeec1856a97f88e4a58a2ad42a56365e50754619a97346552421fda4d4ecf86ed401386601ee64f89c06d75329d7abd84d8c75dfad5c134775e3239f06a85929199fa47e2cce96bffc99d667ad92267d086367a223282369c50c14a2ec4b237eb2f5acfdfc91b77d1e485227d44fbdacc643d4f074fd49b56713d623abb999dde5feda98e5c0fcb831054bae54b9ea5cda33c86eac205caa7497b57c7f87fbbb71c9d8cdb88abce8065a411e79197ce79c9a8bd911767a5bb51fe708c7d84e5574422c6b240e6848dc41fc5cf8cb10a95ebe3e7d1e6a3bc55b41c42d87b42ad710161e93f48ecde12f7ef98d8fab0695c91f073ab92027dd4d09d646d025d64e2c2add2d0beb7b7d5c85b9bb3519c85d0158bde2af150f3b77225c198b8175cf727909ffb6eb872445d2ba329b8d5896e228249cd2bc296d45f6a5a043fdcbcc293207e4ceab0c1c1896176230549c1ae837052b6eedd08c8196238f09e7a25bfcbeb4976824657266421037efd52db43c7b8fd9c9cba2d51962fda6331b4a54dec7bd7d368a1321fa148e445a8813d5234719104792f1fa63942aa6e8bd28b671e043f859ce2f149b39e864aa7bf19aa840e49cf4ef161c3dcb8e1a3c8d042ad2555355bf4647a6ac52c8ab645bc1486e687b04075f28047b8010a18c116adac735cf25e94db3edeec897b056a9bc057263d7865e06fed1da9cd0c839f027cb161a69891e86f6ea30808cb2bc8fcce3a6132a55927e90aff754a30d3cbc25fb78b3ee909d1b4f50b7075e22373190f3728962f3f19f1ed2b255f7e8c11f366639ea75ed63fea9a8119f847862413f33a0fcc7ba3967a0936b3046919e4f589852387a102ba72a6178a5d3f9dfab50353ba8ffe8098cc5aae4dbc596710a9d9e28fca21013b66336a4c3ee6b4682ab1b5e46ebbfc5cc3633f1d04d1f8035523e709a307fdd8cf3959fb3b8688915e06b6f8cc0395b886562ecc8a740561db9cde6beda99e5ee8f39c65c7e29a7d23ffd503aa9f42482d2dd02ff684ef52c05c3c1013c268354ed342b20f4166c8ed6e9d48492d9502c51de8f02cad8568ee0f1fa4cf2dfb7c785d3dbefeb081ee3b0b516d9b4ac312e9dc17125de12870e0a85ac3e93c024f8854be24427996d161df7d493866ffec0eeb6311e84049c86b2ba44d421ec885b26bc24e57b3d7321b6c56deea00d1a1e32908e0d45257a9d3ea899fbc9a8ad2f7858468901a40b0826ff5f7319fc3dadbdc424cd3823d9d17af1d045bdd69b920a9f803e7e30e1cda44e5a3f7ade9af1a10e4e210765a605cb447c490eee248076ffb695a8c7e057eb3378e24d77b8d13adde24c32d4213110f41ebf7b44d5f3cf4bee8c8c590d4f04c20a890cf60dbbb7b65f48a478a3e38412bde0fe42d0c8a9a8887fd09e151e97b543cfd52e86576e034d1ab07668654b01abd3d919697508f564f33d97cb47f6600715fc127af2195592ee5c113caaa22c5413013d683ad0817f99d60e7d69be9403e694300f0386b18246f86c3f5f97eb376ea366f36027823ab51fecc0b78ac2a42851271ad64c4fad44a81050676f61961cee214d544099d745a7ee5d2e290b8b7f6da38d242d84f0c89c3da0fdd42796e65a719c90f22d35caf218551c03cbc38aa13430a16b5390e02296b3816b321806fd28792e68dc3021825c81e74c3be86ae80424ba58a723a2c3f56ea8376235980d3d4066425e8fd664eb107bda76702f63e05231e0660e7a530903a30f6c779cb0460841f54f215c3023789ff8e4cea2c478cdf32a2a4afa2df9395bbcddcfd5b875d0ee7f76278fb5f34aec166d450dabebb317f8511da0a5d76ee7a6a33087a525a0e9e9beb64b14a401f8f26d5d9ce5cb2459c74b30b5e2b6436e2b074a45bdc54a92ba9454d8fb78ebd7d8318f2567fbaf00974957e437db5f58053b138794017de771b8cc5b69dcdbf451346b5ed389423c2320b5f6f7c15b6254be54d6955519a49dbcf769585f8c21167a37fa583153b8bac3910150a618cd4666a21a680ff59960566aa1dbccb587bc71124f784def91888fe8c9c6b229a47d60493351f5793b041aa06aef5bd1eba94db9cf15226801f97203b1ccef6b7932443e715d19ec6d15479fe3da49b852ea2bcdf4b950a328039f26282374154934efa272fef83f7b566733a80456a017611be3cbac1f7d3554ee7a8a29350a2746bd26c3dcb46b266322857dce786f930600dfb92ec13b3629bc824272d4f709b337177b088083e3913f16d42bc7294608210fecf888cb0a89fab8ee59ee55bfc3368461e68ffb61765d167f39f034028a777926b5c3e066f934b0484f9682990aa1d0c65d81c8d8237cbbfa3fedddf73f75a1e9b03e4e40fbb7a8a15d092dcd43c0a86f039ca1399f57b1173b93353b2696601fcd06b74f7b4ad405596f79020f05aa07e22f5760e1bad184d3678ba43735e34100112405bb5f42da9aa3589dbdeb82b2aafed138d53398900ceff7c39b80e9ed25fc01d83db3047ce04779c3719806f6ae6ad56ec4fd4b8c6e8b4737d674cbb60a7606d807c9b1f88b67d30ad0f8816d2021cbdef801e70115e2d40f1d7cbb002fdbc7abe7c4189c572f758c2dcec8189d1c49e35891aa188ecc66b9f6d4393370e536573da525108299c9fc4c8108e5c766cef666cebe84be3b6e33b464fc8d3169da4c0b5549ef615bbfc36edf9b1baa072bca64f6c80883e43c426d9d55f28332201af5c41c3ceb0135676be574d8d8846215a0b9d4c73fc476244cc4931153f6ae18e38ac65d1fcf44cba0929564b9aff58ce4cede9c619199e07ff3414bf556fda0e0bb78dfd567ae7bfb104873da16a8f45b568f14768af1828c9e4485ed7b51423cdf66d0f9f94056b3e0388a24773500f42562829116659ff90c1e89fa719d9a544554f19105fe1053d10a26d6e2f8083e3034caeb8abb7ff13cb35e47e2efa84cb92e323cb77c0d74722559d912e2cab2e644155ddd212fe3396cd8139a50369348a05b4459230951691f94424ab941de23f8e299b97e68437989a317b81a40fc2590755ff5b49ae818fe1d976585d3db05b56ff3591b092b9d2fd35d6d89bd80489f6928b62a82e2a2b5fe6f8380def1f0b6f87c8246006c0155e2da196e6b09fc4800845d2e358bdd18acb5f0a2e14a5dd5cc0c1aa4c632dacff0da82d931f0ba166252ade7a466d0f08ad2802a6d65f7423d86e25444f26f9deee1b2bcfd369c82b744946350a38b573c83b8878a73621c8b7871a8478e76d91326decf774ddd20c57c388236a61d0664da3df12689b3ad473d364a676d176b41c084dbc6beda1562943dc1debcf60fd75b614cfcbe8fd2b5e9e0fbdafe8cfbe90c245f70c13098ab030b209d00759e3e4cf7ba4cd14c15b7152984f042b244f35e037a46a301a0c09927acf5fce2bff681fea587b3a86accdce2aaca278a832be8900f3ee3ca0ce16e839dfed88bfacd4f317fa7bfc07d73fdbfa52956d0e28c89e522948130b396abc55ef0cfffcdf5382e15d5ee822fc1392ac3c3233cf4b1c95e2ff6ebd307c539ff98e2966aad1ab7f2f1d6c53842b23f9ec12697c48583d375690ed9ba4e7c7183f9ee5c595ab06148a46a8103c4603a69bbfdf540bef06a9f7a0249c18fb7fe6874598fc69537d2e6f3bb30a3f12498c6009d213bd266095852684e524d727873981f1cdd6832994856e5bd4836e06ad5b76d1aadaa6f80d9678bcaf3516e06e3955be523916408d5d3bb0fec38cffee2abe47c3b1e1764d008ae16e9d3229b682a99f51b722d1ea797859ee92680040c03341a9811e414e8c41a8cff61f34e52d4b35240ae48c91b3eb6ef89de9bdf3d108f6c0735cf42f55b93351f70b302f01008d6a0d4ad4e49d4bcde9281463baba8e1879915340c1423d2637ad420430981fcfafeb7446defa07ff6dd9acd15128b7a9955a686e035428a5ed16767a99fa29b6dfb628a98246e44d4c672353a04655f2fa33d55110988681dd6cc0cd9fd89dc09925d5d97a26d81df3571c2cb1418cb15da8de1b9989fe58933ffb6e4efa90e0ca174b30e3040d655eabf7963f514b15b46634d6be7e4d50092a1d6a1312aed4a160cc46840b240909e05e1eaa3a912180042a687a2bcf5be596a3c42c392df499654a0c0670e1d12bf5b1a223069691358d03283142ed9c0d068b14f3f67de01f272938c0b80c9d870406dd09328156f509985ad846191051694a4ce816a84fef02fc1d48cc2de53728f3f72ded2afbfb21b791b1b4396b52a2d165bbfe77ddf49ca2fbd760231d2dda4b06a6c069a020cd2e3dba8118cb24050aa0a56dbeb359213fde6ed3a0a547a84ff376d91869d2afdc0aa162ad5d1f708e6272d31eb9327f41852e6b56bc710c74d2bd052be75b7f6ec8387d0afdb623ed44451aff31afec68e93fd63ee3ae92acc401fd7be1027490afdf5344cf383531b84afa770ae23d6154ba220522c77b6e9dfdc8da988a7206c8342f64f540922e2d6a12f250c61d3117094074dc9d1a7cd145c1c43a87a077f2ff378d58dbef5098bae9c63d095721772739e349afa76b9adc9a2835e9780a65a650f168bd78521a23ef3875395e2d299d527a950111ca2c583b94a58cba9538497ae35534b6d172982dcc513d60f1eb7418ade70ccfe464f4b28c88f7c03d2192fb8ef1618ad226ba809ba262a3777a8462ab9d353ea157c885b9599a22a04c175b35f1e29c4526c67f8f8836c16727e565866ad8c21ef5a47294efb8c938601b6679de7673819577f338af946888e10d0276ada0cacd844c0381721ed6f6b40f5a8a6d775627303a2bfddc4471b74009c05af2dedaa3481cb6db76e59f567c0f7f3f76804dcffcb485aae9a8021c3e60edebf13d9cf288f54384c644aed4088d52d9a47f5011eb5f22a7c80dec9c8af96c0442f52065b3eb82a690d4bd0c80cbc14fe3ec2408fa0d0d35241d5171277885b141d349153a5f3f384c772ed8176eabb3d2b5c53df13c087075f30695043115440b51041b41f67b492165bea4b7fef6862378c2cc6695d3a86a991e300000e29c4976d967ff3a26360b2c0fc386aa600b63cb8b7d7b505597283e3a7d52647c7de713c5b839fc0da5513b99ea7c0f0274bb9deb08be261ed016ad12a9f442813e887c198d5bdc0c8a7b1749da8469e47a99c259e0a829d367399b045eba6770b5dcdaa61affe28b2bb0574732dab6d0d248293527fe67c278eadf03c1778d25c9039e7b0ccb53542b5a551e01989282331fe6edd538b253669d5415261700914afaf0bb1f9ae4ef01f83687736ac10000633bfb446a2ca1516b434c9b0c5542c56c6faaa7170e6661f5f7f155c123ceee8b0a2dffd1ca2eb4837dfa754606e5155832a165d8d1fc4fba77539886d7ad4aa3823a8d3ec3748cf285a60e01f0ba27ede1f13c1d28082023558fbb8c5aaa97c119254d9ef85bb1cfc20325bcba2595d4e5469c66fcd56076c19776f0f2a85899a64efc7fbb4d8e7e31a9a8a10877eb6139a7f1a9f7f8d1d1dfb188f06aa248f7a55240e6cbf169cb2f8c825fe6ad593402d8e2948e7e71bc21f91b808c18883cdef96353e55b04dd98b333c3e8a3075ed64be5ac6cde2e6d387d1071f8dfa062f00a44dcc427d2f2694f8953a97a23aef410e8f218da39a8110b86c9ae5ca579f72e06aee086f571c6cfd2338175088579a958377c190a4b250411d6a575879849a1d1fc3c45889ad9bdf5d7df51e9b8d851c48c2dabefe1692c81e1ef1b15372d60649bef78a852aa94b8d6a74276c076709ee50d6bbd626d4a7b68b81ce3a0b86fa5b8db8a79d1811d817327c04a04491693d8d0c3618c16e8986fa778b8f86196cdf3d8112034614f24bcc9dfa6b8320e0e6959bb45e48a894dc44736a6a378e869c3db58e9630d5bc17da1121cff9ab143a463804b601275a464412216369a670776f3a2524bcf0e1a357e88eb3933258c6fd47546c91d27924a875392a12d398313c01f339b41275607fbdc57e5f800d9ca3eb5fd6a0a7866e6c54269369088897c59796f8497c6546cca7d8215ac1bd34014be3b37226f0b8fd7565474a2277090ab44a05d8bd80ae1e4ae58848e26598ba5b2512c8fc89a7a96f496f685e8b0e2edee3d2aadfa54d1edae09096d0ce893c9b7fe37a198d710e3a7ef45f9220c3a46a66efb0e9ce1f35f02d953fc3cf276bb53115606ddddd207e39a396288b019e54d0c2023170d0c54c97a64f8c0b2eb96cf005144cb9d4ac300ff4762429dbc24ab3c008eb569ccd9b8da60b75e7b7683e889a7e99e7f3ee6b6a24b467e850f48bd4ba81bc95b0e3ffcfe1c5efa67aefc67bc2ae2ef32f7726f5324a92603668c72efae8378c4107d7611d39d3f41bdc22d0a29b79f3a06758c1a7a7cec5dd907f33e9cb5ccc0eb6f99c5e22581bd95dfd3b6c62b0adbdee3c3242027596e155d896cd67e1fe0e4c1fb46a36fb3ec90ad46103ece51adffff780f24ea43bbffe6a08f13f822626cd863b9ab282097a47e40b28725d2f74e57cc43ec73d79ca847f6c3d84530aafd225ea02ae1590bfcc8bbbd249b53b453c2777eb3c70f8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
