<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f729bd94f41bd65f6851353bc7f0cfe0c1c0a1681d36235fe019b96b9f3d73c74112edba2f91700d2e63387da85bcf5acd4e54ef17df34bdfddd52540557b2a3a2ae294c3cc6ab587283c08a34ed3939a6eab6629b75cab91e3dfbcff55dafcbff21eee4a9303e008609163b6eb49b4f8f794601731cd18b969a5146e1be44ea5d8375e9ba946e47634ed4c187b328724150ff4ac0a45e45b6be0ba81735dce95ffa534c481f32d59ee170d5374b93f955de888efe8e792928d44e74cfbd372b85089fd132b1d94a29d80228293ef9946077bc174b3add6546f89e1edfa12aea40af6d2b4f4b9beee3f71227391b7512b42a0e2992d2c7fe8ff5b9f0d5dbb9a62d415e77f0a60b389d5706dad9e4e476bb52ddee1ef3296d41ec4d8011ebb863cf686930df132760ba924c37631beeafcbc3cba90150554c47d0a0b47db2681d969628f16f4a994b1e7faa50103bda0e2006843d18834c025909644782a951db65a27c629335ef3aeec66566908fd9887bda03d818ff817365ad44b96544a516c27edceb6950f2b5e0de7854557f3c68668705cdc958cbac36783437320f26e2373236e647c8d405bdcc2ffcd85670ce55471ca42d617e8e48b27031443a5506120250b8834fa19ffb50f782584ac8f3d64e03dc0ce8c7f9cf7b4178b5bd89e55612cb6fa7f29f92b2953b109e63cc474bb60e9d0efaecca610bbcf2561ea32617ad766f956b0daab32cc118f1a0c218200704e97029b268142c29e0a0deb33a6a0c2b17e637b68040d40b60d3c1ef65dabb1ad50716f33c34292b4a310af3b6b0aabe9026ef5155d35c8d1d22b762432184fe541d28bfadbc23b69015a1206c93063449538526a10e06a5d286b567d451ce906a601b79049cde948bc19fc70fd4efcf89dfc2a1e9032c7a4f7aad3763c1a409eca95e6c1cdec04bff5af37f406b4ad48904f43e180d2fd948bcfacc75eb94c8d7a5da8e0a835178bd6314fe61205d466a15b38277143cc29991e0c82db31902c2bdf5f9e5383a4386f2fdbb77252c16ee2a99ee9a3a67da91ba7142b60a714bb59d5d91b004ace11a8444bdd9f0e4532614ad7db3df6aac70ca5de0d261fa60f51aa67cc56196c97c860e6bacfbf41fe4f19c3d0bb17335986ae723d28dee10b7b370d117388f4e48b8152677054d53807101f81a70abde1a262a5f43812c7b2dcc8a23aa4eb3a3c0b7d928f23fac302f3529c573db2a0dca4cd5ec06e493ed4239803e9663eedf3584efff09ff364231416b12b96f4d1e02cb48fc626a9560f5fbfb2cf1d09312fec4ab606bf0daa5c0aa9b5a703a3702d9165e003f90d8c08b655c7424a7af97a51c379be88b17f9b8ec8c957f08f56b85aaa77f4e4f891cba467ed705088d17c7e611d50ffda43d4fec8099ed1115548ddd77e72434227e6f01403d31ac8172331903e5a9e45a2f0da614d48d64527625b2f962934855f2dd38e32a4b1db8f83c36e8d0360af80f36c89f5fc80f9b308bd992cb2ead2047afe250470bd6817e56d08cafc2e1d44f7d159ac4623e2b0de725ed449953d47d78cfb62149337601989b129a05c982fa6ecfa62563a768a7a0522c5edd02282c81e9b32b9e64144fef51346e554f705e4a9225805451fcc66fad1fdb496107aacedc9f679d0f892dbe811bc7d6d0399368c823f0338a8596766ed56d4d434768984285070c47152e0e4ede13410e6186cb4ab7baa1cce27b3d688a69255be5b5370ddc117e2a783e55b86c447f9158bde6ed90c2b2c2c7e754f992b596b807dc994b6b66c0f1f953a2fa398b0e76a073176ccb367c312a8f79abf26a17472a250fd6205f373971e0ef8bcc8bdde3271d5d56dc6553bc28d029e3ae135657d5f03d595d6bf1353a3fd4b82603ca92d3da784507d03775e5b4020c99299f44ce0604ac1ee3586839d859c622136de8db4c1e9e613c488997f7aa921cb6ea99fdecfed98e162d18d6668b516a783e7735f08d9a4906b401f16c5be1ad38ac547e0a25b33d773e7785181cddbe9a9d84402cc54b0ee1c1dad74e02997bc2bbd69a93f599f5ff7bc233f46ecbde6672a456b0f55b0992cd8a582494b2c602ced3efb9a596d39fbefc9a5486496f37bf348d9aeb64e34cf3a9554dd5f69686aa1ad2a9d81ca1168588870363df9b6ec7d4ac1a39630338a71306e963f3289a9eab457597bf7a70328bb4887701a9806e2b404e6cc8ea86680d205bff5620741451e2c5f28e3670b0bdbc0013332c9a411cf60ea935336c795d0e97abfd43005c645a5ec4489d907da0fab95c7adf9008366a34aa432c85f466eb5bfceeea2191aed261aa45bd83d5e36a2c6b40cbedeeb6ed41451eeffb959e80f7655395a40075f628bbfb1b3b2f93f2bc8a863ff5cf49e97def22e154fb1fca2eedb411ebd078c4afdf1fd5d5a7ebfc21f708f2dfb3c46b961c5e8de984bd97ca6e75fc6e595cbbd8d3d31f07eda59cd39a1bca038ba18bb7ad7c96efcb871089122af0d45af088a5e98bf7596734aa741a0b79aac91c07eddb8f57dfd83199613ad35bf57343f9cac7aca097a111762d0ad029d755c817179ef779c3401afe5cee33cd0c8b2bb850bffa366c72d5f178bce6e804d16e14ec878d69870fc149d98abb7b8eda98b97013dfbc83115f3b3f5dff1d50a962a6a65806ffe5e7795fd8779aa30c1fcb30236eff5f1638a0deec9c2833a6f7aec5bb0bcd6f89aaaf3be3507af9a0f340e69037300613dbf5620e8447bd68b7c35c42b39cbec2125415acc32d1fe4f8a1630db9badf80239d56fde534060ab972049bef4d8f0a94fdc73a457b7e711271075b72ae90e7907aad90a9a7911895b1847cac42fe6f6738173174ba19e8041e13d5470d347cd26a69eccf348974fb0a45de4f1b6c43b642e43913f8a9aa0f2d2600d58ece626d0dfcf1818c878943ec0c0e40d144c1128801fa7b945137df83da82f500947bd9f4070c22bb0d7f86df406bf766027482fc25661a91f0c2e0a717726a361a62dd874108403e0969a2e51d5b18c7afc0fe2b6e29554070be68ae7e8eec272758b26d81a97fcb4ce4b5c6acee1926e934c627dff2ee6345081e1f4711a6296a4750939154a0e315405225f34000d7e7f36372250d6047d67d5055e12db4f4140c92d0f8d7c246bc1bbf1fa8d6067d7c30ae8db20d507a0097989842fcfffdc6481226856e0ef29cdcae38e57a1c41af8f0c6f8335119c0652c1acf7b3506cea10d740ec33f39087605c85764663669cf5fd20a773de6d9c73dfeab5fa3a8117dd9bf22a9e8d670fe2aa8de4255cdaacacd314e14b5ca6e4d2a673f810bef31e95b3e1f8c12f53788a0f51636d71012394666bb78e5d9d810cbdbb62fd0d24187731849108a066e168ec3b582fe57a9fdb72e8690d42cd15e10c4cd416006a1f6a0a0166d5428a5971ef1cc99b4f43b317c541bd7691fa40535d1492691546a5af0568f7d0fbf857c39304e68e7d028d8899b6f1cea1e1d9372028ca32a6b76bc1ee42e0c9b281205b8b19d7a7d360017f432966368245b6175986c8399ae685510061a685cb46a2485f9fb8a5e8d50ce57bb733d54d7a8ac934ffc18c1cb2602aebb666011716c8d6072ac641a8e1d315c49f715f98109ac0e95e8bcc13fd17ee4298388f3f5146c1674a2d8989f8557b2285439e3df3fa60b527a0705df7a55d06d1ab61c45a70749db51493a173997d284d5a1f783f462df3ce74a75fdd30f110c1db24d0acdc19c90f6d1f15c74a9e752764ddaa5f5f03590eb97ca8e0027814150533da2089d565ae4753120d53e4331e4e1c0ff16d9fe36d614c97db53928019bed67902b52dd1b705015b9a1354316050ef52a6e3eecf6f6acba8cf8b8c5a58f57aa8f76aa0cfb387b106dde656f8ebf8526f83151177cfc2bb748d5113e5c58fadf54200060de0f313cb3354d66fcc334fbd835a32ef73c341ead97026ce216c8b369e0b66a356ed14147c2863f050869a4e1b5b8dff2fb1f761fd8fe6acb30a1c97c24cc61731bd899df72b8d7051b95c9a0a2a8026e8c589d64985e8aa67964297b08aa4b2371d8e964400b32764b4bfbc3b77b086deed0267652787a498170596514f4c2dcad5ce2412d94d03499992d8e47d121afa4b624dd0ffa63173ad53db5f4a8e1e1a38154bd8c86019835c9ecae8bc940fe20451321a9f98196a8cd13d3e024e28535f155a4019b8f65facc87158941eff946702a2b45b7d962e47f9cdac2cafbe711be67598cbc3f9f41986962cd439adbb18fe5824280972f7a292bb7905dcba59a0ff6871d1784387a19fbfe39c5ed60a50f705329a5c281d46e62ac7484431a1ebb9f798d57c1b5e9de5fdaa45ce9d1f8e30659dd280db05a73171ea8eaff6d0add48b9b285384163811738ee41c38cd3fe96758fecc61804bb3075b5e17ba84ea9583f95b2e4d6f7ddbddc7f0035b75758e6ce98911a9d41654231331ed49955e1316f172aa70010b938edd78c7cee6bd67c386e89df40ed280665eb1aed1c78372307f37cbb7aba92cafacc7b96541851e9b9fc682638c67a1018dd94cded216c19933ca1ee1c4723085493e9aa358520cc71b03163117e4d6783dd1f6cac03962480a053a68fcdcf40fdeeabbf43618eb7e404a12f215d1786956daffbcd9b25b3f83c80dd158a9cb689ba90883f9d6f776607c4a0cf504fc2ef036a9827be8c09ab157ca1bbf8d500d11f824426baaa697d006fa7728502eb1c6e2b3832703b168872f9f61d4387c544298e0bdd3cc2c254de7e9a476063b8ccf9dc614885491cc229137c222f93974cd0b2028b2ed82f5d30c6b784f135a53f11afb5d9c31c915ae979459598558b56b599a1b8c441541c8eb34ccf2e5e80691159e926be3ae42de5f6c47cbd622df6fef70cf1c74e3ae5531974b6e8ea9bc16389a62e64ee0496f7d18e00c034199b4d663d183eb9bdca8347a4c6740eb44e7d719b90e2c722cc86fec40b416e2d250e29729114fcf2302aa2d1351704714b670afc9259a87d710ff2cd13bf559c7ba55eacf1ad8a1b41f192df56854efac8fe97953c0db5a96cf4ccf0a183e2a98e39841b35ed9775931327bda015087a3ee15809077e7e3cdb66804733bc14ad896c571d6444935bec568e08cdb56f801db2e7fd6586471e5e44508c676da0a090bb67e81a0b43dfda9d1d360d4e06a38a98ac98779cb9a072bf20c557e693d59eb48bf4eb77e5a23ce0c55067b8f0b23adfbc7e83d803a0ee925905a76468bf26196026c715dc1a96378b76c6946627b4baa27da89abf9f702758d6295a98af6436e21e8ef9c92b83042f48874b7932550809256033ccdcd9c12b2bc72a7d909ddf397718e528a2142e487fb75b8137028276ad131e3cb03c149147fdcf4c7adebcbdf5ed17dd3734103f3fb651c883e9b2320f2d8f406df5d1969e8d43d6555a446a7bdb2464d0e9cb7c4075c04c951113778ade8b7a26ba9e5ed17bdf6f19130c565a99f2567bbfcab71550e9c50ad3e2775d17a8858f94a4903e3f3398dcf8c0c605ef8131b60e75bf810b97b022796ef68f27124cb4382f63fa70e063a71a987956af282725f2e52d4b5b8ae5dbe8ed7bb93f470add737c179d030676821a854a367ae5b4e7b53c29eeca625850c618719ad72a63fa1343c0c1806c85407c7db23f66a9e2532f52677abaf4ffb8d3ad5c55c4c5a5db48797239339e4bf2aac6c58c100f14bc424396c14bf3c4ede1f109c52f5eaac007c5d9d0c18f4757b1a224eb0e4f455ed1f215ee334f84e1729afb605f4395e0459685159b962a3447fade42f15d51c629121db68eb6634cee225ec0898e8fcecb0f89a42816469f00d64855fe0a92b3e04ea96a26d3ef033ee089a1ab41c786bb34be81a8cd0e0ba680b625ed16aba9e71aab8fea705fb63ad716a25816d264b82c6c671211a448aebb398b8b977c7fa2c03e023fec02d0edca23eee73889a8e2315787530579d18939fe59a8c755ddec0a2f6c25351d543b1659bde52050b070a65829d35dd16d93cfc93d47904d6f1a5cf9260a1d468945066b63f94f760aaaf4a45238e31e252a270a4b71afe4764789349958b755975eaefc908a4f6fa19fbe60ce7af467686d273cf861359b6ab7ed5097eb5a6509cd7c646cf6b9e8d1d93c72739ff1c2adf721959358ffa626fec4b575b2240e8006ed6a34ea5391d222efcaa3663feab4ebbb2c606c89e33a5caa63face2fa57102f335b1407960e357796771fe5d9bb4cc1036c4a30ee54a741f71a2c7caf5c79a1cab9494a32bdc9bea3b95d06d9d1e53dce57aa061e93056ab2aabb6667cb042c7e4589cad88f00b2e3a60589059423d91e917b5372b0da5d5f889e838015bd8a1c7b105fee6de91a3333d722a7f2a7f5e3f48924286c76a28a036c8396d562a3089b3efde3ce444cafbddb5cd2a7d541d3787c0295e595219173cb873b2b8f3e7b5330958666424c7a6e63372909a084160d0b3daf739821e70efc4407f63b0ed16fd0bbb88aacb2321c2c6b9cd3cecdebf54ab5765f015d7dc7a11bddd5f9560dedfb83f8e18fa6b241f9e7f5343dd5e32b936363d9f9838d7af2d889022051b496d453c7ad2550eda34880bb007ed9f711d1b3a44e4a3f736cf7cfb3aab3f3a63d9ae774d4ee4469570197d80e578d65bf326225ea714739de53381421f6ab561f6e087e915c34a43a0b444b49a6a2cc681aface4e6b16f9dba1991a0963b7aa25f06e43958883aa56d7372fab2d7ad14a4d475ad97b29025f98c52e60bbcfce6e211e6700363f7abc627676bcc99d802e2b4fda3d555fa89f5f4aeca6edea5e666e865654561dd5ec3d5dd6a5b7e1e1342ed3fd78a61d0ed891c124d5fbb87d9183bb4f66603cabe05b1a9cdb6a65e1ec1b796116a12fad084bb29f22ffaf0458fde0bf5a1c5594342a19ee2d08aa4e5f670566d7ef1fe4379a7b24dc07351f951add22692a9890083d2df9e2935a84ea026adf6e961bb3327d6732bc1d2280ada882b05e2f545b7bac6d79ab3498c7ad85bd609de0d451de9cc95b592fa66744fdb08945748e7570a398902d4be47a5bab93c9b3ff2580134f81e20172f971adce3648c2f1698397018fb62d3ac30970e4a95d9b91bb6c9472440f24fe827eb11dc510e728b8c467e468df216086fb518dd5920c2d7c4c6b36fdc45cf5c5bdc356ae011aafe3be21066f8b4ff776b23ad3eecdb2bf63c639a659285b7d5071d8bb9de942e50b8926452b4f3f7aa862db5456f81e85bd69ac061ffb84e4597d3bed6791031c4ad92482173d0bc2faa569d2eb496516a8a82ba0e29432c54b807f61031d9c1ea2c3bae426340dc2f2e79c15de732465177e3ce03c1596b21c2b0e4ecde9ecc3ffee5416095d1f63d65c2fa0d225ac3c93e06382ef10b0bab54ba342367ef8c19c63e29c05e70dee0480f607e384d5275e58de31f91c0f87270718f704fcb0d5c80e9e66e7d5e85661097e9782432527437281fe72567a8312151a96708eb0f09b294deac0b5d7359ff2cfb2cf8ec688ce0e59e083dd9858fee5dc1d656dc3ea416aee662c7efcac205eec24fc5a0cc430cc967e6e7e6c3cc189d99599741cc6d7285530440b02ea2f3edd338d9059f7b8f3473069311ba2190f608963347b50a3c83d4c5ac24e2fd00028eaa83baface4f59f7eee1197d233b6839b5b240f642590390f17f450519a95e8658c147036536c6e3ee4de5818c8c4bd5fb6f2acad4662b2cdeb4edef4f14cbf6cb3a1884e38553b9303e1f1fbce10edf9244257e4e6f2c5b58896339cd4ee32c93d75fb8eb3e564ff482aedc2cd5c4f5d71ccb0a7e42dd9737979273613249a281cec16e219ecfe568452da2ff3d0089cf50212e5cf7d2e363d4a22f7c973e7346d75030b3fbc124335e82c90e5039e706ccb93d9dc560f78dd47afd815f92341e1332c4cdba1b4fa58d4add35fb3f9155b71e8300a70e341fc6664912357e424c3cd2750f1b00032b3500fae2b1a81a39a292c1fa5363654fbe2a325934a1fbbc89fc2437ce335f67002409a179f53b8a76ddcbf0f95fe48edc64715eac5e72dbc3646efa5ed82ee3cf787a05baf7f75f4d3c6d13600e30014619daccddc016128ef01a1940709bdacbccaa086aa5bfef68d11db0743e5a6a2da7c760c3fda94c8347750038f54e66ec532d5c0655d5365f1eda53c05c50242e53ca78ff68f5e934ac77465dd440723317e142f35e053ef15112a55d058c2ba4f9281e978941afa8dd397dbfa307d01722a62454fff7ba4d1c854596de25d498abb2064ebc7ff4334dfe66396c9780ea0a3dd3ede564ce61b44124a21d29cd91104b02a9d6778ec421a18c009c318964015f93b77b6db154e10791affa35c6dfbfe089f88a04911d7740bd33c5c04945420ee453312b4a1109b2c14e574c4c55b73fda9c390a0a810fa0f4f1b1bfbb22044093a14f2fb0250c365932e310ea2153c87eeea77db663f55aa540efbedd2a830dd4f8c617ab2ad4a9f4558bd4bcb907385ca8a700802d7196093dadd7614b84b77d6ab02942770245e500eb290efe051bb48f472fda5a3774acb43259c7f2a98b8c534cfd7bcb789679e92086ce651c50f3e31ca012c35f86f85c2a4aed0693ffd0c2bbee8b9cb9dccd88198386088562892c3c5461caf5a22b9598f85c23d3191c3ea952cf24f31b38093669c596a2992d2474e3ea9db54e0c256cc055469e48573b3b45e6827bc16d78fe31efa3a0c2cb1a03ad093a5fb6ca86f0e71cbd66cafd0c82a4d5427072c4f70ca12f57f52b13cce6b761776da7a1db7d28839631f03b0e4b726bf32bb5c8f6f0e1719cb58ef107ba48ecfd86b55f2dc02c3c566542e47b2ec9a06621065f6c93f6c75f3f13b1e834a1e40a592594c3d04a69f4737427186fc27eebb4c239c9332ec834ea951d4fa96235314ed77f5c39405bf06de038c676b65780333e506f79e6c67a8b6d5abdd16320b696edc3b58be3c62965d571144f5092773b5a504c32f1bbb2b6cee4c7d6f243ed4961aa7a3c2d66eac48e19e9c037fa4a327472252014b8476b7c4ca902c597ea24fc112c8ef0c804b67ef933048046e295d57b2084bd8b0535defc89851af9b2ac2c83a7453e2df3a42213b4a827c6dab28b70532837c25998c37362a9d6f5b6a4f2f729f816d2656862a602c92ede87898f289f32a6cb405a86a51917f00f3f66b17bae2b34726384c31fbc9c2858a5be1a4a1f8ff447951d4d535f2c732b0bd802ea2dde2ecb9d28e92685f70e9c8ee1f3164fc33da5de15814e6ad99f1aee6294d15013f04a31e0c7e1d53f37bd1c4473652c7dc18181a58caa6fe722b27d21737aea672f3f85551c37ce36f5e103d0ff02c183ff42e8842c98d379e2e4ca5e48a4f465de1ea204f6e7d3e66be5976f5626face9e4924ba03208013bae29e411f83b1e7dbc9e1e1f3305ffe66200af741e78895df650063a2f5fa3f2fa18aa7f9afa42c64d096044c8c15517d1b0f72c79d224b8e81799f658bdf8d35a5f9c2e56c0f2b540ba946f849db646c298c01e2dab1d6b4cb6177201e22b7c744774a7ae5599b9c3ceac262ba453f5f3557e5d33df66b39d7a833d6c83398f7dc5e6d680397a03294225960819302219f3393294a72c5a7e0f0bb7d041ba56eda40c8bf9ae8eba05eb64ebc96abc609566c9e7d2936d861cc236b317b5ed2083866531736db1b55788b25ea33d9b200d2018e72e967b90113739d035171c4e7a0339ee2ded3051f1969354a6085215326d0de579059643c23a03123b4cb6520972e95bd26bb85f9d7be05daaa31ee0e6ed98406f012a18c536f30173fcb99251796912b8c4aa0348764841eaca4153cf3241aae09f6822602474ee5465b73f1fcebf0a53fd6e7720e24acd06bf261c4f926110b82511b2b8972b48f7119e3e15f2e7799886cbb4d8f13282b3dbb5cbb9ca65ead9e3a9ee17f29629e51283aa579d25b9836f5fcded9ef5220a9f12bb6d5e0fb68104f83d0885aae9edbd071bf843ade1ada47263a494a471af31e224955a927fcf4a104b555e2b6b5347b793ebd47c200c4a2a3619ede7626c9368a8c0ac823dfb1f356f14eaadb86fdf8c2192a3165e75fcfbc3d275d66c48a08526283c17049b5abafc56289fd0935ead0709737a7e643cf59eea0aa6610c493a3e605d7846abedfdd38fb79bb73281d59869421563bc5aef60cb7f635e4d0995ad8b8970d196fdbe8b8f981a2a6d785dcd790153c871fe9793994c4cc0f2a6832903c206aa01d3a5943eda5e3e9b688a80aecdd426556dbf5819893ee1e5168dfd7ecbbdfe9a26d994120c2177a95dd6a14a9ec61ee7d5960fdd5d26bd205409a6715dd08e5b728f57b26391b2c61b67f686745661dadebf43c7c70c73d54f078c9133a0b716d71aa564b167b39900b3411af2c2330600fe5de5c04dbfd9971503ff7b09e87949984b69d843360b8a808c58b357cc55369e5c02d863a2c9e7d0c6607800efa6f5e0c1d372b275de24d0ff6fcf94b59d2a920cf44c555b7ec276f167d8272abf9f7fcd97c4a59fbb42176a6dd42cbe437bb4ad07afce950545ac0ef9ef9498acebb9ec2a9655827754172967737feafe75d9d75bd297a3d2416f70ded7c5504b15eefc6ea7d90f5a1e651726ed69ef333c057581753f691e09aa1cf3d853f3b2e5c11419b714eada40fdee81f5394d63db6a02f377d39193573d09af3221d527cdddabfe2fb8702e5d027b80def22a1ce51f53d3a950be4da2ac8c26823aced63e249d3f6bf0dc7e7c8bde219d9cc5806d041e7258c8beeabd09dfbc88fa67b0a2727b9f603f326136cdb4ed4a5bc338d4a3903007cc06d24d35983b5e71a6e47d9d10ad2903a03aeeca52f97c6450ed00e31850b74990672adf0365d58381fc6f3cb94c307d67651eae16b6e29b1633f351bb14654288b8697ba8c1671b33cf21ca451766b892693f4d06cedeb9eb2f5befa6b0ef0db200f11729861e3c64575db3010e100f83d4853e9bd36c213ee0c299c215487902bbf94cbccea8b86ade08a9201814a768a2f9f24e2f77f900e0aef903fbf3963c1faf89888d9d0d6657fa27a1401b8d48a7fe5006cb522dddab92d8808fb88741119ad0e0d2833b0b9c598606dbaec9db7cf0873898c4afbf4ebd409a675294ba695de4a6dbe3489abc29791109fc44511e7ce6c6d02e47b5f1699bd1a64c8493f4f96b93511a6cb1b0a71bf72306e3e3feb8a6ebf2b0753eebd3370dead8d6826c00c846f3d2fd625c5d0064dea81338ac02fe1bded42018909f6a02bafa533b8d857f02e74a431f0216d65338933e2dddc45bf35973fabd93d9e05ebdae67eb11176093e8d1e2b34ae24e608e8360cc1b7a1e242f598fd56d6fb1594fa1a3f7616c93c5548ad12bf8556e199e2c3d9fb9e716664b4350b61818be742ca42647de357a551d8bf07f83cc3ad100d85ae9d817b49151ae120229986259bc03476ef7a540d77d85b19de9a7f1e8e3bf027ea97091e432fd6abdc4b8524cf584ee143aa931ad65089a0e8f1195fc39ceb884bc3afbef44d1c3742a7c0390c92ae254a4bd596e68503170dfd9ed8cefe2d283a35ecc3b72600d8e542d74bce18ed422f0b5fc159852d51a280f50face32b22afcee265d7a92fc08b39825fdd85d2cc4abfe20280594d9cc8f89a4fd1202df4bc981904c2556484667c9bee340b93736396a5616490b244e943846f93946ee2c5892666c20fd2228117c5c835f0e41534be4d3dde6627c7cdee40b6a789d38b85f653e513ee1d90230b2d4547b742e13749850acd4fb8c2f2ab06e49672908087f74e564368dbc432684fbfd82ff15143734bf488791ac69feb61b9cbf41dca28482c625e5378a19f1104d6a53235114e8d3f188ccccf3cd0d56540a2a85399feea615536ed59ca7dfa11ffb9c0ae044743f660d282a2b4ac63263f7bf5e3c2fcd9c67eb9bebce6376015edf82c396968fbc54bd523589d67bd7bf9c28a52208075c23676def2af08c781825c8eec23a8b476260f8b8383b4b6cce502d0ef1f23ca43996c7f118662e225e2db6eae51cfcb84642066575363c886b2c04657ce2492bfb58514b31c8f4866ed9143b88338f8a18d48563a700bd1afa6f383f3643b58106de2ca611c984f64b737e1dfbfb9835e0997f168fb56883808337bbaf89d8c1c034f6be8ab9bddb41174b9863cfd6e67dce072964b0c7cb71c13c6f62a17410ff319a3c0dd7ace24eba27c0422ab57a98a723dfbd7c2a01b51a011bd291068d48524fe90faa914ab464608dd0b631a2900e3515391a0f859e024b636a16f87d4061d2c30710c43a62d0b88508f41966a38611b6e929cfb14082bf321270c2d347d7b3667a97c73077a3dfbdd2b94695b6fdddadb4564f22362a0f6f3adf0b5637e599643f69cd501eba7f3a4b0ad7dcd3aaa5f525ca3ec5b757c29d5827ca1fe5bf3224acc17a6429a357f84e99448da8cac0a351043eb929fd69e3b160e486f7bd4b9eca4627804bc84df33bb47fd8daf7200e567454943d4b9925821f97b3cbcdacf8e6a6cc10eef87f394de2a1f3b028b57e08c82d8d000b343ecdfc95ed8b45507906284331e907dfa7000487c00023e7511a19611adca545efe02f60d044d40877b6aa8e9b22925d7f38f4b2ca153ca72641abe4969d1720b3ebfe2e6eeb259ed78c1cb0867f95ebab49b885f2f79f45d07f17045c6478ed9d743c6249e7fe96dce833e959709a7933a6015021a866d4745154e283fec686da49863208041ec574f6d7c339c3d058906175be7d66609e222cf2ea3e8e57df56f4a0e7682135795e8a30da890b193a88ec2bd32acfb1c19f69c16f4a43500493616baf381c6b588da1e6bf237546a1216de4ce362a948264aa5d4f840691d2989aed94d970f2aa120569178cd9aa3c4267e7b763d3f4b53c4d0e7a3d97b4037b4a338c9f2d114fba64108b81bae9480f2641d2164e958e7abc0a1bdfb85fbe0c1177f6f1bdfd1d1f8995ee85b671ffddad2720f4e06fd20f4876e0369520734dc6d83e03bb39a7acfa3891e1f230b1d2e5890bfd0b5959bd03bf1978082492ef111952dbc694b98627e2b3770d379d603167ecb73d6716abd9d9eba7be84fbf55f5619e5f2b318398edb2b9f32264bf5890ab7232b6e113c0516c6b1cb4778e4027dcad30a4589e210ed35e12c42b0558af147e90e4b30448d4d0d6362fbc05fcc0161785913b16e4aed30e28113e46d404140c31453a29462f9a3e23fb3241965d99648cd9d2eaacef486eda5b52bcef68c1b86fe103a9e1a5c262c6fc8ea0c5d6be28d9de97f27c99aa5d1481e2d66e2475e5a99ae3fa58ea2d66339eb8ba8f61c810d0b1fd909690b8fbf442c4633d3471cc22ec3f9e3c75f8b4b3bda9b1071753103dcbd1f878044fee8f9c13c91bb872dccf77332981b809f6c6f39a6ca3f61ee613e6e922a826d13552b39f646cf9b9a99c5d8610b0dfcab0d832df18918036d668b0c022da77ce55a9a06434bbb6ca88dd650d657047460a9116b9f9c0580b4d8b59da21dbcb2460380a0280f13328a7d50c25e7c48bc219300f841fdd3ede911457b5f453f0d9ada01d13db73943cf7e91572418a07efbb91b5e6405eb368432c8254ebd9ab4be0971fabaac37dba3318bc3264c5a23f43ad1a57e70083862df49f45867fdbae3faa912db71530b8efad3c8f5068aaa91c1cf3ed37145118c0d8cd032f7b4cd3f966edac76d317c36dd691a5a21b73a395250032a74d19386d717c60f3fef39bac6392cdc3eefc3f402f07dad3789e764cfd364276ba7149d9ba38f88246bd15c2edeeb0a2921e9bd4dc7f8e6619934bc39b7b7acde07ab534884a425dcab096510b8477798a7d249687129eb87e066a44d4c2e64471a99e2ce2025d3f3fa2d387a1aaeb60eb2b23c26eba3229992f1055fdbc8919acbabe8047598ae3049349c38cbd4beca5f160d2cc10c562b6354b0ab684f8922d20902b1d09df22d981f114a06bcb2fc7906ee77d54d3ff1ac5ee81f8a8b5dff0b2f336ebfe6216a33d22e62276af58c0852c8a4da357ccac6907cc694c4fe0f693d564702f39a48744729a7b515eb1c8473b03f0c1f359f2e85cc62880cfb9dc4e310906f04380eab27df96dd0e06e1304f3a2e9fd32ce12f4b9f98835dbcffe7ec3d51822e65cc861fe496212ab5bd4bde561a904b81de7a22e11db803a2806be053468e7037557d55b93bf3eace4f2e3d5eb1b7adaa2b82d1fd34c1be5a46d1373fa20cb0524f8befcaa3dc97c6005d5a4c9bf39bc86d681971814ed1c18ef1f73ad5d6bdb7b9c61ff12a2206979bdd863a09158b5035ab26e8861eb97718c82c0aa8a7905f1ce2059f888d0fae2b7b60eedbe82585a3828c5ffbe53c37bb2db96d7f84cd82855215e85f1877d58d57cdb6b07d04451ab0cc15cb0fa8099cbc4b80af50682e0885133c01daa94ad839b0398d14d95aedd78d6e745da69ef3c8cff0c06924b7e957cbba709695d6a0acd7c642167c796c3137454f60cdd50206aa32244970ca0feecf34dd3c49f1f79a7130ce107ee5ea4cb161cf54adb4b8517179817ab4175241d2f36418bb651fa3508df92d18e238356243f407292486407f26731f7fa57683179775893526b8db52a855170b80a4d07fdf4432370b1e8794a55b586789f6aaf00f261935a376451dc5e1af65e5707fe8a9c7a4175213af69efa7ce96a7211aeeb6979bc22634244f17b6cc247f0eb9887d5c8b030a2ec5f2d6941437f4334c02de22df1ad9b850aac44e5f08b1bd19e447dc7e25450f67a973ed7e7d73a6a0098c606c5269c9d256ad1cd4af1cd116f7949bb01413f79af8afdaf22690709f0333249f07acaeaa042d6d7f9f0b839eda81675d8bab0fc81dbc8c5a9373ace1c0ddc4abdf4382c6d13ed39bea921c78dc025835f497a6f7dd24245525f8ac50e43dd69af34dddaf6acd2e756bd3a159c6c38e183a2fcee1f1bd1650e7356c85cb2a2f683646af4a77a025b9ecb4d5474582af29d560a1e0835ca5b1dffa4cf562d599103250fb782f60cd812b0da8c12b84f480a2ce55d22a5de69c8c3f4f7c0eb7083835afccac0bda131b159873f2a00b5789ed0f8a3a571136a7f16c32625e3ee65cd7aad06280a7be30cce4e7959bb0fb72f7cffd41584ac87fefa5ba7c74b5dddbb2e438801d4c5d3d51fa338680c5aac31188bc4c00ae8b88d25bc79cdede5e9834b10a994873ec1fbb041946ad764e54ceee32b70e529b16e4a44eba81cabcccb5b6618023e5f7970774a41b8a0f0d75cfc319d7536da3bfe8cdc65893ac655d08ee5070cd772904bbc4ee91dd5608e7af9573507f4cbc6066ee0c73fe02bcc31f06ff02d6f6029a02b7f1598ec2993ebc78a835e84faf222943dd7b6f00076d604d556f27695fd71c15c0f3f07027fcd1a035643423bc98ed6c8961b5c475b4682c3a203cf01a228f7de062e6f6d363f7705128e44d04daa8bfef905200760a81c291ec83cba1a3159a475ca01d1c70108dc5bdf47c17f4b3d99b5ae0b2026eb2f57ccae92bb784f239a7d9336ab027d710652ecc478e3b5ceefa901d23f5f97bbf795008177789199a65b72c0b1fc52d3d60c3735fd61f76104ae0d8bd2a5dad3f5c96c7b4502f5d3bd38ef41bb6c9f417a58f5c91f6fbbfbd3fab256da9d278816331f462510ef3e86b3be2d8313832602804ffa1421d3aa8c474cad467b244ecefdaab089fdab7b6aa0b2cd531d20b376b2ccf68a67c4c79d5e96ee4febbbfd0b94fc25ade6149c9ccfb03a0681f186995097bae45b532c2a6d48ff5a1fe6f7c7bcd366c9bb12d97103a524a8a68b94f9386a830db5c56193e002aaffc92853b889647eae684a99f8857db9f62717684b28f005ba00d9f0970dc52488b5e6afd3c7d91f5b5a33d0fd34b6de725f1c82a4382e7211794455abf318235f50c824b68a974bbaa3db910a192d165c3945deb63e419fa953ccb8f82b0692e890aa0a7099518247f78bfed18ef30398316a7971f384fcb4b6b9b9f265dd5258a82e5cf08104a23d7d20543f6b04ce2c6d141920160a0ec6c921246b754231222a0d661c16725798a78e898193f15a88364062c54f0889842448aae88ea24639963212413fe3d1a714df30a2867469b4dfc2546961213b11d887989a169efdbfca9e2f8bea011935ce369115ac4e1471c039a58fbb6617c63264e4bea12b5f9efc564c20dec12259f4355ed7b75d4a54b0a988175e67b07a34b856a44e5e9db5a70b9f3a8a1e760f954474da0d16ec57a27e7affc49c627fc5ff0891d26eaa24f27ed28da1d2e1d151935ef8a4716f4c15c31e4d7df32f38411205970d1816696d71816446e8db1cb67843cb59d23f74923a7730046fbb393df25e7d11533a67cf162fb05986992dd0211617fda924e30d27040d77922410b2050f1bfed29895ede6af20e3fc3856a39bc4d1c3ceab2360f2f6d974043227fa82dd0c3cc98c9c9ae9ccdee7183425024fc652ed29ec770710707008b2f8ae7ebc1859501da172fd87a8ec4126062aa51569abfb3e4ec3b0b97ac1aaa90f699418d5c720722db0adb1db7d8f85f17ed7a554dfe259c42d380b47231745e8f0ff5e285507549cbd12832ba7856d312c4691f28dd2745ab5d977555fc25e23198b38ae4a6e7fd28a01555516d29806e15535a1244f1988fe253341394c900f1c351f41216cf5318fd5a3c5a23ceb6cc657cb684aebf9c223e547f7f74c1853b9d967ef457245a4ea7340998fdf7c2205fdfb08098dfdbfb9ee1035b51b40b1a0604afc31dd4ae15aa558f38e43bee83bc612d2f2d3439b49c7613db43eebc23175dc6aa8cd881e74a4c5df9be80ef49a09a5ff67719b9b28427024b5d6175be5255691d49da2cefe2073af632110a2a5a6a5b774fdb7676f1972e3a65f9f5a6816c0ffb22069bd9d76118506f423d2f0646c0d50159ed12dda09befa26f8e993a15405207d90afa741db7a99fea60960c5f29642ce6c851c6f954fd8978d645d56e78828f3144367d9e7bd3102f0f33eacc25527461f658d85b9821ce3216e66256af496ee1916577c8c1327aef6b9fb26724baa78a2922902980de5563e25f6a3fdbd2a0d03378d915033c71a011e77b273bf4a8d1d3da22f162b38681ac30d258347781620fca4d38523c6eabfdc59420def26cc16deb5307ab8414fd2dc8870fe419b39822fc32ec28ae81ace1d1ce3003d78d5cdf83be25b91db0c7b3352fb054ce0266fd03d548802052b1ce88a38c657b45f64bfda396f6e0c1059155d2cacc3afd40039cf68f48e4355b441b2c4790fee09cf21af9661d623e1fa3b6ed072a5087fd8f7ef8d8e3ab97d99c165647361707ead24b9d5ed5858dfeadc61d2f0345320c1b15da1ba0fd66ad932a50fdd3d59194320b7cc73239b48286b69ac291a1c38998834e97718881cc310f417467b9d9b4d26f904d1a72349bd6530d68d8a539079f42e4a68e2ca1c8a6b58d84ec5e57a99b8d742b002b0a8ed2d66d96e701e1c6f3b352c193de1d8db4c68cdb0ad74b6e637cfe0ce9f7a263ffd001f44602fb93a92c47ef779faeb96965a681fd29415e07a72f66588360b3bdc9a0e529dd7cb6ed38672d1ba87f7fd87c5fdb2a33b8a08d655a5d86a239d0e92f5933ab3b1a4b4e07699c4f8248e2d206d780c9cb6c2354d30e36fb56d9dcde1194b696421ff3cc210121358de8c5eca349668ab47c5580211a15a29617f788ab7a09320e39c5d2714c06816a3264ff0a794cf2b6940cc5a114423444d9a47dcdefcd6e943d4f6176a682b95957be9253fd23c889393cda0a65c57810b49cce380f20c4277cf50c562d2218f6db29edd4b5dbc8f0a5d961fb4d9f89f162bcb9ca18106ca009efd1afb15e680e289aef5acf6fb6469f2698392927a6f92e1d480e40119e1a9655d3b47143f62371494efbff978744f157aaf40e819264b86be87f95c3a2cbe45656f7148c20d54eac6b961520bfc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
