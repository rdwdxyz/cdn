<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3a8d2548ce7d0034843353c9fc69b60954dc3d82adfee02af2898d1299cd109eda4169f66a985af466c77cc163435d28d375d0f105bf79b39be64f95d981801192d845cc6e4c39a05a4419d45af4396dc47cc4c78f20f3210dbee210a9876cd1cad1e0e1e5d1c245dd9ee9d9147e6dd2caac63f462f69eca423ea20d783002b77ae7db074aea2500e19b283070a2137d3fde3588eeadf7e846a07880cadd532978d1a5dda6546edbed0bb6c5aef691ec53ab7580c82dbac315140825ae0bbeb91a1491146f6a08e51443f8958040b5a87d89424f3629086163a6d5095a2b694fb4f64b615da1ab00bb49ed2a357b2d13f9fb5a4e0221f8adf845185e8cee000a8d026d891739e0e4156ca634d19ad58e481a7c4ba8d0eec0bea966fea13cab50516e4d4938d9c3022d2bd685b79fe1b314aec4f1c06832f26a4d45d688668ac722637154096e5d71120d8441ebea87452128c965b511299ece363972c5eb79d6b6037aad9bf719faffaeb89c4fc9b10f33ee5b7c9683bec62e6878de45a0407355fa2c0b704b881545aaf0ff07f3ea30e7e28211b0a24fbb259b980c5c040ecbc5c6947476ccd8f8d0491b254f2deab9f8dea2e2080361b5d6472153e6c04f65aa66f1c6b28d34526fc83e26c8b42f52a50953db57ccac2e5aa76b6bcb1dff53d9714937a3f6053525ef07ef80b94de93f2b2daa7a38729e6a5d8d218246659ea92bab05b6f9aed7877b99c1d36f67a9068192c0a5f1817a098cc80c1fbde5279d0f70df405715611bad457bc22ab2b8469ae13865009b8e69513584b898d2b468a2a04ee8a6d36a1478c1eb2bbf3914305a214fe5fb0efb5b1e1b4eeb977d74fe4d6c66f0d18f1391c0ab8b2d62320cd0428d51b490eb8eaa023784597498d28043ea83cd3ed3bf4ef62a80b273f3fce5e930d8497cdc7aca48bfc77e7a5e452ddcac9b0cd7c8bcfc2d882cc3e081e873f5d3c01b680e404da84d607cec4d4526a2fc0b5ec62506300d335afc6988681f183568ff349569bdce2a3d8ab314b8acd1e0665366fe4adcf37db47a2c720f2abe2003f4d366a0f171cbf4ec7167756ca573604b5536cb5fc41c82f21a683829410e1d8b7521877640591e1f91549618f7489aaf0636ede45ea133914a9d130c15f8d0d18a2d3fff033c14eb8f12f5dca8cc03e164b5e45074a2a4620ad9791865426f23f47a4fc13bbf17c4098fa8ba0dd22e93904681d79314c75d70876200f40c90e75f81a6bf9a9b57c8291044a7d195df1551491140a578486163f7947b722cc8067395b26d3f51cc3680f690c57c966cd7cbdd3998ade2eba944c311d7783bc986fa150e24c398f942940086c07bdd8e8e68b5c78a277ad71828b3a67c55fdc2185fd1071b149af14ca3b4e4c22135b3dd6d69a78f47614f75ad7fe4eabdf0696fb568ca3ba8cb77fce5a26e866fc3b932873b01aeb095bbd6f1d142c2ccb9d879cb100b2716e04ecbdef2bdb191d6b5fb7ccb928d526cef105748ad80f4b078cc89afcea75de0f3b670333a5dffa6641f9cd251ac1f652bc9666dd25d110cc92be4f81ff025f6881eabce260f90f388b2124d226017379a739ee953a59734d571ca19ebe92949093a155ad32fa25ec63e254b5843000df7116e4133bb74c7256424d05a0608f865e91aa45a087e7d1f9b234e7981abbbb49a1ac42069fbf93c7cc764ceeb1570a264325712a2de1276a89901778e16ecc6b9bacc714b13fa28175f83ac7b70d761fecda652f5395e7c0cc7eba4ae16027811f9dbdd2c2f3ade4d657590d22ff8af1925ef42099a1862cabd5372416bdbdf372ce52b57cc491803a9fce135031316298bc7a6f98471d8848b328fab3d5a7914f829c38b33f72d057fbf04ae0a1faceb7cbd1761e0132722a15d80d83e01fd7186aac85f06130ac4f59475314003b96a78f12a51fbd4d4df00c67c20d59ce87560d1439bc3951dc6c22b34a63deeaff77d61eeba07f9db564ef6511851ae6e6324ce11569dd583e54b978094ce425813efa619ac8e0e2bc8f34a9e90ef308524e1d4f9cef6468843131fcee9a941035d25e981bad93237bd24b9e5ddbb502102a58cbabf603d46867c2c23cef17c866bc94dfcd6af7f6f6f7ab81c3416e1effb85f77487da6d593d13a543b22f8af127d3e284467a1dd3aa9350aedbeb73296c725a2902e5c1588522e6dc0fce5512dadf94dc1ab4a8004d00fbfac2b64840c3cd0f02be27b20946efec69ab78d2d8aa881a1619a4916bcae671009307061cb3dd447ff8f1d69a79ce34c86623553c20f6ea31cbef70ea0ed77a5bc98bce910bd65e44ef54dd6586a0331c2207b9ea11319df71394f819804391174edb34b352518a2d911b80fe5000a4886542ed58a90e44d9ba581ef9cafd0ad5d4360f4dc78075b54c36e8d3bbe155e44967338b73fc858c248e4da5502619fd908a3157b36d848074ae8f704139704782887fea4b756dbf30a6c11989743fd79114027db0a1e359c6cbb91cfe1053834d01aa06ea589d0c66db706e1df5e82f2ab6d2527f4d44ea9649dd61cfc4108dccc08627f67c4a8917e4fa3d4f8134276ba3f72273b14f39ee5a1d6eaa900fe4be2a211b704c4bad73569cc324869708a8ae2e23d01a5291e6b89faa840c3399dfbf70ecfefe1f51171f8d4bcf5f47f5ee268bb7167f6bf34ac86234c3faf57d7cf09134f07b6fa2ea92e068fbea7c7c5121922307661bc49e7a38fb2979cf7bc48c76c2be6ea525314ab8002adca9cb0a1c067eac94d47c1f14fb36d997c8601d111eac4b758575225dd7d716bd48d0eaebb9e9ad823f57d7c90aa6c2e2b1c480c863492de91f7942a8389e2bfb133ace6a6f38a87592b01c3ff4225fcfc7b142bf7681771047b7dd5c8e0943871fbd9b0ddaab1c96386a7492d2908074b6c70819266f0a7ee6c5b41a38c091904902e2bf9388e39314b7302961ac307151ab1690a04158cf57bafe8a87ebad33aaa132e71be42bb6afc875f2a72c2c29d7b374f3ed5ea22ffacf21917e3edd1aa9c500549f02d1efca6bc2fbe3809066b6e3916018e1cca16ebab3a1ff675129fab8759182d7033f5834c51816147fef87830c4326c2bdcba4aa3ec25fc20358932d477f7b7aa4a6ed044b33d7e6531ede2990ab9ddcd63dc3c3355b313137b89a4753e10f4a4380cda802316dbfe1605c8e9899477cb9916f19e1ab3ae28102d9c335c8f967714545889b7a5ca27cdd7f35174f44a136f518d08ccff4c92d9c641ec50e592f072f3e62202a05b12e825eee526e761a4332df1f61a55ec2539d1afe0e12ec8f4d9abad0a652a587bb0ce2556abc270b1a2cee20cffca8191807fd0abf2ebfdfb55c513009fb4715e51a5775bd1a88213464d496e195d9318f8d06bdf51c8b5f9fb46c94b744d3dbed2a04f4e8794c3043d4a11487e6e27cf441298f36ca324c6d8b2a9887bdb30102b234043ceb4295d63f83df0090b0f2114fd3c98da633194e7fcd0e1ccd9791ec30a0df27f1cc385cb553c0b67366bac200bb200e031d0200aebc959827fe57d7e718e065171258a711332dc5b8182eec82d2ce11498a5a981c7a36825d56c07eedc83717713c46ea02d5942df0e304eb6bd2f071186737075ca74c96a2ee7afd84ff0b75d15d938e2ecad10bb3cbb2e1818d38d4056f23cd9d393c3b8639429f41a6669649cc27e37d48656f50d4a28ae6661eb9e84b2bc44abb712f947c8e2596e5ba54da8316cd844fb9dbefe9ce5d80c9fffbb910dd800aa7a74ac4ba34bc2e09fd9a7ce8e81a2287dc7857d7c057b86b806b63796789332aaddfca511d06db26527bd6cd073aae8dfa5b428e17990c415f3499ccde1d7048ea09d7b576a64b1a5a0b05b5993cf21d922532979e3ba2e90d53be9df2b7064010d4404682d2334879d24c5a5c2b1096187e4f480740e4231ea5e2c7774576dd19a334edf8b5e1003f3308b1aac600b98025c4b7bebd4d7f869ebbe31793602cc59d9fcde28b3380bd20846c7ef596279f772b793009625513dabb10f9ada7301a80599034cdee686cb5d6f6486afb4cbe2bbfff1f975d53142a575206275408034cb19a4830b96d101dc6a9805ff309b3b480dc9c72b149bf3f2273c318034f02cb97196a013b3f4c8ec3a07766b1c605ca9602c062605635f0cd9386b1bfa04bd70f74e27d0d4c06d577d9775fd31f6731a435d245906cdebfefea92e07507701608b68baf506da418bc50404e44b4f1d27b5c3c1faa55b569791275d3f52c6ecc89c6fba3385fe866f62714b1b0d4e54965567c3ce9ad0b47c8dc61f22f14cce05b1f5c8a8751ca43977befbfd9f360914090e992d3241b76ae774516ef0548c555a19d80bb8384410b473fb76847c62c3dd4c719db1fec9469b72258eb019f88acf1c2bdb4c34448979cbcc53db19288a8284556f5594b36dcbe46c9c9205326896e54ccd8b6f1d69a3bc7386adca7f2ca3a872ef920565088f2c62516b16a4a65373a18271390a9bcf83ed89aa86925b3f3a6d8522784cb48c72a59750c410be0f6c0bbc37d658103b8a6ad572310a6df3a47dead55a34f107f704d0eea90b5704211f998b7464c79b5d161c494c5303bfb41785f7f64b08a861862f22e12d322757b04b518ae1f71395aa99a9f3b4b16640a2c787c6c67b40adfe98d51065b64f0cf3f8a4c3fab683bfbb3c944fb08eba8c190e4dbf5da8e5ecf764176133481683a9715e524d630cd6fc2b0f266ecb61b2be714e09909258f3108310510b50dbf786edac798573f5108ba24643d3f60b7aab8c7d3f836fbd18ff650ac10cc9c39a3cd922e5fa1ed8b603fbb460465ad6819f28b2d29f49047a3fed8ca7fee38b1b772c9b06e73cc977f1e61e42d286c6538ee07c5166c59ca8943672a6010abc2c77fe7a2391cbb5a0287601debab57eca7fe18f2acd2a1527e8f1b8d8d40e85390daaba4ea57505ffb16c09bbcec18624519f740ac4d6b63a9de256b1403337f6216177f0db1896bce6db4d31b1da2823ed3b32b06d1d388a6210a191d31b1b4a9f066c38bfd2547188103e312a4e8dc6c298375cf1d1975b5464a52666bc6d2beaa28085674f67844d4abca706df4ed6d7cc319bbb693853decd68046a97ee8df801edb141b932daec0afdde87629f1b4f9c8bf8820344a948df4055ea4be107e139b588d2305680aad8db4ae49d9bad915f3964343f006c020a40730971549b3e984d7249b52e29bf78c629e9a760e23457c1cc3bb80d01d2629a6b699928cedfb5e622f9b460a1f6871a8488b5dc93ed12eac13cd72872296dc555baeb08b3361dba12b2a9d4f706eb730d799d9724ed58c75e02980f425ba96214f3f3fb5b100830a0d42f69d52b75a0b62cb1d11434853e59b32ec97d520e719ba68bb7a333facdd3ecf1e2335e3282a7e8b3c387a17564ad841d8e05fe5277b6c86fcd72759b39d157e946b5760d29680affdf21cb6c49f256d6e2eb2fae754535c740f9f4615b22681bdcddab78a47e682187569f722bef332e1b8c45ca6c1ca4121d06581de008cf3c3ab6de1ae0799cb187703be92215ac63d4af8aa2f8793094dc16b57e004566134d88288c398d32874809e985fcf42420cf8309523b72d5edd437d30a3460b3aeec29e24f28d817c532985fe2a215a8c1e54648b5797e8fa2d79519e63e4ac7df54eb281fff19f070ee023185ce2eef01c9e0ba53978304254e9a479d8099eb2d480e1ce074488c1e81e4b30e05e5bddb4d69b4e618df5a8ebca335e0290b6ef2ef1834cf41f75261e700486f2d42e1f954b3720b3112c4841d8b0d21df2bb01c84b299ebaa275f8341acd8e8dd2b2907d5ba0563acb5c13f7a779afe02db4ac137f1a0a3edfedbc65ac975c99380c51e1dc83777ec1a5e0e25f486a64e0baa32026ec186ea2f32f9bd5e5005dfb68d12c287f74571275bc18d2389dde54938df316d4050f59bb6a3c4eabd9286a8657d1e7b3b01c13631e3c5a72ef4c9253e6791a84394c58c5d984096e00c1cf74a1c27661cc330471084bac0dde5fc0bbe38553ee3a2fc0ba0dccf92d72c771ee460cf42dc0dcacc18c4b1844d43330c689700eaf6fa33a8576b5f846231f65c9ee16ff3cd23e25aef01befa96f8bcafb109129cf4befeaf8e3099a5f968550b1ce72215c0ea9831ba590ef1df271362f3b155c68a98ba26e3f72b886d2837ba18729f561891d519e62be25c695d7823819ca7556ed9617b3914997af7695fe409bb12f928f9f372aaf636a1c9af4fdde5d71c612e859492388f0582147459387f81e0bb288b92bd134f6c94f99e3baf42dfdb5efa3a47849dac0d48d207ff86100cb251a8c5a90eea780202dc19c2f71e0dd0ccfb6ea5dc2908a08c25032434b68456c69d0011927042b079f2a53320b2a7d4bd9d3445d0737aecfffc2e265f85955978a9c0c7c9394caada500f875200938c94f130ba15ce8a0b6a1f1a0300bef414ee5b7eb55b466cb9ba9dab5bba684785c5dea6fce48464db97be62ab859dde7b4240e575cb2056cd064a7ac0bf1762bed03950923c1dc5bb480c83b78795eabe965b8bf84a070e1f1907a178b0ef156fd1b248be9b8a19f430ed71a91392826b8be9fa6fea23a809836d5f463b316fa2bff0d074591bedc931d255229247ef51c48e4081e383b00659774011dcf47204de7ce035c5f70f52ef07bab465cc568cbd1b223f4ce2cbb34a333019d004fdcce5d64236c3ac8dd13bf01587fef03e24a0a5dca9e5fb99efe8c50cbe7cef05fa41299d8c3f3b4c572b6f2252ae5739d882fc64f9c4c069d2da9a9c8342e7ba931218d015c3653ced8c8f13410ae08c5a6aa33e04fb5d0b1e78335299fc07e04a05c50950494eb1a6e483a1b5da0c7541e9ee49c545b1b03ac2100cc04b86251ee9442e71661c81e1ac5bd9f15ef564cf314c9d1fec64e97829bd55e306ccbb247cf096a88339d58e41f7de9c2dd39ca379b8099548fd9fe21a3ac04d5fb4593cffb1985328c4faf5ae819a0ccb4afe7149cc7572426d3e2fc59f849b7efc29fbb2b69bef0065b7a7402cac2ce92d0f282377912eaa42f4515519d7fb268f439e13dcb311fd9c409cc0396c22dbd71305ac51a20c5f4646e4bb2350319dfad59ec69d89987a8cd925c0ae14df6c26caa93b454f80871bb19d1e13b9d96ff2d3b635f5f312b9522ccd7163620e987ca95a48aed9350db16e2f80eec14c57885998da8f2c4b16a9668ef5887e63c7b787764bca577ce64061251fbb721ec35ca601ed38f095c8d8a2a8e32f42eca866617a6dade396255189e7936751a38d9bb68638022a01ef6347f3a99e758118e731c5b4937e27b2b742fe6772ee141030a176bd9a7e2c4fec647187fa1c410290a2ff48275129f49793fd232b2f98dfad5c8de42f573cc7b63cf9790daee0330ee8180b597f4d1df9408cc84763170cb4caaddd134cc500a97b21254e3284408c0730e8b6addc5cdfff6d9d8b8e4f2c08ebdcd9357a8ffd61535285a05d7fd2e28a6cc3955ba501962d3ece863db73bc3ed3f1db27c4df94cd92222eaa771dd723c0a1d6f61bc389e2466dccf8fd18324610dc89806b194422d8dd678a377d1bedb3eccfa1677223f7f9b89f9ab726310453322c4efc9ff39180696790e030b71a6b00fc0c146777e000601ad9f02e7484465e10cb6b50476df821843affd489913ce477aa902597f1c61ad9b31afeac0a77a60b2c44e7daa7841cd932385c6df2900590951e764a426c6425b83eaf2caaccb2009b72c3ef9ed238b8c0c118c7bc46bee2183997e7a702ddccb5498fc36e22076a97c125ef496176ccd0ea162c2e54a81f8085720e481752f19fecf700a3c576f69af580d6bb4d0087f2bf879b2bece0399ff1ce28eb39b9c0ae4cda5b67b3dae61f92ad44ed15db0ea42aad4c9fe225126e78d07994f56c0d13d0a8c460909d95dadbc69fb0cfe48cfe7e915749d6d77297b6ca34dd7e22825d23f6ff9063ef48d55cf8d1dc9991014f2ee24f37c70500d9e8a6f42df71dbc4f548a9def86d5f195b9987d952ba0d857037d4364c0017e8799a553fa2120997f17dbdda3427bd647f7fe7bbed16c2a6b1a0311755799144b5b688da61776c845c615c506ae7edfe126b2f376a7f43593096348f0d0a65c1ab14030c80f3ce63379eeb002b27d2d4a2a73d4e9abe17dcfbf78e3abd4b35ce62af61a7cd6be457299a6096c9d0e37bc259adf50244dec303230e2e71c153c8cd69fb5e30a6956cf8612524036443c38a43578aa016ecb59dfe0c015b8437e6a3e6ae2ca1f734506dc09b87edca1a35dcd760b17869889d83f703148cd7e09e31826308b617d7b041cc87058e0c8049a3caeb452d707bace31bc7442e6feb5496b2ad35c26708d932e279b0b519ebfe2c79d6ea18eaa067e1b9fd660af8cee9748c0aa8dc35b8fd74ea499dedbe0ddea8f0de41cf15e67bae13e44acf4ed92e724663bd74adaadb703232f4ecca73ed5a37c8909401a180c9f3e57d8df3d524977557197d1bae18dd007447af37e1f4ca5629daad148c29906c23aaebb3b9630721864d69b5c5f6b48357a265d6c424ec6a49f4d3867bd7c3c11912db27d915f6984b3cd5f60f2d05edf7e1d27780ac0a0bb9c777bb4e585b50031ded40463de5fd2f2e68af451694c7cf1a2b5f2475732af9872b453a886ddb67d1ba172e4e5cc2886c49818cbce5930bb2cd58693796cd46d0daa589c4fa438a783bb6b2819e448fbf9f9666a7badc41a9f6c29e8fb60a7ec22261d5cd373df7868acd6b35f49d10c6a16791fc595884751cb49b194018b48ea670fe50ff366e4965dd5216136de8b6825dc5f1ecbd5527835629463ec80d1f65a15e682f426494bae316434430142eac41467d4f952c47ba3738d0949a811af00883ee7f0c78a8b312fd5623d157f41a9ee1cd696a61959155ec7bed4bb5d37cc791c1086adc7925366be3ae06320246b373e102f9a517588cf2da0649991a97f5eefa44ed03c28805709fb3b2f845c631715bbe4e875f813753a5021eb4ed81d0f98fe544c15102b4b050f34c4abbc76fe1ea3200b78d15595bd8b5c6b6b1cdb1d4f549df3c7e24cfd98f48cd8c4234e89d0bed58a88185dc8095e72cb3edf1d402c477e5067479b660920051ec59816b6662d41e7e98788d54332fa96ad891a8f2b60786819b8a3c252ea9e46178da46c746e6da5c8685def53eac0d497ab0c4ca50562db1137236052d3b1214c254f210ec25dafe2f68b30dea5065cd2a31b35aab8918088d76fce7a28c1e9095cfc1f21d495d656245119cbea3f90c6459346a9464bc9952eaa54600d14f0486b8e7331b75ffa78eb1c4ab1b3ff15a7f4dc3ac759f1b0bc94f1de75c218cebd6753834029444cc4e108f3660e711ad0967b3889c5d51419be03b2d435868a0d170c312b65cea23dcae06295e963f7752ebf32d400307ea34e30e566179f4fbe66066e962752b7e4a5df3c0b141298694cb34b0e7df700bd64341b0207c822726df4b55c7a0277a05ae4d79e6042ab0e6c01cd5656ce7fab2f5a78717243f166d5612a7a0dffba9a05bd10a6979163ccfa8affad62e1a2587cc9279b900a4733bd3af5af3043dcf1bf98c5b0cd12cd146a92e7cb546c143a027969523601805e4396413d39e02faec63682ca67808b8eeaa152bec69823d3e531e4d9c88740a6211540628051ca450f00b1bd8ea8ef82df34a21b6719899d47146ba0d922f0412680b212a49a27198add1962b6678c190dae5bfed671db7fb1ac7d87de0b5a5683ccf09fac749c3280197f49f3bc76ff145fa757e6abd4c72643bdcd7c55a4fe77d74457ae2f2c2f7c70528916d7bba3f0414246dbf242f5595c1c04abe832e1500b20284511250a1f166def86197852c65272ae227bb77dc6086670799e6a15b9b92431a9ddd29a2357c6ba6f0e3d5fc2fef5f73bb6a52978a62f50c579ecb33c9bdd296158ffdc7b0efd122a3311514d9e69e1c25bbf3f3c0c420cad7bc720c84311867e8b6dff2c403bb772053d3bac97791d445ebba9a16ba2f99232396001c5c7211a938261b52524c156146c66570d1341a4b224dc52e415e9603b0a36c6fcf8ce368dfe6dd50ac58daf212215558f831eefb3642297cded8f76082a9a4701bb71615ce7e9511af3887591b8b6ae76f74ae64f320d5ada313608f2fc2ee66046225a368ce8461c5e357796347f92269983830778097b0c2e6f5d512fc6736f2cac5afac035ac1c37747a9120cd0f5c0e1e4ea9c6e23bb4a843d5f54fcafda79bd8c6330bdf2746b5a36dcb04d7194920a295f3e7a05da059092a151c05b31c6ee5a61bcb45d393ba67ebbcb69a0add37578d1174aa471d5d7fe81230a0e4d419fde627cd8c48f235c1d635982c9a97529de082d7cc04cc677f0e59eaee35f3cbdfa5ffc500682f503944927f52d72aa95b7b6de616167e9a8420628f4e363b7dc73ad6b93004f2574e05138e371934ecdebdabccae7045fe62e0e7afd833b0ff814eaa4fc086c03e25daae3da4f1640d9ab57be06855720bf03d6c35fe04a00176fa5d8691470f368ce897a808a71985373c3ad53190fe8370fec7ed0a866285244362c3bd3b64373595e5820726677eb2c78a5c8b2c91578ca9ae08cdb3be9e9ae4cbe01cca044d6bbe18677f15faf8ee4268fb6178e85c7b7f403d30d57a1760782a456bae90a1fa4521d41fd30392ede362c91344865c0595d0f2a9018c3977a65b00a7f154d68d135619e09716da8f7f137b5e1a2c2fdbfc1cc74691ae15a70efad16781270891eed85c2c46ba8084faf7d8099baac1f032973188589e17f1607ae8577e8eeb354be25fc4050f711f6167472965a45475ffcaa371d7bca861b32a626bdd36531cbca8844a4bbb813e4fc4385c6ebe86a968dd8de6ad0f1c31b9aa7b532276c0ec7ee5eccfa2d7ddeea0e93da0768f9cf7439c9db032699092289228994045f1570d0035a44f1311c38fa23b209b3cbdd40455db13a6479ccb8caada04ffeda272da00a92a66bef5b2c866f204511aed86c827e6a414f11c7c99669b3e9d9b7ad877c747fac683ae05f938eb221d499c42114b1014478a83837cfca9d61ba4be1f1b8434577d4f8bb6d8eea1b1202415d5d42db5e6dd11b9e336de8c789437b379ccaafddc7c049b1fccf37f4dfe5cacb103b8d0bd1fae1c8f0ef62c1dc1223b5db807696781d44250c8254226242e103322bf126c6b6f8a7b9253768b9e2a83000fba3fc83c7266be83548f7a9c06aa4763f008196222beb6c7331fc8e3429c05fede61962c55298ea29b85f21e358893588acaab15f9ce9eef42e809ef976ecdc826d8d7b128cd809497cdbdc0e86cc0dca51f8ae304e7f16a19cb5735f4213f8ffed25e16e5f097c8cc037ee57c2e4b5cf32ab672bcd68275dc23ef112fe0f5e9a69c8f125354da829429b1b77e43855304737a86d9688a2d33d238882da0d22836aff286957a4a2c2f18506bb36112ce223d656890166253d73336c192f64ef6cee1fd8f6b4017a23a9d1e62dbd7475bf9e29e8ee091bda1cf8aad5795d9197a384d1bf4111d5b0abe3f9bbaafc3731dbae55a409ad2fe93af776c51f0ea3fb4c6a2ab3f390109837b76f6d4d23022d6245d9bd374e875d5d7a6746dfb61c707a119a51a30765757875209b406bbebd268d9d82d2445dda7cc927cf5f0d59f369490835470329810929c6ab630b14020faa98e3c127b3c7bdc378aab7f19d902f190e593cf73877787d4b437775745749f3d7aeb857131fb5e095686dbc1709f70fe8484f3434805e2536cdeb3c3bb2592258d1d83b73602218481c01953c7ed9adb62bb5b56091b2a675fcb12ac0f40837d4d52f56485658d1d32c6456567189eb2f7c0a67d1e1ae62ac1dc74920b20ebe3288864f04a4b7370d1840c9a80cf6dfe51986078c0b83097dd03a220215eed4a1afd34ba641a090f23baf59e646157632f767444f2bc654279f05a9de4fb13fa374ce14d2f94a68be01f02c8f7e33d11c1acb29ece40a5fe8d95b7e39157a3c78b8ee76680ba9e3831f615719746bf004fa9b07985039835e9d8093f1749c575e5460fde27a647acce0c44de1a9081c914d9b4deab0934c49e42d2c58d9c77c08ce01d7fe871877db6c74475fc2db1313c478eeb5fe94f93d7c76156bde8506dc7ea607b1a330b6dd3be06c1b5dab49b0f14daa9578a7bd84d42d3dda5f441a8eb614d2dbc3f88778ca6e88e623e817cbc5099f28c8ce5a4dc17d96a8daff8dc73fdd351b126e4f7c1c2597369e60fdeac567d69692f0b775465ee67dd9f6ff29ebe07beeec4c5711b332fc61054d27aab86f3d0508f54e6229cef25fe4c5131ed0464a7952f6b18f30b521d4d1d911f5acbc60dc4bf81bbca7c71c7db04006eb4041a77cd1c49dec617355da0eaa55956a11b6b3ed11056e631055393e859efa905295983be6666362a4f24ec968679123584e594780a5017c1b0de40ca16e27b10ea70f1a82649e02e749e2e0a068576c3614c7ec0aba85b526366fc05e054d69c9b9f984d786687faa94970c05d891af7b501740c5d3e000c2c33dff74ca13e1bb3d154fdbcd08d87e01576eeb15b24ae1b9e1964edf6f199abcaecd70ce4d627a18903d15a65511f92dd2b6bacef12f856c828d02298c9da0dbe753cad9ef1723bd1c8b3890df41a2658a22e5981757148cdf4aa46840c3177678a41de804bcc92239e7f759c50d1bc5a7d1b59ae2ffb44750a9fdae59e6b686c3257d4a9c37a4587e35254bb21b7003e6d8449af023d47d95104c2936e7525c44d1f2f20cb22afc612c0dafd39d4cc2c6a018d34961aa57be5f73e81ec5cd68ee1be7cd8ea5f6ccfbe9d0e7d12aeada07229e19928c0daa0573f332a559d1345299421f60a70d2d9a0941898066b9a1e93bc129fbe570e848ecb0eb5101a4422514dabb04b2b1cfda6c2119657fb6d87d984d551f7386756a6fa1ae3fc284792a4a1b0769ca192b0a4f7e6202dfcbedcc40d4887a4fcc0abf0a4bfabd6d802f1e891c19546c148e9b2485fee992a9b7f99d063b2db8a87a4e61b9f32090a13ff8103d0dedc1a9d2c6caf8f0cbec8fbf1032eb287f790b51140f4b353fc35765eb40223a22e80a2af634a642237b1fdb0868beacf34a3c0e37e66926ce336618b1bf8fd0f739435f127e066514441bccdb7f85d0defc9056b91809ece9312d5177f8925b1ff3a52cf369405132bc546d497f0db1868b8080f5cee00db943650aec13e620299fd1f8a9fbe0645f9f2d666b0d2d35a304bfdc9d85e18ac3db1db22a83d6a5a2cfa0e4a4bbb15e9e598128bf8d0793858cb05b64070d2c672805c8155c12ac0673fb01a1c1103d250ef2d18cf6eb514bc54caf2eb612a7733035c3b775557445185257b9118af8202f00e06d9f855e2480910a4ad5b201fc629c57b79d753d000db914b25693cacc64a6293fdb318b2ddc1dafeeee2a5379f1d533d3b3cb9fa11291b128e27817a71d4a38846c500e5b22b99dcf24f357ca363278a62a220834ea73c28d21ae7ac5d7a2007940a896bf6900a9eb51f9e0ea511da658ecb35dade9ae7c8d83c804dea84ad81bf20158d4d9469ccfaa4a1c21e91dfa1fba5d9f4668a470328c6c7ee7f4f91da3a7e64f744c6cfca10f93a1fed7481a16564f95a411e9a675642ce80b0916392f50de0846d5fe2c6d250ba3c23bd6375ad53eefca300907fad9fb03f8cec72466a15c55d7c99b0e38441045fbfd2caffda5177739effd1f6e4a4ed2dba0b4460610d1e253b7795998e9bedd16fd5f9c63acc6407268dd0fc48d5bcf002f70a0395b93f5420e91c356e98eb6c50a99ba4a48c46732483ba91c0e05ba4e62ac277a0c22b8cdf37f441270a378ec0de638c292b4b9fbca2b7907a4b92a09499b25b573ae59b01a258f0d45d946a92393bd8af107d4a0fbfddd9cb103d6284a61979142d5cba9ef53dccc7db01bd1681f0fda4b702b0619a7d85d953842a11ec3a60f20560fcd41dd081e74da7e89c81c799dd6f2219cb5791130e05dca26bc07fb28b38f2c1deaf977565036817ebac7d9d48e594203e13d8f644d2239443d2a738e9815e173f5f037ba8dc196f3b546823801a9baa13a42843f55a0c57fc90eec7755530d51c4acbfee9e758325165517d2282615a2f12c3f499fc1dd88ebaf561214729ab6bb037171488ada497bf94bd75c11edafebfca20146491ebc63335bdc028451a4665d65893734352fd46812541df64f419e03384920f8d1c25d763c8a646a0bf2d989a08f61aaf676c003ef33a129e13ad7281937696fd6150d062f5ba8b1ec1369bdcfbfd01bc42b2c5ce4e106fe52991b34aa42bf782e8f9ec7d99bb993157f1f78bca7d6218475791dde938c8737d0041c76e2ec7a334399435f81fdffedb302b3152806605cabc9b986e8b1736a531abfab4d1c7c6650edef23eefe9de65503763a77c1d19239a5069c6dfe2981321800b99fecb0bc2900ec31d601de36a2972069c42d5827d1fe82b4bb0bed2c09f030455612147b9b07046a7550008b88186c3ddeb4165656175622807ab767a11ccb67d048b8bb0289510054cdd1c24a38d23146967a0f7346b905da6f9ce08b19a4a51eafcd471e9d5d2372aca3dd13e843c3ebddf0448f72be74937a9e909ba639c67f59b3db598352dbb3b4527c8b0fe000561f4832051bbf434dbad91294d9d4a50ad9931adb4adfad16c8c1b55892a1b83d5ceede9040eb7d3c352da2f44c21a2b0182c1b23178a67cbae5ae5c24a73970db819d9d8bc6f4628b192aad26cd7ec88de7bf6c3d484e9da534d9ca509f39ce6e05f87443b1871f520e1da240cef40c55406297c14da545582d5ea4f798b08df4017fdddb772dbf33403b3faf918186cd51be295259ddaa27f43a6fb3eb3bd1d825851f84259d7d0178a4814ef7fe6d4581b781163c694e141ed654881688e4c4b5fb327db431dda7c96ef9b4ba859fdc520277c5360937f8cec5559082af38e0f97dc5fb59891b88b0307c0584fce10b82198278c8a4f09fee7e921a2d9a2bc361fcea2264856cf6a7b321735da4918010a62095a27120460fdbb6091f64b7636f44fc6554e9a765f79acd8148317f170d0ebba15861dfdea1d970c2616516c3b85d045e80472034e9c00e10922686edc19120aa3a2652bcfd972acf149a2530467fe8de76a428db9ba4268c9afb28ab612c4bb6e0261a214ca147165f73a93013261a22bb26de2242ca3df75cd5f0f079c3c9156ae19bb13e7074b25b450c72577dba331486c0bf343e88bfe477eee8e54160a461d53858df959a7dcc73b92d8a2447e1e9a0ceb0ab4c082f138bc60c87a8f3d40bb1248e9f8ee5dba4b0e239393606341ddcffc0e2659a134154d900ff3bde3dd970b904b270aa3a33ed7eecfdadbe3211dc457e330135a417634d107438f94a5840fbdb6894a3dceef950d01b9b15a9fcb7aec67a8cb7bb805745cf87511970c05673d5c564189a4ccf4910c83ad11119ab06e786fd62d1cdc925c028e6bf71c45199ebaa93a5ccaf61fbbf136dad6147aab9ec40888bc37a79a7a54e32d3a1f5cb1e65ddc237a7f641d155662dcd993507d91ba7828b9eff276255937e839939952debe9892013134f6619561ecbf1d76f81fcd61667688b770d35150f12b0602029b729c879ff8624370b078b8ed534ac61cd287b75b8b88d4953415d9899aa908f3e00353bfdb3e25b2e17505db18b193817d348d312db75dd27ed78b511dd2fd75fabff9f75f42f11e4a811a2052070c78d12e056e75a6cf6d0accef39241dddbf1736b43b7e52f3a75a38d13bac0bc8dc7a9d9b799dafd1bbf1b02459202f311b1680f1c86eae1bae7ca3942c94b17a62a84e30ba1aab0d6008433d207cf0eb2a7c7e4631031e39fd34e71fd72740eaafeb451489af06e2291244fe92f13ddc5abed94c5d8a7b7eec08efcd77f825044699b3180a732f2e6726b9b1d15a9cb23d78c0e64bdea15f12672e462bc42c2b73f8c91126134457a96cc436e6d8faddd32e4495b2e44beebe7c51311348dc6bddb7ec4b56e6e430f55f89c6afdca0dc26147600d0734c6b5aabe33b77a34a4ff38cd7bf12f7ee963be3f0e5bec02387f478ea873fd9c415826bb7a0184c0a183a160902e849518bcc638ffa0681624ccc2c293102a0b2bef61d8c4cd433f33dca33dd4a7095ec0bf97ddfe1da04933ca26fcaaac554892be117ae1922ddc5593894e100148fdc0628471ac0712eefef86b2d22fe8cb411ab274d4e27ee876f767f24e5dcbe4d982255fb6f28cae2ab5b78a94587295d2fd199cfbe0ec87e281ebb43412685259085bdbd9583d6c6f9e4a5749aa1817619349e7546f62093144feafe5e390ba94530877f25e13815b6ded29a2f76e4c74e30eb575580f9bd9d7026a10a1a071d49b9dda40bc2eae90452c5cfe75f2d85781b95760a40ca87fe498a0777c90ad542cdd27822d7d0f865739fed0c85336771dba398c0d50b4c002ab771e17aa94552af067584f3810ce653d4d2721957ae37fd56023e7f9a2fef64b9cd1cef11bb2a0500393d211fbd885b5d6262dbc196e070c516903e81f168cb2304628f6b9360a248c6e7ca73f3a94bcfe602e61b226d949dde8e270a4a4bce72635e58d93c282c2cf5eedd7bee5cc3491d0eaae8a62d3604c1dcbb42ceee1c286df8798b0a884e0458fdf0c2d16eec9aecdccf53c55b9b5d2a57be6ac853c60cdbdf03114e177aae00d23abf4c9528fba7d968d162d43cf7cd9fd6890195448f0d117af35c21bca8793d41cd7ab172d758e78b76f6312f6259a43a332c895ff73decd551573954d85bfd2b2bb0534dcae0ef80e6fb33317a5d8f3ab860d646c1ee65c4524973588bf10ffefca6630d693b4d45e09461c6428d2f776be84f7e66d2a9d97083b56127a384c1cfba3a7329f1c9b770fca3d702848509fa3a39003687c1a7d3502775e523bc599db25c500fba0558c78e5be6deacfcb3e56d0d6331465930e2e89012cea0336a13592b939559842ddb16006917fe9ff672f485fe3791c2a1c0b18fe1739592a661c161cba880ae45ad147a2b62f047333e9d1a2acb3f9968c69019621fcec4bf7ea37936d016b79862c3c6d8cc88b993dcbad0133e7dc57d949bbd21e5c3662ab1374da90e27e91ebb9c90cb2df2fa4c9bbaeae6a43e49572ab4c9ffdfc1c9a958b7c55e4978c15fdd7b38320d1fe858239b70498a3e99f56f8eaace8dd89e546f57f528ef3527213586de498ca53653e3a6adffaa237fbea0a1a3285a1b5ea5e9e6eeee494aaaa5970090ce6bb5da2586777e4f59160a0ea15d23c67d3465294ea748257466d47422412bc299a3031e81fb53c729c662b71e561f8d30001cb6812b04187762dc266fbab22a330a6c625134b0d1d647da631fe338a1660c717cc6b9d7cf20c671058d55dd0c292205388c78808dd98247f9313e7e8ba69da9286766f06dc80651ee4fc323ce07dfa58c54c9f9d13cba72a7287c3e93903bc2b1fd1d3b51dcc57c6da21cc387c165ba24f334ce96c2af4327a06b5aa838927f233b2426989d1feefa853bdc16215748ed4fa5fc5e8ea8f6fbd216f45b4a65d6bc82b84400bcd9229b0355946879c8146219f99263b4ba23e210ed848ca665d5ea178ce8db378ca6ab45f9374882244b9c93c466020de31a649e5d7547a5fb4ab5037cc7c42dd7a56337a142bdf88e88f10b97a06781d02b9022f29f26600cabbf1f56ed56e523ca16c20cfc14bcb898e486bb6e149eb5a3528eae6171ba83395d72446d2388309cbd6adcbe801514774739624a10353a39fa0ddd79c0014155505abfdf7892712a87a654f084d3438dcb45e87597fd0eebab124f84c8e045ea9ed10aab0a4dbf2463f2fec932ea3800e340d1edce631c0fc4ab1da66855ae6ee52453713476f963c9c33e0c481d2299be90ddbb10dd6c49cf2106346d3b679ff2d0442c43cc61121e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
