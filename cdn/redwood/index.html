<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8118bf5241133a3deb2f24ac2d55934bc788d8792efb3d79307d196e11a66ae3dbdeb211578a3dd78e784d4daaf041d7b762886dded3bbab42bb0ddcedb4365bd5c146882023c382d45f77d20ddd3b06fccf3d0a28449014643d657d41bac7bddf92b6581518ded346434e32b1ae689cad3e748816719e8e798449ea3231aa8a1218253af9e1cc419d7153effa77ae9f3194d90ee28eea8db7cbc18ddb2d1d17258fe23acc8ed3691b0603f4d382430267097dc3bcfc6b87b2fbd221ceecaa2c9c47d1139d8a519b645d3875d5b679d7720d557204cdfbe683c1950b7e22b199a8c7a2ae164d27172d1c7d4d0cba4a3ab796d5d71c15fd5c7c8a132f5314a6e1afc337de1a0a6adb2bea0cd0e045d55959f1276ba3d5fc1d47231859d0032b6e0b8f0f5893c595dc6b12a96ee1d8af386b6c05c7785e3133d374364da4c56c9c5aba5e76c3cfc0d86e27818dcfb21bfd66f466444ecfabbaeefd378a831db3b5a225ea71a545e11311f3d7cc8a46f76cf4c41b92a7e763034975ad63d57eee8a4c9cd76319b85dcfdc3beab923825c82a0b8d3549ce6eb211c9e1ff33b49a4b98d7f3cdcf3751b60d0c81835d16d73d50673d3792248dc62f5f0adc7bd4f0d8c5aa9c24a488ee4a548ece40587131f341e5bcea88545230915af8cd8855ec222237df19d2034a1ba31df3d6f91b543971137dc01f62480d4a24365ef9fcd725c776e7b6eae94c10adc446585c4dc514425b3b0961c5ef6d98d34f280c818f44d69380cb47316bbacd88e307629b0f17b53e7d9bc3acd0030f0a9776c56dadea581d385485ae937c148e0cebdbff89949874102ed18a34d7012b47784c77c559d10aea57543ce2383720708b21abafca6d9d1b165f41a1e739075d2af5feddfc5119e58d7214f1a37acd04beae4556153c3d41f30735a4e98e55f8f3737830f80d27ab6b4f6d799fc0e0418a667c2f054c2076c482136d84e3486d627ee3e47b73d78097210d3c1ddc3762646d0875029c3e4dbac66763f5f8ba4d562e2a806b771404b57b11201cb62d7f56ed1e930ef19618b8445321435ea365c8022307c0e3814bf8fe125ac1132ad3ca0bcefd93d6e9724d873ba1d82816c87fd1b7c156638d7d0f3846d6e674b11c0cfa997e1b55eeaa7bf82ac6050a7119a8afff2c4d237f9f36c3695874ea0e6da15f1ee65baf3c937c5188585886f0d8fe36f4214b47516031f0673ddfebf6dffd07d0d7f11d090858e0c47e7e3427339da992d32bdeaafaa686efb9bbbabcf58c114c5341ea4e211e708e8d21367c2c1e6ad2b1f4170a75e13ffe455ddb83ff8490450850a45f1534cf6d3b01d95f9e5a76c6ea040cefafa942a69c141262d3715ac8f3733ce86c292fb2bf5fef398dc56076f755adf98d1eb0ed6c2cb187e251ec424644426dfd235875c8e4ea191a9baa9a6d874a59a1b3a417f8fad99496ad0dd796391c9305921ce1a054b8524b25d7be6de19e3c37f194f68ad057c61140bdbc21686346338329ad987d76dff33bb20b57148d9ea4a3834abeb0f5dcfbfbd15bfd423a920f07ca569f06ddecd8fecef5b7529cc8ace03e4cfc10285503f4fdd0f51de622495ad6c39bb33a5dafbb478b1bb39694e1ca9c96a8aad30154c4950b34f941af21ba1b3fe7d3487f121793ee22315019c6a9f10a615c5946fa9bd7314b613636bd1eb3ce194a9ef26fc9bc1f92821f86808fa2424378d343fd9ea5d391c536b7daaf32b084c3bc58ec0948a692f3b1a3b954e73ac8255e34311ee72c8d0defb069d1e61e7258a0d151f3fa0daac48bc869ab18956f4cff05639458c4ecdf320ed23d3fd6dfd0e4a519c287704f5d6d7fd5dd6fd8d6c75fa26e981ecd2dd5a5c9089e20cd33014f17af3f242ca204dd5b8dd3c0647a5749c006ce01f554910daaf240e3da0c9d3d40a13847a157f5b36accd707e43e86f08552b62a9b7870b3eacec3ff52a3fd557e87f66e5fd859d64a66a4b8691b76cd4152354311e0e5b032aa29a17ba83d490c1b1154d9ac7aace03d77dfa8daed2b598f2db43e3fc881c9f462d093abf4cc119e2a35e39c0aae9c4a534f3b1fe9cad2f6233cabd4d031bc792885650f0497c6034852cdf5f47a7e6d32ffbcbd782c6f9a3f293f92c2e69cef18e8127d28821f85a52f2a871a72894b5ec1623bb132bfe3b8a949fee4ceed086bc519172e3f6a84e16d4436bfe380e56511c267f07e4879dbbb5ee652806f25dc215a257d1c1091574c038387e430f59fe1f48411a70efc5baa0a7ffbf9ad85fb71e1635ca2bc3193848fbd980f84326c35c5518e8d7e8f1053fa86483c96cf66bea41e85ae715a2be0ee0f20e5eb11dbab9456b688808de9373c40f291f43198c410231913ceb5ffa68b52e3dec07ae5f276e239d89783610fd9d1130f72b2a9e373dd1d0588b3dd56993ed9320f84688be15a9b7cf360dcccb0319e06f262f0122c040974c49cf5af5733b6176add88aa49648cc8b41add8d1bd93986229f72e7a9158cae06f30f7dcaaaa034a2fa7fe8028f03c27c3c74f87807387ab79f68ef5e4bd5db640629ad8b3e1024fe8bb8f67f6eb59e22c41816a5ed63ac26f421a2e211b5718dfa06e7934faea0501243fb21280782edf9fee878421f5e9e787fa5f9a953d8b0529a022fb3390fb86efeb42ca0e953ea96ec3b73e8f9136ef797d37ea90027488b5ef8aec6fe8851c1ba10cf35f05727d8961a368f12799178b962756c927920be6f859e34d7179e294072e518a2abcb5df08b956452c2078d04328578bb615b2e467328b04c783c01d16f46151e00ea1c577c2663dcc3d64dac9d229213f9bee9c320e052196d8d2c278ae5829a25bb9bbdd368bf1eb6b9c69e220154da9611fa3fc77a636f9f913025cb32e50c9259077c21418351d13ac4b53e127af09b2e17ce33c3480f916999612d938d2fac95c5d00faac3dd4c31147af0080a3d91d8d5f40714cbe46388fa273046b54ac4fc551f95ba7eb07f99541264c7bb86bbca11f29c87f5e7f9507d3fceffb2136593adaeb624f374f4224ae4d2a8a141d5c70fc479955ae3fcfedd6a37538dd2db124192ea74ea3a75a132310ad0482cdee9a102cde6724fb2ac770f7a75787d36ee7e05df8c942bcbac03aad845cf4eba2ed4072b178f90add76547e15db511abfbdaeec1b7086433a5ec59863a46b00379dfc0f31e8a6a319f3ae637023c5bff96370b8afb434dbd99583a8ac79f695cf10dc0e9ed93f7ead7e68019f1360a685901fd44df0b577e621a1970df7f519d322569e18937b8c3e11d871d12f595f3e02abe51b56b2716fd0ea56c611fc59351fd4ed6bda281a2c1c568718988e811b1812a7c88d61ade95c228c1e788be034cf185c7d64bb816795ef50bee222d7f4c933dcfeb24f792719cc7ac70a8ef6098fe2655b878082b6a5488d21d12631d62df2b1ac9d95152f0fb6ac296186d2ed23a5e05994fe24f347da953a921203813477512be9aa5070686478c84464276fb944a1d516a8b27bb6ab1f3e8f1ae64274569b9bb0fae4f4a01ee06ef588c13ebe45696fe25b4eb35ead3f8314012ecde3079b319e1e1bb71046eb5bca3edd7084534a10989254bc9beceffdafe1218145cbfd4a1e8546732ac4385467558b940ff7eaec2721094a8b7027336d2839d44083023b1537e300ae2e0efc5eab49e38b557bd08113e4dfe78f216ddafb6c806905c22118d65a1610b84d60d1640e64ee951a5344e086c8875b25be2c36c584e6701e3f7e7d012569508b2089f981f69d89f56217133358e5fbb575648bd328adf3da959f0bd4b6d587a17f99c6fedb2448456ab7dda6d0e887c600f64882980c903891dadd66b5874c665d49546725dc0ba9b0a31e2461a1fabe23041b7f71245746030d60d0cf38b0f0c294d846901bfbf037db6b4b46d59a0923235a555d28e6b25a538c1f9e9342a98c25ef1eec9096accd838cdfbf8d6d412f41db61ae4a0b69edd2235e94845889e2d980e29ff361302b872c63fde5202615001725c10e597ec46f93f41a62c7ddb1cbc8ad284cd94da5a94d53e0baf6ddde4c8722d81f57cc4b2c3264fac7ccb02aea3e7ecc49f37f15fcceb25467d321c9f470ab0bff96a7ca53c3df09c9b3edb75fac51d6b2f225a5f421553c19e390e25ea3593834b56c7f743ddbfe674354cf9b8d05e0c5498588ddd5094053893a69efbcbf89232bf4588c14fd5855c5bf52e22e9220ad733cd49387a4779b776e1bc78ea9446268ecef4299eb7dd65e31313203a795e7af0c2a03851e44f3c4ec5820321af49d0d0401d0d9d82c5687cde70d59c4be2613a1ce95c12512ad040edf3d6bca7ea6dea37d3fdca516f97d9b9593f5ec7ca14ea9804f71aed1cd9e7f3c4b877dc3f3bf341883171a7f8c55fa291284cb5b057acdef1440d420eae00fd3a7abc370e0dc9b574de061800d9ee7c792e7b8ddff3cd30f48d4cd9ec1be432e063b141355409b8e2721f519a60069171877ca801d3b5dbe90083acdeabb6d45476ba9e9c2e0ba2bd5408baa991b7888a48c63310e24167a5c9ab4d7a4d3f232f5bd9dbece46f7de68605c95811a2e504841638948bd80b79c8c80340a2100aaa284d730c25ae8f1c83aff648345a854bb3f5dc6b17c5bbad452a365bb7699843b510b3776c81a543bddc5042ddb8f6b8db3baae6cfb189abeda8d7a8db6051edf243a329d9beb01ef6e854de2173ab3c2a1fa872ae56f6fbf112935d0a21b6c1dac2d56459a98ff79433d874cc419248d3cc831fda11e0bffb825b4b6939738b678e236ff9aa92ea68970b432cb3cb42f18d4554085a81a8b2af3f14fcdd0884fc333857db8137683b9b8dab3c9b0ea1ff5c973e07dec95016cea22d459b6749d6bf377bb5abac56fc24398e2c0b8eaf3ee2e14bf9e180b5fdbd60491cea269d8d7406dc73f2e88e7ee9ba9e9b9f5e83ecd40b14e1f623a88439ba75f4adcd0d10b9d8659de32e003f1e8047b76c4b338bafeea130cc86c3eca205dbe9efae946d49f65af478188609b9dd47a0980e373ff6f7cb51092b3b377df3df7f2ea5d1fbca22ca17e2bd1d6fd5a397e00511c44a4f713f09f1e37055b397d83d84239d8bf57016a9221a63957fae1a74c605133235feb83300712adf5ad44930d1ad04f3ecd88936775fd55eab060490a8ff3fde5c86afd7cf461fc18031064595c566fdf674c1d1cb814f575a6f1022b83988f35b2315310cdcdf62f560a70ecd6aba4eb46610365c1c7a37f854fac54494ca41de2a3926874a6bc2fc66681fbf53aa202b9c63f813ac92498265554964628d3d6ca73ee9671763c6f6c6703df45ad72472477c0569a6f26d4e2c44ee7eb4feb73c616140d46b0b6ee272e74114ada9c40c41daef3fb63328297f20298613de427a44fc725f033523583d9ab90ce9d6f32f7e27722317dcd4155947e23a91dbed62cf7c92b0f7ba4037835aa4845b377a9cdb67f500383541c148bb17e5505ed430e23fa9d273dea2f862ca4d0699c36921408113bfdfca36849d68693af9d97c6742a9a2090f247eb92ff2a2bd5aa1e6b720d2d08c22a073a2485c3da0bf11ce4785b13199ed67ffe65327fe595b35b131427d8feb31039894f0b8e300c5fb03e43247d20782a6071d1ffd7271b3ccbcb8c73c9a7cdabd5b33801c6b46e1bd3e00b3c231da90513f39fbabf154cb1e5e8db537698d615aa802613bc0070162cf365fae1bf6d4fe68f9fc820556c3189b578342a13bb128d053f351bc3e722d992cd80c260a92b4cb65471fc6fc65c0d5608ba9ca167cfcf044ec1304a0ab575bb3145f48a89d9e98fddbca9562717d0cab46eed4f9e694f296b42307f511377fd927a4c60cd611d278aafafb8ea79b492126cc1f669f58d136a74606eca61f451098da68b2278fae0aec7b980438393dd7e825ff7c09192d6408a8f11070f17641e0f199b0e5f34b078601b95e8799a877cd13d689062a30aa45af3388ee66baa26023346ac990f6bf6e41e36a3db690e0ceb5681b0b8c3153b4a69dc473413db4411493948167a2940156f3a6aef1933d8dc65238599a6f9068905d5771bbada23cb093c7141ddafe329defca9a31998bcc816973ce25fde988cb0ca5f2cad2784a0dde038f08dd3ffea7caa70a170105c19bef7de275bc403dba01996b3c1deadf8f80ae5dd051c6d57c36f0eac386f2eafdf04fac002638f03592c3070104bed27a7c112535b647849c77ac72d893e1e7ef2e684c9709b7acec060e59bf93b061268c9eefa8977bf58e376d6a735adcea5828cdeb19cba23c4a64a031c70eb75b37d8453caf8fe779f38ee488820c85dbe670e830db16bf37e1777248c1f5e58c5b0659de9d2d2cfd197b57b86390bac94e23b1cfe74337978757bc493c40df6d17d691f391780a060a73c63b0203c96510d01639f7171b156f5ba113c19ff534c665c2b2cbb75c3e514c8c4bd20c16a5f85eaae4f8890054b60e73f418a974b0dfa05b07bece99eb6acc03e752338cd05062692a45e6fe46173c360ec68eb157a055b84523f3adeca4317844b44ccf9c32629a0a21e9b80e2e03317bf9856c81676f921bd8b4103a2312eb1a49e615f9467885b90464a250c955fa54d4eebaa27e7c91ca4528555733fdac1fcab588c29720c2a773ec5a18150a975bb32464ed609819679faef52d0c0164066c1bfdc16eff93138bd5ff15c5a6d1decb5f944b37ec6cd1ad7752626d2d8ad5b20ff1371984b57482b9820d07539b86cdd0dfdeb6545a47375fc08b32beb0721eb9ea5d1933a7473d5d2b3b11ce9be04e4508673ae062ee69e6172ae31a8a0be07a64c72c6849741174a5cac3d39da48ba0bec1086b968613795314ecf1eb3e46cce1dd6ac5d1e4f929ca14687aa68344cb432c5c255710cf6387af9c11591dee368ed6b95e88f3962be59f210880a485f9a7033b627028701a3fa746c2e6c3db7bb15801aec1ad9614d5f1f27a61e0f3b0d5aa0f3f9d10024924df22d8f4ec46f215dcbeb5faf595fd650dd06b9acf57d1fd55a0cd33c464a1d1bcf2c3dd6ab4efcd160a2d07fd256698760a46741f3a30b26bc93bd4b4041fcab4a8ff2be23a1bbfde80350e30f28584ef3c3a819cc3e105b806d6622e30a0e925feeb65310b1e0a9c527036bb67f61b36f73e93a419e8671f821aa5bd587b0880522566ba09cc9ae6467bacbedf866b4dcfe416afca1686167d8e2ac43154b351c1a14cb2f1e2b118ac16d3139c68b8942438c672afeb43f44868f1c3b3ccee0503bb094b56832635082fb978f85ea25f9ff56ad2e067ad083c6a334e4fef7b89d8544e22350fb8b618c307745a49f420aeab24cc5eb63f98419ad32be9f9052b9db744bfb5ad34a4dd31865e8416d0986031dc8a800300ad7a371330d3dccafa63e827ca1662b32bdefd1751c86b05cc21dc1a3be149527b4f0441e003ab33692a004987d6b14bdd45b5561fdbb932e88c5a5ad548caaaea2f5963a59fd208f1de54305c9366b010ad75bbea9de38eabc4a18fb65e52e26c35f12c4472d5052f76ca633fffd9b86c496b7326a2d7e07bf619447c92320b7da057eccdc9b3880a2a0eb11e43f28e0dfd5aaa4eed8540036d83b41f489e64676b1170fb394d20f3f5e260d70a7957eb794851b02d75b0aab89b6f380da0615faab82c04f269be059e2c4544008d6af7e03674dbfea9e2feeeb88f32c23109a5882b8b5885d021da7a9fdc8c208974d64cbfb8c33c75a3f1347c61c77e68a7b4ae476ca0a47c91f8158e19173b78e926e82573e07258dd767d2e5cd45f943620c33317e638d1ae3cb74f7e46280a85519e190c602602ce9ca0988fc4eb5af4e42eac3f35fe149aefb6310ef86b5cac6875f8cf2421028f1cd316adc863f4e3c8b0ef102f35a3cfc3d9fd15e1cb96adc8c468ef74b7a5752dada5c5f1df941cf8bf3b6f6956b6849eae63d8e0ac16276b28f3fd5da90937c391e1b2c69984cc2af1e7652ca97a190a6f703efb6a253c00a0191b57a13db909799ddc6e7920e2aa4d78fee12acee8161ced52ecdaffcdd5fd4bc314302477c7d4b26e566ea4e11123cb77ee89f6b959e19dc71c3e09d27b7562b9079abbc3b0f2c201c2f93b1f0833bd9f2047882cf9e169ba750e3699403667e70e1a96b7c7349e5aa3003b2684760db3b2daec2678220d51a66f51e07c66fe8fbfa949460004380d5c2469019ef3cb5c9990079853b2d5b13a0e8f23fb06e4caef4ee8c24b5af4d8342b74d48add9729af8cfd8d0a20fc1d6fef42ae736c81c57f2bc75429740936fda9b030a4d6796d5851c403587f865a4d5d900ab4800c72eb35bc8c17a81f1c4ab729338aaddba8c19b156e48065433ffb6d3f765c66483b1fe7d55dc1c1413feeae97ebdf1d93f6dfe2e56693f56c16f7edf2ffd4a3a18139b63ee01cd37a100b8a9e09dd8119c0f756004bfe65d608d6054f8fef157fffe346e2d1bd58be61429968257b01c7abc12a6f4242cdbab03f3922fda8d9576c3fb895a0639ca784e88ac93f27daa655b6742e8ca6028eacda52fc52ce382d684b944c4eb94896d65943e2a4045024d97b8b92df15b04306aaa36812cce1a4bc68c4590b7bd1071ddc206f810e8ff4ec5823a90a4bdef2a0864821413feebf52198a9076b2fb7d3facabfe40fc3b2dacf382c7aeb33bae1e5704d1cb9880b4a8b7f623633a983abaded1a8a054c2409102c543154faa685163dfff035c6848442074f8930bea00458e26ddd9d42972d9acff643eb3775dad2c48307fa5321d5a96423fc40ffb49c6f543976b9b06e7a90f487cb7ed1f06e10296206d46908ce90ccf53d135ac1e8f4661badf35ab11ef23473393787fbd170f7cbdd3abdc1a9318f157b41f8c26f487c32856d21441186c09f76563ecfc1dd81be788529763a1de2678047db3615974dc84595f75f322e6d9f5373878ed1f8a09c34e4f08a856579abd4aec35419a02df8fcbf4bb855af7e5105840eeeda4567cca56ca88d840681166a443c5f97c170a81ff20f157602dce3b9360d209fa1a51d9b00c0dea480b41285644720bba145e7be6b90baf4a33f6e259d076f3c3fe3e6132a4268c19316f5cf3833ca5599892ba672522b8cba8cc2672ad0071e4cc0fd14c0194570caf868d95b630075f815e2af427026ca7f866a430ac9f697c34521e9f4f736ddad77d887d303444783f8670084e06469d9190f93d611f2071c3cb8e10a25b35ccd227f4d59a889e65af63ead1d233ce23b20ad6284c57036ef7c6f9aed287fe8cede9014cf6e8f1ff41bd258c7a9bc4e35ecdeae627b55a665f29f387b28dcd76281361348b25d0e3fd7dd3fcab1b649bb870fdd687300d9a4a08cda08ceb9cec0271fbbab038e7d7431424ec99a925c7f3bdc797779777d38a3a10cc1c6ae4284c35548a6b3c27753dbe752fdba533b5053c864e9a2fc9d80efd99ee1ea1704cacd2008d27c4861938a7a4837ea118c0823c3751abf948fd1d27bf95565b5da70c81f019aeb5bda1c8b0471c1389d599b1650405951f79121d1e452786ad72ed10aae6e8aaa87f9e1e6076f5979d6a826b45152705dbeeff4bfb4d23aadd74819513c19447fa41ba474a757653af38afa1b867a145aa539e61c65faa1c1856fa8df77f566e2f2e7e78f03e29144169901122f603a2359b6600665d15d8a0358682f36108991109aa3446944a8684d1f59a21ac7f553bc8b5c51fc178e7d770ff12692d806eff19568019bcaa559adca86cf0612c1c62e930f4359ffdbccada093369218ade7da68abe4a6facf57ad1c2a78fbbcefb3c17b1e5bc53afd87f9567884a466e2809eecb444ba1a1f0720fdd5c0094c055eb3d633627e35da3a10926dd2de8cc263afdd4350dc5feb10273c425ff1406acdb72fa992c6e3b6786b98cc245fb67316c66436d59d6f8fcdc08a80ac4a24eb76cf6085e3194f01834d3bac434da3706f4baf058b3cca0d7b52dc247cb446d253c46fb26dccb269e16d2e88ebbaf6001bb13c12fc607cf6a6d4268a0fc40cb1a84c627580f63caceaacb084341fb90ff27f5db09b5b8bd2551610d132f9288e3a1f6a554653e470f46714f3cee7103d5c01c90b5814dc9964c8462f220317c01e229ca89b2f91be4254ad25a54cf249d9ccc723f39a31dfe33fed12196243e71f83d4d29ac9a13bd4c527deb31e9c38e18b4a19c50f64738c3978f906412c74640eace37deebd6f41bfc3276eea0c986cb2e5496a7e74272c4ff59fb7efd1762b50fc17e2163fbf8f97b4b5227af0a76b2d9e9a5325b727be454ede5d4fc3d8d23b60273cdb474047f4f1151dca3d06c29d48db894dabcbd079fbc46c0444e6fceee7b3218ed8e95916c2255cd454434debc1a86b4683dc3a429ec0d8f19337034818f784e5316f165a4bfdd13eea7a08ec9e42c3fda27b158ff5830fd0024836b443c5338f6a8e70d67766d559df3d8bd9768e7fcfc6b219fb03a60a8c67985543f9355c88848edfb1d79a6749a57e0cf2d7de01b145c6b2c254cde6514e616921eb7b949c9f04bcd36fa020f4b9b5c997fc6f98be3ac6c6da4168017558f6b547ed992ce90bd0cdd2f87e79033131c1c9c9cf1badbea21886a2f4a787486d0a67d5e81db7c612fbb7d3d0c4622589df71f8d61c0deadbe4ab26b5e1242982c468f56176f39c83e4e353b284cc49daa848509313ac715362d042f375ec314175087f7a29562dec0cc28a1ce29a5ee6c639ebb2d6d27d7771bf3f0493a02caca6c8add698b1f3af22f82b83d14d551d94e162f11819b083102c4a1e38c6ec62d5f97bf2731eb5be5f589c81132a52e65cf9c619bc3a6288530adfec80ddb033acd5872eef7102db08f06db8254ddc033852803ec96fa6a7415720abfa7b25fe98f6aada7bfefec00b60310131ab25f60eb131a8197961b27506fab2c629c9e97616ed4d71d7cdecc271d7b33dadbcdf036517b533718e0f1b5d458eb0e9e28c53fc2c75f32558520d9888ffdeb7891633477bff492df9caa66c1b05973fa5a34b7ae1b7c41e87cda2ef7742767d0e0b81f3abc4e5cde4d168b75ac72d21aea7d3a4e5e3a4670a5ca2657e05443c092a9dfa7145f61f965433ac8a7315ea424049c5fb18d0c227aa7528df1408def1cf27a99688ef72bbe1e7dcb96f6dc3f82c25e7cf975f4dd2a9b3181e3afba05bd3e15f2e91582bb418e74d0a531a4434c369d0c8991239027d139af1330b1d2910ed40ebb538ad3a33442ce75946956047216cc328b6d1cd29f745039b0a67a4e6e1533771ea6dcc862d582a467829f7b9b82117176c25c94ae077efc706861efb455bcd576b69b51e4960ac0ef7e8a6c994c2e44417dbbd6c6019fb430b10ba1defd3a7cc095fb8bad3a72f2c001a916e31f721e439fe98b21b39135d9d5cb7f97501b8468d3aa6db173ddf0d48951bc58c46203e075a3c4fd9b390d51316824110b3e20838216af73b446efb65b9f0fca8f393d11f7e4c73fb32636ed181288f9ba90c343267a245c814b37a4471df0724ce584f24372b2c3851e1d25987ee2f057c4b834383f436931772fcdab5cc278e2b48a27738168dcd52e8e01849ea56ed6d5046675b18f2005094ab671198f3ab2938fef928582b51a91e308efab97bb01346621c2130a4c204f808514f0e2222ee3c704517e308b64495e8862a04622b9a830c843c9b9360b39bf5ab82acaceb0ceafb4ff11c49204a6d03f1289061c38756c1449f6d8607bc4c63d40ed0afcd1719567511eb930b3642a9b80dda576603481b01686b0ffa8eac05dfc5568d2086b94916a0e1fbb9c1511f9eff18d5a2600fe316d300084fd9f1f59cc436b650d5ad2787a1dde435a976f4e2320eb7fd177b1034809d10f48b3bc2166efac6ad9188b80959ac75d0e9fcf32ed8f6ae3d9b7d93952bdfc04bdd3f3b15056418341a124ba394c43873e8a151fc3eda043379661901554cad359056af87d9f116c5b5608b1c8812e849729ef858c0c8d1a1a94f4b94e776f309ac2a3d8166d37babc6edb691c19b0ee315789a9695bf58463b4a9aea1cb44b64905c751314194edc3598cadfe0c5d4725c935a0c8d0b86619854366059f6b335d1a0ac5fc11a2a570b030edc414a08800630b5f00fb7dc02c458d7e8950414c994ac4a83e1ca52d9f02bfeb7997149c900dbac661362fdccf65f6e45d93d9213a78dcd9c12cc1e7741524fc5c7cf856cf64ce5c703357eaa64304ddf55a308a07f177b6a2127d919300c9505a020228df447202f18b7bffb777917ac9404b542b57d026d75a5f1c40209ddb31cef79ca90a5978f1a80eb847165551b2d4ab8e6ac36d8ae14be4c55891f96ff8890b92f040046d4d58bb05bd775f55883b24381403073657ad0446e2c83264fc2cb4dcf95b1e7da0a558ca6697fe4266907a6f5f3c92faeebde78758181f9910192fb30c4b777a8613d9347d3945a9a79e93a664a25919f64f10e527a7aa916b69d6c6ed5945834f2dcba70922cac3a365e2be5d68ee11c5e5cf9d1efba2fba1f92593aed70e5d6a75672bfcc7d7cd8a4550e24e6b5ccfc6331ef47502f4000c09235d860dfbf6b9ecfafd06612dd02b4448e3545bb6dcab817638c194920f181a48fa77843bbc37c5895743515347e4040f7279f2038e02ee769de799665d58cdca94e8c7ac7eb6e6d298c4e06eb1bf00dd4fee8337ea66555c1aac4a1cf5459e7ba1599fc41f2932bf4ee70c8d7b7c6026d46baab552b5e10b64e4a9c15583e6f863a770d45abfea77c902abfcd029441ac09bac0471f6ce8aa4f5fca520489fd9c813f8a32c0f066e0d4e609818d34e1a341a9dbb39f04b578b3c407990c719bdd773da486135724483116ba2a559a54d347ddec72c0a1ed02d3bdd7386d4ee3dfc5cb71ab5fb779575fff93021090d5e26b74424e6ea7b22ecb2a3e8f16c5f97730c26010426f530d06faa951948ac1431399ed47c92be95c77eda58bd3a4ded23dc1294450b50613bf3ebcefbff44bb8f13b587ee6499dc57b04abf49d2737df45368a9c6568e1aadc02d07665804efd54172e3efc0fbacab20aea54829a50f27520d96ae69a2743367d033d7aed0eedeb1f0aa527bfbda5aa3ba6800ab8679a26d9cc940b7c7c63f5afd7c9f5d8e34a1e367813576e8ce86387c3648ff1facd62ddfb1a75b0f96be3c471aae360f353948e09111252a4b59b9b39effd9a639c8dc790bd7011e00ce0aec097fb8415ebf8e6e55d4ccdc5cc1eabe6b3dd9d6cbf93e376b67578b9d612bbe11b352a9367f44abee54fb80572c186f0a800a497cb279984b6524cb94ba459ef32ac1487bcac81c859f186967702fe668fdaddf127a74eff3234fa309acb0f25a494a8f598de5bb1108b88a5bb28e64b91458a7a724b3ac658c1c0f02af83e8bd9add2dfb36cf60ce8fd80bc4a243ba30e797776f959ab31c3d9d3dae6936b53c4e063b1c7fe034588ea5701915313fa95f4d1cf24418d52931dad1f1f516798ea7fe2df0f0cd4dd77bffd4f7819a781586da1558aa02166532cd52e54be2fdd3704121d35942eb73985585c46c7e40533eaf9e6232352cabd1f3c971d06d130f8058b1960c3903aa39a99b1675f619cfbc806de4ced096e63550ca81df1fb36d1dc7542f9ab2c4d39ea986572011bf34dcce27c96f3a7ffc085d5fec7a48e76fc0d69e1c659d9435fb5f7fac66a1bbd051250ab34dee1bc10f8ff7a546616deee4e55d33a64bed108285a472bfe1712f1318d8fbdc1c6a8cd463f5ece58dd1145751dc0c3fcf4cbba838835e07d815ca3426f644e574e2e75cdbababddad7538c1c5ab0e982263f6fdbe60dc06f0cd8b0b02cc0ecf3a89fe8f7af9403ebdbf9b6f3312f57da9e6ad1c3a3f37c5de0e0d8981063fcd634c47747bc2936460eb559ae2ca8ba79674d42e8c03f5e03ce1f7756418e6e6846026a34b69bcc55824acdc8b444550497f5855a4e11dbabc321bfb14203630318c5304c55f79756baae0ee97f65dc23aeabb0a28390b88fb252905c02cc9038f51e4ce222b1c51a04df575a6b5b688793be9833808f05fd3b650f8b4f3e623602513b3d803baeb3c8c4edb9e7031ec0b8cb4910ab69a66b32203f40e59d0f4d733cd292f0221c9d5aff491d059e2b3dff769ae46a19d85e3d356ec3a9e88c140d8cf867b89ed940f8a3fff25c8ac7f31d20bb414d80099f17ed16cf05fa7d256bdf3a326399281e045e23a9e58406a4f7d626d4ab91e2f0887d8ee883cd9dcbd66c41203f5b547686355c50b5cac4467147c84a6a479fd2d023ee5a27bf205e75c65fbbf4a647bce8304d67a2beca6cb0ec67d4f9895e52801e645013e82a4529d0c18aec12e1869e0067565e6f90483990b202b6fe74f41b745f37cf5d8d50f4d8cadbb04cae9f549c446f2438b66a25ea4bf4a50f28c3ef12d62ceed6f7804339e65e6cfb89e557db00a386525255247b042802dcc94862377833da57951efc018c59f8ec6bc6f26989349df6547c7ac9545ff6bb40efc796de8e3c374d93de25127f354abf8172bcb8a96ff677e08fcc220bae3b4ce88328c86b34aa3515f157382cbef2b892a7edfc118e53ed119dc7a70ca22584121cd528cc1b1135a39cf66ff2bd1e0c80cdec0a41a086d99ee4eac8141713048d004e1841f357582931c06d3f8f9168f44034b879da3d8d95e68980dc92bdd92c0063b84eb4fdbc5485113feb9bd8f9cc653dead01c10c0a53625d7d9d85813ccbf76f708b522dab55563f9787bb57b77e72a86ad54c212a3202ef45d563f2ec6466979a2c2bbd55f7258d929561aeecc4d23fb80b2d9239f2ba47188d40dc9b0870c1e5e764950e7a3590e23ed7e428eb7060784aaedc6c672b38cb95a2d9f6116de6c58a1622c9a8764b297809e98d6334dcc0678685208ffe9af860d8ddcf90473444362541c3f29a7da66823422d3ae0905d227c70dd4b1b9159d93e7448a6e5a928ee3edeb1ec02fb8933a356f468bc593ae16274658b6f3e215fd0d2d26c4f55204f16429e2758dd176eb2468f2245d1aafd4066f66e9a2b2bd4141a554fc943ce88f151964e6d833c692cba267b0d7d07c961bed1af53901febe4376e72a971e65621daa4a1b9c95965bbd2bdbda12d3755bc6616b1a593ef8332f41c638f914baee89414bcd71f6875bab9be70abaaa05dbddc4106bf4a28d4561352e6c1b8c7e96ea2cbaa84033f3ff61bde9e17a49af2bdda3165151d0622daafc5b25e1516b06c4f63c9fe5cf7fe105751a371d094f827b985f8a2966ca49ac6288b079bfc959510c9e46bffe4b11df9bde0898f777691d8a8bb4244e5893d22ad7fcaaa75a247b3f304c5d75559ceefa773c9e95e89140c11c773bdb42fc27f0b7f8e0dfe082774ea96befdd338dbf886312935de1343fdd05ca399c4afeeda788d92e4183c0778648708598a36a6dd2c04651c1f41fd6730f313c18e65b91df39376327220a7141c36fee9f36442194e0538a788a3a9971c4464ffca614341d9cebc96ff9a5db15c10b977ba17a41b0b24f1a382197394185594c4e7b8e6d35c44e67c16dcbc7c26a9d418e00849a6553c1cc4182843ef5a0684da4620b9f43b0b6c1662554eb1072649e8a1283f16684aa6e7c4c47ab15e0e8cadc6f3b6f31a7cd11107f15ec8606612c3afd577a187eaa74872c1b6186cbd0b60304638613819786bb1a443d0700ceb1c2c5c849aded8134b78b23c39678dea893be8e71b1796ae9b71f4132fd540377a342e5b350aa6f1876496e16b1470495419a17be55114389236a28d48cf86f271e381cc964a6b03d42b5cbea3302344914eccbc96ae71872aeb2c41e0531999d40a24cba24149c53201eb011ddd9f5430075ac51c3f54d2f2f0c1b19ec836e903acbafd8b40d49f3083a366627be17d09557615538b1be6fb99101ed6114913ad25462f71c86eacb565fd2caedfc6dc0d3a77e0395277fb6852485cc94d535e050ffd01fa8cf81388881a015049c998859b80d27cde81e997cd4e8c4ac03a0873707780ccd33e020ae1930e5ad9692bd028491f927f544c1367b72ba1389f1c5b084e8a9aa50081f97d77c0a5ab0e1cd21d3a46d26ef892ca9fb3123840e7fadf65c728a4b1c862ffcef16d1e97869131f58926132cbdb33e455cc8c671e9ea115128a212bd3d9eae988e5c233777b5cb5efcb8bee5ce8c73d15a8ea37b92f8c76589b0dab27ff383a0fdf38c6d951bd193798e257267e8b685017ee9b0ab57faf7cfbca5a136d011f7ba7b4692b32f3a2c76bdffc3937ab8d8c2002e24a50212bec5a7342d9f95812050dc4e2e01032fad4394043fa8341df284ea055f16c18514678a865f260517d8baaecd54e1f36e0cb4f8c8929f73a18972c19fff793f4d583c0288dc20515af14d26e296730dc9d624e8ccc12540fb385dd8d193baec5bac40e833287b6ffc81e404d290fb7c9d85d0b76f63554042e18178bba876f62dc8c5f817198a9f5cfc768df934355e08ca6b76a416a34ff04bcd2e38718c01f0e4cd79b73b8fc334ef03f8c17eda759bab80d538c9eb4d58719930d25db6c4ae7ecfd00cb4cebcb2ea9da7f68019eaa13a23b5884f33e06d88bbe91f8b0a633c75f6cfd378ebac0a471c6fed5dad0bea6a057af7b4f177fed149826c310ddb0665113793feef812664405030ecd65f500ad7dd2517e5e8f67757c733d9fa9f012c5b8104b0efc07a6dcf0fda708d1a3e2a1c3a8dd5ef7ef52fb7f7bae5ccf5abf812d66c08845efc5e24ec89d23b675efd8cfa15fd1aac8b9288f093fb030cbca59a71fc64f14167162c9f56cdc6314c666472e0d13d0605d1d894c6bf76df761684f8170df4082bb3da5b28249f32ffa913bc0669d3748830fa983000adda14a1d77b6dfa22a75b564916bb175283072ad5ee089074a3154c9f612fb8ff28daee35a1cf6f5c162d6ddbce6d2b8c0b331ddd91605967fb73c758061de8b5ed6964017715bac43eaff42d352e779c124d81ac779656657484735b1fb450c5ebbca74da0d45dd341353644e87bbf0f0ee4f7beccc95bb9e8dc7f77970b7fe9b96e06890c7c138dc1e9e70032a2d0f487abc34071473df4485c312ba5e37a7ba855ac56523b9b3014bc3678454ffacead7f4f66d92afc7a58e1125afd9680139e8dcc9d20f7e2a3ed3ffbf420b2c2044572c9dca062fa384f0a129b5709395c0577ddb571ad36bed5685c1d4c0ce15abcee227c8df3579189fb8c24138d20f9aa60e77631d2624f35cff09ac69b9b31733ffc7dcc83aee106d0651f2c74da820307fccaa900720c95548c444bf138f6897d628004f8fb5faae0cdf00943432cb7511121b4111964e10e85bf8e4597b6be1c34a6d8c86ed642522888d575bc384b49c3e1e70fd5a262ec5d6024c7851c3fb133f3995a6dcfbd8f37de346d0a5ce50fffd8cec68c3b8be98db506243686ff6b0474c3055c3f0253db6cdc6e5f333d7be476ba32d55dc1516c3ffeff8b09fae123aae9da4299690eb66b4d9a0a6c30dc7d6ea1bab5253229e4adbeef5b80009f9a138000f9ff6ba2d694dd2ac3d4e0ea127754b6c68982ae678146bb6893a43944a90b31beebbcc0c2253ce852d1f688c2576a5821d71c3545362b2b2222a55c91bc2f7d7fce44733fd65b3a578ce5937449ba8bbb3c75322e8a87d50a29c1f4dace9e95787b0a59b21e80683af90bc49f18e874bd305233c032e9ab054814433987bfc89e26bd9bae7380656e87c7e96053a2a72069edbf50f892b9dcc82b8c6ec28f531ea33793167fc04b9e19c803b116c6469ab8525c875d94aff41762a6fb7e656c158986afc3aee5200281489b44c92fc4bdafc218449fcbce9922df717687ac7593ea41f19f88c071a612f2bf264747daea2b5f7f4bb6987a8c77c70f664b762e17d906c4ec204378283b61489b757e12c1abc09e05505b3a30c4db0350ac572e685f32efc3675e837607cacf5d27cbf940fd43e336cdf83fd4e0078e314e5e56","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
