<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6d4b315cb1f42fe6d395e374f00f1f96728ed69df79a03e2aed7af2f1a711b5feb15a2f06b092b64d7f899bff33db1a166522403d3249cd6efc360b6d7e163683cc15e850e2d838076063c4ae5b3b267a0187e41eeb5347d0124a733e9d19c20215212dcafca5961ac0936a9299f2b7e9a8b9050af095ad59c749535e51e56b6d05133a07c314620140353e94adbaa450189fb5dd6d44dd240e8c455aeb6fa768379f26155f055665571c297979933e2618561fdfc01c0293b550ef931e3ea23bab3a76b9e93a7b8401ff79d20262f790aebe67b08ec8fdc03699eb1c8ceb28d10aec379d85c2bf81972530403c419233ae0b8ee7ec42747461ce11a5aa3d93555407b2dbbc80f970e86adf4ce8b6991dfb4569f88d44de7951ff5bef132e2310ce7f4fe6f2e07d9a411dc61944d8c7240104803a8cf4df759b19c115fccbfb709b1f2f92689f99f709ec49e7ca85beddff997fde00e1df91e5d45026d3117334352f2fd26a109fe51a9c4a90a8323b6ad5cab54102c97e87f9c7a01bf166069674da5ac92be094c9d55e840f2572c3451143cdac640df4e385f24b7f68085e114f08fefd92780958d81dbc07a2841a14cb8540fed73fcf1364a6a3d7fced3c075e70cbcb498860a2d93014f8a7ab89c8c2ebe330324de40b16f92e6642c0b12c1c16ce357a968fff6814360d45293a6fd0e45c9f1b0e4c2a4f60c5e70e754781c2935735bde82959aabe81806d448517c950e01f59d070e7277c55a5bc89657cc395f66e718bf5557871e0285d189d26d362796f32bbcd3c2ee1597660890e46e0bad5eabfe68fa7bb20458dc9c633cc48f98bd3582801e2be2bf55b4caba7899d33433469e20dc000b9e14590d90cda7e899d3e7855a149f178a74de096fd2e8180deb9413ffcc647c73ab7a6c94d9293dc39610754a7825826b20937f399ec34b7b753c7841e7c4852d3957b7c525e629af1ae85de9960bc3960cb1af1042e2a1971662efd24595fad4002ed5e5b22b2f75dad98e5c3d693ab18b8fbfafe79e7a571a8e246c476a118414967809837028316c13c01b0683ce8a8cb5a23354a23a5beef08a36326553fcd52ca8357fc52b24d03bab587762395b195d481b88830214c259d936c59a68657bf6c30c2883f41c9f6b2956f0df6769ef143009bfbeb51bf6da43c98fcebdf7eb774b613a1fc311aefbc2415ca1c77ee15c5d47415bda82fd5d03ee38e284edf55d0b0a36921750d377d6f86bb5edeae17d7e1e6e792da497514098f3e0c8263e466a0a8974b8774401b3b1980de186c56da0945a3591d2fcd59449532999975f10abba91d6220ad2588aa075dba03d7400127a0394b38611ee17e95a9279d6a9e8e19cca6f97ba781f3122203dd0154e7930a5fb87268ee96d7777f7793525fdb05035ca84607b9d9e5f813dfb351d08c0bf689fafb4400a42939f3f61db4ddfa295cf4ade98ffd2d556c28b04d8fe4f6c72e3720561a0a5bda1d5e3188f465ca3ba0339cc190a133f04f3893b717fb776b3059de4e4130fbea77fb68bc98b1330e2c7632f2d4a87d4246b8e90aaa80b85d0b9e6a2e610fee90be9fa306b0417d96e815a9181f7ad9a0b6f16ff98a0a37d0af6107e0cf699f8af8d50e37776b6b8d16e4436c7590bf5a87e275aa9728de4beafe3836a0c5b0f2a6b6d2684fa59c7e4ad1f4ecf1f9bcfe2252f91c5ccef6e0be1baca029cde993d99c143160ffff7def36a01ac3f2143ad1bf2330f5bd5f412be08cd2ed4ae7aed582f511e19859026de685375c24f945f4057a3854c4401967a1c3337db0deeb35c82ca5bfcb705644eed08e066f81d895b3f1cdf1aecb7a1947df889e1a2f93f62f77fd3dc3c031493d6f56a3b9b511983e2136932cbd95c7c0d551c4ccf3b8f5c6935e1fe242b89967a4bbe7294d4dca7827d9a0b0c06369aebeab6aee9b6f070f1f6e62052a60f5416914b1bc921caa5e6d948b736564faf161a737c1da62fd5fe0f33a9928c76eeb67d563caf92b432098b659fe295498993eb1c1cbb5632ae98fc33b8b5b61a282061bfaeed1a86a3dbc393fd2a8dcf2ab290da00a9df5bbd0e87c80a1a4ad0f66db5ad712fd927723240658c43bd229d3ed3136200d2bb6ce883da4e6e00efd511699d4e9aa1011186acf4df690eb7485b7c4b0a14172ef5e813fa4093a1303b5de49354ed334b5d5522fd853a561b480107258c004dc02c3f50a24ab2a8f04268584cddbb59e00f2374fa49707dfc126d10114cd76c80379c756d8b26a10779553c841a6acd9b5e61d63985700cfeed70bba2cbe8133bcf89f87405166d0a13371b739411a106e7a04def1ac0b4f63e26a5ac548ae3a8a591bdd92e9cc7b84350378f23fa3b9d41f2fa0ed1dd77d2f5f4bd3a2f13cd2f607a518f1c4bf6d8b1d19de963480b0710d246d370009c941be9c08315fb7b16152ebdd810ba3e047422ad8eeaf55c8e7e5259215ab879b335e412b02dba977c67e1aba3dd519a01d6bc3ae1c83d6f59a7e3b72e54521601a74a1e65ec60d0c3a3cf633fa29ce35f90bb44f797c79e0fec10d917fe0d30f39d7139b232cacbb91345acdae606ddc5a9a19a0707f84ae39f73fb325d4bd456d0fa951b4347db6e740d854a4de3812b1a8279132d6e70a9b1c821b0f23cc47bdeeea9d7db5b8a5c4ed5899b1c5f78dd61ee54e9cab5e022ce646a554cac8920981d25d07a31dbf1bc698fd854a24f989ee3d5df00e07ec62fdb16be3e5d4eb6a2f512f448f4bdecaed9df24f1a44c050d6283ffdd5ceb117953c8a0e7c142fe2470166bcff9a5ddac3bb5996103bfda3503cfbab6c6f59413e8da9b4f682b3b563bb5e040ac78a8393805c23ef8b2c73e3b68909151387b33c76ad1ab8d3cfc4494c27c8c45994557f70b79a4d72434603dc98ed08696dd6cabaa3b94d99df911d3da550354dafea35e1c1e004e3abee4825874f03df0afe883ba58ea2935d5082ed57b07481ce75ed9204e2971c370245300c2fd99faacbe1921a78a077a0c4d28fea22f8657df71fb3c54becee483f003391853d3a039643fb419665c78221abffaec7a732db4a7f8344a9966d05c67348da976996997a798d0bf7f0790d30e58af861254a917325c9c5499b0b42377a44b1b6c8d1bf6f68d58d39317d06afb578b8f4b2335097c98802b107e383e85eb9efca7bbdc01727ef88f50b79d1f6a99b475a9f6ecc5d5e9763d130fa18ef7001be466e53c88e0818fdbec96f755de1d3f45c915a35044861723e78109d2ef3343d58f89ba4b4ebe8ba09260d0f5f6493af2e20066917e953f5d9da2511c1a838486f6c9b714bd76f8450681c4f2329556855d0e6a3c10f9a2d8646b15d8cc78d0282987585fbf636d6b9aafd2a86b773b0baa2b37a70c0847e99bf519afac9655574829d92a92cdb38945f826035edf582d9be2a1519ddf8760e6d96932111ea026007c425890c17a641cc555110962d9dfd3156f7bad3c15f414c3cd242a8acca2abeef2926672c73f77191c6b8d6b1d064a5bf564319dfe676d7ba647b40909b7b6af63eef200a63af3bdd7093766de4e3a08a2f50022c9ff027b800a4c4ba34c16516b7f86cabafb1308fe6cf13100ba21db86cbf5374a9d8b7ef8228541d14a3ec62ca2641324b89375bd0c8db5f34b839f1e1d6be8901b2908544d725b7cda8d1f68e4d2c5b8b66b86eca306cff2ca3e08078e148cc91b82622b0c218230eceec2111e0c491240cd207e388e237881626215c94509c9806d92d4f0ebca9cbeb929f19ff207eecf4762e3bd67b80bb431035a032c6f92fc8bc4f3e1f1a135b08c3caba0fb4beaea41a83a243b19d15b7ea45f3de5ccb8b6412ffc3f01f7c4289e693ab9743910171c03ff4a3e66b2415e29f8a2fcd7b74477d360d51b6ecef43ea95b50949c21ddae288656bf6332a4d2f8aaef572dc3dc6ce0f67a4a5467801d8169c3ea7093d624123649344d345af00ab38a49955ce712538741e103626fa26cd55be0f97a20c4d6f85c124de64365bd3a0ac852cf760447f873f168d0fc8b90fa20ffd0c1261d523ea9d3d91f5d2f6dcb4e7d775ea7d8427662c4ccf7b8f7dbac479464c3df72cbb2600444c2c36a757095421e47dd35538076443f115e055c6757687e53875603151dd069d2ad21a89220288cae7dfaf64cd189f0237973daba898c429577a81ab214e494d610408cf75df78322510366fa352df015ad01de791bdee05735962fef30c265b80bda2e3b1e5de613ef568c28122787ad5ae2bcc1020f149b5999d849a3eaf94683ef5b7603becc2d483e747cdbdba1bc0c6517437fd2ffa79de90cf27d45d97ca502fe00f7a9b46c870e799290a13b3adb07ffc2db36f5eca6a3d9972b4715d4507ed531d11a509ef79c39572999afafe3dc1baf51456b95d532e95f5669f8252bb5362bb8de732408b4a7ca7fabdea86db83e7105150e458dc83bcab2f74c8fb0f63651debba791fdf528a7c150ef1e5769fd5e4179ff909391c3cf26928f0ce61cdae2c4387d76b8b96aeac5ac966efd054eb07b0028fc01f0023bbc7474acfbada50d345fe6c7b8c6a6f2bacb504e974c541d0b62ad9d99202be9ffbd3e572640079905a8ace026420e367aa455ed57f880903b87e926a392d2113427b2468ed00b5afb2d4fcea5140b3577dc5c8174738d54df489d0b714409dda6f125bfe7b282d41ef574e0fcdd73ed4f5857e12e3d9e44d7f98f342609ff63c62803c0977326560eb1ce6bee0d0afe75358089f4154cf6f57b66c213fcea52a8d5cf6f2ba43d42ea67583f6f2dbdf56194a7d0f392a5096c24f515e801e1c1b47b5fc6b0463bd56e4d78ce6689ec42525f61ad6628240e1e390c2b1703892c16a2c76c63afc3cc3e8c357fc87bd3765536231b5a61b2dba01f699604a94b1ba21460008f4704502ced9520d94a1c51d97bdbd5e62b26b6eaf33f9556d7114f91fe1f1627da10a5d0fdb5cc8292a2413d4dbdaf0c8e4c958f9435ea131d85e5d1b68cc97b554505244fce48c87bb46adcd217f9c0cca61e9f44463ef86fc133962aff2c5ecc249f92952ee24f9f33179eb6b5ec151c55aef2bd6fb5caa2f59e86a0957560f951f48df8fb627b369bd960f4edf3ceb5032a29600089745deb7b5981b7de8a8ce784ef7fab675eb0655b3ef73ec4ae3aeadf134d66575e9c6a0eb0cf2e1f370263a011a342862516f219f96b407df59bfed13c25088ae43ae99672d5b9a9b92e575adb14a21b9fed9a92d70e1ae055af28b26c1e2bb96c44a95c122c0bb13ae69d6bac4798bbe94bb44c409b20d1cc92d3b1036c2b6c08542a3535abc6e4c62b981596d6b64243b588993a7c686e36d7c3e3f9dab53995710346f5b0efb9e36c26219fe45ccc1f3792c6f7cdace99fbf0985c2f3d0aadb85cf52ccb5598bb6808c980e997f1f582fc59bb4ebac3bc7b16d705b6db4206099de9b47991c100472752e93fc4871a1a044d6e7a63341bf576a085072d9b80cb1a99ab08f153205d2bd1487aea16e57a2d760350947fdd8838265d24b2ec7cb4096f09ccbfa61ec2241fc1cda2c79cd02ac42fca85100b10a49beeeaa3b44e86908af73e053db211966064842a7d89942660a5d3a927504f9beba2a0d4a513ec0b780c5fd36ec9b7375a671c8cec7a43edce4b3a93b072fc28a98b5d0cfc6c9b3b719a236d44f82fffb89815138fbf3854a2232bfece7b09cf7cbdc84066c5890c0c47649009add7392948976971c552975667203cf753a2c64fb605634593d9812b136282009ac167ba99f3af91b4add4906140f1954f6e7f04b55b51da079039d33d4470d2796eeddcd31f25d2f3aabe26794fd70afa2173244288ef0b989bae518b7697eb6aac167bca5bf36c8556ce6644a30c26469cac9e128443b732c439f112f092e34be87eb2a336f59bafd4d24fe1fc487006a1dbb431dedba44cfb128c97a360aaf1680e819057c7f714d937f94430e298ce9d371f6bbd0df3b53691ee7d32bd18c4234a8aa46e0485297d17fb5920ac12d5e536615a6129ac4eafb2ac7f6c52ca774865c0576635bbd6df19fcdee6b602e7ec7e3285b4b3d4234c7b2c00160f0699106c0ca6fb2674430d1593b1ae8c6ace789c8ed2a87d27eb11ed119506ebe940e8b836d0ca4a6f20e04e081d0a455d24346bc059aa97db0132f819eb2db3a0efb769be94c1568712c183ed38032bf0d23d887814fc233201d5aafd5cf882a37b43063fbdc397035925194a0359518ce4a5374d1df8dbea3ff5334b2371dc43d6f9ad0c9c5c9eda71f1aed4fcf5b58a1eba8a51b5355382645bc88a7411ce45bbf848786b33075ff912682f499f54698b00fac7c01fdede4430b6b0dddeebd9b80883c384152a5864f44685003965ead571010faa482d9b031b4da3cd2c5cf068670753a81dbd27501f9dc6b8380fdbb7114c94ce2f2fe600486b41f70cabfd65341f531317f4a202a94b9d91c9a73262a8417e24b443ee36ee480f9a3e0c068f0f250b0cb7a99a465f360f87a0e9c4fc90619f219410b1d7bfd742b8fdafa9e36d4334807230ec51440519020725748cb6bcaef8e732e03cfd9c2aa7dd5bbb1224bebf4f5d206fb8f0fa062cdb794258ce3bd582e5029e102ce350adb165066c4ec313080a805d187206ba8cd93129c716aba5707826bede90f7f97a763491b50ff1124c3c9cb622e3350a84d345b460943cdb7d24036a26937b9fcbda2a4a0e5c7a344f778f183b070afed0a8ccac78ff5ecfc0141a5cbb055f4a17a5fbbdfeed4083695d0bf70495a59c0b66bd53fc41d7bec7ef463c70271d27d8ce3496f10d4943af7a1f112a1da6e7cb5881c0ac03345f96cb4098e62966a3459343210a6264c195a6b3f030bf6aae5808c0bec2740354cb1ef8a73c88d02c16a629ab50776125d3a2ca73da84f0d7a6dc11cec84a95bcc5dc4f5a529228121eac4e9163f2aea96c073ea11d899c3365c7ac0fe070b6b0562fe3c73c0ecc0da803a74e28c54cb756ab704ab042dcb92b0a72bc8195487de6ba2d9ed630b29adb94f5b0219a0f7bedbc1f80d22ce80700925665205c91e200a139d2fd99d21475a978181bbd50398cb3ce658a30acc01aab740b50924d4118f0f18a0ef058c5b5e66fd9e54476b9f558b7b809fa3758451b3e37d31c36e7adfbd2509fd295f61821541f6056757d057f80e764f84bab7bf00a6fc3028cce80f5c038ff556d49b6eb1c601be43b326c1e72cd1e40578c020c112d4c263edd1a419e2eb9b131740d2dd56a87cf8a16269cf8ac3bc74c57c947d61a284ca09fdfd52fe153ee534aa0d4f376c40ac451d9bf78b252041b3d6cea083cb13a644f086d40b7f872c47f35377b612705a6e240b18536af7b081dc1403bff75b01ed78019442be1dd7ed13f21c76f6b2a8cd7cbe3f68fdb0a063957353bf6690d01936478414a5691f950a30f65392beca70c5b5314e30788aa51db8ed0c190d56a560eee02737cfc5eb10311fcf5ab8a260a1885d138a3856222a4a501b6732d1d4b1207c1d06c71713fb60a8effafebf4b43b2a7b528204647ca0985eb1d336ff99d20bedd8996949fc6f83b7b4c9f056a820ce0c9cfc759d50740acee59b0f2b5b62e02855383cccc3d8e6b78deca621747315437040eeb5de9bb18b3195b9120154b56c017c83ace941eebd1271a893a85b26231f3d53a290575fc35d3aaca37636f22b158e634db2fee5064bb3b6c8115fac4b8c09026c8253888d3f6a5fd263cac2839cef0959687e66d2c4981d891903fdafd098d9df05247f9637f1fe3de831b2670cc174947c8bb9797762274f6f21c9fcf33464338c8f4951f926aabb48ae00000e2b73ba4f86c65bf2060b23f30295d102bb2af4a6551db084e5c04277169e2e9f2852f47692b20a68953e371c093cf1134285eb316ed972ca1d9e7a78f2b7ee3745abfecbec38a97d546e24f8f6dbe5e06fd08012b5e46d9543b76c909fc2bd968633207e6fb15af9dfe2b7e1fd8fb0926c04f04156758e7bf811dcfae0c3a1ced3b3c2c496ddfa239ea5c0f3c67c4075266757326b232cc46f91a67e1ecf58e4ab751707989902849ba259a18a7aa804c1d1f932b004b4ce2c476d0c1dcfea6211b908d9544754073d861efc4b60cb926ee9f0323eb800c8f7001c3ea3df92afadbd37bb797acad0cd2173c7a2812678aae7e0eb398d09a1e7c2e44f0763a7b47d8a9f33549c2d6f2fc99b033c25985bded09d87bb689c67a7c407cd0279cb14f28c8c86775bcce7695f626d5284c22d2aefbaab2ebebabf8282de69abd6db766e55436f63903e215a3fa7abde8be09286ac4b6050fa6e15f4b5627214222cea55ba052cf25dcc55c4fa7f41a4096daafe332593eb2072ba8eef22f928a1585bdb40f2c20569c20fa97214d6d572d05916dbfff4197deafd3bb7855bc03f788f6effbf2618a6e568b968500345a7fb37aaf6d7d0c1926705d60856ab846afb2bfa4fea593e03fa098334c113ee6961db93f71172fe10b1eaaf4449f93dad8e86e49b1011291d7fda028cdec6bb4c16cbf113bbd60660856d4bd5197cbfebefb5b644c09cfede9be10de92b5d1f68eb71c47300c41b6a3c83c966f0fbc1c523cb28f13b04e139f0d9f39a07fe65ea623db36dc3230c0c3fb58d31564e3e68c071bc847ba9a4d9596f4024432a6a20142dd44e8bbac6c021ca7404837fa3375ddfef4ca1307b27bded9428b99c322d07b52906adeffc5997d08accc4584ec927c75cf193e6a6428f60ba97cac0edddf222c5bec95a6aed2f7f980696c5739f95f642036fa94f8942c7a5a4aaed106dc959d14419e3236906cf081afe7e82af0d59e6e952cfb0989072c14425d628c327ef063abd2497da5a3c5fd96a50b71410f4569bfe41502471fcadae90923926534f1b56ae2880939038079b494f3c95578ebc91b26930da86bbd6a42f57d7d243f4c36ae51ace7ae799d9d135142219279529d1bac5f8c00c65dfc8207b996db0a2d663f3cd816b21c54df27e07816e727f1f1562d5563db5da6c381c3e59d44700f0440b2a7743c6c00c7adb8e9a0056da0711c2d87813b12d68138cdb1b6266f8f18d10992fe816956b05bf70221ca7450ab70a2e208c42645f1f0e520bcef09289dbe93fff28f308dfba855cc801af084d19620cd3532a360081b840e3a306432c4b142f102698536800ab7ccce690519e2625e47fcfa7f14eeda70a40e502a294590c6b6cc6bb612bba69156e9c05e1ec5b273a7f578de759a59054130bd15f56e092a98aaa85b935b1f4f1341d64a11c057ade516a8e47f8977160b3450d4b84cdb15e8ca27c60b46fc963712a42f207d7b3d243346e099af53a177231d3a0b226ed5d9f042a8223b496f236bc986953316e461459275d3b8f0c55ddd9b70d0fc918ecee5cff76adea8496bb99237247a3147c09a94add1136c811184f6e6a291e390446ff15dd93e4b750d38610d77833bf9407132cf7113167ae9a0b4e7f33aecae175c18fc7a22041e296b30f32215952cec256b0e023f28d2c005ff2aa32397ca8a8ab564122694588331db50c1b9aeddc85a875191e64181677de5d9912b2dcaf8e7f14140782116288286e2e4a4802e3a2bb3c76b49ee87e9868e2b4d77ac56c6a37da61340104fb0e93c6592fe9b4ea87ab46ac9c486bd80631a16c502a3358d47b671b16f96254aaa5c02d11239f61508e57433a842c6f491fbf4c8ce0c407f37f3df8148a56856005a6bfd4578da302549d2ada868afefeb64dd7491700ebfc7e135b10acbdd2124c7bdd42840f6e925459347c33161f9833355463c55764fed7a2724e93a1b0d5b5184000bdc6a5e796ee625519db994740f4447c03c079fcb7de7ee8d8b6336d123dd229291331dbe8902d35ac270d92810bdf45af9b0eaa34878366cd0bdd9b06a2de588ad0883e4fbaa766e3f0e976dfde13baada6e36fb84992663309d99fc3a90f1d4be5fdbfa88055ed7fe89bf862539bd4dd229706baf0d6b4d27ed65a8f00d91fa9c3b0954d333e9417f4a8e4efd69ecf9abf51937c1b6ada5d09523f024e1b444137efc099cfe73a32d2235d64e65a3e68a31e5f3f1afc0d1e19891a186d8405e522bc243196fd0c9a436e8700cec9dcd55515bb7b4ad5e1e77243cf9958f44c1be9ca274683c9998117ed639d39dbacee61f97fbe8babdc31ca8aac363915e8ce598f58a7b9af056a48f91615ef03abcd9ed522ca187a7e7a05d0d2f6cc490bbbd5df04a54de374cb00de20adbf87d753f5cb50c1118437e114ff016044b5a982f79a07bfc3305ecb74aee5517b8c11a7b260da50e3a4ef96ebf26a43739b88e0413599097e748595914c3ac2c58340455d67367f7b5bd10566dc3d1a72103cb6a894a0d173b486ce3fd4a6280281fc485457680fd4df992a957bd0964d4c3c0abe358e9a488d6fddf18a92c29811c662a3d3701861e7fa44d8f21c95c364a9b8ad7ff1645d39c66e8cab924bad3a2a90a5b6a84fc290510a8eaa6f47432598337ec9dd0db15a330504243f761f4bb8131e04861965917b8b9802c3c9660d2c05681cbafbd783d16505da40f9b95588899b27a9a40f702df24f5abf8690f07815addc92338fc2336c06b39fe7e7e76b864abeca4600fbf1394d2d02d3a101ed8f20c11d0baf39039d87a1a55618132015e1c656279bb7c63fb129c8dc3eb50f37f52d75c81019ca480bb094bbcbec946e7f1aa2133640faaa7c80837c1c0c03edc9356ed8deb9012f3b12a9ebf9a7d66e1a6b753d13b1afab6804f3d890ed9f01e4f7abacaddc56b3944b9d45d4b5ba15c22a15f9f3bb01820731fb45ebbf14a03e3bd32c33a6a2511a6fb74babfd79fa9d2b258e321233cc7cb5a65c3578ae9c62807cdee8af3bbd88c0f40912a3217457b7405be5a451543341c073d98b32276e0bc56ea25c169320093cfec43c0651970d98c79f7d5c6eabcba8a3027405d8c95f27d0b2ce5bb67cbdff597a04100f779d0595c0afcdb2c9918e23c49164014d85f9e29c30df295ad24e2f46c1ade6ce6e05a57987894a9acd090b90624d5a7fb59ea297bd8a05bacf6473a08b8351e7cac86e0ae631fc6611a5323b651ec1d8daf46c24b35305e9011a37aa01b11b748c824dadc17d768b80a72dbbf9c4c6a03ea388b8acedbbac0eccdd6b6eafaa79c0a0d8348d241b5c2ca47a9db08de0c2bba53a9a758c837e9ea08782a09f1d0f1163a8cb9faeb992fb1b239eeb684ac6071f09ac22b7e7eca60f1c16e0c83953b75c16d6d06cc86db2f2921382e131b57a8c38110ebf0e7d00ebe6951e5a8ccf9400e33c9e69dfe78f13e89fdbec54f90dfa3193915e64ea4911c861b52f788cae749a1e10ca9e580515fc259a24f5dab1bed46cb9b27a62d2430e1916778e67e70b9a3fce96d55737bc0c58d73136040998d866806f927782f623df9610c38ed4767ce5f1f371ee00a86ba86d25008ca05b481ef762a36e698d259e736a8a6c917d5a1c719e252ea23f07ec1c02d5717a47482ffab905dfe1005fc8271ef2ca706a59324da8187d82d5cbfebe5c632f0f205d3e1cbcb0015d498917cb38281de8792a1a938d31fa3d92b43c4f5c3799dc8376e1390644bfd7cdf4285f4c0a8ce4d8d477b712f889e5b91c0aa053a1a995908db5827a8da28ea7a20edab5ceb7231bbae3e7b2a9d32fd395bb90c111702b06546d5daac16fceeac43c884a9626cd1a7c6c067ea64445cf4a6924830664504080dfced6fc4904f5789eae45e0354120978af3580b73d1088d2cbaa48331aa965202b81c15e805dc58c6e6a6884cb3c7c0379b43b94296412850847fa964c081dba213fb7973785c0d67d2553c817f21b8bdbfdedf1d9ed33eb30771a807506cd717851e98d8d505885b688b1ac69c7190296d34ed7aa8e6a712905b9731262361de29b68b84c9aae2fdd146fb78c26ac6beaf64e048a82014bca53052fcb99cb3416ba522d8fc7d9f463e6eba28bcc38106d9b814411ec779ca73e67dee27a2e138dc96b6b5c0fa39ae594ef03f7db147b0a99fc9d1f4028193ee2ea9a0b0630f43bfbace86c236bad8f027ab1346ec9141e4387d7479849bdfcdb51c95b9d1a8f781446da0370ee3986a77e2572ba9680c28f670d025304830556c5320ba5cce58ebc24c70860b910d2efebfb931ee3bc7cfe057abf54dc6cb2e29ae13f19ae582c5b9cab623df304348e8ccafa9b174246114c48d4a4d095105c333d27d9b5c2a69d1d0a48039238f40b25c546c07f36f76dcf5331f45fa0151670a852205b9b5a1a5148857bda272baf52c16c81b3afa758c1bcc64775564236fe833a3bf4709cc551616dc9cf6600e4f878a14dc1f83634c015d593da420bdef6d4e22f91b5297bedbae1b8f356a4783f97d5030cc0bdbda8a7b71b0a42670bcd98d49ee0e95220bd680a1d3d5d440a80d98a37f688ce5d58295a21684007c6de8dcb6e6cc899759d1f524082a68760b0b467a801fed919aba498e749a5bfa35c00008486de8f8c6aa1e834cca3bbf1345d672b4e8828d892a1808859e493ffd0ae5496476986ea135ba949623014a0cf2155cec0ea7bb6112464d76f0244667dfae3fcde25bc6887c1b5317641068a1ab4f380a0e617ae4b7c38d340d35e13e9958ae70b507214f98a07208fb1f636467cb90cc2b3120f8106d15a5b8e3f911c044df9fc02d362d50c31e9176635ac2c7a9e4d9866923378c19003cd8112e86abfd33ec0699ef53961ab4c8f17bf9835c1e79865975b2647b73440ff03ba0cc473ba604cdac739a8fdc9a2da7548ee1c9bcd8ef6c09d371bfc5d5e09437b2b41ecee5e73eb2e60bdb1eea0443e499a22d8e70c7d55e1dff94b0914bbb582fa8cde3e7e38e68afb1e878800f197ac56b4d342355eadcdd2a1bde0dd104dc4554140dbcbf97d838f27d2fccd07334edda2ed709d6572af738e4afacba60269ef2fd8d68628bdac530ce05648d521ee1859bc54161475e42f3a1d3f03bfc660588128a11cc03ea40c096d68dd9394fa9e727b54c9bd8863901380d74af3b98cb5393f17bada13e93c6c38e807c0d8aa99ba3e9b8e2f6ccf42f012f9e6c1acb4853daef6e71bd840c3302dd9326de3d1baf99e4c1b6a7fc26fdd4bf05ca4041f60e8334fdd577b04625f9a74fd805beb50eae7cdd0258b66b8e666f49720749e2adf27058ed92aee4a81863b409680bd3dbd6a5e9c73cb24ae55de53b2514dea1671140d64a4ec94c654b5fd32a24ccf4913e7ee7fdca377d88cde0af8f78003d68c3d1f41ec29ca6bc8cf5d6ff1e8391e1fe6250fcc52e702990f016b3c58f00df2f02c59d4048851144e8c1fad47a553f5da6b2cfb7e14552151f1c9a03cdb262e15c2a4d81e1ef8094259d5201985afee2df47634913258c0859d4f5fd48343422e89dee20d0bf19a561c0318f767b6d6cac7e8cbe39072b7c0beb3d66f5023f0a365b67751a612cc697e4d2dad5701172c972e01905d945bfc6ea746085f2c8392a13791db6e5d5465d999bd8d9eecefce662124edd42a906e7441793759690246a81b5c0fbb77c34f25ca5971887ca401d67c5c68caad5f09910b2e13ce1234827e96db3b81167a36299d3f8667949f6e6203b64e907a71543bc866382a44df0c9c3e5839754271a1f1df9b27caa3f90a895c1269df951fb0695a5b2912eac2d0e85f973b7ab92fd79af7e9bde076f1faa835e1f05955b6434e17ca0af2b883666d9f7ada9417ba9e3e37ccc89c30e5d5bc9a0e2cc89891ae33938146ab8538b9c466d462efb1e0fd3baecc63262469cac3d4352e10a3172dd38999000adecc9a285d10e9e1fa0bb30460afcf1491b50205332ebbcebd08e89570d8bf614d83048592c95d67c1eb55a13f1a61ba53697596f6c7af50aa531a2c27580a6897fa709f488c62702f664e40c30e43b7939482975732de4b07d155d6698e51b8010a0ed3e01a852c6e5e2c57641b91a4b7ee3d0c0af2291cf83d7c0d86d4db500c66a4bbd4c52f53cb1b40f947f217f77fedcaea636537dd883ff4f5ac26c4111a37ea5cb947664ca501ede405fc0780b3c7c71736da78d8e5b9fa68286527b732a68913535b94556f36634838c9ab4e561533c4f396f6fc56f06c83851339bb10ddd6d75b722e89c2dc0805b305bb5fa5f987abd67ee5a3402c8b0be669bda5f8e3c2374681707b8e13a6755b959ca1f14e3a71db33bafe488ac87a44341955c985ce47dbd827e4d17fa92bc215cda930e85775237bd2c0516ed071eef71128f4e79a50bdaa6d7e30afb99dbda59eedff442ba4d3d7547bf9a9ba4e363e257f4b0b3bfff4699c21d74564c8794800e010b5ffc413b95ac464ef2a9ce56da6ccbaa2abb3968c6ea274248fdd2d4a7136eceb429a63538bd080abcf4479375e200a725c511e98807702dd8dd787e9b48909ef29f761902c39363c6f5d79b63dbb0b074373dc8be669d13118bf4e081e062cd7b07f7dbb2f111ae51c8263b63133b378b7ed1ba9a1fa6eb11ef7a4717eb60f09735b2ac185fc8e9a178ef1a1096ff2b80e72fd8abeea6ccb05a887f69ae5207f90a49e989228610dcb6b6c0fb7080eb0ffe79b083de591695d669169a13ce0aa13e73c6f97120a194d6c2f3b70fe0377067e592d5102bc756177127f54222407ef96dfebb9201cae47effb2f9217bf33ef63683ea51feee54762014d9e0b5c7d915fc274d998ec6d414422a6550feb9e6cad600f4124721fa4a881d9e095bcc8f61858437c15953bdd5ea5ebd03899cc2c81ae31a139b282e8a02da3da6e8d5b55f9e39fe481fc57f80ba2625b318591754d2cdd5118847b789cf13d4908a8e9c35dcc68d660a69e33bd63da7b262c216dee2962fccd320b525d161fe174406d5bb4bc5520ec9c19ad16ff8caf295ebcee90719f91fc8762ae6c7d1879b4b9fe400134e9f26ea748517b4edcc0e0ddeb590419587729d31665bfd29e9f565f8b6fcec80d81104da09ed1f28f2d53a0232d26e7328e1cb80ab2f14972fff4e17663cea00a8f06848efe8555914d82b0ad7a97b4f7b4bc1edd0a696c3fba19beb7008c1404db857567ffc27699207f798086b0eda941f0a0a3e8e23ae990b1accfb311914a09ecdbcf5e5dfe311c5380dc67e1bbcf84e7ad73e595e0e2d8a77ac553092a91ee3faa4c4e11f3fe0ea8a0b387e9679c0d0cf9bf22dcfe865b0e0f25a3ff63892259d5df71701235d7eeb93c59693c5eca467de749b7448c8b8a25281247b525d8926014dfff4f5ac19f65e66427541de95dcc789885617b83e3ffb9ee62d2bfaccfa72b0d56418ac3fd67b8881d0281888ba9f1c3de315e4079ee3cf3cfef15068997fa76058e3c46e7eab6fb37a83349e1a17ff1a71e0a91abe82de4388be2c962ced71397c24a5ae26513b153552614a5f40117d3d7a7618288ffa2e02e38d9630fb6de0d7707dc19b0469b2286abed094b19521bca86515fdba613c4acd40b67d052cb80e4704de8970baf93f2161a59a47ae1c2e1aa7f0b0ade2f300d9baf78a01e6636cfac335e3e37865be6771a4330f3fd1180b3e6922182266c1565827e8654d329bd830f4dd62ff3f4b3499e7497d6e48104ecb53772eae7513f0c047aaa5a1b958808beaaa36f3043c715b1f1931ae7dae41efa34c463b13e61ea4e5e2b7939f521cdf24e246e53f1c6747fa6254f4fdb335f7557594c2cbf94ad61c43371059ba8adc06c677c83248097bfee602dc4c8ef8117752a8444648a88a8846f8e6c6e1d41bbba39e34f7d2faf49e5669de331e1a63117645419445072c2d358a09142220fb33e3fd18bca88043a21d2764728fb209b4f7f1354014da838e46ee9fbf749b0be62ca69efc71fc02195fbdd1a6bc38b2de6a0602f29d06f62f043cc36d743adb7b130864896e8721e8d63f976b198923eac9d6e649ccd947845bfc3ed6dbf7181315d1eb1e1dcc5fb540e069808ddcb376a8b8cb5b609aa3be3e1b1c323794405366b24ca1b3836a874f8bf30eaef385be4b4045f2976c4db9ac3e7e59679df6e5a26c333a6d7586e67cfefca8057fc6fcd6af096d569515c840893a126b2162b5ad85365ddb734b630e02fea5efc524aa6d5f4f59925ad0c46725f80251c68dc9f5d9793f7153f2d99f03947d7d7b86ee59ab1bd5c772220a3577c3548432788bd58852d92b29b20f10fd11d122ce57e0b39013e91ed8dc80c3f6b78f92640932e5a9e30b3f132d72efc541f32d4ea4988332c3665ff0ce8a568eee5cf97a0469e77007aac73f3d02f42dc7ecfacee099b55e9b3aae12e047141f3d532dfc98b085dc5990142e257f42866ca24fb70614259f5f58213a1661efd11d070fe743848c5e5f41babf44968a447b92953c07bbcdaa87c2089c199e35c8b6535f57cb82dc362522a6b17e0a7e2ee92d722c3bc774ec13ae56b5c0d30f65127e21695e4e814ebc511d18f1ae1dda73785a88c519649220aa301ef2d252025492fcf41bbc9fe1f09321c5a7f607f5459ccfc524dd20d0e78530408e33dee3c893f42928ba1ef3b8144c5efc39546831ff968d3733a02d49dacb4635a24d08272942691daecf58682a4520a9172d5c7230a184eb79f3778ef772516655a31744a90c8a7cd3fe6041af32bd07d047f1a57acee27282be428c34c585e02a680d205824b97e0feb96cb9ecaaec6dc6bccd3f95719d90793fc088b33aac4c85d8a0f300a05ff7beb1fc357723f5ceb8e7cf2d503f02df32caace3dae2fcc910e4f85647a6217a8fd91cf85451d7ac8c2c58167673f5d3b89e18788ebe71bae5133b436d049fd7348855a38253741b63fcf40021eea46ee460edc0f3ae502bb29fd25188ecb9afc143a5df0e7f926d2350e6da3a3e1bf8a78ab5390a0d8580aa17e3870453473bd1ae7ebed7a7a07a2122e8ad194855d08a51b5e5c78f0584298dca33d97e83a8e7f473263ff1426dace7e0ea901b62567ed1315a575b8cf9f1407629a116f3bea8270ddd61fa3f347f2d6711a967a373b226e1dd187828fe12092530d0d452cca825b9e222983156890ead0b806bd9a78ee37aea3e0485111c5f5c8809d69d9591cb84b3d7444b61eaf4d0b90ed9c21157263ea91bc43d645cd069eeb4689a2dccfe535b3d4bc333023df562284d2ed93e8aac96162068a0ef1a75467e9cbcaacabb6f161bc3c973468f29bbd87c159cef54fb59556dfdb5960d87d3f8543c78b41e7b211eb961c47fadab090ae251f179f8f7f7de29cc040b625f0302ded69f8a0afe4b2362fedf9d56fe526de1bfc7fa526e773462d72b7d2391f07b08c6061eb56a5c39742235fbad17bc2d15e4f961a822b5723bd6cbf761639ba3e10c71f6ecd6be43bf45a2536ab27dc1395b089e9359562fd53b605b164d91394d4d1b98f4183f740be4a339747ab3844c3595c217cb2ec479f30e253f8092e31288430cf6dafa57a7e9a1c2ff72d9f95702c236d7a70f8b19d8e48a651fa8385171abfa61bce6a04d08049cf6bcdb7cdf908a124e701ddecbabbdd6d7f9ab9b37acf1a8628f3891842b23eba5f6c9a8c89f1cce168cacb8f0bea04b857c34e2c88feda914a840b37b0c84a5631f6411e8bcc6021b103f4cd4c8f433ffd95269b12a3e58a1ecce5e1766e7178e62401a3ffc523ef352f47eacdf20898e91cef9b976a34b8c77f3ad30133c7ef9b64f65d133021edaf05726c76624af922f0cb2797e72568d0dacb2b4eff245867b484b8e3649924428329ad3df314435c884fe0ccd78e5376041996abf335cf5e51697e975bc815a6b2457923d34c8262b11689d6aeaa53f72c86489f9d126db8f52728abff837de82c87345af3af076f0fcc975b63bf82f625af29feb3ac91770aff87ee7595db475f674820a885e11827f0818bccf77634d6d3770e83c3f3d90195a0645f524284f0aba9a2d1da51902f51c1bc536540f4f385313a7d468cad2d880490c7a8479c9770e151eed7e25116dc5f03c75ef8fc278af2ca72a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
