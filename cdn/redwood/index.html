<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ff7baf496f899654b81588fbbd301cd4d6e45607c63acce595dbf5889c4a0cad5ffca81c8919bcc1d546ed58bb468006a79f67185704d9b541277c8963d7ece3195c399a94f1ae607c12701694ca41e089835071679e2f64b8b51909a47159730183c1630b5ccdd22fae5f6a933f0ba8e3eda763e91e19b0fda28e749ef477ae7ba47e6d9f866fc3e2813313ca8f0885927f6b65cdca4912e08d8d42478b17cc52590a4a7fc8642ae15ff961015a83fa8bc9c5ac3996d0ce1eecb498833c1c9a53d0c96623dacbcd596ae9f6364e174851134a94dae1082c652b43c4337c082849afe632404ec17b5597b4e940105b0084101fbfd02d8ae9560e851366de75d5da77444153ed48b69b4ec17881ae1162b5569844cab5330dc982dd147b98ab0e32f77e6937672dfcef046e8f84ba7c90c3f04e9d7fc7d0780c0ff468de182930ab871019b3234dd44833fa53ecea2c73829ec0b67bc7a5808d9577436d184704f26da07399179d265da5ca9a49f5bd40131356c7456b867a71131d3e747905e769ace1ea9514a4dc003afb0b70d54ad56fd73a98eeb0ef83fabcbb8a524d5a5b9c26d0bfd7ae7a4b2729691bbdc0a2c7ae0d27b37510ea7262a7db1c6a0bac59c752172ece2370e59c7a01c7b77a4200902ee00f508612973c0424a2ae879c4e98b5c338c620fb58d755883f9b04d06a200acd9a2c646c9297a3ed30ad181655dc5fbde6ffb285d8071525bb80eeba7a456fac91a702ca8dea056f2641c4c343b4ccfac2fd5b6d03f86d941e7d24b0b7a05e6c863bc757302c98cb97c8445fbfd561c6363bd65f465fad1cd289ab1618d4136cb0873c029d9d001bf7d49a27e2f50c1cff4fcd3b4b87a30647ed1dbe4ec6b84e2a8f9dc159d6f9da7cebb180aa931364737b619a7a7d994ed2bff13dcd428df1e66229b9915875cc5489215b62809a821b1a615a18a897ec3bb184bd7d172fb96b7aa37d9e3dfaded1952849bb34943a6df70ec46515f118bd60bf6d6135f6568dc91707a603e8694339501ef25bb2da4fbfbf71218593af0ab616377e5db6195d0c909d6b6918a2b2fe4496e7663a052bf518c48e37bcf370777f84d85a23ac5d7e2f893b56f34568ad8bd5b72b82f9f966fc29a9711712e8b1be3bc0ccb002963f9993cef30c8442a1246c33e04ae2bff02a9acb68a15ac40580efac1baa17c6808d76ab2c57693ead9e580226dc628d26ec02f3adcd11ccb6d9c83dcc1fd0955542da5baac20e381902c11ac76823777bcf406a1d83779526ea38b6c09e1973b25a8aa1cf880fc774f62909193df3f997f683b297bca0eac9fe768a638b5596b3734b27a7d88b6ef8c81ec1b8d18c22343de857ff50e62c57fae45e5c08077323604f329c7a3437957b74514caf7a0bda5e7206d7517e4cf2853b5c17463485550076ed1d36e8b8e03b709939fbc7ec7ce35e8d6c7148cafea6ebcecd62e8e75cb228ed303683c5181adb1dc132870eb94b285188156af85b71d5eba333927ad8952f1a2f8ac53cae54397804fee3df693782ca7f700f032503cdc2d1b3b6ce4940255b280b9d969e79fa10507973a7fc9a5c5412e99541aad3e83a7251673515023014913ac1ac8d5bf1cab26e248a8fbbacd862c070ad1ae0946724ab24bd6a995e0f18cf8c85e3d0ae6ecbdeeb84325b652551bac2da53f31a31280b48b8690cd0ad346bd2f2599c45a5b2691d90f45ecdb324dfdac3e62fd5b7ff9b0c809830ab1f07131c1bc66b2db25725e23bf42a3740f3c4b4691099465cba35ddbbde94ad3942f09ee96f74fa6a1db7927529a8fc2abe760a3b3aef95f8351f8a00df7175f24a8c69d40b58170d88262decb36bf2d39626d36875aa8caaf77b5fd771728bef4f49564d58bbc0902f85931141759a0b6e5ca28658e235a5e7492e86accaebe940659bf11a0e83d248f852d54c2154fce4f6cb92e884aa93a89633ef0770dc26a240be9857a29338751355b3c829597f902096bcacf2921ae99ba45413db5b3c423579f8cc2b8b6ba63857adf1cf67b698817440d79171582c82119807c9565b22fc726e55c972071940fdd3cc2fa4257fb75262e5def4781912a1f5783253df9bdeb60e920a87ab50d8b93390f67cd93e718f567a1b40fe44d8215e1e55104cc94eda9572f0b47137b5982b2c070ad94fafa7b0b46917d7e23c3c9c835d14c52a60c226af81700a5029a69c4c93e87be41c5e8ae7d8bf98fc53b04dbbdc1243bd751f5822d8ff1f324e0703e7ea71dae1422334074274b5f5788fc29e7d8d4a783324be448c5378d73dfd66dee3a106cdbdb36534ad07ec5320a50d7a0dee5cc1d23331f6c9e40745b82343ccf97c9ee633d296d1c6b9619094904c8af8a9e64068eef3c60e4b3f54c053fea5f7e6094508cb5a5bf027f3d6e23c3e8a638e19eff0a6c884af053baa00d37532b9803d993027f92a1609b86797761881f468981deb07aba7666b0077c7fe401699e4ce5ab3c84ff451cfb02c017deca7fb73257b41ecbbb379853baa890589fe50a7d3bd7eca390cf89b5cf64f4061873e20860fbacd41bf3c90ac7edeb63551ab0897b83ff9970e4600267ac97242605d7ce1ed1d1d5d97ca23339535dce10840809fc249dc810cdb9b8af9b76d174141632e4e810c481748d27609684341b5e68f76710f41ddc62d8a40d5d049dfcf83f0c014ecd681f038cd05c758a99503ad6e0c5a515e77cc8acb30255e804bfcc00ba50cf15cf5d6dabf8333775ca983a74a44493b676c24f7015b8461bd5fdbb67b9cd1340658f87db076d99cdd3094ef62052ece0a16582ff7d8accc399eecb0c63186561b9526e84e18be388df08ca8cb077cb14c43d422175c137598bb8c259b68c7f7b9d15641915f7be65662765fe22d84b04d7f4322abeee0ee7a6e275eca1ffad6948ccb2399fd8be56924d1dddb6e4d7776f1628f0841add9126293c6720263c90cf98853cdaed99564b91dcc6303cf9fe8c2a8cb517f2c7ab04d00a861513082a14221ea7c9a9e8283ce2cc679f20d54f8918103d54349792a33b2be51a21d80465203a2c3a94f59b9e771586532633cbef242da7fe841eab8e96fb399c07cca5aca306edb23bda959b7dec5bf096ab5ac8fd00f620f47e8b0439aded623d9f5f1f0167b4112e2dd965fdcf306186a1961db25b11552f92aaafff54532b931e4490a1eefb2fd363a1750d8430f020a31c60c95799481bc0f9070963de38f6ef325fa25b76a52604598fdbc914ca1ee343b23c333fd28d8f8bdb43765649708e266514c089b471eabd9e21f72153eace5e1ff09112137c323a0791d640b0fcb9678bb5c740021316f96f06401bf3c47be5327ec1b1776269d0154a6156bae278531aaa7cf0f92bc4363046c4425d61feb4fc281a8cc445e011c23434a7347f4510f49dd7413271bf8ca94474d25154daced5e1cc4ee2f711cee53f56f9720347f3bcb81fc256b6285891195bd606d2ffcc1e37dc84c19660b3cad4c10eadb9a4175e4ba220f20344017515536f298440fecbe41273bd2cbe73031e0c2837503a8c54c0d611d0a9313fbfa4c3381ad1bc3ec08821b6b9631fd033c4306a25bdaffc3e17377334b39a28aab36b4695147e6950e69c8012500b6a78626ccd00d8f59943a12a7864613befad37ba5f5f4b9e60c425d2479594379402f5314b823531fef5e1523c43cd44d0812bb6b0838501ae98c05f9a0092ea58a8353a790eb7b5beb17d952935109b264e783afcb29423eb70be68d65d5312840e9d9945b427f57d0eeddf0bf849ce8369c25738c5db32259e35baaa9f17f7f7a3075b7088b217b7f5fe0255a26ccc98c9267f4a84e00d7de169c8f71c4dd04dc4420500ccc4aa541d0ac551c0cc99a1d783f2223307a7ed062375b57d98790765debd7e5aab5c5b1508df28ed71a4e4ca99ec935458cb2b756458b602279cec62dea5c4a766ba7ab74c719cd51b6f4ee2b22939c7448501ca92d593e1abcc734d16bd0cb7a26166bdcfef5b80c047feaf4fdf3766369d3e550e4004935f02a6a43b0c33f5c60f63ff478e6eee19ec2c438229045e1484f044ff930b1bdc1295166a0d125526c5cf9ed8e84b1f473131df733afc0b263437075df5dfe54793521c366a5fdbc2ba140a3c78687fb9d9ee1b13a67a6cf08c3347b2d3bcdc96f041e61f531c1b2b595bad51f1bf30d3efeb943d9ad2315848e471def3e94f2d87492bbd53ca61773462c68222818fe16f9c4d4e9fcbe169085f2b640b92fef028c8a00c2beabf5cbf475f5ee587fc1c49b1908e4a30ff25a7459c49ff398c2df38d745a89677601b3049dced8cf0fb160b7257470ac800d45195eb1501c2055b7b7f55964952043ca1440e8c92fc740e20755f05328ffeb7ca9d821f9294631af0926c15b1dace87fcd3e29024b61dee788876c52aa2a8c7765e2b2966c256dc510eb3bc6184e2b6224924d05c3457271a9e859139bf341561e01679e7e1295baf492a9a82258ba4ff1bbba84e36d5be183d5f924ab33119d13154c7d53cc6b9b0a6baad620989727e6189c3f2ce05d57c61ca561d53c216478def5fc1c6a29bce414dac856fb3a362dc6313fa5f0dcf75a717bec2312ef750bbe425c614d5f1a2425f346e712c9cd794df1e0fa6be94e0ca93d5334718d56f5ccfefc11068dd73d1857eeb2eee3a6048bafec96f9f1ed7b425475fd8b7c54594910c5c3ea3b46f83ec9f99cab93d6d9d4ea8abeb62bb91594792dd102357489d7b0b138145f2ba59131c963767ce2a04c9daa64ef29971291ed526e4fb116e461fd736a3ab472ebf8ec95bb986412149aa7f32049574d800509fdd3fb1d2bf07d247852b3b56d8353206559c0519d8b23bbb5ccd3fc5778f78398fe7a3daa2edd1b50e89b534a2c8e0dcaf689a81b24d2e97401c6f77c57b0f69598504bbdb18d1754e0d6b70145ee87c9bb60c5873244befe9f68eeeeabb6f1bbeaec8739f817e72e172a61a418fec54be0d6346ade6550adbc76d87327376ab9f8f342daa777d9232e658fcdc3c6d7d6a1ef06bdca8a015b9ed6604e12d864332102fa9ad47ab8ed6781d8b6468b2dd6234b750da7d7f20e1d2a70d3afc21f5d13c91ec8ce1ff1fbb9c0edcefdcaaa09ee931ed104dd471863de1d95eaed815e1a11695c8a0df4a36b8495bf0db6f8fe32f70d59dc40797523ccc66606f6a03ee3ed64656d1633963e8247c7a55bfeb655ca7c99e6719d39901f71dffc0c91ff9144cfa5bf3402b3f31c78b4806230f1290cb6f732616509d887d73b0a035a6bd955d1e05fc1c52e9d1512ae8442c9184191ecebd7b045dac9fe1af1aef2236d8314a6d45250ae9d60e61edc6f1fd992ba6c5f02a3d0e7c8c16ea5a8f3b0c82e2e71eb48d4a9c2a2806cacdb746eca3411443daff538af276fc5ed34dbbed3e453745018754878a1fb8567249e48c7571ece75719da21a38bb29397d0a5d103370d176fc7957d81943373fc141ea52019582819c8aa2811530b331aae7197d4d1f4a6540eebe195f9ed451476e97be783477ea0d95e92788582b7ae197f8ca8f4a77f0a8119d21a0b8152103577167d2fb94c6dff39a0e1ae4438c78d1ae662ed194746f18d709d310f34d60b8e45865c37269d8797cd8f7b6b2cb58b8cac6af52a681dcc3849651837c5d1ded51c2d86c4a6d904f8d65f0c0944a3ec10fa09c8b72013d925ae1bb0fa648f59805cd263ad70d07f926cbc00649507de5a067a4852f74dd6e1aaa15318571b31718922a3d4b717c3441b9bd60cf439dfb7b5749c6df03ea164bc91bb3e4be0910d87b7345cb5b9262bd722fc33473e4a2c25f6d8216a964ddade2b8c6014d4a752a174cebcb8db0c5413e533ffe4e93b64d03c7df9056f594e062d20285e04a3f3d293b2aa32aa4f81ca53c7a31cf69403e7c5864a0c05760b20415c7c42ac8b42e9bb2ddb25e6033e8a6cc67e54a61f3aa6e65c093fb6daaa62d648bbb155f075e8db23421e28cd817436b210cb39d31ea0d4e5d3c4331f2eb2501c5e2e7fa7c531190f6ca9d4b00af79147bae932df22d97cfa948ce3d38ab0b17efe0454f3b530cbd8bbd59b001e6e3cb7fac6793c53f3353c12507ae1dd315238b1f50779242dd8419fbed0d0f49870332df394e8061888f7bf1f7826a8fbff3aa267b3e4778a114463ca3d47d93fd153a7ff475281818582485694eb80d71b9142c65659fdce972557cd48fa7285df5fe4a5b1f2ce03e0a98617075995b835e87b2489acaff23d087d3ba6861035f1477275bb81f52111f37542d3c92683aceb4460d69981ffecbd0f91f0010be6e9206b05868ee9bfcdfd864d1d0751379536e12e376c5567abd20c861d832e121b6706c931c169d7ae088e9bc0113ff41d9031a8b26b93707ed3fa5230b5ed060eed29a3796d2b9fc881bbf53be0a2d80f6617dba91b70c35e76d3043b6f4605ecf543e803f57505229c37e6410889bbdef4faed633d9f13d79b7c8da5451685489df9066def95d33d142af8f0eeafb9a0e05436317c9cab6e9fedc95ecb29d4961dbd1d5db8e1df0fdfda10c2636373a1d8a4b0fd18472aeeaeb47a2ff70d7798b414c0c85072ceb66c1038b4e94aca2537d80c4626f92bfc29b9a597f803de5d8b06219326b49ff02f89a83cfbbe569a456002b0e07ddf40a22784306e853582636bbebbf6fbbbc0d328e6a64c962d96a6fea173e9a01d2d987a2026fb1e8cddb3fee54bbf7d3bb1fcd59b9f0c7b33ae8fff3dd7a5c2404563eb3b3e71d337e9b27d9618b9f4147d5eb7e9c87e410ccab369bc19429be14708dd494c0356e411c10e44b352777cd596174e166fe422edc85ad67f02a550c8ed242441a73d0c6fcbd7ef22fac28e93d675e277ce1fd61faa42017e957aa5243de0271b3696626ee812d695e7d9279dd7757b713f14e225472246691acec7826d218be9ea477e830a08a586a858f30a3960a475efe59f90b78d0c45e83683fa16ed362dc5631875f234b4d80503f7e5ac4fd7906e76efc03a5fa88262b9fa0d9934fec7506855639577d6f0a0c12ac1a9f6cf8d9d83cbe12c973eedb0d7f328a6cfab12b9e8725871417148ff141b6802071f84335729facfc1f19e7111f26aa9ee527ba809766d343cbfabc8dca31ca53ffbe398268ea6bc2fcf780b75901649ad764d7a062f86bc07419cb297ca7eba7d11546af31edcf924cbc37b09966f580fe5c85bfbcbf14705eccc1183699b6712688d1e69fdd113659de04b7a579cd60756856c36fcf72a2752d7a37d62507de6434a2ad87b0c0a5ad953c991b5817e2eb9ba1933f8a649b150d107a2c1fe5821466f7a40e69e914589dd38f30545d2310631a5b78ac99f058c421244e3c8c18a21ad3c3f3c85c53a2e7ed716922839772d62c3662f287a4fce76ce357a7c776a7b45ed06eaf4bb248d902d93a7532f754af83b67caae48134771a54b4b4d65a4c1f20b041faaddc006b78d74ec5f669ae55b0174c696fa8ba129ed2cce007d2ca9a3a04067e68664f138ab3d14ed810036de0415d0789b8659a0477a9068559ab0ba4a4bc1611d1cda94b00a8e9f8cea08d292464b8fe41df63f553a0b629a93a1f22488c7986dc00670d17e44c54b2a23a9a1e1b087150a5acdbf47935c73c36c9c1d17213e08e0712610966074f37cbb9706df9b6366b202bfee6958f7ded9a04d6752e414704a5c2e241440c5d85bc34c37c35958f33279c41502882583ff0888ca5b214e9f6b998df948a1300c9713967ff673ff7f24e9503a35a9014b15a8da0cc8c0bd3f4b8096c8cafaed6431c137676870c5e5b951c5044af1b7e36e892d9f424788512665dc1a96f559832a4d5e9bcd69a3c877dc3c6f46ddf7a2c77f5f0d9a9783af1f1f3e4daf81e3ad8e7fc386590977259b8222c75abf6bc35f716c75368849d34ac59c05fb34f5d1164118cb523784aab335944f61d19953d8f083cee7442920eb37a821c322722445150b5fcaea0270f2b3f1165d22079e5cc4acfd2ed79aa86d7ff6ff0f476128aff2e38ce5406e3552d34a8363bbe09db34fbb6d6d53e24d05dfe33672101b573341465195bbf88d387e6a9707165b7f2dfb991c7311b45ccae00e2dd2b389890d6e10804b49e5f1a665eec29e995243a77cb755fe1289dc96d2501e13f6757826be9b3150a6c56b3ac3a9465b633689d906909e20b1d3eeb0e8d6e7af6d33e2d6f941579013513200ec0a1cbab22b0733aa283c693414e903f2811dc41100334f44aefcd0bfcd843bf902d45be2f21c800606fdac28a0476d90c700368f57bd04ab7df4ae85e43eb1420d4885b0fb4d4c6c8576539af040d6ab7288a02c8641808e1fd5729ed9df31691693bdfab1e4325cef975dc9c6b22daa9e3e07aa1471794df009c3ea9d7a199bf620148aab4729fe1b18fc5c146433dd9c5ad7b1daeb096223c9abcac1ba1ab229b20d487208f67cdb0dc99619f4b77d2d2a684217ba1e495f4cbf5bda560b48097f93fa7ea74fe31bf4c852feb785c07bab7b50881b274e52741bc025555c7b4672add9b52362f837061de718ccbb444244bf427c9f90d666df6f7fafe80809942031275ebc42cac2a60a4759fcdc1ef8e0096076df61cacab2465434bfdd9d868cda6cfb1c73482621f52cf04bf53924780410ea7d1a488b025ba0c2dbdc000a485b4f2c12c6269f7a6b975836b53b66b4ebd0e9489a88f4abffab6888628e3dfc98224de2d8d0cf733f45db44e23d0237a40394e68fbfff5c3c2dd2dc536bf76017866878a66e40ea32cab47085996c3f1641fa05d3539aeeaf6c915ce23325ec3c7d3a0c13786882323ea97f3bdb38b4722086545f4e11902066c8e7d2d3059e8376f800849f9fafb9b37ed03cd792c5fa937a99c97fa978e8ac7d4e8eeee66dc1a59b801cf14316cf652db59b1afb2e243db7d71ff026bcc158205b57a13de0120b50d127becacc94cb16348587a8b0bec734d25ab1f65a53ce17d833e1465a63631a3db3916d4232a390dc13dfee02ee121a3c010ce3f2b560d3390be7c711cb4efa71719ffe3ef7e6d8a2c1c7a2e9fc7319d59a30154128c3800ee1774e91bd286ce6d01f3067a7fa86867abe08ded22b42b89d36cfd9ed842e02429ecbf95be6b1f43096e9de1a3528785c951f25061f040877048e02d40238e6ac0ddf48edc3b2697271194231895ebcbb9773208ad6f7b0e494a52843f72cdfd7e166b4a69d0ec62f46623b4aab6cec47818a83a8c94b134ad018afcaa93265315a5f0f3ae7d6c9a434f8c6a62c9e920274d3a94422eba7937a50c853af2d52bf4193559b67ff3bd03cf18f6092f6b59de38985923171ce6f8c81432bb24b1c6b788368c92daab3ad493262caa72ecca2b7d45b9053d4559e3210fb1ebad51b8cd27b2f9dc6fe20c8d2e10a83314d0ac08077d93357b5c26796d25b9c6fcf8c798f9400ba995588da14dc1b9575c85c5d9e2126b163ae85282f6ced142058e26a83cfff43bc14b3f8d739793f33a5cfce2e8896d349fd5a1c865281287934f9cfab39762d1687c0b6cd4e5a92095b7b6d2e3ce1492b658782469cd9e651f9e37cd46be9ef3aaa2a2e6b229c9b02faf0a20a0db3d63015ae8406c9a0300de845aea2ea62935c268c871d4c6c33872dd0eb9a312fafbdc2f471f2a4a4704d8852f5c8db3b3110252be051c34639d4c904348051c53dec2bbd2820b1ed51f9e0d3a316d66329e9c6ee17f57f15679ad758e3149cd51acd66f60b05e288cd4da2622c0e1868aa0c322e80f20d29ba18fd92ae167e260bedabb3deb3c16f724c4dc4fee3ec7cc8ace33ae76d97769e5bb9b9c19b7a45573c1adb256310ed5e1e8d4679c90d5bab18d6c9470a79ab628a476db7b0aafbf3ca659ac9931e01f3192931aae6bc19dca7e384765592c4d4762ab86ecb974b4247cf998926263746229ea12f7cf3c34a89cc9824fec7ae5435a6e2ec9554178c93640c73938b9ccdf2a76fef9746bfb92b59525f31d80b4d078f116ba73f77c70eb197ffad8f4bac3b82a4fb6c64ec0033acd77cc5a6786202e7da41366a228eb98c7e4cb3321ef84003ef49b0ba75e6fdff63a12da112093ae8455d9d1e28173ff0935f29c7f94fd32192ac4c0cee3d8c5ede9fa211df5a8b0f547da0bece239178ea954d560ad6a8e4722df748c1d9705c0a40b99f217ba8e0e097632e2abcaa426472f958d2cc72ec2bb839f2109fa8b32e1c3b3f5897851055b5c422ec53087b40a300fe4a11dd2859a33d4d4b0c11a492c4625c6922205daeb427f0ce6ce763d79296ae20054f6f3fbd8e0bfea75d65bd86c260cc9ec7a41ad6ec0f91656cc18131d5f5afc1c61dda51f6a55dac04eff54b82afea0775833297508f2f1dafff3fa700f640f8243f55d5f55eaec55bf917b4ebec60cb7ec71330e3bf6c210444994891a810e00c46254d14ebb73f12d6fe081eb7173f6af389cef37b8b09f46e598b6b4fb066c921d433aeda2639691596ff11c94cee4eed071c6a61cbea25d339976838aa996eddb472893acef8d4ab0ffc54910fe0cb0267e4bf100ed67c81e07c5381bec56d296d8038aaf7d9197f21039f0744f14d731cdaaf9b5d4bf0cafd252f6710eaea8b454ef3a20087b9ff287cf70edabba79c0761220d238b21588ce7152f059eb0393015ea72daba8123195a8c4df39881df3f8ddf00024385e52cccd0ba04fc0b442f612d80e32ec26f5d738a13769bfb11d8afda8d60a3de8e68d039f56c81b9c3d2ade0ab6f976ae8e59c9a9693235c1a5b0772ef961e387e21933e1198b355b955a5971e97d9dd94bad514956a553d2e4a4f5c92bc1d392256e3f654ab9482cf6adefe3c3d60caa5426e702ba5ece20d450004c41d214d46dbfe309efb5cab2bf1cabcc8dcba6dc69d27546a0527303b475be51966ea9d21c430999f65bbf77ecdc65c128041f7662597175c4ba84937d7534a5da74a7708141c36bb3b33587b2ab3055ea83c8d5adf24c53daa73590bf2858d95dc1c6fc57bb55854b6c8d8c7ec7ef6797d1f568c6d20bc01c49b908b7e749c4c69b35547d51138d5abd4bdb475893aca8f3255991858900afd4831f3d9c154b3498457ab3b61a5d817b3fec433b88802b6695494e4048c3abd8b868b91a652573ce749252673ce1736437ecdd02674b7fd6eb813439d07a2ce16fde1cd8bd9060567e68824784dc386b61a8d44075c175d57bdae2990fd65c26d15f2c0defac4ffd42fe6437673735bbe75348d9c6677c31e0d6fed8834c069d7a31c3e790707f5594ca97aab26a8d8d2a38beb698b8646434b158f49228c1d1c122a9d13430e38c0adac8f2cff1c995f2988c1340758f65e7a326dfa1f9adf4fb436ee47c5dc604c4a211a0a9192ff5a584839fc94cc67431a5a0f8c9c130fb5f058cb444812f1185aed5d75707e9e82da55fd560f0be6146e1b22e6109e1c03ebe8f29c8e3509ee7230b998bc7320475485a3c109b975b45d116976c0c773775cef3cd4c8e4296769440511e4b380acb478424270f2ef4544afe22d1bbc73424caf61594c807da87809cf405409110a7c355205be527cca0d3c4257b219ad5aa6fc821de2446a8144f3e6721f114a503aa568b30ad8cc4aaf2220be7dbe3b3ed7112bdc43ac18f40d1c45fa868d8338d8b4b4103a4c70961376488f272a007c6275bee2737ee46d58a12f3f7f7b5c3455398ae1aef8837e69af85726e57358c385fc6a9770882bb3e32fd4bfe1de1d9eb4d14f84140d0c5d1ed1e89345b4d91319db1f31f92597e26db04704abd6e0bd0ae9d3b7b9784bf823de44fa8643fa9f2a72cb2ae075d9788447bb1128e394419b1c3feac24baadd553a76544098d303770399c19316f4fbd9a71b4aa40085de59707fafcff922c217d8862e5e6cae160caa686e6451b53f88cfa2de22c40d9a625aafccf83ca191275972526ef1586b0e45fcad6db0de03360626c45531f171bc173b681c2089b95c6185936adface863c28a44c1225fd2522c657bdc142762797e478d13643e6a0b81936da5290cd6b84cdf1b64a1ce023756fe010414ad71f35011607c7139ac215b2c246adf3867bfac9add5207aedfbe543d1c05e10b4b6f239c5ce7c31526d456114d3736de7fbc36669fccc45f89e51b815ea90830d2ef57adc804467c7f2ca1c78eba92eb9b2841139914e774248cea5cfe7db90a900ef0299c6ec84650c9e51ef430cc9e7a42eac1e0cd56b3687ddb22c67e6c596676c1b69a6f95e5466711f293f284a3cca8141c1665e3d2dc2fd6de98ff682bf72f3497a0d54f7475556d9250c5e08da01eb5ae829ef151b316e53f70fac3b3a52a9455ec1d18aa86545ec0ba5dc5b0fa03ec8f4b6ae208994a2971b31a1cd1b2ca0d13ec33e676c5a6fe5b62f0f28638b4de1368be9d562f23a28b97a725f15a8a02e998ffccf66ee6af3d181e379ba7f71af42462b3387b76d99060aa8c1f1ba0bfef53f6722b6dc66886be3d2fcb4d2525929f146b6be4b393362b7c469adf27e23974e2af41581197076e50061105c88be4bc12312d2b030f523fb84b7ac371fde5f4fc398081a0dbcdc7865f5bc7189e0c9c3317cf93ada8a88c73924bd2f968eee984ddd2690e65704dcd08ff075d6446a243a0d3be6147c4b92466d60c7f5393abfe61ee5e9873d1f13e3daf297c246514a3e3e8a4c52215937733f169cf22e289f21231d536f282a3f3018b9a76022c58c2d917c7a08ffa841664f1cd3974e066da031b04812fd01d96a01e2d38347d28a2b18684db88da9634b6594a0405bf0193978f08963acd48a4bf80be32c2b7612590d739c3b9bacc8a05adef8f6b107a1495ea7b3ba89f176fc08ac0391e6b9a1d2a81fabb6285bb742f5d797939cdc0c71f5a10ff08f51076700031c91f72594c758c7ed967797905c73d1c7a155754b74ef65a51fb5dc80ee2a86fa14f9102fa5b4c6054fd875a0597de795820573c16ac927711575f21406da9d4f07a8a9c28c64710a0e58d009c08d100a400c90ae277ca9b57b2ee5d580dd9e71eac2dcb32888d454abf3158b18998bb8ac9ca7f0f1aaa513f6c58d3b1c2ed1a15d8315b76ffb7f815cea79bff687cea9c4ac59f2f6532fc950ba555ec541778f1a841a5565d9cfa5f1b9cd8008d54ed44e880f119821f074dbc2e6de21dfd120bb05b65d215c2db2bb2eb7807d206080ebcb2d5ed2e3f6271e3536e17f1c2c2ae6e7a9dc8fe442f6720712e1fa063784289403042738e5479e3387018e0fd9751a2d95e77ec750670e636f0bdce12ea812b22c9f61b49384066dee6b1d4488ec193f0ff66b518684df34df5093f2ed37b506279ec5834bff816749d6b10d4641c2de917cf01f0d94419b321d6697ebfe1366b8c95255484c18d270954af00c91997014d339aa8814589f3b1828a667aed7c54ada830054835a52c04f5d4d32ea8a6dccb0662e860d2813741907b654fb1dc45523f0e5086750e98a00fc799b4ee7c81c3e955eea3bb6fad33c7473e6c56080e953bca7280f24fd027d4559a9494552b96f553d2577dedcd8504d5c131968aa021394ba79a030777bec4f8e0d9f90ad8406c7db2f65010dd4cfa5b0d28d27ca7587300a7debb0d17468d3a219758ff01b8d51bdd83f4e7e1f27647b199eed4c7c3d8998b9d6227a886a42ac6c04d3a3f9593e662e4761d9caf2d0ea17a37ac8b57dac351b2d57e0c01ceb611fa1e88244aea5b7ea47b037931f0103834a14c67dfcac31ab01dd1325dceab39a81334101349ab380cc9f13d570e37811f1a765700b7f1977558e7c785159c06832d2224433b1ef1828269f0d66681eb0e58b2ebe95b22d72365fe091fa466fde3ad18fc195938aa0a8e3e6a5a7cf6bc1b5bbe18da8cb1dfcd1561dbd908dfb5283b47b165e2d264390b298b50f5627baa3bae171d6b13d5edb58b1f5afa1398adcd67ca96dbef1ad153cd3146138e916da5b6190a17bb8db80ee4413191e12ddb18d663e9e8ab6f2f4b1cdac76b4264c5f34720c736e331226db5c593b0d26cc2227d4a866bdb30e1dbb64beb9df2168f37f320707d49fb3e3997306f19c9b1c01f90b380754b0bb121b3517af0b5795874e835812ee49c97358b08e6364c3f28cd749f374fe8f610b5ec1c865ac93c57fc9973e1195b8323173d23ab777612eac272baf589c9f7ebefa5b3e727f717edb23faba124df30ffcbae641b8dd25e767ff00705cd2ff6c67e3641cc2ec348ebfaf187b26563513294fac24bc2377b6b1285aecd236425e2c8736bb661bb0c0e980004298119370963b6c109ec5017626bae7b16e18bc563868c2a689621296b6837248ba90fca1cb0a71a6d102a50d8a86367c30c5ca7ff0cd81c956935bf9ca530b5c55dfa0e7e42ab05fcc0f2222dc9101f6edbe0d43b2793587523c9496de4283f5cdb5114494e499ac11cc0c7947e0bef31ea74e52a6507a4beba17a58fa4afc495f3266742fb3282e35c2a37d0c26dc5478bc6aff06a6728f0d9f44d70f447b42e4305012600666842bb234d7b156febaaaabb7fc93764d39932bcf732afe8fcc836e3563ad4f539c884c31fa9a8412d2a81a4afdfdbff3aff9074d6df311fb8bd829946f12885d27b98031e620602ccdd2244a343d2eb8a5af7cd41d388608a51e8a2c9d3b6abc338e4432fcf2aaf35ad082e825e4bd183a534f1d88e5ce6bb0d9cf14d26b48417cd86b087dca231fcc3a19fe2c8d45ff846766586e6b68192946d8cd23b409994e1cf0a78d5a699ac21bd56c26a7412301d0da9b41d20ce625d77b83892b64229d0f0328db217d2b08a7e02f16630ca1a7537923b11665c246705c1380d34831bacb6a36cb049884158f75f316733733521699d21911a74b24de40cf97bad77a7b781d455111264b8eb62992e5554ada10b0e98e6ffc4a10dccc6fbf47445546f4f3fd7f30f2bdd6ca76316c2147719087fc01a422d002d2ca38e3aa5a9a85fd29b62aeb5d446d9c7cf5a524f6c0fb9650272c9e049321838841490f596ad24274df40abbc95a582716e0035afd1120919b13722321e8efae933670cc74614a0e15c0156b5a1941b5f89ad0e2d46b9bae6ee4a27514d3acbcc3c2947be36922f58f4abf8d2752364c6a8883e59540864e5781df563a30d4c91c259ea698b25f98dbcc5776047f83888146c8105fdf0f7a626d0d81a4f4dd07491f83ab7ab2f1df827a9fc3a2521724d1eb60ede8151c606f06ac1c586f8a97f12d662c8afa998af2d0f072de139c77b24ff235f98f24b09402fa8e1fdd673b03f67aa6617cfcb77100a9f153c303d8d4e9a016a0b071f19fac0af1cc24170b0ff919c3df69d16004230d8684b4961537bbae2467d02be4489cc83ae7e23cc8d1a73c45c947851eb857c73965aa6039dfa53ca3750645538086fc903194d6b405322c80816fc759cdb22ed7bf30cb0d5c86f0ba0c2d6531d82f25d348093b621d81e59cba9135b18d1ff9883d29428fd3e45a0d59cc29da051b632d1ed22708e46becd55decb63296bcd82fa995259862ead2413d316dd54308999d1ef36189fe090ba76914f4958c8e721275ec07b2c36971b2947e642be9c1d0e14daf203601804ad7d8c3423dc64d2fc69cd43e9aa70241f2785a874718a4b18df9338dd02e9359f6a62766cdb845e779da8779b397ff7bf0ff3924a3546d559103b00d518a06d638ddf333969f70b420647c73ddd6bc639481681293eb70c371750f07178fa1c7bae5b5756e69a9dae20192b01a1a6e2ec966a85818eaee4c2b2d23401f5659fa3fd79118f51cb2eeb9a48f69813409be864bf9f02d03cdf58b0026b84d37661c64d667b9600bd370d4166cd0dbf12156cb1ff3698a7ce266393b333270e9403b1822ae9dc66854b2ea831293082742431786c48f441234cc6247b298a4ab7d8307adc1dc229f5effc8a8884645773065243e8dae50c823e81fd8b621b8e32281e733661b576797e4d19c74ba5bf4d80d0ca0de207b4623bf6657b5b714a55fea7a6f10279bf8817fc6818038f7b0c82f6ece28e368e0f6b96156dba8acc7e75b22024b7deadbce580d87d3b759b666da416b8cc6e88ad9358dfa06e60cd0a6a6d6738c7271e2b73218c0c80198dc1491c8b7fc165117bfc16bb5a3028a19c624383383559fa1e9d5fdbe3b73b12320d0e5a2ba67040c086432a174ac1af2e5bab80b458669ca400a70b52da8a6ac9f6aa1650a53ba7b1ff4a1d35b91a2a95320b6365dae19d0c115bc27a065c38bc9364d22d915eab99d20e54e3ed462ca31dbe5641b03871bc96d6a22d2b93171c4e4bc593c38824489d823052940ceee609f52dffe8ced52df4ec037bdd8dbbe7c0151a7ff8685376c4a0e5dc4524579cc619944168df4536e3651000bb4b8a369c034880d4690275fe2fffe28126b0ba4fb001dd80cbe83f51a6d990fcebd563a13ed564a61f65e95f36bbb6ac8ac29de794c7531b2723928e09ed0ce7382af777aaacab39ebc7b0b12a0c664eb2c83f6a5ca292ece2b9e324e9b8327d3adcd4d91dd33b3341b27d054e3aa5f9c92dbe33f687e939d0cbcc0a803ba396b5729839b73e310bd6dac6f97a9070850df47641b5d3e3acdcb3157fda5c4c513e13561416e4b87908391c0ec9abebc44738f11a9487d87104cfef081db4033908872f5c4c03ba94bb01505d1ef2622c00f7469d51ca815e292d433b9f5f0c97fd212f6da75801938dac705ea843bfad82fc0bf2470edad85afe6962a54d79b05d2d61336b82e8f4a21157712b54754a32ad53487fde44f670566082ac6ba34ba8177fea15eb05c595294ec92af7eacc883688588a492b76288a5783e7a780a0fa0d3e1d21b952d343401fb61a2c1c0b7257b95c550950c75323f2bf30836312fb9d3b24e428b4e85171733845aff3650013ee43aecbf25061d2fad31bdaa6e4dd2640b05646247ba02743fca87f36af4fa5a6b5b325ed7bb0ad4769442ccf2cd8e77d4d524ce620c78d62c3c6464164575e2741aa3f6a62fa745c804446bf5494e9d6677368a6f3a45119dffe7603761f61646184e3845f9cb1742caeb9a7dc978c1ae639795c59069ad617da584933a9b89396444ff3a0cf6d1c1a2cd2817808f95ae5dc77c6aa804a23562f407865c265419de432873fd60059feae667ec212d89e30464f92a072f2d06ae4abab032909ed7a0db926256916c56853031caa7a900595cd3c8978f1985f1f794a30a741bbd44255095828ccbf774a2b592259ba247423328c9419d2eebbea74b67d932afec9aa19b5e4f61ba21d7c65b3df9ec32f0b770f65d1d1832cbfb52005ec21b267508d6677f34381158195e01f3fa7b860b0f17394f4808c78e7bbc6b113892dc072c1e30f53804b647973efc7fe130ca693e681f1531883fa1940119b6ea265fb00a3363baf9a9db9395af304719b0583e03f5622567e8f9fb67904ba78516e00d5e06640020d5effa1e817564a47015fe56ed5f2f7e2ee2e770a797b6b1380aa0e863842320458dbdd193a7e7f602ec9796a23c845a5d9442c5909f1afee686e759de5f14570a0730cf59461afa7517ab6b8e8a18f52b3e79f2d634ec50799d3d8c88901ca81fe406022c07223a6f6e90db10536f0860d9ea8c04d73b9e08548adebb983250c8e43062a7ea2d47334cf8c4099dde8e306e01d097ba4d38521abe2c9e6cf4fa18fc3a4678e03d4f3811d74636e81062ce61773f7ab6c5a9bf622a08e17bdbb4dc757b1803fc46553f37486d6ad78643088e118a2f366a611c365076e1e76491459a1c96a916249a681cd5d173f7fd5fcab55121d98fc6f2e90eafdbf06df4a70193bf208559d45f783b062076478201c3366c3997fbaef27646cc149c84d3d3e7b3d08fb6126e1193e07c18d70a5fab4d4a18734e39cfbca4dd0d07cf52108feb9c60758e593a9ea602597985bfd73ae4ef607ca0b7cb601cdb9d1de3d55ef10d78b0d2648140d66199067d880b7a232784134814eff44fb60fc5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
