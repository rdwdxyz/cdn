<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d9ed6a1ba78768d1eedecec19c2272a0519d33896b32e2c5785f2ed29fdba2a5c7436d917f617630b8eb107616622d76ae7bb1294525966dab0eb426374c502c3f103d657deff341cda235559a3540c35f880bd8b934c2f307ef0681a71066fe609f43e3e26d2cda9de68af7a08a130e8a743626b0d7a932e4034271c8259aac1f00c8a4261d5a0291a42e7baf4cfeb8c9b720250d4db32c0e7398d4e92fcaf05bed6562279aed63b817ff55c7d3114d04a761e74d252914b205b48ae87fac7207dbbab49e3b7ec34fd4eca94685221fff0617552ba3234276fd50178b9a22fdb9703ce4c37fb48168373c8caac614ae2994cb094e2c4e6345bde6b12dd372d4a9d82af829a017fc2258b1b91811543960d61975f41e4f115f5cebaa06052dfb3b5a448d83618fc43108466b68b6ce7c47cece2a564220c8b62aad0338e156d87a28fcc064ac3250d39e862c2e912de5a02b8a4d0a8c68bce7f99f3cc0f796d8b9542292f75c83602091a2165bdec889fe4e1fc0c76660098d7f30f48328102394fe04f025b6760b38971cc4538447f15d282c19a1b4027ace7aa1e1c7af633df10c08d305ce9624782fe4a3ab6ecd470ca4f8eac5daffee0d8ff6230e257a6bbcc1831b9bfdc4368c37466f4bb6f7ae069987e8d0125ce3d7b91b99aafd153206a29033458768dbb291df851e5cc73b03667dc35cfa52098cabf7dcb07b8b036fccbf79fa5e9164172b99f0d92c034ee67bc14756dafdd1bb7e9f050d95adc9cf3ee600802d3f1e44bff6cc96a9dea0268520885612c81ba7a315d33e31c06ebd41d311fa02d4a2274fc65143d57fdcdb99e2de8a983e8b16232cef4a5e9ddf39095c7bd5351873802cab1a07bdc1a5b691a1236ff45dcc968fe1bb29b2c7a0e65a676c0b0e12706f3a6ec711263aa49d71d17485de15abe95c82e0df5a7992ad5a8bae6fbe8bbb11f8522d7d56da281a3aba3d1b2b19dd669fc7c37263b31c4411da2d395e14257a794a20118354a9e8ea60ad065d72a25f3417280518bb0ce3e3b7d4a30e2631dda2a47e824e0aa88272b644d3a90c673bbff14da8676029b7fbddb1bfbf5afcbe14f529b24f0c2235d14389836f9bddf1609cc6c865dc4fb2d85d4d50ec279b342680ebb07c89dcee65a5f4c36170c9a3ee1a25deb7cac0e7a21adf6755471a9a08795792ddfed0d88375df7cbf034796eac3c1d03eafd7eb228f58b09a11f6e1f7f7ce1b289ff27d82ae538a59dffb4871187c722e3552d77b5a8c9e3675a805374b26d82ab1e81cda65c6bb3b9313127ff6479f884c34ab9832988d607aad4b08e97bc2ed33f6fed8603f45215c3d9018b4c0674e103f48bd24b096a94850a49604771d7a04d7063e4657d4d355c270823676ca2bf579930b388e5d01412229b53fc871044d5f71f3909e5e5f248d8dda40e2d8b7ec6c5e9fe141aac4fab8009fc3a404172a8c96c69d7d6f710d08657948a5ce8836010cd598d32465966d3944146dc7c119d2a03dcecb7588295d65a4a18d7cbbe3fa7f639135b2d5a05f70393647468e83e3fda7fe58d5864fd78fc5cd9645b819abe615bd2cbc473079331dc70539d1ca2dd556992ff4cc31a5d049d1868ba73ec04e254e0275ce5df8059fc3860b3ab47076862fd1ce277c91089d4f7e114e798e9b7480bbe40dd91bc335e7c5de4f48d5ab4c3e5ebdc52c0066d8fe9f572b5ee631b09a2ce177c9770e51ac2dbe2d42d55946ae18cac8686fc4bb1fb6f25858b45c356e257a1f5ad2192565a238a4ac9ad19613e4064da08cfeb7a145580a80ed8ef76056f10f35e303ed14ccd79033ad4df9efe9384d06fe2724c4b5a1f731aa8de73316225ba136b8fae57be8199ee130f4b74f0c81d131102a678ed3ce305a1877898f5d5abdd66f0abfe6f754d68450d28e32235a930de99eba43668a4158fb7acb0c1ec29c654d1533d2c15fc3f97eaa02fcef2ddfd73477fb43f41edce1eec1a2b05f46d79877dc40a1dec4acccf70fd35f7b2c4962b7675bf1bec9246efc92c450c083f691634e601ad092bb5c8272bb17ad03c22ac537eb781bc8431cde978a99e4cc57126b412550b3e89882a968c57a30feb168f735a3fa1f53215d5b475fe6eea46a5eacf11a76745b5ece80e02dc92a900946296a1c629f991b9a3076e245a2c7fab66acd28dc97b98aa71fefba239ee8d22151406730f235228535197fd44bde8fafc093a4777bc88f77d43da0765bc00717bb1cd52af0cd19ad44ff3af860548dec062fd2c6816ac42f342d1a6e96648814ef7e997a841c7cabd79992a237900e32b33598dcdd1e63c8eb0489e8b2d8cbf0d1b0a48228529b0624181f6d5f8d897a42ee9505829be184e07ea26ff3c4da39ebd0e259811d87493aaf68038cf43e5d64c845cb75d8f282a261449d6466fd059a888baa2c7366a7e505ccb99c415170ccba56d7e6a31d802f6a703ae14a46ce2c33344e7e6dea77b911b0db090fff6586c33a0b02aa45db02b2774db93f2d80942502352c75f8da0d363b1b25b0a016d9154ef3c331fd725aca99aa13455343fe0f3a650e53a12dee80ccdd80509800ce29ba85771764ac0cd790d4898134527b7b376cd00c4ffc37456e88854c6473f9e5bf2b49493b7bc8a11c5f3793691ace802cb0fd064d52bcec7391b647dba65b796b7d84379d85e20dbbd4b57a3cea221e4677be64bdffae3b509925c339f8b06c0403b636e0b0c4edf99b3a6dc32e069ab9774d110c48cdd31c746f3921eea62d6ab10a6a4370f880e47992d4bb31132499c9e39c0abebd82581b60aed07d5a7ec6b7e4fe2ce6e3bc3b30ef4d901ee62f7cd36f95a7e42abe8255d96bea2c4aff9138f15f0afc35b8fcc5c5538a25c807ad655eaf3173b0077ad01eea5a696b250e9a85a595c6eb687d32231f561eba0b22b58c77f6cd3278c5ba74fd70e714ba6a4f8b8de0301d9cc5e8547d453add4dfc34b65d14ad5d5b8e4002c4a5b8e41dd2ada27d1b36357c2fc08dae433d3d8c7072b05145ee9ace6aebbf9aa1ca131fd7f7965f4acbbedd3ed889ad4f0b46fbb0776b08b99d14c066fcbe245529aa565a67a25acf37b981fae36817d1a96fbc4b8c5007d67260a8c3b563b5b1d8b8b4aad1e155262356ce23a144a00665041a4196713642a85ce4b49c978cb485e047455d5b6d77b668708ac23541fa5c4e9db28c140e113e7a75059035d5e99fa6f42946f7a4b6f3e82147b3051ce0d86b5b2a290cbb23472b617b90f58c6c31783445834aa54b2cb40978bb89e615ee36a2cca16522c99202ecfceeb26b042097c2ecf76d842a19178f909a3f792cf8561b74c22b01824bd4ad2b421fea62ed66bc0610987d34379876a802172a8d1397c4436c2c4398a9827b61436e3452e31c84a91cba4cfd98f189bf70132bcd509b5481241bfaa4834bbc9b5d61e256caec2f9d4379436d4c3b57942a3c6f14836803b2eb1e0c1628a918bbdf4597bef699c2bbd8c593c9faffaefcc813fbc8fc8fe941ec0e4e8ec8547f2d5702e86f0ae063db055dd7eb03c6c22f891c38ee6079c43833d32aee429bd4d2025210112a16c855349870202804d74b6e811e6240b1e28c8acb4575baffad0426014019770a4dcc8fe50d5bada32dc66b19379d1ff8e0f9f1da3902d572693945e09b90d2393ea66dbf618aee7d367d9e41fdd787e33d2181ddc44230cd48e3a32a1991211957579c27ede3d7dc1089679de53562245feda6a8df1b896f6e33a16e2e88283cbbe71035f3954e8a894ce416257bf056322fe551194ca42a9811b2e2c8dff64edf8ed1802c59f83389f43a382baf2b2598dc922ce291ae312236071d1c24998d978bc5b33a4365f62264434ff721cd301e8eba5acba8d11f0475c7233463559f1798e7637b23d4b3e51a658391f2e5930ef2f0e7d7987545b76319f5b9192b5ece46a0c7058557b907059b9fed32f978af27e7ef75a24e5586c2bb083b590c904aadb1a07e07214e0fc2f24de6242033312d94767c2475851acac771dcc1be03499c6da37d5c73397f45ff2ca92e432d792eb1168f7846c68cc76a8099aebf066cda8c1943a8959d2466b354744200afaa2171c33cf8ccf43f83b57300ddc6d39b3d4b52ebacc69e8c918736b4244bea3c08f7b2af857eb1781bfa354d0d9e1c685192c1d5f11dd144913598b97154161155b770374b9402f470e7b9ba3888091c89ecb7952c4261f71413508a0cbf14c514969085f57c1593fbedb4ff3e82bee244b8d10b98dbb132eeb33dffc0d965edcb84bf353ef9271b35fa34d7afa444b8c413811bdc69571ca6374189a2066adfb3ca7957b91e074f48cbe55013db538efdbea672ff90138b6e74297107c4fb56347d245883cfc307e1d80cd2f0335a60f5aba342a8b8561c1134e5987d9728fba8558f5fd12eae941480e3c4131a4cc143004c74c44dcc6db5acf408b3e9c61e49a9c2c83f49eb91ac8ed48fa2dfef2b335c677fdfa655e20b358c9162e3d9912af58a127292def970b2923cb68452d997f246e452dd1a89c0f87a6fd7c215e46b630a98a282210e0ed51d112e5a5353af6ea06ebedae95409565e2cbf9af1ace22da59d65cbd0bbc0e762f275a9578748cf6d697c3769bac6188606525284f3aba9df7bc498c73557b551f4864c9805c1455f4c7526df6d6e82f0ee0a32b335f90100103fd82f22096df55aa609cb932dd2ba953f775ca6309564f8b5a2f58580c20d3f31c741a8281f2bed2cf68efd6b9a906569e584b87a3b962be7f0c54d1044d5888242d56d3ee2326542895b92f5d39859450de136220485d1bd5c2045776126fc09b4c542df9ea87f75adec788fd91bc838ce164556807d0e69d5a8904913e07c5fc2fe7c182e277697e68706cc87ebc892671dd9d1450148bf3977632b468d91d2df138367464aacafabd6f7b02608c6409faa3341e1cca7f31c8e37f8837c4070a796bbf7ab7749e2ca6a716050f530b50bd6f3b288af4bfed03c7572a271b3c6d9629f7f6fbb840f71d6b305304b780ad0d112e972730058f63d43fbbcf729df541ebb2940bea8e089514af903b55136ca72b617a3818c31bf87323bb32155270a0e6a7262cb82e9b983bde6a88f2677f3e3c4d7d3823a77227e3d6ff6b2f67b03cc2a1663d5f02b80b7a339fbb74f4015b059b6bd0e6b0b1688d54dec222e4b4aeb182ba0b26985b114c7fb52e9b62c8cb3a13530cd6c60ad19cb64b061e1326d7a3331f7f92ea41bf32b1bd5730b36d033a896986e8bf915c1b3a9fbb19ba9ffbed9ca1f4f66d2a448d1e4e6562c9ef7d2937918890a54465734d23eca0c6b76d9c35b804638b635eef1f196c7fe68cb44f4b8b412d7e094a14ce3d47d69fa7b552f4ae065ee532a52ae037cebf1d85250882fcd853370bf205f7c87c7d29c196fcc8178dddf7497804724e0d9638d3bd8b80c8fbfa27bea2c92b70b8e32e4f9a98f47234a227db91dd475071e3b8e9c5a3416c1d7511b35c3d33086c2e707e0d4a62a30cec56f0f8d327b17c1c38f5acaf0a1c3cfdf3c22c20f86cb2a3fd3b81fe7aeb78c896328c4b2f7b43ad4ac042ee6f82259a310a15d9b4255aa99f8278b0cab4d7ed348cbbf60524dd12f07a0b1298d37172e6f5ae8bcc773079e1243c12b8a73447fdf0ff7ac366e939a14429073a446f190c473ab255304c29049549843eaa7a902bc2936b7846da21dad0ad5103a56cc9a11561b0ce080827bc7452e62ce2a3892c1bc2ef7d3de7f4e7cfca71534b055e2f3ecbcb9498a7af7b986e91c837aeea982253bd3a5059f6573a5baaff865d3920ab69b7a1e591719057049e18f4d48d8ee667d91f5263daedd6721c8dd8125153a280859c4a607a08ee1a5151e43d52c69002f939c18b9f91247a7242974bbbe0de280446b7eeb92803fe28a186395a7658034721152a08aadc59367c9b34eefcf6c057c11a8601a7049369bd3d9b2839a15d1562b620ea7dde867d07cb3aacfad948705147c4f88834c1533a4f8e6627535959b445161519ac3865a03f88427bfe03a1f99a989fca14e5af55a0821d1dbf966a99c84f31b2941f02f0b34f0836aec4ab077fe5f5bc88d834aa4f8bf28f2f5d261cf7968322d735f41006bc9b47a7f2451eb56f3731d84dd8bc06b67e4f1a07f82faab976fe2521fccc9d4f7af1a410660b4f9904879ecf7045e1c450cca9a72b19de540a6af3df313e30aec0282e31bde5998ced0cda5675e01bd8d47d36193340b671c9b51ec870826a9b74759b0105209528daf56c3cf18b6ce70932a092f2c1c3872d024268a96af73e72df5186fc02f1e7f5aa4e96d9c4331fd594f67aa323d8a795d17107374a07dc0320b801c51d0d55b2af2d6e49fbfe227a65bc9a6b4cf77811ff0565936263e719e71f0e06712de8756cc37aacf50f034f0238257a78dae87d880a0c8a6d54d5eaa39ddb4b073acc5d0322b8880185f9a44594ba94f2a98ca49180fbd0a4de921e2cf032f5f4062d4a1d2692c3098299293336b5e1862c2896333dd81699f0a5e674cce1720f394beebc3fa213e3705e5a136567d227650cd7e476fea78e3a038a32cadd0e6138eb81ef4835648d0f9240dbc68763380338b99cd45f7429413d6ca9bf80516fb7b812a516484acc165e6b1c4b03c1e29f4f6dfa4e0cf1224abab7599b4cfa36035b705793bb9eb187da33e46dfa678e9a770a77ad4ee62c25fa107e3dcf7ed3db6c3b6b5de796512187686d1bcecf000008a055495c3f320775fff16e500563bd9af9a269512b161d5d8236b904bb1bef6dd058e7a5a6d6f3cf323e14fae9f75b3b49c013b802c6dad7640d9a8983fb3a89bd16e7c1d00277e9ec19fc38fb194097ca14609335659ebed3ce8fd59bd3a41213c2b3e0b2c64779411cff192e3696f99bdd139fb9b2f5dea0a034f9ab8694949c3e384bc176b8f85e226d04bf1ba60fa733a328044ded572882de29a3ccee6dac1d849a873978d134650d042f67ce3408f1a016b0816d0cd4038115a7bfdb78200d77c8b2edcd42f6f2a4fd12691d1cfb9d1f8b2c06a6814b0a087f13a2000c52959f6c60934ab1581ea859c081b56893a62d30bec4d39a5cba413010e3c88d13d94cc388eb1f2b2ec97391e6d8a9adff3c841e7ef99a172d5eb2f1790fe5d746857988ca05717a243ce46e9cab82296e3f3bfa1dc4e2071cc902e048730daabbb0bbd65c91998ca999073a4eda5253c589df86dcba19e9cbef53eea0ab77218b186dc225fa334fb78594f85f4bb9cfa1cba169d8e7b299c0049d012ee9e9fcd6cecdf8846cb125165d1871ba28741679724b521d6a8c14cb7788f20a6ad69cacef4398112c773ba8a774cffd2868ec47b07f7a0ffc5d4347d02ec5ca934dc9bee98690a847871dfbe1aa24f5e8cf8548e62e51ddb55731a570b5252a3bbac761719646eaa86ba2570580740bbb0e975c80786744e254e51fd6762041b5d62bcb476bdb868c4786c276a7aba84328d43519db1ab1003beb4d01dd61af0541dee84fc1d83b9ea73f1ecffbdc13881f3605319bcfcec773c5c622abd9b2a4f3d3b0ce2cc985010176f6c9eab5489ad23d878e37090c538657735c21c427fabbe701fa47a5a669f1074d2517113d0e2a5df9f55e3de594338a1cd51034efab1369971acbf19df138d1bffc5bc5762314c9c3fb148ba6c3c2c55a839fc6502959e252a6c57bd2560e3946f4aa9ca4032863e3d955ddea02c59801275497f17cfc53c51f06e9445593e0bbb8c35c761bcee65a35c54b3b3450638a95807bdeb975b84d850638406e13a7810f930d4deda1c5423d7657d61ca12d173baf01ddab5c21b3af164707da79822fe984f55500043b321a1fc0135a1fd17cffcd3a2c94508f4f7326542d0fcb60059caa6ee0fd33dbf050dd9ab21ccf5e48b2e3b4e99caacd6eced3a9f8a3297e051c9078b4805908094d81f0e676792c912ef2fd662d1d0a43996f93bc1e52a4ecc106c943f66f94f3e458e5676115397a1b11dd3110870e2081a0ef5f93bc00075dd659a4f5ecd053ca49735a8d4e98dc64a86713d3643c2446a9af9248cc6fcdc6adab4c2fa0b38ddd0a4dd9ce19c96c39c6963d4b893f575b9eaf0d77d39067b659277a51090c7e5c3fdd668b74e6edeb84aeba844cdbfb0e776402662cec15b27b4b7fed98da0a063d48f72705b6e85c4ce43f402dc406d8abfcf87ea94c0235e45e98da03523fe49f9fe9ef3ed3cc80403de888a4e5b666a8f8879fa3e925f476664ca0071286224d40193f8d320533623a3acd89c04b322ab8603df32dc06d3950da00c02c432b5db8ab962671eefb6ba15ea8e855d9e04707bd979e7b4b77bacffe16a2968db22fbf2002b91e343a9d7e5f002daa3d5e270bbdf471df0fa663a0b1c58a3ef7d8b1da32f1fb30d6b605711531eb3258ca0b0666107862354f30604b7a01dbefc58adda580ef73a80fe75147c91db9a8112ff44010219299e933d6406bc4cf34d29993756edb26ab3a3eed252e1686cefbefe70572c9dcfea1a715ab666618475cbeab6e277983ca6866066fe1f7636a75dee6f134a741b297f0948eaaad59f605f8410c8c8025e069c882bdd14c3faa997246410937fa275ccbe52c3622756682b090899cfe269d60b8ff83397bbca1a0cbe51d209b18c248682cef72e49983c565581d8826b5a3458f0576affd6e5e3912b8741e7cff90ac8990194a2220752f19e01fd0e2aef1b5cecb894fff1e8d04b5ea86fc4005705e2d7759c4a060399749d91d56f5ec59ff49d36392c4686dad91baedc68c88249a427a253577cc83a27c60d8fc584f067e025daee819e981467eb498d8a10b9b899e030910d681aa3030b2e0526e676564a13c8e2dde6e4acd3027749a4c598cc1030a279d6052f664ba8666cbf1333a7af903b03e7b9622c62d514c79c76f7eea545ec3c2e286584bb0d1d88ca98151861beb9b41bce8a55cf0c3ddb330a793690c694a4798a985dfcc79c1ac437819017ba0ae2cb1eb5740202b8e8496a3d3d8e8edbfc876ee00c8be781686cfef04acd66f39b9c34f32386a53cdab6d2bc29786e9f3a7abeff9142169591cfe21015ca18db4f80ce91f91105f90a9d5e4786b5a6c6eb769e08135e4aaf14d6586e36612b7984a8db6b6da7bf3aa625cc0974c90b117880e7d039843901976171b68fe68d8e7c9224260e000a99a3e9bb60c6155f35abb144e710dcc3c779f491176a55d62c6db29606d928f4da555a39c4f17c1feb097709503108a34e79557fe83d58fbf31c249ff06a97f981ea49a48551dc4f4f726e88084e8b1048d9a3309f328d241f910106f63adca822278005f16494a8afa8a0ca672d6e86ec80a7e67a6d122b23712888f31818ee3f593be9269037c8e40609c9fd5f810e22d4a342b25dc06bc7a28fa74f9a25ba3db5f626ac9a4680871677bb29523b4276e994609ef2544831675000289175a03fe87e1553ad54670af336b69e48134f647889af45774b1e9c772e9ddcc4b09d68167081ad473ca96cd30870dc8848e325a1c1fb6e07d2beb663a8e461ab5d8e3f7706040ca89f8d86c5c048733fccfb8e5f03cfc9af9b60935285875c55e1bcd54c0903687601a4b637ca4c053d8f8b96814841aabacdd28365acba5cfdc87449a1e40e225ecb41cd0d5ecfde7f7e3de45de898f5dc5e8a41334bdc59cde7041ee3426e5062a5486deda7c2cfc4059b7235eba7629b0bd9ff5be32ef0876b71d90be1465a56e9b1bb1553c3412297c2ed021baffe6f8ea7475285fa5e0467b5d392688067bc183cbb008eeb32e14088ff3c8fa474a21836c5777b55177e069ce01de259428b21b4e9684dc79679cd9ad5f8e07cb852e1bab52f174cb146a7adb2576074da1e975a9f4f800c315e60f66559b753f90f07f78d862a58f7519506626d13548e072baba9442111ddc7669043a30ff8072c0e1f28e56f9490414573ce07fa262d1db6b77a53f76d7e1735ccfbf6543253522c0e370be4b6ac4cbbb2f3edfe38e853356febe2cbed1e5ec6135bb737294364160913a940cc6986e080fe27d4256f157b4996911cafc438fb09029d8409b0dc5588445554811769c91af61f7625fe16c725a50f7aa5af080e0771288ba6139b94b9d9283f6a6a862d068b2b3588e7fbf823c858e77bd9e10a4bafbeaa0b0ea78402b3dc5b307692c2c02be7378ccaa60a7bd528e391fa4c6fef300364fc81929c50344a62fb46df08f34fe4653d8a8af22d6774e486647ddc0d26afce7422bdc13d7f4296387a294324ef4217e3c254c8bd67076288f75d0888603f8e2c009c556f4ef3779c41ee2324e6723dbf5a0eb5b9e7154316407ac02a29250eb0b5cd65ea87ee5b62749698752d65e9e9223ddc8b288f60ff3499378caded17ec36b18880b2c898aaf5d6fb8880cac6e499e396bbd67c52034d2beacc0381e38e4b16f53b0a7688be214b6f2f595101b95e665406219e45f64c482df3616b833181a0e945078bf37a0accad90e07d0e5b5cd522bdd2cfcc02e145f0dda675690c0ae39c4a8c00baed0e4eb68363a6b6f8aabf0a115828834f04fb8cfc68a48995c5bd1eba9ceac365e4d0729e494becb0b1b0caabafaf01f3338ca6e959144cee0dfdd40774e0c05c4ba44e8cd50ee9a288e73aa6bd4a36919ac9fa448e0a2ef3b755d0d66451a296ffe03eee2800876b45b43722f14ce7698fc74ae40c036a668b6a0dca8b8f6c344c42768c367aa12eade501097d7894c23d98bce66ff7396b051d3202fdd9487139093c99a8180dedd2bd47c4fcf22a7acabd53e6d702dcab8131632c50ed9c9abecac4c2159727ced9ff63ffb73a197e11106d2f6bfc4d9ef064c07c0b3ee6b7b8761c59c16f2ca8b070d69fcff5ef655798b668a0b065922c0f3bb1118c221b054d7cb92af002ce555d2d0efb3816bfdb19c65e8c7c55036ffeb8a1ef05405ddfd9f2ebbabcf7a552a9ead164bc32dc8955333665e68550106a3db7ffac6bdceea3f9dd0983af8f09acaf6e877761b658551fbdbda4f717374d0306c049d5f6295bd1cb545a723641f95ef0dbee96743f5b17441b68d2608cdd0a6468e0b46c4e4f4ab7d946d6ffdf04ae84e670abc75523968b963c80fcc5c26c1b8c542584130bfeeefc825a6ab396d119c55b923d346186a266c5a1d583362d939d6d588d6f1f6bee3cb660b332a3f3e88c0837e669bd3aba1e1e00e58e4792d83bf5d11de70bd034e83565d067c8fb300085c4f19321671457df9ceddc3bc61199175052b40ffea47ec2e0d7cd0939def6482d7f1f53dc4f05b2b4d107df9da8ad60fc985459360592ea3dee0df2cece5a03b6d40bd68f12ee60bf13b4694055bcb012bc3906c46428de1a750408d7edabd9daf7298333888ada8bc89f9ace1efe71a433b08a6d20dee4dbe1634822083ab603684bbb09a987fa4500188055ae8634cb12892ea3c406cb1dd192c9e242e09e213fbc2be422231595ee10bdf67f7b04b1625c04bdaf7f388fbf6df2afca418f987916aeb0f37feb0617be99456846f006d1ad529b91940dba38703e69cf295d958d5bb7ce58c5f2819d96f59f35337f7e9d8615aadd0054904c77d3c2195f4d64167e59eb9e9aabcde8c4d041ca0bd3f4e3d094c97c5b154e953d09e5a9dbe432afc408f285d3ffceb54306afc9543573ec6aacb2d818e845838b2d6cf1d6af7bea5db73db6bb3632474c89c6d745ea30b9042bd609f309e2dd17a691b89ed572cc36836e0ac9e550f4b8ad61b9bb720cbe89b7ccb2ec3da200b41edd244865b7445f40f75d95419f38bd828f22c6a230481aa0880a9e991599db11ce0eab5fb85e957b8b9cfd5479943db285b0d9f29bcc350e9c3368f31929d86cfccc39efcdb7cec2b1b2ad55e3badc8c2d1ddacd396edf3d306220cf0ac9417a8be32427ab2b128a8bbac789cbfd6cb30066a4ef1f4d73666f059894b960c0c5a25fb665d884132a9aeaa4ee1cb1a9170f1fe836f53700579b772d107b4e89a884cf7a23b1895ceb75a593483050c9970284106f81dcb1e6dbf819ab7a83c5f0bd98780ac365eae2b36b69f668b5898efa4439081280844dd18829cef87fea7b13295ae41f87a5ba9a165f6648d8a0f04f8ed1de3cabaa52386c48d9f12096f5cb716c179e6cef15ef524fba2e44e500bef4c96786f5bfbf91127debcfdc0c72d0132ce150ca4d73a33a538cad44de173cb0d64e9a70178db9400af6b476dc44514de98d7eedff1bbc4185d40ad89ffb01fa45622a145bb80efc4b5b72b72b7ef7647b43aa63f5f448ce1a1ac2866d24e476a07c51e88d8f3fa633aeffa794801758f195b418d9db3da77d170c541f04a506b65af34aa6181cfdde03d98a71988ccfabd9c8205a4647431bc3b51ecb8b85a5ee5237ea3061d155e36dcdd2ed948b2762817e88ea1607a8b6ea1606a8e8c5960ce79269dc2d2bebbc6a5fb2944b5eb10763f508e989aa114fa7b60ea6ea962088bf950d68dab8878fc4c789f3bedee7a8573c4cfda444cafa7f197fef5f4564ec1e8814cdb4f3040ad285c6978ecc4c407e2e0780da9579664a48e7a85223d9a3aae70d3fac2e6eca91ee4ed6dcb4ba8f6066806b455d8ae1d514cd02e311b04cff41272d8ddf231f22672a2ffe9d7c9718552aee18fcbfb15333b04fda560daeb5fb34f92c65078731dad74217728ecb046abc6bb3d7f75c9a4815bd6ee27cb5b8b62c6670e0209ff8851b6cbd63f65ba25e240683ec7327a942c315b00c7f3dd5634d42421554b6c5d8a60ccdd5ed7a7b62da33197e63df4ebcce32a07681248b7ccf42b7154beef31d1c6f720c21c60db54b6ac8385db5fa300e993d23c09dce2e0fbd959d1f45fbecfac25a8c2a5634cd4f7da481aa0203df264e837799e76701b210bae596b2b4278d2ceb08bb449b712952c35f9dd6373ca0761054c94109e1f6ba847afe8d6b050c5ff623fd3f1a790bf9668baa1b8a5974a1b09ad2d6793fa8c4db8fbc34de7224828a81f4fbd513cde2ea0a48db23a24ece1329204704798784d7e8cccb8f55b0b127ce6cd9a7859487881699862c7f779f3750c0e59d13a71936c12c4d44c47fbd9a48d13b45f6c6afb3a1b59af92b3fd4d86afae0bd038b6183446ee00d62a4a2ca4aec822f7625a20c5708bc7f9e68f4cdeedc20567880c496c41b3819896a2f351e04032e931e25dce37cddec3958464bc830cc3fe09b1a29c502543ed56685148f39defc9014731ebaa9ff9a6a7d8c49d725cd38b5468ec7bad836c665ceb713803d19f3b37a84fbfc7044a3846869bf26ff59a4a0690601b044770fc60768d156475d8529a558705fd20c053395fe306d3690f87d6ea5cd4d57e5fb7711dcb26cf3df8aa30a4cc911b25c8a40099961fc25ef1c05a03c5db353f629880adf152671c53b72176790c2b151c40cf8f1458cb6b9d47e93a9ef13146744bf02b0565d1889576de3e31c28babe5e8af3abc49b4260fb23c1931ead687ea6c5976471eef44b6c7ac312fae98ac3f979fd283438f59292717b92c3280d6073d846850cde2b594c168b71ebc597cd92e7c7867fd1efed7f138db5c02d6ebc22eed50e24e26b0b69596c1017658aabef7f29701b6518097aec73d09ce884a8fc6fa2f61dfbb4f312aa948b7b09436b6a39af01e8ee2af4edeb9ce7ab5f3c416d33f113cf299dae1d8e82a6c432db9c7bfdff1eeae83c970bcd7989248d0632d9cf3e998fe6ae84399c6515e15f50ae9ab5d85fc07a258f3a07bcba7716a29fb6997d31aecbd38d0e523a2dee01143e0af0dcc80828c809bde49c4c957ef21c3678c0aab203178e3f806141230328a23fe544bd1313e5b3dd921517a7f4431cf01faeda114a93912c9abc276b4734f62e21b2aee98da7c2b84a1b1c0f6cfd18c242aaaf1289f6e0cea8746c417a4592bf594abd1e5236889f0b542fd4ed5a98ecc5a9258f2d1faeef0e582882bdc0bbdbde1d9cf42d72c93e71821285a918af6cf9a4e257d54508c936fa3cc0a9a7ef822c5c417004c66ef2ce6379cd850d18f2d1bcfdfeb53ced4371a9ba1aa3ff10ac7003c57d9e4fe83a0750f8362653d9e9709b562817c68895458bc61bdbdf3c13070d86819a388c206c017643da0023c2b3f33d259f2c258427715fd5821059478e9c8c5dc94755d488518c1d37148c9e0ac13725177ea405b8ad85f6e379f9603146b2ba5710ab7f72f724f6b4ae677e7714dcac728b88898d1c772e85435c3708b7750dc6796b7b2a5d637b859036802bca8e0dbe23cdf5a3705e9bc33d9ab5acc45ab80769074920a0052c7895d85516f1cb7807df50ea92daa6221de9815d524606a758ea14aa5e4fd4e3a435cb6d1052787e5ee8862ced6c21afa2b027329fdb7328db8202895e7c101fad628df3b77ab820f006f063f074f9ff3dcdc316c00551dff2c4567b2ee8105a0352acbf58c26e1d0c5f248059d3173094ac50ccbbca66e2b8b54dbaf28fd58d0160e14e9353e02da06ac894d0f9da893b64bef7041e8694e2fe06137ae5aee8364cbc43d67eb5d84c32d53076dd462f8cd94cc1db1c1358598f4cbfff6bd1c6419a0896fb3d7e89b1149fa9b343231fd110ad82eaca3984707f3d02a952cd8b33faf46fa4c02de82ec2c2768b7548cc7403915c939c8bbdae058a2e97865efe50bc0ebe1d47f53b1a097099f8273917298636e51b2ab514db1712410e92aaf3031a21ed2d7155229de7baffa29fe703b5d939851a9e5716885b8046105de9c7cbf45e9e7ff96b48327707676221268cf6db30c8ab4456788ed72a4c0e5b511f0159f4fd61946fbb4ada0710cea922008437f2502c09321fb7614d2c5efa264d986abd0774bc32cf07560a96049d82cdd1281159d656d91740fb65c5bcea491f9a9780820aeefe63926b318be28312715ef5d48eb06f55bfad8b68ceb105a2f7ea5e69192cd7a50c8d54434018f144b0776ffc3ce316519bcec00c8920d8d39b5b44ed8d595b01cdf1de4b5c58ee453a76e69a71a34aff2d28494109170b8864686e59ff0552b7e547956b088604419b74f64258bf621a73cb2c68aaba7ca7d0659437f702ef67fbd98ee14dd9dfaca8c0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
