<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fda005599a7ea52270571a0c8708e4cd7a41695a176e3c55203661970463ab519a5c3b7274b62058985b983b8852ec264c4038336ed7e13da2d07d275eb60f831262e138d5e2998817153614e5719e2f857232891c15e25484c0f739621a37991d061fe0729daf8486577ee5b8dc9667223f2996a62faf281b429aefaefa9041b341842e7799dfd07fb60f6385372b027f93f9e4ced9f418542bfe6a973779ac9fbeecfac3537a03a85dc2b957a3162a256ccb6b54d3fba81cae2fe49df0d91475a17274b90dd2278643a88bb71741ed9f690f4942b23d0121f5ce04c27f7cb628f2cf1fe0518e4316b17cc4d018402ac14e6b8829beb171ec4fb07f8796e6dcb4a1e09e658400c59ed066c91bc8c2e3b46885a04555fa4bc04475b920989129b2718a05f793298fd2ea7316ab169a634797b0a38070fbd16900a8d46aae6054fc192c9bc60ecdbdc1658b198371ff045beb4541473d770884f2cddb6dd4f43c58684e50e461e62010b4ae9bc2753bc5e653b88e40c7a6f6fc333c2d0f47f8710f2c539fdf5d1e598b7832edfabe70581d141df547d8150be89a2389b8781eea0825325cae0a4daa674ce6a5a1e1e42c897feca790b28625e25e1cb52abfca2469299ec23184db81a5e3636cb93f6cd73b789789c8366970e0a0decec7870c963a2fd8784fbc3d6e355ddebf5a216f16bce83f95adb593d659d6a76f606b61d5094f69e6da39c5b4b0c0c05d892e3ec0fd4477eddc66fe6e16f1bd57e6bb2701b9762c1a4e37c54a8ab234d4189ef415971bc5f81ef2bdd52d37dbad429283a39b6c8ffd3ca8675d0310993b2b7035a13aab9cf50ebeea112faa6ae4690de1402f8077199d227aaad9aff364ed8f2925a585702fb68d6bfeb5acaa19be12ff4dcc093e0e787f76dfcc7255e77c1d7e1899eec1b697cd3f13e45e65f67768a00ad103cf88a63acb89937ee77395f0b383e731eb323c5c242ec7c95d918984f0f872bc27bcfb157c37f73f436b8f2864c5a6425d181df72c5d9e60272a041ff303ecbb73c2c00c3bef2bd6be399a8d136ead7bf1c6ba2aebcfc8a61bb3c0cdf6b033aa1b2f5be8b153f8cee66bcdbe9e3617af72e059aef322ab07e71096ac46a288b5a28920cd3e34cd4d1cae454adb5fdfdd45c29bf6361b2e65d60f5858fdc042e717ae0bffc4faba347a65294ddf163b9ba4e4f1de956f03d61daac84071982f55626499f94d870a185bbfa1ddaaf71c73f403e5363ac86fe6624ed27eb27a91fb28d0620b8bc166442d3c65dda35843a2704f7f616bd278e66476c15c571a4b3991f324d47a3f94378e3fd1e08b14c0871fc4a95bdb0def51b7b1fe5d4a2e1f7c3161f8d44a30e5fc0e4542fa8407b6a5834edb0f83e741f9b4132f666c56bbd262c3400053b431ca416f6a375177f62d1666999b56ae26b373c4c1b13c25125d3b378d22d2d208dba6b2857703ab603e61c5a2cd8f6f67ffe43f50c18e74fc362cc9236e33b2ed0ffb1427781807a756a4d06eefa61d36937bda8bc9802891396214cd6fd3a853eead860928838090ba59ac2ef6fa83090df506fb1f7e33f156a90ce8babccebd7e76461c2223d50161c22799e0bcee793e4d6a5dc7419b75f57136d6c2ad9f46ab9268acf0a46483127dc6ebfec66d6b372a22389eab8b4983ce9aba49af93b88e73b930e4c34fc04e75633282205ef4f3e4167d5be09bdabbfd55e82078252832a1d54ed3753f7f2a364a27014bf43027b04a08c65fc675346513b103d3056a4dde62e95bbd2f4e856516b0841d8eb5f75394646ee8cb3b51b29bd186d01a73eb961c3d7f4e14d2d0f74810d3921b221bcfbe33d24dc97b93488ae5db4bc801f74f02a6d18afac318152cbfe85988c8f7b8ecb79d75e36a505e687cfa596ab03ac74488a7e10b484e797bccba6e5fad645c56e08d7de114ea042da437773213eebc489c6e324ac0221b706c0ed4214d26d2b8838b0dab45c46a2b787e0ecc6ac8bdd54d858ccff8a1adaaccd61aa6c092c0104f2f8c578374ee50ad5f91aadcbdb08798787365d0b527424681a47a62ca8a9ee257f1c2ec52585f4f671001aebf4e5c3f4403cdb5db8340504a665c301ff820599befce2c81152ba04aa6f625e83de4d1b4a5f342129f8d553eee7ad74416b750e56d2fb289fce021310413aed5d7030d93b5b10f5a1e0a21bc095dc40a4266e96b11db6771bbb673fb7c0a7907adba56a07b8152133541cdb1b3a89b3de54eefce60a09a949c5c40cc3843d2284a2f9e9ab40d710c5566690d20d8018d64d2e6caebf9f4e5038a893e75716c9c7a8db9a454327fc00815099344ecaf786955a4ff0943eba0013fb8a78d486ac4910ac3e9640d580a09a7acdf60c071fc6bf721dc6bb8ef6f37b9a5db3e1573931b5a79628deaa104ccf2948ce5015f3b0fa210ea29f7a1a06cfa7b9c25c16b347fd7510bacf5075a17831b3e53229c55ef078cabc38bb8f32b20cbf021c55de6ef7d2ae44adaf666c91d4c61d6c2fd63e667972a92a3fe64b817f5bcdc68162fcc89cb6d7707cd5cf92ef4c0061d7355f4b47328943abe22360521d281b98c5c273eb2b732dc7378fcd7fb2b24754a7cd2516ed4f50dcb215630c28cc8365171e9ee6fdd8fa01ea4e4ece569e1e414943469915a0be33678c67b13275455feedecaf79d7a7cd39e913840747423fbbd8f7dfa99e2e3eda2e03a5cd73661beb2417087a5fece4186cc8f77b111ee7f8684b15493cbcfad15599ed65c90e180396b6d406cc7c84dee97ab51d5dff721a80fc95bd08346d6b9bc145c6a337e2962dbe388b8677e65a6b1fb8954464b066deae81658b1c13a852d01ccc7f294619a9233c3089df1e7830a0005e076d7167150d5786fbeee18da00ca742cf4e0bd90d689bc512152f9a2094382fade8b2112a851d28fbbd6929f9497b0c93b860ac6494e345a7f95b100158753e20b1b293e1173960db6dc5e1e466e37072fb2ab5aa13dec85956764914635c247e545249b21c1237a29bdb42a45284a390cb61fba5852c09408f9b2e2789842d2396d54d4ae908dc3875b25044058b8fd9d7b58fb0df5e288c2e428e3c6f2a78596cb7e6ba25236fcff9aae1c46c71a6743182951d118ed7b9b975d76681ab5eaff1dbf4a11f3f100413f598b9c050f275d84ba9f997fafea435ecab77b02b5768c62a900a5ae446167874169728b8d8262b81f32f63f38aeb8729c9fae89e87270c3dc05ad1d80b894df5535a5e2a3649b6e8760ab9774057e78a163c8b702312e2071efbb252aca76765f038a5b818bd60f86d0edd0bd8baa370f2d7c74c93f974081d85f24329d29d67577c6f915565a1b2383b338d7979a6c8f6ee1f90b0951b0643c432b1660a02256bb483a4121413d9c13043f10fec3f8a96906f1dd9ca087f07bba132dcf2a6560b16475e23969ad24a9f0f0a148eae010cfe92c45ebe6d3abb52eb4dd80271af9430ef00609fa63e4114ef32243d8c93e28f9e335443f0290d8ad32dec480b7fedecf74836909838b6a07b6cf4f49f4ac7c4ddff35ee9455d61f05f515763400f970e64e4adecf7222b7b1dc1cf41c4277e2f61439f9615b7a1ee2c1174dc4e3d638eba9ea8006d608019918ce093cb94fe785caf6f2f529b662e8fd7318d39163c876c9a27d099467c06fe5ac419d4770688ab1b2aeaf84fd0613188bf461699f8fd8e02f1c74e5265c9303c2698d9536b360ef20cc7d476bff63f3445f91667489086100f8409812e7972b80411b6ffec380ed25db5b121627ec9297f84e30e17c6f3adb2d95787d0b89302f31a13f33f4df43aee8160eee65c9acd1031dc7405c935e1a92639c559f515f68e9aecb5dee876f1c9feb2a1fd77e78efaeff263cbcbf0db25843beb04892c89c69382458eb06d2a0608391469ed0e4dd305cdd19b7662e53711fd81fbca0a8688d3d25efc32f354109df33fd4cdcf67de724d0ccb1775503ee1e13f3abc19f58ff827d3428f75c1fdc1d05f6b3e0af4f3b92b7006b61aa5f5c2fa9076a5d740d34b7f853cea2241d014e26c9dde9eee1281c63573965ffb83a77211daa8f1eeb464c90617f9f7311d4871e53bfb55f30aaca7a3f174041c5e127d50b76d67881cfc233f62dcb6c755639d35b7548d1fae7985daafa3344f4c1d8216a14d1bfe28cb07dffe3007d8aa7e062cee9f4bf3addf18d7b7544a835e8248ce246e4fff90ca5104417dbae2a335a43419bf2667a691f2c5ed363999e3c88bb71ee1c03859d4d94efcb0b517e85bc42dab4bc7ee7ca6999ae841a072bdcc76da927cfbdaa101d677f693426346c1659d983e03567208cc2c776c70473ebd0aba7e54c97293743c823e705855a43b3da1853d6beaf95035f68ea872583885238e6a2facfc175fa5347081edde8b81689019c7df32d894626427b47b1afc7dcba87369c754c778efbdca1ea904a183fb9a3ac840c44324b7e5ad8e5401ed9429db40f03e755d1f4a2463ffc735fd440fde37f6bc8d9e89ec2ab497598ceca7697250e93a57ee1ea895ab68795163730417963e6fccc50d19494166dc988826694c0a045092285f75a1810cbe614df954bfc648650a4906af050b136e60dc1322ed2fb5c83398d314e2afcf9568e688c789910d0c0debdd7ff97fae7d99330f235ae9592719288b145933badb385872aec663fdfb632e0bb3031e00552b1abff7b9a3d0c2b12264ce0b52613669c4946c2ea8a78b313993091874afa2f794af3bbec53f3546a9822947b5ecbb74475f17d8742cc1d9b9211d4e185c3939ee9b0791fe1636b9fb514b7ae174d3c71e5007c0e464a8f4a3924a9b68a61490de331d031bdc7484f6de084187bae58f3f61201083ebd4c3f9f77be5136bc8da1e5978272ce6d9bb28b3c5e6dd11d4e2014ae8dcafbb62434c3897cfe85cbfc0770e3c7b985ef1c7c6bfc1cd2b9f3a83da9f846384f37e083a904361a1d85313e7b32e13fd3221798fa39e86c4af0c99256965e1d63e8fda6ea02f63074cf7e4ef944f512f8e84bc2a62dbd24ed2b1230eb7433dfc909410f606f1f3bd321cf85af691317aebc4e0328b9cd676a5de5bcce5ca2a56af5a9bfd74997cc19aeadde382a489ec4843c8adf39f6ada927dc2d96a2bca050f1a094a7c42000797dadd64d59c4abea9abade0e7f288bae1d4017ab6cd7a9420beb62a9f856a2af178690b3b55932ce4d2ed1956d81cba78d1f4fc96325f0114fdbb5071db4443aa3b36fb992ab6bcd0a7cadf6842b5f54f9aa9416ca8558c27ff17e0cdcec2b3f914bedde17d994d2eb541d96874cef3be55e49d0e78fc1b67f9d971008aaac3f91595b22a6e8bd6e4107536adaee9f41b9eeeb0bd8b5b1e5a4caaf8e7be402b51121efb98b9619ffc57f8881db987661a4d6d3c72cea399b9b1813cdc8dda51d2fa5f8a7056ddcf7126b2f3074e83edbc9721337b5f50fede327e0b9f2a990c7dee637363e8bf718833a4e913b8b7d3013868daa2434968738dee5a02b58dc5297fe186e20892d23892aff736be9dcd5f2d807b434dd8b96e3ff4f23943a98abd22a304b17a37d4992007d829221edfb509ac84f4dd17f49ff6fa7182715ec3e9e70a988ca358252f36f3d4077aff18d9467121d2eba49c3aaef3424b4a1bc27e66fe339bdf747a293be668267db5fa3cc3f480e202ba7fb3fe10419f4dce4c17d63f440871013c3fa32ea0fa410a005a7de69da6ad45d706d9bfa16d62a9986771186b569b5073b4cca92488d6c4df05e08da92793f7bff107f61ef5e27bf692037fcdf42068cb6e22f5c85057a88f2b4c6b1da60f95f5454a60dba813f6c90466c04bb2b401f3e994d849995c66e607f61f16276268850c2b7d876e653e9c553d1d8c010b8a57a50b3edaf368f59709a7ced6e4c2991b1f6b8aad5a3879a27a6a6c02583df3476270db469f5f0b2455f01074ea6af26d1f1e014b34728c3f8c9afc9cf5229fe3e1597d4aa73704ad388c2b19a13a6f68181708d1a177e23615576bb4c232d6d213835ffd4def1f40c8f5b35091d32d3e847e89f0bafc3b0c0dfaf6cde69ecc7dd85408183d84874ff53d4c8f01a0b51be9bae66c1fa2bc04af63162e8ce89980c2be67b4daca60158e40bae2ad773354dceb5f584f322477490d68b20c97482f5ed5146267592df09a540621a282092bd6c7a6c1abf792b8c85d7a0e1a908f5727592cc7e4035c95cb0e1d6fb981f45187552b1cae254a21c527573d1a17fa3bbf2dd71211a2a628a605a0e20f31b53dd270029e6157cfba37f04431a53025d33a709d568843d90069ff79f2bfde1c5e4bff973ac9e19a1927252c594bf69cdc40f810caa23ea10ea915741fef57f1bfc567ca6d2719cf065b12941c810e872e25f51f868fbdc0e70b266a97b4377fdcf41936ec57ca6da9df7294d57db90d85cd6cd438a420b99dde6c5490f64ab1ff9cc4fa5bd8f1db34f30031c7a8671e25d77bc55b89d6294039cd55c4fff72bdbcd7f79f9bd6a7729868f0d5576c633428f4daabc1f4cfc2a849040c0755420e1250645dad0e6530acd9556dda3948e4aff9039ff44f375bed5a823b865c757461db175fcde8fca1a90ddce811efc7d3b33521f8661ef4d6db82555240c95ce26234ea8e3afd8c46800bfda6bb7ad53f8c32b414280e362e5276b708ecc8b548522b0ef25735ed1fea96ae4ebe2904c642475f8867fb70153647609a5b7514110fb30e25258863f177ed476b87b01eef6e86ac384043ce8493c4ec152504b32111f868b73dbcbcecca9db0b57b422afc7003a0a0fcf80edd7b00de98af9c3a794168bcf418bd9afce38fcec96438f33500cff43b3c7d7ca7442913ee25ed30a78eb74f9250952547104e04daf2ad1304a3c2987450e0373e1182c932b384dc523f91b077e007f9decd7d8865de387ee2a8529cbb33bb09974784f7ae3d0e6aa63fb2ee5d811c1257ff2ae30ca3f1241e107626ed2bcafc39f68dee3513b9bdc9e737218d27be5cfe405ca2dbe459bf3f3d84dee63d51624efdcbf867864e5629f18cd6d20837153aa97fc91b77a9bc3034a17378bc7e2e9068d36272b7fc26ac5df1ea9a68c9724ece0e2c953cf7c60a93b1e8380718f2663be5be1e8ac4ac91ff129d485dd90ba1327fa1036ff3a4edacb4a787713ec3f31c9f60f56a61d1dedbd2880caaac7b05d3965dc6793033b8b8185aa31e8f68edf5ae7549e10945b930c0cc9648d3e39f57fb6442dfc8e9792a5218ceb6944b4cc1f5842710494d5a10abb640699b17268551593780596d4ea6eb2280daf72957eaf6817cf83283741903b2eded16c8fee6d5cc7cb7b7d55f0424028d9ba7ed993380f2dcc547034941b2df4c8431191b5b744fa0b9ae0dd1e616272a6f94108e88a32e407c12937d6c042b77b074913ed82cd84ed2b45625d4a4a81c35da545c280413c88e4f26661ba0109c4ffbb40b99ad91791c069ecd59ab242d62f793e8437b46742562a73528432c35feb975e5da7b5b97d0211a7d4d8db1e2c550cc78a5a597d22db638184e2b43a195287f8c88b33821b5d0027f4acc11528c9f04de23f3697b08439aee01185fdab53339f049fc354031d72ec958e1acef34a1ec6fe088ef8f9ce952e724c775e2120e3ad79ca1ca96050209966bf6477d155752ca3a076b1f8496ef88b52083bdf9bde1ae4b0b16ddaea5d251af155145df2542a970437e0bc1a8eee102fbf7a8d4a867ff414147a82ead93e971e38e2594aaf4eb088f4599e66870db64282cbb2ba8aa2a89df15cb42602f99576e8acfae82d332f1d538c607d0adc6eb85794b5d6eff7ce3440caab1a8aec18458d798e6110bca0cf02100a573cdf6c1da6664dc0372a9578f5cd58bfc0222ec0968c9e828e7a338ac472717d66c6fd3fdada2fdfaea25259ded3f777a76115dc87fb7bf2c29946b09f5791b8a6da1ab7eadb471f147dcbf8a8361c70514726f4163ea12b23aca616930b02f076d9e95f1fc269a117fedf05a94b91b826136ce3c0c6dc9fb94add31383553d231e4e0bfb940f146f39b58605ca7683add22db840f6d124915b8a318a4f9d147139dfca1098bbefdc09c0a82dd8dfe0e064bb8cb7d4d3257b01bd7bad498024eed71984b155dff826eae023a1131664694363c98491a097b525528a8c73efa6389aa57c73a4b06dcc3bece4afad647f0d4a5c1da827a65849784d98a7336d8c2be66ad52bbd115c219badd3fd9dc13cf6fc1c1a5f26530d739baa6c3af54be4cd728cda60ab6289dc5839813f09ce4d7d0f92ca6355dcf61ddd9071e309d2036e30fdaf6ad0499be291302bad8ae84aae75c95a9fd414cd609df7f2bba1af9e7f0b88bd656025f3548622306c99022c362c203c09a0e1b9023ccbde088709310ae0ab25b9f8e30a98fef29aa0d44eb4bc3fd537f7809d55c44f8a496ecae7c7840a02d382cbf7f85021157be7546ef9994f1f2318d76146754937385ddb89ac5e8f272f606cf5c6d357d68b57b5ad897d9d4dd21f9fdb9dff8881b0879a07fa2a53b69eae68c0e2e973c1fe0c0fe9ff29bd99fdbff1f62e5c0adee9b97392233354ecef9438489f3aa2b444bf5665c744fc923b58c53f83787d39a2cf4ff5e05f233a1f5a36d894f7e3904dfeeb14731d34d3d14ca285896e0ef83c00275cf7d2d074c80b4ac429348e8613354cf1ab8ff5f0076fbba954ba4e4443b65666c24865a3d24a43706e67056a18ac68379c82dd2760a38f04010a720a6141e0d3e31499ad659a57a40df842eef28a181c407a8352b262f6b258c928f6b1d6ec136546d2b1cd4e6c8adaa3e10b6df56c1e753f15e7d5577d515617a072c22a6d87fe45187d8e657dd091627092609ae35ad070ab843b1c67202461662eba418ea21f1c196c0bb2c531b01d417bde7de5d20022710ac51e8e944825bba02f738e41ad128f1f37efb99c5e21f52339b4d0ef127260c5d59652b7bc1009396bc1ba69957d539dd3d02f3f929670efa24447545f0639112dcaf05dc1052868067e1d99f7bf9edb9cad5bc246e1b09084d497bdfb2251b87469bf91e4ad17932427aa1cbfe2e03781b65d3ffc499d782834ea6e2f6e95e42ddef790083f43c5a9b768d6446783e9b042a4566feacd614efff3062346fbca9b796202562b5be95b242f0d6a41477cb62d4e4244c961e9ecbee336e8ca5bfbd4ea6534c3305bb44e9842feea4f6a608a92e1d9310a05e81e2a81559a4e963e4ec45c2360e5defd62d4109b4b833a0afe2e6e1d63133056724fd1a14e1afa7d5bc07ee9f22ada882e48a7c5c793a260fcc3c98600291d01a27c41b559ac95897112c0d95cc9642c89c36ec5bcbf05e09f526f6bbf2c1fc805074ef8607eb5cf0e32dc72c97792924779ccdad1573454b7abb6b3679f3729f38e3be975406e7008d0727fb6923af5b0a4634946f8eae8d5e6c92cdaf965cbae0b13bae50acbf4c3812f99a5232b78c5401488e16d71cf01821e1302d433d91a4b6840dffa4056c58171ba6e91b002992b8c14db68ba2d086fcf9d06eb9f40db62901b690bd203ed625eaf82d7f9cf2c92b0b284254970dad861c858a84d50724427be91c5e55c079d12bd0dd48aa86ac1b5b14058e9012e2c2f4abc67fd65fdba37852681dbcfc0e9c7a2c6799393aff22c655657beffd4560977fe71aac8f13321f833d988b86a4b0cf1a0a4af82b849713b78af04d7db3bf8bb9242dbe1581850268032e61862217830929e05bad239421ac648903b28f15e056a3810c28a4416919ea5600751ff9b278a4d7cab99fddf0d3280fddad11623ecd0e0177df814ad19656bc465f914198e93e8580c01f8ceb514bbb6122305c251eb011851790447970f0aecb998b873dbfd5e0ad78ce8fcd6d67c6f9accbb012c6ea460c2c3860a1d4d57ff2f2f778223b12f72c16e3c9fe5948ff9a6bfa8a992d187bfb05139f19ae35a6f5cad410ecee6b27770a9b9fc87fbade2979640c74a2d5f4e6ecaa247f9788936c0d6f2f9df4750649f130acee0e069449dc880a9d803a1b29435a64ea6b90e810088482b48e1535f4f2eee2a25406289f2486b6c5adbce6e0eabbd6495966571e062b5b503744201e7122e56a1c7c4527098c6e5edd8c11d775a1a5c03ae85183ce3a7ae65012f3fd22ed91ec3681030b6c501726ec6a61926cb63c8965c7dae90124544381f8f4e5700ae8a0c380bd810736d2ce762b5288e6acbacf749b72fa08c0d3ed93ac4fc8c5813e02a03d7bfa567d78062b2b468700d94b3fc23ca1030be23fe4a98e703fa5e748362065f9876b55313e85514c1f3e0a040a1cfc543ce3d35a87d3c9783832d2b8718310b6c0eb10f5ddbc2de88ec8a46c50cc3b971bfa71bdfeddc05663544b5027da68af468c27526023e7e550718c55cae84681cb0326c6a5aef825e2b001923a98ebf07e64c3c309dc031603b757980cfdab20f06f67a009d4f061120fb025594ee940cc08525e5442abe8c1bb0f71b2d7d11c26b2802d0ce0df55a0aaef0f05ca19271aceaecb17c313e3068152f12483fd9a714e14b922819ff35f6d2f48a3837f86088c63d41630d0ee79f4b9af3684e34ab065a8926710312c7b3002c594b4670776d6cefd58c0448a3c9d5874d65e8adba40b585178732f0a3fda284ed9b86a4e463fa7c0212f8d22d3f270b90c8f6e0523d11b965b03a2467c42b2c30008b1435abf40c532bcaeca1ae5235e7e75ad562d25e6177dbc8df028149f7b089ca1cf68415edc866bee267200accfd13b7b4895148b6ac17f327dc5512962b8361ba07e14918ea27839919e3fc71cbf2f6a507982baa53fa71d5586223f5dc368e4d2e811e63fe9edd1d830a823cd0a38b64a007bd38f9d57c9e8ecbb972572d86167bb87a970d83aa845d5cfaf6dc34e13b2f103f832b93ea5d8ccba488e9225b11b26f509fbd5197a7cfa7fce828bbf490b1909a5841daae845a054f9ce114d10496692925b149ab082d44cb46c5f3760ac5b1db3fc01c08fa67d7c62501bea9b5093554265c10eca9142f5219f5bc71ee130adf70a4dba776c53767f28072c545f9d8de1f724a4f095edfe5c98aefe45c5bf655dc2aee7c2c9fe8d589915fb9abb19e1c5b0188941e8f00db92aa70f98575bfa5ad9900cd567a58a9032e7a177e96dac8cf2f1ff764abfa4cb114b391bca2298299d16b65308728bdb05a99746ffcd349daf1bbd2ab978ed31827ec53325fe2b6d2406913dfb91c97b0de56198ca55277faa24824c93ed1570e068dd48e7231e22366d6946bde2dada8a58e16480b94af96538ec92573b5e6aee065f59b168fdf26fa71e2c4d29b7a02f0b698cda73834362afa28e191efdb6d3ae52c97335cb7089941224c0950ab5cf71c2e4bdcea1730dda583a344e9df78c8d9d16f65595f2245591f4f1a30982deab821b3a2b9eacaaf1db36958092df597037f8f03867535244a2a8db94dd2c563dfd3b93ceeeddd974ca18bb846085673145d2e7db95d32a719ea4ae0401a4b74b4b361b5901842bf0d2275b56a18d2f25defe6d03f898308c5dcff4aecae275b81466befff0c15c7a08fdd35c3f92a845fc169f141f1b9ef4efcb472d00a578553f6e2b54f7c30d23962028ad7d43ca16b1a21b6a771360aa7b6e5d1c8432eacbf1ef2327647d0633f8671d57935ed6e1cfb515bf90104476cc6e3b3a8addf42b4f75e4cb8d14f6e285659a32ac21556372c0a68b27b456d44b725c3a417885f1f545646ae40f9d1c96bf67f333b24ed22af9512deecaa0d1944632d6c7b36cb576f13652ad1f3977595d347f63d348a027e41a1baf1b9aaf7fdab70d9e71c33bb8b6c249086159d1031ad350b6e31b1408fbfbe44a52cfc253ac4e409cf857c9d1bcbdeeba32a7614843d6274b7663cf4f8d7314638f09af2f08e2fcf9e7e5a3ad495a1359da1120c51fcbb3b32218e1719d937208e5303d30cad35c608e564ac256db95c0abbd588891d0fb34b251bb5d4cecee15f4fe9336d6887595eb681fa579a7faa35dc8415af3d3ce0793fa97add7920bead2c8e61d81510015df4d2dde50e8cc724a5a2f4d2f267e3946c155557f34b23c717aea9756fffd0d578205e639b1bf44a85332292b5d6fefcc20aa699c80571bf8bd8520e3bf8a33411abaec2971f567b2e0391e28218e196ed89b8dfd43153a8d83318ce0f581eb0d92ef44acc3f8e88522a974c6805b79800d3046d868f0abfadd86a7298d80d55b14874fbc6846b3ebd062d7a1818f4866def37a645b5dfae49d4d5d415289a5942a47fe722c68acf5c2482740be8e0d5e75455a924a7cdd847ef4556a467df234cf5164a1b817d3909622f4e3f58ebf1cf26789521b9275f8a9021e52d0af590934aab59768747359d212dc7be30db04c0811ce36cf83afbdc81c9bdfec8acc334743c818753ce444dd6ef66098495574fc13b845c790bfa997622ad24a1a197c519d6321f7b56669b4fd23798c59e24e39d880d3ff53eb0134220eb4a9c7ba207525d029fe5e762bf986f2b3f8e6e09e2ed5dbadfa861e9e6a6ca98b37dcdd2358582640196f75917d1f969e1e1dfd1a12b4464c29634b135fb03f50adf15489ab4dfc963c240d9db0964ef29dc74a2244a0bf89f8d56289202e94a5f8a1f564f888e4110356c55e569a74e4de8dee3689c631233b8bdf765233797c44446fd3cf63590d8477ba4763a64a9fbde7413cde24ae27c75c4098466d3e85fd3c1e07c8f4b3cfdcf163d84ca7427b8970813ac6c3e3be176afa8f2646e6c639f22190e946d4b82917dc8845c73c8f7c4870f33fbc709c5ae18baec9d87456c8b9e5cea759328aa79795fcb44c403f717f021b27a017cda96ab4d15956ebcd73069ec0d90334cdf5140e9e66eb8dc751b037e37a8c634d2c328b13e01d1d71fef4606452d2d85a013d2ef61df8189106aa4b346a68ec23355a23dfb2ab2f979e42f5bad6b1283f9105f131c7cec7234e64de44e1f7f2cf9175f975f4cd42f5bd76b859de2c3dc574fdbbb96daef1eaa85963f2917a2a9abda48107320cda0377d7668b2e78e69396ef9660fe1f1ce53bf9cce86a33fcea56dcd3e37530326217713bfc5ace103188055f35372081616658f324ff1c0a62bed3cb32701aa6c7e8f65affc005a878319b27e1f97459d055d2c635a1626d8634f85064912f5062b19782d1eff12d24a58a8421b04e70ee6fd02c7903e09e31789f438203a313b36897af15a90bb3fb1d225960a3e1580152bbbae7aea90bdc600baf81cab759d095de6de6787743b40001707f5a22b7ab987c65fbe18dd06b028a78088774536a0ce307c9d04daa4a76e97a6e7c7976da652cb687bd6c80d271615a7cf7860c4623d767cb906ca01cce9f0d12cdb275b246f5e8479a30ea3023db7ff646debe0ecd28636a7f04075dd3d03c7c22eebd54568273b8022a88be69367b0007e4a4b1b24a2148c6fa1e07d1308279b1d41d2fede204d044493c3173f0db58c923c57d9cdb353a7042146446644e9a63f4b78df4af4c7be0ead50b587bfa663ee3af994245742edd8bd2c590204fdc4898d859c97e6874bca9208d330f49d8ad9a65fb535a9aca029a533cc1b2e6bf8a322f6e238009dcd339c9ce7e5c34023e0b32320eb4d70b3bc819f9c6a589399871e6b7d1f3edce9413f3ea96bf86a717933b2d68fa206bdf364c4f0413f783776e273a7ac7d72bf570de111cbc1b8858b1cc62124ce10d4692cdde894ac529db0c3c9b8278e3601db91b0c1020e8f8a4fad975580229f361b21231e8791103429ca6c6b5aea7ff792cc067c4a45bb8dca915dd131cba72341952d0504cf34d9109720c606d899aeb8b34909bcefb2df4c08182a0c8aef85ac68778c52cf27ab6976fca0f564cf532c3a7e42b0efb57a691295a2b7885150c47b88a43b636b2ffb642c01db26c61c69f5632cde553e945169b95b6baf15993d4da6b51a82d844a38718d32e5077c02406b5459dca0413987eb3e299a29cd10b6f44c1315a8ea91959ee16d1b1789cd31a82542063eb193260e54e50d729f61bd9d32698dff341fd33ea6aa6d632605ce325bc0f8f105170a585e037f874031cc0f0ce0e77e094575b090cf028a0769c87660d0e5acb41008100848f8b16d4b6a670b45a27b289efd29ebfd6bf52a7c8b36b371eef8b245e41c88340ccaa9e09e0ccfdbc847942f0867fbc3ed33f8a4108bb7d0f61d2df5b7f154bca46b213b9340d335ef518cf5dad5d2540a4de1a7d646eb748d35ffb3b605eb21f6dd4c2fe34dedf3a102540ad05c69dea5ccdfd75ef7ee9533d8bc725db570ec7a971d9de78169c48244989b5e555625efb317c533eb128b49907b094f7b70e27411d732e9951b37987553f8be9c59c00db3daf3ff9bace7574738f7bdfc3ff22fce02cce000e9fab75d61fa2086880ce0e033e8d55a243c71a4cc3d8c2e7a37afea87f5323d0bbf5eabca3b4de6f4d1674a19cf1de89454900ef70b5f3ba7ccebfca0c7291c1972b0363002d7d177a19923b0aec4a0797ec8d715885a5b322a9077668e2fb0aac1fabf774aa98004b7e01039d8cad15badc78fd0dd861b5145d32d061b7e2e09823769c77c479d5e40ebff737f5dd6d1cd4c3657d7e672fccbd7838f52b446e7fd011911fc8cfe668889845b794d524d500e4cfdd5400e2fcb7ce18f8846424b70d0afcac43cc56d8cdbf3a87ca1aed09632865cf27c1130f777d8ad834866a9620285ee0bcbdf36e1acec96dce1308cbc736c74ca19a143bf41634713b5303df71ead3b6babaa27256bf47f78235f74476dd27dfa9734db2679e27a4de63ebacb37bd935e95e2c3a73cb4a8d006e19405b7ad6a6687f22197be4bbd1c57f8a69e69ab3f05ccc8586eab191c5771c26d8b0c7b185a85dceb0952b99d9fb1a90d1567d0ef8c3a796883d7e23560ad071fd107b370e561dde8f74810c2c96e0f032aa60a155700887f1c9978b4de55815277a23086b1110c1bfbb419f5a46abfeccb2b3bab83e437e3bf7bf30186d62d8e948a10936a252db99435f84e23084e43ae4960a094d816d726f3abfbc3191b8e1d3226b0416e851225fb1625026112113f445e95f4fd03d41d4c03d42ef62d800281157eace0839a978f3750f0c113c0f10e1b1279c2ea8c0ab3a94b09319f8e59cf404d15dd31cb4bd54295a984382c6a3c9119db27dc28595617526c61cb3becfb32fbc666b81b8a1572440b86d9a12cb854043546f5802e836683ee260bd146106e4d0e266d3382ef9eaf8e544745eecde44e389357e28f989aa116d47d31976ec6a85ee8131575455f973408f05130d1dead4bb69c0dbd35449cc07e9890981d26f49d0e6a99ed663dd9a13c8b3535b2e0e7774a145441fa054c92455df0c22976bf2b560a527f18485818bf7913959d30b7e510541fbd92ca129ce1d2eb6ce3f2df70e82e90514cb01af23edfe524c9dc7076977e433926b63142c98e3e4e30d2f1601ac2604571e7fe665607463c94fea321d432941fe0a9f6a7a5c88ed9292861cb3c9774c1e88ad816f2f4e48c6d2aa058cc5c1b9db634fad6636d9a7127740f64e0b5d61a1011a1051fc2119267c26c140b4096d6534193713417dbb60b33e5f2cdbfb3834db873a0f69ad7b913e2a4fc77951fd352d9aa9cdebbbcdb2b4ccdb7760f11d8815bd7481cef53386996b6b34d67337dbbad1cf417e36fb302de4e5180f942f6543e1cd345ec865bc044e58a814bddf5ac10dc36cff77fb07d4e63449fb2a7b6e9d9e0c835052b4c806227d5ebe0b29922fdcca0ea1cc080bbd96ed443b2d1c2b6f6f60903431822d30caedb1be642e6d88af0ff179aeec1fc55a1fc4783addb6ff5c3496cfdb739c97b429eeef392bc22cc34fb08e7034a082b72f7c833232c3fe9dbd1fefc1020999a5add01a201abdd24604273f3b57896fe0ab91c4dc86e5011bf9d9789fad450157de8940c10e30d00eded644038974a567051f4fb77a88f05ae481a4822054bf460d569c9dc048d72c766913637f4de6d2f0bad314389c4f4a2f53bcb6ef072b6760842ef2dc7216a52f3e19934668fbe5a9fc3b923bcacfd3da1b29f417e92747fab699952411eec22cec881c17f7f178ef4270644c260f203a05c3267b8d2a6041a784fff8032a656cb14a6e730678ca20b420b895891cd2ce88c0101979cab8cb41780d3b2deff7e760601dfab4c9abb7955437e87500db58f990304c261d39fbe99bdbf1816f03131e89f121a9a6ec9908c5d273d31cd2db28e6bc851c9675ee8087e5d621a822ba57a821f6b661d2fed7ae9e67902c564abc95772bf36e1b0958cb57de575b6d874beafe42b18ea9f234a5eadd4fde8a4aa4c0870fd3f31cfaa4d0b9732e2ada8917699e7f914e097d28b9077c1074bb773de34a9c45e83adf47811ec83bc5277f9555eb41a59517f15ca706afd70dba76bbc911341cce74df35fc412761cc5168a05c37df6e16620932d14582f37780469f529271424db13716721bcbfcda25993cf93669ff60583a9f18200444e18351f16032312580be0dea935c96ce40414e810465e41a5c33fc59eab3600fb9be3acd665d1b9dfee0c55d5804517516b2e247ee5b8426ef64e5b47a7d4117141531a0f343c0d6f1ffbfe941fad9c400b4773151f2521f7a61fa09d04c23897f9de325275514bada5a7bba4d30fbe80e00e9781374e8b3505deae31202b56cd57736178cd7f0288ace59833bf6349314ab4e3daeed78e459e2a39245f727ff782d75f552a94cd7c17ca1f31df7e1b9588d409ceacfacd91ea8f09a1495a337bca252f7afcd8db055b89f44a811e789d0c77381ccf62fb7f3358a4a75915665b0b1ccff6208423eded5b68b01070dda3ccf4122fefbcd6fbca54cf08ea74b3d854b6411447074c74225991e3f3ee66905c7ff48966b013f83deae1f2b895946df3113ea3f8e2a958dba48d63911098d3c55e9bdde9fa830785feb537828cb82207285b5f2682e15b72d7d047ee0a5ff14b7e3194876b48ad2074f79a40df41a0acee8612fb69c8fff6433c7018eb39fbca9597bb13a6e3ffd71154f114a0aae9475b5feb8974473ffe059b1ffb4024385f682df4595750125121c9b6ec181a698553dedab71bc4df7ea9b4d9bcb7c36138dc4a1195aee0541905736bccc4bbfea74980067e701bac642560489777b1c28226f29327bdc009f04af91e8a64855d0d1c2b0b75ceebd57805404e40c0a7b8f1b19fdee1a53739a105a0ef27f86371ee0cf1eea69bb45eb7e1a6b1b37d56d3f31ccab803f8b420600655f4045e2428f6a3588c1d3bd5454dd4b1280394ddc7ca3f5bf90a076660e33d1df1cd29793da4d86f1371718784397a83bb949dedcbee571dea61bcc555dfd1eb5dad2a4e186f75c7140bbac43d1e35fb6e489143067418942aee0a9c18013cc396f1a319b143f31adda75e224be4cd8f8563f25a61d3c5116e1d7ebc13d3075dce0dc501c52323d6bc04aa3fb96d310261cf2b2f14d438de3d5e1f70e0b6300ab06a2fe363ce0fb70cdb12c02e318e25e50c90ddfaec64047a775e2b70d42f26d97db6f52d2fffe32d7740a88b2c9722991937a73b2b1ebc0814b2f2c629e11f0522421b62bc9dd0f3a58dad1d3d74ab3c2c2d5ba6e3e30e698bc25402962a1eed97ad3db2178c97490486106e2bf13089c476d21407f14f8e981c76ab3c69e6f0f54f140632608f8898ae2a3d62a00610cd346d7e1b210e4f8518c115795360b898a5523ec8cf49e8b25b3beddab7fe939347bdee326a54b35fc4a670fc1019995155f769b91e1c54c0929d2d6bacdb10c8b4fc401747ab91d5131aaf5ec2630dba67bb4c835ef208d13b0167b008ac17378524445d06d2e6703b634c6d2f24d6a10a03c11c6f6597c4c66c84b66e32947816fb963112fafec45664b9f31613d227af933b570ecaea0c3986f718101ed86eac115d09c82d30a36082bccd614dcf8663d0104eb10aaa3da0197cd3966c8eaaa0fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
