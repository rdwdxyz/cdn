<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f50db582d34cb1c2e1f3d0428cc53191ebdee5cea4bf3dc2881139bd38c0452dea4091a7f55d2701172c3cfce8f60ecbd254d8c55d9cc1cb4d188faa1fd7cbaf0bea440183b4b5173848c233ac233b28fe8e1442f8fad0a6ab1755c90a666b238287b124e98a273e14c93899ec6ab85c40257adaa3b51106b7a4cc97c4e1000e4f977cd6b2ec6ba19152923302a9db594dd8031d74543d2ee89d1cf12787d868f8fad05d0c53469d00da3b309b62bf0d0561a87a51ddb7f953feffb1d0ba1757c054ef43a869f02c313c18c2a935b674a57bf9a5da6a86203642454804cd5f3ef097c1a049c5fb3250be3f7c70a5c5b790859161914e9345d30a3997058643c51cbaa0ccadda029a2a79bf39c3de51b4b9b13b5bb7cc98cd743829bfe69ebefabfc6eec45260059263e476a7eb98bca693908128137183bc8c06883728a9f12a1671908c17c482271069200b1908786787eae463cad0e311f5c725d93f9c265735ffd9a6573cd2632c4099e8cdf1c2e7016d81b545afa74431131a4cdf0555c41c566037dd2f63542dc4af25b960437d63433fbf51c6ed743db9a4e135f151f595092040b55e707551a0305ba36cdaa0f8fb0759668a9dd41623a59209b6502b1d1886ea6208514f58be5c360fc6381bc24708147b7d63947dcb7c70143a5776819d88a9568d04abeb178c42c9fcc9bb1be1e3c4c13c0cc7ca3b3e4a385b09bfc7f70e0f33e63b3714226087a17945ba338b1b686a28c1761d469988436c03be7e89031713c4be3f2710a9b71a9cd2b8b5c9b53aff052b37fa9fec1273b3dcfbd5d4a03329cf12254d197b6240fe1207b8794d389e2732358d2e417eb49f9881e08eb25ab269434d32062e598b12b537f827b0854fe0fc17795c278c6d8d9526bd49847daa4a0ff98c88e3e6695c25c19774dcc413506db49bead162d985982ebcb12a50d96ee077f96271c74ce123078d481c1c72c562cebd2bb0d6e9bcfcbbd9842582b81b18bfccdf1bde3df01879038d08e19aa37803ed7c5a53b19313bcf6ef0327a9bd88c1c0eff52f2737750b4ea829edbfd40b22beb0aee92c102766bcd72ca494d7735bb9cc1c88e9137c76423ebfb74396bc0ce5c4d01c0d886fd53db88d61acab38cd4ed9bd52bf248b48c1e4e377bf9e2ac0296c675f265939a436692c95b4eb65628e33e7da5cedc3c1c7bf006e0e0d1b54f761f4d21de17edd1811169dd29a7356f2a0f0cfe3c7bbeb4b3385986109f419426d06e3d4fc51d3d31b441fb69057e0d13ec0c9972c567acf766cdea05073f9a5acbecd7bfb6daa4d58618a6deb7f55b1c296d3cb708c63c710dd6ca7825f073001b1fa5ab9430ae53c5ff1b5f8a603198d44e5cfe03dc08fbd03b833c90956613e57fb0ae27ddf46461018c52ac68496834ebc68deefe44e60edf1625dcbc1a11fe6885623f3210f1c7ea91e0e4bedef9039454e3fa97566cbe091aeebf38178c77cde6ea20813894d38841c1cf5fc35ada5144f643614447037286b45f274e25d6dec7328ea526526684178c3a56417d632ade48a8767882e9f7b3d3b0a4f6b856909e308e1621ddeb71d46c279b1f4f1da8fd0f0004700676c3f342627b8c1cfc383253770708ed500b29c44de5dee2685088ce8cafec509c12dbc5c11e9103bf861281886d6dbc8aceef5742d549e67024af463277078fbfcd378511647b0aec7db24d10c06406779669abced56c1a956fa017dff525df684266e0337ad275678c5348d3698e21b261da9b434d0d99b6c306ee94b1c73a1455cb5d3ae2a945cac306438815dcab93ae4914b23d114ab1ddab667112cf6964a4bf467be2cfca11ad5dd532e9e060a9cf2cc854ae792bad898678417a14c3d04c1e0bb1e8bf0371650daa36525eede0ec110fdd5c8919e681f4c2b7059244a17bbea6ca45b58346aac8d4b4bfd829090d898e924413a2de0813730213c1877a1cbbc21b53e66d650d20f6965a255ccd440f734c6c0962dd47b88ac3209ccccdb73146929e27f64b250bc7e0f166a025d1a232eda4dfe677a9c21c61cf34aacf21d698b97d03f96355dba9be2766f8881d4c7a94525329602be6bcd21d3b4f98e1af3969d1a81a121843126900b5664cc91ce110153d124036fa78279e5c744614ec230c0cc82607a82ff17764376be5332d48f1ca40e136cde60e6aea0412cc8c831c7e9cdb980343352bd3e7b5def4c9aca340510850f617664eebf50131a41723b53b2f312f98918b78cbe68124600f87dd56c14ad3889b796bee5c05afa38fa10f43e99647c91554391710148d4aea2a9b08018505baf411ddd3cd404d17fb51350da388ccfb1d46992794958cfb7d636742038e5a44af54d320f4d8aad822a1d98ae7743aa90b6428b05d7337108e996d40e058adb99352e83e8a84854a7272fce86a142375f60b15e2df7b5ef1156d05b8a66c7bf43a9ce41e69dbe6792d37248134c3852615ace92d2fa349e6ecdb3f9a606bf54465421db09bcdd0dc85fdb1bddeab291ad0b505279879ba8ab9d5a9dfdb4747f9293139a9ab88c019c5055639294a57c6ef63f332ec9775d4d7b7a61c011e09b8c0396202a0dc82ff4c2d319e9432744ff02bc4bf02815b61b370f194a3bde0d86ebed73acb84b8c23ce116d3f743223550c15fc382a72a09ba18fd5ec2c2e4310bf7e87271ceed9195af82fbc84a13405ddf6a15d73ccd23da901ad67ad013ad52ef5f17e74067295686ba81dee9f81cbeeee021cd8436245c1658eaab8a6934ca1c5451285152c2391bea9da0f8833b77159610600898d21994e01753bdf6b74122560ecb0a1e58fbf5a8d7c42108421b160571b74fd2f1c4967183b21fcd4eced3415b5df1cd2b7dfdf9b434db234499493fbc16f21bf2ae37e5ca6539d1edbc868760359f9983d2eb0820eb17c88cf3aedfcf33b491467c8564362b1bd821cac658b38e3562e6f1f10567c4d0e0c85cc77853cf6ec937132b7a33791207498129fe4bf53a1184718321e3488fc364cddf65461d61a856550befbf5ef242184e57f2a860bca149a5cb2b1355f46b6f20788d4a6e2ec9281fa9e9584cd4423cad37f3af5ac686abc62d54ba9851dff0d0cba14b01b63453e8dbf3084fc07ce82201e9c09ec63002913c3230a19e744c135b4f72c0216f1d67af076952d340739b550065e922b74ec73acd906d896df33820c23a174716a18960073bd9adaed4c129ec93e5fcdcfd90ae30a39221dbdf6a01093898f99a317f4bb60edbcf6766d5c3ff31c0824c32503b3ef5cd3b9a0d60f61dc70a49876d22f4f3b31408ad1b0c8e3bf29e48b6d48fd0cce4ebe7d53cc8339b77d07b8540b0eb5c789cb061ee31f254a32e08c6f831d13e80eed8fa855dd1def4a56546e448fb37235f813079a7feae4eb58814bd6e465b8e694be8b02ef41cd8a8675c22b04d1a92f499be98780a635a0a0afaa807522b7ac4d11f1b638c8c94d5831bc983ab950f7be44ff20af5d65c680b90312e2884acfd6d5e79656445833598cf91b1d1fd50f5fbd2235b56cb0cc42fe52fedadc596958a9b36e69fe0b97913cac02e4dc8e4206f0052f0f5818f873ee762769cc9fc775a86ba2d0ae8c9706ccc82b5948a371c79e24485d48eea9fb9fc7e0f20826f52b5701fc45dda29a4202711d7387426f29d1df7566a5d1c3dc984dbeabbf9d007abc4957fe74928535bd26455bda341d8b257f629cce3940c15c159a81cd74c58182024263758d3e7f670091a840544eb6009851d4fa2bb526f597579bdd0c0a1f87660c3c9f772b23df03c183a0cc67d126225bb04a63d6623a2c7ebc685f702d7f3e72d99fd321a6c2288512ede08c187a1d56586d06b296186413c0970c29e883dc8119bda0393a6138b58859aa7d3984e240233ab3ec9038e4d84e619bc7c6972032e13af52f449483aa6919894205353d6a9ce18c90431aad2bdf74fb1bf2867b90ae890d76f5befbe3a5bb19450ab86de3396507f925f9dbc13c4574f9a9428c45ff8d45cd62d56d80e18517263992e8c664ae814d85743fe0dceaca3e79ddba5615882b3aa94fabe439c4777c6fe39073a00e450f7ffc74f2f6ea993c5a25f229810b3fd39708fe3d6ca84dface3855a317efa49323f59c7b680516f1cf49c405b61a78943862d2c2dd5bd64a50b6619c759804d4b9db0c748f0c58f408551847c866483032e5f3f341a3fd3708f88271b55a2582d0389d355d9a12a6a53638cd089fc84e52997c0e4d1ec6d1f64f7b2e2fc8ad8194ef9ed4116c3739c074a1470f5d28345485d32d70bd1074e6afa285c5c15b1d44ddfd28211f62fc1cf3a3a80035a63117c0bb4da094bdbd4ba704de1087eba33299c26006ee6f9ba973a27b3d21241204a04ece6d181eaa2234841345fa513d556dfe114ffd7b0711cb942466d9f6e55f989ca45026a0ac888c3955686def3fccdb2d14e8780da925618c0c4ae49240452e126abf76ae4a5526c3bff4bc63fa006cede0869e0fa66f96bcc4acf2d46599f8ab1b00982be616d18aad0cc74cfd5439a26bc5b0a9f721000b0d676420de26594a7076d5c3c0781904e5f6d38ffd761d5e2ad2ab92f5ba320ea941ee19d442dcaf6dbde93c6f0d3dbea6b52b942e5fc7f683337c3ad8bf1fe9c72d74d153ac6decf39ad51f2a294a717bd255221cc7abd38d83a835d29a98cf0f9607551d455a730472c99f07099abca46b76e2819203279ff1f78b720dd166a659f3de3cf1d3045dfe8fc942c5b713172523077378ce426f16d8d22f6cbb1baa1e0a861bf786b6dcbcb4ebfcde968b097a062646ddeda2ba9e02ef497f83900a736d78728b695cb34a9fcb94589d02edc74484ed67cc81d73de39bfb46ae3b7f3c3d334865bd14ef5399b90912800acf1ac7c4b514918e9e985a34be49b0df830424a8dd3424de79941d681f2e3187449b2e5141d8b217352ea32374ed2c2cb2f04eadb34bf071e429d4a3400c7b80e3b23a08df2f7bade3bc207efae9e15a78b2b2f063a9b7750b3e2fab66b47c79d33404fbf5ed8ebc992f534c620aa1c43d3b69dd624f11a371ab867fc2999745c96f9d3c19057a9d6628dcdd5a72dd08364d8f600e128a595e278277d37d1171c6cb6659b997252a2961c0a51b51d62adb49cce62bb1d69f5933665f560631ad250b88f75578a206ba86da29af83335b351929be6966df00655a8957dd5268d14b362977b4b8ccf761d2dba514b2f40096a27f8fea6e30c3a21c21b30a0e7b66a8271f96d1ed76ac3a9f19c820b8969ab54254dd4020f9ce34d0e98291724232fdc5cdfb1d78200b0839f650a07a2b96e679dcee2b289a79776a41c4b3667c8026532e64a5f1abf24200febe9ddb60e6deb60a44841e78bdb46a737cf241632e6414c512a40411ced6d03546569f9630a2eff85fbc135192158dc36fc581d07d3f3aca5ae57165d8fb39bf33973ef2f48a7434533f0e5e39eae13ea5b95763444929292e179465294af444a4e79c65377573c89c4b14ee73b459475342a0ddb8d9fe89f52763884075177bfdff48c19709aef48461f7747911a9e5d0f064cf2fe16c29cacb30f3f7d0ec408cc39cbd98cbc3347c33f219a3d43ab475fd4c850930914697a39e902d097756a95b99c1e3e67be39e4517ad7a75bb51eedabc00e36ab3ecee3348230d426492766d82a3b5ad2e262e28beeafb549485c375bfb7ee345e86d201b3b6bef1921a8f57a6c9e4a836c465d39081a6811e0ecd3611b326dbeea3b33ed95312ec8c7ad8b301f2e31353ea0994674d8f233abcae370739cc0e37e0afe0eeb8febcabf3e4cd889dc5bf9e3501244ffc63ec34134cc657abff63716aea9ade10705b1b393804dad64a4fc513324a588c5aeb8a2959207ef3fda76ff80fe6a1ccda55a4c78d8557e1765707baf89c1896b8a2949665a35111116051d07d4fc6bbc0454e8ca4f2fe3eccb6358e481b88bf679bb176df94c728f4f6778b4e3892c7922fec6617082a8ac1675177adc9e26e60d85247353d65b322e7fd8bcee669da5289973e8e363791e55e4fd24f78d828291bf923b5d8bfcf418fa2b478f2904a7f38e74811e8b96e9bf2dc1536c53f807e64f2d6856ca4b39b10dba28ed3a06f04dfd512489db9987335f5b0096ab09167cb8cb23f060668360646d89950e864658d6ffa5ec16f51146dbd08c5b1998cc4c2fadf9f33aac0095d4db557e836d9048cfecea9bfaada637c518e73ed4a85617962683e0887185f52acce1c92a1c87736d9acc8a69c2a9358b140072782e616f4fbbb977da01da5210d859d621a5497234506a32e91f9608bd2bea17510730bdc0d2ebe4d19e9e98beebc4815d24aacf9aec582ad2a1032e907ce222acc65460dd46951f04394ddf98b8e4501efd831923b64367c03511808592a51d31e98e349ed1f5967aad5b43eb015fea1cfe6334c4de737d0705d096a48bb2aa2f5bcc3769bb6fb0165ad73dff7a03660774d2747d4fa66df2b39faafc5eb981b961ce4ab3598004187f1799a9bb7f59541d219eeeb560f0175b508da31196457840dda607cbcdd855c06f4438a59a61c7c4339b24d3869ae06a02737766d386eec7661e5a5a49551ec6573c70aad5abf9ec4a59547b8ab83dcb827ca7229735968e20cb20c5e093778e29883e23284883c71a1eecf970bd55899617d2a50bff3cee2bdf7238497a47f1b36164eff067b1e4004654d7f5335d424bdf2c7a5c4f6f167d47320e842e79cce6f7b169779e19b92c92ba88260b7d8b1d6be2ad26e23fba62ec5e03b0b65beee3ac7f983f821ff31851f1b9b5a9d4117b08a7af937931b610790482682eafdbe6720afc7cc5b5dd1798aba003529d7d82238f6f75a9379fbf51cfbb228099362c838da1601d10c1ae2c9de9cb46ab898eb9f8644697010e05a6c61ff0ddd8f10fd9cff12f92b21640c3dc28d599dd04246b1dba6ab74828d6af24fd4d872d3c966175c8c23202ad1ed0eb2ea74b60d4cbe6dd5cad77b7c6b71a3b87936669c0dc8392069f425a8e2c77a74d34de0d64ae353824bc29c85a2c5b028ede2434185a231000333c2e4c5b1f2382824cbe20742559c474032af13a81372c3bf4eb6c21aae54cf654bdb95630bc509da5028c57ebca831c8125de4c4ea7dfde7ca1f8333c32d7e461850ba26d7b5b398afc33022e3d3c81d646b7df05167bf50fc94cf91c10955082b9e9a967eb71ba4bf6bc64032d14645b89516ac05c40171b565ac2e4619f4d8a6972e56e40be0cddd19e2fed7826021790953a62dcbdec6ab146755c1293e0ccbbbca223c42fa1049f9a3ca97a85e0fcebc37347b500147839f517f5e8a703920f7a15b85058d064d0e3fd8ba0ba927286be8f2327d8976062770ab62196e20293709b9d2324554e96036c2f9f497d134c8ef768d9f1fa10202d74a20f1aa2d789792bbd387b80de670a4eee1806ea9237afad54290103963ff87b604da2bd61c029efad58a821ab28560e2560d2fde4b1402572501623f537cfaab146505b79076308a34e40ccd7a961d9d6007feceefef0283062c600d19bcdff53f241f62a3a317138b0cbeb967ce920201dcac9140d7deb38967350d18a538504938d90911b3e2fad01bdbcebeae315738ada3ac11d021350e8716790e57972ba89a53fb139c59ecdfcffe37e526b464dc3f5532170f0902a15bf28a298bfc600070738a36292c105a86697740c8d2a3913d0b532dfa9435ad39a33131ed529019cf358db68b4f0a2a12ae8ab39eaef8a68ef4aca62ba335cbba4b82ae873357e134653a15f43fcf98464b62589301da2c6b94e56b11c577d77920be2ebb6708ca2e9e2b0ddc713772bde72a48679e2b669693ed0310cfc42fe86c271c0656b5752de512d00d6c32074da0a47814ae06a2e26d95b16bc6f3f8811205f344c047089978791e180bbaf897ce68757aedd09f7f8603230baad906a7a07e3f73faa0c2f31724f547ff8324dadb733a94633bf081459b9dcc6568f6ebc3577872cebd11890fdaa986899f395a3e6e170ca02a89802843473607ceeb8da86bd0464a8f8617672a666c854dbd76a72ee066e9eeadeebec83a9b88353ecd3a230aa0b27070cff44571aa20d7c10b7601fdd35e616f70935be7330d6c71a7ae610fce0d3a50f2a7dd7de96343a40aaf88c24da52e7f63d356bbae143314d16482c4c41c9bf53497eb5fdaaffdf23cd743ea354b2c81cc26cf80d8d750e457f04e3fa0cf8b35597f023ba83976231fb1640a4a3e9d13fb8a513c65f1d046d9c26d7e1da76738e00abdfd035d2971783a80f0c87f38f6131b488482aa87d8134d6ce108e80e89255ea851a1d410794ea73a1e40a6851b8682074ddda4150c7186c2a2a65ed2f60a1ff9c84f9c9055e28292ad2d7db182531557613d95739c2c666927e5ad9d6584875ebf9074d4d52a00afd71188a4142953d0b44c38770b0ce60ac6ea446bf6fe73ef7d0ec166a2cc4661d6adcb003fba880c754132ed330febac765f5e3c9a2147458d8f60090e79988f0647d915bdf88ee4dfd024e10c81d2a6e8a1523e139f486be62b2d5e200feaee8d075552723706d8903411bd05bf3a803133a69e2c7c369badf473dea4d4ee4a6b33680d703a74e9266eb88bcf53bd1047d1f74fe97f1ae6088888e95b4abdb9c58a267c1401bd5e12f46ff6b0f2da011a455280739ad41d916f4b21db2c9a8fdf81ef129aa9497012c131c02d8d940d02326ecfdef5e1923400ec301e771210826a10974e72abc9ce20fb07b566f5844989358a8263bac90822368cf72f8c78222766af0e3e8f31ab3c1acb81825a30157377e79bf0bc0d85e3fb6611877336679d502cd858cba501699dd3f640c6676e0736f792e91bf4747b5deab9c5291223c3310a6ae03de67d0381e3c5ec50da0f357f4b95cf512da07ae6520fd78fa109f44322be6d8434090ee9bac0f940aa352dca48cd806b417d714aa5046bb6dc8bfdba7033820504a2db4a7692584c7e4bbddd21e5e5603ee329db61143e4744ca2e341bbd1d90fa03a57b84d0efb90027e6b0c9b7e95f810cff69b23f601ade5ffac51a3dfb72c6d4ec97e6c6143d2294fbcf890d6cc8829eb2f690489e140bb76e22b3e39515a564fb7c908fdd7a03d38fdecbacf83c5ac89af499eb9bf992decb453fb516f32c1c405c2ee91c4ef227bea2a69bf19a2359df260b27a8d1c6cd6e3fa6d06fa3db8bc4460a509361b9963a747f51c6f6ddb424e963fee2798bdf51f9b07bfdaed925c5dcfd59dc3f815db02d91aa318e664a7e5b1dd8204f98aa00b601e16a8a7877a9ef0abfcbc2bd91f87bc5f7029b16cb2cc3288803179ce3a3efc3173f5f7b32b82d53283dd2f79974eb3a0935f14f7b3c536c8d845e67c9ef161b14e38da7faca9708797cd8524fd529f50e799e45cb5cc0aa93aacdd9530907dd6abc69eeb144aec007c38014826f4a124606e2d8501f93f2471505c4214b8b321c5c8367de374e460266a92112d5ab83eb8c55f662d2d041b8128010699453447d575ead56225e0e83ff64331c19a34058b72289a6776a2d26c56d7504068629147ebc485e81eeff6c315e2eced981117816995e684238bf4dd7a64954f711def3422fa05db466ab973f1ff3dc5bf30ddb0f2dc7e667efd03e742b763fe9fc8b139f1d6a25749723718dad6eaaf4213fed7940d8ebe9594048e4af1c268ed8159295e1a24aaa6ab109b104b1c08ad2876914bf49a9cd4765046466d99fd46074a786c4e6a3aa876bba84462721910ea11d2dd78c83e6f51da2e9b253333592ba1ad6f1f751dba706ab7a2871ab8a46b9519f3e9400880b684d5db8f174a54073b3dece604bb787414218cb699747a054086211bd4f7da30d5340a58a84034a2549cb055399b6e21fcd959cbfa03440c191b6f07ed6ea7af33652543b8db613d4cf45ff58fa6c1366e0289d9f0357bd35450eed9557536cb10cb0deb1b83dd3887d63bfc22bba903fedb577745ae4678d287a95450c50d5805d4c270a2c98728885f617c68ffed19616abcb57e6f42c17dd3fa85e969dd2e1b8c0f7e1061909505e7f0d6aa9da0f84235029e92dedf81c56b0f282a1fe4fbdc4692b5a8d043dcf176fe7768f023ad203092da66dcc692431487a872debf4bf89cdbdc37d467c33436f8c83961ab1dbc9be731bc8a6cdd7ef745bb735823345aa4c5e4ba8b26c63f91494aa8478a1081e8e78ab44f40bd477f4a49a3f98c9d4d32ddaf49fa3a6841d1cf9e0ce3d936ba18b4949a2e9082de526d0ef9bab472d8333c8f936f50e79e7fd3728fa2b20975ef56b805ec3bf4cec8ddc0a95de26f78bfee17ff5f7ccaa00efb681120b64a5872e65628a64ce8b101ba193057c758cd28474fc5c9ccc3b2584ab32c6d978d091fce4882f27aea9c1dfe7448fe30a0136d552f3109c3b7ceada3ab0cef03f0d541f911d12ac2ebf043456de9a0baedf2318a80c5591e2189cdd5cbd064fd4b1f8a141f41e9877ac5e9f7f3d23d779c1888d7eb3e9cb76e2ca40df8fcb65febd4808639cf73840f610c1639f738b91772ec3cbb8e728c019972ebe5eab89600a2e9e27e3295f6761d076dacff5bd275af63a7aa8136a252b7a7aeb5f280b4017cc5f670d17d271da0a032f0200efd5cdd427dc7076bd0c6ebac65c2896130f6eeb2441d76ad33f546976c0ca884ede5e1f70662e466a304e1464b2c403dc3de89b53eafd387ce0de7d8678781e67d4a6dbf8fed00e35f4301a848b92492cf2c4fcbaa61eff4769d6f0fb3f64c78e45b1b4a3b9244be80209a4d4f6834bf64c72a0ba29bb1df2324fb999ea59beb606307e62f937172d3c5b4beae25d356167ec1f0a2dcf6c35a321148d22c27e8b8bb45c1586262d47e6f5af38bb17391f0eb1cb50c755cfdaeb657e4e9b22afd2978eb3ec89cb98124134e06633cc623e3cfbb2cd7f35f5b4b2975b8a77ee7f94c872300d9e96ff1689e10148f09aee8c97bfc7ea9fde30cd6d2ea682b98ad628241be036dc06f54d5cec20dd99a64dd9f7ffaf7507dab6f3bea655bd4853e8786e85261b025aa0ed5d0b0c97d8cd07084c0c553e469644cdf36f975d883d2fd9bd366f7ea3a7adb6fcbbe0e1b39f4e1fc1add4f65b55eb92ea3ddbe78a9c381efbf476acc2f25f19080d6e3f2ce28898839c58d9b9450125af9c7e3c36879b0fab0eca6f60d335dcfc96c21f2566138f092118ceb21c0dad93b69e1d625bb5b9faff1517c68ac8fbe6a78aeffa0a7530fa55ee7c5f4fc697e7beb9f67f2b9f1d08dffe25eaf92e534a11e55b04df32ce3fc12ed2c267e6a24b7e3dae276b37780bc755234b660bb03018653e2da25aa716c77e05cff3747a1d358d97fc9dce49039e5a80bd658549dd8667d4c1d40d8dfcb4b05d373a46e779fa08fc33bca3255c6b576dadc58c642a3af16e867e1206dd412eabd4db155dfc029c0425bc2ffb1f1beb953d356baaf207262004b12262a851f3b4e44a08265a2d878d7ce8e6b45354fb6369b6048a5593d3e48726d3ffc72ee72c3680515b92f1605e92180338310e6cccdb05e0ce2676a6c2020ea74ac8f7a0b554d29fb5e6fa246a470623e6cfca4aa459fa6844d63a78e78cf16dbebd3619a99a3c8c27b25ad2c6447dc46fe25d6048b99fc85c896ba8e114343d932fd81ebecbbbb487839a0cae70a7f4e52dc9f57ea3798e0cddc48ec3842a1c33ceefa36109eab59709b993a7f4b44bbc09b80259ad8019bc71d32deb4662053d0796cb954d0f21d575ac6b635c8b6f027f5008aeb4027edca0f9169e2a38876cfa0eeae73fb92c02df5deaab80fb1b56053f20505cee97d20f75378896c4b7595f49777ee1b14fd40ae76e124189ac01bdd53342e42b77200b09b8eea3403f46d98934aaf6c8dab7e614e632459f99ecdd1d97b3e16336be802fc1bc295dc159f1cef13e9310be3849196c57c162a8e1280d57a73444185b63ed2f890ac65bd826d703c47c9d76c3f7ba6b30a094453c0e2d7b1a620794efdb306bef5e1e92d2456a53c45cc58f3484e9e4add3167f801e854b21c64f6a9ff26b515ac5594f4bcc1fcec059678af002921762af04a6a6833e60aefa4074878245b5340a0963daad3703cb4543337173b16e73cff557678a5585555d879fb76e58ead7733667d8dc8b42b7287f9be34d379b7a8f7404d8cfc55df6b314ff1defe92d3bbfe88464a80fc864bad0be353c4eef6720f2acb2f85d98549b35c35193eb3168bcd96787f0cb97cdc5ee11de52ca06b4ccaef2024d8e77b14ea441063d7f89c1a82c33b7f587aa3ed849fde18dd5e510a9e987f6be86c9119b69b1dcc3237913d449a7b363bca051671f23cb15cf1b7c3451ea5d6c0ce7764c56ec026228daef20a87eeb6c5b8d57622e5631ea82415c81759b1d7cf7b11fb30e3af78b259290fb1e927deded2f7afcde9630a3449bfbe98dff541f3f6486bff950accaddae837b75c5896249e9d7ee16c7d397da9b87bf9564d42ffd3e1e36bc7529fbc33062db8169a2c20a3935cd18b2da05ecc4da88dc44a0cc965dbcc937703056d63a04b328214b93d8ae49ee4aa5832400127b7858632aae97317351f8cfc008816d27480298a1bbfcc16516eedd8184d9a9fa1bbdd4fbe27203650a37f36042b229db944a16b298e252d50ef9280f83be386d7d4b2ea6fb65c9a973a66fae4a064b0be0fcd667e73621e23e9259aa7b994034ee6b7ad74b9ef93f242c013d513d87a769a2dc92c2edb951063f51d84476f437d8988845f33217a9895a32bd7aaa9b7723f495db165dd720269b36146125c70ffea1e85bc437652a827c3b919c51e2b6c2d4edc489e08310ce5d24a5171be2c6c16a0b8a759573df28688a3dcf55000b5eb2f8c2e3f230c7891cd42906102c68feb70dbf3f229326ea3d2f2ffbd33b1141386d72fb6a6bab2700376e080c97f58d89140a4775088c931028c94fdda5b75844f839c14d54f13e29f5b541a8cd19217d1856b70d0fc5b2ef555f8180e2696c51e903a7a0ba26efd9a0fd55ed75544205af8b9fc8ff46652817f602f3f1b3b36fdfe1f02a0e1d72327b69553c3e7db3c52c45277014867c9ddfdc0329ffc737877dc95efd127480fa421bd10bf3bdc77fbfd2b16cc5ae9311342d2223ca1eb4e9fa3f93a3e9b2a378cf5619be39a2a18b0f013ab845e7474410e87b907093399f51c913f9586de415495c5e740e46090cf9b9ec5ce17c24552adb95766af5ee578e77148c9394b7a31b827bb85e3fb25946bc1935b386dc895dc2b8dc4298a990b995db9cbac601a225d924338a42df1388f79dd738dcfae67f989bab046bfe4080ac527e85567415585888b5f51aab8777274864f1bd027cc747a022e9564bf516540943d36835085d2c7b8accfdd6b92281d389f5cbacd81e4221245e768ec0c6a07cfd02b11cae8e8fcc381445ceb5a4f8ba303343d544babcdb6162f08b13738a806ff5d15b42295fe28db051d791fc5361a5161bbae4cfd5e82d3bb443cf1f9163440fe38325d0c2b9c9195de2e81b04cd4c7270ba7c00492536804f44017c4f8377cff5009de5e8c7d967722195cbbdb7090e5716f0fc1543ea6b594517247fd11bd039308acafae5f5d9879c8c45e7dd01abc90199dbd134b2ffcfeac72cac19c898ae9a3ef8cca9817777d3c2268150af63510195b329d61d565728672b9e19e594fa6fb26f67df235166d0d08549121bb27b7439a5e08174f5f1e92bffd0747ac93b405b8cdcfef51d5d667596bb1d5e77ab90f0ae6e7266041eaa7a59a248f6d31da75a1ad261a783aeea6b77f4096513a0eca792ffe3a969da633ad1df094086f9ba17556e0d167e564146d708d38b537ea2edaec7f631924a727cbd8fc67668d2496914e80be98e22d29c94ec42a5828cb16db428365725a41c3c4a9fc08cc5130afb40993521e96dbf4960f3439ed632e07f9fc5f21490fade018891248906db941437d1177f95572a90d4f0a8d3bb68796d6d86e9450367bfbfd85fa57464ad9169324a204f4a334704ce91d778b97009c2b79b046989626181cf8f8d737b6ad4912326080db17294f26b2ca923fcc9791eb0bb104dabf427d7aafc4a3642ca9c413f7d21f0d2753dbe7527975f8733039794b2f985c06e125a4abd0e2b1d096fcc6dc4d485b3b3a0d67c56da6b089b377f8beaf44a315bd9d5db85bb9203750298f127a61d4f533c3e5837ac28092fb47c0efb4a53f67cf7af39ab8ce743902a7db2495f04563d66b3ec25d42422b82769edf2d393934c0f43949c5ddd45aa6e5490b15b3c8f6b8710cd23cd73a9f3b991a0ea6c47a6ecaea302b58d31c5d9f37b30ff9e99c98faaf72f6fa4d69754b78f426b8fb64aed5c2801fa30087ec187dac4d19b8afc2cff60eaa3a09a6459489a090c83d8024ddc7dc2bb948d72f13b1fac75d6d1dbbc5aad82a13280e4cca96bc4e5bc2af6ea5c666a7720aeafe02a54fd750f014b568c57965a2612b650079e66d822f32fc1ed6f780a9ca0eddd49fcb386886342453fc540a07a552c7529b545de44c949d72e2740ee447451a6f2d72a477ba0981cb5dd8c3a77fae3fa4420c0d49c9a110fa3776db307b3d1456544ca68e2e5cd2ce07650095a3dc915b84d5a6242ca4321b3ee047ee718e0aea8ac5ed2dea4106047ca818933c3ce55b687a786e9b7da55469ce3f30252f369a565f99ddf14595bf4fd344ce9cc48be1101fe04f7305799f52c074b6dac3cc76e679a04b0f02d82984490996d5e289d77439d5f695945f9ec2a816b88f5e32cc2804a62219913efb84e6012d086ab9a2279022bca564cedbec1767768d8ca4a19bf18a9e776c43afae0f392fa15bc0a84505259131efe3a19cc8e01890847edd746468ce311e2f9db036e632ba002d0c75aae1c3078f86193ca934cab089b9cc6cd20c5f6db27dffd43ae5ea190f8040e7409783a013881e841b7ea071ec3bcc388e727be234fa8ee27eaf288376120ad2c98b7d6904abc7aae8eff9fa01a6ce9d648c18435455e1697c3afe1cc8d3a10d426abc86261b69a203c6efea70556c3c5496a045b8c0e50ea3af968c1a943cc7b15d96c95e0e5e750809dee148064cae385f74aeec63616c79eb032b2f10b46532718ef92a9e1ac644255160bf7605419fbec0854d3719a5a30c28cdbc3b3967ae7245124d6930e245db2ad507762c8a7218fb75a726c761bf4f9df8fb2425e858b2ae201bd4f8194403c0ff06f7fa979262022c2deafdd2f2097a4f9b658707534886dfa51ff654880f78225a557708df241488ddda5aa07d5952db7a8e84b78b16c73823a3bd135bb86a5bafe24fe64e58ad1e9d8acf199c7da0e90daaa125e6f6b52110223a0e7f585f67c9d03ea775cc587919ead02b99fbabc4fef1145df1de0cd638ed9dca6eabd1eb8dc90e67725000d38484f21b67a0d8dd76a242f280ed2ab182cf03dd025945450351646da03bf6f52b876167ab21435c304b654edf5ce2997517f7746f2d6290b49191ddce02c66bc7224cdadf5a81eb28573fb9bf194b538a0053b7900396a5f5aac6eae1fb79e8c05d00a83a250b4dfe1c20b1632ed493440c3b338ef1f0a213badc0524606816f33bfb85129ecc30cb2d481f830991230ffea72313dcb1a10d6607df672ec91f0afb0b93bf09805df352560e5b921d871d45e9f8dbb28dcc017e8e6c6a76e024ca680b2c9e9edf0bbe8611a2023c464d0b4f07ec7992e9a3354e29dd1b5169efeb545a8ec5c3b3531443e4df0804ada7552f50f576227c269f3951adb04a2b5462247fa331f607eef3f86c8dfa7560e4a76965a9d41602dd5fbb6d1bb1eea266207f5f834ad1697652844fe6f709b7d148aaef0c72c50630d6ab8246587f79422dc866042f94793b17a1b261b81e019bf889db1a32ae72dc3def12d9d3f32b6b52ade68abf46d416b325e1e2bb9339afac9c8fe9bbce139a7e77c31a00fabbab24e4a8806107fbd10415c92293aa7313357dc4ecdc07af0922661b03b2e2b2717f44ecac6b3802e46c814551921374527b55895e488c9a2050451bc330e0aaa0b00c8b47fb7fa86e6421d377ebf7b0f5b8fc4085fad45ec01dec265776ea8fc618ca0398e4dd49a4c262b427db31028cd3096d834c41e0ef7c495f727f3516784026e5a3c4cf69404064ad7416fb1f89e038b2526389eab413f42e1cb3644347c035c411a413244e0b4885131ec6e1563edb079708171451e5c6ab4b71f4727fa831378508c212ade61f3054dbde751f58b35ca260f5854bfa886e33dd801e17b01e59217486577ff0a8802a1b7473db6747d28dacee6cc69a47c3a80d99595cb0e2616690cc32f16d64e086ca66bbd3410f02cad185f11ac3beffae61b24426229bb5b25c8a0b91e8ae6b990758803a518b911778ef5f1b0482bc5dab3fe9ac48bde917e09c1d238bff5affc5b26f337a7d51d2e7586a2c14889ffba74262dc44396136a85462d4aabc0449a75a0b7a792e8e72a7386ea07c7b7a45ba3589e9bf24f228b6a75730ca0f04bcdc80da09ab6b2f3e13366efc5c9ec6a80a69f56025e4ad8d76bf27c1406eb1e83eaf18ad41b9723d80e8b62575f995440604db97d8e927af0b4775bb7aadab7adf7110cf2bb3ee65cd99cc814a1747478e465e40f4e421be72eee54d6a4bb13ab05af5b725590f008840eff2683b5fbd65cf0e348c20cecb39feda141f6bef2c339f01cfece69d07c7a420f32ef1d515d63d4e7de14adbe2e296ef846671b11ad3edb174007fcc68785a6117d1ff504d1a450fddee78b84d890e255d2c52d5e665a1611adf53f8e42775060e7ab49e37afe29c8173f67e8cd489c53e52c1cb14f0ed09352310e0ddff9c1c0dca1c12975468ad47bf45c962bcdadd6fd922545e64428bffa7d6844f80012307bc8a938f66c24edc1a83e9d9ac53853fd935dd9ee4c64093644bf96c1eda2a521e5d85a80ffe879b7113c4d3af942098dc22b13373f748c463420a9a13a952a1004af17638c46d7a263fb039d45529d83b9ff1155ad985afc270a24b8eb95870fadff8804a47750562bc4e13fd7759ffb0364accac7dbc698b6e20f10857b17f5da3f9275907a3dba5acd2165cf2f8d97df6ce5a1d1e78edf84c62a7c8f2acfa3d7ce098cbf679ee0402750a8091d526420e92118e340d66bdb71efaa2e5de5ed0262fd2b55e2da2dc2129a7c4fba338a11449e5179a00fc8a5951932779c815c3f0580a621fb7d4cf4932c47fe486b063595dc4d997152d5237c18cfcb5b22be70fc61466261402ca0ea78a3d6eee501041231565a100f1b7cf1f69fa6dcd8f66a6d26ff244a8e5f5063fca7216c2da8aea0af064f2b9583531971dc89a8e2a4ee2c7624a6994ac94e20d639b9f27dcf352bbd12362ed6b39e89ba13ca1d3b4e3f6ecb09860a8551a619384c9e3f9dda33ba1086e4a3f5ffda44e8ee171fb56157a751b3415bcc28f90c083510c19e02b2ee5cbb96764be06b2918feab58aaf55be133748fc266f0dc02d557e7a09344fad87860c3348e3ab4c149d1092935cfe5b49af9412392cd3dce9235133fd9d5170fdf256c85a888fa7a9e53d10289dea029bf178dbaded5c8713ce0a7c0bb11fdc0850deaf2548ebdf76da507b17000991cf12b9d4ba36d246ea1e7dbee8ce9b960c1f32eafe592733880d473abfac1a3020f63bddefcfcb58bf112cd7d8bb8d33d4d533425baa72c096bab844583c8feb9e98e9a26dd089bbeb6462bc5f250056df5fbda7f29a558bcb887e8ab6cd19ad7cc51ec8eba0aede3995f7ffb5f92500d502b105efede7c9575dcd55317a5b3f528f6f89e88998a6dccb13d4d8125aaffdadce6531fd8970153cec91eb3493da4c125faaa1693377e317950dfc1e0040c0a59058acc03f7f6f892d7f50b740a05c31489877acd42540215ce20684fcec9a877d95ada7ee1a25c2f81b1b7f386a83232e3a97efff15c50f1230ddddf4ee49b7148eaac05fce1fa689a33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
