<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"905123c25e254bf0931bddc5cfccc9e0ed81121fd9846ab6a6228228f14fd41fd60b81a1258a27fc0b024015b85d50d31ca548de17838c83962762404df06c0746ade43c8886b6f19df1715170858b78ef63d3da87d15477d53bcbb61aa9b3ab4817124fc03a9299d50ff05e35f7bfb69d9a5b743e43a8ad6129fb85265a0a53306cb459d5de7b7cc8023607a00095baf1cda892eea11181f57774dc4c16a885eb1d59f1619732fe68454ae1c196863708dd3721c2375144bd6b6c0dcd35cb844a9b13ee8883bf1648d2ac2ddbb609abff1a745c4e20b5e271b443f60f073cebf531d066f2637b0c4842bd56e885d2389aa13da74671e733c9655cd4dad728a44771fe1305ef481c45c0d302489bb77cd714ad50a9816841de11a42658a22f9dd65780b33b5cd72dbfb43258789d4f7d32a7f95c29a94996f6cb326f1f33579e3c100320b42afae8109a6aa33f321c4135a1cbeb70fa71183d1056bf634ace99009a1c64bd8094763e3c4cdb7e8224cd4163c21900f60bceb183365ebe841ce338ff4921affb04717146b5f8c514cf23f9b5f35a62e091f2dfa09b3b2a48f837dfa6074c8b0af446fe9a6679e810baa47da1619057ab026503085ff917ba6bde4a440f341a77c2dc84a3331c9b4b27ebce8f011925c895735cdf48ed2af9b7c48eb8a2fbe906729229f8fe0da3834f6fbbcc832e00276eacc0606723bcd194badc40be710e478f371b2da4b362cb6e5da72f596d398937b7f8711df9b999f8947363380f49186bdefbddd8bf1ae635196a7fb116657fa2ba425409a2c81e80524a9fc1b86d89159e745377e0db5283366a19c195012e23b7753949cd3fc743a50867ac6221d0f40eeb3500f86828d4bce0848a4af9f35ba587885897171432519a2a3d65b3145ca4ed7b009c71465db784a24c8b954b48e7974aeebadb13583be64292dfac4fcf0eb9851b9f5f65a8fb55e4e3c79378e0a51e2214c70fb7e06be43585e68864536bc217d2e467a54d532b785877b0481cd4a982e087ed340d801f74a1528bcecf6326862bc634855407adb24b3581a5af9550b9fcf7ae059f5151b16c7936f17b5de25aa219116c1d7b9c8acf547691682086f98fd63260f91b1e1b8f63f6f924868e5273fd1e161434478df5e7f3ba77ed7389eaaa016d83048671a4f712dec10d4f582e7a7b8df7500b5e46fd754bc1d0196db8b5a822405485f5e7fa40dc09a8ae0dd8ec836d3e93a788986e620a551ae7224a7761af6f4b7e0249e7d89b94d7d19a70b0b4c5b00cd6b93e86285c2af76a67eade359107d8e756ca11324e21102814cd3830cc46ee86cfaba6957118d7f78461d7ccbb58f9295304c9b6be80a11467cc3f23bbf154be32e4ce10c845a717a74828c6921f18063de47602e9680775bf3035f2a4791d60f2a9afa3e4186036ac0cab669f90be59ec9b3b5de10becfc8acc40a4e648a645547e38e1a0ccd911e434a69194ac39e311c4ecf3e2df714b6576bf4e897286255c7278181506f7b5130fb3a926016b70c456157b8214117adb0cf3eddd457af0eef6b5388dfc4b9378038a3e55467301cad75ee33b5da3faaefb1102e6805cdb9d334a6e7e15e1c8c29c455e0cafdf291ce3b2c5d5ee7010f1d26bf525a04d9e5ff97b2eeef24833e3692886f6ce0d6184402effc18ee5e1537975cef7f7ee77446d9ecfffa04f4134cd6d0125abde6795284fcaf611bde632b2a69fc8747eb45c4de49465a8fbcc8a8a98b022ffa5be3190217180cff584494ba98bc1fbee33f9e4c60a799b6204a0309d67326dcf9a760e2efaa44916c158f3f9788c0eb87f3705f52e5da73caa7e935f0efdc5125c3ac376efaae96256dc69e07b99b277588588dd9c56824d8ad486a1dcf8d552fe6d693a2984105a521611fd6283683ae6b6fc90000e0b92c34e45beb75759e135f46a5af068d32768d55d015b69148157bd28a9461e0f5b1622f9b468f512ac0040ce8997568db86166d7bf1454b8f925282f48c1cc885e918fe5d03fa1640e4fcbfe7c5f5999daed0a589783d7c54c96c12ab227fe568a2fccd193000ddd290015bce2ee662dbc3233ef4486c73a17f776c0939d61e2ce3cc1295ba3c203205ae600205b41d01196401605236e002403f48fc01d0e2730156e9cdf7f3c4ae9472163a55a485d3406b0cdea6f516935ade505e19e4bb61aa4436e86eb04a22a457ac41fbd993134ba448c66a909828146bf7b25f59dc1655977a76618f6a61fd493eda61463557ee8a25c7b86ece8ee2863aa655cded5c7090fb057f9a8340d51982a76433bab1debf63b90e40f2763f94d28ffd1a880026decbd515e0aae1d1c1a4ff1499ebb1571924e9a03c8bc5aaf961f4611a8a5d8cfb23373b781d3b4c16f9fe0063a5fcc6673a82f20fe5540c4ea84ab565cb5d0213dca6ad0ec29f41b38b1830026eb464e98cb6ba384282e571f888185537016d08eb611523dae3b14988037cafb3675cb02090e67f302457dd2b6cb9fcbb9937eb22d3e4000b890d6d98e5f032b5f6bd3c4f8ab7a895a8e6a7307405fb8eb21535db66f35d8d175d14c880a06db6d3f6067c61458a9a0b2f1894707e9c1c23dc2f572ee1506b7105759828b93b115899772667559c52828583f516bfc3e4d2f53716bdb666ececfee8c15ad110e06b6f003e0c9372540094e33f4c125d3d63a2865a067dcb529e44e5b8602a2952a81e83857c165b1ae30bc4e801a324867c470bc123cd87225e0a62419fefeb7e9025afa1a0874dbd95444c4854a308bb33cb11f9281562c190314b20a62b3214a0186f4c6e36ae500fca002b75c04f10b13ed3fdde266049b2109544ca8feeaee8c73893ec2fb6c983ea9a114aa11b4fe37bd39ded0cc22c839f7b1b05996a5378d0f3f2095cd40f1cf3a73590fe115eb13570a53b63f993a8a12e7ed3fdd2ca34487c8eb9ad7cb90884c2d8ebebe02aabe4dac7596f46e4b57a3eaf87d9df5d7b153fca7e7369b5e8a6ac3d25fbed3bdb79f32d853ba2668b8e70c6c56e1ffbe47a411a6ba3aa6b0d5a1c0f5fdb53e68c1efe6e645920d0996a30236759f2e21197f5772b58f5678be6938946481d9ec198546232e19034aefea900dccda9606914282990ea168db60fc33780e350e4905027d35eb1bd0e1eed3d331152c3eb559724739bd6ebd665b687ff7bd5f99faf07f17994ee2346137d5e1c3a45b8e6633e7d47d73096867b1e2da08e6aaa120bd987f031af69cff196271d9599b3ca583f03039646ced7a85bae50a3e611886e7b0b2c40ca372ef5bb528d7564bafac8eeca193cb0ff1503e817fdb0a6144c01adddca9b2d4930685b2dce32c64bf9456d27386c9e8aea7f86924bfd05fc14ce711d2c92b5b929214a628035d18419952425a92e1cce9f455e20deca9cd5032c499f7d3d54ad9209f8f5029b929dcaec1af87e14f5221645136f9e93957b83c4be57a4282d55c27c096d78acfa6f4dc1daa2e1eb6648bb23a7420aad2203c1e0eceafa5e7b161ec98f7f1e518f38081d037ba8aaa8b157ade2b7153c4fc3d0e988d5d842ca16363e40382106fb40961191b1b776b4327ada1bac76d12da280048a3dde6ef97efa8392dc01572b36300a6538e1d0a1e23b8decad08da1e9fa85ab21f9117cc572892571749eeeb617292206b73929b85c952886a96633934c083741774d6e07bc9e13ceee8d2e63b807b5026588007ad4f8fadcc5ee77c77a02c49d44dd08585ca3f15541dd79212a03aa3ba07de4f5daef6baec38cf189916fffa2a20c57baf1af6c7bd152b55e774887d775d0a9a564242e66ec5f3ee7787112fb6fa7f2fdbfd47eccfa2ce37feb632ca11dce04fdd220a871ef7d36a0c317b90bec9dd94f2793f89513322c49d63633e6726652de6da891ca604713f825a8d7c67892782d456847a825660579e739bd5953a4d0c6b20a2b1180d29b06cf4cfb950272b0ab4e39bb73f94da67bab7c7b20f0dbaf1015b703156609186295f0ed20ae8a53e08c6ed8cc2f2e3e6e832cc20cd4aa93c693251599a466a6438bcde3284fb3f6cc9c5b003428eadc4dbce69516ea5345c69c8d774b0efe253c31ab8a2108b96efcf9fdbe914d604f167aa23f3553ea6f877a20219e810891a31adc28f76819b35e3978bcc3bc5fec542bcbcfea65018de468cb938bf2dbb854da606cdbeccc825b1bbd50c2e93d88f83c6d6756c0fd8559948e1d9de6fa6ad48948ab66fb480d52837868385ed2c521b1ed43717ff21419f2a97c68c32f25accc4b11a2ab365b3a8f789b25899288160bd0a623059edb462052f039e7fad1db6056d2b92fa2e8acfc01d279c2e58e6ee1a176a9f767207edb56febb0de3a3df014b110bb45e7da620a560f0c5e9305f306e1131ee0a1320a35bdc47544a4fa4996bde430044313c77ed8003aca67dddcfef07cfa082957187b2f20516190f93a845339848c02336445640aebdbb27aa9e03684bc9f262e249f0a26da7ab907c1b5590a783303e1e460064e5644c8a5a3a325e2e4f0eeeb4fca173fdf6f195ad57f6955740647effb21da60f2cc2c1ec36390f9d107448e25438400072e2e1ab7beb5b507da8f5f80e9bc72135dad15322b555f1d3ea039ebd66200365053235d2350f209ecc19df9dd18e0c8e405f6295e0d5658090b220527b1196ba369d4894b1aaffbd50ff2028a23836ea1916717f7994038dd9f72704b5a766996567b5fb7ff79037cf0b846600dfd87cc76fad6a387bc82b9fa5a162d43c281f9b8d2c0832fe8ba32ed5e40f9ad17bd6e2c7f3d6783fc95c36df17b722e72c873c42c6053e0ecec2e063b30cc18cf5bbe5429a8f7eeaf01b148e91b50c2b1d77851da47a0c4849724b410587d8717c167e43535f23ca09c5d1a21eb43f6791ad239a7ad44581b42464ee1aa87fe960dcd0a7f00de5b2ad29ce4a612be340bd0164c65c27a5389e60c4a7395074f8970ac8293e3bd62c7b3dcc5ed1e0184321feba081225e6bc11d70bfed3255702e777c7c549e0cc09739cadc1fbdae141279cc893ffb6b307743954acd792580da996077ddff503fe2826c4eed7b76044d458573131a223a3e7cafdfd20f3306c449b862566bdaa5b1f6018c71b3eb1fbf4615bce8162110587877acb089ce170717b57a59f3ca37c5dfef3a214e338fa803f0b0845f4fee5a6b7428ba6ce0afb92eb34e6dd9aa3c97e89b025130d0584518db424e297810c0fc127cf510380f8fdcb7ad72eebe70388c30ee2157fca71ee8c39ca7575938ac093c1423b60e8a4506b1186d3f171bb619cde2c8087d32eb901383b6891300952b44b60076f8fa9a83c818f3001e17571a6c96387c48162c590448dd0f4857eeb21ebb5c813d8b9ae07befcd7f1eecb48a97f21296c8e869266dca7c3df541884c0076beb679d9671785342c9ded7e4baf68e03975fdddad8db8f48b259096007fff558a518690af4d97009586327e8d86c574c1eb3fe190195182284b88cf234118fda365f527a3d95eaeec576e36b765ccb04e6e209897debbc5d6c7cd5b056ad1a017123456c1fc1a8f2b5ae3e820fe72b87f8f983f0afc29b95b594f57a68583facc966e1bd216ddf52626663dec5635c8cb0b79d04f9b9478fd6c3330e4a84601f9ecd290b889042c562e0c3b4656eccbaca348b6a6dca999f2e31c10fdd942a919ec4b9b2e5cd35e9b042a90b639ce30cae62f1cd3e7209628036e7eda1155e7883f4243976cc0a234b939ebab4c4ac9e510473eb31f58db75dfb8704c0f9e24d1db2503dfde4e597cb6534d8200eb68ea6dc30b22679f441e0bbb70a0506cf7960815eabec726ed19ec2152af5d52b067118c19ad99be98f53cb78d0b764429e77f9cdb9fd83eefafe435ce864d365900bbff217bf6ba7ad9e4b464aabc9e47204b76b04f609c3644d8a97e650a7c23bf4002ca03e65d4f253d4e173db47b6037caa34782e3c99c63484668c34938fbb00b95affc576d90aa2e3a7816a3d0ae86bc844c6d188e8f142d31dc055d8b35558719733c62abf2367960a296de9bc3efbd2c3795514203332bb9ae38b3e6e0cb3aa4478f5209b193e90cb70bc115b999b2efb19f5234eca7669614f3afce9e5eb474d9937b55ded1e81497376198c4dc8fac195b7c4fc487c024374092ee6fb8173234d05cffba6cff2589600cd308b3987bc06cb3f84a83baa7b226c734b2ec6709d524e31e8bc6001d1a190ef35cab72961590ba10782eac80cf9848f698764bf31b184a02b7f4e28c96825bac3b454cc7ea4ea24b46e6f8cc767579c5dfd7fb64b76a99db2ca6f01b216b0c48a9c406368d71dae4cd172b3ad5f66cddbd91d17b1c5891bec20bad88af692fe168cadcf27cc1de34184b6426b6845c98a210bd9be2dbd17cd5fb561546a06b505879727ff63e3f977fd995961cfe40909424f493d388d960274c1cdec475dc78b6d2849fc8698d0fee6c426032cd64f819d4219dcf0e8ffba35c90c7d6604b5d4016b7f2979308f54b83d5f30a0734a38e75ddf3fa5f5aacbef35295563f6b8c9b1e5f39a5b9b331682c26af9ed1780be71dde93b9111a4c3e4d9a5648fd8fe1753e3a69d7ea36c7cc0430750e7349ef190511ffd555d1c7c22226abd16510143a1032bae6ca0c1682a5bf58a779a7de1860e688364adb81e57bd9150cf4e8b84e91d2a2007955ab87b7e524e67dd17a64577c73aff9d1eae25e5de1b616260e0b90a015435bd12d9f35d27e5c69a1505136cd29ff97d0d7b8615369255aa8f841d0d5138e076aa87eeff737e781a63ae8688487ea67ee347acf9b71a5376a04c5f9aae4bff5eee7d4dd51a9564d54005414edc7fb20b634cc4ce6643419fd0d819546c7b834965f5a6614af742309a0b5d781861484e0b54ff26178f6ed911e226dce157593d1fefd97231d958f5bb7df41611de6fabab33627fe9e844c44f6ad4eb1e40f4e3a5425a1212fd2fa1d6493485dd689b2b0c7978a5c0890a8844f367dc8ec8002faab4bfba64efa2b92e1391dd639d6601da711f55878df1362ed2b673deb727c58ee19901c9054d0c48ab7c244bbac9ac915e9d8ad76ece567520103e01a0c61642b5ac096fbf6864bca9d21af2e364bb0c9a74993b7c01674f31a0bec26e19dcf5897ee5fd434117b359af8d11b713599df69db96ea4d9cf582f416ed783f2264af0151ddeb9eedf9b175162695c2e7b54345d2127bd93ba105da0d12908d2cf69087c689cf0c1c16591441a2a64021012e17789765e9f7b6dfbb74593fcaced4e726b1d3174d1ca75ae492b5bf09db097212a6823bbdf0913d18ba4471ba7624e61cc5383efd161f536d5ccafcc79d7eb2ad9aaed00856bdaea625be2195126a0cdde3e55c23bd959da184d6c3a6f34f6febafcf8f0f8d18f37b85facc874147ac3e82e23c0b0647fad5002481741998cc78ed96ca5a5c89686b990bdf50610eecfdb8e1b8c80933a0c6077fec9070d3dfc2ebd1060ed0955907314b3f8220840307fb0a316d95b0b1f6a8d8b9672725cd27e1774b3a5e87fb5c4cdaee7dd9ce4631c5c6671c77a456d1d662c36e543f9ab3fa28f4e0a8eb9a7aa29b0d35691119bedb3fdae0920010659ab3b715a8be39ec5600250c5877e5fd86c56d5822f72200cce7cf49eb6b903545aad29e3e111692238332ce2cc183a10a69cc3ee26c50662b0a8421ee0fd9fe9eeab3cffb1e9cca4a2e86895e3493a201ced3df5ed2dff5aa50326b4055be401c02b16b310f9efa5bad06bdb865184df1b5bc3d46d4f54bf5602d62e90e77780b0f9d1106627d08b9a037dc09f418ec84ca94c8115948566aeb909b4585763695a9a481e43a702450e49057de1880b2f056aeb2262718c7cad1d090379350b5777d101a022957327c622048e1b5f8d72ce81f702c7ffa32603df20cc51b20b0bdbcb44533cd428f6bf59974c5705daf93cee6936e8de0db0744843595fe220e183f7c33239fc3fb5507ed2fbace6c9347d7b8ec43e790520c4fe4a9c4d4092e18b9bffc7dadc5ef6f8bb528634a75fca174d401d73ce1273e20374a1451ba86e53312d557eafb6b35a7314f8e9ad8ad885f2987e3f503299278dc8999f2d972c9f6a811002551963eff99263a3f162083c9df622da9a3ba35bdd6a32387930cfd5097502781fef75dbf038fdf6a6f53c0b5555cca7e55c9b16c20fbc1fa19e9732c96e9e4e40f0e6d159f050cc6262e5847d3109e3db49bc42be9bc69d831da5d4b786e532a02ff65bdb77d2c1e954adf25f8824f09190b33781882ef95a2ce547be28cc6ab247f6024c43491769db8a36507029b65e2bfeebe6d3412071f61fac234e036744bf969e49dd0122779f3ec7783227e44482d0a478c436db4593d433bb9522181806bf04070684b6d320752ea899e5fead19828a98d365c44a101818c36b364deb5000b3378b66e717d63f4c84d447ea37b53e12f4215beebf6dbe21421588064624e6f153a8682d05ff1499c5c303cf61be0a3aff2cd17aeb61cce20ef22455913f597f95228e41f6a27bfd0418832b7add650fcd37bb0594cdf5b00cb3dac175f8775568b3ba63891cbabdbd14bd4d38659a7d766f05c8a6fa963f1dde195da356f4bba2e7cdccf4df63aa00760cf726f60001689e6bba3ec1053811ffeac63a633606cf2097a4165bacf4376a9e9d0bcd118be5b09598aa593ee9e43b20567e026730e42424fc1de1edf541d1a432bad044d58c276cde81c9c9bf0ae63b358d21bd6805c7a0a93d43bce8d538c7492e28f56f4c17dcfe38c1c7f1a62bf3c2f581057f12c5949e5b38fe015977f792ea2fdd37a4a0c5ef0f13f000fc46aa4ecbdaa401d3878493a1b940441d3b8784ff4f74337ba71be728bc446de968a9a484d504c25b479039cc73846be355324fc165e521d2e9644b0c19e13337834960a68659182633dbcb7fde788b5616b243ac99db6a319f170212f70ac69cb50485873c846136267b1f10af836cdc454f6d0118077298260ef55b333e428481c55973ba5387699aa9d0a6e93356aa20694ff57aa0b07a30a4044f4c1aee4f0ae959405af43016bd4e3abf6564225a185b1c08b751a266d7dbfabf66f6677fa66a454caa37c5508ce61c8f7020a9e3638f905c148ed3f36fed1ddddf2e117e4b63a64062721ee029bb1a1baddf5073083adbdd7482a95114c487bf66240172f7dc2c2fa69595af0daa3d52dc410e1e808cb966a8f7bb561b293a73c2195e29c09a1ea102b8517ae4ac2271e692cd4d925e4e64485f92978dc0d650c36ca6856818a939dda47c12072ebd914d441359d506f7a0cbfcf9fd0ddce04fc6b63344d0a1def56d522dcd4089ab2432113274e20667a8547b44575237bfa3fe7eb702dd0e0c97f4cd2774b7f4d330c58376e699f21768f497a0c5f3dd74b21a26f5bef426aaff4abaa7cc82becbf46b9923faa28135e4781bff50204dbb42d2908ebbc881e27df3bf40c475ffc1e4d360d043f3d10c906cfa6072aeff5354273e092ce7f10f2ffb50bb027b640e237b97ebd004fa2f63576a349675003e2477c286a17ac7ed098164acd86a4eaa32473bf34effc4ca322a8dc55a47b967a1d00c3735462aeaab44c43d179c527723c300cfda5b4158373b92afc913f608cfed56a83d8c3ca643e422b0f7dfc818d5ee86349863fd598dea07ce0d1bd9959af6254b202ee50f84b4eb415ce0a47b916b9bb3d28aa703c5d7561acac51339573a83bf4577ff0547cbca2a6a402e7a31d8a0bbfdba6b4bcdfbb074036d869515d2e316fae1e3e836f1f9c69e4db93ba26e3e1d7f06b358e6e33b62447c7b9aa4ea783e28bce7aa077379c421d674590bc828d0f1c00f7ba5acb2c88b5d5c26b0cc362ccd55db50d6d664f568681eb5ef26c7d9b821c8753b677f0f6cfed05c327495ae976435157eaa95a8fac597a2beaa65b6eb10cfcab8a9ffc8bab2fd3ab38532f09e8cc2331efaf083df73249865eed921c51125ac6578b8be036b5a9cdc8f957d6f12e40bc1a1e880e45c1fe9c201a3a265ce3b38e0c787196dda5199efad665e3ac14afce85bda869ea1011e851636043ccca16d49038f11d603f20966b0f24cd3ddf5b16bbd74d76e66f3fed22711ca8c3fb48a91243d9fd4c527eb913fe8e19db334f63fb455d3ea2658ffe20d0358003b9ad3e4195a156d785497d156b6e313d0148f45e2eb2e9ce088543c1010fbaf640c2c59ffec13d9ddbdd94a516fb501f2da93db3595772f54b3d2fc6df1b78467d9258ab036440e371101a7d44116f1eedc75a54624cec2d09d1033aa70b9e4d263d1e2a2c18ca87503979850674662ca00939acfbe7c678a3b6d186d6f538b84c8153e85a7606c200445fb004af4834481ec441abf5c0e4188dbafbc960e8e93975aa34dcf7c23963ac0058bac0802033fd2723da9a2d40d3a9c3ec3071c096b6dd7ea997994755648336660ab0332de101d85f94510bc4b5f9258b0b6085f465fffee7bb21854117c9ee69256ed340b2f9267fbfc4e9338465f2c1a6c4b9d8e148ad3fd99c90ccb7479e1eba2defef3dcc5abbe58db00fab1f47c880d580884c0e2d3f00ddff1c4efd24e333b1ff102bfde084b0dd14ce4b4eaa123de2ccfe6856689c6e94c46c744912461dc820c7e9a88e6cb6b240bb72d0e94fcb4b0d2a63219aa33133bbbdbe54a03af4d74d2a5254b175da060c2c46b5b36b79f35aa20adf94d45342851c4de63051b1d55d4c09647a0d0d5bba76ff5732b0a6b507ff428e667a8faadda5045f5f657a55890a2f68eb1be81a4decdddfdc2b7afa2aa60dae0355f5cdffaf45d4c98345079966c0a6d42a04233660413c9aca90d31a85590b3e1076c20d8abe95691d8f5e5470f93327c8f7c7065775267ccf6b4b90409b7d0f0d986404e41e55f27cd865273d5cd553562419dd97bca6e1de7b3df7b65f2e0735b515fa91d328be3963733d24e39c076ef3b54f28de5091d23c91d9d461007d4141d9c8a969a77b1f888f6996e43d382d069ba9751e813e0d315b3b740363bb72ed09fc4ca65f1a3eb5e2803a4b21af39fb23fedfc3e7a355f82e85321a17ccc9e3de63a18a033de9a48b77a59c562a66e3e06707cad23ff0aa3a1c37b83d4908fc55bb526b01068da442ffc41e946b5ce2780ec96a6a91837112101204ef63d94ff777927bc770cb2ce5ed85662a3f76e052e72aff0e34ac59fcdc936eb5c7f6202ac083091b1213967296f7420995611f87845ee222417aadd5807d6cfdfa3db04a2a80fc35b7ef9500f6da7208a4c96e1be6bd07a40af194fce3698b60018227504f3a550645f9f4cd5673f63a0d984f93d909c0d2a857a2edfb9663011e400cc19f97094932a5414a6e78718832fbe300b9b2c068094bd1de7109020faf111ab49c81b653795f143b0cdaee27efc31f3f9fd19c4a2450a937f731b740cb9a2e458a39305d57db78106b4075b043721e523804b9d3c2b438d38c27096375a6cb37a58eb376165c3ed29f9c0fa44bedcc47bfa2573b1b9e2bb4f54814268744c147a8c7e876cae49231c13b5e6cee1ddd679d08ffa88c03af8cfacf3d5c9e96d75f6eee6790151b62f596133be9af34055665a209b9ed36ab9960d9753e7d11d050421ed7c6a695c7e1a06493caf9e04530647722089e68f0118cf5165b7b11a2b6327ee651a84e898bc9b4c868f5c65d3a22bb3cd9cd08930e4f2b9cc3dc8d2f818b32dcc12ed1137db6cbc710d03eb3b5de1a2b2a6e8ea6cf2f0103f947df6ee1923481b8f9a0495e13dc4fbc11a95ac2cde258c62d347daeb673e9a1132ec386d6af2177d778571138f87779c3506128e1d4cc433cbc6c38b56c6a32da9fa012786d3c3c3575518e65d364f923ab1372e2d1fab3fd8f343c34393d696a35edc40509fbc231dedcfb8b522a7cef5a2ba8133094c645cee78bac5ae9a7300854b42c731f8d6a587d7964011f0d60e3f410e53e9800bfc1c8c2eef10ffa16ddc7d103b1df2de5576926673df2f1ce7fccb314daa7d2ede053d453d82f95065203d69ded3adb330ad266e0359c1af57fa6e60a73fa238b17f683d086b9c7f6ded6fb1cf3973dd901edfe5847e0c60e1a51ce5d0c91c2e13ab273b893a5d87a1979ffcd6a82c381bcf30328f162a81b22dcea3447df3f0321885903735a64ff9dc6ce6ac986fd96d15d8ce019bd691b71d7be01101a394eb4a0f6befa3509bb7f984f82e310a797b7c53b4fefa8764079a301c678276d28f9df2bf8751152e0d4a684d50aaeb9c30fcf353160ac1d697231c7c771815bf42f28ae683579452d12c6b47277c5a0337dd7e3fbad0047330a7b94d52fe55010a7a09548b5d244fc19085f5006469794eeec790f75c91b1cf670b90a783e331599159427d66cf7976a3ef090287e5b1a08dfb815069425eba5eb35e60c694d415977931318fa1175888ece6896d5a1d7b618a33df511527c9886831dae6d33974ec46df76472af0ead7351898a09ad1fbfc7e6c7af89af5d6b2dda18c8372f8efa0129c5ba83be744bcf0de321e479e0630f480a15b1a92ffd77151bd1864336cbc019858db221011bd719ebbfaba8f40bd053c08f750509db29d3280b7637398f30a111c0d742e21809d69a0a94f5f264ed1a64913c22ac7c71f8a6d5d9bd0ebd45da595dca1e1df478a4b253622f0f1051bdd253f6e931e99f3de5ab7c6cb6fa7b297da71ee25112cace868119bf7afa465bf85938d2b198c7071a31c700d62b774fdae2b69b6d50eceb0d69305fb3f1303b7c8c183961edbbd687d657cfa08d5e9c9798e48cd4cabee4e57c9e512586660db24fdcc9d4947079b8293b48507ec94c634b50d1458c9b83f36b9385c8031737914cf7c9c761891b7765b01382658f6c1195b912024663da6052b5f0052816c62bc7b0077a96457ee1d95d4c81e286dde21b1e8b89826d01052cc4b6ffe89a3e7ee5beef4b9aff518b4c8938aba83751fb97e0f59dece3ea2cde47a316c1c117b4ea0bc572fc4c2d48b27f0a6daeea72b0e9c09381c34dc01bf2705f95f2b10f3d3b683fceedc4fd69eb9d65e58a3435b368657628c84e69cb00aecebcb7e74efb04f8d17789c75752656154e2d1b2b2fb2f00ba47cb6cea4599e9302d28180d69b1b90b8e8878a927eed7a653acccca7e619d6851577c03f5139d703e6dc058c9874e6b33a77d1634dc4f8d82b6c2b71d9ebbbb7e427ab24029bf663d55d5c1907875cb9cb4ae9081a9a069c995be84857e5de9700a3836ddd4c5621475946d9feaab3e2f6539eb55e14368f6af5eeb048fd904cbdbd7fdfd3d20134a89459a2d7b151e45805e50602f2e35024acd4a9688e0a4edfa4691b50aad5d812031db07d0ad06cbf18c010afe4a4b5299d6e672ed6e6abb29a65dc03d3194603236743ead164d9f3a072f73362460c6cc0ceb60cfe7ec7fb0984b953a0dd1d03f5b26e30b7476a6b7286894ed874ae6e230e2468a75955bdeb7f38ab8ee547b9c8285dd7835a76ce6c939805eae968ea1778ce8b9ad4abebf237ef5335969f874c33c6edc9c3144a0e5bfcd0f56bcdb84ac73d6102dda0fb81a171342a50f2130176ebc5a98acabed4647080bec1fc1603d41bc520c7690a222c8e40f694a70cc93293f53a510588b2a69cbb929edfb64b2d120cf00749ae7977c0d35380284305ec369ad885aa9ab948b1181329bdfc069efe63113e71c8efe7e3e1e860e9426ebd7f963b8672673b6dace1683a91595a7dc575822e7308eb3d1274a3c799025b3444278ba07ca247ba6226f3d6e192d28fa3968671929532bd9bc4f1966dccc903879a487dd86dee04a1dabe415062fcfcca349cb4d725b41a3a6281b72c6b206ae9193a079a7d4ee787dc90754ad805f022b6d537c0f9981be663c5a09dab27aaacb8c31d4fa647b411dea40845e117ddad4d11f30f3d79db5b92483cd47e60208489af0d19773310b45915c2752eb5c0c5e88d6d7cdadd9dbe5a1b603e6d75cfccd3ea349fd913d7b49f924bbdd2765af569f8b25fb0fcaadd932b6e2f3d713d17c549f1efbc51e1734f1886b5fd4203950d5e0be08e38bc92916e366d17ea162ba16f1b835e94c25522d4ec43e4c5cdb7c4a3ccc48864e6177a285f159a8af5f9da47245bc315600c5a451bd9e17aa087fd81878e31401001b07c51adb79a5e1375ea845ecdb8e6ad16598c1d14ada02108c7305a39e02afa944745a24253972cb1503f82b05de6a2b8604bdc9ba159d516dd5e77b25e103252ccf4f34fd44350bd8f89399e11898df6440bfb495c58c399fdb2b78e195475b04daa83a751e969f2414737e3f01b0633b558050f90d1da6f4d1f81afa80816c140eb3adc8ba96f681ec440a6810fb9fdb2b9acf727c3803e0196340b7c346394858b9830a69b8f8c95b8d9a2477e8137cc88302d918f9f637603b4ea42e47f1a67df11ef3f57015c039cc990ac2fc4fd7070d6329fd5c6b70eba83d4ada156a973232401023a783f695d1ac155c39e3b737dd68b0ae837e3bb365fc8246dcd2e5eebd625fd5f7cbf62aba5be2b78955b08748c5c17b089f1ab2fb671e7c96c95e30082ea0c08a5474e2fb800bebc87b4263c5b32cac66a23e58e373919bc1f0e21309c93dcbc4dcd4f01f26caf0edb35ccfbb2b517eea421292d37537201cee09d447709b22ee76ae1d88f24e79905beb273e9fcfef541cfae785b828ee3d0ffe324538c5c1a0b1c3401df942712b386bad72ef3fa557ef0fdd8d349842444d6d5d60a06f153a4d1bd676b57d33e144ed2d7a4965741b7cccc9eb01c8930d0c0f10479fac8b0a4f87087f2b4e12040c81029f2ef4b242076a6642f3659f340ef69709148ad1616e3ed9943c4f534ae6dedf7a56e52ac9b6d64743f18622aec3ff0808eef8240c82bbc8faed2c3887f303ea0a64f186a8e92382ef22b6bfbfb2980743683bbb075f105a1551d7243684713f847b9231d591e4923b8d9edd5663b1aa3f727b1c0a0c6592d3997f60b6478fa6f2447ad7392bbd3bf34ccb4f5977193026bb49645ef754a94754e1de6dfc4000fbb30190564a79fb6c599e5c0f74d212e9adf6a8a196a943b1124099aea85b7c8a5a6432bfb38d5d4b6ae4d43775f00d010c8604a3b7c4e3cc241be14f1438e6378b17b9a00c567a075737755caf05516ba07edaa9f7135b4aea307e0bbfc59956cc0581b6cb066cf89f98815ec9df26898bb5aa2d02c1e313834c4c5a72a6efc52d1ed3e8c9d849613e6a6c07c6fa2b3470499878d36fb35b4ecb9d23184ea49d9a8ba1ca02d0139d30c0b4c941c9dab395bf1bbed9dd4ebc818a4e95a61919c5d69af92f4abdecbddc9772d747c8d22ddf66c3165079f40bb33fc8135b899570a0911d3f3b82338fcac327e88b5e8bd5a49e10c6156b9728a13b3ac1acfb1026a4211f5a0df90b6885b886b49b97cefd8fcc797f1e1de995457601a203e4842c7a11c46a4fc59c064bf195b768b6b014e9bc2a12cae9c55bd36f1dcbd8de18fba0c3c11da079bafd31f67218408ce6e4ea9e37a7adfeb3690e0ae28296562b252d23e0baa791ba867dcd0a59e2e0542b4b41c916c2c3be76a416bb5956a24579554fa17cafeaa4f0e3dd9377913f596979a7ce94f197204fcc7a9e2fc1222b117b9a7b9a77cf94fe1bfbf1bc957896e2c8b301b9e9ffa4feee12b7571d8891e98f519e9126bfc7688701ed960ddb68a136b9ebdab01f09e5dc18188504efbd9e29ba6092c21ebf44a8d39743889f0ff38bb8635823396222fa6371cc7df816aeea26f938476af425d57e4d5e92433ed8719b7f572800d55f0b0dce9099383e0d1dc1775783dc9fab228d59e87e9c1cbfe2323317203960b52779c70b374ee8213075cc1fc5bc6649a4c838a85dbd4116baac95a827d425f0233e930e213163122a4be1a86225369b400f50865f73c9a0042b7febe9cad8ac5d4be5751174c1858458a3dbd6d6294e0f6bc40ce2183c9f1429c54b32faea74d815598f17744f11b7cb2cc4361a7c0ecfe718087f6e36e72ee505212421a46f0675968b6d657666a4e3dac70c1ddeebf0a08618c19ae83b3c4fa453d2d1db8ce8d9a261287984e9fd19547fa093cae46d9f425d3b9a62e046366a03bf5c94a99445126334109bf51d238cb300f206139260833187f57d844b8ac1af3929f06bdffd9d620fdbd0556a82becbe8bb4b517b23bf8910e126d1b75795c34443fabd00380b66d5ca0fb663d12dba9907aa8173aa532ebbe4cd947153f74208d504f616578bb9acfd2c74a269a434c821addea470fa99816ac70c3ef821420140dd30a137928643093d26eab10cd07e60693cc9727c0868aa43b210d870240c7b81780332fb78cca0d5af1f5df8cb7162a0b71dd2a0e680061c01b9e9adc385aa6c72fd7ab9610d9d40093ede3d6f2d61b4ab0bcc0106afb961540d65b0661fb87a7877f3fb6a7c32958994d7b66e431b1d18e3f66ca568e024b1b37954ba045fad877937e4923c226b04e7e321cff21bc53c31c0530c467a9cf2d7bdd80be60589cb480b9f84ba1d92e64cf971b02b4786039cd09f567eb49a928688b5b31e6bd071d81e813b1762732cdce9cdc3f2882f5825c4fee7c1edc04e858f96c5cad7e35f10921043713e8b704881ae0bccf1dfd9b35e2c7289a9c91903a49850afc0a42fe586dcef661cdabb5650311af1e3cbec3951e7d49794b7e0e0f3883f5327ed380b2c0efa0c6ac4f23175f0e3f228be0fcc297e4d71a1a77e77015e9f2c8ddeb65a8a2f27e7a66eee43bf1acd5b0ae441b333360baef5b412e5346e2209ec3498eaa1e142c5a77ead011c63a252e19c3eb5908b0fd1984eb99a99f68107183ca6a138ba9322038f706074d5b025b2105fe43aee1ba0573976d27f4863befae038c4fdcd69d45fac60d2691708ff641a6877d64f52b87b87e0765383e1f420bb8a841f874dfd79fd31a9b4521df306344be7e69873d58dce9e4c6b58acbe4aa25853209befe779c9ef3cea97644be5bf1db9226a47e69e50f8f727cea5a8cb6669eeb24818d7f35ad7efd6900c654727555d119613e5597353e2f41ad93ca768f2f3a8c81a75016253dd101a66824b075bbaea84a79687ac9f9d262cf2614212b93e4a4668fe8c98758b3101c8dc04a288e684679cab9852065212363727899cccf7b61129d769b3d705a59ed47e1089ef2e076f5429a3f000cd5fa270a6af6782a8ee6df33b945e1a12004bf0ce9ad28630bca6dea9aaa25871b737134ba96d225ee5a566cf2efa3cfe4c3fa654e98f0435243684f575d7436065b74dbb26b7029ce8492975969266b6529d9cd9068f717de3e182bf9150b6ea328c6460ad43f6681746c9b3095b3edfa4937326a2bfd9ff6d0283bae2850878b0ff7574b57b7c817b982dad35298afc1384c507368c3b59389ded933531dc01eded3b82ec98c83a6bfd75137628cbfab9e82395b1cf810b672745e8573aef3b4e10c054495831de1d7826685db317ba358a3e4cb4660ea56304cddadd157f38034789d6237bf0715596fd510eb0f28370e5c7852f4c413a58c5ff8c9a36a24835b5b3cfabd1618261a8c11984af26d6fb39c6e71f4e17afaf14b746feeb57bbfcb6f5be333fb588e002ce89168f934c863a30960167e80f8fdf2f92ec2d9a5b79cc494665ec939e62512134fd4d5c7019bf0f44668bb99b0d27abf89bf008e643ae9f2f324e5d142f27533bdbb602fb8ef91acbf202634089aa895249f4ee7b502b45c915805b52e1e81a1afb0dbb8802522dc6cc13c2c5dcc36f34a40a21f0238ebdc004ad8b66cd43d7a516c84f3c842a145d192553b3fab462d239f2af4f99be3bedc914b6ce78684894a32904114b4c00c4b68bc8f81c216b0fd6c40006649c77019f8a773d8d5a145f74208ed680a5bb44b0ed4e92947c1328cd02468da19c478a0c46811e96144581215747a8e7e8b35189b7d39a925ad58614da33d1fff15786552dcff246f95f0d44581e8a6523b7958244d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
