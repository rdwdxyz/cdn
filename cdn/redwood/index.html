<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d0746b55221c3f723166150ca9bfa80e397438d574db8b2bce6bc00bb6863359e4cffae8bc8987c379839eb0b73e330ed9e01a844074d29d393c0a776340594f03e753ccfe3ca146f0e4d3ec688aa519fd5f6a110769a08f20c6fedd1edd7d65143c6a015948c1173d4e153f63adea4ba47bfdc12f17b2a0c916b638fcc46ff815b057f377665672a410d633b4113b2baac2b9ea3506ed7dcc16cf3aa85f884ebd36369acfdc9d44193540a993351fd754de44d8862ad3f8cd7b114b0b67ba1b38cfce6d0c0b06306098299e0ac0f667567cb031290b87a7dc8c65d1e4138f59dac55fc0208e3fe2b51b13bf15c24b8ea4856bf99463381e4fc071e0a7d3db42a088bb141b6f28438de91404e26eab9a6257cbb0ffed4833ea1b4f6ed3cecd69dabebcbbf78d8e6858be294e97d9a653ae3db9289872da917c084105d8228cbfd6c5294c6e6efafccbd55f079a97ad2c69f7e907d7e505e4681c0d3c8cbddf10dad5304af359f4f176918602f5894487dc85d114fea381ad152b6d45fcdc12117453b5a187ad62912e0a68fdab156ef326753c487d0f9d6f73fe2eb09d93d4627f80e891158619d74f705da177327d5f24dcc0b5fe036e7dcf4568de669d535bf227daddcdba7b03d0be243b8fb75a760082a5b311bfd819a6d092b954d8166abffffba9a48b3e9a8864b15436113647aa20745f835bf2e449dae0e59b7204ef746fb0e57b71f080d2da9d15b9b4d9677b46979f4924d26144c0bfab861098710777e1cd7aadfe142574a4eb1d3e9a19777c5b4e598276926c3286ecd1913a06e7bb14191f34f7c207784937330e0e3a522087e0717d5640624ece7c82d7ddde05f226c895e15d4769b98e1b33e392527705e86004ef90f84cb3cd8b090a240275b1e1960eeb06b811fde2cf7a8a97319728227f2b9f50e244b6eb317f1b71703deed3a50e89de70e715454584e2ba4c8ef77d26d3764d3fa33cd425242c59a377da904ac2f992209d64617d0ab5bda9121da2f20cec51304bceb9a6ca54be454c03d3759deecf0d28006589656d8085a391eeb607b87f016bd3a158bd1c217b8e6817e4d58b30e3cf524da5c2670a305c8dfdd4ac91a759746da24066db5438367137840ae5f3aa7653544225205a8901e128522b464c02acbeadc7989b942594f651ad42a39e474e2cfe50d92a5ced57ee15b1a43d67262dbe40b46a3c5d2a648751c33287c9fdcabe2886e358aa3962ce3a6651ffaafd951d451a8ab8f65edd6148121afff4b436b0893d4b0b2751c99790c5dc8f4e87b6e5a63da106580cf1e1b014da41a96b5419ddcc33a51a21dbe72d31ae31007b3ffb8e4164a8aad11a074197be9e50837af0c87b805f721cfd03404c77fa41b16a83a613569df872122d54a4024c89b70b3b203769941d1302e02e9bf3b6de915e79fd1f856f6e05d87c5ee4ac0572ab549a3ed866ef1056989b5a58d11ddcb7116a415225403e4f5ac82468c6d7b63e1847421f3c859381a4bf31945607d890db70a3f13dc80d8ba5646ad7335c5a0bafedaf0e191204f441ded9126647a26d541c21306414492108fee8c388bcd3441657d44ae4ce9b4e0d2e9e460a0ad73ca24abc6db73e159963730ce74947930b8df22b979b1d01ca6990d39bf86b216741659245e0d00ead47413b5d153b93cbc4a63aeaf3ef91cd9a76940df2066469ad900385aa5d0b4edeb034f28116504d7631bfb3d8fd7f003ee1a2a857a3b7e4bc33c1d9a637fbd2d0bf5c9fbbd5eb766bb5e27a38d0ee7b545efa3dc025d01e80328ce15a86aa4f4a4a6bfc3d3888fe992b3ad1d245b56edbc46a55bdef4ee80008da07dceb3604182fb33de6772462eb97796da484859827d1a7b8028b9e3d8cc87c56a18f9ddac1c490b0e6c5f8be82b051538c43deb2a5a88af83d158c456c53d7e99950f9fdf63acde7182f82c70a83e2df693d384ede29045b45717cb1fea3145a75e54d45e7270df45de9bc2c06d4276a4dd8f27a7e00d3ecaea2a36fe9c9eb6674dbc2eb488cddfbdea57a0087bea92dada05b369c6bae6afa2162a4e631e2336f57518c3741e910e1e2ee4da0d629fc0c102cc91ace424713c7ea35c8b0067cc0072c8291448a0da0ff1405688e7d68a913410413283602a03df811dd8958aee18afe074a9615f04eeb6a5268a3215e1d7ac555e1cd7ac37bdcbbb2b1d13251e29a76cff6ccbbb17d40250d9f3de6696f12e30a5f6b873cbb8373f0e4210ee352ce66b52160377495b2e907124214a86f78e3cca62cde55b38352b4f87dbd85663939e76fd1135a6ce78011b1261d518999f0a7d6841b873635cd6e29282b2b713f71665a2b756076b6648def1c993588446d3f8b406684a36fb703860fc320573751282c33503fad5e7e78c2ce4a662e8a8d979c3c0b8db13b74364df53638c7fe15af3af38bed012842a26a171e9cf32ef2775851da5f3563aa00c1cbe50eceaccf7a8b6a82e2a1a680784463aa7f3bc1e1c196957fb3fb96e0eb5a988f6d8da7561e0f13fc9e216dda3ad28476e72421ff74120f303e724a6e61cf99acf914029ab4b0522f87beb63b891340d6d5cd67b21e646cecd27174c1f20fdf9da84bdd33806eaa14d1edc3620602def6787e17b99342c56aab767624e747a4d7de363c24b4cec4f0cc8afadde3be112e25850e5beceb9f5377e648fac6c08633427ef68eba0b66f9d9bf2633430a76ee7ba2ae590b713fe087f665cd8937a4acfca9210a4247af68d3ef03c2e71b5d6bc38c9e6431628f0e1b14dc9c2a5d663a881734b198010616fa002cb44fc92b7536d47cfc553907834bbea07a1fbf9235cbd96dc37ce250a282a2d86bd225ae68ba4e5a621c10fdd93eb1cc7a7df6ee2416e0001d4cc06e3bc7743ccea3c84766df14a9636ddefb8dccae5cc6a0215504e4db9747649d8c1dff9bad6ef81188c60645be3b7d4b5f2060ce880b0163612a03b0be747b1f49a017f7f95e2f22c0cb71150f049431853249660b31225e801609fb5059f93a3d298404153790ba682a8eafb97bc99d0a24f9c15280bfa520ebbd158bc97554045eeac516578d6e5d5a42b520c9a8149dc97e86301177d3022c2f4589f31760834e8eed8cf028cea7572e43614aaf42f08a348c65eb12d0307ce05d7b286fcef4a8ed6ea932f3b8264c347fdc8c50df7d56bb97701d040322212a8afda53ec2605416ca860df7d29aa09e6a1e22328b2feb72bf34526a1be31398a20247fa70a30a9f5450d50100764a1699d2f601bae3ec3040327838a23b2afc2c7b1a0c75db4fa351e05da1d453917db0dacc0c4315f605ec2bb66dd918819e4088c861120f0ccf60a316f04ad98815b81a5b9f3ffb2796e27aeb430f100f59432933ae71100b5fc381390c73e981b4ab46b00b837b585cd5c76d260463d37db17b3df3a14f8ad3cfc01ba58b9bf4a828b0b08e9ef48b4f33c0589b0363ac7392c85d7c466d769da4a9332cf96f3f7bd5a6092dd2a63a7fb634a7e29cb18c432522e3370d173d8c21d96cdcfdfd84d1156593ff28abcf9fc5cb7dfbb58f90d06b2bffbef4fa1c4fa12c2a9c3d2d460a81c3473b282bc00378cedb7eff268540579e720804d73f5b7dad16cbaf38ca6627623817ba1c69fef5092fbce1b235de69a226685c1b117ef5ed76d12e3e50d4769b4013a61c50e78db01a00913158927bf4abac319fdd7eca91c7177c7e074ec0fc68e4b4934bdb62c254090153668b48d177567c68bfd4b4dac9afafe603ea951142cbd8faa32ac637117c5ac4588b189304930373bd67d3d399793076b8a66352f4eb1afd11507dbcef82deacaa4fb2bf2f8a58327f5043e85868c469616bd3a558f5f6d31f2202ae02299f811b288e39e91b71c6a2869cddc7fc194fc0a3920601a63e7879a97c9893f74e6dc9b34cce60aa9288cfd833f6458da3727173c90ccb82b0b9387a917fac4e49c627273e03161be48d3daae2eb71621970886dbbc6d05ea592ae3712a9f458c3cd4f9862370be46009b3e0ee656a7e2ab2c2d57bdab8953651c76f395c2fbec6f6ff05590f594c1981db3a70c531ada50fab93c6227c18a0aef2dad6859211f8875d90f31956353f22eabc2cea78e8ebf0e8038aa7266f6f211defb71cddbbb2cb6650ba83b2329fbb5b531282af8099ca9b95f956d0f84fe2cf0abc2657854628d3e586fa04139ff30c062124877f7b39a22fa2ca662a73e13dfb6a8ea735fe082d77e08909b33a4fad18080150f2c5487311bf59a1006e98ed2bb5575453bbf34c9bcf27e1838cc8ea74843ab2b211dcd3321be53a14f16b454b58ce3aa9fc4955c8d345e29d4e06eecdf437a53d8b5a13c0043cf6d114ef19e465dcfac978c1015f90360b15e788f9b2b594929ee0069f10753728d01b060bf043a963728c29884a996144cd4ebd431fa843312ed89c5b13410af34c0453940943b6a065fc2ed3f99ad1c1cc31ec0b982c8122c665cf405cd6b3b9147a98de587fd45efe271d1240c8632508757e832a5c3876a51440ef9a81ec51e2233f03175f7860759e444356d6ae0acee32154d9ed15bc2a99d5b4819d4c48c8fd440cfa8f816bf486a441a744bcb284526d3b5c66c6e91323bc6e7debe92409d7919086623667e31c0e17bf01390e837e68a1aa771e8b92664565b8e73d0c4c61a42f29242357a9a4a0af088ee6b013e434f31b540893e34d2f3da60f3c18a9ca77eac8830c300d989f2ba960a64a18236ff0856a55f174ab8b662f0260918324fe5f8b84b1c0bdb7f2c9182a6fa7ad4511b04f5c9de3d90c3f8cc0140715f48499a5c19ba79037bc74a8c71f2807504edd841cc1a3fb44aeee5150e65265f1cfd31a6e8e31a5e33624460445ee96fa4d2bc1daf5486faef3184f94c6b89403c01a8603a6dca92540ab760ae8a96d9a89b61d522df4c3b9d4c22e8182575b7780e6854e7467e669aa083858c6f6c51e6dbfb3d991a76cc858bed9c429dbbb20f9f746f2a3a8de8adff66556150dd3855b54bafcc7f0a7b9160b302832b88ca349a5056688e0d9972493d3ebfc3da818af55db2b8e27a87878ba7912c8d2f923b6715bfc04a508bc3701a19487e52132e6956a8ca13f219e4c7b07bf3d8ae304c2d0a93fda0c76260fa2977d5a2bb5c9b002ba61400bf92ba39759a9d6c11bb82411f39f503cb1f8396f389ca733493f1190ded2791d3006dc33d6ba1a26e39e1079d7523ce798a31d6623179d8e3c45e47c9991ae3d756e7effd85ba70f0cbdd3eedb6604e23850fad795d0455e7d2485360166d4c5e089f2dcad25297a85d773005eddabdd0055dd9923a357a324c6cad0c6276c662b8b32f13b1eb3a22403db314b76df3666b1a9883c1e3807b238bb4f0f898a5b0cb44df5a4408bd8c4843f7f44d53051e3e9088e93aa595d4b9ac96376f2d45e071ed74b86ef632001070332bb05bc1d4c0cc7802d23b0c7c2f20265f4dca6ada3896429e75fcab1535113c1b69296cf85b4d4c0488b6fc1d5301f04df11c13d7a26d4b5800361876f83d2e835965b5300f3bbc3bb8e1718b21c728667db4468fee68646c9baedf721517f915d44b141b1978d817840ad4c81342ac135a0345fe5c9bf26f05ac22dbb234c57791c1a1314c733d1e1558353e2736e63ac7f625f5fc9d13f8c6f067d658a5e997a2b67a35135f0e36b95513403746be5c27b4001b85c240d247a9ecacd33712d96a26d295ab0dfcd7434eac4a8e62776dc3ad82f042914247f6b338479ca406e0b066d6bab63d4318b0b23189f56b60e9614c1b0c0b60b884b2341eadce1208ada0b0e246b9c01ef43ccb105453cb0097b96e72e9473c4f7e6be01587dcdb0630820c149ac9a07b14c32c59d19d6b6ba62ce0750db42490bb8a84807fed2ca67e3be9f8c5d9ced25c5fe2a73ab22cf3c961d7056ab9a0bf5c53b346dc7b7963ccd9021ce3209bbb688d9fd74a6986751bd89dda53d624d38f415f92eb0909215ed1afc225db41879f12c412293b067d7c50452d5090866d8e5f396cc1450dfb1f0a7f6435ee890127a12589fc8993a88fa33c6f0c6bb9a83389aa783af063e65a6b0c73f7b015121f901888d647cc71f80596d33a96bdff119155557a487afa86e9aa3d54c8467aa6eca152307403cb3d208d1fd6df7750b9cb51816d29b8b9852832826afeadcef230c91b11a89f9cc4a2d522919d899bf19b50f2c590f7d0b62c173ff96e7443ed00b311eeba98ecbe2745e7f4bc5e797b00e321393ec61a3b1f4a9b6629ede7da821fb1b94d724a55313fc5de878d05aeee23cc36a7a556a25d523a31855edc298d09b954f8db085accdcc2aed20b17ffbf65857e340300879849f12b033aac35cd8d1838725a96d68c6938abd59c328fc839e905136c68237fbe51c5fd160b994d666d10c1c3f4ad7ea4f2e04a6e37fbc54397fbf045fc079c4e8e7bd2b17c9029cbecacb1449c5977bb0583c9f6b8f0ebb7f0495d62fee0154a1c40be6f05681c67fad6f3fc4d2622126ff8ec1799a3b151137cd3637898ecf2c452260315ea6f105367a705aa802abb2f0ac734a08c04ee03d07a0bd61d454b4ba48eef23f479bafadba0219a06d7a9db6b4a6f47a5676ab51d780d7de7e9f3813c4b1d974b79016928ec5281d332d88761b9450b5d826933e29650d3a033c1c05eb3838f58361ba312b1df7edc11fa9f73c87441d62dbc95ebbcc6ec10bc7c1976900e0545b46c42d30c28dcc25b9362a3f6fda7fc192d2597ca21ceb0f16d2fd038651c6815b88e270e5c897276ae199f463eb31decdb8f3283b62c11b85d5841403857f325a04c73cb3cd8c2f125accd8158dbbb21ff7edf69339e70d63f2b85c5cade1c779814dd37e7a25f102588489da9a2e2f44d70554a755a846e24ed8ffb69d92a0f5d214b0bed96ec2e06e34c77d2dcf85e44ef24e6609a7e6d903b26999fe78f03b4a40dac458ab7d0c33c97d606d3998425f32b30d872b6e5e270f91434983d49abd76f22b8ece1e906faca0cbd5f34d03749557993334378b30ec3b353ef670f6df57968b39a9e2eeca5a8bf23ab8a9f86691b60a00b79a06d7680307d5e334d54dd79aa8c7d0fc185928efabf10c6512b2bdfc1dcc56b04d0d734c86101cf20cf7a1ad843a64f8b02bf7381e6d21b786c567ed36d394c13d0b8ef172b8196d193acec7a57b2768451a08d5ffc3f804afca608cf6407cfe10020f375918fc46296d8cd4ec92e01f6bf16801baf380da1cf5e96c3f3e65242a254bbfe6010bb063c3b924e0156277a7b9b0736122a20ffc0cbfd1b4f73350cfbf08d39081c2688ea28cdced03bcf56d10f4091f8a64c4d02711797286cced546e66bbd793595bb620756daa8de44c1d290880c1e1e1b6bb8982f850e791b97d3823f93f052a4857f87b3ff634a6b1e421c4541bafccd3627f81e49963952a58effd96e8aad6affa6a786af5a3fc315e9f8805efb3d234df649cc879890500054e4055316b7e43286207500e0517d63ce2ee31c5262487971f1c98c39406f0e0058074892e1406945e93b2adc6fb11d6b91ec5c87d2416ba4f6c9c3dbc33dfaea9947115a0d0f58ea086d090e5e8254c2ea4b98d31d9b7d3c5ad921f73f9dfcba6a3e79dbea2ec9a5f9bc2d0c942da84f45d52075ca9a456dbf3994e74763217fe1a961706c0222be14e803c1b31e0764b12dfb7842dd9ab23d4d490928dd1f93bd833b9e1863f50e336d7f2047de4d44f2ef41ecfbee08e84030d7f9a1ff28b5e611ec1bb6f321511bb742742d945108628a045e0429fd9862a5e18e8c14a10329b9c0dfd020b6d1b15df94a3e935181a7f13357f5f7232723e7481c3cc34482ce4bfb262065ea8c4052f9f23f0390f855251db7b1e46fb4d4a53e56ce63b7a03e7cca40d3b6b8b92e23fa959e8c8c1cc4186d3bab81cd0180e242153fac2c52b14b41969a69cffd3507e616106c9466dab5bd4dac69d557cc94db1a180b3203c645ae1efd3c44920f1872491f90af33e23072477c457f5a23d3d99dc337f9dff93382c6b0c20d7db87ca9865bb333af2a99551cdeb0ac69921098cfe566e923e5182e2001787236236a9e85d4ab42711ae32f6e7996a0938c1bc0020284657c4dc39410ffd1d4351a8b31da1ddb856d734d0d14760af7794f5ff709df25dec5918ae27bebac0379561764c2f2445edc9ef53128b51fd59cc204eb01beb0d6e10f72bf43fe7986a3dc8146a2eff8deb0cafe4577167f834602e581f80f9f9f478fffe141899fa0bd0aacce1caab4e4c82b603b1db46e6bf68d7fea26f72de0f2fe79a8c79a727b7cb086ee131c5bc94f05960f8f5d79b1ac396b93f36cbd10ff469239ce1b573259947cc03565a8d32ca2d860f763403a8c884f8a2a47ae4646c70662fd348f36e9e615c67eda5829142c388c1af4d2cb17f5f3a7366817eca944d3ebfd2aeaa8fed6033ed74e251bddd1e862494bb6ed4039637b108c0cebf55293254ab4d7b9c2af4effe9176c0a3b1b6770865bb0ec3da3baf345385901cc232652db335810056344d2cbc2396b0f1436896add09d90185db9a01a1438bcd117974385005f5158d4a0224238038812efbcd2bfdd96a78565f4e93ef5679f697edae2d251bd3a0ef1a433da4416436337beaf191d6c3a9712aa55ca39f23a1bc4f09cf523540f25149b2b8886d204d53f2a373bffd89ed98d024bcab14247c40adb6a58e0d9b9c0b91cb316136dae13f62eb35bd9831ab4706340c83f321a4e65c520275cebe366783d174c5ce19c3febcfbc2c0071ec43b394d16c9c298c7b156b4511e69108ed2d2780f14a0429170b88373dc661ed3d2ac8225cb81204d01b07f4706f616570d8cb7d3c7da70975813359e4886cfada0202a405256475e1154a39f04bb2a24efd1f81c553a1dd6021329497cc931ebbf2855d0242c4165d885a23fa9a6ad4e1200f40357393615d02f7fde5ca271a603ae600f6997069eac20d7e1d1a574c8122439a62327f1fe006aaa2fc6fafdb3375e90b47a030d0b57d74cd68d007505f16c8cc4d99161e641ac466f073c70ee7caf432a0d42911ca6e1cb3c7f66114e07ede93973625e88c9efa2df164fed62b0ecc07b4ce44ddc39c1157147971ea7180bc86a585e9a94bd9c2d4824a9eb8f313d86749adb7c853578ddb0f3ed579d22d3ea0f3f2e20374a3299fde8e6453f9a0cf90030bce8f236356854a39885bb1de11f592013edf65d5ea7be58ad5b7029d45547152bf47853b7dee5a397fec38272cfc7327f1b6983c1947388d9396ad76ef275be5cb820acbf333d39833e1d253540ddbe9fe0a6f9d433a2a21c9e3d4dd6fad7c799ca176dae0741a27e12d82a0ebf6dc289d03e0f9583145531a57f88668579c0e9116518e161ccebfb72963e3689c380ed6b67a056e8852fcf210cab4459280a5977b4eb8461733672327d7ef55f4a55f05d8593f05fb957e23b467066d80c0485f36e08b9779142f1a3f39b540dfdb9bbf5f4a3bd8989f190eca5554648b18b66aa9886e208434e154a6e65d3e63910fe749cbc48f03b72fd930b12849d51b65d3cdea7847475de2145674ad5b0f2ffab14c47e07f2d3a2eb60c6f376509226c9a9daba35d02b5d33cc72db1bd9895467b4309b7dfc80af99d418f3ce9b348589ae2033a0f1f404d03f0d6093e294d7a373d32f8adb2406f3230eb3946b1763da2a6a0c88d043aa27b2888587c4d9f92d374356d5d5e67601729ae6c012bbee8f7ef7b024ac57b587c6a2cc4aeae58e291bfe245ea4792f76e226c865f843fc4593cbe6e54f0f618451d939a6d001fe4603ff9b5045c28072f05ed8f40507114535e48b1a7568d50466b8d68da6e53f0532d1c78465425e12272647457f867600978fb151e76ee6984571f4ee2adbd72554116c2706a499db6883066d7dec3ac8899783a0ba6fd7fbf838307cbb0378fdbb06aa1c3ab1088908ee5af9e6eb9caa180b649fb4d46b63d70abd5c590081267c6a6d566cacd15e4ac36efe849f74a96ac72974708aec96d627ce96e994e873c7741fc5cc00f0acbb1f31ebedf2e3b255488f93afba37757d35f087abfbda1832e15fda2848768110c6beb37a167046850791d975a71439b8b9a41776cc71cc1687902e7412099bcdf3fc3963969e96a177c5905ec82d3a0953eaf64d704c2dee5f466e1b9f4379bb0440aadf45b5877e07248c1e76f5771be8c1e3fc80ff7afe9cbeb5e153f8d010287ffb22e23bf2ac68160b943ce20f64690f0f66de65be24c1a297d3151d386b526fd6a3030aa231e021dc4149ffc3e9d09937711ba7372ce35972f0d1736698a8b8f4aa251ca28db0da35a637616ece640c29822eaf94db36da26963f9d58eb9e84a9ded04def7ad36c208c2173715a797622d7a457eb1e2f52cc11a629a5673b8d426a2ec68707f026a56b9d1643b0baa420ffb4b6efd612bebb02eca8d5ad001d2cf58e292878f28c2923b0b178c9d9538b4979fb616aec72b42c72fa7fe9fb964326136360f64963f0a12940da0e937a88e35acb3973509574f628a25466a6c771ac067053de221e69ff2141dfb416f58c26a27bd65412558d8e3646bc551889f09f3c1e2c30227c48b3fb013fd6698582881cff66994b11fd1c9e99b596c22839a9bf1ff72f6ff93827c498863268558c065f9be317cab1a2e22f73a7c8ea23713c923d47e95e5d8f6501e45291ccaa68b8b38697c4c1d91b05e8f47a7bf7acf7b4175b60d45095230fa56d8f2c305ea0ebab438a43cecc3a0a36075c7d1cd6fece5f3f69e340a5d9cc17ccc658a05e4cf3babe8de4ce7d8955b494ec8501e2de4e05e93f9fd011b703ff4623eb3f99322f78dd93ecfc0fd0aeba1d06ae6fc378622683430a662d3cdd6f4bdb53e03e27ca23ed4d3a19989e41c3e18ac04980b54530c1bfa35da5dc71aec1a86387c3cdf4b66fb045f430096eb6f353c17da4a9226a88d95bbedcad2cb9def5063462f9e0584366c57fa3f4017b83446db1e12db29be623bfe88412ce7b1e8ab63ff8ac99ffadbaad49cd8fa0675ba0e4c3c2a29c9c8e597707bc6aceb8409bb943f3f76190dceb8ccd048abb1b7ce3102d75647e4460fda24036f5bdd109cac5b09994e0e56f999a7ffdfb81917af392d28f64530056da4d578eb03155638f357c84b2994d145fbf9d478c8c78d23d2c94e9ec519d49119d08175e6394620d61f6199d41297e1b3f170ab382c46ec94b509c6875bececb614a1d2beef9e49011ed2e4efba4154807abea846cae7a4ee848e2837c568c3b998613d01b8c5534f4c2cf2c78749fe71eace73424e80435b8106600da384827e86e4438bcbb0d7fd9c83c3a5e80137035229a5d9a33f59574755635567accb5eac4d430ea9b27a3b937828ffa6a0fc849273e4585775c6cf573b519462059a8414f3f3b5661fad9a378b88d982c28981c0002c89ee36ccc3aceb652bc4891bf8bc7922804684f9b7f16e58b6c646b61b478666c254491887bfc461b369db410cf8f5026083e4e96b511da0aec7601cbe0761ec11d535be0c4530c739a22bdf53cabea87aea73d18c9b6c7c75c0ad27cdb64eaa60644a31176c00ce8287026a62e6b215ba0b80fd3002b97a3a35703b62a380540709f7590eb239be3244def104d6714106b3f663a136cfa30051669572896f9454be16458bb2130aafeeb866f2eb6021915a8e34e7825f63d1ebffb41d91a0d157535c980d88be10c538b35060f306707e0f502a93861957c21dacb11734424fe8aff1939c5a747cdb248598a06e8abc93e75d7d3c2f74650bf71abe58387e2cbc300a56fb5665027a22ea5274d7d94434bf90d45d85feefac6a187ab812e04690ad7a39637253e59afb3edf2b7ee9f51cd8a5e2e9c5d06190a2543a87c365910f77b4e0fb7b64b938fa2fd618c15e5d6b52ae87216221d5757e5b1974de9bba434c12ee9746dfd688471df10a95ffab03d2da6a7f4a3fa162e2b1c595742b782bb0d845d3e616de205b455d072c62c24ece05435f7da8876c0c5996c2df1ec30ef0ab0def3001bd1c29b2282a8043657ec56db8360035107c55b9ecadeb03539eafa8e3a087ac852b5b24bed49ab0eab0cb6afd7035906eb45cb068023b821ec208bfdf0564a624806ecc28d278e84926c57a3267ec0a450b2c04169e1b7728b05ede377abafc6501e09e53b8c7591bb665b38b00802b66f02042dd0f5d087ea9b73b88de01fbb7b10600b0f08a856f285a70b62f78c3f1dcb1b59f724037729389d342078e264f5d97c71f8cd2d0e287e0b741d4e2abaaebbb16500a775dcfa131f8a826f32cd2e7fb4e2747708002f2e6cc26d5f18f2068884ede00647b305c09951fa389e2a807bd07e62dbde8ca1cfab7edaa6b904a334dad6289e44a965d0e07477608e688e66eef2d9b6297b9ce0febaa891706ea6c5a6c7284bc0bc2f392d9d2e51f2870076072812d9c883a0c02744eb49ce9fc453d5ddd574192cb87139d2017faeb9e9406b2c7e257d0ea52c02b6eb1733e54e6855de48c2752ac22176f36288e6923672c4055f454f333b2e1bd13ef591244cf7045f7b8961c487ac1e4101881bed1da094fc7f00d2e735b9fccaf486f393bbcd32b21e227dfc8a6c97192df2178fd63ba9522e7ed4d8e52393e275a105a7958d60844e36618976b6e424c51cc84647c01da202dc679d251689a32001e7e411fa8a408f40eb48679e6b3606626232894fe10602a55c72b8ed9f5bbc28e61c344c002437b9361898710bb8b6eb0762173f4753d70ab179a48f8aa5dfce9d282b5624a4dc8083b4912f2ca6d038be0a35436766011d68ff93488b30f2536068ad6811bd0acee084ea2961c98c3ca944aea6c9cd6772d723dd553702bc594ab51ec09143df4da47da237290eba0f86d11ed62b6cc8da48a46a27bbc0c9e45bcb3cec42273bf61c7398b5e2d57c398daa2c5bbe85c397dbc2d5ebca91639a474eb516db31efc67fd83d2754acfbd6dcf612a1d56afdb03bfcba44b080327560976578e6a9c8bf9788c5f9b4044950baacea64d961fa8a5d37b2bc9d2bfda6acaf9009294fb2daa7898f8094a92ae4e6e816612d2581b427a00cf616e820ed99f9f5985593a1a7dd3c3d4b2c3ba41e3ffe12a7ea3710bff147bd82ae2765452c2a0d226b2ee71adc6ff278178b2546f5d83a222ecdfa1c8f8451bb7fbe89afcf38d806dcc6b21d247d8d1d8b0270c4c82dc3e8dbc10ed27760d88cf2c1d80efdff292d60fdc6a924a51faccfec5caaed1880cc19aec995c8777c374a2ac962a76459fc4ae45cd2241865e357237ab8f231c8e59de746b2245c83c472b6c80034581860909b50ee6cf261da67181b51f8ceb68064a4bd23d4f38653bd2f5af77e9cb5308098c2020988f074086b850644d91b8e8e04cda4e942de14a79f64c8ab55d809ca12ab8f3db777712aa6483ad574a80addccdab3a6d02f58cbbee3188d96583fb3215d0e3f16a5d53f4d2ca052cdbb2b92f5d4c0d16d678d07f77c4d6f671062992ea18f224dc5699722bd13f06613c3e47bba9f307fd2bedc8fe4864c13b7a3b954edc6b21e753f98d7f82b9749a8f8acb288edbb074ffd2be462dea38316c885bd225551aef52eabc664dd065fc75ce57da153d9761c924f86d76f874235a80189b208223a9a2903c4844ee63472c68d8c5a20f5bee73afe3e2b9b36ece69f87b733c22cc1356537736ad90e8a60230de3efc31e2867902e3e03e89b9c49c84c613fc607c20f1e6ecd3a57de10bb8313e565b14da58a03dce13dbd99f0863ff6c2f579092cbda726455f6633f9281dccccdb1647f41c3f7f8a3f8a0dbf18cf5c6b05ded21e0d6b0cd7e6174ea0df17e9288d4f66c46e71cdea236ace52834435234fdc113df0ee4af749acca3e23531d8f30de11c77340968025fd30526a1d6ea7e6c3e3e5c9f768f7c1fd08644a133af2feb4012349e1ada020789bcb4c1a4d1b4fb9b9df6490dbef35353338cc98b19b65f178dc50130364deac99f20950dd14000a08904dec77f6236b32cc94084e8993cf76df7bd7a7bd559065f998353ab5d83b80500e0de5666953e58786a264365f520f74cb6375a5e7432fb2de74e19a9b1024b13cfa4fe79a40eceb325aba7fab708e18c190841688daffbf186d35262e3521b0ee65f0200248db7e4a0f610e5ad46ab8ab544718038fdf69421b96a0bd2e13799681afcb235e33d037ad7516969b1792cdf5b25fff7b998b996a9457388248878cdbe1b192041f6288931a449f6335ee7da17aecb43f4af068c07668bceb691140822906a40032650c7ee3fd13f0827631096869e262a5f6e88afa5112c3e6782de55eeab4ab5bb95cfd016c18fd63766e4e037ff9bb511384af8c771d43704c4a0d4d671799ffbe671a0b03557c0c7546bfe54f2b75be626aca24f14d389379ef241d5d2ea181c07a8464cda55be94af98b5ba2dcfa10f7d04597ffa25b5c6f95f15a687a8fa65dfee5a2d79f5ded1eab16e735f267648a89c42f3a76ce0a941a804b6cf94a7f5d94b16f0e3ebff3c4847015392575bc9e5a9809b4130a587b54fb8e67338bbf89fabe43abb4f99ba691f0a09df6788e6d6becff8013eaf1807232c3d4a3c82bf8366906214e166f6fc2c2168a6631cde8b71c4ff84ba80ab05163f0a017597c649d77bd0f1571ac467671018d7b1d8f51876f714db366508246b860110c35e0ac9a7369950e2dffc066af5d2ba6ab9fcf3ddc6342a90f93186f1a365f82d045b85e9336d6db513be713edc42ba6a213e0501444e4a9bacf3b4d98a24d721d986348f788dfe37f748fbe0295a8c9d84a3459cffc4cd3daa1d0e34a10069651894126219d573036df841b5cc192c0803faa0b32c8222634f159650ba0af24748339d9b45a673b996fed1c24e79bbc87c900e853fd98bd745c96bcf8ef558652f708d8bdff3e6d90a90c2875900722f6563916d2deb7044342098764c46f315830f594a39bf73b470f3a7b57bac38c7b5dd7011ffa9802b63156f294d0b99714d566f803ea1d6857de59c00e54d54436a5e7e229a822f6d3acb01d3bed38da879e0429c62eaa7f5ceb37053db1d99cc7e54541b96da5f27cb54732d3f8a95a473b6a74e4f63f2c3524c05e3196bd31f910d5bd1a899628da33c99e79c1104e197c70e6172477b4d44972b7d78f815a7ca401abeed69e1bb83ef7c0d9b2a2fff6e3f98d5fd156e71b65926760d790de3bd8ceffd824521d4110f66a484049c60ef77956ae9ad75803fa0296eee7f8301bc837cff6960b5b468170c3c750d514fd06dd6a88fc7cde0a731cd7ecf60f0e0332a97bed2d08b554f416f7c628d8e6fa1607b30b4a17b5dd4b36cf80f4c394ece029075c7104aef776512b11cb6ce6380007e29c6b89774e405c6c5ee2ad4f76956767476a433049bc748cbeaa3da00f1a7250665fe5c64d8d05672946aca94d75029222ca39e496f7d7de089d30dbeb33d58a6cdd0adee38971c386f8d8685336dafae44115b1869be13eb9f32420aaf60fdb99a6183d8e99f938ec37e24f26a11414c9dd8ee6a665a5d90ed26f75b571b634f689b387c7b635244c328680358553114098bc9776a61edcc7d7fd98c126e793b1d32d15f9aaeaf9900989e8eb9aae8a4f82b40fd43ad9c57ebaffc93cc00023b41447ee2ed6e9735077d80c4af5f1a54768229713e14049b5175d2f6c38689ca737d0df912ca2c3e134ab756267c6d849868326597eaf1aceca0b8b51e09ea79d4590c7441a83031a147172f3c162bb6b89a57bcf291c36e30fb72970cb2241befe41805ea66686d0662a3a6d930e8ec06e4ed9948ba2c91bf7fcfff37fade6c1c887d02335ca49d39663fa8cfa356a4dc72615a2e5796f65691e54ae19d855f8bb02777592513ca5794f1dfc1996dfb3e517cdd421fd8e3ee027cc43747467430af7a421d2a135f621d75487e3f156a90e0aecbdc91596621b0ce53e84669a8909aaef40ee5849948eb44b3ddce993ed864cc4dc4d65082e436c93a6c7a7a8a33868ac45c8e5e983f13d5df7b38317fd932165f7b4af4690dd2b916860e5a0c537d25a891249a7539fdd0040ae869580d50b0efdeed1af58a64a793852252bd030ca04ee63e068f2eb79876a912664caf2df8782292fb2e92cd35d378e0956fe8195e567ea30f676764780d84714465dbb7166c3017d87596655bc04ec009fa3a4c9306b67ac6f2458619470c30fe786dec40ae964cef000f52aabf24b79113d1ad2e6fb37ef11d86e6160b3f8f0cdec884d26906c067b4ce2e49d7665b2244ed7422ebfa6e6b005895662cae0ac3a36532574fab213aafb1199e457b4b879fa26657af18ad1f854f903c2fbd3202c5141eb32c70a91835190aee7f3f71cda06d73bc91ccfc447f601143c474aab80680d2187ab065a0efbfa7122ddf233b9b1ce77af948c0698cedf4de962ada2900b2475440fb579772ec59c0dc4222de0f7975b85b3fadfa8af171a553bd9317645d3c5e1e6dc91ff664a3d55e6449dcbcb77f6d253b83e6fdec5596c3a458c3d8ce66f3e10764a9afbcba922f35378eba30fbb3c3b11289c997888fc671f1155bfa2e9a179fc77b6a9a2219070d3f1ada763a49024f141ff21bebe30a365cf91c435e8c8753a746fed74a28f65cfd0e83583801ea182695c545a5429c073b19665b335582aa939d541d9dc090b39ba8ddc6772997e9aa6ddb820540129dc58344f4c8c6a126b85368c6af92481227f6b7fd28191895230eb8091ec1b87969f74a59f115985d3dd218b32b8ed7b18fb06c0e8a827211e01952b59805b1aecc8d4729dedc5acb26499dc24304df6073c12730d6d32a28e682c54b81c22776c9da8b601d4dbf1d9c3541aa58c4e68384003e77dbe77c5e11e9b00e4a0b34833f6088876ae38021a7ba89bd1dcb976c26a6b8ef49cf1977b5b88a5491bd070e726bb5be30e3e5f49b8db5b6b36f200c670efa732c6f187a0fb38686bff47bebb5db219ac946e904e3978bdcb224464ea152897ffd3ac7580a275be1649c98fc827e9d40d5fb086ed1f715942d8846998314fc34218438a921be15cbde48acc8bcc246af18ba4b2321358af357d0061aab8d2019ec6e289371042521b6cd30c8895ffd0667a35a1c1e0c946981714e9b1a88a32ccc27cc28c04648c0e2040abe3040839eb754df0bfc23d6f1111bf281f9e030c3417ddf9dc967c6f0cfea289d9ea64e48f47724131d2c9e50035dd9410f0f644ab033e07eac593948aae5385c8141ab1902f6a2940538bd78a96fab8124e5216ba41610932dcf4b78d88f1c69de4cc3a0e17c40d53c6f28a1bcffc159e7b27a0790b5f9e755f835058276c33da026ad585e44b443af7e8757184b1de3bc32e32d96935371e016fac79cc70dbf8942bda0d477aeb95fea0f4f7463a3d0d16c9cc13354c3870c9e973c6cca88ee9ce31ccced9610d0adc5a8f12334dd8dffa94906036943b06733bc83994aa9a4d6c8c930106589138c3bfd0429e347866b9f2bfa45bba318a91aeb8e5a79a44132d6a63b158e6e4385b1270150d06469f248d5334817f4e7446df5a414dd62495a0e4bd6c2c704489a0e6af514fd84b7ea6590793ad251015c8d57646bf0e07159efb80d7ebce04f8457b5ebdd4e12cb726c73e249ce9f009d7ac21b2f0a731cc787567b96de8dd8b832c5bf4aefcca6879c6f0e06bd2702b83d9b72519ce299c8a16da25513e6cd94d8fa1da19c630e77d95e53e8ee823b38fe089c3a91715aa371112eef0f2f9d9fe647c14addda303530d15fe29779a1c75a099f8f19976a290894373dd6e9885f39e11f7192bc5edca394f2bfe571a3d0f88fe84fa57f9ade91f94af6ca4957872293cc9f3a6aaaff689441e8a97dcec20481d0dc5ffc96132207b6eeccb1137cfeda3da63052b49e1db64ca6c8e295bb8b814190d822e1288a6cd8c8f1ef885730cac7f3f2a36e998a646b03f5ace2f1bb7bd4710f479512e0282","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
