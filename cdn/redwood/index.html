<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e6c53ee5f5f69e847d07032e85a136ed41748dce146c5eced87132341c639915de42be051c1df272deddb93f5c99198d98e75eacb0e06efb3dc33b4a54d73b08502e180c09d9dc90750db7a130b51c64359d010495955d035be0efa63e2a8d628d9a7f94d69556e799ffae2a53d8fb8651a01e6ff8fd6eec22eee3cbf84c87d9d739cbd1ef51847da6a66d8bf8f1c8a01a305c714da82e40056be785fc5c4c6a70d70586834a736f1c447b0f4599464e010e26cd90799d7f4e87e2aeffd72e3c894717797138930b79fd2c25f27ac140d92d6723f4e337d946488e8f9f7319f45235027b1c4b258b00e60540daf9e85aa28efb1c908f589cfbf2061a3c04d98525167273cadbabc0a8b5a75c1c36b3b5c984c554ab94b03409b478bffbf235804b7011edf583fb66307c796935fd4e0c732748f8a763e0c1f1dc3899cb42ef760fadcacc79147e17036cdb49725e2ba37fcbb7818e1b2165290f1b0acdae4d4c4899fcdb8ca2b2473faaf139c3957cadb875141a0249e83c3036ab6053adca0638624c2ca3054108e58b00a6886e77632f023c6ebb88b880df779f6eaad45691a35f57b51358825be8324d344ff02dea6c08952df5bbffec9ade2fcbaa1a5f06d6c0cd94cd4d565efbe1d436e31319cd297ef9ea892cf42a17b91c60d1a00ede2c6a52820df54f2d7358a50e7df77af4b4cea2411ed506c5ff4e3b640c2ef643ae761337dab93a0a3d3088159d303155a8baf7861cda55c7adf4e503330fc892a2c17d72f14aa5d4f4c2f9a1fd4a530fa02e977082bc45a93c6cf0b508a6f1a0eca52a95de9601db013e0d5c447dd9b71b4775fe9c9808477bdcb84bef6a7b7c307301ba084d069665968c5222fa9becfacb1f74048696834bd0bff7e96eb5b2cdba760aa8caa3e20ac08fa958b8bbc8d5476800aafb77cd3510b011b0bbf95be77d34cf692c944ec9678597796b083ef444692a1f83604a717b0368d98c5c8a3defe96a37cb1331891a30d68ed07e3fba981c193be972ec7c12b3e21ff0d8f98de16be2ff2248139f12fdfcee4c82f3173cea44094b4c777f065f15a03617362a40129382b3d0265511c5a3b0b699afccf7f85b800f9e0b80eac80f79c90fd0fe75ee51603f919a9d3323c0070a39087bd95ddc966f65653d3e0389a91af20ff2f85f4d8768529a9c1e9df671b77c459654eb4701d31a58a0bcc292c4c32b5d81e4ae3df1c45d49f5505edc6d75c108bf2d0a82876bf9493c7efb900d0e4e16aedb8d8fc2d639ba0a0f62bc094e82c19cb6b2a36fe7117e584d4d714dbcd2f9f7715617af956b997ce14e6c4b77f2a5c2d75da2a7864d396f4631f38570680a87efdc407946d323474e10d323a36630773db72e9626289bb77ed9f233a95c2d99a0d63bbbab102b8d4fc99b9316a3e99d8a68b119c8c28e390baff17597691aa14127ef29bf79ea06fe48a90ff92341337a5816ef69eef0e4ccf1a6257fcbd5e2cfbad473bef0dc636666d2fdd174a3f963c3bbffae20b7ef969beaec2df71cf0d2ba14464885fbceb78696c14cf44e8426703b36cbc27966cee3c18d7171bee9620089dd71e992a242c540c48f77e8155f2976f6da0f777a3a3d4844b86eb42846dc51165def05e926c5281bbd2624adbf89b3552247f0b06bd65240f9a4f049a7ae219564646fb0bcc118e5ad1b8fda3d442f6b2fdae36455e0c404933ea8fd8276ede2742fb9d17417025fbca358fd8f6ddbfaef6eb8382a63664e7889a4bedfd0372322781b2ef099d5701136045e0ff5fe01860c3ab34c00d8e78d6d62a3b6e5e6e14fc93d2ccd04648fbae6ce099125ae11124d3161a34f9cdc165180691c57b67682d8fd504833724fddcefa91a07959a9521dc88460563a9fe0b9962007cdb03f60ec4f01101e4e143316e25310233022382262c95541cdc165d7f9afe6c55a745aa0d8448ee15c5e6b8cbf1ee09209f5e12eab567a384611c13afd1ebcfbdfa729a9f258c2b4cb080143393ed7d3b91aad9797737357fd0201cf9c7572246a8d0ad79bf4e1a40726a12b6fdee7101da1e8cced1e8ecf3b4376ee5414cb65c5e4546c070daaf95b7a0810181ff7c02b245817e4420fd7866072fbb4cf5f5dac94a5619f3bea22f195165a68795be562017c20a88bbf37ad1bb89d939c3c1c063dccc011696a953e84f5899a3a1a0f615af911a8dbd3dad76905fc1a872e74fe121b65cd5c88454f12c8be60834d535ecd361a4e7e0639f70918f34ab916e299cd13a3689e5d2926d3055ceafd52e737331ce6b638841c3165ed54c3df286d13cc232ceb21401501357d4114da1046ca59403cc8a75c424f521857d80df9f9ce9b0d80936670f8858dfa26815472c181e1f2188561a097246e3f6578e0c247438f6632d5928f4e97cd597ddba876a7b5eefb655ae93eaa82b296754583be1b0f146a47847f96ac3f13250a2e7545fc824a9525660eee6cc7d4ffd43fdc431aebe96a66589f271f00d183211992fcd803809d441d25cdaf51f654188d2550d58a6bc28e8214527590decf26e1041e9b4cce9777aa2860f83245845f232fb68a7d277af99ff638649436352231c6743ccf487eaca1b15fb64d007a93031cf19c8b67e2750e9488f105621b6142a4edccc2b8ec81e64d42bbb9db2076888c0aa5834bf479dd76c33d4da0b804d1c7c6c0a7892978726af41bb8427a1ea3dd11cdc421c6f9f1a4dc097e1dc49aea69168c1ce1ec4c837db05158d47c43f60592e54b5e20aa7dc2ba4a0e620312ecaac551087dd69728f30a3c6a9000d277f80841772ab09bfe685b2e995696231f59d66b92cf5098df9b77175c77273b293580a513b0d619166321a2a6c12133149c8b4c1ce53a264557a433106204f12b2937c7c3b4e129091e7eb3b7381bd9acc366a62b6bbf071435f1fa664e21802a484f0d3b3635c499b68c70a473dd63cc723aa712ad600181a04945460c827178c09cdda451cf9696fba462b0fc8bcb2dacd9517a0194d539becad413826b07beb2c0c4e923c728d930f6a7278d2d183a7d61cf9d99df26d2fa9f554ea5b8915e3f6428ed290ed28c24ddbed7682af168b8a27ae6f3c39f442619ba88e38bf5c5a9daf291ec4bdfe7a887d44bb74bd3ce9b555b7253572c563ed847d06d16d97d52fd5340f34a66475458c267d75e5367cedc2d98b64f7183a145bae0c081b62dc0fdd8c40d56634e2380883707e1e905f6f1d2bb2a96cd293749914ff2f21f8e7944b3db21eab2a9e42cad3f43095eb82d11635b508bf60bb5377bfe59e961bffddf18cd10ffa382fa43e30ef463913e372b5447a79643aac8f91db47e9d543b6a418da715361c682854421b0efbed9e9b0804f260c1a826dc8fa967ede7b22131e598ed19523527e707705f785cf5114a520fba2f96c0fb44143b1d814c9523c5c30b2d7494ca303ae2e58e422017ac3b282ea9eb5b302bd67b571c26cd26b89c9e0ce1792526a703d3baf127daf5101aac9fcc62efcce5dba18bbb29557585e5a633330ddcf484e2cdd3fe453943fdbc34bfd50d7fe086f2e148c08bb2e08f36f432fdf4d47a648921e217b0af835674cda332322ed0056d531695b8a9226df21c51a192d07e6f34cb814ceb91c0a75f341d422ac75ac44a33b89cdb390e63c5dca7e445f22d73f57f33675b624010d1c0a5423d74e5db3406fff1770af2cb38c74da6fad8fc270242495265dfa38b0cadf7849af41a3491ac1966b1a591b946474786c3f6974902773f7dde9e499414b43d0a5d3770e2cf5a13eee772d562b30f51c71f6437e7d94de7f99dcbaf06f7a941445b6f4cd3a82580f376556986002f4f47754a33ac58557621e6ba978f4836a3c8a3d53ec3b74c7a713bfe83131dba7772163490beb0c54fd07385edd479dea473d2d5077d88dbbc597171ee6192c2aecb7a2b16c0009608cc81d0210f2792a53df90e195d07e40b35a133687e2556a1ef4beedeb69cec2b164107b81ca52b212c1067ce6c9b9b3a900477d7d9ff25c2053e593a6af8ba0d8618b88ca96ef244fa7dfdd38d40111f874d10e50c4726f4daef7e46d2772f89e96ff750a305643e9148248ddba39679fd0b89bbb7772d52a089ec787473499c58b26d68f639edc5464a1005e26dc06ef769b32e106bc27719c9592255724df42fbf213cad7f9ae915a8ce498a126876886e55a97502c4bac36f1ccf8150eace3a385a13876569cb1edccbed2b600767ecf38d3bc5d7a8f0200d41f26ec7da7969e3e4e1f53e4bb1e2f1468734e18b87f1f5c2768b11c3b3e3710f3220f9ae667b0d49739c9b74250692896633ce41d3df071561d3ba5fa46d94ea16554c20b9385aab0b54613d119d4d8ca9bf8943a685bffcde1feb3830a19e91dacb5cc5c9996edcd71a736b40199e613785f2458faff3bb8fe64271fb63a5b32867c1776b13d8fc03737c83da285a860b71a0e599b372634b2ac5057c9cb804553e8e8a2fa68ba2bf271c776101f5af35030275628dac2e856d2a4dc1009320502cd22b7f59c71feb381185c42a073d5ef0ec202f03bfa5cef0c57b1f1bfd8266e487b13386ad981f4214790d84613e5f5ffc8ab954caa93f127f70d4fd52048e48d820e77657c8ac4fac560fa565acd2cba8e936193b6df29e0140af2a16139ceed446573c5d5292d8757c24bd3260f4575743a09970f2e7a22fedbbac9f2252ad04a2c8118c03feb747d27f7396c55599ca2ff49d033f0220e3914554c6c7a7f5b64547d16522fa14d4d01f2bd8f228ea2bc8c825f5b8a37be81d413632954b0adae56d4231d80957d2dbd8d7cefe5b1336318d543ccca59e4c85d22d195260db20c3e5d5e393b770280d4cf9eb51624056a4c9358eaab4982cbef0876ef222072aa054c32b2cd67060838c1f05475c50c995bf5d854384e4ecd4fbe3c419d7575e47c762a495f58807d1dbcca912fa51b57cecaa67a981a8c5b5a7ccef2d0f2acd08cd49dbf14a2500a93a006a8bc5a9cb97874bfe670154b700e29ca0ab49db708e38e7b3bf94af8985ad8783e1b8e9d20f8f7b84fb116887f7832bcea0926ff943a5acbb962f8b8714cbb45e1511ae582bf822e23b15839660a7b8c078f998d29b174edbed447cbdbfa9042f359ad96abfa130c163db7ffb7520f2b492277b026ceb57bf817527792bbb7b061c4592771a6ff4836871d2fabe54635ccd610282599ad1563069f9e969356310875abe7454925e4145521bc965f93464fac60702b42a590ef244f4dccb4352fd12d229d92f9f89382aef535ef27ef3218d8ee50e026a361243f0ad246234803be3ba412162e92707b3e5d80a07cb53f802a792b2c5c42e9805c173c183eb24f88a8a6b2eb8de286174c880ead08feb2f822ee07edf557d18f9728769d2ae104aa9a73df0871cb5a769e863fc30cbed3cb31eba4296a4c17aceda862c678faac96469a4943f0c9b3e61266a7092c89e814b69b59e03ec74effe8d5e24d20c3503ba7f8bc9c4bb18009eae3064af68dd72ab32613862d514312fa506cc77ceedc902d6ca1b955086176aa39d2c13b06b2801cd6c6ec2000e6e4efbbc4ab5c365a586a90dc737ca11151db2c32faf8301cba42ad18e31505b375fa5c9b2f1ae7bc8e8ca708df24c34de3ba6d607060bb9d122d6e6d51e06f75550f58251aed1461a803471dc583278b9fdcb7deccc3fe1fc07b42537959f405d94b421322c682c10701e7efd681d1c1d757fb209fe569922f26f49064aa001c6a55a91893cc62140749473f3310928b0eebbd970192b21aa5528000256ad1e85ecd14964f6b65b0eff9737a78470600a8b26634dfdd14eedfd3dcf77cdb2395a270f4d6afdad10909f13cc2b3079ba0d84c511da3793642c07ad7bfe903eefd5b68caa219f9fc36942beda0b360b04b48688d4ed90231be9b2a4ad9bf0a3c82eccacbb50df2e34fcc80767a276d7b72ef41d03eeec9106e45be84091bf21c530c850728e47135f596033456f339d4f161507c018d95e4ff76b1d85898c6407f2f9203b39d548fc69da87a81f5990c584bdc3a7648a122cb3fc7e828b812ee2ef9800901485f2411cb7e4cd2f8a580736c25680586d1cce43fe47bda602697bef8792b64bd531a8d7b71b43714f1c64e3937add71237739ee0b45f1e3237923f6d11017edc9cabe8b55bd4989518aabe25397ad9197428a8c8f60672088602fa3c68a5afa5fdc0b64061af0b55db62a8c7e7245fc76591cd9f135e430f5561fd77f831de916ffc3a876081648bee497b3346e91763e3018b2ca8fb84d3740ec5124ebae455ea040e8a29df99352814de8bdea9e9c35d904966ec793f74ce6e78bc902dc3eaaed98fd67555099ee5dc6c4273207f51ee792ea7af3e5e10c5a0d6800bf94d363b0a3d5a677b648198db49c9d763a8ba706e33daf50766f6a2a6d88e0e1cdf0c832b43839594a0135abefda388850ca607e9c38d99e7e9f42829beeccfacecf6fa6d64d45e55381c8e63767963dc3d2b0ee0776065c8be1c7eddcca58e2bcf46447eb4d8d6ff54bdfdbb501e1e36a048157d836e641762fbdbe459feab52e5a3b37f614ab63f2b69606218370d790c8d9d4e5ce27e1ed334c2d9eb20746f7cbfd1bb483919252930c725f7239158765d278ac7e25f89ff7c6cacd8804a3bf7725bcef87d302f786837983a349f953ce21a2c6e9ce5c91afcfdd0748520e6dccc5d74dadb3ce7e3f31924766f560e3f9ad773ae5fc73ad910d3d55d19601f62c8c7a569b81ab0dedbbef8f8b422828e878634f6be3f2bbe9234370ff093bab4a3e4c43b80e72d28497e1a7310587bbce5880dd23891b3a44e5678ab70956b3ec35242b67c42c94deef64c49135624ac57c4425cc0b91e4a5d918ceae5834ab7df05a699b228f6a0f84acf8415a646cf842b65cc3e804aea3fab25702bcfb1f069f45842efe931e1421732778ab78b07ba0ebd4749fbac6238747b45cd8b044c1699b9becfd69ed134b0b34c1793098d340eb46ecdad0a3c5265369809e105d9e0fc1a343fd179e4e634bf696b5080302d2e750e32553269e882d509b69ff4f2ec018b8c6e3211610ef21a5cfc312a2fe2c260af87cf47ab9c1b46e0adc60d9294d6dc254a9ba128fe7a5892e3752f548303b48f9708296b5fcd8518ccd9c2f46846f831be9c4aa1d1c25ae1a55c3c1970651ab7fb639ddb2815f57fd383afac3ccc9f4d997a74eb14e99407d9d17d8f4cb4360d028f4adbef08a451882f1eb9e3d5d78c5ec737c303e91beccb30dcfba10737a76b316e96c9e9b32dfb82402bb25e80dd089f7dfc1ff039cf61e0ef6516f9ee715d07c86db3eba34c3141696f9686ed5cfb4295039c7c304e6d346f9440ba41bfaa0be6aa43a937382a92d1a9f2d6d44a78b38c21a2ad8d19edb6621864d8ff0cbfb3f0a342dee06cec074ca07364d369935869df127f705359aeba4d58d46cfed2d6245f112fa687c167357328e9e16da1886d7e882b9aed82d86b923ffccfabbb09d285151dde2cde003ad4ad9dbbee5725938fb1df11b5957e9911583ee9ec0f5455799ea2cfd81b29c89885e793ddfaf500278f2cbf5145b2cb5d4f96d35fb19c62d8fa18122a7ce489f1a02986dddd824e59f84fe732a5d4c641efabe52e97557169efadc4190384a99f41fb20a80beb3bfb9b66e0c29b9c6afeccb27100130fbbc2cac5c52c287f62f71232d851f1a53a5fe8041c92a8a28a52433e0a11d69a1ee48959a2c556654b068b434b75c76f7fdfae58f48e2e49bb3921af68fa6ea6458cfe0541fda45689f8bb11c0eaa31dc9329cf8c2ea3e06f51c91bcdde9e9af52bdb7f5ba93f19ce94f8bfc1c0791bc8229b36d79bd10a5c65dac8dbec82dfb30d9d9a07e2f6f633fd495fdae07a5367a773770714e6d43683addd1e2f54265e3ffac3b741147f5351ce8ebc66f16f3641954e1287f13449c7249f58471a0bb94598f3670c5520979aae5fbf750d31e1a19ccb09862eb56eb296eabc56a8af7709a6da363b16c0d65fad6efda3bfbc9fa040641fb4e25fb434fc40ef3411fff4990ce91e7f1523b87f004950ab1267b07fd8ed46238f2445a885e939dd3c55e5e9f4d519fe2934e0ab936948dc37c05c48182ccbf50b7b66aa7b5590f6332530e54299e2394a97f31fecac4630d1a65c7595d120e00755a62a63d9e155042da7b4bd756aabc27289425b5927dc0d71eff2cc58699fe870071f1e59a26c5203aff5fffba96b482d98d8bd7ebbcf3b9ee3dbecb6d25a9dfee653184631d683f849e93b689fbf289c11c89cc175b58e4aa0ef0e0340349fa15ab6418e57dcf6d58a18c4fb05b33677e976f95e06b921f1cb262710423868d470a5bafb6968248fa1b990ee48a321b76629318c0a0a1312ac9c805647458c0f8f62d25a4cd570419c48ef8660c820576852e42e43740d8eb8cba3d3ad116c5ffd51a7846e1bd0fd4d2a465d34981f1914244d2b3a7b49fabe63d91a22eb94cfea0005809f964c06e8d4a797087502865960323651b130d4c8fd013ab765f2111a167854eb91a8ad1f882d8a51980a507353179fe6c6e33fc675d88e92385b5b6dbed344fe48e982057f019e49ce0d66a3415f3fae0158baaa28c0f8d7ebeefea4929b07001b6733f6e2ed9e2387938353748fa7541caef4e207891057d5090c2a85d90e1378def8ded1a233431b4ff86949c4ad7896dd41484851e64db29d5e1bb81282d68927a6ef8057259bb246db2d330260a8623681252579a426f6f66072f0329f29b6ebe843783f962263a5afbf6f7234968b371a5208bf38e220a7532ef782223b33cf9d6d4446f09b9e5a910e464b1ea89e9a216c5ba96011b50dfcdcff3c61b3315d3fe5ca93ad824ea963d2d218fa047dd7e3f487b7d636269bea4b5dd7cf2e99469911d1666c5f309c10bbeb3d9a04ae0ce6c34a03389f9ab15e2918d21eb05d227fe6e254563530323ba2e58375c00bc2054c099d0e696d957e72baf4b6bca3afc36fff9b434818c8f64f567ed5edaa2a479e0fb9542dcd2380a6d70314a29e1c3b7d8341d997f659d08cd7588847725cb90a5d6f40f1be7e9a34cf9286ba6e820b841b55f92d3ee23b520fc714952eb3a4609e7e6e81d5fe9799e07039c9f2dc607bbefb5a23f0a2b98a3fa3f7ce2c85e49868ced2465606466a7f332f1aba03e037bca49cd84294f38fe9fdf2204f8f38e9c24bf13920087c65b0ca3cb0035b75cee5399bad837068c48f10d79518dc05a6bd269f070aa2fe941da11ac25e4b34a7756511f26083c27b9a491ed4e3668aa582857309f94f68118de56d70ae124dde0a38022034f16f478f17b36ec8d82882ef13187e626d6aeeff1fb22f28766c27e4829da5a0d558c447b0499f0539952e20e9b964d2bf5bb88d95eeb1570dfaefba0af8d4fee6bb0011c8b084524975b8ac133243ce4f1b3f109cc1317ace18229b4ac9289e7abd1ab92ea77be52e8148db5ea6e47b956a3024cd4902d016e571b36f0fbe5ae64cce6037bb588029bbbc87712c39fcf5fb2c1ba31bfbd5ebe395c32332f00f4c5656f6c96f987435617e77e5dec8a1c86db9dc039354be0aad4a58985847f96146353169dda1988d2b30136bd3cf00e40d41112801cc2ae7128688f2e49b94bed760c375ae6fd759234f3a2643d31f5d10929feba9e33652eee2162103c711a652b779d66dfdab288f182d926f399667cf8dee803944f757141c4ca469e547c040bc6f62c8a5523a32b32dc0ff63448847bd34955f1dd7004fac1a98cb52903146d7c488d76b3aa905a98afad2e8d8b957ddaca0a1dcb6676fe5daac30d97dab1b5543613cca974768e21dc34e4f86491f90e2b473291168886b6f19b15638e05f41c4987104ed4d06d6013c64cc439b6f2bec5ae3d0c577224118a9edaca4577c3947015f8f366310f6e891ba0052a1b72f47514d3c4f1ec49424b7bf48c56ce9f6fe683f53c9b4a9499bcf62ccf191e6e53efa1ca64aba20d85291e526a26b2e95c4b07ee4cdfcd09bdb87239476c1fef3c0e2129b6f41782e50b1813cb237604ff3459bb709900e73c5e03926a88fabbc0da0f394d834daeff90acb5231685d663e3dae0209503a59577c40f21bf72bad7693c18b06b90d589448879c0b0f002ee29bd9c8f63c46602eb54b7ee5b7cd306b9a4ad7a6a70f34e46487c09d02a3ce14b19598a3b93cae92b0747bdb72cb12f6878341d5f4903d97ee60fd78d85b7c31222be3606939e9da3b86392806c1b06d8afb5284deb1b0a62838835e239381a63e373e808ed12c23ffd3b6820bb64cb921cef4dc3a7f4e7e989c094c9b03b2fbef7047fb47c02dd29a2638faa05a7ae4b9bb2309c69370c8d519097688696d6c04672a13c0f1667246986bdab76b20b87c4dec0b06725dac6ed442efe412aef20bd3a7e825e61ea1e7c97f97073812c62f472f5e9046f09b2becb8e47db6d0de22eef3e254a58b94205c162704a358046f8515431bb77e67839368a5eef47d81dcd019014eb5e684652b17eed130aa83b76744582b0bc0eee9de0c108587b89fedad30ac0ce3f95b7619032fa5427663529a4be079c57210ab7c273fe097fce86b3d628f04e7907bab2f2b46631440577973d92bb00338c7c56d115bd8ad8b4bea2cb166d7194ce0841d11d55843300e433abce9fd988ccaec335fc897c011d4a38468df632cdda154ea3f028b60bf9e39ea24108da3f712e5699458de4b8e4df668d3c0e8866e7c29d25ab8c961f7dda9a0e9af7790eaa6e0622d60408d2306606c33569363896de2ccac6e8894ad1f6491022fb53eecda3d15669f3730d6bb9ccb34d7bdef8828d5494ab090da4f136327056bf55ad2382f906818089deb02206e8ccab05bcede0b7f573de7f533eea75b3c5f49e3a742ef5e7da5157fa9fa101b26d3603b4d6060a3d4edd2859d431914710f206014ddbbd05529c64ba0f7ea8418939020da8a47adb1f0e48f46aad0629de1a426599ea84ef663aa5584fa4770ec11863c320f627be33af8498e625df886175d2871ff94bca57a69e853e5ea22010ee2c12f06ab86c844c250c859ef0b5250da97bee0d755b4fc9ef796d2eea3a4574a2fa165dd8e036da87f55bfc07b146b13c082be85d11242741e285e44c800d20fbcea07c1d73f8e3bf3918af68fc4937af572d196e9def2b728b503d97348f7a58b79e358e27ae70a0263269d4ed4e79b67d0e430d575763df24e92272e55a285351f867472b731b7f65037f8a947bd650248f6c7cddf6442d65eeccf0acff874fe9e8edbceaf89627e95fc0803aff7e86a0ff8cd1c000ec9f430537a89fb165d95872672819eac5a1f19cbeee8c8add1db001f22d48f35be75a3536908f6bf43d9d7ec37f0d5da3ebb04c28599ab98f76aa550f5d7e0d5988ed1726fca3df77eae08948b2cd9dc60b41f91b7848362d90dbb1bada659725ae9597adc9f07d6b6ac89930ef804153b6bb37466246a1bc927b5b7aae510131a2f6ef490546dc00e8d83f586a13492bbe5c48c4b6f828e6f56aca33d0af35ec4c0225673746e471ac739a937eb706bd8efdadb850aca34071e7cbcfd581ceb410bd96d455cf0a362308c29800c51ed6b8fce63a0b2fb92d76c755707f3b65936ef67fc5b30174058985b515a075c8a319a06d5faf99bdd59cd71e52c3bd6a22b84af5b2d2960bdd26ea02da184d29be9112014e293c967886a0309f88d63ec50fa7ad64c593168bb773d8686de8c1b4d0f83ca330a01b4d34556f751eaede8ea0d6609a646d6e52feddcac4ebbd9bdf1bc5acb5dff9f7b49a071f3cdff866a2f2566f4c231a4016c16cf7fbd81712930e0efbc899aae99b8d04d993a0e15d044ddd76e06030481af975f144a2d5da1cf9cc502a13811ce23530ccb93ffed0a1eb9e341a3e0061b30359d63c7ff4ffeefcffeaa55d9bd29f19dc7e19b9f982b1b0537384d726b1041b98c1b6360a774653ab51d59eb25c78c724215362eb73071c6c3e094c4aaba64f8213ee300f45eb181690f2acfaa50c0263b697c436029a42fdde6e81a4dd1fbc9878045f3374f1d9a233db70032b250f6653a2d9ebc68f2575af8130cf5684b93856330bd2f66f32b2060c3864686716e34253996da3ec5ca26f14784e2e7aad9cc464342d9889bd16af22a3711f6c1d5761df7a5f13085114e51a618d3c8fda23533b2a683295ab2bae6756afa46ebfcb54bdae88cc12b639da267273666828c45d7266a61433e2130c7aeb15384b75ae23c1ccd6b44e59915149cdac3d165f442c9fd79196d940dd79e2894e62aaed657dcfd34e20b115a3f9c46e5abcd79f9518e8b71d3c4097e0b7e7e37b960567c43bd4f372d38bf6800c1cd9d08e9a7aae68ff3a958b2bece4ebae00f7e85541b4e7468d94aa6eaefb7ff74829cfaecdfc9f8d7a70817bcd998b2086c49a1608cebf8639c40379cbf5ae501008830ba158928e04a3eba6ae943a617979535bc83ebea45a9c94f3bd9c20ff3ba3226374a26309fd37539a8a0b05ab95ee693f6d4dbfd50c49f55db46fae88c89341bb8c190da7278cccb09f1d395368c97f3a8d65a7491f1ae422ead870c5a2969accf868bdb0e39acd57f348307282cb5ade396fee5e6344eb5ee596c6153a68fe7127d4febe0506d14523aef1803da1ed40d76826db74c7153e1c7072bd8d2d5050920d011787794acf7ab5fd4169c049d2c1da0bb5e645401f7482d2dbb12838cb4b8db01db5c16219cb0a4d43e921aeb46b06d42f19da108ad56ce8f0c097f6edf338eff9a97099dbea5c650ef7b2e78afdbaaf34153d520c5012ad8a46dc19329f89b88dfbb91f1ee4698876f4d493257b7ad3acc12b5a81a1a90f6fb64ea666f161089b4bfa87e5c7eb2a3d8402ad08063323f21e01f4286604691d8165624242fd9ffd55ca7a316b7a75629679967c4a06cdfa9bc1a6c1897b85b19c7b6cbad55fbd3c649f596b4007169f298216ee7c9968273648ecb02986afde8d32a15eba02fd78a6469cd0bcec2b7ce954ac4d60775dca49d60d68e7f77f0083fe02f6c432de0210f784c7190f9ec2af5a0ae2bdf1c05ea040e07fddb253ea47de7a8e3e589210b55e6327702d4ce5563c9328fa033dfc992c890b5dd5af42578c97bd64033fe3e27b532c478de6289bfdfc79640e3c9e27d8b24290a7b032c0840f65defdce1b587d7a6a4a062fd390c5b342bfee3b85f550e0e69f4a2e565b064f1a26cfdec6fe6137b3c15e084e60514374d96e492b1ed5bbd6f55656c83d4c0a22ca621e07db2d936fa7419de2c3c841d61e3dce8e93af6040a8b87d548e1c3361a8b722892ecf8b33a24b7cc7d8de260ba24176d12fa999bc6f38d1ca9b35c33f27af35e881a0ee6f6570602a4a900fe4ff35b622dc6b7e8efb1cf043fbcb8937644b6fd48c050d1dab85477138568b1963bf9f5ccc0661cc7691ee3eab11c76840270c7d46866ab9f81f8ece1f9aea83344fb571a226f24d65af06a580f65396aa1ecfc12a079224f640a7610966af8c86d4f92789004c753eccd7d806c2d0761da615e0d45f61808c1faaa31750898e38ad28745b7ba49371065585797835e533f2b16675c8ee82bf11aff5847b272c260587dedf5c47a0ae1ac3f3591751d886f84d078a43370ddace2b31948edb08b8316687644e2dfbf84661b408d96464cb18237840796d3422cb8a9551e06d883002853e4e99aabff4083de3375471c3bc22877d6653c50a58e45720bc43ca917bb441305355ff45e8e8612a32783ad68fbbb5a80ace9878ba6f1af4b1709917f0cb989d9fd91812a97e2e11ce78a80033472ff7029b1f7a4fac0198b7a59b50dd953c9cba91756b1f2215c81ab6c8483e3ed4c808ad51d0102abc66a69712d54ab07f52e880fcadeaf7fbbb04fbfcc5538d7676e59ec057b165a86d9ee1efd41549a0a6a18a4cc1e3f23bfc586d64da4bfe1dd8b35cfc8b010ee6a73b6fa303573075a4f68b091aab9035e1e38a725c9dcb9389992c9300ab5d07671b0dd3128172c3368eae4e33bd6d9743f467a52485d01fa2e1137e3fb8c3bdbcdbf5a6f31f81b0add8bad4b61bad5faf375590ff2a0fcb1551f8199261c7b99809601100f549be32b1832f8f811de75eefb945d86fb0f88e31febf99d1d37c28617c348ce6042576baa492b86d4e49254b890068f75dafa111a0a9127954b6c23a44fcd0a6b497081a7629856f720f42577a4dcb61fce6d2ef65b2d82ca8112e6f7b5899e5f998f9c89baf80a6c988b8c3c47614dfed23e06cea93194a34580cca4c628879cb7afd28a4add82fe411e07c291c65c9584d17bfbbc425792bb5882abc592a400ad359379176768f1ccdda4ef48e70a099ebd1376d3196a1d9ef3341e814031fda9f4b6b5a80753ab1d0d225a647c644be5ab5a8cfb59b21e6d6d9a9bbb98b5829dbb62bb2c8c720af5665ba24f7d808c394a7b7c3ea9dd196143a0807de8811d843f9866ce33d734d155724c09960f44f5801cc5478c48faeb5c0524a7b1b7f40a195ef0a0b1822849ecd235ffaf197c97f0270972a4a8b0cd006ff1d89676e2e5349b55acf745122bcacebede0a51ffe6360cd33086e4d21a42eb913bd42052c379ce3b847c5ed0cdbbba1ac7017ceb946bba24e2823e9be526c32ca4c07e1d234710da6b76d0c02419c1b6f169eed72fe379362cb2297b46b01d5ee6d2f30b4a03d28e362645cb4720e98cd171a09e9e59719d0d586f04f760f2f98e4da96a9aad0503138f33fb5eae5e65d4c6eb146a86c7866320d603d4fcd724118dd262c8b4369a93837313aa2d886c8ee94885a13370cd283567fde12156edd5b5620be83b8738d799e10ba75126daf927781bbcb509506213b8e81de14a8d2f1e90e01c315b1fc0b15761b6d47c707a37863342bf517f1f0c41ec697f7d3198ee786d6f81e29014600ee84b1bcdc6756833cb2a187b2fbf19289e7a76e83f682c3b115c018977cb78682c865adc7216da358748e7e4c064c34c74271e8a7885a21cc704e87c0570291b9a88620682487ec2d3f2aaf0399c175f7634aa8964720c5e3eddaaf59e2420c5c9adfedbbe46864504d71681fbfe59dfa90c112634ee5f801dfe74be6abbe3fead31289685980be0376edbaa8cc923981d898819501d0340615e0831807206284adc607f3fad7903c91394dc782a9554d26eedfb8413abf86bdc336a9102e8e12e2edb75ef3a84c0ff3acd4d8898d12b535ddc60ee3dd83b35d34755528e414117edf25aace189e44907019fba80270eea9b161789f50672a6c3c6ffeef844fe8ad044f1f90033f86e89ee17567e04094c07ba39d5b39fe61093673d4322ff1b6ed1258284b6a940c948e38e0d75ed4b74cec9f331c44ee589746426830463e40fade1d7f7a71b4196c28a60129b328788c5c792b99ea82d46e1749eb1cca887312a7b789e1d72465ccea25cdc215cbd430a44761956ad6f801507633cd31f62aa5b343d7e6d09e2783435d21072e5c849e050275943c6aa2d04b4792011c9a589ee09cc0400f13bf03758e80886a46a86569581691cdcf319986ceab5495a1daef671a150aa4a7d805511c1b72b0b87c3e50208315d5b21136baf1378eb22258d6d61776dff632bd81b07def679cbf204a9eb13d6f36b7de8ef3385448c0244fa05f52a8a76191f14548e7026787685b76519d971904bde6513e8a54b75b98cea9df4194bc36a207184c3ee1cd89af6fd36f400ef59d0bfeafb084575939d45752b3ac088788453d1619f2138f156c211d5ada68a1214f51e416cc2d493f0241527d6791c8bc94aa8ead2fc47e10ba1907023f775f9dc69fc44842353293fc60707e92a31844ef8fd8ae273adabd88df03fed9e5f40a5a324ba5c125af388bc42a012e65f9b76d26c44b32ef9ea8996fbbd2f5cfa0bfbd86139366366546804f7186c1728126a98febec20e426e2736442654fc46ac05a5adb04a281950c75450f253fbdd5d1c26f1782ed34dc7fdff11b75c8d53236ba2e5905018317addb6a5ced7b710a5d8ec7569575876b0ce0d35f8982c8f3fdad8287b6263d7de4f8467d96230271ed38070c2b8d9e45c8b16fcc4282260f6f7f297237866ee4c9cb730777e82613bb383860e30fdef1056f71f7795e7625cf428b9f670b1b6938de20bd7b17128d7f6c5434295fe32e5eb5a977ccbabe55cc83a2a5e8e76ad249516e2e061f8ab75e9f7bdef73981a61762948dcfc6d0a28366cf963f6c4e5f109e0ab12d1f48ae46c0eab34b3a89c83d8895ca7ad8eda9a26c405e2dd74810705fb492b4be4a7cb31199587c19cf432ac6d560205da0139360806021a2fb3002e85ba252f63e591644693f6afc3d163961147eb4c498483aaf7e337a113c7323d795fc36c368e9754f20dabafd6426bb8522a9a97b2a4ed7ad99a2672236b7bbcfeb5f352596e954cd31df6805b2cbc1304eb5789ebc90dafab2bedaff7a228e18b7442268037dcb0dd9cb138e428d2c03fdb2685ea70b30c254e3c92d1813a3004d5cae9e331b20415a6a6e6126f66566486d498e61c998ad86d21388c0ffe130dce67256a1e834a6750ac4fd1e836a6adad59a93dc89a5d8e8690537e090cb4de19281c2efe4b840eec9d72f8c7b5276c2de364baff464203d71007d6f8e2ee17f7e5afcb67582777522a6741f85cc1cb779840d2da86cb3b97f5091c7c77e915bf2ecc3b14cd4402117c492b70ff06a5c5e5be24c987585e24e019a5d8296641d997ecc1469f39b43ea55be8b9e8f1579faa80b183483b708e259812e790f1d1d59ff9a7a2ba3b00b1ca7f21acd2c14c4321426e9b8f100e46b430ad84d69ba6bdd5f0849cc5060e71ec6cf1c70033c829ff7b2514adc9b13194e4ad124b0872b5d70313294c061fdf6a074fd58e41aa6f62e32f69d8e35de05b3a52474c549eda6eff998e91bdd53e2631d4b056782747a293843e267cc96eabff5d211ae18c3fb8e6c250ddc6fe24d77e7c9a6debee7e0ac57fce995fd2de418495d63ade55f20785926516021000626fcfa73da5978810bcc7c7a87ad9ca33918bdbe47a403d685ec4603c5281bd26e6d6d6509ea03d1940a279e87bc8e9fbdec47df4129cdbd81a253374616d4781740f521c138e44498a7543541b240f847fcad57446e2cfa2d2bab97d2687904e244d8fe53fcef67b0f28d0b5bdedcd442a74d63f73e5f31323fbea54f0528ebab5fc4582be244f2b6a5d87f3e83643637d5f274fe6fff40eef15af761aad56bda05b0ea037021d4224f1918697cb0d91077b82892c406cb810b683e8d6358f25164e78e95c172e8ba95e7a10b9c3ce28c84229af196df027fdd0ff436f733dff6aa907f21adc6c6ed79c77b7ca10701386938b95ef56d2c20d2bb8a840a5fa29711f5fd5e74f037b3778e708d0bf812b6ab8d468d3a64c20c08ba631d7c53b91c450c0e41655c85ecfc65203435c23c6b263c503e89cf6ff1464990dee53777bdb8e036b591ee8388f7f4000a523588ae3218a77a62926871eec9ada5d08c06ffac358210452e524653c47139959e5364037bc978a73208f59f75671f0a53384e87bc96bc0446cf3c4613c671462ab9b81e764b281718821616d78155fcd3026a89ca8784fa10e8586b04431f6a9ce77de9740d19fc14e72141f8d5f1d67ea922dc577487454c36331c4456ded44d0915d439913f91a2e103f35b6d9b4f19320185cea824c43d695f10ed89e86b326b2d694d9f934c39c3194357922b1900be2b8f7df91230a66c2881149f957859e811d759ba48d41eb36ddf5234bcd6e40a13335b1430b626a25a767c5c3a2895eb7cce5a68caab30084b98aa3531a20456a32b7fe7dcf605abf17b0ddc6f5f3bd11313adcc1dc5c99e62b959c8da2aec4a93a60ba6c990214134803d2c6421ef76384c7d7baa8448edd8dd563b18cc3f38175bed665fd15940f31e4ba8d313c8590a4473f2e79a77db196d31c335d78931657dace1569b6662f83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
