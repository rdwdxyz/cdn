<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fab9746517eb53aa9c569755a6c444e801cae376e64af3c19e4c9eecfd9f90169cd340c8715a40494bfed63d0422b83eab25d32692650ff4ddd11330c48e9734534a102c47737861858bef4a21493de81d9126c4d3956973f7cbb9ce9bd871a11aebcfc6e4f04ab021ee45cf0207557edd2220ac93bad81f8404b4e40e821145d40f41488b22a85f734a04cf1905ccba215257e3f93eb80dce198a1dafa985a8b1f433086c57b10028716666bb4510e63bf2239c3cde9b7cfb2ef9c7d73a86fb12ff8839863da13382c054fe6b7c623ed98d44055e8bad3d30394ba65afcbf19a2346d2ce842856710c72239ec0820cf03fffab348e2e29f7bc964439fe044c7fcdb8f277f6904563d58c47a89cbf5490082e471f3427b8429754abba812f17a2944712ebb18cef3620a59dfbdd9e13afe0fd8fa7da814f06dd3da289ab56a8fe0b749ddd12555e6a06e2e16a313af04b5c2eeda848b22e3c5675d7e963639464932faf3375b28ef19034115a0780c753b91b2e658c1461fb4b1bcdd7ee9e68d8b885c59b840a07d77d57b8c50372dc3a6a126b13901dce079ba058b00ee857a5a1d4fef83ea6b825de326c0692b00ef2bd11e664cb6f9dfd6612f818ec063eb2725ce7820d88896e1e64ef1d6de9e0be08ef736b8b948bd5dcf45a59d21d9f772c3cca51326f45af23bb38a6b3ba5a46b305d0b64ab1ef3f3ce7e6d386aca59338a9f21c433d511a66f3c7f707c0d69a01e2473a46fbcb850f3707784e639ce76e95834e92b7f2887cf3c3cd88205d4497ea6db95b28afa27628923f0531dbf76272f85aa49997f8cf249696c1e2cf2e1148776d0a9208069d898b7ff23f413c2aadf7abb78871648f1e61e92287eb46e3e137fee09bcbad3eadde6023c81cd647447d76f89ab751787f63b6ef561d1052385bda5e8daf6f863629bb343137206bf349fcbe7b22f8e975ca74bc9e236784aefc60450de6a4cd82859be3db946e51bca096ece26d0035440592c4323cacc1215413a3e81acb67a5b500ce9a7ca02ba074b319071bd53ebd41abd8d43044966ae3215b88d2ae3c4e6c255eecd3cdeb4ed835f514fd35265e7e85870b589f4c62f6b8881575175c97d6b3629950a77f5a13dff3300083bdd21f03e1b2aaaed4584fe1a1aa955900f6aaef187894b23f27688250224ba4ba454c9d4d759c81baf1391173aa116aeaee66a5bf151caa58f1bae6d2dd2405b89a5ae32d5961704f6755ceb22686b4dc282e5c02b1d0d0005d8c4890171519ee851d5b24690d78e32154bb88e6dfd5d0c639a9ee647b798fa7c4d21bcd498760c853ab3cec7b7b4d0c1f0c48c65b4e1b89411fe2be76f1e54d726db1ccf9a5ce063d663c8b5029df0932a218be211eef58c0e9d87d32dc2ce06eeab7987da91f854e812758547bc2c78db1bf74f986d9def96d4fd263824f4c446e9b4232afc921bb7c7df2c748f561145af268422cc7ae5fc5306b9d5cccaf85ded01252e9162762623f12a80c23604c2503d0c594c60f916b79141d99606d3f200aef9d668467f9e0b8470ec7ff11d08c9318c2eb9b08335432ec37ce19cfd504e4c644720b5cf784d947878899cf19447df47d14224eb130d25ffdb4e02933351a73a9b8f0ac3ee2864924c226fb0f6ab659dd622ccf0cb759583c7e49f6a54f9ee8966e99954613b4911d69f29c22037686b0a879f84f59b059171e12215c07f434a608904b61fc2dfe505abd4077432e71e8da34a719869577411bd51f3a380d87ea982409b5b3a5759ab2bef230d0e96a187bc9f17fc4736b4409593fe5845eb1fdcf62fcaec8a98903ebd08f7ccfe2750c86e5689ed05071c4f5eeefba7fd5a864fe7812182b28c461f58c7533d2b75a575009a9c9435bc6d934557fccf98a8859293c65a31ca490a8f6e46f8d9f2587eb8234b68c1ea961d74822afbc611ce637c5e35164b291fff906243da3b31a43ae875f2231e61b93add409168c350543b81af7fa3286d8a6e309cf912fcafd02f4e18092566419ba7e3071e7030b0d8e7246a2815a6dbd057e7541c8a400594d1c53fc16e80295d6d2bae71c457dd23cf5924429cf6109f8ba0e785eb3c6db7c5da9e0f9b8bf0aacf5ac04a7185131b62175b053b641fd4d210a8ad83bff78e38c482307cca857ed3ad2f487d2d45c2ed0ae4b563637b0d2f47260a21a2427545b1cc151f53c473ab8e431c65f12f20bc136caab29b33268810f61eb77896ddc5a67d9ae6c4bfb3c09d12ae991e403a786eae58d440270e0c20a132a7b0486fb453f2ab301e1020aa965f6113658f0c84110adb139f207697c100c9eb2b8f4f25decf2eaba269f2399da2e4cd129414e00731d122440f1ed10bb5c4a6d8395e1eee49e5575dfb6c066049729f70e28d506eea08b525a1ab91122ebb638c55fa80e598f36bceee421dc241df4ac3d03ad2adfee3b787a8d4d1df55828fcade2c270979571d80ab3cfc035ffbbb9c8780a39bc1e2203385827e3dc7b1ec5503c156cc490fd9d74f24f4783638847f1d16a8a35a67a76f0ec6cfd6e0a345025ed0dad0a67f1436ed10e643bb98ad55bd527555e8e9e58497c3754ebddff1e241765a23955e714bb1474c8d46b07a54ddac98f5af4915b00a16aaafacfac1231476f48e5735b30951bf57364a0609d0b6478328c9dc83b8d28916e56ffce4ee32ee11498fe35e4c630b47d633c536c9ac477a936bb69a406953ae52018990d5940fbb33cf55cf3a4fe1a3157c107fa3a31773865f12463233b811e6d66d28a3d6abcb7877e2357ad6ee49ea4c63179bfefd06efb66be6312668f7652186c0bf204718d6cd38a0ffa9bf5617c3416d6f33e624bfc329c0bd5ce2df13ff3de43febd59e031b9fb820114935d2f3f32f8ca65535a0b3ab44339e90f82574c2bcd222a945dacc78ca778336b44433fe177e2b2e5edc40652ab0051df94e1ac7c697e9682457d51bd2e7bda93623a230d575ddd2b37c601853070bf5032220a07be4689dd43079302761ca3f1a6bc4a3aff89c640d629ac9f80d1bfe216fdc196fed21c73bec7fbb9e2dd6e5cc49cc19dd4e8304cf59ee39d012b4811ac3014fb7a8be5f4029bc46850e274cf8e45e12ba145b8e9d020763960c396c18b5bf7aca15ecd25146a3f9697ca323cca503c1b5e2c7f1134ae0f44295bf8539b57ca0a03520aedae4d54722e01ddf0dc9cafbf34dc2d49fc2e5c0e154b1571c562150cc463a84b34e69cb71ced0702eb560ce763842bbc485299bb7e5b3f651fecbbded7f63db70b9c6e6a96357817471aaa27401f8a5efce472fc91cb28d6b1f0f33fdd66f4f8400380794a3fda4d6a5d408d7b5d244c32117f761910b94d953cbd77bbf8a250133663494a844138ab64d9f45505bcd60f7993ad9e4bb689e56d92e51e004e55c9b1afc839dac726703adc69a9915098b94c1b825bc09a5fd01e437ad999cdff459a76edd48ae4895e1069a58cd1d7c6c4d8fcdcdaca7280e1ce66d40953648934d4da0d499fc37c48ec1a1289d18549cc0e7cc4421eb3fd3ea138dc70f94476b2ffb97187d70d556bd44bb10abcd695d3815362ac652f52bdbf4cbe410e7888cc02936abcd423946e229e42916736ffc7cdc7a8a97a7046969a6afa46ec846b460dccf80690c7f9be7ef73f558c75c795fc9ddb20390226274c3298788827dbd1404565ff80b7698128441fad975f27a8a7de84324a329528a0be374a0f3334cc2da71f5c6dd22eac03a9db851679e35b1ae722724c6f2cd4e48e1a822978dcde3dc877c356f7ee6d394e41bcfe5a7e1c0ed3c209ac017a30faf6cf5ec7e5dd673108cc01599f4253d119174be5d9fae1486454d82acd4519d874df599b5f33a778de657c705e0e5dc9e5ffea7658546f9647502fc4a856f76289a5b65db6f54554fb2d6c9e6b970b2574dc044a81947cafe3b983a5ef7b585d9f296af0c6874d2828ecf603a9aa195455f2991a8a314666f727a226f395d7df4f6d1cfdbb4b5c5b5ca30736aac110f3ce24d0cae54086a12c2ca63d0f66b87fb30d36e3ee764eb470ae3963f148b187d8d14454bc67db6bd7f438bfea38f302ec6b047a2b1378b31500c2d1abc34dc2e5b168cc94cbb8820baeaccc9fcdd37a38775447c964d4e0dda4503d96bd3287c2fa58843269eb9de34fc744b03325e0c7c65dc967ff6f86e924281fc95377ae2759abaaa54f5f93b804db5b07a3d7b214986a121e93a3c22eeda5dda760d700a8aff9ed03a70384c25643c5e220f02e165cb39fdb3bb2b29ba0b9a9e2b8ffd5d76bc0a8f95092b5657a3b700e1f4444ba89cfb8e7bdf0fdd59f895528666bf0f474742b8b143bebb19675e73be469e747160422a1dadba9b66764d781ddca46e2ffe616cc6363832d692b083b4032f1d9964741e77e72d7d5dc103f5bbed8e9dbddecc36b70f66cf291b500d7a905bb73b8f773ea64fe3b822a473c2ca6f3ec8a589fa2085d70a2acad3bc0a383acf08a32fd0f65bf279fc0d075e6afe0c7e43ab80a2ac096cfd8500d3dd70a7c98e7ca4424c5d055a7ddccc3f3c200445db17ab644d32d857b268c2d09fadd98357538e9f7f810927b1b3b9436f41dc630ef1ce5173126af617accc419350c24e8014e00797d5e97921367607133044117ed5983ae27df9492e81683c0afc1df771853666dbfed2bf2fae47b7204ef3a08fed871809f2808793bb2dfd5f402f4355d61e283aee04aed68a151671558a74a861ace1dce3bb414b0ee4424e140975bd137f68ddba8410de92aa58c8bcfeafc5788ab287d7c9d8cab6250638012ed757669057be88a02bb58f120e70bdeb8801295f17cee773b8b916cb97979c1021ec23cc8a6cffc4e1b9ee14b91cebc37f223ab4c32332888107d94929d247b436226e22e6a960898cc00f64a216e4cf4a86f96219fa44aa3a6b3c39b3788a29187a905495df2b5662bdc051eef4604f0ae7283fc476ba36c6f4b87d6b2fe99d032a8ce906409965c04913acc2e847bf2717bf3cad9d6460830162b6416ee99bc721f4e807400b3ea3c804562f74dcadf6ecd8ea7328f8f37fd28c4ff2515cb44dd5afc89136134c0f9dd35af8ee69cae59c599b6a16a59b30d39930e13bf161c9d362abd39accd6e9d52f4fec992d95c324a82f3209847313df9b1ca6b90ee0ba8b05e630597ebe02d0d9cd45d68fee4db141967b6c9553d970e738c48c752c26d6aded9ac82dbfc384a2b5658eb896a6c765ba365da7bbb014affef9cfbc4e3709261f731df2b972a0aeb8c145a66e5ac8dab9011dac843c2a368da279c133dfe9a5dbbd3f4d92805db3df6fbe4998698d1735907a3571b82e0e298d6ff1c595468d3354f3e9e2623f7fb306724b1b3099bc847097213863ea40cde1bdf65b0d93bf971e61ed4ed7e23dd195597157beb058ebf448c1801f5dfbc2a3eb489e0c477a12ab942a2bbf1137872c5ffdfc3f2444eebea5446b8ec875942d8c0a48718b190468779584e60ec869dcf787b35e63b6fa637a2a4990482000d45ad07a04596b56d596a61e77008ec8e15a3a339bad257b276d25da9e57196fc4f828bd59a51a65497cdf8a1e9da306a9d0d8e998c50e9e25a7a36c1769f93be7d81d170175d7e0c35778d612b4e585b8688ff28d71ff22e050829340525802c9f61bd256df8c0fb14ed1a735dd49bad437649a08591a0b2c3fc8dd50144ed968984abe6a220cda909447f0d4b1dd9ee4ffd98148dd763c667fd490d056bf81bb15a45292c5a9a6a3b830375759ba016c134a9a7e5fdcd1f072c8afc7e0f2a4f97079565809232f14d0a01979f004c381887b21cf5f25c40d8b97a7f88fb47a9bfc7f03b5c7a42ddaab3578c66d1997ba1cea95c25076148b1ec04f9302b1d854c52e2e17df1ca6ba4d17211cd180488e0e80433e95aad0b384867cb22b29f9b79d458d70eb1775e4d1192df51eb739b1fbf7b01e75037759e043c6272bbe99555d7fce1d557bf35b6277c584c6c181414dccc8177b2762a7655df9117d16f51efbe341c3b7e59e9cfe66090cc9d1658cdf79fd9de68595e8ebcae27bbe3fcb5736aef755987732a43e6bb5a2fd907725cac93ea8d060d524f5452c13859c00c31675be0c89054eebdd771d026847a4c04a29d79cbfab0972e4123c7da7bcd587d30dfebcf80c91551e7bd0bd56e2909e6cd30eccfc291d6ed1de7b0440086f615af01c9fa97f96ac59f60797b91d9d15b0d233ba4d26224f71c84e3b2c5ca9875da60d7770eb6aeff86c162aac7596c8df35232d0c3fd01e01f2266c4a4a883ce9eb8cd8ef0ac09e699a5b9d37546765db509ced8e7ff8e93c005b6eead7ffc36c621f61742c9fa01f6700f59e16b4114aabcab9ce5cd1b30efe56201db9c7632168e7c9ab8ada1f256939e4f851566daf7fd708ce8f3a49b8f195f52168b4e7220a1c8069f296af3a78e7fe550b95341c5ee58c4caccb055e5a42ac0a6fc41f96017d16dca59bd3478d62cbde94288dfb3081fe3bc284f6907966eb754f19e162ea38150545400138bf305251406973f109166a380bc7a7730c012141fb3b37a32c7485d034706f61bacb97d34246f7650f620e2ae91d913336fb75dd3086970da543527148c1d1604e7ac3417fb034da7ed486a7f7bcd0f4af93448c6dfcbe62e9348486365c444114cb9b4d68743272e108b3a46002730991f5e9463cb912a4164a3d2165a332a9a7cd29b81b45915a4daf0a8255cc8af6e8ec3627498e6e7a22f1f41f47934c442d3e6ac11298994cdc1d15d36655f547ec201f05598f3a5e3d4c0b183a857fd7e06c156b8c6f79dc4c23e001c7fbe2600660ece2b01541601ca7937b1a4f92f5ab7d2224a593c86b09b866bd57b6809f37d07df908d628cb11973e2144bc537b778c567590f8e1ed3bbbf5acd1b273d4202c08d0787e71363004c64e4789b859454b7709fd5429f7ced97ee2175a91b93effb821c12b1f5161fc27242ff2cd28d37aac21e69f0d09fa50fb80c6379973377b729872674d93152c76516bc27f28a065c483830727fdd832bb08171b50f8c0ba8a2ed51358c1c7df3c2aa2f1fc3030ab58f9c68f9903eb790f2db4889cadd60c99ae8a4aac29e8cbd7919e50f72044fa70e4c87e75c4dc56530d5c9ea294906525b9253b265fbb476b2b1d862d493baa361ebb5d2a3a269882201fd57276c991c093678a7afd4e519352338ec56c1585b672a2d59b447f737be52acdbbedf0bd25dba03a0720c9eeadb21a14424591011f58646ec553b16f2ec2ad090f9b1f4f9315ce7a0030413fe5e80786e54cc34b6070bb676f62756168e00ecf0fc9b77c0f3b079d0a5487a63939a4104a1bcc2f2a1219b6b3a50864a82a71c726168103c894e111488af1956243bbf3a1a22f31de802ac263c01be19a319d94e93d69656d5f5f42cc58c85b1c5947c4036ee8f41ec0ac547ac1a38243cab6faf0875e554c0f2cbbae580a9b28c5df9bee08098e87ac028a8dffe4c0ed1eb5688ec65cd588f75dc5294722887caa15c890933e70e486f8775c52040bd6d92f2e55b4d9c21561c242bd9f224c6e509ec4f27e8096c3e969a2fe781e961964de06fdf3f04af49133e9eca7a24b7a92636629b015de1dcadb6202481d0adc1164883731a29d37b0d155355fbd2365c32763ffffe22432e7ef943a2b05faddee057bcadf42e1f8804202a7a2ad381ab3e9ac33d267ea8c352a9420eb3dd052cd101658045fd9c1ad609501e74189f82dabe9fd46d2e1cca7c54399e511bf0aca17861beb2923b88c410330ae3c1da5110a988c5639c95caa98e0f126f8791f79941b6221ebe5dfc25a10f2be7b5fd3967794ebbef7c90a0b6acda4d811112056b9bbb7da23fb785b456594f5f8b277f7ec2a7d1c18dadb93dc4961951c7e34ceeca020e6c913e75253dd1780edaa7d82bcb5d47d51aec29188d857a94f9c2e70893546d94ac9b7736a8e2e655c114b6ac6a683507ea6a0d5fd7c6709b1dab68f6fc7a8face5636a1c2ad961399995c34fe29ffa759d65d8c800ca1d616f3de8cea2ee0357e2a10af10786202cf7b007bd9e5aad58529c2961906d71b11d0d3b1f01ee1a10acaef68d182303b7b7ec075aca66878bcee583343eca97189e04cd37dde8174e8c6232667660d700003d04a7669b2f9c63e1f7510412b7a7190bcd81dc45ec91b63d4bedbd7e34c5a113b2884b7ddff02ce1ae8df492a5a58282061622ca092bd430421fc04b2ccba227d66e2804780654953f0a77c10291e72ec606d599e6d434b2e7ebf1f14189bd6c0ae2422fbe5b685e32a232b98641ecca46303253678a5b291f298fc5dd73bb38da5f0c5488219b656e682c8a8acbb5b507d604ccf9b04aab05bbd54c9485552a26314ed1b23492b1e9e7ff7356b18ebcd3c4d4a5728f61ec6a8f45572a93a49b7028ab4a9e17643f469b7ca57b226cc11e12cbd733e31c13270809a5435bfdf4dfac8a395c79625a761f2a633f074e656cb211c198fb3270eb5e4b22241a1766ba65457b1bbff5c400d6a42812fd568a99c48972fe46fa10f0828558f37ebb0ac6741d47ebd0ab47cf04f3c39065c7928af256f45e22831aa81676b35310106416943c3b9e2f8a96fe3db20d7f9bcba10428a589c63a327a3a7e9127e1495f9e92e495663d8e5670fefbfaccbcf8ede51a288c64182c85e752b194a2cf30385e62a4507ced735405488fe38e466b896b9f90af6024e8f5328e26fb08b478293e3b6e6e842fb0df344768e302960392c5f0024b78bb99fb943f42a976735c90d865824488d8e77770020eb8d502e203baac8092b2e2eba97b3632016b968546b4975820ee2defc73cd564a8b1dbc9f58c91214b0e9b08b3889d3aec1a9788ec52d58ec7781fefe120f1704115cf3bfd56cb76e20e07eebda86b0c7f327aea3b04cf6f2e91087c1ff536c41e405f094a7379b005302837ea15abfa8569f308a2d0c5fc7d3bf4e55710c5826c2b06a645545b90106188288fd06d8123308d99fdba2035eb7faa1e3c4d9622fd9fdd99202199371cd0650e011b9b410e49d171f31b2a2eb0774b887a37d3205b8bd6b6fa737c23ff3c00903a3efb6c4210dc1c851ebb2948beb168accfe0cd2a2ceae44447ec001f0cfdce35b6ce5f00bbd1015b2294219b6d0a870120f15fee00b10e6ee4e0e6a56964ef7c7f451a5660664edea2fe46ced12d964b58b594b5c69d53f5fb0d7d4640c4dced036c8972a50b481b2879a9154d360e4a4f6436eecab807d3259e20683c21f4b590c47620842468176a4d8b80d34239a0b7e4d6988a320d9cc5b13b7de1e112ea4a0a15233435db142bd18a5dca3c4496794624459a03cf06010454d462434ae38f136d79c0a4c069d8af4de02c7294b3b7d4c375f8e68bc935927be1311aaf54a43f1848c9e01f8fd906293bf07370960acaee62f6e1eb4f596fb107821d94bc8bb838472eebf947d3ce102a4d91e6225bb07310c9a17dd01d44520a9c305f3272f80de511d597e010cbe395f8499b81a2e81a62e3fb6805224bfda1c3c982fb3ee249302960bd2e3335e45259495c5bdfacfbac31356d167f6b8f1ff6ed6d5e36ba9522e0e6b4bf040d34129c62598b5b0309b559ffdfa6d78aa3fa43a52e6e532ebefd2f035e45a3abc458dc71b62557e6aafe435b6bb1a38d4e49c4d671482186987d6af2e14f917d9b8aef1773175b63853699dabbe25b03d32537a2f2f7adac1dd9b5028e758255e6b656f5c8f9ddafa6521705677d3c85527ea06157644bbe589a0508531e16a26db9719631aaa72febbc82e98cc82fb88c07d602724374fa5c80813249fe0e99a811e4eff6cad695bdd88a27baf5779c91ff99e48a30b867f4ba747be6f20975d854054b98561382e966b75cf6c41a8743a4a76953819e505261f6f94a132e14016d1103bad0ad8e51e14adac68bfcdfeb3d9131c7d4f97a6183bcc47d029d5784e9522e5906365a579836f788686e51c2fe0c2ac3a48864cb93d99bde7aff1bce6622a23afd514fc0a1410a7bea3a1dd1429e36accf5c5f938b1489eaeb4b931b4568e6d0006176cc484c641e7ccb82eb1797e0991df6b234d66a090e4730ed6fa271fd14dfb991520dbeb10d09120272f2f7a7929117398f36e2cd99ac642e88edffb85e44413065d87f24756fc2464a03adfb0a2da123890af58b3a7e9b8d19c8094dd81514f794aa5b55ae452e237d08d2203d4bec125357272a05d83387e9af0bb0a651f4fe3cf1c45a4ea3cf46f17995ee74c4114a6942fd47087a46183a62835795e2d1cffa84f2d82c8b0ac5da0256e997e3a7a952d9d22204b7a4065a2356f31f7b6f906fec001ca11dbd4bdb5c23ed194a9156ec245a316b737563f1628408d8fe2f709a483fe5f9c594d80f099e25220b78a4de2ec992d725e17cd9486c0160eddf07a461dd5da3141f23e78d3919356c79ad9884bc93b134574892b7e333477dda9f16331c1e62de7a289a640778e5aec85d1ae129fb85012786b4e4f82eef865696604253747b72ca42db34511af819f2b4bd6f915ccedc01bcb920adfd71ecb24b04f9d2ad0693f31d0eaa52f50cebaa7a425284597f72981ce54fe405dc1805a0016f73348bb3319e903a74ecad17d26b80ce4ee88b4e713014116cb5fdaf83623e8fb07ae20350311d1f79d5c2573de87dbd6f971c9ec414b3a8e3efa2993025d758c072a8368c09eaf10ad5d5111ea55c3a7a08b108780d036711be43645881b4ba373ad0a2330d682e8faca03e533ba1683c4e1ca954307a7ccb7529ae05c2c51a56c24c51945c10dfb9f5ef3e529893ee447cfa255d49f967144bc482a43e5b514b963bb1e53bcb33fbe52181b62f4e79edd167b0d1ab9c1edb188301aafdca0ad693e57ef4bf17f23270c100f0d90642bef51617cb77ec9573063b1fdc6bfb9a1b5a6dd5094f714519b9c2227352d6e37b361799b0769781ca2c94528b3bf9603d5b3afbbb6352619cec65d43b1ad2f4cf7e6abdc711f8c12e7a534309dcdcbdee47acc6000e232cb2ffc75d39d33abd6fbb9a4fbbcc25110a4b17cd27ce9bc923f4b3b8d5840028e47d0eba5f265bbecc36ede76a3221b022541c1c10a0fc77585bb779a86e0e35e9d1bff3aecd280edf584144b8f40a007a7c6c50c71ab840fe83fd0bca2c563fad298d676f9b376fb86dfacf353205a77aae7eb736560f546a14acdaecbcc0c61525583d288ec111f8c94a484637a119c88f2950eb52b1a0f8997b2f0327fdfe217768fa3ff2ad844c585a0699801f070c9de59e1eee688ed05b9eea26fd5d1b7c04fb235b694e9085ce233caf32157bce7cbf1c8efa70b14253491570e6bcfb81e9019dcd4d405af2175232aae4b7e78844e8b29c5037aa2a528edd8e2ed04e2485506cbef2cbfb5f5d6b2db32f36bca2f7b04750cc0ce093cb11e0d50719a3ac35b36fcfbed09e3f0068487ec808ec52a53b9d2c82ddf43839246222deba606fa46639cc3197987043360e3e2e0e10808b46248ad854c11db02bd94dd6ee7cff1329799dfaf78cadf271d04b60eab28b4799cd00f2cba50e1311715ec5f60f382bb1ea9aa34cc08d3e68771e97aae0adb0d25e970523f8286d072ba4a8eb2a7ada9a608494177f79b44f7c909cc9a5b1ea7e2c4e0e6f25593eba744e8d12084a84218ae68320ae75b27a7affa589df5505efbfe79ffd5017ab53d455a2c469b1662fa5c01c13794d0eb634975c43d78f3111a0ac3c0aa6cdb979a64e4ba2e8c754ac80bdb60622483b10feedf845ab8935aeb92a122d09d5db58c9b18b12589524a0ac95900f16df8196fe5a7e1c2558d938be16f8ab47e77c77dd9e125e65729e6821e139a6a4586235c485bc228c1121c930483679d033e1f4f989a289b0ef4ea8d4c3f300c622605204f78eea9ea37697ccd790f9754c213575276b37589256a0348eb3aa0947d4d4b8d484d5de7cb1ec8eab6fbc221318f381b319e34803d928536b4ac6da5ff0c10680aa65db6c83e8ef3a703f05bf14a7d34c83cef919e0f299d1728fd4bcf2ada9ae089a16caf0c6fd24aa9fac487f10d535b37a6b607f784b4c5700c781c31e4767f478899fa03bd3f6a879fe89f013535e1dcdb55b09ca6a1d3ea00f46faeb0428b3e712fe6c0260ea3a45530f3ac56df7e339d2ff6419326a676a52891bad83d10ac0866cc5937869b09ff28e836cd607f66e955fef09d06904658646c51208c4da999a5cd9438d0a428ea0ea23c28cc5576cc504451aa0b0768553ab1fa90eaa4abfa37b38a7809bddb535ef7b0883d178eddc5f3b2b6aa3546ee1c161e9347a4deab2a6dc43b15e43da6cbdfb97553cc770fdb28f7d39a673aa2759ee749ce5d3ac639faee960b907601115f805d506b0d8ac9c93c8aea8acd26523c756206c45c9920c72145b3caea5cfa63f9dfed6d27c777860b4089626db00e8ade54bd13863c31128a6ca3d11b44cb16d0307351460ead00f5d7358dabfb64510480d36106c09ee782cf3a9de6c659baaeaadd8cfe85667f98360fc7e1f8aee27812dc96050aad6be72f1119131c48e87e018d23cdd8165a4ef1a144906531fb0fbc5e21f0cf7f7c16d7cbf4ce8dedddaa2f8473209ceffdf8a282daea9e52b7c91010814a1200aa72d454abf8f500732bc118b93c1bd10eaa6d0f999db384f300c964b37aa1daf6c7f981d35f80a461158d63c6f5f18959a442e6880c53f5069e0e566c3e200e2bb8c86010c36236720e45e6e2362b65e46b773558ff526ef0961943c5d197b74e24cf9379ae9ddf837a11d94723189614837d90d64e83a908d5fe7acbd71b8e56614de1f53949e4a1a71537dd1f1748d26c9d7f62c81610c7ec960f60251206162bb03c731a450427ac14cac258a0c16c170a3bb72a744ba63c9084351eef9660c6097285f5b6b58a102121568aa3e1cc622e5d761d048e693e915021be0f211eb16d80c7ea14ef23feb2f3c5db529541465c085e2596167ec56bc2e07f7b6f2f2e9b6c4dfe177f8221b6c52138cc88783dea3c3a32ff76b80ee2a8d5a1f86430d0005e6e29f76ae36368590c729c47ca12f241e245128523d640d8e0bec2065db302c38c21d6acb7069490a5677aac84d46a29b34a8ff0a08d1fbb454c253ccb92302d6c210ea62615fb035d1b4f1f429c5d84194423a532aabf529e161e6eb53d69cbe3e6cba9b73c08fdd250a1d66f147a23309323073906ebee183bf05b4b296a1c70ccde543d20af29d6a8d4a678430d491d8e49b9b1fa4e3a492810cd5ab1abae7a518a175afe436e2a866877dff3837f3f1e194eccfbe7235121500581a907aa85d3b98ce84e3e056c170dc18b99ffeaaf1ba879ffab4b4c82405210b07fd06f6dc2bb4405982118075666c6aa6008eb385b467417c7f505e48ec2a487d9b9dd2f53df32a43908e22d15bcc77210245303e9f0e50004d3d8d79c72bca41e3b8b70d4ee6b92dcf92c1684323aeb2968cdf362efbf3ec7e1d48935e7ed966febdf9bce48e6889bd270f1ec35013640ed2f2dbf68f32729670ac349b5a2bbfda555c4078e3d55fafe560c79889328e9506d54d3f83e5f2d0a6e47f944e0c663396b589ef161bb867dd453a5bd1f6bb26060eea7feb02bb1224a56da9aabbe38e95b5877ab797d5ce3265e7be486e2f6bb9ad2a8b92bcb82fe0acad074c8197d1eb7cf109963a4b692e9a42c68b535138e24e7cf4b949ea3811ed82f638b7634768781699f36a8d0fdf9ac3db82e4e14417715330362f16f717d66321a19bb924f8e424d5eb82aed7e06468f9d8411195c1ab04576ebf91a9354c94cc0b671d901e471c2f90c13bfd71792bf25cd1037d04e9ab45590137f93896556d0446463a88ef997b4c7108043e05c6f556fa7cd99798a28560ef4b427074f5f49ca6ba7a58b56d97df76679fd9daf3a4cb01ba15a01c382c9636d90d6265a692fbb54830b91c2ef69595755b21efe731dce696cd883d5e644df49ccdaf45fae5226efe4d926022e07022e10974d15d5c5d25423a26c97651b1a2b09fd213712d4482631a7cc3ae77d2a67292b6d7226dc1a5535400a89af5c0ccc1b62610fa9ee94ee7deab7d30d8438bbbb3f06a197466d3dd05a41dc67bc1d52bd95a575e13c73f8a048ac9e08a28c633a1cb5f88d82775cc755fee97bf6350947c0b8c3163f421c4692c187eeb1cd299ff0eb89fec3e83374f6aabfe663dd4b4fe7e1ff35a1640e406020863e974fe722b4021c198c59917409fee099ee5e2304ceeaf8de6acaa567b2d5a6ffdee610131b02e7c8405b1639271d6673e811e66a189c909c0080382e1b9385a73bae7d258b8b10aa32d0ce482415d09b76478d8179606c46993006de86d1d230e625cce9271bf04e42f7d3feb246aaaefb933ada9e7ef2b3bf93642c684d851cfb8a2765257d6ac7c5e4896f3c4f82f10c53db305d832e6f95fd99ffaabb206e989d275ba78e1196b49e56b760cbc2380ded219e41ad506d6d69a7501dc50b36208cc5ccec96ef8f1d4b49fdc81ef1e818ef44ef53cdf8eb078a4b462a38367166dc1b678af468c4623f51a51284e83509d35a63ba953440825d1dd4fe6cef7c28de85050cda9a2b7ead0a1ff7b7a180abdbea889e2d6d2f8f022ac57a3c090138cbec4c0f87b5184f27ab63b0c00f82521b6de0fa188daefeca1064a4f370553bf4e223dc2ae17c4d7ec18b0b57941588dad0a3bc835f3c5a83fb6620093a4f745281e8fcd15e8b804302ba87514b418c9ee28c63aeb495cbb8987b0584a16168c09b29f856fb5e7cca4d9f94bc75f2ae9ad03e4db50b40b3d4ad28d2ec491d0f47b13404d544e0d5bc66664f1ac51746df74dfe3cc149dc3569d7af12a2dd87ca1d29ae1d76b24ad4389b1c667d532fbb8a0a66aee242da3636f4315c4cd037d388e5a15f651648c98f198e98499cb36a2a29ca615260ed79f9d7a9f2a2b71b7ea4674a494485a9d32c511458bd76f31387a22eb11665596600efc1e11f306f8aff87891f165f1ea24fb60f6be176f6afccb7274c43e64f83839e4259b046170d0e5ca6881bc186aa049e97b989e58ca2ef1e7424ec17ca81ebc528554ac33f27ac6b874e64aa28f3eda654271f547d40338413cdad61726f029035334cce7a4eca58fb095adea1f95f3a4456a364328eb64c6e9bb15b09d4a1b3aa38db82750121173083dba922d5854f0780155f1ed617b8d3ba4c5acb192e1ea97e0286796e6f773d1e4903fc401c108dc3944935ff831ba0998d41ee6ab8de241c107911491123a2057480167207ed4cd72b8b01b03a0e7850acf2dc5f26e93ebe85e49800de0170971a2b371581344b07f83f91529b1181e5cc0679a06fe3a3d98408e5251f04b1003275cca3f64dde820a3ab1020eac1a37d6b02ef4cbe044511d56c53b4ce83c08dbe737df820f3f41911e76ad4f885981881a9100e0a3718d426d629d01357cb758f8c5518aaf614e1dda57686af8621e9487c294802dc8142ef35167e0d0ddb322e53ca96cae970f09ca666ec09f2f956ae5ab048c79909cbedc8a8739771365141610915feee1ee71146f007ad9d0631a0283b2cdb0017ff2d25d181b6234e031f4a1d16170d7eaef4c47ef921d764d5e8e1d7086753dc2c8802e2e90d72d886e9ee5a434508e09c275717dcee0ded376368af5751c8175dd86131fc22bdf473dbf788158018ee9e95a75283e7d7d8e53c245e9f2908f69364174e3b93c93ed8a684c051f3cc1b2d5a746fc5c5b36e7538a44057e84ace87c3fa2429c840fe22b75ef6f90345bd7269c67be4ee0d835ac5e55c1d865c2aaab8a3736ba96d14980bf4b12aff12c6b645d4c95213d0594e8851e5a7a2782118efb4e4b89422aec67eb5627e7f9a7c61f35b75e25f742a9e876c3cdafc4d2553c9da8f7792b0a8b788d6bd90c019ef6749cef262c9da02ccdaa27e01008539b1437b58f4e71da4f2429bc4563b3a965f655eb89b64ded5311068a2bc63b917353147af057fe5110056f0223a4270f65497860a2622c25319f59d2cfae074075d5e1161db043c6aeb924c3e7722c4162a27b8e1e9c8be85a988d5164b03e0178a1765b8b240323de98dc0b0e9318673f53841a9175f5b47be54f7d1f9a6514848cac2311c6a773660b70a20eb92bdbacddfd4cfc4c952f3b896edc3ea93136cf3cc4ae07be6576b697150bd3745599829c52e61b3f75d1734eaf78493d5a9f39065b465f8696e3de598ab50918ff97deff78a5c9317ee08f3a891b3ce44a7804e5bb0200f893bbc38667d744269d734b388c7f7a92af7cda68e399c683ebae7369be058aff80640e6ee07f612bd03650ef5fc44ba0250925efe10bcb99ee49b051662829bca9f1217f8e56994362fd1903cd8250c69e6859fffae3f967143f0193ec6a9bfc476357a8582303a1de442fee3d620c4e2e463b6994915228f1c098d12b12508944a1fd7b52048ec972cd1c3f514f320c0e4e91c6558b1e27d7fc956062debeb1f0ee87a7cda83ecf7980f492fd93e4cb230331bd543b683dd920c35452e3a08f5efaea56a3ba74a014d22abccf8b207363a5b19cf84f357b2ec337d6962e6174b4807b1688a3c0bceb2ffccbcf0a95bc539e36f9ac8971186177d437addbcbacfff1c49e381a656fc09d928175b70d4cac7912497453282b1f4d932ce08e5f49e17ea6609edb24c7448ba264a3a6de23720243ac18db800f7943268a893f1f2a180e6badad764ff69c9e938e8a3504eca9dc4c71ee77fe74794a3ab12ded5f7bdcbabdd720a6d7e81e6ec9c26bfcd87279d03919cb8cd1410f295730a4550db5fd932cc965c97e0612d37e83d49e4604506e727f469a8500b57eaf5327c87bc554fd8662813b7005b5e6fdfb1ba2faaeb6d0afa4d77ba5f799f94ee9c40bd57f1fc112b00aef7231cb003cd7084264e1cb2fbb7ba8f38ff8a6e7584ffe390acf9c524df3f28754668913f80ce7c9c7c9daf574b70196f4bb8723a138baf88b49f29a9a0469200f77d9f6dbb91d93b074ec7bf8e9fa2b1bae6e457f6f12c626b6f3d602cb79dae3c44134b56f2ad74966f91b56bae59d372e7496dd073bf5c21c200ef94138f342de2577acc813f612b87c2640ef3d9a97be774e341c3f41e7453a7daf185940e746bc59c7255ff0ab84d407ce4b322e1e561270d9ac9bd3d7379624e1fd467ac022813d22efbd547cd01c236013fc03d55d9bb1ed7cdd42ab311454395c3406413d9414b36aac8d5f065072063ac70ae06f48b8bd5d55071c842db0bb311884032ffb7503a046547a56baa7ec94d29a9f28b31e4f3cc128fa8ceb5e484229ba6998ff66760f7a4fa0c0ba6399d771be07d31103ba53cbdda84cbf3fb72af0f02391793380659c65c60dabe0b161301f97fb5cb520c1f10a77d0bc4da3c6920e59fbcca05b5a916f898a609b5bf780dd36606a30902235fbcdc4b589cede7c06a5e819453f7904ae9ecc6eac6c55484b947bc3fb500b19655a049c382271c94aa4fe5000b293060053e705e1b6d33d78acfa1a98fd0f11fa09d479710ab98e3973022a66b93aaab3ba660284de6a6dccbe6839efa2697eb4c1a4d40ce7ce715dac18782e6abb3a76e58032db33a4b4349eb6bd6decd7538848e653a4eb68c533229a66df588a85e46456a73e501c37e3c6051933aa79a08f45b7bf8fbb18823b64bc205f714d1674a69c98b3e1792f224a3160e26079792d61c669f1bc1cb7b7145947415d2437221930419eb2f88a7b1964117f948954360896d4fd99bd85e2c703c88f46e4b2a076873c131311e4277fd39048fa0e4d9831389c293cab77e7bbd8a41b28b5288d5a268fff4a0220b53d2cbaa15c3d8f2e7cc69db2fde444d45f130957175fb8fd3a8777bf23f0b36ab7434de58e4391af35caa5d46f5971880fb55c8e6190263a3032b6c1d03427a3215cc48c0a00974042c28a04893f19715b285595a282636696ea81ca3b2c52289b659b945b9dff879b9d8d9fc0480bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
