<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a47d4f3e244a5c6d6bebff57373951ebc83abb31b0d90a2fd5663ffd4b270b8aaf0009ecf3e4d3e0581feaedcd841fa27e3f723349edef7c1a4385886c3bbdd1dd31665997e93a9229548437de99de9cbb9e0919d66851dd4e19b5e31262c897e97e3bb0c145e7577216b092a6f9d72811cd820ae0c36cbd4b369c32e24c57df4e159751c9f61b8c8e0d40c50b60c041c2ca017372adc95490872dcfc1ae517a45e721037c0ddc7042966fc459bd365d6b99dd4aeb45b5e701738f1cfd1038fab6cd7a9fc7e2acb4bfedc33474de4bd3bd4d9418afc2702ed4cd21745e0dcc4ef38799e32df35e469362fb0b0b8928b707394fbe6af324b493f1e2e8b7f7c583cd9db673689d9c6d92990d39c0f5667b3de92724d79afb4f4156cb2d97400e689aabcd2fe6bc2559b223daeb8e1c5bad42eda612c608265e5c09e9514bcaa3da3a0cee8070d1e92b2b7e662e9ffd9ced7217b96286b8e25fdebcfdd419ea8ce4b2c2704dad9f421f0c6b23679d32fdc901d9c65a983233717c60c4a84fa1a63fc66cf33365f26009afe2012d83ea49e509a080ebb7f65014eab4ca70bf06414bc243d9995c3f8ee5d6615e678de9aace45767297e68ef12f55c2ac9e63830af040a916e6578be22fd1233f4cc039fcf1a3820dae304fd16c26c75d12e4967669b147cdb93773643086d8cb04c40141bead4027c358ea04651ec12bd43edc88f151fc3b98bbf6187bb1c37e3cbce254b69ccfb1ab1e9130994a730ea61f3c9dfa8a4de53db162ac3e6edde8937467a19adf971635105ef85185cc8805d8d87b9b132a5edc7d1b9e9c813a152a9e12a4fb813d259fff06f4d1b44c2a2ddbbc6ff7692d18f1dc9ef37b2ae51fcafaae0b00dd74d7b434333d44a66fbafea08638519b443a1161984717216b96f33e88d3eb65778e7d88d1b124193ceccfe006c26f2e7305fbc2c62f1defcbc4427bd5ed8a685c70b3b7f08175328adf3ed4a8633e464b7a0fe70a607eaa2619953c8838b2eeedaff5d50befc0820cc777c37e03bd952136bf0d374ea2c8d901cf58f6f2a6ff22e3405e153759d748c90919cf1219603e8a5c5220e58c91b57d44c66a54bcc72d7e23503a6bc1f615ed6b215f86c568dd7d0835cb4f26fb9359247b5d9da1d8a1126fce20afcb9d9b02dffaad252f3d65d54bb0524f890f2097e1d78af70a387ebd83bcca3b4b0763a366539cb9d3f5aa153281244997a7ebff0218775b3e7a669b4b112331b214648c167766c972817b338e8bd8e749ef4e1a765b2488ef2edad789168e6b86180323006ec7acac0f7a30edf62c212c646df4aa3203abc90253bbb50e735b2072db4b42fe9f86af170e42c53d6385d4c1c7b283271285c3a56d2f4967500ca235fc55dc11eda021f603bfde1a6e38f886a5f7b223fa6ce0f2a42c89ad6ad9de8a76b0171fd0816e4e6576fc62f0141ade126b604fb4d7281e4af4e6531099413408b25b2f81ca16924d3ef73eb51169607be7bc13b7e2547c8f2d124f410397c1236cb0b6f0c9ba9920de55f1b90d4be4ccbfcc8923a9ba64787afefe037fc60bb1d8936a003b8dc00d34f9fd6bac4c3c8006f0ff59d96903d0055b958de7aadbec9896256e2815644b13e3aa1831d5c573258cac15b6b012a6eb7a0ef95f229aef062043fc836f749d46ba2146973c9b29dcb8b3947c1b7d75384f2fdec9fad5bbafad190086e09dcd2a0f03696de9e702f465a60a11dac0b6be5df527994ba1c7c93ded8974bf62504cb06eae11589df11e086dd0c8638e02c5f1e493d413e5a840cf6738f34f2c5ee64174fe34afced8176f58e1ee4e68060a85b3b576793d8024fea666e89e56c68a7ffcc8a2ea09462bd329ab4c9562f565f415bf8e8c7d88859a77047ea9cefd30069bbeb6d7e279ceafc6ede9dba991a8d22ac030b011f2330b3034bcc9ee593970fba127ae344e8f6220a361e7e3e163d3362346926065143e7278e06e3bd52d1ac81cac8cbc0643c094f3953851e7da302e08a7aea60ebcf07a8d3f44680255c8454e84dfee00ebe935f1dc413169cb396e250d85c4e4513a343c648db1a0687ef692637ebacab27c5082d809b1d22530dd3e284fac69054f92f14089094a0e1cca86cd241b0af9e459517998e8b94339b39bc5eaf47273c84749594a89570fc8a9f0758d7aea84ec897fb7e0cd25606e259b6d87a1f31687c6cc74779cbda927b504d041f50fb19690592b781909227cbbed36f7b74132f073280dadbe4ed70410f138f5b188941006cac290fdca163851844f22a2a8ca9b5fa7f4426bf0c8504f884ac12d73a7d5c3e4ba4deeba07152993a08cc28421081123e3e1598e972ee9a86b2b9d3cdfcaccfcce0d3ad4e81090d474e5222356345a0a286a0fbcdeabf80c59ca8b90557f204a7b9982af1cba22c9d84e0bb9d1187bda740b4bfadaef51ffa459801e099820110935e2afb0911c6c9531450b8ec00f0e719a65ef70e825cc860cb5a6237d02eb3b6151f321301cdd97f7c9036a202622ad7e27f10bb84f1d2029bd13b83d31c04f171854b5c4d327c2fd8c03f1bfdddfe21b0c3e8cd12f3ff3c6b30eaf93853886e637d230f9edb2fb7650d3255d1acb48f90e0e3ceb0078c1e04b5e94afb87bb534cdedabc36be58fd67eda343823974a62b3ea2e3eb701b27cea6863ee18665d8dbd569023701f3860daa684914335bc2fdee8a6003459fddec62ebb109ca36302d364c0b9790c6647dbe7f1254e6a327f5847d49ece8cd863d5c0ea40912022caf13ecc032c810434bc148d13e83379ce201d7a3e2e10649f6dd1ee796f3d6857355f91267d352aedf0c787a5b269dde2ddcfd0756da424bc68c712853bbfa74ef84ed2b31e055204f26aeba5b771164325e7a25d5934de7e481e9e1cafc989efec406e27249f2d4131dedb4c248ac328aa38e06233aec854656d83038e42e4549c2fcf3ad1e1dad08b6861044f91818d222e42f828c626926408911545484bb3fdf430cb0256e2a23828abbbc035080befe70aeb806a7f4b35f9950f77d44f3e3545e09ff4d65bc87a2b54b8c36ac54c41e6f53f96c2b95a2ef73d13a441f48c339fbef4c514ec868493cb543ad09100a4626d10cb804aa4aba7f290e116a8d6bf4f9e6f5d54c368985b1a084136dd862bd8dfdeb25c83deb830b76ceb7d10824c1813a05ceb73b10f3d56475cac423a6542181d5533c2b55c0c637b244911d509fd3d2b7e0f6fa85ca6ab4307c22857b674694eff19439705b70543a279843cb6d657f5145ff6eaabbd8571968cd6bcfef2eea2d1d6ea1248f53f5862a5c8b4435ba32986ef79c73d4ddde8760ca4d4809eee43a224d95193f3acc1f2e1594023e086b7a19ebc87033778deaf6ce07e755fa8691933f4a82a126a6d2dbad84592b0315c9d32cbca76bfc8f5121b511c9b682d175b22ce30de2dc5f1071079cdf8064a65e00e60dfcfc0051efcba1fef30555c5acf3d8e7739d26443e4937f8891e2fa4a05c271ab7c54f40fbb3cbdde1c6dcf63dd0964bee6c4be3d55215cee171539fe97d493e2e0ea5d6faf9f7757afa5ded13608487295fd89c7ad35a5be293f6a279b5d3154190bea6283926d5a5ffd3406877a61ede3f5db967d5ca230c4a42ae7cf04e4db77fb24a1820b96028462bd88485d589d7e5f503fd79d9c79dc7d634171ef2474d9ee92779495dfcc802fa1b31ffa39680ac6c855a215dc08e5a945ef2b2acb0cd7cd6503f626e70fbe6fd2158d13ccdeb404d9b1af5b06fd320287271b78acab7cf5dfb4b3231917350436a462e31b40998b9eb704bea9621e6f7cdf068954c540e56eaafefe2ac65d549ba8092e486af6f1828b02bfa61e9f59991bd0b68fa9406e22b17748a6d55e910dbf9233bb6cf038a9bbc3a6e05b5ac8952114fb3260ead5a3b216079955dcadf2789cd7f41d919198a737360234c8008168803c23b12db5226b47a282999c051281e7ed1ea70301378054ac718e9a0b8a2b91422964ba102c1508f5e0ab7b6c9b2c3eed8b5104b816152169ef9f3cf92c7cf9949dd39f5f4e52af5e08a36395ea429783547acdd9a65c58a32dac6baefaeea97cf99907de962dc286228617d89ac22d8f1ce763142ea999c330dc8496ce31f6f5c425127c9d82d05c3b6e6ed301c2511e4ee0f163ad5a63f9323d4a5909c97bc084e123f47b05c83cdbfa1fc6006a549e627f9e5fa98fc479dbd1d34ccb048c332f4853c8e358d5448fb3d188b7ada5fc1747cf87699cfa8d956db1536e78b3622c05aa6b428ff8603f4d05ca22d8281497b1dae6f09f67f7d9ed42aea3d4193f7f583245c141d81d348e7f58bd8a0b69ac727a2131c50800375dd04a00ccd7c48d2a3891fbbc83741250f70b7044febce398008d27d822356564c7c1c11cb0f61260f2deeba48bdbba4a197a42c7ef5e842bb17c4e2af3224df21633f1fb9f98140d55b9896770000f80aeec8fed8bbb801137284738d748ce8d6941ffdfe9e3b7889462b020ae6fa465ed967f82de586d5152f93b9949fea9a095a071bf9f7e8328087ab47dfd4195c94511d0c1db7a27b62f14597157f76632cae9a0095ad0f81282a90567e6bd672718528cc4e49b11192e0d91fd72f93de0ed95d2b6f3c0b85026a7c968f4c1a2f6a593ca91e1010eece0df878445eebeb309936896a7dbd55e70c8096a25e83e0fdc94124dad29fde4d3787efcb52be589ebaf4eb2a396ddc80c4362a7941a1014937a5e29bf2d67a49b6c7ac4051b480089ce96347a408219433619ed2219867d1cfc1a785756299f6e75f607ff2f2077df000adf45dace0f92f8740d3e91c3508ee27aaf26087a38e9d4ee4a63f423a0cbbdfb8bddaa76fe9f8a6d16fadb7f094a0871f55f8a1f7c23e2623416b38fa1617f2160e6f44b488bb8b6f27bebe3397746d581d107aea33df60a3e16a8928ce83d636679c49cef8e40aaf920119799e286d997c7ed1ac8020554eff105311fd240929a616b1e6a321bac4426945ffe9f0b846f9a135166225300646f8563ecc0148c6a017628001587877312c954f5123f4aa4635d5c0f37a28d20ed20fad45b51ed11488f848f11d5edf72242aa0527e341970ffe1de47fc2b0f6dcd6cc6bc00a1cdd87dc84fc6d3ee7d8b600340292e63db83f6f7d53f5745b8a0c396676292107e77e4839100496ea76ec58929dc2724e8b63c4f924456cb42a3757098680b004b2940bf853a55cfd1b96be6f5ea9f8b93513822562753afd40606c0937d403380735a4891b875dc2cc72ca864e5d176d5bd60312df36cfd52115ec9e7e07c7b82de1f22131a673e8e0cb5d5c23d00b504c205f9e0382e0b74506f8ff9aaa799c6483d600ba2f86101bf76c7233fb12e8d6648badfa85afdf3421d1e0d6428bc66fdb00161c1fd8ca4f803b6cbdd0178ac7eeaac90edb47152ebc458c17a654cf1579659e6328528ca38784d4d01dacb9b5f236513eeed5f84193078eaeacb83d405a10992f815616a5698f84b88c6dd325c54b5e6c804144d15ba6d30efaccd498da24c47b39da40ca84544d94fab42e8a3b4f58347ef61d219a91790abaf758d930da31510074b2e4a1b32d0f22438f93e9bfee2730eb7eff19794bc639d8d4cbdf69e7a6c614d9f34855c261efcf140d0ed96a199106ffa705be70cae5c3afddc8170ea9f2a81758a69fa96a8dc26d4fe20a9ea4117364dc034136dd87a183186e1e7fa245470980d50714c461707ce47f5aa007705e98ecfc9887d04245ab7ccd95a39b91b4f0f31aac0a4daf9c50a85088f8b2e14d6d0a132774f1e561f17dc930c14087b6a1f60546eb08ca535086ad83c41dc478a6757dc8444105435b57ce4ed0e1e4cdb75dd6b309ed81acd93f767d20f38fd7ae90cb9ce7918f8d3eb0191f30bb2177d3e34c94080447440faae120feea65e3cf8ef1be4450926ee874e0462c2078fc891a9fa7ebc3ebc5479c766825510cb9efb4fa22fb3a6db1c9131fa271f2051f947d6e1ba4b08d0d5fbd4ce4970d674e58a3a2ea67d512dda07106c2ccdc7f4d5c94797e2eb84b54416a3577fcb1311dbdc08c61a6d28d651aa6bd6b0c8423846320e800648d67a0bdca2828d9e7446f6c6ec5355bad0d0372e6f962f2e5c509d9dd494ca335d18ca5c1523a796400d299043fe772a9146b6d4fdc4fa16b8cc419140d86464c60b3847b9d95c41dc68c3abaa0fbe042812c3e62174c270cdf83df976a74ad9ce656af1d3141a3c5a1f4b4e191bfc3689e40cb4ed75cca8f06b8068c9631dcd55904ff20bddabea3f79f65ff2499e478bd0253c53bd4beeda4cc5be0529ce495afab241140b92b63668259ce2d707e17cc031d1132176bdcf375afa76f2c0c9536f8b268513e6e93dd037cad3b0565ef6127393a963adbc80c0f2f3f96dd91f044c1e977d3b271b5feb9c23d7fd492c42deed58a01706e52692998a7d4369b764436b144df7b7a0c4ffc1928b6fbe44e200a87517bbd75e11d85d8373ed203833705c0d88190f218f16807c3bf5ab4d577d1223faa22836f6bab4161e918c8b3b5dd56bb0b1f408a8cb2a255b283d3894e498ac3c9e1ac460a971b916938066342ec7222f07be8f23222f84164cd4351eed3e821dd544cde566275ed0b46394f8f7e2ae7993f756ef4431447dbc0c2876fbbb689510f501055ea85cdedaf08a54d98f7b8efdea836df6fdc59bdece02079b02e3f9bf6acc0dda5b8fd7e439421e9d6da6978ae0fca9eaa1b071ecd67c8df9236c36b5ecf5dea40ba16e3294ecaaca164e6b5db4052a2e557f97da07cc2e65aadeb7358dd941c6af1236c8471ae759c3ce1e402c9bac326f58d53e74c28e5dd723782e8513f54c0fb06fc8a7892ae86299bb4f3456745c2f6fb28704379f073b3a7cc02a48fb49ddaa8419d2a36e7021109535e0c549d439eb2ee6f3c809f2c6b2b621a803495687ac6578848007e235a639fd4959cb061340a44f38dd94376c250bb4ea725178ed59712b0874270e7307f226475119475458ecd7b66c490301d4453eae079568514790cc12c40bf9505622f94f13c468f77fcf4eb79251e8a3e23db6ecc80ea8e7108169f78c3589eb7a6c8007ceda6d3085b91677a07f760c0ee8569805a760884b0b18428cafc2f899e73ec70a14231d15ce3cef6e4ae8dda2f4db508f75462cca3c69fa8bf3dffca299ed87834c9b022781b907be723cee956a676b7acc883b70a6b3d50e41e6de42f3b75f27963295585173f6d0580c5da313236c3d6b1ae7c30ae051da891fe9f20f95cae99b1c625b688513224b7f6808ef60f5321a64c6efb8e0d870f911efceed70ce3adce61f3824a60e66e2b5d5ea900beaa3cb8a8145ecff694cab4f4d38fc60442953fc50f4088e09382c54eb6f625efe1fbc331f07551dfa77fe834adeccb656bc888b02c923c17856cb06d61decbf30dd9b7d5d5a19a17d0b0fdeeef9d5148633d5d05d66d18e082b4763718b0a12b8d55112043c96af1f8402fc5a09ea2adb11ee61d3403fcbe8df7faa269c5069c0700feb05d71b56246e99abf2f76757568fdc3a09f7ffbdf4c68e9db704cf077b33800dd7eb68e683059dad9206c055e3f8baf285c36cecdefebba93a845b1a376892f9572cd80e1783e6d2c532d0b591400b6b44c0cf9b7fdae99feaaeb9c47a326d50f812cc34d14314133e1ce12449c6292f3e53c9d8b907ade41f3d1046edec3148d07bdc5e897eea95e7c90efbbeb7547bcf73b55958e9558bb15da73d48f0787a68cebd123b7eec689c94eb5aa55d6bfb5794bbce44d5540c5aecd1ad7aade37b2046e0eba4a17233f6aecbfbacf3828571be21eac5317ee07ac0589caffdb561ade4580539becdc68893d8414fb8a70eaf8975e6a0648ef3d2a2fa371f51a9448ce10c6174e098d46d6a3d9192f4c149bb58da3ad2ea209f06588758d680041aee32a3f215e195fa230eeb8f5ae423de0442dfdca56352a114ce1fbf31ef4a328d635d6c9eb17110fca2e9135e1d039f959c1ac5fd1ddbf0045e0baf7581e717c30879b173a3af17252f9f3e75e67dde085881d1acd2efd3def3ed9c823be2972ca59f4bacdf18768130bb25c29d8d094ebdb11846f2b1df6a33374da3eb754771baf266a7760eb53789134368a4baeeb189c2a0393704943629827f460492b45b35aaa87e01abdced056cf218b30a3d7774eaa137b7579886ad6f8cc0f92f725f7d9ec9c1fc73db343179dcb016f6dc83da6d364e6769c64402500fee6f384b3f8330191210e489bbca27a82e58e74244bb3d79e0b50df727f1aaf0b72093d418d6dfc646a3af652d8b1e4504c3d922d16b103465b48d28a33307d60bb1f7cb1ada1b4c2ab5ba64a25ebbe5d58c3afd66e144667f7c0eae3f576ece836a1f19526773c5b62d7f7713de871b49fa077bb4706efa44a220df020d80fdba9a2f81ec16799a8ac72f1fd74ee2d2d7b0362047b75e66bc38debf1e3bed63685626e5ac057ba9cc16a8a934757c85cf11ba85e430869e6e5d89ef9e9cb18f209289218de57326558ce684949d0f20a27489cd5a6c345e35f6872baa3dae6a4042562e9ee16c80c93239d0c99eb18f7593b28b53145af2d0b4918cdfadfd18b6a6ca57daebdb4e82ff4ceabef1fc15b8700e1125a18798adac199b71695177e79076011ba9487b34929ae306993ccfb9f7aacba6bfb3d95cd55b42f801d73499d1bd4a7859804d673aa869234580accf42a3be658450492b8635188f1026a20b27c51272759fc3a51a088f8c05414f8d666a7e9fdac570acab98e4bb1aa9300aedd149cce03ea40446b0fbcccf273fcf2be4f3768a592d4d7f13e4afa015b211d3c4994ef64e2eb22792f4878d65b2e2be4a9a4a472601836135d694dcdf65be8b5f53294393da0c992230eeba0f72029005cf49b09b4e01b3440c59ecfcad7b3acd32620c3e880c0d403fb724469730c575d9744896bb82c64399a603102c71ab14dbe9782ac5fc98a963082b26566de04c2a7bc1a87d43f3651d36ee061f4af751103e76bb1fb986959b345da05760818c0785e037c061feffdf4c931bafe1ebafc55a612d988bb16b8f48bedd50e97c3b52dd74913af14123eea0e67d6131d10b17a62d93db32d9251bfcf34b4b5534fe6d6d01a65f3aa376f20e605f619e0ee137e73ff26982d5098981f8a72bd6e76f549c2f73556390b7a9b8f6f2ace695e3cef2fe7891283796949ad0d9e2363bf8abc3c4a43e82a94666f32b3346e8e6359081fcf34f178225fe84057fa2f1ad8fce976dbda13789bd410108a3094f86ac0ff1d95e7c3ca7e879bbc61af20cf96021a0c4d1e7bf67c2e0c53d8f4a60a280491b1c34de6358298ae0653b690dbb869b7b4af283076d632a0c8ffd1c77b636886ad59303a918742ce76b06288ec63181fdca487b240a9b3fdd9ea6fc8048f56c01ba7ac6749572dd61fe00ed68ad95da864b7949d6582f253a5ac7dd87ede8bc0eb5fcee5547e88ee4d9b9d36b0071cf04f918474d7eaf9ac5dcae772e0d81800fea9c77fd09488fe9526705b8de4d1a73354013284cb22f7d2390604643feb16708e466c3e3771cffbfd97b956712cab9944b74246a85b7dd97067c5347c2cbf3ce4d903dd539cb45754c5fa0aa665e80fbf42eb8b3220e92838c91143c42f64aa54249ad8979d54dac72cefe9d8e7bdef20206be952bdeb6bfbfcbc512f89b4294171042c68cd66d168edbc9d49148d415dcc3239c5a87a08be182056b8ce79ee3d312865c9eb13d8401c8f5716583038a506bf8bc41ac71ca86305fec4d884b4bf3e87302fd54e48789ea857348caedf75a8ad841c6fcf6a442e6c48154fb48fe3a2b2983ce3aa7573bc41107cf811d3b6c23d36cb7cd2c1a9128addead93f1c6790ec2e9ede66ebd2f0b037583e5b30e641fa233629f5402861110334bb2d2894c234fd305225e6b52dbf9b6ad169a1ef0ac16291167fa964e5857b394cf63affbf774db36cf46b052a5f6e69e78a306c9f07fb163f7dbb478933bd77345717b0bd647eabb33353aaa5d42e143cc910e27fe2f9cbfa2b731bc050c3326488e4be416111435537fc620146c38268ff5e346f3ed22534b74c7ab6148381016ca6773ec432b15a980bd8f998565c5e6cc8fcd4d320bdaf8b2bc9022d33e9be96e5094b2675d6923ec1b946b4a1182927f916e83bf7e1df21bacb5f427a55c1fa24ca4b5f9362e93db85b3302a25dd78cbb020b6973c23bdc974a387bc288fa05274764bd1d52565e40ae08da55adca3d1808d67e18334dbc4728ac330c8f8994ef2aabe07b801fcd7741c442b3028f938e02eeab5701f6270780f59d5ce0c5b248d33542437e1bdd12db0c8070ca2f4fd5b799fe9e36c17da8f610bbdda9c758862133454f689741e0ce7beaff5a1b3d6f6d74054dab5696a2040f6ded6da8a06803cddc0b8840524fd15b03d3b2715f2a3818b4c76ab99a7cae8dc25329013458f826622bc3b9b7f65aa1bff58eb622fbfc20c9c6e16cac9361c808db6f10019c44b2d3edcdac36f01c60de3960e0f8b517915c913d46955d090962cc077331c3b313a7d3818048aacb868fbbc2d519c4bfef672f37676b69c2986bb7fb6a12bfd042afa1a41b20f8415f097bad11acb10854cf683bbd5b6e533f731d851d65c9fdcf3aee1dfaa3ff2ea375582c653884ae6a87ab0397a035f91538012d03f40c05d3ce3200305ab5b1f4e833947393cbc983dd6ac166e55e7990746ed12b5dd182f86665160374e01db414fb27386242f73035f71982db4826852c439438669c911b3761dc15a25e58b47dcebae9fe6c8c90c21e711e4939c44fb38281e14281cd2ee9cf58b129b65466fda0008139aa351534ef1ba37e40f620d50c6a6f814db12dfa0548d096cdec3245fffa47335d456595fe6642a6ad3453db04a090754e67a69f67a1801164e912c275f8d634c3f1d5d246a579a7b24ab4804e200241231580b249bb5b8103dab95aa68f12564ba717b0706860920d0f8796399965ff74c026b6ef7d589a277ec02f0cbf8e101b30b4851fe023833001a7652adcb0dc33bdadab47a8a701f612f12ab38c7fdb54022ce6c7e7b3775e03ff070d8c1147dfa56d224469b489eda1ffd21dfb67621ec55f3e85c7c00922cd878d4b6500b1c237a2139db7971398e692dfd75cc65d7d6488321f12253029bec7b0e91e517d97c40183dc82888ee170126dc64cf100bc5f91d8856a398d0c38875afdbfc10c35eb0292416efa53a67d5ad36849aa137211f88e0e396415c8ec7cbcb6ec03773e83950df2968435480428f7766d378c2227be0679ed7e07b61248481fa558fbaf7e4408fefc581389c18404ae9b3dcf49e7a34fe4aaf7271b4ef00226a54bd47eb32f28c6ee199348f52ae494898cd3227548431f1d1ea05b81a3a29e5332083cb99dfb05ef49210d2682ee9f93669a678f0baef456c5603797d567235ba1c9fa548c16dc1144b749858336202cf57516023d617de75402c8022b6da6ad0efc50475b842f901c2b5a3bf5147d62af30f2e63eef6587774e5ecf164607f14335fc9bfabd25c02cbacae27bd66d7eb011eaae1bd63672d98268e6af5baf56ced7ab74fe907fd513ac6897713a6f2194030482bb4fab15bc3de1839a4249ee80f0b7888b7471cc2f2f8a25bbea6bda2d099c7dde2b8a022c3b0d1eb96aa49af8abae1796739bf1125af7ffef6f6a2e4ca9f348abe5f2dfd550711500b4570e5e861da52514654020a56cd1a252891fddbb5459e6723b62c12316713a91ee74c309f35bd629be650883acc5a0bc669c1dc1ee923d291052cfc675bf588f1002eb68225b9e1a303b6f8d7eb7add37468b8fb9c3b6969cd8cfc90c4f28264f9343b5473334fde794a0039c6dd5fa1abc4023d498cdac92c1cf4c1fbcd463de3519febeadcdbf3fc1f8c781a3b4e1be54a5d97bf6eee75767441b434c1a464eda518101ff05bad1c1b63d98f2e8101a1f6ea6e58bef5bb7e008f476ae30fdf767f6c72bf548cd4cddf3c971c7a4a1a64e24b535895f01c84102cb170db06a5728ff612d51d7949dd6ea1068b845a67e085557edd6c2d112120d75638bbbe0bc86453d389b2c2600bb53f2d0092919eec107ecabd6fa3379819f2cdf3f26c96ae6d162e2d613cc11c0aa14675df401ca606f54a57f00dffc6ecd892811f2811451501280ec0127a7e178fd9f29e0c1293ec33cd3d649d7897eed2576c9ff396439ff9d582bf08ef4232565310acb7572a7fef5643d749e775529aa2bf5b61f020828010fe8efa99303bc3e20f8b3acde0be354a1750741c42175317b8c707a59818609707b14e55e1da2064584d4913784ceceddc735982f1ee6135361247a985568038b42b22de815874f4249183015d46578f5aa250c6097a0d19cd41d5b158db53abb645627aeeb9f8f184fab8a81e2578a1a44c5b33ccfaac1b91adade6028a8d3258e732a65cd17638e090e7585399c502d25c495502dfb95a9807644aac8f78fd358ac9825e24e97a217470f65cb3af54f74790ff7724dcabe2d4220bf490d59925436ee587a60c4f3b73abc3852346d989710e793b02d0d221819f8fd507ac434f472e33c05ae5c02cacb56c21d1fe323bdecf062b125c5316d056cd7bba87e43c2387be9aa21bd63616a8d7be2de3c4e2aee00ed1538348bc3676bbdc006372989c9e5e15facdd35cce64cf29db038ca39826f4fcd386da54f91652a4b6e2e5e5c17d02d4b631fc73b650ba74ce78310f633de4c30fc88db0f96f427588537a06b8ff80797ce8fa489e7d2511c83434c3043d2376a936df5294ce1dcbec944fc9d5cb5a0734c47bf64103280b07a58990f3a71962b14d64d5c08cc179f4923f64a401bec3fce11ea91c3e94634b33ed8f7f9723affd3146fdd9ec7f6dde598048f06ff0bc07f5459e98bdc932f10f023a6356c424d1af4df6ba4a5600012c47b997cb86c83a6ec1437b740acc4198ce38831813f897aad42e605f86f04f615b7f6e71236df71141b12c8691d82401a6f4c605363e1c4aa035161a3bc49e06a9b6a6af37c76f7b2b5e0519c3625a53d5a089eb7e7233dd1145eb0831880d54863bb63c644d8c2cd17be377446e51f7fd3f04c58e8c081ddaab18c7d645f766b2dd0bf50b1b7c26b8c9cbd85de9a70cfc18a1489b321c617073d5a9f4726a708652921fb46bf42b9b7cb0de8e36083b2e1fda5c5d034c1dd7dc57fb957908f3012a951235ebe188f0de202f3b8cf54149a6aaf241f79b0be611082efd5cfe4225dca7d64b62c9fe81e65ce3336004ba51a14c1b567f3e4a1777a7142c7466ce37f88ad4f2a3cd55f7aaeae3c20d0b00041615cd9d4ad1e5a5ae4b186f12fa645c4793157e502645c2615b5ecc021b514eca61c2c73d7fbd6be54b72c6087f4797a22a74cc27524783a4ed597818ec09f7e2620d0b0da8e6caa2b67ce99def975570157f42686569440ec692aea34798754b1cb5574df9d4b92016d9fe8e8bd54d327e0813073ca938b72dd55c63d5353a46a6dc4d33d55782fe8deea1618686851eddbf7595d6cc08c6724205bd9e35f42f9bbf864ee0dc7c701363e576e585f11441865926bc108b926a121a64f3f820e6f92f13b3d46e6ceec91a4d3962a9836fda002817567ec82e80971de7eecb70e4e361131305553ce57bffb596f3da395769ad7d83f8fa60e63342e38a1dde43608fa92761f4ef29ad2681dfa275654e5f5a3400079b37e8094cb5eee2fdf44e5604a0d86a711e8702a308c93a9af2a80ae030e085a24c28f6929564ee9a5bcfeaebab15cb302e9b18bd3e8d868d228bec27610f3dcf349ef1f5d22704ca16ae6c88a2079655e0377b68bb8ce53c657a1fc36a709067f388ea108ca5cccd2da577465b5f6af249b4cffe45e0796983bfc0294a151c8fbdfe23198637fb8b3a9e60e2e0a68827177e3fa36ea4d076b924518b17e22c4b3e7eb1d683841ad96764c060db4f3be9b8cf1faed9c01c9c2f484dc403edef6b97dedcbbfd964b8faa2f0c2a6d6eaefaec7a249d3d9905c269e9d39f9f04446954ef43224be822e78d0baf1c0a6cc126082f6e610ddddf4d7acbfd9ba0bc3adbe2283933f748b309864e4c93fa483968fb9cc94d5363e78f501453c14a97add42e5a70055e528d0b4fde22d1597eca2fbb876af85851680e90f275dcb88d2cea2c236ac8167297f4fd913dfe855c8e73b850de33f2a4ff157d94d9ffc2e622e7b661a2cd31e873566fd9417a3e2088806cb8e8fcfe606d475ca3f7ae308d8e9898a325b412f9b18b1c55aa990f6a9bf9a6b0a211220b0375d97b86ba2e69c705d6b942a72627e2b347cf39e01de57e10b454f2b2276bd3244843a0ad3b1e9d966a6ee386b534e4185c79ffed637500ff89cd6fe53e7e325ce10c08546937042b56676122c034f2b1b456b8a38541beac66ecb4a1be6c3da36bc764f69718c9d3837487a20dfd51910b8b950a2404cc7eb652bdd46df8f97be3ff0c52f1acc1fdd1690d1db5c232e7dee5b112a620b850eb0b133b0bf268747686ef0176f841b009c5506d70ac8c135ae818a73c54795cd9bb8ea35c9e3ab08b17e5ee849e591c0faf169d33e71d656c61f81eddcc903478609712f3e97ef95ff553d9426493267e68422ef7beda3ad0b618eb20fddcd00db8237e141fb1269294872a72e7421d6cdf756cfdfa7a3232f67acc9522d0915bb4b717d2d2f22889ac1fa1e0bdb4adc13327c958f4908dedb703eb12b926c59d39118dbbeae15e82e06cddfd4c256123ee9aa15da0add22523b00651a967d245117828bf0b5b17e00facf322b52e0d89c68a298da7ed190cc877f8e9830723b0a2c964c6eda66d1b8175bdcff600e8cb95652d4ef55472c0d71d747cd512b9b7a8d5bdd2686a23995cb5266cee4cb861fcd75acbfa610978192e1c5d0c5b2c1904a6f7608b8bac1db463665d2f4e57d155fe109b9ebc1a4659c5a8c2f91ddc658141d5c7d2330adb0a9116995bdb81627eaa58658ee673457cc77ef1137923f454ad6534341984436e9eb16b880c5f34eae9407e1202c9e65ebf09fd7a6796e23e313537a3dfcfa2b4eea5e8d2480cc029ce7a3a507d22eb281142d7facfb5fb9826cc5e1928a295178de55fb134f9d9ad54764d700a90d0fb0ec1aed19241cbc87cb5618a33748f2a095bd6a02be8d9cb8fd1d1c139d98caae8b424a5d35b88ed6bf4b3fd55b5a83615c5460f537597bf94412bca106899cdb1dc4bb7556b1f5900e6bdadb13972bf6e0eae301cadb545480387afb02bee270d36b2f99c5b9f8362e41f0715faa12f31490c5125275705a3139141943172c75ead6e0fa43d448ea0ef2237c7a17d77e8f1c465e0828bf7d257d9885bc675c2c72b10d8829113a5dc9c2789cf55faa6c7e40e4d461bad0889c4a705f8416ce9d92d49f774098971a21b5d4cc2c404e66d22f85c52f419e057664a44378c9c224fc4183272df16750b7380c5016f6f570e62c70ed9985af2575554f2ba275a2e9000dc3d761befcb9cf8b5e6010f6a20311ac3366cd7f14b0cd9144e273b2812411ced37e318c33a45cb2ab9bd7858bf5c332d44aaa29642e3247942a20049b3b140d9426ac126b69662efa2eb1b1e72ccb1766a5d8139e010205c85140a6589b70956a8bb3970666f314996d1478b78bdbde9625ac3bcd37fdfce5824e4157772028ea9d7a662213886e137e8212e1d39f11bbd9674d9f2116cdf6c6524ccc5bc0dd2ab174523568b61c55d9d0a2c46f9ac48c0b30bf4c2232ed4aa27cac06c0b3fbd0eeea4034a9c62c2355397eac98c84a210f8128af0ae790abb3899cd07320946c712fbe7e5a0a43320eb7bcadb813198098a27cd4e17a613f5037cb12a520ac2a7f63b69dcd1ad573e3329a345cd499f2b24f107af31417c25e94f287a1c1e3947029e789856110131a028db16a64e1c795acc0b66cc19c6915475f67a11409d049df93d8261265a6b3c1d7f7bace8045a27122ae0a4cd954dffaceced039817f4f3a7ea553047393aa75af95c8d6d86fa6d252d9a8c22391022125bc1c7ec5977e589bec29d2a2f5926e6a15189b6037c274ce1243436ddbc2ed37a166878d91c6b75f2c042bf0f3de956c5205c7033a324fea35eaa752906f9814c45c7c51490f39fdb9f4c25693b90157fd7e876562e802881de522e9a1cdcbd10b7012cabe3a4dc7b8a854148a666bcae8f026a52b1ffd2994df0a6a414918ff2ab8b57345f118a700184d695a0d191d07541e9ed5ec777795aedcd108f18ffa7f2706a53bd48bddd7dcb019afaea4b1ddc7820c1f351b426995a0b7b2b6634ae474ee4d437df1dc2d107bcc87c89cb2f58decf93f6955c8285bf1329d8b9813d0b40d2f4933b42b78555133df137fe90a147f1965df48fa48eeca1bd0a7c6c591a85c998eec10bf04b0a00bbecea174990f89d09997a0fbf7f5d93df6dbeead06a437e18814ab0f382790f67d04524422a7adc4ae3da48fecc48d63ed74936ddf33c9207d3c63eaa848bac3d4b07fefee3a8b46e81f970007275d6662bc451f7c4b3270ab3f40a96f3582b27ffccf9239b8fc69b71846a7f7585375dc1e1e67e2a9090304f22cb684e73361d06c8f8e7d6658f347a5c1521696180b3069410dff1d46e38e213d58db36585242b7686508f7253ce36d2a6af1bfc14868a6016a0c8b31ebe07ba2b1e230f5c50c60816c3df69d3184eab152298d76fd883e9dddab3d555e343168838024ce66c00b0130b5342e146d33ede2b3cbe446510b1ac3ffe9bc99a95a43d8c9c05396cbab9515a4727553bbb1c214c729c15ab34428be738541df5b4c50774cf9f189a35bf1820242de3fec724cf550181909f5df7f1eed77d0127b52f229ce9b9764683ff5ecdae0f283de8da3203af174e3d05a4fb2025c8db9ad187cc5da290516bb5c26d6946ecf52884615ee53f9bbf97c6ad78944550220df9a891c5b5a5bace32cee9687b3bdb022e45876c5d5cb9d28c20f687930d49572d0d81f028e4fb1dcf46c5033664435fe4fac2ccd5d3f3ef7a6f7a38a4fd2cc0049bdb644d9b6d250dca67ced2ca340de32b20a7b14c736225196fe69c92eb26fab29441f597fd6cf49f6596ed42cf5131dbdc57dc32f641739aae32b1d42e8efa30673de3008ec0b7b1261d1fc7c3da7da6f0b7f0b950ece286d0df418eb2c12096709be921fbb7a7bc3a82f8840b07888ee59cb9673a321843fbaaa85529cb3bb98bf2da502f11571b5fe00c210ad9cb66bc52421907011f65c7964e11c048a18cb225286a326c44c3c6eb379d13f6d23f921f4bf52406f9048630961203679dee204c30e1a41b39032e72f8dc555b1262c718163d3460f33df5616227b0ebe1d337271a01a214b7302f442da593717edb7cbabe1396dd5a046765d744a8ad62348c5bacddb2a4f3376f9a53b2c22add1a3de7c47f69269ef0ccdb45451cfc8bc103cac0200a4880143f87898dabc85d8c8390206c48bbc8f107ad1e1d54c347960076a0a36b3ff99f1eb453016fbec4042c2ab3bde18e53c6f23385b9a2cd4a1dae6ce186efb3bbe2a7108521b1d71a441b72a8b697e243f32d71d9a03f01ed04376d6e34c68eccf1c9c84ae88a31da2afd6f43a834cfbb8cb6cadf84d2ff84830a905906a4269ce4a0eb0b672fc20d74d8644d7a8d0ca9b144fe8f883eb283972dd3f94626e203192da097104a94985c69d7d59ae2eb229f6c64a247f8f3821243e326d7635c3ccfeac9216f7f5253f2860c8f87d27fadb24a95d96329415aa5ce2fd788dac48d3c3e3592edad3274f802bd88c32bf001692e27c2e1ac1004ccfaf680e2055f924f204d6e4afc1b55d4c516c4d98766a1f628e7bfc1dc7d656ff8a04f08a56fae1dbf91ce2778d360f8087abd6c47d2826c2bf822504e42de0838195537275fef77874dfd81cc1b6ed2b4672c9bf82d6a4ad2b90caffdff8cab9a61739eae8acad0319ceeff7af631e55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
