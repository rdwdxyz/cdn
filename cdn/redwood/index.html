<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"803bd28c3c1f25b1291710b94b9f7a99543d69bf764a9b0055063d7a56ed7370ef7f2e27ac582f5b5909ed371a4e8b338ec7a215af2586b9c6998f2e035b72ce2c973b69ee72dcbf31c666410ae61486f2f50bc8d9e84053ac408ddef0280b62f5bd837b865b375a2c982d3061e7de9408684de5dce6eb5f7228fb2109979355faf5ad4b8fa37416f0ce05dab28a57b28216105e0f22d3826622d882e2e0f5b75e4b167421e87419d97b50d0b545340d4a0b3d366db5b286b429fde274eb4b8fc6790dcbcc111781502ec342ece0309f5b4dcb94b466b6e340dddf6fea7cd735215d066d22ccdfb5c6f2e6dd4233962b20f1a4cd5c4a4d6572d5c6c78853a4aad16b9c871c43d0a0ae4555eb5f9c063b6f6cce952948bff7a0f369eb7200163c92a0270662463e4e7cc171512876786fab01f36ffd900a7a1cacf000809f7460a31ecb4e9131f30be11da95e762eb77537894d9234d0e5df5cfd8fbc322bf6714a03bf6cf1860f9e15d794a1119acd8a175df2fc22a48b3d5ccf19af85f7069f719ff87d11cd548567bf529bad19010eb43d5904c55a6e193ea73573653d9d3dd192efb79656e88ead06259079d83133a264e8a296f4e9b24b24098c618c0826fc27967b29aa7d934f57e190b332693252676f48dfc68004a2ec54b02c8579792111dea751b13fc5eb9566f378c5d3ae40de9c0fd09aff734a8a2d0e7c499cc02453e2f7c858640f8fb3f696953431d5222428de579920ff4ffb226fa35e8d48234565d9e5907b1afafa1cfad60ac6b3d8e3c3c15011bf204b72cff779ec321f36f0445b25856dfd752114e10523ac876e89a6e0239c2dcbb86aa3a4a83d214582d04a0a97806f226d92930fc5e2fa20adac86515fd4b54dfc43c4e264b3090717a2de09465596892112d44faf438cc4b7d9ac73e06146083e48e41d63baec7e39b3a8af9ec54f9112aedeb0224eed1b18c9604630a305d7970936308423e8953a4922de8f558cedfd68238d3cf769c2f2581ba309b2845c779fbe8d4053fe8866abfb30f5f6ca09b4830ec3255552cc202bf7f0eda45b47fe882c42d9c11cc9e29c95b8ae9eddfc92450718e4885cd0fc741e181e0f73bbc26442945551120728b2c91a423341bd42de08fee91c088315db2d31550065f35d8426098d28f0a6b8b87114381e0bbd8b98f271ff58c3e9a3f30494dbb8700b3fe363823413bf70fb6b2c5d1351b63d3ae75372f85e576d4af3e0f88e8579586a3b28f143de51954e42ed93c288dd9a19958da281b17669e6d18d0076e05f35a66ba41132a5ec0bb4077f4df73ad9334089e32372e8e194f7d59ccb831fad6de136d22908a6072e85a528c714c1d896e1a65a26e62759421b4c054fca7eff4cdf00fd4a4db659a1cbb5e419599ceef974a1370cdf15aa0eb22f08041707e4fd9bb2950258dae2b7a61ce829cb701ff1256748a58399c90ed150d6685433fd4f61223fc4fe19ce59ebc44944c3dc4ad4b0754a79420e1199b4067cef1471ae0f251cebbeeadff0321a354d089cf74a116acfee6c8b13b10d41ea4b74623244805b580f7bc509dc18cfecbe3a0cc367f5bf42602fba427b1125a1d95bdbcb553d190e361fba24e802bee4914c7f9f60f7a09944bfa5c0a5d8c1c4f948678d37b679da3b6a0b11ec3c6a395908daf0945cbcd48256bc1644b936407bd3f07cfa12eca738f7cb8ca5d3a2b74194b8fe6b585347cc58612be5a6c10fb7354228c037994be5fea8c82f4f0ed35c6b3e6175c6d131d7a9f19c235493aeadb104c153df7ffe6f5473d9b2543f58d41b736c161a58fa8f9a83b47258003dd6e4dcc277e22dc417917b9a37c6dce15891e680aa50b1a4363813ad950c88d3e6be8cfb5b6e680fca90a74587491ccc2c9c8d239bb1c6d165a417ee2731439487b30af761a56de6bab54b5dfd297c451ae74f7fb48fb0995c870204fc40ee7c7d1ee04d9ec4392c9c771d38a4d039c703cf61e6916e5e4a630948c834cc75501cf0aa762d2276920604d2ad28e21622dc7facadb7f282f10a05bc84d49568998ef06df36b78793b161f3aaec4249d6bb65c057ca309cf205aeb653724eb87976a4f01f6f44d2ddf2e1f834cd05c60491abeaac40e7db45af3288e90a1795d1dbf63c282e3ca124e23debdf5db16671febe707cdf9a43f7f55d367a7e4bbe4e077fc268aa03bc5c92618d731e2e35adae5cdfec6e4b081e5313109399f090de577b88f87fa76f6bd33b5cb41d9f5c11f6dc7f9443fa1f552abc2bcc6d2f96af22400f8d5240f8db3a2462439f4251b30d3afa9f390028a04a0b8dfd72b7e09f0f0c5f15053d47c4877c8bc0afa3b09f9a04262cb9c0136312ee051aa7ff83ee0db9c82d7c0c6778d5aa331c66f7a2d2a4cbfd5b5d6192ecd1186809759b6e94e640824941e43f281180952961a2e3d2898c44555baf968bf9bb4dc417aee50480b2bbe2c89da690183cc170adf279bc6564269f6256744d2c08bd2f0f40871e63055a1cee5e415a0970c1b0745b6b35149bf13e6406d06f32b4f02651b81e2ef460ea094ba9798d6e2393ffd6a64532b0c7411ba21b4351105c99c91a533c7a64f9015a5635f566054dd6df535a371c17f732024c114cc162f7d34d9589eaf454eb71f3b36d2029519d96716de61fb5487d4de2e5a08ef1e4e6bf5548bd96bd706e25226ab5d2e7544560e4d6446b17a44f5a142a0a805f08dd2855654ddb0bf8db276fe222a189e84de7ba914a75ad7ae47f0bd3c056a1ae636c43428fa1df638cddff19d497e4ff05b8f70867b394ce05b270e3d97c24b97805dcfaacffcef450522dd2ca723bb550d1c5b2d69c5a1a9744b68765087ecb2ba00935b29a49d3c7b4c9a9326ec7bf3a62fc110a3e964fe7dc679028586d58468a80930edd8fb6f815ce277aa83a05b57bd1d4573f734e99e111c1e8189ab550f408f344c1dfe0fb7a68f5046012314523285195dec8833a01430eb90cf38808d6f6bea28dc031a74a76ef06897f212e16d78ac955f3fc1d9ffb517a222c8bdf993c8493ad9126ec4d7ff4335685cf68a8594e0abfcb729ce1696c45c5db9b7416dce5f73007835adcff13321e0a25ccbd79babc717702b270cabae69b8d565a9f5d3fe2305e27f42d44d1b87ed6efebda148fc68673ffd0924eb83be8676377f6424b4cdc38ab4f4a27f7e6fc60ab75c31025d25c22e1a033359faf9cea6b908add64975aead4b054ff4603b39a1d4237215cd456bc8b4fbf5a2e78705b55df2a536010b9f40f6ca301c8c0437e6b66e7aad4073dbaf8a208c5dbcfb803fcd453be2becdf26786aa0b10c285214cfca1964b926b33d32d802decf53c4871d7be46a71c730893e9e5a45d9bfe8970ab9d4bbd91b6f82b7a8bd5cb0ac63263a947eac4fed200956b32ad3c208ca677e2b79f97917db4804f806df561cb093dd4c397fbaa3ce40d8a829481c0ac18097885b5380929e692d70226926595b83646f750bf47b3221e8e3fe8f4d623833d220774d2e64bf4f0dce04775881e623a91fbcfe50496c09144292250470a0f02642c7fbe14bcb6d987e2d7fdb4449eea0c2178db0309437b029e283d5eea6a678cd1339cfa5629af7450a5ad541adeafdb8d29bf6f616b63316f90dd1f53fb89134c5c902e1ff13ccbb6ba37302abeb7e6b46de9fffd10d2cca479812661c592f2567975a45a4ba2cc49c975a1c178f5fa90992bd4c083a915a983a0d6fc0138d35d40f0eeeb629901e947919d72e14e9ab41c2f9d00ed713df0574922e8a460ca0bddc0b261c7dae80e95d8465827074a52d0dc44631511de373864f0cc4dea8b32841e94887ed711fa60da7498b852bf4499b7155ed8e1bffeef6305cc4c5a228f30da8288e80b4b5cf6af6d1f3fd4b8e0b3df41c1e5fa1df5949c238624f1fcaf36e50fd022f2704727ea4535510069f6547b70393c710a4bb94c7a0a4043393b0d18fc4f50b9c674f0476b11f915539bf8fc75df44da1ed16e80244b8adf62fd1c1eb9441b6305cc29183c97e15ba359f7242982670977cfa8c3f2451d4e8a3a8096a1eb785f3b5e0763bcaf88d2db513dd2eb6f169e2b22e3d6105605f887aab970473d82ec31898dce06da0e97a0426e599bc15679bfece8c28389ac30951c15aaf5b8676b00848a9acb9ab3e54b87b72dfc1e6e3514a972e242d5f31d60c9aa3ea76073166708452015822121c9660cf54bda157575e1aa62c34121930c2ec46b61457a8266fb0be10ead674e141fe5d2c5e54ac4b8c2416b7b5ee5f452fe59b1e8983a976739d6630d56e0f46e9a2d7024b0a8017848da90663b4a6843ff181ebe8881b5d0c3986a219711346ca3ad02b0831fb37286cf31b495b4e049966d247affcddf17781f1285095eebe835171f1d0069b5ab65be5110d59801f7e1a4dc16af81fb594289ae47e85d370c8dd5d524d0f6f6d29abf1ac595703b56f5046fe40240eb40c92475b76903aeff53458a42fdda8366accce918785d7ecbc84c06c0b769382bb490487d46dc223a6fc35ac7ea1b37753794654d8310a973329a017ba44088f0da31af42a7721e455bf4f3b2fb8bdbdf2a4aed9f6753821df6a2671189978922785a73affc6cc6066def21026b1eac2bd665adf1f99c8df91b9ab04debabb73a731f47d1639028b4ded7ae40590c131a3386bcec476ceae44d6bb9ceacc403222bfaf68682f4d7fde0ba56afc004d691a8ad55406121a5fc74c7b92f82799f569dbc83984d9dbebde81273d429cbbce71d0f57a0e94dcfccbb4f13fc9dd1ffc91da506603fb24613bec0a9bf4246e35897ac3fc1fbb58298037e7f6a017b7b8071b576dbfb46d79c4590a0ef1f689426ceebf052dfc3d22d7ffa44b4ca631f636d800b93af8ee15c03425dde7b940a67c8b542b94adb64af84ed38cd0aa983f49fb2161daf273b821816098a830c4776e042a0f20468b1f1eaa1eb32fdcc24c0d146efd90827d89bd372d60bee696175369d2b939716eb878fc8fe04078d10e35ec71e129284e5d2a74e9ea56857342fa562c3ea9097d9b80eeeaed30b48cc2a13af6143a63323cac011293f9fff3a7c0c38a351f2b3830ea166901e77997bf7cc68c0594c16697a878e2ace2e5d037f83c2695d98bfb802ea673b487427b61635aa55b3d7f4bfef098693c2888b3e0fd891a3db569129f86d31a773a79b9c8ea7a85148046ca37851a8e31d8867dbc5cb1281d4102fb5ccd24f1ff328546520c03875012a52c97c7451f022c5c80d6bef333d63276d79b0ae1d754b396be3f555341088d558ef5055c63585cd8bdcf01b9704fba8747fdf0cb978eab763c5e4d9c57b38ab7ef86ddc0b1bdd65555af63605a7cec0ca016e316cb213f2e60850a0c7a388fea20d11c6835e352e422251059a597afc7921db5a8155e1533820b076ae2fdc926572dde5851e549b65d2f4af5f038687ab88d0111ff7985e4a5fdeb0a1faf3548ec31d5cea4380a1cbc88706a2d6fa44170e0906152b366083e5056883e98b4a53e0ba5898a32ce19a3dedfbc8f39b7a3ec7560c384d3035c576e0f13a08d75eec531cf99f72621304facd14df6e7d7c6acc068e843ee4fe2cb2dbc61deaa657c730a2309d71b594496d1e0e04553216ca71bb3833f81c4b6fb6fc7c628992d57dd50b1f85e5ed731a45dc20fb1b31e9fa96e1b092d1aae34501e0b849969e315af1ddf1ef46ebbc928de60b2fabfbfd41c71efb9add02acbd6a812a351f774e72809c7f0b446f2f298aa4fdbca52909a30fd6e2595dfabfcaccf8bb7c5c2836e564e683d8a26b96ee126cc3451e80c5c104a15dd9f24a92a4ff176afa07dc9fa256ab328964244ac2d6fa298383a4c27d8b837ae421de5d723706518350fdb1601902a8d480dbe03aea44ee88920e9dccbd0d885b8cd159fb6cfa69a855f03aec093a40b67bc99fe97fca4c0153e08c5e8430a443fe22341442bc6ad997203f917f10e0bd51a86301b744dda933e9eea2c40b0c6f9ed5736c338cad661a8c9afd02b0a3773f23aa7a87fb3cc5e401428382f04575a1dd77715e634efc0af5815a1f8449348297cbf9c41517a03093ea576a673d21769a5bb0e1344b174a80471c369d68e3ac824cc1a19bd404e7d3dfd6f61031fa8fa036cfade9de88e9cb76deb9c4864ff08d9a1171bbb39c44af46179bea289625b5c451c8f54452f7e122df1d771259c3807e6aec12554e3212f2364df96fd4b1d0157e6b11c86bfea211725a76f02fec95c5f57c0bb2461f4e7c8d2081255e84f61c62ea5e4e31bef3ca011e919b70765e3d479d1e59897880608c4904341ffa0f2519faa68f8ed704a89de30f373871bbea124ee737cfd7af2f734d70855cb720b072784a69cd4ef46f5eb08cdb2f2d89d1e178ded804b188bd7e8da56210f51ae219c8b83e8077209c4ccb1bb1992dd3f2689bb7284c57037acacebc711190fa2ed75379dea695ec79f086cd7bf86c3db8cb7e52cd3e8b4ceb78172984c877b95d38c2aeac1297d8e63096228f08bf5ec752fea22636256f03bfdba474bb2e7b1629aa86c74549dba4748c5e54eda8582a948d61c85796462f2f0478efe1e924c91751584a522d99b5650781362ba39fb147323530df876eada83cfe79074de907b49ad9984d92b4fd24d04c84bd367ae7f3cf33b365b56afbc3c25b2a7b1d87c4bcc2119f30d82fc02b4bf81902cda486037d5bb9974c35284200016fe3354d681473ff7fb355d92967d6e6a81cc8132e029ed566c3fa181adfcce81c5f1a33834023b8fee722eb546890aa288b50a490613d4a9b1885276d3403257aad561889b3d516eac542b6dbadacad606592cc171b6154ad35ee29a437187c3d2a83d85bd8c27564100ba632a983cf7db7a3ba4723fe342cce697e78e8a6883dacb8f1670f5c8224ced44bb1164d60abaf19c2fcbab7d11cbb39a47b839abef88b41be1831ca29d347450bd1c9a67319e35fbca5990cb79e68efc108e4ea12fbca3da419b949ac073f13f507ff1dc7b5fa2ad9b837d0add227fa3cb3ac874fc35f0a2689dd4e910d6e0a1ab3adb91ffd98f8154c7e4a52e2087ac18a807a8106e06587aeee2bc9e9b3e1f2d3ab6b148d2bb0d1d05847b6f0d737dcac50e602e0cdcfc4faadd8f6eee71174b4f4fd374888334bfb975d47245c5cfe50e01ef4ba2fa4ecaa68f19ff704d0cd340a75699c8cf6ad381a172ad32123c2394d71e4d48d2ee41d92d035ddf36bcc4c23b4be4e25fd57f23d988960c60ce3a4e1f5aa2e2079c4c20759c5cacc5cea4ee5c10691b971e33f29956f12f4e688cc53dbc991decc9c77253fc048ff2e7e5d02b498aca780244d73a1a30c3143cc0c195a8506c9129e2f2ad69f4568dfc3dd9a0bfbf433137f7a5b05fba32e82590838968de09887f202754af994fcc425d12dac655f71fe9799e06900277912e844482c13973e719377a385bceca674a967cfc9c76c8cd2ae5c02261932513237753c63610a4d93f8ff3bf126f953c834725c280105ea6922146a5c125823c8c4e44239e9bc929f8918c8ee3ed8cccab4b2d9b1402bcc699fe6ee82fd7f52bd88cb4f62ae2e0d712ef6479e8585f6ac68bd46d76b73b3b69d3c5b2e58749bef0f6018b93b580368683bff6c980782f9bf6005a5e21e9822aa6753ea8d2fb41e82514898479800763288039d66ff728f2e6c3b105b28fa6019c680d1a02bc7441a140995714e46375a4e046cc641e5cf6015d397cc61353beba8b2ee71af1d9b8b794c0bb50f96cf1c365c2a383ba1518992026b8b0c2ff43126c75ad0af0dc1cfa9a8368fa6a8e0dc0a422ee457239b832fd9cd7a5d70164acdf31f4c2a6133f1e7acaf398167452b09424634a07e3c37e6f413cd966f9df6113e136f5c5a2e874d6f38f8348d14b7d0eb645da49f03f4717bcc9a1f37561d6cb9deaea462a1d49af4bd7b3c286da36fd505924a33c6a32bbe9a05c9c5283ede16688078fb14f781eb00826bfd5cd07528285d965c2d56436a3833165a18569343aed9db9d9fa455c14e5666e5f3ee620e9276061f9ba7c2ee32f25649854d6e508e3a80ce2531cc79ef10d4f7e404009066c61a94ff50aceb542d8d3b4861509babe186bb8c59209992ea9dbcb730214cb9fb2213d631989851d83744a430cca8dbc19a862d05f2e5c7557dd03175e145d2367e6fe0b9f5097a9c1566f3c42108dd81efa5d5a9d18ed9f74a50e444e52f7cca0032849d83d0bb30626187eed713bcbc13f179a957ab35f249ffa0db1df1231161b1e92b207721ba98a8b2b32de8de512a1874e282c75c7a64396578d33777d7d6782e8b77ce3072ddcf288c3dd09aa00c36d45c736598d31d0016e8d0a4d4098308ab1de60b085bda7f1d4900af46b7d2188ecdea26701439456f0e9d087febc3bbce3fd2ed0dd7991553185ad51531e436ad3717be428b1f34e26cfa81a9c7d2023746ef204d211148857ea649d268ae903130d7ffe8338e16aa11f7c8f547d31825d870a3276030db96cfc9ad6a46045e380f4e91d74bf0622ce3029d2bb23a286bffb7081ce96f17623695dd35a81082d32908bac23b1c9fc9e13a7fa04c38784cb77e9b72a306add73d95d5d3775a4fea1a76331d6cccf072e55ab7c806b653fed3a47ec94025a41ab5f3fc865e53689d4188e7f7e69cf01bdf9c39203dd74fc48e3f0ffacc1cbdf05fcd1282b1596d6f6283ed13910f61967952c08f7d139b71d17b092e338fcf499eac5d7dd857919f68ab08f005679415292b0e1a477d6538c5fd35c7cd7f18f84e174af6d13d2ad351ce450e285331277d805bb54b8ac14fb0dd9e4483e1906aff62b1485bf4ccec5774d77f906569d46874d2fde6906a52fdf3840b6b9848822e6c4c5e1c06e4cd5ed9a2df32964083197c1c3fcdc52150b5a69c2b61fa99f9a50134a222a516fe14c579156c0e7e8757a0e2873fb814cd357554e702212acfddc5d8c016374c3ec769026098afdf90ec919f428b9f4b1984a6f10dace3693d376ee4f735ecc4ade39f6b592d91778ddb55b2ce44c1e6098a1fa38d9e0a699ce27a46c7870128a8b364f2c5fb80ab4fff9ba412ec80af3c92188c45b09cae8cdf56eb48bf0979ce6ac9aba2a87267f5023ca963f26956cd37eae933c77b0db6f143800fd55eb8aab002c52db1c2cb5c8556e5baf0dcd63b30d2034ac20f3e16b1a67633fa18d01e9fc50ca044d8ac91cf2fa6623ea6559a02b066ba62d8c77b9091e0109cafd1d40457c23db57a42791b3857cf5b123eb9146022f0cb7062eff9bc0fb197178583295294026009bb04f12d6c22a05ae1ccb4ebbf79fff3c97dfabb3dcb681eb11e0a668ebba7180e9ff4604585671d94095392e6fee45d8b0268a273f706102fd68d265c569c1435187153eefb2b8df05d5b00264587663e9ba854721426603d484a9aa1a60815d552366b2695884d23ce146142ae8fa4df01d240a96d04bd51cf3b95f4ecf217400236b86e998cbf0ff9fb5785de9fa6dfab6033df266fd6262c0e6027331ae0055a294518e93db1824a866f4c1827c038a72437da289d866f072a1229d0890f824ac626e42746ff3e08bed733691d534016a5fde98c14938b54b8fc0d157ebd279e979d2ce85b735b7110c9f099dbe6f8079866d76ac4599ba3ce73777d4e23532257a654066ccdeab5a21f7a172331e4521fbd9b9fc959e395d2da6f912c49ab53ac5d327b1aaf9c79933e365c7e01e7366d21e5d08e2dbb7779aa2f20312f8a10b284aab266ffa832e938fc0a9202fa85e978423b818493f03b59eefe3165582427dd0e9967d634aff7d4218007481255147ead5961ca0299587fabb901d50c2bc8de85178faa7e8d4a95929b29d8156b55fa3a4a8a4d964989665acd1b2fa03a6d67f584c82b81c6d0d9ee3d6832855c85fbb3ce6730973ccbeae778bd1b1e661b4c1695aa5bedcc864659c85bffb883641cf5ed98ed47bfaf0e0912bdc00b1bcd5bf89140c8885cdfb3020af7bae340dd707f8a41b61d0fa893eadd4fd822329ea8b7c9db4c25d3769fd1c976b584fe638fd7bb8f48d6cb5d797a38ba078a2e8c5d96094709e69329acf6451f4c89d88430256a0fa763b376ee33177f3e6b2f496881477226321725e4c20063f55ae82ff12ba1f7d3eb0a8c1cd72b5b490e0ba64084d784ed3b4191dff021a0ffab4c36e9ac7ce8f4177d04d8cd7737eb58fa9916726428a105e61694c56a911b4fb73a1611a47ce9b2ce5e819a8503373a1380eaf0adb62a22219f699f6d72c526dc2445f430f6aaaac79a5b4f60c25ab8ee7c0ff9b86d5dd17b1c8172bbe748417234ee6ffa7c3250198fa3edcf4ab10e604b65","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
