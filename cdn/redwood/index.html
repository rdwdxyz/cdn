<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b900d0a199dbe3420a469783b93a672b3ecf778d87cddd34201d0f885edbe15e19d004b4968a7cf7a83819d069b6e5a49cfe93c0f3a8749f58b729d91c8d4348e66965523eeb1e68110d7f4cab7479717858a6555e66b89bd4655b865cef265951c5712bda36c4b4ff4b10e51ec6ad47a8be746a9cfb9cc84dca005bfd51c31a58e4d101c43547037ec2e5609e9c5e4f099b9935899734d94800e3011ca2a28a2cdf1d74fe6b3939c4f12cbcc1983902cb17ba006e83fba5aeac7f7c097e93166e09d2abb5a0fd53da3ba64dcf2edb74c4790fda1aa0374cc82bf0bd6c86fb6a77953f5648424c4a1a08f215a55121415e1f4764c5e1398977882a80ce8eb5a768768b35317f37af8fbbe01b9c5024a8692757e583ee025f8a54c1d185c2f96666dc73906c88ad762012474fef4b21323d31b3ed6944e98d32557783c608b9f1fb0edad3d66f6c109916d28a46963fc35c8992c9fe37822fc9112a90d0b81af652b561edb7432b2c295425a615eb85c6f8b30ef16a2e23d9124ad969e7a58ee613f0628d6576d08a3d56cbd06cf9df1ed86f6cb49b88cb57e91f7d2f5869917675011c083eadbf502ddcb9c844e75606b18b3d485da22baffe6b91cf8759a920020f889863510957e81301980a78926d23e186810182fa19c1adcca66496de72e7422fe0b5c1e7f7c1ce3ad7894d56d47c73326c3048b6878bf4d3f40783e4bb55b007803ea6640b45b796476e27a75e28f6ef68cda1836773a466c14ef52363e31074d524f284f8acdee71d3732a8976ca337bbbe0132d575472a6f292641d35dbc549aec929d46b60c897f9f2d305539f13cdbf420a58e1f536d2c68e17dcd4785680aaf48a0c835e3ddb87a1452d7fb97237a15ead19199d17c0439ed95065abfe9719d37f87c55e59ab7c2880be794764f6951c15dcf8de2a9814bfb5b6c1fcf74cb62d281b3eb4bf53603fc969d31217b40a1dee45d69f0c6bc57e64ef7f6899491791660562c0de655243ee009bcccd31ced06fdc868c11e024a5c74b86fe558cabcbfd44216d0384c49e02a08116425afdb8fd22b6e02463981499dc65d21947ab9e54479413418a10d548053e4e72beedb284059fe494e45c0fadb0cbbf24250030d3a9b6a479e1529e02cbea41eeb86d7e65a6e3fba7ee9429f024f044a0cc7160b0c3701f4ec30a7d688a5f3ea787c128f880548deff8b5c163251144ebf84ea7935ff35e340c73dcafab4a719a14c9960c8e7c568853ddfee11083616971ed8ff2961549df57b7d23238eedf0c9b344f54652c37cfb5e70033afdfc6fbf4bac7e6ffeba8be99df2963275c69fc28ee1607fe15b14ded57997752b2fe968f9dddb374b6a05d57ed26aa3b251739f28d9a6a3b21aa502b274ef1aa5fc92804024055bc548f4dfd918af042fba15c7ea1821478134921741262f714a5721a9c9e140de9f58421e0b7e1ada6fdacd210b9ffc5a66e5d3c0bdc2610f708416c54af82d92b7fad1cd3e1131a03bb69c4c69930060f793fc8201b0ee15b369551809b12ef25929450f42f3970f25a62fb45896e4f07fef35f577ec4163bc813039fba3ed7d80540a5a7e4d8e90baa0b224a8ff28e0bba2681ff445a2ea6214211f504699f725c9db88ef0ceff36027c8d7a581545e66b9aaf31d5eb3a969bfc48a72c0428f840ee3d890f0aeadfa99637a63f7ad28c6b081caceff3bcaeef560297670ccc50a03356db8f8044d3c4d53b8813c5b2bce17557e3f10e355c389f254216e34eb4235e5fc36e5dafd87d2ee55e49f71bc773f119f779851e12c1c629d9129e4602e62ebe10add108c3a8617f8c639d34dc884fb9b5dc21a01217a85ea9e75b82c4264d987e2ae669fc4fbc35a5419067bff0666dbcd7fe0521bf6293dcaadf9f1cb31af6ce9baea911183ba454e6efe7d1f8489024c9950226c211b6a73bdc999459dcf242abc2ec8766ec86f22364b400b78ea6c36a1def85fe14fd30cdc2f6105beff38ca2f2c33fcf2b217a11b71257d5147b8e97ca2451ee870194518d251ca1110677bd4e828c04a5f697c7cbc8bd451f053561cb28ae937708d2fc26d7d711a9b5b4219d60d30042683d8c469ffc3381cbc1fb1e1fcf7279c1c8dc345863ca306eeeb95d4890d11ec726d0601760b5deb646fd2aa393780f4de005849718f245338f346081813c085c5d4f04e5da53edfdce9a9cd925d8e39b2453855f2f248242673ef48a94cc3eb91979e2d5920fb7c16b7da44098b6844368db88c76543073e9c0b9a4bc0a5022f593f7c1f381911ec5c54be69d58022b6d59dc8bd1f620c6567cd3fb94cfb7931e0116312dc70b185174fc00a526fa16ff9398965cb1b21046823c53d3c5459adbd0257c5285050da9e2ddf417869c14fca661b5a73ca431246872076ac809001ffc8c61b1d0b98f043769c8f59841520972d69570a7cf196daf9d952acd614a05b6da2219e6056ae1befd382f0e7fc21abbb600aa635de78276f2e52543b2b7b60aedd836eb79b220502ef6c1934c17e688cb5f367113f5d900ab10d37c6b778a8422be96daa21760339c59dee40943ee8ee67fce3c90b7d2cdceced4d9a8e79288f232a621a3841c55e3aecb94dbbf0e7905987064d148cbb79a59acd8a363503e07648dd638b88fc5cfa32c96bf701148a842154320856673d3c0e55c8f3a40c2bbb1282890add159d84d70d753e69d7eda388cdda767be46d74342cfd52d2823e40fa731b7e1c60a556908c4d527621ac0bdd99ce0b4c74b8b01cb93456aaa8a7e011313c89420dff0f25a16b906cee9f7825b1c331cc09bad64c4dcf5d1e544bdcfc964e15682320e052655309c7af72125398e8a7d6e3f8eeaffa7f6fddda760e79e1937f726a9648f1a37c6e0dbc8a7779c363974e967473b167f72b2216fc2d226e6f91df6ce0815c880e434114c06d65f98f17a711371f0502aeb8390fbc68ac027ad1c6573793b03cab1fcf9342a16c3c2050fc8010e82b84bfad988a081fa4e8bd061727c8ede835879822f584e59d7a5e0b8e8db028682e8f390a5cf3744437310e05c2f5f62351eacd71eec5fbd2e1e5b187837ff03653f02b280293541c2f5d90609deaca22e0fa9ae9c75b8f03ab8dcc9054fbf91d235b7831c92c7013a3f45f56520a942e56e2e79742cdeca61447e641ecf43cac9d497bead31a3aa1d4d456a62aecb4e536df7a4d10164b34e506d1bc15a384a386d1f99b6fdfaaef82db9a5c6cc1298482ac20ebf7129b019bee4a75b2d98f655c07802016c685c8b49d495963b234469db36e2fbed3cfc8281b6e01550ef3f7fe73cf696c8b25e37f472165a32c7d91059e83ea5733baf5da3e5f322c970100754172b95c83614787f7cc980eb80a9ad2c83078d33e333da7501a6ae273c66f6c8aa9693462b10b6de5dc33780675b7edbd801414488a062709ad6d7a69f87e2369bfc412de7616f2206b8ac63ad0caf59cd0a7f7a60ff5924539a42a0cf9877ce4b11bb3361811c102f5f9cda87f07f19584023dddd4434580d30264dc2d80dbb7f0592922cf62ef9c920a792fcb9ec00d6ed7934e054c01b4829c27a53e99f2ad7631ff8b7723bad3406497af3ba6cbfedef1f9b10b3855254d0f7529e651eb3c033d7fb65adb68a55778438df8858e9aa52a887fd1e3f5d8d9e59b07257c1f7d4d50c58ce4c8f93a8b0edabf50ec66eb2433a64f47cc4c8fb0270c54a5ed79e24755741f32e0b585f6c07122c5c8637aea89e1ebb3f61cf5eef775225c480b5b07e0a08ddfd71debc6dd742beb242000d9f1c2d0449194cea669cdfd53fb92c47660e163488bc72484390060690981c786f4e8d7540e144a358cb0505e6353a184d9a27d532885d4f70c9b570022a11d58dfa884c8ea41be755828e1267418836141f0fae2bd9f67ba08d908413f9ae8366a6f58134c670df8822da371254e54c00aa3f08e9b5de23d246a5b5e39fa98a4a337b920caa9faf63e6158d2b2dc3951d34895c2f563cac3e03e88eb15785c1a42fa55308425371d8849c08222ce1aba7be5ee607ce1d33c10ba4703212451b6a543de3d9854754ca26a6d00d992355a435701d69c2f438279b55469c1206a080e2d7d8444ccc091004efc3e18ef0149d6baceddf7a5bba69e8902ae6efd4873c00d0a01918a0826fee1472938be3d3fe4b816d8c6b5e159b8abaf29d8738ec5bb39735939000fc36bfab23cde06ef1f4681900c1217a975f391db6b3685677b74f9ab65f97884b07068426f63d176fb5599e60e0c78da9ebad53fe5affd245c173b2418411d19c6774077b3f7c2a58d0e901ce97a801bc70164ee7d6c10e3d09588295e488ea7dab2b34bc25a1549e2f86ce3f926b3eea9e2f46032decd0a45af8b25256f17646c2baf3f2a6c663aac8f0156efb82107d5d20466171f17c39ad811054354bb8c5d031d4a720e3215ce51c739dda526931531a47ce68a710e78be23ec7969693ec7d707f4777f410d26502f1d84b83a7cb0cf41c195ea352a47dbcfccf7b08380548fc31a6da6f936e122d96af558021f2d923f39d9f2f6caa65773db376ac8fadab060fcef8cbd87a387b8ddbedf53f28d3f84a551daff32bf7b4ff3e29509177459a6ddd088cd3c1f92b383a117655eae78f8f8a50fdceb16f78efdcc936c1ae6fb31992caca1040af33dc3b82502998952eeb810e48cf691ef4b3dd8a2f4b07ee889bb1f4fb3703acf55b9fcc2f08fab8727abd2fedaee579754c49b3cc6228d0b5d527c5b1fafb52f903d8ea390043526e3ec7e61d53c41b5078865c4aae4858d1684f43e25a6839a7d32d1e12bb12b43aa254f210b2070059d2e91bbe71a7f7de8989ae5fd43815ca3707de3dc59b269c170dac62eeb14893ce601b7cedb06f536eebb659aff5dfe46624989d07808488a88dff257da84125d53ad17cb2d39180f47fd7502937bdeb505f580be8719f0a3375da95d2dafdd31ca823c5675a927f8b575d66cc1df06f161e45672735e46ab396f6e992efa1479b9ec9cf07a02987950f78aa3b42bd8736da0c16cf014e9ca703747671a694642cf98c758787fce8ccaccff35253666821e91a2526d4229dd78e85091398e3f20ec9fcd73f9249e7ac94b6e635c8703698f0f121592f1dd9806ce84f419c7eebd6e1858d4b53224fc12762aa5b77a68c082155327c818fe01d0aec1aae5a5fa51e4691d61f61e70d1381bfe32715e6cacb98921b2d41fec8817d73648210dc3c1f411d7a66fc46cb59686c1c3263b65eacb6121d4926e3bfa0f3935732eb07e2727081354fc3aca67c8423bed5bc7e463cf637e657f3ecaa29a651cdc09f54ceda6b78e3ba5ea76699b21f246c088a86c8ce78837229a22522f2a0df7b6d1543d5b89c513e80abd1b95fece2a83b5ca8cf3cb26d3879291ca2b485675fd84539172110c7f0d2085b604e4b65026a26fb4be5fa7dca65da455d202780065f57281ee19adef022e8c99539c3ed9c15e18eea4307a8427b2cdd0b657ea050371181e6ae779e2f48fdd9cabe8a01e7037d9755a0acb8122ad6afd71899c29512c08406b647ba62c28c1beb34cea293290d69e7c658536d2524cee326ab69a09e45d763f000be5b5aefb92db158d5622c45ea4d79608fa48737e3a2209b1af97718536a269f1062a2de22c7ada7b130447189014dd8898da047e70b27c3add1df3c1f033baf394db442f01185251f649daad3f51ec989a765ea630fda83ee39c12251ecabceb82ce7ea5bf11d5199114bcb5efb66c1c5ca86331b17c489ec912fb916204a98b94c495bc862945577604af5deaf8c146a8bab3402068f7cf7fd95314fe5bb6b3f36a8b03f55920ff0aa0ddf6a2ea4852c8585397d08dc07f04ef98bb851cffb1bac8be22ebcb7b73acd55df4c682ab6abe5f1008b47fefc6f5b1fbb1050713960b5af5c6dd6e85b128c55578450e00b30df7928bd4e0177c1507eb3fd5d156abe233b16444127088061f7a1ac8fb9bcf512a37fcc184c7204d9000b7c1fdabc0a3446bf473cf09df6b408ee61243f9407497a15fb5f81bb7c42f2034b6989ae83f3e2b35f0e06c88c6e2f85f040955844d4471477fd43d84b598bee2ab0ddc3641b94ae3c46e78d0e6e62018baac3865ba6b0fe748409f2721ddff81d19c3e0799ec1e02ea567dceb391a0b56a336ea7536113350792fbe1badb27c5ceab054d8c720a58bf04092faf182ea347fb2a0dd28b93813849c4f9724f65370e43ceb42112643baeebce26b650f578340abcf97e21e3b53ae36672c35d6517182b460cf46b83834b8fbf41c62ae56893c0b8894bfd1e097a917fb6f603799dad89a59b8d467c5fbee5cbc2f0025a0ef5c74768e7235234a49ca55c08f9faee0ba0468a5fe88e6e2993a1b6edb40ae2736c02b1c14567ea6eeac8b0ad048459c4ba219ab3728638645fc93d8c154760c631153b84574984032b46f06ff312c1084f002323c82ea8becd91d66182e09c8fe032c4158195ae8cd2a45dade1f032e02bbd28a95e9ca32c93a8649efca7cbb140a43b7b04ee65ec6fb2eeeac75c528e11eda161cef4778cadd1ec085bf815746e3bc508b05a8e4106621b02414683a8ef76d87f2a8f495ebde73a253d42c964688d4c1e481a0e922b682affe20380be758121b6dc96ec690817ba0ec223bc9aefced28c0c46fe8632c6b363806f065d47bf7dfe6ab453e70ad863580b6c0f6122f5bfe2e0521232817536a835f1722aa2fc64cf74f3dd1507acb6bb5bd64a557662a7accb7c406f0ce0264e6cea202e8e48de5c48aa3a2917fe0e80f7da74fa6b73dc968199fadfc18bfb8f1410293fd77f334e5028de2376093d713d3297418f478787821cdd63bf7811748659f2d264c62417a133c863c7102f67eea69b05f6ee94de46afa596b985515b1231096c40eaaa6a25a704392d59b5535a1d0eb891eca0ca06832dcac9a1400c022532a1ea2466292d2d6f871cdf9fe5b4f3a0b03c943182794c64ee040a63479402f174b62289edd8309166abaa255f3260b2ade32e88383368b55c9bc220446b26359f35a7f45399a78bfa1f60ee676518a37918f350dd5c06d316e2197238b569dfb8b32d19be5763a50ccd268a30ebe7f21542440d0a52a9fe22ba4e054acae61fe8852588f3e609fce4fcf64401f832782ced93151bac41dbf5ee1acfdc639b8fc6ce06b04b676a4995e3a9868dc9e55d928bcf25953ac01c557885e988bdc6e20fee7843d7fd022ddfd5218c47f4bcca709214719617ea756132690d3073f5fc80e471b0eeea826d254105b1d2163233fb419ce7ba240b6dca3699e21535ad112d3b0fd9919669edb4033fe720aa368fea9e3c361f3517bdd9fdbf362e6fefa3564f13eb14343e9c7d14a34a278b0e7cdcd6b3e0e68e49913325a337f375ec56c837132bf9d71bb4b623db99a33c6e8c2acc4a7a63a9563ae470bc521255b6bf5bbec2752200dc3844e8f4d4f257fb3ce3af139eae9083562b7b9f4f3b6d1c3620100f4b9e33928b2930428121aca11698f58e1bd543e4864b64842f845751f992757a38c76e0ca0873f07dc2fea1b21f8614c03c16c1bc1fd18493b5ef0a37e3ecd0025e5b3657f18e3d0ea1c12de093afdf744e3ca20e90684dd2135f83fbe69cc811d7a610b5e5bf67fa14c9aa06eee335ce2face7c92712617c79f77d255c43af2490d6662f9880200de1421cecb7c0311d4fd98aa3acec6e861d33cce1c9c948d78e01daa377fc86f8b37699d0b85c57ab420383427ba4dcce85097ad525dd1879f5ef7d6b9ba757ae2d9bd5407cd4b10e7233221c52a2626143eadaff2b867662d07c1173b0b3c1b36dad6b1f8284f083da5ba952664c9e07795dee1124ab98c9f50cb8f0e950790c5afb253ce0a2f501e0cdfe8719fe0e607229bc96f2c88fc0d5b4e154672b776d5b4d9130a225db8f215ec397b13f837c08c01ac2dc92de019c6f8f4f8b5ca65005e0642bd10728b6280ebc9b5e3dd37c0f257c40eba50b120e8dd15e7ccb924005d7df75fa3f8e73ccf41bea614a08fa4b9004168a44b481c982c873a9400788045b966dc6868819460c07a6c655c66be551ad66d81ce2745fecc045977e26030533d51d47ad401d5298d81a3c0f781d9acc1e9910ba1eb205c5e3e57291e5b534437e4902f0007dc070c00bc02570978014c7403fe3dd2a1222015078a8c872a599346dd7ca2166ce0c9c8806a202c4e488f13c226cd6ba4e81333d35fc4799908fa2b06948636f31300db25079d640b2a83da74b4ab503320837731f434f10e51ce0ec954f063491df18d0885bd2957293383cba34e15e5eb7ab7c2d27ef0878511f15d0a48da202af7034c90b9ea15910b46253f1070c3bc6598e86d8898d747320aaf9b110ccc2d7d3fad24f79430fa9eba05eefd4fbd9fdb2938f6ca018d7dca8e8f37ad094566f6fd49af51774879f64bbcc9154ea5d3071d07320bc0203ad99398a0151e98b906376334bda02f9005dac82de653e983fde5265123f49bcc9cc443e49f19c6d7c2362e1fd0e22d2cac45c7ca8b891ff50ff3f0f6841d972f517ea474afe3bd888f94e5f03a9f9a18fab5c758520c29ffcaf736007cddb076d62c901ec8fe24881c62683b0f7c21156b31bcc12dff888abe136c129c6b1bfc8e10d6176393ccd60269b45ff810fb9e9b09c220e26ad11d34baa5876e021d54a8e05ca43c247595c99c7bbd1e451a53b640995166424973d3079e33c57004e67256340fd75a086e268dd93ba1ed980af5669554167faa9d32bd8b117dfcf28e1d004ae8efef61b3c9a46f455b0d549aa2836adba80b124fee1fa66d47d9a010edbb2b502a6bb62799570e66ef5b7ea321cab831cc26d110714335477f318e7e55d206535329554a3e0c2c2d1704037c9bfe5b4a56e425b86c94dbfa6895615f0758827f2fb771bb0803eeca59b2a93c529e0c324d2fe49002ee5855d14c2ea8e2d32364e01bedcbc8894d6c4d005ac4f41db325a71b8c11006d05223db8a06a054bd528cc874c70918876bf5902d81a6be665bfa3cfe05cbc4f97253ad93ba31969898f2c47f44e8b425961274c5b877e18eca90dbd8694617dbfc693b9dfb118b49cc87f21ff7aad4d008851a6f43c682dab344accbed955b9ffbeb2ed120c76094715d9f9ae33197b34524fece32d962224c1bed705b8bc9510ab4a9b996d428a5fbcef3714870d8caa56fb5049d97c9e549c7601294505c851b32693cf86589682bb4834460c04ac974eb300ea90b57050876d8259b9c0c2466d68ee7528605e1041d64db53931010f90925397eafa27f9c98e654f4dc402c2a2f57f2692c1e69f4638d977108867cef354d3af31dca9a29869c0db37c8e3756e614523c595a56259bc32b381aba0b0fb8057f81f400c74557d8d071f70b8a7b9082e82d4bcfa1b5e81fe49853025981e6cc82e9fac81824a6866131ed9a3cadde8bcecba0722e4ced61ab578ed866aee3bb96c09d8728a1a7c5896fa430b6719ef1d0965012e9fbeeb0e11732cce721b538d7eb42cc02e30f81fd253f7065b4182af6ced1715edd1cabe556b52324d3efb9c7f62105e77b8cb345110a60d54f3a0b8b9c75b4af43378ad5bd9d5ada4514ffb762c7bfa6d8aba15f1420e3069ab8905979cd5c4f3799741a9bc2e02285d37ca939bfd5376de3416fff770ce3df981ae951f5da80e802a7fb04cdc7beebc892aa834e7bc0bf94ee4d20754af253219c3cc2a454c9fbf464364d3ec610d0117fedaa0d842d1c72822e29edf816d7e44b313c49eaa10bb6044d261c3cd53870637ad41188c944a905e08ceb452fa629a20df2837ca6e961f75289e627cef62a8abbe05ab0e0ebf1a9acbdce4b01d17d9503a1627ed2aa3fe567f3a3f8d33a013d92afa133df908c149a15db196cb9ecd437e514ea844cf87f876d1ae740aa017efd507fb69fa049c9e46a73a306596ab8cca997c20f8b6825f8df4a1d4cc32d785a35598084e71aaa8dcb0883ea8ddbe20085c95b18cc798a36815f93beb80a8a62e2ee06b55269672163ee22d98f992f24b46a1c2559a7cb239a86587208e48a3053f82ca110c8907050e4cf05f5b17e6618c02ad07d45d622a08d0e801eff767d9b91abce8dd07f6e6a3d3e1ea8c5b02c5f34d6506886da851a11316111600c0907f7eec9d4471a30bedd557952d6a3801fbcef96b451763b629439bdccc0efc333c8563315a6d1e42b0f8895a35eb03fe1622f98a23b747756089636db322ed345fd46fc6f0f185a9a64f08bf6eb271843a79802c3ae336aa75f14679a4fd3627956770d643fa96e8bdd5d8199f70feb45cf5590408a0fa6ab0bc1590e5aa9065bb4c2782c59abd2e62e146dba5a89547623ab12bef449fede56123730feab60cfb74bf07481585497665ad67bef924d30c76238d691b46b912478691eabbac1aaa2933f3d4faee83331194b6549e163ed54168c09bb7cbdc2c8f4b9642e0a6cef83e8df941308a30583dc72621a6a873e15821d9df38cc5fae381d61b81290593de3dd6b8f2ac4643aad07fd2cae70718018c3f081221943fcb0f9940351378169996d838b2a5e6f86a9f6b85be21e29e008cb567aadce52296865cb7de63c3c6a3ecd909c36d1c3b41efbe9301642c2e0ef515152c94b01f8024d75f5b946e47a759bf51d02a2de9e8586e214e8341c9576022f29a4f39c19e161476f7b227b272cb4982d6944c84270edbf85ef757a3540cbaf39aa393e7077b9f92be863b6f705239a72b8acc83acbddbe6d856af03192010c23f1eec8b26fef1724e420a5d6af9d6cd6dd0445605046cc755848a6e3a2df863b07f6761c8a475beadab38e6359c3cc3327fcd1a296f61b36cd8f7033bd560222261598a7333e035970e0fc2dd93e8d2be5c32665a235701e833957635ffa3ea348f96a542dae80745a1f17151501f50c91d46dbf1a8ea399e2bcee9e82e76a271a2acd4b4492401c14cf9b7693c85662c9fc7f24c1164ca6a6a954a75438438b872cb0d1f39e58d8374b2af6d21160632e341d1f2b94323a156292ada7294c9ad24e4ea42362287b9861dc6d8285b86ad44bb94141965b25e53c16b3ed85996c05b7306640dbdb4a50c4642a35fb0cf5eb4d47550159e5f67ff7ce1732408ea540711d2f602f1e450ca474052cc9a48fa0ece22f8da239dc46773dd814cc077192fe982dfcdfc8b3105560b464d4dab251423ff4a6c9d57a7272a27ebe714203588f631d8b36106ad48e58522be4a26ac8df209b2f8c0ed4bfd4cc7cfaa6d82184b8388f37f9c77401a2d45f1f8ba5da80efe4e10e86e51e70a0c91bdad6c3fe947290b31c1c36100a5e64091e68c10c204ca0824f1632c017fdedf5b8d9c2d5b80bbcf037082549a4135fae43304ab0a7ccfa6b68d5477dfd0a08b61b92b95c6e65da1d684068cf4fc30ad7d9cf67093f4f3b2a18f342a2a131d97505392410df0e3e235d9fdc0d4660f0913ecfcf4b11c68a8fc4bbf21d7066eb379b9b8ba99aaa79808b8cd4f147018716c1bb93f06c386165ebc172dad8211e83c4b6d5f6d2d0480e6a1c47f9d7b7a4c8863699c6df96a814089bf0ebb63ba1c2dfff11e9c0a6266ac29887e71c7f65a9dbef8f9159b1dd961662fe69dcd9d4aef21f9c280d75ac0dc41d8d97518d5b6a7ace31f8111102e20b9e68bb4d467e82a10b19f40fe09a9fbabe79fef7be7bc85dd5f6b108274639ad46e582f1aeefa96ddd46a7eda9f0c9abccbf703aa7509a1a8040738060ddda82117b09e40cc791c4643902084b1ff6109ef43b279826f27eaa081519d53591f5ec5c0dfbc49c603747b208b1bc3e4f4cd76882ee6e40494eb4115cfda4bec80fded0b2b754c73bd9de9891e20a9691a4895cd2a88e67637e0b71a0a580379a0bade048bc64a4a20a984176346e4a3acd5b52ba48caa8461ed679a010004c8cf5acbe25e84894f05141e29875ff94ebb14d78e01fd6c9093211a5f7d6c44a6b5f39bb2ee276fe3afe8a819f0dc3016774997e8cce35957dfc1a4af005b75ecdb670748444ce968a4133c261e971f7f51cccb3de8e539323dda3101c930fef1ecddaa1c0afd39e2e49116b3c0001212e5cc276979b4a958111fe8b927f273a5ed9bf353a65808d7c9041293a17a521d3149a2c062fc147f740e383f5d9e347c87243ad539e373b8116eb769b5c4e3d645695098dc5f433859fa193500c8418fdadfc603cf104dc1263cca60991b5121726506fc2d1eb24783aba04c8ed87d1954f28579394fac5cb526227a464031f46d1361ec1effeb51c9d9e7e92735f46408ada35f01d76306bce45bdad21c308345bdb64dd33392d93173efc27e00be39f5b8b34dc1569111f0b49e34e37cd97033b9f1ff417c26a3bb7d786db892f4ec451e7596c4e7af395b6c7f878673e8c39fe087b026b58238c4d544762ebb7b5dbd19295dcd6f98c614deef1fc35f5ea02a2ec9d6d56a511b0274d0d67abf4dd2a55606047cc10d3807bdd86a49c233d17ca4b63049d64e8ee469cd6a25467ff73ddb5031944dbed571be7fc57812d4d5833cbfb711aa37104a04b763610011e01c841f5e5c5a06d735acd39cff82844764e4a5f8c3d65fd5219bbdcdc609ae8c8eb318ffece81f9c14eebdb325aadf37e7d37a49daa2f97770d7d0cf5508a237dcd751820952ac85c512379c84c69a3542e3ca782dca85e068aaa181abb9204cb4074b7bbaa99ad45cd1d73e3593723c1927a3eff5d3e9b2643bb048769ef1522bf397019d9b5cd64bf075194dccc729aa114908f8c48c96d44865e84eb417385105044c71b1a36f0650f17d389ed131e0628ad4ea39f9d63e73a0602b6b23b3db86169f1f66d126da9edc44a5dac2de95c4491c51b25b5ddfa223aeb59896622d45b8d30f8aa7189e06a03331872af92a25a13510bc6ae0ba29ed5d2e114c4235b110a3e3a9d395469e41954219e4d4e71b0ef1c472a4d5374e14507b473152ec06d35b84bf3d0163af2fae1d5c692f3cb6df2328b363baec1fb52cfd3af59ab8bb20f894177b934db8a5ea199f63f47e8e10903a58b10547e66e672cc2d565ec58c73119dac19f09789ed11f5b4de633e66b76489cb62bf81d09ea272c5fbbc7eaf560cd89d924a09879118ff636442e07aa5cd379731148fbcaf64ff5f21065e79418f966b9d8d59f6295d9a3e07eeb9b4dfc7768f3fe3f28d0b716b076df07bdeba06c019a8d0c80ce1463e54192a35e545229572e7064094e6b6fb215f41ccb5092d3d0ff096d026fa8f4b34a656ab1f1126db22d4eb7bbb13d2de87d645e128964d363670fb71f304e82e1e37d9174eaf433bcaf51bdebb2edd607a824592bca7a5e506ea24fce3ada84ac85ad7ae0db30c7fdda82087150f7d0af7f10ff4bbe57f2e7b488eb33c4ebfb2455cd318730ecb3c267bea685ebbf0b0de5c0883a23256dd128c51770e47341f135d25ca2226bd5f7816460a700f32215b39cba0f6614924419366a978505c3df752f5d5dd9de3b46ee6e171b56bdce94c5ba912fa6a64343c5de7555aa414f7c9889b44bee890a793a4c1d3cd9bee56aead1ed060a8d161ffb41e4f3155b158178277f9eb31dd637d181a9d16a144248e55faeba01b1f6f1d6114d6f569be8a178e778f518012aec6a7e0fb73207f0055290eb06bac9973e6828325302209fe484879727b9e8cd0943535a64cf1f149cd1f9ebc75ec02175bfb63cea024289546e4bebfef91626fd06fc900b36d2cb688578c89a94bfb096b7b090527708495c012533ae04d2f97ea499dd1d24a6f671b510541ba807b3374b7870b31ed0a0efa73117b79a2c15ba9d679dde2ee94b8522c41f827ad184dc87116716a6731c05a05742b14609480616e57bd7ed74f52e0a944965ecda9feee29449dae38ef00264965ba27522612632b8c5b95e702a1728103a8e1e6906ba29b38e71bb694b48ba3e364507ec13dc9cb7143dce8fbdb1303499bc6d71386169aa0611c1de7f800af379cd1f06dcb3de2b2958aad78911538b001f05d9381558d015272b6f07c32ef1f394dd0042a844b143f9ce9087e1c01a6439872b2becf5f7cb7f8118a0f2ef3a9fd6979174a6339ff833b09e9a82ba950a66cef5b4f33fd0bc57171c61d372ef39bade601154fb7d6610edf78845f27e25ef884533bbab5fd083480dafe781176fab3968f448db51a0ded3e27571bfc1d067e66b03d7f7b074a89aa223b30a9900316c6222909689f42e29c0d2b6f39b02e5005bee8d55e36ccd2eab6572c8d4c1d9915637e19b81cf5638ab522aa7b1dd659317deb5983e0710e3342b55056fe931b23db98f5a7e623036213cc910fe0f577fbb9f35517299443139ff80b36edd4336350b3b5fdea15daa61542c387487d2fd70a374d3d728c93799161c9016f3056584eeaba1619a042e898fa351f0d600e358e271689fa54a347f356000a47eb3928c19de9f1b17d3067ede16f1d145c5966ede2b6062c706f23b446ad4b5efe8c105d7027770480c31d41cea2a5d897d7cf9bff8544b53941ea77ea54440c723223aba9b287c0828be3457340da469864de6b92e12066bfcb0c7358d1074a4f09d83284aadd06b7d5e20031b4182f921e67f76cfac5a4e6bb9d544b4ce8c0acef22f83364139f62e430a4e5f6c189076dd50230b4cb1f197bbbd638b070b16ec640ce84d7652e0aac4239b195237cd5e416a06ae8ed11a014553e0c683603e04d408dcea51334c93a905e79234afc79103e63845c14370a6e0e3e5ff00deed5a47bdcd6671907c20f88af541bb8f2f3c30e0657bfd0791a31985fcc0d2569f54a409d081f082ca3ec4862d2da5b175e0cd3877f32f94e20e06c16c6030af65ac8de07a9848089191e1ee883a08bf2987d3ba335858caf8c342d67ad7a601a55a47d0c3de0ab1f39b0f884f26c1e2e7c07eacf8c2e807008200c39a50ae23fffd0de52bfe1a85e16e27bf1cd49e121918f2056f02796bf3820780c01f37dd72ee1e41c6b939497b04fc8ab5504669b2bf4bc076b07e2b11ddc42260b5cdaa3198df55d6a4ef11f3f7c0898dbdff6e61a9a80b499fa9ae93f64c9aacd1af58fafa38f801621a096d1220e9413401ff9d6d4d53392767738846356deb636ba050f6463ab12f0f17608306b9c1d79822eff538a948a3c454807becea93a81f9f936f383faba77c20512bbde312ba3a0bada8aed0fd408e46dafbbcd8417a38a9a6470f285c6bcb387b7614994b88362e372c0e5bd8fd3a7082b57fedebc4aeb68a0f6ea952a866cfb4daabbb0b61b8d5a5cb0b66b3c7cbbf9a5e283d5c43c2579ef28bb61362b37f4c2fe9e9677b27ba9e68cc8fec79ce5ddb8ffb376f5def920edc61e539522607c88f3012adccc0d10e89b5f52967dab69efe93cd5f141df465bf8bb35cf4149320c752a7b0821203296fd5d6787d4e97070c9ddcf8619507b2abc5d50ea1a4838b521fa470c3889937c001ed630baf07cfa784ff455aded76bb16bd526835b198d73878d7e1ab51917585dd5262123abf36f05634c2d19e26c7d05eb8ee97ece585fe7123edda593814795c924ead4e05bdb06922b7440d52596094f092371517759a3816035e8874270e0a185eebb35adfd5ff288b7dbef9ab794a62515da34e1057933765a28f61d86c9643a40d5e563436a2c647b8a95d6ca921f0d91202e64f5aa7361f22d8fc7464c629b113d0a1a3138f4695ec4839df9873bcadd0dc7f97c5176dfbf003287aa505743ed743717d8c266ae070e65a885023c5027d12c6b0ee8306e0400d21c3bbf0e6aa8a5821dd24e5a78e4b7504cf10a6aa7eb772f17ed24178513e225666b4847e8f3f1686e30db14f47135368bd99d2311336d75c24b5ce0190e3c125ebfdb94a939d9e5cb4a13f86b256cdfe1cc1f065f3a5f04f5548dbcb59d7f13a58b408273bf23f6a97594c60ab365da80bd594fcde89a6d361676738eb6b571576d471caab2c0d5f3f936bb1b0f4a2edb597e993e0533dc2c8715f290d424eea939a140232c191abb86521f31986a8bc90849a028151173587e871ace530e9fa580c11d47392f771f364ace8df791d700697ec8263373de81fd02549711781490a87de18f76e2f33355f91c0656fe114bd38e8ac56a50dc950231573f5fc27135c14755d307b6a7a6d87a64d56e12f5624f6f4c6186e8a207decaf5c52df5b75864761c1917f7d970fbdd15505455fa151e76331958837d338b6b7007e13fdcdbcfc5fc660ffb12526170ef776cc990660a9f5d03bd7e7320ac3953d247960a9c3a9dd119e264bc6915331ce4c44aee0373da812b6ff664c9774efe095f271ba0589abd7105e27abfa09965063738b59222203300d44334c7aefd9a3c508074201e59035124fa5d1a8cd440568dd122e3f4651ca3ec779d8fe3646903ce04dcf293b4677561091af69f6603738d586b2b074865a5ac1bd274dc441600e953d9fdde324d773cce47d403ff2bffb7f8892ba53439bd69ab22322fa5197438de3eca6738282691a01be03eead0e3e7598a6fc8e0efe2a40e49e83c52d61bd30bae35a4fb2bf918487ab40f4d1dfe1867f4315396d04faa363020a168dbbd3c67ca394cea4142d91ba7801a07852fe44ce41933e0a75c283822dd0f01f8256b7afc59ffb4d99f6faea4d2305dda7dc18f71fdc7b5227bfb575d018e9e9fb4729a4e2b2f41648f991324dae374deeb52f678fdad8c553404e354d5230caa41cda98cfd40b56f5da31a9709b6efa75deb26b57c5310c64c935a97d1d7b51dddab2ca231683c66ae0cab1a42385d431c29f69eb7981595fb26c3ff3de72b8d25efedda108b9f0dddc9ae085356b9ff5d293f2e56619ce5c98191e025a50ae46a9ab937a88936684c688ae8cf6059f595b9a471d0426e269783f5b62ed6c6c9d1b769abee5d26f434ea8c8a217c53cede6f92430059abd3f353f6568e7eba41530cf6d5275205948a4f4c85c8c3a235c4c2163b83140b3be71f44cd7db60ca77da8c36b4a0d30153fdb07a3d69792cc41200429b4fb2c7a4a7dce6045a41b22088859c43304101b630da5f45da3791ad2144e01bc8b5f6a0ac79654b28a93b9162ec236df4ac14b5f5547f1ac52dc4a0889f1d60a8c81f7dcb07defd00a86275ae2f398b96cd6f1e24d3501ae162d3c06c00e55f1a3c0457b33f4b7a23ce71c5033601900f8f2f030261e62cd4415be530ea1b20b3a81dd44f26e6c2d041ccb23c7556298f5c5382fa3dd35f92e144433494988f35a25528dcc2bf041dda7c6f6596175c99840ead3c65aff0040831f04d1ea3407a82f5902e69b22cc06444ed5ab90fb4380b9f82459ba122b130ef254430eda39485b7d569e726c395f9b96c3a8a44136f42a0f40cf4f201c3e94e00710ceabb2b502001720252ec316bdef70215c802750765d13636b6da6a6dd7a086c726191aace7b8432cbbe173f67cb0b4474ece9655f70d600bac14dd6d909a77a857892696049b17d285523dc07f546c98d224cc2566100a19e09d50041ba8acd88d51de387b884b552eea918bb6b3655585439f87347c21d02075c138613cda9a62f5eeaec2d38ca49fe925ca994ef1eba9e313689b6a863ffbd228ba0e3b77ab5db78ce85fbd06a5c930994005d342b2cec557c510d3d2c28f128f665f4dedf839d7502468a591ca3326d364a698cccc8cd3bda2b5823de2b9347372657cc5ba3b11d368259ead17c39520f8f5e53ce1fd3d5f0cde7d6b0231c9a4290e50e60a35025e3ea31f7a75b62b10a124dd53d59d420fa7cb9fb460efab1802566b413dc6e4d83956d0dc827d279345b884402ce3b706dd18121dbc198925f5aa91de11b700291867075abeae032a8b69c162ceb84374ce754bfe943f8c0dbb39b699d9d4dca7f618e7526a36c1bf1d8535d3d5ea617a42ed9fcf8084fd1864e850982bf4ee51534d593a3f011cde696e7b497fd5db7b8b7b24b0aee4a54a7e8af4c871391fd9691ed1291e94ad7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
