<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd70c8883ed50df0c12a2d1161569a2937338e8d43f16ea674fc77650ebacd76c6e6abfe34de450227fd53056e3fe14b0b9b4c35bddff13374bfe75803ba3111f26348c5513f3c4e0bfbcb68c90534d00e42b8c4aff4cf844fdf52bd97131f970fba86580858206d9f45e83b34cde54f2da9732b39a30dc7b28b1880a16e11b6cb8df8670276b1ea0b9d2c0381934c8ccb142dfef46d2825e2bb0970697a6749077a61c8baf1048565ab9f30ddb2c75ca4e0c51d0e89a5873eab49830be79d9368ee0accf6d18eb4aca6624fb689602d87c12c70026e79c68b8f508ff360500da20f875fc0f35a4f2d53d41ab381b61f4d9efbc7458779b89589f0353e0526f1d7a24ee50e37dcadf16ac4a99ade0645b252d3f7b92a0ada363cc4c2fd8350d65fdb9f57c7e310969c70d43470a4b82554835515b8b72dd00978a7d534263296d6b00e8c9e2cfe2c182734a407716533fa6d22bd8db2333af84c353215980dd4ed50ef569e04a130e312a0032a6ddea20657a9fa2459a60a926ed23d125cf5a698cbca44299969e86224661dfb34fbb3373e1537660e6a7a9939e47dd61994df8e9487f7501cd4bd783dba9dd853f44a0ca0db6651b1eee41aa7ff4936a6f7ad352665b21cc177d43368341a8baa9ea3e2aec72399e7aed0a2bda3c779a10f3e697c2cf492cdb961eeee518b613d54ba01f031dcac1900466fd5bac639c5535ab50d2fad4241c8f73e94780ddd9ffc92470f99218782f28c4864bde6a686ac854cd7a57b6518fe9bbdb10187fe853e5cb7f368b8e34f17e323bbd7a7b23bc9fcd4ad3aac10fb361bd13a87049fb30e06d3eba55922ac8fbfaff04035de4670ed59b9e73f8d5a74d399dc992102ae410eef5c3c741e30fe7d883880e5afe73be927673bb7677a443f7f577402d785627979eb51f67c3f220811fadddf414b1a78903e5bdc6c5a5eed37b9a666ca46655d41c926f395b121a6badc7afd174e1b30d5f78a6dc25c8a9472be2ad4e969311b96115a045cb8451ce55501028f89149fef1e4493b903322921b54cb77d5858b6ae5e1c877fb01e1730147022ee2a73e5b402b38e73e94d21bb1b65bcc6ad13e1c7c484a9a148db4479662935a90a6bd954e736f32158d4dee3a2e3ac558633e0e7ef493581d8f19d7fddaa031634c795c3b8c32bd5e4834deb9201e032e99c7501d1cdf431e229eedb300c3d81ee6e60b749a113511daa4b58af7203080ae29be73abc35c3acf53afeb66388dfe300a2b7d30c74add215828b49318dfaa4c4675db39e307086cded5052ba8acd6cfdbf4a278e6dab917b9b38c36c533cd3f327dbfdad4b30e30cc3e6c7015782376c23974e696a2a668cfaa3384a995069acf83c027ffdc13d1ed1a4e02b7f7f4e29ffc5d38cfda1abbe68342fb9076b399f72212e490a1f35529ca5cf83ab680ae77bb8a97e4026580e7e99b52db751d254a39d12d565ddae37d1726319bb15873c650e36becd43e2033e7a889275bae5295713c93c95b4fbee561eed8f74ea13e0d997da3fbc6e5430a6b9e247ca100db9f35b51ede9cd37409f71d6f31f82d979dd3743127bc81a9fd70171b07816963bf69d6962558064c04df24ead7886eb4b021ace8da56fb78573c82258c659525037d597b0545901ff129b24fa4336f8657fee2b1e6c2c089e1dbb89df566956dfc24e07c5d2b7758f9dc38a8fcfcd36c12aa6b7015a3b4c75b45de252923e439cc8e7ca02b3b29930057734866b8ea0f7da5fc9e531ac62d4eabaa461d9e294721f51626c60c83643ec02bf8278f0a0a924736b6b4ae8b34647e6565ef314f3bec8d44ae22909dfa0604df11dae848282e7f839d9dc5948c315594e14cb6f190189cfea56847e813c58e0efb08074d05a4eaf0f4cec05ba3ed1ef5c7e12fa81ab18818c2bc872c6669ce1fd238c01468d250685a1cbaa73133db6d39b33a86927c5d58f7295f88fd97939bc26185a1e22a5d0a0d0397531571e54f1ce076171960006e7ca4ad31fdd89829b7a0a86445ff002ecad780fd0c0c19a384b6b7f059db7aa66f7b492ea4645dc49c6276ac1bff1deb1ab736efb03cc9c2333216c2da9b6aed72dd52acd4af12fd6c3135b5a0b75e7fe6d3d5212cc81da1d2e4330a8191485b74bde465514ea30088bf66c124383c09bc94262da12ad94e2876f7d7ae05d2f231f16da147fda8cbfc58e4a015c29678b628df07a84c14132a10a9a261f7f43ba640ab58fd7a312d23829013d339b59a80a85a476c2f85fbd3e315d0871e3b6066ae5621f0ed6f4d811dcec7f2a5e5525114a8e753d9598fde38dd685660e4b9d3d6e5411f30c43a01976461fb9f2c7bb62acd3297145257c8f43d354c9a55ea9a6647868057e953e5cfa5d7bf1de30e67e3ed3fe85bc4cc18c90f8f527906e54a9d167c31f8d28126dd9ed2169b1db92e809f8d844285966b6939cbffebeb4234c3fdd58eda64224bfe4e42fa8a73c0ac3082b23cab78791fc7dc5b1c150b1eb8d783e0dd98cdf7c73956eca72f6bef5980933536798f9fb6f4a43f3b83bdaef99933e71c270f459891361e4668bca0bc5749c5ae7a5bcc5519ebee7e3d812b9e1c2fb900abf9b6c993118970693c7c250c3f1316921489c0ed5d3e8f416649855754893871849b223f4da3c742c7d643cc98de9eabdbbe32e1951b8fa534d004ec609ac5d1b011751cdd3377a79a56f1d05be156e5ae256f23929810ab016baeb3059ddb02ea8cc8da5b5c74c5caa097a2ec327364b7251773ae2ed68ef82c8e5ae7f215e38eef1028a52ea86b220f5a2d0c3ede97898f12d9233ee4304131bc3773c88c12a08a32aa59ab4d7a7608268c321a39bced6fd6a3c1808fca0a40e25f1eedf5465c6c9b73788690b8b9bbda03bc8102374d390001c0f27a09982151f8bddfd8118661baba032b6904cbab295d5d2fee3ecc4151ec6e981091e9687024ad19c066b507cceb6c275e4d04861506d0bbab91a55d31a48eea7a1d3807e40423017c934d4c5efd9734790cbf9561a51e186d18f30506e79b1ff968b4928b692d37004e4a728c5d4fcc561ca86ce4d54dc0155473a85b4a4c0b94ea0589347e501fee7e7df4b02af71b84208f6e48250a6e8e8b7dd22afa10bdcf998e84b1580155605c0bac5a56926ec3684d875463b1202aa42f3039bddc65cdda4850ec289929a50df9fa3352d77799d52ed3beaaf227ea725d83feb7e3c8842b56daaecc4368f1742be51a1a47a846a66c03ae30a8b798aea092157c39893a56ca9da6db861f479290b43b38017acf4861e2073a8d017b69b59e3d8615a83b7d3544df913884d028067b1953ff92056caa6e2151039d3bee739d4c6e53b0b0813ff8e4ace86ee5cbcd7548a17b8de0cbb4d4db21c1694f2d6220bf1240d03466e45aafb961cb098a86ca41fa83c913947620aa619c8b3b08b9b9c454a6f1bd311bb33f589af7cccafea8266d3c4fcf93ed5bf558bba8a1ca347e94da961200393107c4a79f2941d0a795ea0a7e7b0d94fa2f998226207892d6ac24263427914f208c117eb41e23e3637e708dc628f41e4d32be976668906497e5c3028b69e7a3e88ad971cc2de37e91c0880c875f15071e65d1be44f052c241baa5b067cd73721def9a5b347cff622e685f7ae77d89a4324f36617e3d73910120d02713d408ee0b7540169dcc96513bf08e37b48e04af19b31c7108deaa292ae1f045aa3a09c3151ab39db8f9831b85894b4ca8601709b4a689b229d148e9e0b0cf32111b21f35d6c31ebddb8c3b4ee3a744e950cff0f59bfea92a2b5ce057829bc401f293608ce8f9fc83a1a4c83c64f12bfc1bd8718819062faa33d37f1afcf37f3891dbbaf04a8c73460292cd8f3d94cf874f24d874ffd3c111d58ec061159ca7fc91256321f6981d92cedff566fb4af5e14ff01d2dc307ba15abfd3ef46a93396653736624f2e65cab3b8ded2ac16f9c661a7f95fab86b9301fc74d0f653b61fa4f5f4334ba5774081d52c8df1fc65895da446ee6812ffdfa816b2d5b375fedecb2142a38ba1a23832bad820a68347b9ed66e532710516bb468d61aba697bf0fa952d288a7f7f4020d17f04cc31f38b2dd4cbe1eac41de7635056d19df2285ee6cb3bcecbb0cf6dc9d5c6882f6307c220e9ab41b7656cc34b0c0f150ddd09c907caf116c2a06421b28c6714d6335292c26ab7a92d7749984ff23629a49cf129a21ba41944ff3f53f3e16b2a706600c3f06c5958eca9b576433ae83e6dfe38485cb3e99d2c26d210a9ed7e611b11cd620f84c5cbe95ffba0f0307d2d359c25b11c9fafa8f118f28dbe2a82c39d788867ec8abff0a9c7421ef11438874a9287eae6be9101977a5ea7b639ef91cfd8dc6a1ac098cd17e4e23b2cf15014ac7c15aac95f989c7ecf94915e563ebe6a9ee6aa4af654bd50652cc8d257a47a26af201758e3be9189ed2fc0f103a704c36f77e39bb3e3059273ea12b566b85696a698795d09ddac0c1413fd085c981a2a931410096456749fd0973c3dcf2b4fa3fac294cf0bfe08c77fc3e62c2b063448e3a00265f6b9f19d9f765fd8e8bee2c5ec795f3db69dab544d484df6d9fc7de9451a182aeb3e380403ee64ae6efee2417f81fed5a36611ff5dd127e2ac475ca6c793a0a81231d2f7d280f2f31e676ba1bf7f557189a9a43bd541675f88712ec282e0ace02b98db9ba98da767620ae74af6d6a79ed2a6f9c602570896e88d3c1d1e668dff859977fc9a71c8d0cbfab1997e2d98ee21a4226aa17d9b8e35323f5bb5ca0c40092e0e2d4ef27216ac9b44845b94abc3ae7c9079f69474d9f9b0cfbda7c3723e9fbf7d0bcccaea71f3d8a4eee118025009e6ea163f90711fa060ae10deb00b7def9d7f173dd950c920594dacb1b3e36120e96607c226ef8b33819ad2b0bf7e357f30df73d31ffed2974c1bfc518990358362f5ad7db942c4fc8b22a6965f7ee4e0d41e07a18d737f3134d083b7fe8aba2a2f0071dbb555faac614d2c0953095004cf075ed82f37aa6c720c70144b47d6a8863813e0d4cb20daf58f63a9b3298e579f385441b258f3c61553e523c43c446bd4af116e95a05168a771a26ce533d8cb114d8c5d62b13709b115bf775c719126079ec884ca9bbdd34ef3510f3b2169294cd7dd2d28d8233a20cc7c963cc00d523f49dcffb5c0ce2a48ab6bc9ab5747d80071408740b7fe94e1f681dcc3828ac264b0dc302f357b09c046058aeca938b902cc4a02e32660ffab6d5901111fe18b9a6807392d307716a04dffb81885b97dc0b0051c0b527e113a04aae5f1f834a0a11153248a9ccb937afceb6bf1ccb085619da177ddd99d7471b7143724e4bcb077208003f005278e58638b30f61cab6fc1e0e10ddc11974e3625c96d67d546cf1833b47a1397796d291b7b5fd0b450b715c1e0ee368114f16291281fd81f1db7fb2e2ec652aba3754edcc4dc891b46d27fba31408f1409ba6f3206e9324f4d78974368142062c39fce4db84fef2a1b223c0e8e14d0f3a2bf3265c6c501db368d8c2f3440568ae5dea4a74601811fb182130a5359572e17bead9fa0a1a697f0b7238ada3b6d78a16e28dde2b1ab520e764ed912de02306023e2fffa6508d64b4f49415db25139f94f3c87703563b03778327e247b151c34caca8e2f1371d61fbc74703bb79de6ac227bff7eac06b9ac9e91d0c298e63e1c3ff4580767c4236f83768e9fe645ea7f171da9f2df63121f97ab39b290a494dc79a543addc35345e7df7b785205406eb01b5053b2766bbed71af45dacac865aa7b3d074860e06a4182cadab88c62d053dfc6c1075a75a8e4118fbc1ba08376ba9a907e840d36f0cfc2fb49d6498615d85c8cae6c546e642f3726f04ca5456cd14125bc01597edbb23d6962006c8b86cffe34a9c0774c7eddc0df609afc6e3566a77b36b5eaf4a623fd76ef86392f79cdffc82adea9e1f4761bc64258724c5864e3475a20ab7683b830a5503f23fdd1f5712a5a664232af54f8594443741be768fe8aa50e0309d94f8cc66cf52555023bad3cffdddadd9cdb6fc0be8e3785e637dc694c4873672065e437aa6cd4510b580515f2f51841e38d59f9f2fa764efbb05837a8056b5538d499252c9d90cef854b55eb48ca3f5c1f527d9af643b69b806b97f061abc91cd99ba38048555b1f483417afd772437a169aa8f78317564d9913316aa7bc78a5d5ab2001b80462166f7969111248c4d6bf77e4576eac071018aedbddd3e3af06175dd7f2227a462e45d33800ba27064667706c0748beaf8443d03db73e512743df67cb87d4bfbc9a6f86a1cdf3bb07bbcd8b158cb3771a7d2db5d2ddba53d41fa17192f6cf44de0d1985d9e22317639b710e9811d6d744a44e6f60532df658735423cd4d1107cac10d79c9866a3fbd648507335438f6446b7ee86ba5d8ef50a0d5b4eda9f993f516ebada1766d1ab551d4375f115376511395019276520ab968110d250a4dfd9f3eaa192d91c83e2c3a14b47f6efaf2da48d1e7649b2e4fcc29717f8c03f9d60ccfc8e0029f68a8736f5fa6dbc9bc0a85612c9c520f912d57dcf9b8e2f0963681be084f64bd716d706711b503de784875dd5cb24a617ba7076fae129cbac7d6dac74b70fcc6c22beee636a782de8da36b14d3b026bce5d8fbb28482787eb773157f6fc8ee5498980a9d69d5e4f1e4452d8daba94324bd477d07f86b3193a0cfe02eb4573af6d877841157ba3aba41cf9f6aaec5f506af308c640dbe4d42649c2ef8fc20ebdac26eaae9a609ee9537092ef14b0cfe7994e9084454a34c966f88613c1ca15e6f031610932068f35c29ff64936c312558f566c56ff4aa9aa41abc365509ce927061382f694e8e5dc5829787aa1e4dc2356ebe0964b299fd87ab9e79eefc0aa6e810eb1eb38c4f0229eb93804ca9fb2363cfb9405258bae571a6ca7fb1281c978b85390531d697fd92867a82a486be24d239ed7db95a881de8c9bbc0b6f4607da44d4aca5480219cc5471d56c63e8c33af0207147ce66450ca238ff8fdf580aa3218baa1332c3944bd87a6abf93af6c2bfe511198c68fd6b70f3495d8fb9cae0e296e0f1d580b95c9c0ef5ebddafb58817838603450adb65c5291a19f80dbdd025ff713da46c5acad5447b7ed33222e6534358ae3e22049b3570700d05158754520e7559c97306aef45114cc898691292f0117ca1319078a362c4168c653ee41db0f8cf0763228ca366e91f5d09c93cf78738cfa35bd6c3ece6f42f15d924fbc102655ebcdf529378d2e035f18ca632818a9554fe33d212deb6c096f0d2aa917ea3089fa0fc88eeeccf7adf90540f4b5a1e042b2a5730e588239c8008bb25a78993e2c6d4d54c7eb42fba0d2ddfbae3a64a5cf43afff97fb68834ed1c129e2cbe10551a92000a0c925cc2c0fe2edeb1468d1824efa14543b89c75714864432ac8db2570b914be110f4576098f936da56a5a1832a72f50216c91554e74962faa46bd2a80d53741c9bdcbb535519eecd9865a56f85b0b95dbc54cfec68e1bfd12046659a1887bd2ed5eeed7c7b0334d372ac45b4b31fda4d0c5cc5066c9f46216514f883049b35b3778bf1558468f5be5d159f37a2aaa3a391bdd4851587622cef8b19c51192535b5acfb4a5dc99204e377bfcf61ca5646fd5f516cbaf80d26a16262f98683bdea2e5b476892c886e35a382ede20549ef80b796066294147e390c06dd18647a56cdd4a3dcafee4af99c6e13f66eec94880d2c673af2fd4edde8dcb22e4057980933fc970e890d894a88ec82f92b7bd0d269b2491ca478ddeec929cf19144a3114c3cd08f0dd72e4a14576ce0a87e835e634192bcf857ad7253185c574adb13d8f6069682195e7658c6142540a8cb01df1a4f2aa1e24e266d9184b2c9247c37dfecf64ebc081fe0c09e3ce9ddca20a4b0f93c467920106f3afe345a4f9bb7451ae90d6f5aafbf6a7fcc5dc07e7ad1ffa25a4ff809b6d769572d930b2eaa63ba55689e52fbd1a7289de7a9e59d653e631449d5eba49dbff909d24cb3251024ad1bb99557749ee258b43185bcee2471ae523793f08496eab25cecc17d84a1bc63090bbf1db97809ec755ccb6661d3b840fc6d0552a4ab5b99da6784cb5cd15442698afb5a917a88f32f81df02d74ac49eb336f4b81a1bb76bd87b1e83117091a8d083bf8c876044e8d02beaf6e71bb6677e857b22a69d91797d0ed3b464ad20499021d5b1d9630970bbcb1c4eda68ea50a297817a78a8cee6bb148f9b7b40040468335f488fb624cffef9440415453f0b3683b108ae42557036178098d5d47170a1902458e2b2e62e2036b2b2f090dff89ae6aec4ae5df7a756a4ffe810754856650ee137f6661c17dc0ddb46084005bbdd61b384d06aa9e013dea8b05f718ad62d69d5a9d883b24367f716c6ac405aacd9fe64c411bdb714433ac2300bacfe4b4b842e2cd7c218a2585abd3afbd3ca0cf15fd261cd13ed6dc87b03613535d45be8d9d846ae18b58de8386efb4b6e9151b8ebd0c5b52e8f7beb0b752cf4961f0c51fddac8cd9946573856954be405019bbce4568856eed4d22b897e46227c3412b62e95e821290b65fe76f7140e8f25d0486ccabb5a2173604efbe2fe323fadb0cd1e193d1a0c3c2b8a4685f2c9db51f71cbbe295e8354677e512d2bd57cff54e9eccba28991fed180e96488c2089eeb28a9c777e8b00c4602576cb17f934c62c6ce8a46f19d85fa8ae0e146dc99f661f15c1e253458f9b6e84e3f3a35a98418b81927a98433e0869d14793ae8226c4af7167f4735337c7ca25b60cf578a27ba92dcd9d46325056768852b1517dad6aa131cc2bdd1135524bb375cc1a01b3f7f03c0b09596417f720c516ff7f97b090a54f3bcf265c144fc8c7d5e8ad1a82a24336716bb4ea65e543cc9080546debf4f6dedf0fab58485bcf6b8b6573ce73f20a350716cec3fc1c036ce036a0425c95aa3e50f03832d6ba96140b6ffdeba949dc5886b5f73a7465cb3d8e0a496fa28cc99477081a6988d7da3fe8ba2dac704c272e268ecfea82264ea48d71d41af74f6b8bd6458732a205f54616e7bd48b9805c883ccf09fa2ec45c2319b9f592d40b0cbef85852c61139762fb8c6bdc433b4b4ba8583a68aa53459c1e43800a18b756110005187e8aa3a432763fa8ec561b5014d5c77acb59680f9c7d3e7e3bc5d058177446f96d40a7b881063e4f5856bb0b74b227692297e4fc64038b558ebbbfba8ca82912550f410fa2b567e87db378bb08bfcf18db5f45b97fef3a59611978d91b18d8367704e1f29b849d46a6fed3018009a58277c7771c016cbcf8732f36b29f6f47bc4a571e437ded652010d6c81b6b1cb50fd5e7d093176fb006d434ac9f57152a37287bcbd59d64c59b8dca92ea35c718415f4042254ce8bf5cf13ab14efe5756ddc00b53bc8ab7f89d19e337b194d12fcc6b8e5aade9beafb20c70b3db25ac7c7c75e08161f0f08b1156eb6b19071aa95eb7302513f643eb906e287a2b0d0db6bfa4af37ee24aec0e4e5f875b52e860b52b47cdad6b561b5f8f86b4e47dfaba06aab607bb80144d62c1547f491033ac43635c897ea50c2145de7919335cab59fa36328f43feef1514a97e928de898090c32d0af42cc64cebf008a32af5365f4890c9da218d1fbdce13f8886eba5042625ffdec9b500ff57a96e4d9c60b0e588c5edeaea52f2d96d59f591132110e0eb4682009913a68aaa6cc4e384f32ac8995debbacaea428e056833e79eb55307deba48a03da15dba2dad2dc8dc370cfa677e3bb60cc5c02bc1839c34e316c2b8e9f18e1088042addaf2793a6a503bb208959245091992ecbd76fe55bb9e736e097587df8c9a2d37b414d40d28baa7cd6f868af6efc50c92e2b0cff5c84e5cfe38f08b4a811b3190f02397ebaabdf4d5927349ec188108ac6afc51e62e6c3dd970f52c7d3b0363577b6323ecf16cee8b393ee19815a148f23e535e8bcfab07f93e1f76ed8243aa27c77c42cd9e4663134b68d78bf692c3a9ab179784906178a560156a3f51f276b8d71a151eb5d66fb90ec529c81b95673d124c4fbbcd1e038fb382835036e9a95aea9185ebbb02df1316dcc741c111b14645d71d9f007ebbfb386fc02c955b30b682c7535db51a907a42fe78142cc92ab9873e82ecb746bc7d5f55afdf5554bbe0480456fe82af493be42e5f03a36f198ac3a731596f1c7f3c182f43626583cf86538a71294de5ba92e419f18dd077cf66d6abe0c74df6661112d1b223bc83639ce1a1cd708bc2ebebb6fbcbaf13380da9d0f544d12ca814f3e13c4a939a1bd377d39036db7d7fc1c622945d343f5bdba758a09f500cb48310fc61d56092d23683bf8c16287a632af48145a63bfa16a1a7c34e69b100389c7f6878f3e5f70ed7913e31c5c0acc5a5e1468261b639ddb3c16536f5a7a19e1b60cd4363c707e0c306e0318f6e01749eb0dfdabb4a98c1fb5e225c3086093fde4b73b9e5e3e61d9358726e511c3519c662718cefc9ead55b56cc6c7e8b687a35b74b20b21a45f74490fa75bb42ed3926070419e4312dcbfea9fb1f312013016f629e66b14d942ffd3b0c2ae3543739490546bd303fbcf084cddd44b74e481d32c64b4c5e104c9491f15ce8f85d2805af9ff5b97d1963a4a55c34d7d5f26e63ba80b7530f3ab9f8cd94604a7578d636d035482665f7aef17dd1a6a7ff26c35b693849427687fd24415bd78b0f274d1529a13c50e06b727278fbc4544ea7bda5470eef2aaa44e649cbb1dc7acdfa8fc0b99a4bc005381f41d3cbe59a229a78b0ac1e6bcc64ed2962d420655219732841df5ebb31b20d25fa3b36a37782940ead7e45a875e065092c883fa3a48fbcc1db7c7ec3c6e025511ea4f317f0128188f9e52238a0f1c565b0d256e9dd87e7c3e3988390897ed65cc100abcf9d4a188ae7a911da607c3cbe2c9d24236e2a69a605a857a6b46d62d59d490b0ded4d5954b59103589732c13458c93dd8bf007ec837dd9a6d8808bc8bd4429c33a7d7c7dc43435da715bb91c54e213ab736dc468ee1283056ab31998306d98fc84209dfa7d1a91150c24f83a49fca62e0346508e75f0a473ffdec85f0aa3ca1bfbaa7495d424538f6fe1d3468293a66be059b16be754f0d978c56fd380621a913fb21516a73058b77d63952deffa0e7d019958e18acc61175b1d43f55c66a7df7beaf7651c1484ba1485b84f3d3090679c904836781edc15038ad58ce0e77475b55bdc2f8b2a5c8423b87c87328744a52d6272ecfb51139b3ec36aada4c10e8fde8e9540a136d421e07c702f4b97ef5f2923d19767f798113b454987a19f49292c341122844d8ed5d4897cdaec49520396857cdbabfead2cf8b5a7da76afc101e60e2a839b2bd93d10e28a018d5e7a64389d116ac2bc879347608acd7e2cb0668717d65d0000bfef72e11d0de5e0835beb5a3db5e767571cc2ae55ccdd41d9aa6c7ea40521744b2d87aa44971b4970e1dc05953ea5baadb0b58e8c918e1cd8fb4c2dde4d0893b9b2d2ea86c8d665433c4daf40794dcd338484f1cd168b12a38b7d5c328177f8d981a7f5ec57acf819bedee8f5a70d953c64b3e1d4d0306560f8268458fc67d5ee710d32a4586c5a8c7989dd4346fc44f315b572797090ea2ef09dc82a73e6fc5dc84ddb6cf7c227b69908f6cf0c909e517aa9aaf35b294ed56750570faa4f0d74b47b6c3fa0732dfbe5ffa6dd7f99e3060a149d5ed75115eee02fa785f71a08861c6554bdaeeb4cccbc07873e8989125e9a06d8f503fa385f154ed399457bcf67acefc2ffe19b2a79c9532a8da252da60d7903d8867206591d5a4c554e165ff13c30ba61c6c4325794a31441ef5c25cdda9f02e0647270b4b9c1e8c7f982ab697d47f63b7384731ce4373a23a0284c71096261e5cf67fdf807397d7764613f6a9b0afe4719cb166e985e08b9dcc663f869fcb73272b768c85ab196aa81f9ad2d3147e5b3661b15b513fe350edf801da9af7c03c87b61cf96bddc769d06d2bde7185a8e809281cc29e517880c6d2f6d2e27e9db6a89c0925dd22485ac6fecfd6c54c0cd910592c4fde264ac9cf7f25126f78c412f768d1b6f14a52141c32c754783357e32ddbd0cbf7a09e1b7f8610d258af7171dfa527f8a0f0d6ca6d55edee8659f807199d2b2636a7f6a13fd650d066d37ab1276d1ff67bc8616e2847dc650df34bdbbb230562d6ea8d63744148a4b3d9255170bf84f9c68c8a4c25d1ba5d66609f89628540170ffebfc33185e119e2bca73ac08425373044a7ffc3413a12bfdcd76da9980f84da42e77a39ea8aaa9ebf9c83ad4e6f4f43fb010e76671fe7e6cfbad3429c6acce0d4bde02480b52542e4c71e3efd76c4cdbffd6d5f6e3ca6f6dc0a78bf5d5bf5dd67aee3bcbbd53bf27d0e3f5e60e606bba9a1bb91a8772adf688e03b24cbcbbdd7ae6d49b2b67278f5a2b136e99329902a2f28a30a615b13bff803cbd7255562c4908272c928036ca4c54e2b719af6f2c24102d609d1c4b1426a1da5df2f68cc207dc45568241f3a00d95408c52822f62a76826396a072907a3224ccc0e3eb0d8d47a425e343155dfb4df00e6f5e116d701bd06538b4a0b738db56e2be8dfd8a0fe3ff998f1045b804ec9234b2fe39dbcc61cd8615c57f0d5bed8ec2253f36ecd668db551ef5a4a55f7433f6770e12414c888c93846416a2a8b60f8781708b59815aa32d06d950abfd485e7a9c4d213da9e42d4cf73fe62ad20de444f9990a4ff44b611e2fa23b62bdac32050de5aaab226ddc4105fbce5d650288a324db8f48d1e0bbdef18b1fcd89050fc4a64aa7acc3b4b81acfda69f338cc764c7396a042490a3d9f2986e7cfd41c9c53fd825f8aed56eef83de00d7d5d55d9d36413de42e461c844b60e4f41985e253344012a5ce989cb84421daa828965a01931daf79a1687e72127d656c5a1912f5fe4dcbb31cb30c9a1a3d45048a387ac0e2335b80a5e858263bd9fa42f2ea28369494ebca5f67e2d7c2f9af8b7d5d5690a26d70188559eef95ce2f9687f62313cca447faca3992b942f33165847ad7d188afbfa41445774cce0983b69dac5b142b2661ece980b1d06ad7bf48517affcca45c33967261b77b79f3ecbf394c5f6824eaf33488677f72f319f3aceb7a19f71c3ba936948d1f5dbc3ab707d4643af9b49443329a329c3fa5fe522c9f575d706e62713d65d98adc733638ede9f319eebd87f7ea3853683404be5bb6d6ace2f48bd69ea32b1915ad31fe3cd822765d8799c360bdf63f5dc93208ad469ce72153b1530e7123acac0e4ac63843e240e88a2acd4754e22c98ecf143160e4c0d6efc274a5e44e36987b8b0ef6e0429186fce053c8920ac16c77188d9e9a19bbf3a9bbb7b5b486de2d1c14fbd26761f47e167058638e96dcaf7a28788e558f7e59a9f369998870a8c361e2a6adce1b84f29c2ff746510a19082bb1bf1a69e806b83e56416b5777de2f39a133a82a74c4f179a7aa49342eb48ca34d4e54a74eefbc78e2a6b587aad54da8c14389f0c183171796fef0784e6c7bc9070f13d112ae32d7e59e639dd5f219fc0a92693a7b1c566fb533a2f8d389a8c81147a42cb05403b0fa6126e654e15d7aa9050cf9dba8ac08c2c4a2d18f5f91feaf2700dc0df1aa0702dcda8d603db383d913c0ddcc7df041cbe318c4b86b20858d418094947010e15a1babaa8bbf58d653324f2308b639359846c9af24dcdda689d9f8397162b891f9ec773712caef92a0e74457e9992a1542cd40c7c09fc8a5f65c95c693ebdc608146b9bdd8432f455336e0c875c24342b9ae1412431bc489fbe2074dddb459266ac19008c4d9957b387f5f2ac72b38e76ba82e545cf477e2360303aaf46f782a012d4ef958805b95d9693ddc23c581998665034421a6cc139aad080486a965f2721f855077598fa50afb1bd1d58cc690140c2793b71a45d6ae358eb4bdf546037e7d3e3a4319fc10b5eb8b37c640e11118a23af6657ca4bfacd5a733ef3a929774800804c4f732f6c2f450d27181576b4202dfca5261566e1db81d969945c4a930972dcd12decb7ca1470b2a9de0b1d0f51e33afa3521624e69c2305eb8c4e2091ddaa85ecd861645c7113854af734ff92ed6d85a171906f372c582e6c48a683ccf44c35286fe6e56465b2c0209d1c6a4350af32381509f6cee32503738483dfbccc36a469065a314643924ae4e1a78602e8547feae8e52ef72ce90248e96a26d3465dc715700b6fa7b9a40db293fba4e9268dbeaf12e1278436d89d2c5916d2a5239b32fa501361154adbce9984648cb61c74391c214bd1f49746eeb0a024a4df7331494cfad8adbed3c96aa5e7e088b1d1a520c141f7035dff1a7615f3d4dd82ec1cb757b8703fd7aa35c0daff84546461c608e5d5c48b584bd035c3e9aa86c042b4d2e9e52d26c7070481fd885e2a31c7989d5a9a070e0a7836f35af1af2a8b198b98fe4f6b2b197088c8a7c6818a27aab01c64972783b4311b54fed33a750a0db9db5cf6f8ca7ed96c89aec731b7c9df5203f7d3fa1a43ec3b7f7464e63f6904d0d3931a3bace84a3375fb94d6a8e383baf5feaed32080848cb47acc80f029747fef337f79e5ef87ef3f7f5d689edd603aa474a086a56d0672dc49d6f2dd820d36765f72239f59194f3a2886d4903f82bd24ff0059e2785abd07055bdbefcd3030cde84a8feb423667a55b2e007d78a5874ae2fe084c551682f15499dea347d3b6db2fd14914665b211f3f426aa07c5176d42d0558a793895270795f770bcb0a8b641257338533345078c6d056149dc1dc91764221cbd01161c01105dedf1111d17c74da778dea92909c59b9ca5fee36c4687cf1a144f5487c899f25890774d5d65c34fc7ee3cfb6d2d0b040f86296deb52e63b31830addac38357dbb0a26da87e2610fcc3e3e48cd81a985d7f1fcb2953d7faebd8394bee706cade1e24d5a02efce913ad9c0c7366024ba4f14dd8856dd52cd5970d90c855ad2fb107bd3cf6975839b7e66bfcc7cf20ab53176de0bac31084cd3e52f7ebfcf51641952b05ab59bf28dda81f2608183b8335b16eb11dc75279b09f442afbb242891e8de8ae23816289cc354706689b249802182861552fd99a6296d938ccc10024143c0737f18e0d9ffb53db81343fafb9e1f36d0126fac27b661dd98b974428a701c869923cf55ee5e5cb3812922c80694e069cdfdcfcaa159d21097a5df3023f7516f7b052a1e162ad45461845598344f30f9c0b022dbb84ed0aa3bb474d8273d4e89044c0e0c199ce3a625a7b15ff3eae7274ca9c0aed4020418179d40d3d6af735b2f49c20dfe0048f282c65ba0620678205b99f93c81aa0d3cd0c9b453b5780138cd8b884b73918d28ad2f16753517349f485172ac01024dbd7ef13eb425926cbff6557938b24d40e896c63bf49abaa22b4c8eaa09e95052b5c1dcf3c719644c39dc2ea21e50e5302b301f80f7a3c86afc4598d84af93cdb0ad6b66d5519ca7836adc538c4c3470fa8e5ea2ac74afea4ce41725a53129ea227526e71e09cdc3927212bf7fb5c60faeda68b0f0362a87dc3be19e819378be51960cfb66d5c94925c0a89082a2f96102894bcadfe99ea60790a3d2da5b46e9e64d6cd245b70e145187ba25d5567ed941abd025fa9217b008ad00eb4f3c87b07d257c39a133abae026a635e5815653d6902d9e7c8cc298f665203eb11e4971abbbccea8fdc3ad970762f29deef13357f197a36fb8f5a2cc0834693f793dc8ea746bb30fd66ac658aeefc66388d575cd69ed210fc541f2e646c2842f39a45f5021791df0586fb247e45da943d2515f6a90b09d15a08cbd3bac3f415341e63ba7d5b169d414b147ea3a1ee59a387c81faa62d07fb0846e4af839ba33eca8fc6e5ac82fc65c488d37c8326fda9ed5e87d333a4b022c25614c42ed8742836cda37aa036ea3ba41e4b03e8fe5edf319d2bf34f510a1c69404faeb2aa011402a9e50a019d058782d1c991ba95420cb606317f74c839de66c083133d89e409a20f79e68c485b6ab244d9a6000be81b9f0609172bbbc6b154d02ec9a772fab309d8a6710ef92135feecd566275f4cf69d4c1686c617f8d9ef1622fcecb6e5eafac14598c28febc6652178f9450a95deb3b9574c90cabec5d3b88c0a811ffa7023e12595bceeb603adecb925ede25c22777d387f8e3fd2dbf04943d22f4e27ddee5792bebe2c86128bebb4103ac0cb8166dc1364392d364292b121a115bffd5cd1b1e68b717aa46203a994610270472d15d223a8b9e83c4d3fa83f4085a443389fb8ce8955f2511536f86bd49b0a43625dd67ef09651126d62dbbca84fedf07ac5b195689d181b3ff797ca5a0512d0651c572b355907de318e5cdd34905dd94b03e77b480f0cdbd41a892d4bf591d82d46acf0b0c1d93367237650c237edd808b7cff67d58925a0e87e0221ed606cf2fbc4a49f082f42b98cf1d94d45a78030d84af35c5ce1d67d117868bc71dce5402c50aac10bffd4f852ba00b9f3d448482b0eba50924b4492db56c2c1463560b2f4281aa651bf1ebad455f929379edc2f30281ba5bc3a1b125e61b97535bfc9b8e9390f660e6c4be29e5cd1eebcba63d74f582f8c54deb05fcb3250b722a1449295457f6ad3b2017918ac86a51e1f9229058ca6b1b1a9ce1432267c2c0865bdf1b1b9f2a583d135b672e44a24829d8ba9abef98b02bdc5feaf5b68f93400d0363ea54a192b5f2c55026338f960bd35b00b50626355aa8b9008e1f716d1590b203300ccb2c58980f5302afb235688dc1614550b63a7ec15de275656f266fb5f9aa2db8f1dd45820a56b7d40960abc11b182fd9496eefe6ce2d47b31d55a53d6be8250160bb2d8bcdb6c3b408498fb46b30b9cc3b32c3c8a6b3730fc5e28ddd6d5a595907415f03f1c79ec5a1b890811cfa76444ebf798ffc9e1cf54d1b34217fea3ddf6823e8fa9c1ac487257798cdf09499a08ccf3b99ed3762e9c2ba4902a7246d9fc3144bc3c2bbc44914d5472e181ee96db4a6f974cbde426b65f815d354a7cac2d742995394ff9289338d13a62c0f53439e34ed1d92b55ba51a43ca6ded20e5c68042281bccbb43689544e63dea48d68c06fba2a3031d0d648f2257096505d1d0a432fbc4d66acdf438e6620ac79cda1a6d0056e7c9dfb66b03d0b7a47a2ff201c9a3731a09b940cd3737ef9a9847f3b73ac1f122f27df2048ac474e95493524ee6e76897f740e0c7a32ff11b1bd966da6b8a097b74482faedd2a02aa9c081e3fd64494beb3fed9532d19bd5175e8703d94b93d7610de818e43e38738153813f8e01d5bac06dcbbfea3c4bed0c7e148822b6d5d6260b032603473b9aaf73a3a248ef143b4c59a75e14307de87d5f8d9f9f3260920a3e81a7c6f08a9c7dcd1eae2dcd6c24f5c0d14c5d8d4d9baaf03cb1d8793f8d23586c51d1503b60da27ae36e342415e644e2a5865473fb8fe2c386d14662336430c18ac37a7aa6b67f53fe7b77163568dbdc22b3fd8fbe217f4130723a8bf484bb341af9c384f7f624e0b68e5dbd3d2b9701b7e9dd6bd25e0eee41a2ba5243802233c0f70b348c4a3234bb0af612e969d177c91fa5b403095a84fc4c55ae87120409b89bb3bb50513ac5d20813e5dbdd8771717f4b2b7c1172a79783f4701373d51aa70f9e7a9eed97c2d102ebceefd13975624d64fe17e7e827947c69c5c6096b95a010796fcbbf0f3df2c6f37843a408d1558a5aa584882523cf33bcae25ae0de07740d966235862d74309641a8148a864e79f44835f37fd9b70e23c0b156f6d257b9fe1632c684f8bdb713095cbd64f94779f50c8c7df7e8e6010dfcaf42a7cc5e425c5648c58ab053536b8ed6dc31c94aac476203c7769c6d96237f19ae782953e1336c78dbd628052d5a73457c4b633ba827543e9f7ff3743ef60c11c0388d8faaab52bf7aef1028d9115b8ef2cd23ea59b2332d0c16785e3af9197c5960b27838de8a904137d614b85762","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
