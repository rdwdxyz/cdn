<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf8e76a3b556eed9036a7e0311990600492693b9e6094c7a6d902053748d035fe1ceb259df6158094be8e23fa7a7160f41992c888c8a010ee4502c6a2fb46235684720af1bb88d774de9dba0deb11f24b003082ee3968736b279a16e5b84709d2836372306d3917e790ef7c3dd070806eab263d3de7efe27c85e21044b1782ba383320db94e04edef355b55322689bfd52fff916c4fab4058ea825ab97c2570e5744be6ab619d2eb237e9020373a7dce7a5e9fa55ec56cc50a490a94fbbfc57183715249cc7fce0b4c942cae1d6647d0d6116ec6d70743971d38823adfee21bd01ae05e777cbb3ded63133152250f1b04428d831aaf1103990d157fdf893b678b70f5c898cd2d7732d9622829003a02edd9ab17c3b4143bf29ccae0f093d0a7146bfe0fdb33698f865f8f5c01a28c748fb8ea923723b3c611a5a052032c3c6e1c3f41daf11f1aa9710b084cf3def50970e5e2bb0bdf3548a43cdaf2f77c272f0f70e38a454ba2c39020693239283311010f5097f1e79f47392c5b889d9a575bc20766507a460c80523650eb0e92b6403c97181386261c6d60a191d190518b0ec3f06559bf52601e1b7b2a18c8bd01f556c28913884566c31ec639445ee2ea7ac0044e0648c23b51dbf97b6ca8d3b87afaf9557536f9dd98cbb8a4d6f6c20cfe6f6896e55149e66be8d2696ca37aad688dc7759ea439d4dc70c0c7e508e2ef057abace38dcb294fe5546b6d7bd778e54cee2339ee0a09e113cfa9fe15ed49213c9aaed435637588d4a7b115c4c2b543bc7e86ee640b654bf410f98c594ff07eb0a95d1b0d22e52de721951cdffa825df8e219c19bddee5f623d1d2473011aedcc78bbb490c037ab46280614a0806b1dc61eb60d925984000f03e2267a56e6e70d51aea372bec204d76f5c32fb3252d72dcc61a1c467bfe936dc4cfeee6e9a8f61957257e184b9a0e6a6d9b49a495e081a84907f8195feeea45d0e045e2b654449abdb220d14b753cf16ea3d119d66f2cf3b1f835fa22db2d132f893c37dc0169dfd4dec2c2291c76d27c27946c46465dd154abe2f9643db4c9ef85b43d2d15c700f0ba5b3fef353c616b84839daf2db13a7f266b7ade779000edbb8748794ac9861966a4dff70fefadcfb67b36d24a48786d9cd3ffbc0042a281d4a74c3bd39c8d5dec2b967d387f33dc02009b5627fb5e28e6d768c650c36a2e967a46273d3ce19206d7e3cf7fcf695f0775f304533675507e09f24b26c48f6b822bfba4ce706fe83f9d4a87541a0bf4ba0ec2b28ecbfc1a5b4ba32b1fe731a6b29c82d8947bea124872c264a289ce1f3347e1a23e57db9d03d18e5a329cf44b7dc9a147e68ce46249af1af94aac440ece136bc36cf42ade0416f6cb957ebee2848a1fecbf895b7cddac30608d27189404369c71f82d00025f861ac2fff4b25165eea18e1bdf504e65e469a8e3d5cfb8378c2736ea19fe8b9f5d8b485d810483717699fda3268768b12ca74f623f2a8aa13f22c44230bf6c5b4a524589807b70d2282610b1a469fdab043687e7440a61aa8dbd3f7d8f5a3ecd8f2e66873b1ade2f010845ba587539c459a7771d6ffa7ad6576b43d5c7778c643ceead8fc2c5603a2082d56b0265abffecd1b877e6a6819ab6462688feb321cebbfa4283f104b416fba2635c31460db42c90db7c0ae141b136a41395946cf45766c5a571ce7d4a48a735063c6ccc9d44a6d8f772ac9f98e2456c6bdddc80a77809d8012165e136184ec910177e0ef73c6bb6836c87a8001b2f0e77af33649331b6de66f63557b63d94cce50c657119a8257c2776732a5a824d056f16f443fdea29d89b895c50b56cdf605fe2a304fd3d29ee63c1244930b4d3f459ab8132137148ba9eb47398389ee7a8052da1fd639a609ea0f4b2bcf909cd41e323ec4fe1aefa51634a76abd50ac7aaf417a4df4a65ec5922da94ac438e54ea4617af8f65e8fee556971d0c90eb7cda4bb9caa46a981bfed911a68bbbba37354b0c6bddad8dd85fbdf53df5266c7c9ad58a7eb491bdeac00915f6938932982ab7c448ca92754bf43ae613672f65539c57055d04654d3655d1e65a9138f839e27600acaab9e94e7d02e8d2b29d3f2cad24beeacd6e2d6c98e7d991e3d02a2c612bbbed73d5e67a860381360218c095bf10ed092d4a51e97e6170efbc25c05a5da73ec677021601a69b21f45d87fe9439ff8d241b36b957a27942e039029cffee5f6e7941e719df32b41a61fc2cb1966306b8126b90b229e178dd7c6ed08adfcb7e63baddbabed273b53ef94b8ef9c4088d78b2b081bbc29e48f15823f0795f78fbd54f029eddd78ac2c18662b7243afb5c4e1c85bea26c1c20db3447b52264ef31e9281d542c8b93908e74f392fc83efbf37f45e7325bc725c3b502afc8b25687922517890b7495f500c2b800cdecbdd3302b3a564eea58dd183dc2483402a05cd734dafba4863d5821a2a9e83bbabcbf992375ab1f194fa5d3dfc9bf54d491790f6a9a29523e8e97c76708f9c38bc486414b7272e5aa90c861cb9cdd596660b49e033b8714e7e5b21194013346905a84fc7cdd466b02d3b785a7a3c2e96da311221736a1c955ead824f8f3f7ae43eb775ab3fbc515ff6e7d1539a53d447a9051fee63e1483a273b4ff731d28ef5b63c5ab2808337da8171bebbd8366f87f868748a749ef58047097993ac43c472997606418d80601dc7474c7aa8e6071ce2a685bafc0560be55bc119ed8c07826ee186c77cc58b76259965fcc6ee2148e6e185e054fdc766306183e2a4f08bdf9f2239b38f688da7a9e456a856bfe49db008ad5952b4f33a96b336033cd6971b9f3a8c58e189a5f080417f110369658811d9fd2e72e4c6c9a092233bc20fc493f3d84703946d676fc79b5fdd7cd10d5d3dff1d2864f770fb23bd0837a8a2ce0bd6c6b456a81fbfb14e362aaa2472ad54891bf1e92a792ccf5bf8d64c2f67705b754376d1e1b09c2a9de0644e175470220f6cd6162f225453106f1d3eba9ce9725a89a9834306f2708f25c041f2d04718b76e12201ad04d8afa565dc1269eac04e423d67c89ba4997da4085b9944b0ce499c1ca5e6acd51d41ccb5e1928a5c671dfd7890747a9db99806b36975b00a893fe575ffd66b467b82e8eb8d26291ac8e787e85e50e560e4a91425b110f89bcb9e9853f9cdec31f4793f5b4cd2ba191b45157c0d5da730f3ba8888944fea93526cb661ae77ea4f32ad5343698384ae3475d205b9ce60a1fdafd4faad239d4e8fecf1554eb644f97816a3139aa54800359f2a3cc0355be823419fb6468e6e38612655706ebd6b451171f2b463fcae664b85079a5ab4adc68c210030438fb205d3b68957f73bdceffe3af7328e588f4ebf8ae4273e4971e51e3f86057e23e3b1d849eacdd768fc3c19dfa8b6dc7962dee07bda344f7bfd6587f2ca7418fecd4f50ab08065c62168530f4f7ed5fa05fbbcfda7021171ee26c5909e6e2363f03563a593e9ea8e719de0857a547f0a3f604ad04d291a2cef92900363872e2b7bf2bdc37d3046126e3249ecdc60361d12658347a7b178fa42c1049f98b8fe3818c7c42564df383671746964a0051270a4de8a5507f07d55be3e0c877aeec2bc749d8ed5a19a3317d211e35c92d77ab7705ed27f5cbb276933b62e1b65f6658e0b4c5fea130f12cec9dbce645ad968c269e3db839b5ffc13fd66ede27a8f530e8bc8512b601028a71d55d0663b2562c3f41390f5e8252c4595d21a04de1007dfcc9c93c9843f15d3946ee9b6fbce068676519ae1657161e4329569fd2f830602550636cc4eb0ad5bffd1ce37b292b72c50e8e34000f8c8181a50e67f53ce7eb459205fadc52088906295495426aa3d5bbb6ff3823356447b57445a820c374af08959f7a9061726e8e571105f12836f111a557b85c900fa9c55cc2c8269eaef01f9ffedb579f3133a6543140529f51c6978992601a9d37235c7a5b0c92c0f657e54cb06858b6dc09eb4d17f873681b542cf295466011cbaad6190c06642866ecc664ea52a27189789c11afa21162648e7a045c799dcf47a8ba4f42bf614a453621a8fb600fe24444e58b57408f48e3af643666626d375f4566f0391af7190295271eb069c163c772bc09f457e19d3ec5525bc02483315483810621675334b9171e70a6d92513cb2c84ec94b8370763622ecfcd4d2fab3e18a23b4176fbe7c8cf47f10a7b6f343cb0828df2f9e163a933a6e81ca162c58a41a7da4946e42f66bd9273c392541061f389b83b0c59d4f80f52faa2d1f51695dd382fbd1aae8866549715621069938cd160931485f706de284bb9a5fdfbdd57b2d8dcba6f5fed8d70e685d676666ad33c24a3e86560496accd7b49a3675d0d8c73887a0be2ec3c0fad8ad8b0687ad48272cbd32aa65ca2364263bda75cd5727b9a18ed6db70d0c8b2b5028984ad967e7766dfea3bbd0b30ed31a744841fee414f7a35743d771908abfb28bc61290650613ff4f0a0ad82093f8820893162ebf7cc7a39e695457ff1a27a3a251c6a8c5f13b2c00702b2de5adb89a057facbfa729825087336a6c0c6aa691e7704eea7a6aea788e35df2c3012ed501516e4800bf521f9b9e0a7e81f08d8a33cd168dcb1401e4842f39ce437ede0c9b0c2240da14f5897d7b21cb1e45b18b86a6d01ddee558e727587fd8b4d51f120fc4260e3d422e3d8bf3d9bb80a9df3f99282ba63f195bce455457b1b05c599af465780626494b96e8c2c6929ac18fdf0dbff996421c2bbbe9ba69c010f099725275f09a933c13761a8a750ee3f7b06dd0b2c0e0db05d4bd05271e95464d2a4b577e1938ea201b007d6c59083b57ffbc10d7bdbcd1498de920eae23a471d8940083bf8726ae14aa631cdb95f517015833b1c6b96bed51b71249dbbd0ce91ca027bd71d5831004b7a67d5c576b00149e1363fd4227141611421f0b80f20d8558bb07178d443c3c8cdc118767cb736c4c9ec347b987c3b7a884e0e24bee28ffc4d2ac65cdbdd400191495a4f1555cbd84ff6f2a625ec1d1039f3e1e21d48731bf7b8c4c80e8f661b089e06085897de442f22a435dcc583c4471e24858755cf57b322e9b9956b94641bedff5c5a70934691d0f6c916947cb3a7f2fa2921eb01d64d1990c9fa41ea157da960852e4e4fb29fbcdb1f13c1617282b548351bb50a0544bcb3a2bf4d7538ee147a06263ce1134db59740fdb54cf1159a21014c065c6747fffecc42353e2385bc4d05fb3fda2e63cb12a0dc1cc70512da2c03ff16b1ee174d10894a575a0550a39f97d950cab211acdebe64216d0acb589e3719edad057f6557b772d3eb05db4a581e5759904e29b0bf852cdab8f5995007ec74f61e37d8fc8f8b10d1bd027d4d09bd04f17665903b0362aabde59689ec219c67b51731e5efc15b174c2ed381cd880cb40b74c9583d4405ef583bddeba42eaba3296eeb7d3572b84db7ac48af4cc257ea73d50870a3344d63d03707680b6ec84e59a1f1b1df1cb3ace8f1b455bf03e2ad1fb877112656409408c38c923b0162dc2698ab17594c38c8c5ccc47d14a67cede974ccaa575ba2f1e637c0d9b348101213b0bb2b1179c46e16a1fa800023f4befe63b42637b0ca24efea2e4641ed5d704fd8562d0beb55b822fce514a6bb3fa71ad90fba6d412605fab9f9984010fe9f44f806b97dbe1910f28a3ae6dd47d383ba3cb720c830a4652d064cff4e3ff1ca41be37d6683b61947838d131fb51904b1dd6cdccfc0dc1705c4ce9b81f25306c15a839a821a7e7af4a1c81f429a5b8dcd734c81f587a9f60fab0b78f849bf0cff8ca587972eb116caa77d27f458500cf344d7618e8fe4f421f5f968150967c18d3f2eab357913f84c9b039bff00551750f4ae8245f286a1954edc88eda35a5ff72ea94aebba27f129a547fea06fb1bd94a1729caa876ab4beb56530317f17eb93daf0e73d41416dbbe939560490836b94ef3b16a27b4db2d45ee60c80a6a044313e9eaa4808e05c0681e9603250299b64ea8296ca618a52df448314d61f6539681f2212e9a96a04fcade0c6029d8493328a71665e5a68ccd1b18a5e82fd35cdd9b57df1e27cc7afe77600f1f590608d032b0a20beee4b469300b63ff3781588290311ad259c956ce9dfc2f65fca8a8575729369b909b9d2106e84cc83f751f50a6ffb5d659b8b87a3ca3460bd0a55e6c4cf1455694af128f2315cb8d7773dcc8f915ec3e023ec5bc3c0c3cb26991c5f45fcd651c08572ddea92986f0343729ba9c6ca934b5890f7eb82384465fb621691da12cd4b5da4a17cf3d84fc5e030df06a05f4ad8bbbf15ba0f93da3f6456063c046a784c84cf8324f7396bdb2fd1d8482283feb8d8b397f3d9de4c05fb76d15f1535f938f1f1f43bff757a682ee26968731b9060ad8f63dfa44091155955226a64c95a0ff60f70d0e848608901fc6ef8d5af25db301782cddf27ffcee2e951bed10a24a56d76187aabbebf0de57ea384d1506d84b671e0dddfe4db0b30d86e7735cdb2b8f8939c707a7151e9c7f06877ccc9229f1a427b7fe2ee1d5a06ba2213bb0fdbd029d2f2ed8391b5c78a771a1be63f4f61157115783bd639fd2b81772ed2024c5ba290ca9bae7c6015fd6194b56c73f81c364630a68cdea2a3107b27c3e231f5086a352f82512d0d3850ce7d031fe9c6fc05b263e17ad5b04320e80c1205b911e1e88197f7c755e820ad5056030748ec01b10c99d96b187f5630665894f3e425fc2f324e751f2953fb6d3bb13be990415818adc331d7be72516a693a1fce6cebdb8571b3bb6a298768c25d4ac76aec2a0e07e5975da6e192645114a987cb3779a32f58fecb908c17e5f6e51a95b7d9f7e3f23fdd1ce2f0b2ba95a90afeff435f7943088deb79af0ba8ca575b770d91b427e7bf6d50b9d3940d27488c89f10230f24b06d21e1bd33382b618aee2a56a0686000b88254585dc52ea168e3712c57c61e7cf702a03c73162a2582819ad3bb13265ec19000900c0b4ea9b765c4dbc1e84d594ebfb5932dde26b4d64f8881d89ac0e482bbdccf6deadc892ba8441754c57e7b83da1003abf294039a4edefa554c4b3f12c35177fdec5c825f1193212609497af84c60e523e4d50ecbfbe9c595dd7ed14d11ce8cc823df6fed6f4ee325bcad2aa0703239c425f423324da70d875fcc3e23723713053e2432d702a0fc4b5b6aa07d50aabd25e9457b929a3f6146e2ab1b7e5147b06ebaaac81e48d6fc3c7a6accebf8453e4278a0bc355e1ac5658314357eefe8e8fe1f1c1c45760cdbfc2eeadf0e70693e2a8816531bfdfc04247a21ce20bcd5416170f367785c9db6a079028d20e817cfbf58ebcec0031031114437541a92944a3c0daa6c0ea091ce76bea24eb3ae51aa3d3b19a11f0297d66bd891f2604001c8cb0a3a662151091c8de08e5a33661f165d5b68c3d764e890177511cee3eb314c7d871008274e21ff92badf8de87e3d0649f077d8fcecf462f8ef279e8cf46894534532fffaa15571124833bb017db1cdc6204b61b937da569bc644aff9dbd0df9cfb7e398f35f3b93b19622820a64384f35610ea9925152e0829c627bb5fc41f6a08ff5148e45e042c34d7c9c1b66122563ee808ae12b0478e5961ce156c8bfe7c7eed4a993252c6c29f86bf3ad633484dbef92570543c69571976a8d53f852b1dbbc4bc36f2d6e57d46c995ec5b4b0d1bfd2e252a82e7d8d897435c2e44a54964ab90bed3c28049c443f3d90de8ef7fcc0d23f623b8dae1c74576f4cbae51d80fc014ee880fa00c4d6c1695d714c8ed9e65ff3d6d1f1ce10c4ed02b4d00d49ba005a0cf65779f3b9f5ad7b317e02afb95faa02df4cb0e6f804a1b05b9494642d27bbdc8a8f7f7b6ff31357809aa5a57eccc646e198f1b2b951d75227174f312b552e58ae5b3a520272e9173d5113df584bf8472eb2ca9bb4ba3ccb2f1841c8809b3682476411dab47df98dfd8a5259fda31879d783768b3b24c7776fa1a788d79055f43cfccb070f4e4a0da033f0713d77784bc149e84561a5401e140f2671eb3dca2a8ffc8329c84a0bcbe7b05fcd6e291281cac20a65f6a2e046cbc1c0a04c7efdb2e134f307767f1dc3f871a016520755c89349e951fd5914e22286b31eca392283e3400d3ed34dafb7e2dc22d78aaefd37323ecb968c13a97e77c31fa75f17109d553f6ef228d59d379fbebcfa722b0af76301984fa270772835aeec69f22dfc9beaf06e7aaa6fe1b496cdb3efafde92921cf70542a659d7543958699c753c35c8bcce72716873b09eb2747b480b926492f1d01f8c555b160027e4b215ac764702b2c97394cbca1caecc1228bbfc25075e86750578c1998c2c57d2dd939b2dc948c76287ca8d6f3b90b82591bb18b337fbc48e04361d6b6a2bf82cdc1f35d3fcbbb3f5d35a4dba6450103d4678161474d2e45df276976c374ab07887e60dcd0debbb04d16f9463b2a7d73d27aaca568231d9585531c8810a34acc52a6649b783873418bf4be4309db95c0eb6e3f63d0f6ad3563123ea4e731e79ef8a989f6ffec4bb35ac7558b52ff947acb973655e04658210888a79eabca6b5410cc8ec0946558becce2c187b9fab21d46b75474a3817582f29481aa02972fcb0238473661812f8d052710a7fb9425e3c1284b6a388368aab4b26df0de74bc3615347f1c95e376ca42edbbff791ec35cfc4c6a060cdbd5bd271d38f7554251d1a34b92527017db675ef849eec25e90bbef522b528e5a962c686766c3c331094bdb382abc3777c7055506d0ca8018e7adc037bd42d2c9da0bd579b12229471a4b10b088b9308766756c6cb56ce2dc5aab195b1f3b1a25bcf65f53f0fe4e08e99eb175e84f4e45228f03958f387322f2c48adee508265bee7b8c62abe58e706ff18a982b5e19398fad568e2ec713199042296a0c9fc1e735f3b1cb303d8c436a818791e0ff3143ff91e5673aadff31ed4e7236ff0b22e413bc841d26555faf143231cdaac4fa43c24e9170bd454dd948d02cede0b83d0fb83237a5d878b12a067685146385ed1d04a36758d018997972986e3f9f2c73e0a3fc264249e654da2f181b8478e1661c06391365bb3c452c813a5fcf56e8952c4c5bfbbe6676a68f895b0a385f8cb46b8ced229f77260ba096b524352ea54c0515f01c605a5d09e81d6389167f2fcb68e71121a64cb4ce50d3987d25e039cdff30b1554177767df438291111d2edaa461547e4b043387821649f38f9e767dd69e89089d29beff2594957377181e30af6920c18641437d0261c322eacb45229234edef9a8d4b7790f6a187c3320ed5ded9038de6b4861c46990e0545d437e8ff46598284f7fa76360ddcef5b060a862d33a5115693be565d43f1154d7fe9f310fc3ce7a10878f731872283cfe200b869a676cdc4f11b1e06623923edf07d84b2c579524313eb76c5cb01a22f238024754ac4b8cb5618343cae3e0e4eaf8f3926c620405f2d73e561d4bfebe0c42bd732cd1d048fb0a2179563071ec39663bf29ed7ce402ff05c2be77517018f910580f9abf79f80476f9ea7d10c0aa7cf691ba728e103cf7200c15319d6222816acfabd88c22bfae3bf21e616403c6525a29af9ac7bd2baa6f559938d0f61ca02c5e267028f6ee67f7b38c2b5980a8e8378e9a7f2dafa98fe858a096c5a6ca316a748555442ed3fdd8a21f3c2e623277f6060aac45a457109ba4e15a6337b5d880d07cebbd7461017ef819fd629928020a6afe6e78c28b7f69f76d5687d62b58c6bd88527daf66cfdf4365b45f72112325d9e7875b02d2b6a2bbf672753f98cabc98acd439268e37e174e3b176716f857a8b69efed9f0a63de56af5140ee29f926eea2b9b6e45f2f97cd44dfd6ef60f877aec13c341f4dbe49c3dc7c95bf4ead944ecd0285372b0149b56c091568cb5f36036a2a95afb587e5e9048514a22818f5fcb1bf6c14e7fbb60900191def3c926c9e588de6ef6913456a6e5b1ad4ea929cc2d4fbd98dce577262ce4e2ef1979b08c7118cb5c44ad5911635ea1347e81973d4d45ba3a511a18e59a76aeba4c1e4600ad345a08cadc7782462403bad3765e893b0ef4e3a1368f64fbfb87c4e4ae4b1771b65304978ce9ba0b2b617b5fb3225c97271f083177ec99c4013fa47c574504ee8312c3e8004a73eef874cd672b34d2ce9e1aa62fec1975b4c048ecb8ba1cc76ad0258e9a7aa4c24bacabbf1cedd024ae7ebcaf849ed1da385bf4e4a3f87f25c4d33dab538f5abe36a0c3189fccd626caebce2ed0e80feafc02f5877ccfa0b05d6f7ae90491216059e4c9921fefd19cb19f89eed546ca5ada3892bcb915e971b3f06dcca82be6c57df5f8f14f506283d37b038bd9feb9336af8a31f2d723abeaed782cbc76ec53434109eff37efe93dbe7b8838cc9b445b8bf0afac5c9ca63e3e4603485a1fed9990a2d36f11c37abc1bc36bbb021b401876fffbd837426c068e2251b79de783fbbc258c3b5d4b1a869b6f2580b329e2cb29676b92d0b567c525fe312a96b2a7e0bd3773ea590571c93f9cc337693cdfcc3c27799516ab46a5e3939dd2ead59df3e397cafcdde706a365abeec5b88fc06caad5c4f87255ffc1543dd62ed35d8e668566d4654e78f5ea5ffc7fedf7a5943ac04b89f5392f170f21314bbb9ee1b2cf4258fdcb6adac17701e9a70dc372cecf3254ae92d5fc4a8d6d2b755da9739ee169ee240caf3eb8f1a85ace788c0eb2918f5d44459676581783a72383eed5ecf0db9e4884e6b0d711f43e722fb9629e3c8971db090b82ef9605e3c94c74d36bc3a99725823c11cfc5bbc375de3688d1cfe3e6372d10730ab373e959ebef3142c9cb513035870dc6981a8459be86dcad39bf604b01f9e51310f557ee644368c4fa07544ccf6ac1c39d18eeb6f492d88cd96de795e25bc9326eee2c787f14714168f7714bb25d798a73fbac012667553854c19fefffccad6b4aba960fbda52558b598373ae245785a3eb0c184a8f36b873c0dac5fe4b312cb6b58647559956152e003c4b30d50353c5bafa32e7a6264798d3fcadda4f04010453417a3c7a36476b5597443fd2bea5fb83b0dae83d3765d9b32f8c5e074286a8a9640d4b2a4b70272dd1320f33f2bb72ff4ea8ff83deb3c5ef1ca61e751fd3638d8ee7b43c83a2bbe593620c8b758b4d80f13b7a9ff692912b217bdf7e6b381ecf33bcbea9cd68fca867871d65f7ea000b5bd07b339c203a6250edca23ea3e0e94d8982be0411735e3dc287152dd8197a40b6be8e30cb9a15078b1326a879b431c8f7b7c44678886faf0ba4a1e8fcfb38571cb7f6cbd06b436af6113e5bebec04ae045291f2457ed92b86778f068a68f52760178f8304eee51bb9a1fd632b5875062af8f33ba42a2f9f3b0fdd49e420ddf409cb0c1c77da03fbbcac5fb8420a9c34ea459d4c903beb3fd92227fd59c9ec4564bb42a9162b50f60130a07f086f7ab7cc43a52672569a0882694e7cb83075a0f78c45906b1ed01ca12f268094a2c6a80827679baf05a7d484ccb1ebb5a7a90174b5def46b130cfa341f37319f0fc2de7b0afa4922b8a1310d9637762758e24545fbe4d7b1dc4536141fde026b913bdc702d4de0fc58c2fedc4029bd62ff2b7fbfd48a1d9006a31bd14a95062cb5183f207f7074f0007ff64c3ad8e5535d8e9cc185b4f2c8370259fc8642a33579f00888ebc221488958eecae9f90f9f463a2ed7e2078d159529490c8894c5bb69c764c6045f1f4f536e08d928f37bbf5e0b5208fe4a91eb07d048aa5d1d22cd7b16e101cc38f02aecf2905886a19e0b3f0d841b78fb8fc8c45509bef4806a7bd2d93be25639bd13465bb7825486bc69bff4a9d84e32c407b56374f9eae6c3c054f323c1b0bd835b54236baf1eb12525e24a5760ec41a383a401eee0a75c114b46a650cb3794663038f830131c8f6ed806d3aaff7f5e6b7e782ea3f2b179e6e710a7d334cbad3f16876a54c7ecd6517e76e2a3bb5ffc4603e3912414baa0bee2b3964eb8fcf2f7b07a29ddadc317227e845e5b04a4e5249fa9b93408a461dea889cf0807ef5a21dc03b7c651559c7ee53faff7b995a6c0a3de4fcd6e1cd94c4a920547c1195093055a67baf7fe54abe4559a8957ba0874bcee25d5747b3a2ebd546fdc1637d02a3f315a19255d4ea7d7d9e52ed2feaec603e82268b08949278bdede47ddc5c2e9b24292b764393c2e63d933209ab41a36f569463e783ab47b0817e30a90bf7fd9236644316f1299ae6f042f210a7d5fff6c30256f3b13c402a9029e434a87723ad5a03e8a4f278591c8e40f8eb01b26d242e8fdc22212858e34a79f2511a391b2760cd88e0e30c5b850a3598d0f829c3835962b26d971227b97d4af0d9b5cc9128c708646d8f4d0aec226079192438a2e9f46a87eed0dcf292c154a2672201de6bfba23c045027ef6b91e0d42ee87e6596c819e090451aef9a8753291090535048cb082f008dc79f14236ab3cd3ec6218f950d49a8ea82e3cce457a06ed677e5c4a2d1169eccb2ced31f70e3df24e7421ee75f1ee6ba546fcf2c3c89913e49d3b3ce02bdcf037ab9be28bf89311479d8eb00fa2de5a3973a334aea690de3db9de7b4932a1846e9f636d9b8c16e023752d598cf5ed16d9eb47e857e88ad1be2997bf52fecc5206d79f7ff7956307e01dfa21e450d648b1f7129650f970e7da6889a3ea63c9ab73895ea1981eb8d6663e4dcae41c40247e50df555e8d1bd641cbc8d1a0ecb5d26b25d4a127e28a18a6f529db83e123727fc79bfd5696cf08c4f75a2d9e45fb059a3c1c017f0e2f83848e8352c276b0cd0d6ba5b940efd317894b989630f6b2b94ec33c5b0a31d7cbc038688a286ba822afef89d57a533e820419350ace3ae08d9211b717a14eab1f780c9d7c204e50073ba43674212129c6ae413c2cfe83f568f7f6c53d29a3f01d1a20475169212c18a9ab2ae1bc52b0069641cadc36a5dd232644a6989490a91a4fb8b8ca1cd327bd8ab9b5eeafcbf3b7edc6ff73e1adf210e33a14edf63ca1aa32b0f94cf47833fb91922852d2bb1e577ddb6b528cf6a2566e4aadf7b7caa311b3f61b46388fbe89fd8b4a6e0e3b99de076b789d21b0f29051459759d598298db88384d4a6c05a858ccc34d26582a29eb754597b382b0d74986989aeadbdfa6b503fa7cd79c4c63cc56aacc5d306723528d7d9ee23de9f83a760fb68973c8f51404b86664ac833c299b6103c8b43951aa7658edc2f9334c549a97f775c7bb322dd5cb90ea5ac53c7df436dfa4180ba028ba25d006f09c3f25e93208ad9a47fc4e646558df22e3ed94db987e1d50d8be5e4eb52a2153ff2f1df90a57425a7152f42b9db3ef1ab0054a8572960fd31e676b8a747425b409e660d1412aa0d86e530f402ff32ff7656dd9b07b0f518335d1a167787c0b6d99f54179621206fcc174564c3ac70858aa6fd20c9e17280f34af7deea6543098d10f28ed645dec980861deeb3a32cef6abb64a7f9eb446dea412e74577863cb7cd1b1113086ee12c8a3c214d096a3ff487a1e573c391a6f9e9aaa7bdb7d46e1a1dbf50ded9467f2d76550c1395077f1c6dd7062ac7a053efb832b18ce7cce040011ec6968adffa155426eac582a83e32fcc510b1d05748ddf24b6c4bc4bfff3e10258c3042294cf09a513e4babc80fde39c3f69675c870a6c8cb30738e24db32419afcefae3d61723c6630daf448e13b0ddc39eee7fa8f63f12a949f5d0f8e8a5d5d42026ab1a93de113147c9c7cb5d157b5c51bd215408f5334c6f964a5274ef7735f5b080de98779c99a419beb9b2ae8ffebaec0a9d8cbf68f37d81827461789b9983f908f4a18dd52934e89c4d7df794c36193a48a732d5ada29a219c2b396a99ab2489586f3c0966b72f436f2b4586370560297a9ebf80ca4467fc58643640ffaa3efc5cf3a0f420d28416b6cbe89c928edecb6e9bb9c0bd4430e3a3bcdc2c978973846dec01f840d9d006b9d60e1836c8057db532b05e45e391d82b8c54836546d40b7eaa10db05c6b7dafde18ee970c768fa8e5260af18fa80b760ee6eb0525ed656cfe75a867ec54fc3ca146203e5a111b8e6fd8af5acac5c977bbc7daee68d4fa4f2ea6768ead6f0340a076e23f129159d43414db861db4b30425c00e97bc593a18d89511d4df93fe6c2dccb355c56fab13c9eedf6ecc55527a64a49c552c6540add1759923bf5db10f6c10bd34fc0dfac71fdcf1ebb0240dc0cff0c09151d4dba5b6c7950df001623f0b76aac2de62664dab8f5f732eeb1b66e75f06dd942ac5daf9670e797fe291087f23ce5e6140da4007d2f90d1a71fdcf70867d6ed3793efc46fcf035b3fa5676c33bb1d991fd2dab8e25b5bf650dbae719dcf330c69ebc346544786707c9e2e28a481fafd25ce88f8dc7c8bcb62afdfabc5e1c7bcf932dbc4f35b378019b8254e706e6bf4c9658fb674808eed74d24849f409316ccc13c26e06a40b98285ee20733831a6807f505bc57ee1dbb72dcd8969714d1c00a67b388ad6d0556428a2c7b648150e2b59768a7cba9827bd45c2bb16776e3afde71817ed80a2bf269d52f15a9167d68f5ea4d05300aa351645e42a04585979faad2f86786c104603bad71b6e70b043b75481d430a584dc52ffaa11b78d7b929b4e8db1e422670e4fa741d1d4c613d5a53e3b9da13476560a78e73b924b8f1b9d57ac2db5660a30bf1ebc01211fe2ce869ff6c3a88c578ec2f2b9a19d6cb88023d81d70ee1689bfb591ed0960e4c11e26e3b2fed159de10116aa2e52e085f82cc81926457f56c74bfdd014e1f29c433166c2a5b57073af05c9641bd5c9ad185c1f95e13483aa242c7dee37da0cf27a1cc946199faf42de2e21c37d2a6809ac141b57bb4c2fc801466828ba85f1509f11e0354cf110cc68330a20e1195a04e654f4e4aa3ce6cd42608a685d863fabc03191fa9e46a275c9597196c4aabdb78d0cb1f81110a7a84e0ea944129c7c2ac9c94976b08f07a739a4e0d3b444d91d799790bd01b7838ad485edbb131e6ff180165d08080fa64349a8193b26d47098fe08120e673bfb3f1a35845c9dbba3c619463de44505ead1314b4a505440d885d9aab58df377253dd78cb58c6004e66149e37ca866bd84d9b2aee9aadba280b2cdb075c68f3d6ae4ba0980c294503412363c4c006eb8b28ff031bbec876176ed3f50c1e4b9f0afafdadb46ea324912677efb66b20568ae60f4a5e1da72fafa2520f1e73ef9e4c1f6f2b7f9a1d8c445b524d8455423ea1a6d61f8c2e9595cb178ad02cda802d8b4e78737b137bf38dc40b8e04e98bc747c39578ab34af58ba4eeb0125acb1e3a4ea4ef726aa03c1f40d24e603edf5d456a698153e83421fb2b57daa42bd85a15fe2b334f3f321b77c03ace9df74b77acc0aa6d6148b25c5cf6134af3c5353d91a37b074ba6eca7ce3364c90c0baab98a7f6db5b3a9d73952b33d52fc53cec7d559805da3b566ad4e688885b71da6c16ca672db6e45ef60bedb045b313b26a8b9d7141de93aba11a59c480df08b66ed3bd1b2a26cf92e2c0dcf75537405493e3eca34e99db9d3fa3665f89c752d1e8bc21c50f1e2808fb93c4a3585b56e24bd682e8c1c74f3d98e2796572b8a01cac1eebe221e7ec4de11e1f30aa0ae37fbec0ab40f429c75870066f53fb343260ff6406184fa16021052adb17888fb179d76ebe302e019cef4ac52fec8d46b62f6dbd0b8b5b526ed7de75020f8d82314d382d3f29e83552b51eb0fa78db35e546d996ff1e1bd681df049feb0f54a29f5df443588e9a4b640590a8ac2b63072b95d8a12c73f9cebad6e2ba36a429b37a997ac133d8daea031fb3d5a79705fccce6e8594d84c329bfa343611a0611f37fdbfe81a98f645d3bb728ee3248c019453eac8a37389a25d1461aaccc433ab3a21cd60cbfcb1318961dad79c3b78eadd3aec239a6d7f8f5d0f4faf92628749bcdf802d27b62aa36f57578055f61b312ae08b8f031938f97c13a4b6ff94f933a0f3edafded35520b658c8a7da054de6ea912448937a45a2d79f6d757b09448643a9fa2d5a6225e03f47080a7f7cd396c1e9dfafd7ee4a399657daca81201a5b29119b87cf846722975590380da1239a48f8cf8c3bfa32654e967e5b40434c68586058859297908e3ef4495098874e58419419be851c39efe4a6c37c5e97ae0e65be4343c84a7a72de41e87f7bc2d7ceb78d1e878fefaeb832f6b147121fff77a4f746b0d5856235b44c92c72c18c27a26b67d56add03fa41445906f48480622439408ff63684aeea4285e6f1809c2a1d927861417fc30ed31cc252fa6274505f2c2794a3b061c932d8eea63c731a122d57d84d9f781e5d82e7a9c71b1786e24cacf98869bbd750c86a3832fd0e38d3812e93d38b9f7424e9b1ee76f0310e72d8becee7396c6b5ea397a0c4a95ae1bd04bf8dbbccb2a89d34ab835fd0f2af548ae343913c3e8b0f0cf18753b4164aae52d391435c4962cab65e3c700355b04d1032041fa8a3774ba463f3c40312ffa1a1eb267fd330dac59ad4208a2b9549e94a37177e135a1d7dbfaa9d51f1e5b20ca057750a70500a54618b0b5283b7d26367138489544ff7e305c1bc09bdd6c38d8a98c2e2a5e3ccd77ffe8a8ec373bb7444998cd8744926df836d7926256abf50c32457ec39ed37e072200ca2d78343b80d6d2bc49200eda414d2774587d4523c79a0f64f97118ecbfc37b1f763ff64a358d4535dcad7f0d6ad00c4f51816754eb881eed9541e8197c5bcb1fb1fbaa14dc3602b420fd5567171cdd7cf69d7a52cc2387a038e78dd82a20b8689e990c390df9647cd9e50c69da5f4a7173a5aa2b1e9749cb231b77ae42cb0408eefacf66c18b07825d80cdfb27c222aa245efe34408d7f8adc4241c3ff484b04343ea90cb285faba64062570995247e0041fb4e0cab0f173cb6f592397df10db12f1985206ae62e5d8fd273180ee539e5f7e217f7e9eddd495c5e489174a8ae753cdb65cdac6bc67aff6aa55ee2c1ee799a0ca2ca84cc5f46a70021dcbf96df8ba25a9f916cae77aa6ebac4648a8b9a3117857445ce6cac632be159174f88285d545001e19922af88a386352f4e209441217d3ef3964ac3b618f060cfa7775400dce628faac9bfdba2c72d40f9eb2e6d18e0fca65a56fa189d700d5cd71f85130296218a057e12d11f1e976f164edbed38c2cd0e1285999ec22b944fe06cc7744546a56eb67fb4c0ac280782769224f45e9746a96596e78dcd484e3bb62307be3f86cf0a02ccb59a16ef1d9aac81985f118a012279dd65731a8f2424eed023c034711b0667b3bd1195aab6f261b6cf7ded971101a83a41400109f59b3bdda8a2ecf4f56adf2f942cf838b101b6ad6869126447e10f1f1cb47d47cd1e3f48ca243e6f7c27750a6008bc03e8460cfe301869f7fb1aff8daafb066aed5453a310b88191cea22b0a348b7fbfadbf7c8669c4f650e0790175e5621f60fe9ae2520b56efea16a3471f921b9acda9b17e6ce75a0446d006aa2e6b382fe70c9b272d873078f9742b7009f67c852a174ae35119bb02c8870d0b67ad31602c2b5959c90caa1d22532a99efe654a5f4878ee434529426bb2360036a027105e60868334dde5de56cc3b465480d368645f3a0070e7e7196dd116a153b1fa2da4ead63bbd20b20dc852e246eba7e698f6159fb1d69e81652348844d2fc04da9b284dba4bf5ffe1cd4c363764f7bb8b9ebb754c19044d65d8137a01b41eb154336aa44eea25c0ebacee67af2fc5ee28d54bd6b487b452328ae517adf3eafebd66085b7816de45b4e4f50b5fdc9893f3db9545eff5f06bbd7d5d06823b38ed578cd7b09c3582c1d8225654bb3ed26d45cb40d7b97504f619c6c695204ee2b8295a6eb1e035ad579b5848617dd77b750b4308336428e16f2b35b867ad5bcccf261c97ea4dbb42f992d1a064f8bd66d3b6aaff2c42f925aa98e9084f0eb6a1e6fa7e10052ebbc7f6396535661b4999e553e11a1beb3a184f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
