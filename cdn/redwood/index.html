<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25235cc5e2a1293f37ae4740e9663f4c115b5911fcdfa4384ab35ffc622ffedc2fa978e8fdb94bd90c38ac290be81be0a600ae2e24d43916e6d6311d1d5af6ea4cdd8b77eb1911683846213133723f6ea6625f029a7147e6352f17cc185088c6a706c9fed4c4ac05d68acc11b41abcd0793d6627f33de90790981d060173772f307999c89cac09aa9c48d5c6aad8150e6347983ab8b1e146bd8a795ebb49424ae22240798236287f2d1f6587101510ebe34f78729059e3e81b980b9929388550b3efe9878756d000c183aab2d13246c843a8685f0230b3c01f01412385b536f94f9a8d8b179df6ecb166bb29f9547a768246d95c9dabaa231b2a88ffce9c0722c775e2a0164324c281071742d406cb44b5feca7bf870a3fc13a7cc76437f9e8ff3c14683187363418d2982985edc66555846be4825d57169d302ff8aa057c8181a24a2f2cae9e0aa72b32461230719324134c3982aae2604b2d53b9a06c3b970172bb6888ad2eca1f007fe946a1b88fbccb86e59905dbef72643d17b7c88d70e37097b0be96e70b439e3c274952d3b626a8914958ec1dc6432ab3dcb057dbf9a2961395913bfbc0c981afe6731cf1c18ec4b7c7b0e89b2ac4f81e30630f1b8aa39c52e8845fe30ae15f0a07b018e122fa2983e0f0b34003c1535c6cc4f6fe594c0264bfd5e5a8d96de6997131002a90794ea0d64ba3e05494d692667c9c16dbf12d7897f73c71e2e39da56bf73af4c1e120d9d95c95c3b06fd59e8da273a4942ec024a86ccdbe1d46418d173e1a441c762dfe4b2f32023770c00e4861a3908f85de257651fd44c21e32c480a4e159f06c57b57715bd21907bfbe71ea64ea85b7f0f4b577641d7a3734ef7ca402b8078098a059d589efcdb8892861b66fc9e236e1135ed3c3d6a99d9b4f72f19e5308a6319d30f66862261d90d17d909dcd90cd6c3945e1b290df8b2449de091c49a0431c88dfa3666e78bb2119032f088b02368bb16731927cfdda4ecef8298991a54c239a3138e132955eac9cc7149d25620d8fdacb73a112f94c5888bf98b4a87bd75fc5cce40de2c023ebfd662b37e067cc01fbb06f3d0d90c9521e0061f09266e3aee65fcf61106b5fe8a748d69130a5d67d3707c5afbee3c889c150417324da14dad13839a468bb2fdc298db77bc6606e2f0e50494020140fba3aa3c00bab0003a5e01090042de5672a0be2741109e1a76868b367723dc806694353b1cf238fc4acb46b9c936c2dda5ff615cb058b00a53ba0da85f64c0c48d22575b1866c94c4f9ef85513c05f5b4db873112f43533025e57ce4769db8ce041d93bd2a63b458b167a4268414dc45349f6278924741f6055cd553ca91c62e33e8c696d98470fd293c3ee2eff21cf14c812afa00d463559b12e6ffa7b1188ca8783bae6d39274c84739c8e387049a720e182f68c98d272716cb78f220ef90044509d136c736f42ecdbc1aaeb5cb50b84586ceedd774d74cedc8d70f120fe86974980e5abd518691e202044cb7c50e417ffcc77aaaa83545a9664f75e3a3cfb115dcd8dff730b21b128204f6c0ef8ffb2a10622a4f6ceab884c31996b534a26091d7f73da04adb5b4fef38d8eafc4d56b2350c08df170674554f17927442375970326f8f08215f96d63472a53ede6f98a4d95021116cc993d317fc70755ff30993f60515c816cfe6e32eccaf8450fbb461b6107043cebd99f5bb6194e72d0533b9039b6a8bfe82613576bc281ab99b85b841d696ee8aec20d88b0cb79113d855e90ee485f1a5f4b239279ed5da82e33f3b14e200ea6a44e993f3b030c2fcd8d887a91d764e0882174285f00e5ae6001e419f9f725b600d2c514cedf5abf25fbd60abf1b2c6baef9dee974a6903a1c8afb556022f41a10d2b6b8e027ed68e6439ed55a3700d0b3ed5dfe6d69ecf08c4ac2c0c38f2a8b15af91f2201f78f41ee915f1383d8e338d21b590c8885302866f73df1a9e30e0909afc1f44b4db6006a5ab612b8ce0ec80f912bdc8994774ba8bb762181319fad27542a63e4025dee856df8b60fb0552eb9429806bd566ae0023f35aeb0f0fc74c64ed8d277fa2db3e18eac5281b697b1e272810038f52502bf32a0af36035367d92442bef8dac562f1bc3b3c663989a0c2153891b01b14c2868e622d1f51315aa5e44eff344ae71b27a27628c7bf823073e07f60ccfe36edb52f171b43e2284bcab60a569ae2ae2d1a94a0356683d0b71c9adb6c0fbd7645a758fef0c64a4817539b0b63faeedcf5fe04c883925a8d9ea266af0b0645a6dfee1b2154918438f59282f4908265a3e39f604de1371c6cd94549d0303bab7acb4f7c63ad24f574cf2c1f23e292d1695e3c388442cc22c588e39e57a0250cf39c17218ce570d36deab8e90f6cc6bb4edc57a2c361c39233b1892d73e6d6a5245af3ed365d61aaa31d24880c10f6c71844d1b586a4668dae5fa4048e6a6bd9fa1aa01d2aa767ad95f627e3dcfa3d404fd887bb01299096b7621f9dd2c536b8aa8c63839d059fae512a455d17180fe47306ef759014712c5ee2200079c8f407d0949a2a030719b06a18e914aa1a7d58bc1139d9a4f3ca92e716d0f3b2bb2e8192940ec7a0554cee4cd03844a30bcdb097a60e8486992898c644461d1d6eef1a9a44d5e3b9de85c0da2c62b808688ba12c84a60ca03d95b212e8ee1dcf2c43e8f681f0f2468a209de68fba6089c860b66867140cfa2cae8c34a13e8139c442df017ece3d23bf995ad1044bd7ba5fdd82acc512e8395fd9476f586805b6db460c2782b8393ae33740d7fa50cd76f79444f73bf01493cc3f3eb964954424782cbe35a1ebd9ce8c5e28d43017a095303c4746aeedb774cfa13b5487c001d84793d994adc9be6df6f5a9e76ca36374c09c451afd23ec971fc910d30b0e393b0dbb4cd362c8b1f1d6953a4732db85dc1434024441351d40ea29a14096eba469b5029532771f2879015553db9f778caba70fe45675e21fc03c7a235ae030f50f9ba66ee6ee3cc0c9bea04c6b374f3bc0b90904857606615dd837f013bed1213cf6c39f5b74f684771d898e1d28093e2acff187beb25b46850a2d75e295a9d99d1cc3f698b2fb9b31094f504123421b2ebc8f3a53565e49dad3a19799a069eaaf9e9165946a352fb6b4678e504def94e0d8fb3745bd2bad064330a2235e51e254db65ee0368979ff28dbc5660ba068b4cf964f176298e487149beefad2ca596a3000ddf9f33edb0f455893e2ef13b3d8d190858388ebe7f17e4483aede90fc11c7f9b9fb5fa4a921fad3d17a35bb89559407e563366bd9650c1e43d23fb26d790e27c46ee4e4f479f178e8ab439b3dcc67461a5676a4049b77be14b2594629bc1517859bb3d1b3a8f03348d9641321c39754d15314fde4951ec473aef01ddb7e4f06705b994f92ccef734020858ef7a1eb528f4f801572661d1512357480bcc85ebd8497e4c69cc1d3ba11b2267e200ffe62279cee84aa0aa89d99defa789982764a849433a7f5f878fa003144bca7c9dd83829ff6934cd868b4c506f202cffb18f8e6f465570cf872a16dfe4df1d8bba8368b5cf54cf3190490e56df3ab15684e5cfcef2bb80cc7fb478c80c14f4629efe4a62b9b2f56a08838083dc710cae51e0a0a300f772a3690ab35802e414ffaab31b5c8e50123ec9841a4512d4d18cee75388c2b543973201f8b61ef643801cfea868715c38524cd10cd3c3c201642ea2074b6ebdb0a57b43f16cbdf3f3f7fc899df83cf7535d362c6b64ac4f81e548a34f334e3bfcc14bf97dc17e9371735b5f1c336cb58ce5e9474107a65d8f3d8e4dedcfaad4bfc4a46f69854ff11c2ed56c121c31e0cddf55686f02f8d4b9578ab94c6cc777c52c7541fdef7116d00e30b7cf83d1eb687f9c13e7393a833df85d4a55cc7e36871aae28c8be75429c7bd6e4ce64848f5b1a2ed37188e03840fbc16a48ee5960ece1fccbd06633038783bb1567967c253e67a169c4680059c39768942d0f8339dbd1f9b789623308a35409a02cba4c50a0103f35985b0b091b4bf36184c0793ef540d3eb3eb3963c2d1de08f77f6be876772f9c5d0fd530550c486999c8a6812665908391714366a7779f8de1877cc6fc42897df69c8f65e28d99154b0f0f6988765c65697725ebcffc7490c74fb3afc7c1616ee740ffbdd74d426a5cb90390ae62328f8d024e5914fb26c0f5072fdede1132e1aae02fc69f021d88e0f8dba6a2d14f244ac3ab403411352057503626ba3f2c237c61e170e939c99b41b81c156612ac16751b1e14d07c614cbfbdbad4dbbfe8df45be7df9ef2947a1d7b0fa725baab67f7e52ba5230cd9d9bd8a7fd67135422e92aab9a04b904666114569896fdab9b2a898a097dd8153e21fcdbb329b9c4b17034572d4735048c57a97d085f08d2075d4273b091ce8a62dfcef9d9307eed2b323a674e306275356bdb6c26e1eac7db733000b8825cee140d79d1415b5aeb3edf477be0d4f143a4516f663dec2f8ca83c1d5aae0a1aad7a8dcf27cf04f8303412b750eefe9748d5f64f26f16257b64e06c8f5f838644ff614c1e546c4222e319e0ef4a6d3ee15b524ee2478b319cff10cdf5a3a5d5ae9e076ab248808139301e79fc9d22f71c4983e2f0ada98eea13edd0a5556c9ddd6f154146a49d8d9cbaf88b2f281c6f7d2c5e773cadfa23b36f287cea4aaa0e91e0bf103d734f55e3180c96279960e17322e8bfdeb9bd1588132cf99b31bfe8c198356398072672b7c0aeb233b7db4f3a318b0bb7b23066640be36ebad21a52cd2a34ad5fd7b168ad33ad2a311563c7a5a345d1dd70ba32e002fce8cbb1c026a6ac73678faffb3c2e7d7260f892b6b0c16996ad1e77d66f8351009b3ee0279e91214de236521b0bf130e60481618937c7781e46a40196b6f7cefe5ab7eaeb88bf06d5ac167c236842258d04e6739d89d8e1d0496cc0d16f6a0938a2d17632faed55c103e8346673c71107cd8d1ecb89ba47e05b0bfd7bd303fa5e70dff6a15121333bd113dc3f5e120eac7200067c528e2105c52b7afdb71a0b63f3ce79f45d7985bee26d632081f9091178a35cee1fae1677359675df3f1e6d242d31f59c6b377ceaebd2a8c52d976553bc77a5a38d268fc6519c0b3f65dd196505477c3b184bf67f0dffc46c68728eff3c2e6b642964db71807f3176e32ce72aef64891869a714601ad1299f4193e3a08bcdad58e6ad54b425372dd65c36cd22176853a4287f36457c059a6989841555b6f54698a147d45e5055e18e95a96e81bbc59966c50d7613ec647dfa262da94f3943438857077be421f89156fdf524ca81b03d0198320e065d7a18b1e915b22329e2b32bbf7ce186563f1bb8b3d1c4aea1a739f2cbdbc5189097c22c54c0b8ffd1300843d9510f9eeeb3e68dd175a225d438e1cc1caa7055588846b457a6c6d26fcc2d6bcab486b4e0822445e509a422d62267267bfe3c6f9a311af5df97007314ff129d708976246d850b384337aa86b9a001850c5b7fcf2c2814fffeaa75f2716db5b00f9f9b18b8efd4a203f581c22dab32117b511f28a5c7f3a95b8a7240685ccfc33d1ca75c6bde57e4d8047844c7af62fe8f3a405b685443054fb3a3cc01250e6900217d3d6b19f8fdcb2b1b1043e70957906bb9ed052d93b51975a981894708b7241f56c8b222003efb92e02592038314b0f6f871adb666563176f89a911d0cddaded56f3cb9d337030a2e230c51221c8bbdbd55d3b7abb623223f978e7818ffc68044729ec51e0d4c69ce456201f35d8c6a6312bee1b1abc80a688d0a1a2154fb7a651bc68db8e2a841bd0ed4853d07815d02c952fb6c09ceae470c8d09738dc6b79d1878fef19c4e94919a3935af44b0b6c638a3634a6109ff69bd13d43e0bc92aebe1e08924bcb5f3bf7faddbfc5d37271d518d4a57ba5a7ecd21f0aeacc556fe951a52f714bcc61c71ba93bfa2587339c86ba24a537c61f11985a2121ee4413d472070f50df2427e14fbe4ce5055f7378376566dc5f23583ca2bb129aa98abd9db3520161466d2f6a957ac31ca7031825dcfc2d5b5d47b56cd416e764f9d0b3d9529230a859ea0e1ed7930cd3ff79f799a38a64ca9a4b699ffba927901a160643aa8351d0d7620c9c578997d30b367caec2472e119f3e8eb9bb084c9536db75f196f19514cdb701429ddf2e26778dc31fe8408334d4f8f10c1b45e701de5ce2a79b456c85c671c5925fad8dcb78f220e16ee9b1559dd152a64abc210542e4e2845620ddfb189be8172fc94c924aae5a357acc3072a3d48faf5ce4c04babda0ea3c278efeb9a8d5f57adc9edaf1e7165c19d29d16250a9373a68c75dd51c5e10e4441d4eade330fa892358a42b45076f9e2dbb589ca4518574ae2666981400e6162a88dc768ac7a1d59d8b6183c0198e8ef81d46c68247eb2bd6c0194131cca744c957346cd1ad60ce34d7a0613eb2e1054febb30092bac989352fc5cb242536e9adcf7dcb8c5b0802fee5a3eb6c1bbd1cbb2286aeee9078fefe6ca4988c8da1efa72e8cb2950e53e69499fc1fb60fcdb6f42d5ffce762585a2a64141b88351d4ef2e6a02d7461197235ee877d8675406e47af4871516c51b1cd278c4b9b5fd583c8a6532b9d955cc91e5c5d7e8637f385ffcf43bfbcd40a1aa697ededc0f6a80283d320e441697a9365ad7821196d0a005018236e4da52ad9cc692191e8b852886a60b0d03076c152145ec902d831bc54a730a0a0372fc1e878fdf77a2c275394262e27716aebd65828edbefccfcbf44c815418c07341115c692d96e682accdc754fc39505e3e2987ece2ff2773086581806ce2c287400657d073ce5becf16187d8607b557374baca1ffa095e15d10e2a6284922300492e87485c8aa1280a61ebc3fdac37d83c8282c804374dfb565090b95a6722a6d9ae64169832ddbb173ba5a2ead6155e459ecb8e6f41c46b1b87550bf8a79ba9ffb04d58eac9e3432277fd8d3f71d700647158bf68c010e7364ffb2826ce0e932f3be84a244793c5815febc015a6dffe67a14233d109ec4e709ed257ea3408e6d244306e5cb40c91f1c0546561ea1eeb0b587dc31d323ab77e25593a9c5a7858574f137e19f2e9ea9503d122048687c238b39b355ecf5d36cb7024506b36b6bbc72178d06d533bdc10049a655c5eb3fecf60f80e163ebb3a259fa6d5fb846a37c4ebe4d9fe63aa023ffe019c354027c07f301c580b8d9d94d49adcc016e410e653d36b43e58b4e6b03c7450757af5671f7ee552cb252bf811220b4c8a09c825e21ff90e51b12df0cd9928709e675a3787c177deadeaa3b0d6a9170074f3def2b090d76da15fdf6083f6480c64e0e4d7f2b447632bef088f26d8aa1762fca1c9001fe13d3f18f9e08a5ee75971b568cce6a742ed7d796bd2473d78c0bf827a3caf74b77afa724d2e52de5a4006fb84bd01acb09d475a14d4aab6b284c9c5811a7fc80de20a0263811520d072d2c5c07f7d0c478380c73388b576d04887634c9fc00ae5518fb94723634d18d0b93741cfaff7fd9fe1ef08c04476b4129737145eac9e6e80d11a34dfad8779751f66762829bf79e01566abcc1c263be8bd29a7aca500006a2fb5e1cec6bfb913b6b632284fa91588055ac2d5b81fcbfff3991f5fb62d7da4d4b5b3f207c99f0c478ce0cc601fbe3167587bf4accd115f694d7688bed7aa296612924ba67518783e7ce65512d3cff7f68bfebbc726b68ed61f4b187066be165fd9a67d564830dece42d70c17de7ffa4679262ab6661cc88c8222e427452e4f055d11670335948da798f962309f71f208ab01d89cba304499fc3f26cb55ff35153fd174b4c5cf8f4ef6702f9d1e3696efc5f48dee1523afee3e78196edc4969cdbdf3acc8fb788759d82279927803e79098436417696201b388cf38fd813bdc6e3fd7ff8ff7318ef2b89147341e4a2bd5dbc901014afc7ae5c0b0f2c4d1f13951c9e719ef95538644c8838f9e2c96a262b07d328d985dca1621e94758cafadc005de24bf8ebcba51c046ee6773e8ccd63cb2753d2ef1f528976413a69c46d5bef5ffa4c1a161fbdac48193ffb09676bf7a58f9045d3c00a149457e1bbbda2a631fcf78ffea903cb714cd73a72d91ba626499bd12011f65e10edb872ad328ec3fbf196a6051e26b4a2790eb5ee921a9f0d97405c726211b1ab14bc8181e954edb8ba0052bf9b6c93159e78af1162e162893a33c54e5b46c31f6a112d34ebebb0b70082b37e68499e7dd8d1bc041818032b7b78444646eaf34294e4757dd7e7fc7a56a31717cb8bd045c76534c6bbe983d8073f0e5faf11fa101e92d69e3e4e1c0dd8042ce81656c15554dc59e9f19039c7b93dfd6283c478d5dd33c50c26e9835017351a3c7ab83a97462e0000c29d425fc062452248d9942bee6f2aa21ebe4f7e61e2491518bf08cefc12ce5f30326233c8db5692a623fc36606dd115f3efd02c74b0a8266596b1dcf07a2daae70370f7f71ee13f5984ffeea9a5953278bbed07ebf83ca0fa21349be7443aefef47e821df80257aa31949b001daeb3b8c21dcc773f6269a54735ac177c0f5a25997a41e51e71e00316471360e38aaf37f5712fb53246d87b5a9394bbe12915c7433cb5cbf1d5df73afc5aa850b6f563a7ecc5c312b0e9214bfc311e93f3ceb82be736d5e6f8796b203166faa46ba73c9f010d23c0a51d6224319e8e0a29d63a3bf6c281049712190c8dd560638c52ec5568586351a706aafe3071dfd19039ccbdeeaf16e6e393bb8147693be5181bfd2a5a518b3ee913542c7b51bd8ff1f8a10cdefc32931329e376fe31e0aa44efae05350d5407db13b93dd468b18ea2e00e3d3acc9c532298964b48bdcb3639bd97dad28eaadd074f60ec3455265e794db23bd4af4bfcd09d215da8df1869ef7b167f768867cb6643008eb5d829980051b68ce4199254c9e8dc134b7a4ba35d775701ddfaa6d711a09a42ba0c3060365d40d00c82931df1f19f0836132caf8f2b454cf460929b80c162bd9faf50d7a2ccaf39008b8cd218f4fa4222b06f26614fab6e67a82cd8ec44fa83c48f488447d20b5b6c6575c3c7e833a2106f13c6862966b1f236303b31b8399e12381135fe10c9c89ed1cbc893231949e27b77a347ac5dab81d0b296cb82b43edd6987c5194dd547af8696fb84f52ebbd3ad577405f2fa0239deef0c4ae96891fbf636608cd97094158947559fb7edcd743b884b0f7d358651dae958661de64e7ef7478afab23d3a4cf1163fe7d5b93bd55438f0fa541261627d6f91ad828cbf5978c4499c60b7edae46bcc318d3afb21a2eeaf05fa054b327cd03d2a38c1c79d6db236d682ed1ffd2b7b4983b595678831899b27e06040a2fa0e5e3349972486c52fbf553b21dd1deb0a7a8cda7b1497ed8a4360152b5873b4ab2e62f9f4a81b1cceb936a964fb6a459287cb1ca68863666d23f5600c81d7e858382e9eb6784c5cfebc45cb747450fe516385e47fde0404ba4cab86d0bfc193c60a2be08b86c500968249c1628fb279b0f10a3504ba9045f175253cd1581275e89083c9b461d8f8b13aea5b7a524d6e65e8da949fc3021be2b9d6cda143e52734c849a252af0268b950f6793233a23aa627ad69f0aeef892a8a528ecf3ab33ed7add01fcad843f5bde4f81fc485a376b477af3ede39a3f247280bd75f76c9c9887e6e3c7606adc84562740b84225830f2c8536321a06b27bde53b555f9fe37a13aaa461bafe418451bea3dd2ed0f6560e284cb65a8a04d74262f9f263516328d865b14f576ec5caeeeb623cd4778c5bd6819977a2d72379d71ecce45e1064459248aa8161f54b9e4338e6eb6bf7d50f9bf9471a22df0111ad10f64606ada5eda8ab3322d9ae07df8c78d937558c91d8a3eedc3a4cc8d640abf9dd1989cf881fb8d8d840052a315a066aedf72f69c7e003d95700df7be50b20bfa763a945cfdd91f151a585eced132fd2fff529dbd5207ed7716e5f90db56bba67b1a45a8ef1504ff1a71a1b9cde54a09eb34c47e7a1f86612eed024b5668fb62acbeeafba53d5fe6be073f8d9f2d33c894ba67215771e4a74a73b82f1a5518a841f3c387f46d7c877e910537287a6e6ee97462d938f47f5741f348de92b8bba5cebc3ec02754a3e73f6796e16dcd47aca1d27e664fdd9e2ecb92534028a0a8c844767266ef45f55adce5af918a29d239b56e2160793fc30eb776a573df03d584ce214a908c9538373098821442a004ded8b9c3a619941d8c1dd6bdd29b8d8fcecfa0b567107899b09807d638cfa977d35c6a51607b6a9fcbedbf72d9429f3fb2a2e44761dae71d0f1de86923a48e958fa79bf10a2b000b934b08ce16d7f76fc3f45d511f2d9f980019eda0d4f9894db3bc5cd5104b6da5f3a453ab19105a413cb68e6956751d00534552e4717a145062a9339ee960146ff1e01238900d970e54128c33030e40c3b35593ac380163fe5798d23a3735c38205cbacae8f4f2f94d7175e342490fd3d524783f2c1819d59de93ee731efb51f30229b9091a5139cb18ce0b46ebaf4685b0f477d4457d0d39a81c64709d15fe4a3cf3e0dfe23325a987389c2ed52827c9bbdab434486fe454b26560490bc52951a4866bee274d0f99c5e8b3a2253866949a646301de36214291bdf23ad7e74a0bd3bb5f310903fba12d030f357bcc4c8dc33b0a4765292feeaa88a249988662434a84ba3582e64b95105eab50f6c54ce8ff068f3d41ad01803b6da220984321aa77c59c4b1a745d0ee3b212ed0abd3313fa243786a89c320ba2a3ef96f54f7f922c009dd050a1e7e695e8c66233c11f1ae992c7abb2baf00f32e55bb8dc28a8bf17524bd7e72f7c2dab116e09b084a9b7dc7cba01e253c4dfd87384a7a8530d7c571fab4180cb1b85d6bca752cbe2fe476b74bf860562ebf365ae2ea2340054391d45bd660060246f7c9e4160841dc804ddba681ad39e85a9fcb83d25d8cafc903f6f4686bafa3f73021a31af436867c6764a228357226cd1ba3fe1f3158246e9e0c68f56008341be4b3aff6b64885e6191ce894dfdd057729db8e49521581e0d21afcf94c6f6a8ca0b601e392b8a9e8d92f29c1cf221e40c36a829ddd6eedafdc3d9c1d72a48073f46183fe6d235d87550a19c47c7c4fa6eb31429f2bd59b81d345d77662c8c3040b1509c76b879622cfdd22028d504fe2ac020b07023fad48a0ed7424b0cad815334a88e09e1a6850f89f5c4c8a218d7544075281ca36fc4986603c25b929a66ca7e2be0bbf476fda31f7e1d5b54cad1db22212055c84cef5a460f5a6054142dd7e19d1659dde261eeb05483f0f825e9874f8686c9279f499d92a1761e1b8710bddc0a6ad1bac743aee316b24518698f7c2497f2dae14ea58d4ff3b03a9451919872d4752856475598e70cf2556b95f97c4849b07edbcee1ede729a4bee3ef722bae090721af54d34a549e849c32024ecf0a5a7f16079368386f10d6edb9e4218f24a9d79b4c3a0d8d9faa8102eee824e6cf0ea1e6b85ccffbf0d8e7327542d6b6f1b928171b4e8071239b47bdef3177cc54c6d0e653920b8efc3284026488717660529b91e3caddbc8e05bc5857ba753bed6fd07aab0709fd5a5054ca66e0969de7458ad27c13ad555265ed0ead6197fd5c29afff39570628173872e66eaaf3d2c56d05d7653f33443a00e32b3ee83fc5c358e283123cb02578f89139843f65442c8a6ac3a9fd6af807ce5a123c11547ebfab2aea6d043e03bf25ab22b2529f0179dfb4d70ebaea63cf228c29aca8638b34daa69338c8610124e5c29e8796e011338d27a215da77336065677806e8346b55a283e862cbf8ec8aa8a4be7b241d4702dc123fcd5ac68afa96e9d6acc5874e117bd7b456e7466ad49ce3a43946b97b70d917a576a8774adcb8fc0409db701811e12bb498f5fa243eef5841d19a4ac7e7297163e1c0aa87c2de6c776be6cdca6b5e7ca4dce73fecd7982deb503719da1eba8f70a25c08e9c927624c18a77841b5412193f4781f088cd6bfe61bb8c134593ae2db9e6edb8e5fec97c224e513e54ee2225de13406769111735d888a714afbf8a7c1d2156ceb388274ef0c731586f3ae56e8b3082b6c6fccc377786737621c5a0ac3c9ab5972c52a9e3e30dac46d2a559a7ef40ad80c1cb7e3c65bc762c90e976bab9b833561e099a02dd869ef096880210f89a6825649e3bff69890776662c88ddeadd67c95212b863d82ef64fb08876cc0f42890ea64a72a7cc681ed36fa2c13df479c27ce676244083eb7ff66a6396e18d253f365a23c5a6bef731d5156cc79013a2ba23ce0f6fd3fa8134f48d22e22f8696a4780e973fb5547bcd8789ea515f59e77b1933dc77df0f963fe48ad759a28be149d48c6cf31c18207acdda019c4975d59a9452146df87855666aa19dda0a3cf59a189b159fb45defb1ffa8910412f0d76cb7d59a219b80ecba7d1c4a8394387d53f05a6723c4810f33333bba13c466b416b20bbf3f4ef44159ca669c12fa1b4da8afcfe2da2a878520dfb39fbb62d7992324e9c8c4f7e3e1fa07f19c405f35450cc81be35082aa37d56439765230bb740ba7c3af9c208dc753369ba4edca4180835e063ea6da4ae66c8f1a1e34002423f2b7504072ea0124a2d1255f838a48340688fc39d7cb7f5193bfe00cf2b88b92ad6e511b3eb5873c9db61f2d8317e6c0c2936009d9a8344d0462c3e433ec9fbec2a18a4dd3b613091635009d7e8e0c40b5a019d42218d211df33ab76b602a76768a63442a01a83a4677572c9f823883630723f2fa5c92cb56a379df6af06ac25d3833c8a0cd09cae0cdcf5ff76aafa442b6361b38026403126baab7e50cacf74e9cc95857cd3a20c51b6b5269194dc2a37708435e1c7c2883f59a4ff322ef33db4c2e1983839394d2a967239d29af9dc09aa9a9235e7d859da7750662da511311982067591539662e6e21f92c114621d100b7d7d1944a333c3e4c6911f54adfd74322f95f581a0f09c3b5cac0655a84c43db8d33f5a02c39508651a50490623619991f35d5282f1e4bfb6582541bdb29e89fae20b1f850eca2c0766e4273eaba07a63740dbc52492794ce6777693e4c833c2ccaabd3fc577ebdb157e9b692855ab6fb7a66b83348b852ab7734903cca2a9b43351b8f91d81c7bb43fa2271979d5b9493d62750c169245df80c99055ef44cd89792b6d0863d9649ce1c98a710ea80d110fd018680d13b5d148bb797b876020e265ff1b70a7e5c32e6633bbc3d7b2daa6b324ade320df2514fa1df26b79876ce48b767bf41e428ba12b3b79399be66cbf5ef8f7c1748336aa3baaec591f84efd098f2ceb3f3de25c91c0b67f9b56752ceb9f1b829748242b5c081b57b54b39e1590a79c3f6f37f19a917787cb86352a611b09834dcac2c8aefa113535f975f1ea150bee7236839c6ab09595dd93313d593425f1087fb01f620ce8d7b385e56f0644b0a5ee9d784131984a75ae17f15f609b7eb3dec37acbcc547a0a946d01c7a0c95a5c46d70eef64bb8df7a7ddc7f98847ddcdc043b938b7298105970388dd175821c7738e5708d132d2b9209201e783c7c6a4a86d1cf41008742958c5320f3e13be84d350589a4a73c3eaf7a3a05f5f8a9c6495c0e708d24a45e1a5ecc85177d7653638c151281665c26a3fee717704ee83882120fc81d373039be67f17a0fbc669a8bd58949e09a228623ef0eb44c4e74f20a9a037aef91b1392e68236c648321bd8dd0232aae27786d24f18e154547393e13b79ae777c1ceae34757939d77b54a9588814d66c6c9782ea39ed2652ce536f513fcf67d2e649d02a75cd8bcd9223e0184956ef6f3a08ee4fa6fac06a9aa197f57db6fc38298a3cba69d767ee98398d5a4b63068adbe7578730e67d78596c812d218aa686bf61cca8725e78a7c059041403dbf6a6d5273f7a1e0285f29db15285a000bb884d4d2af5daf878f24f0741d620cc7391043d58288c5885f4a44df6bd21af9155b55c4d564ee734f14dfc04913f89965e489a047718931911443d2d317c5a78ab1381e3931475090f54957d283a076fe6f83e291b377a953d86238a970febb66c73095cec787755bd522cc1bfb219711be24174ffe1cf72e7b0860102d42dcd79b701c826bf4cb539aef5848468fb12e26046e7d89f853cde3d26c1282d326646ca0b5bd2906fa22e328237980c7f905b8fa6250599f64cb23537c6612b09f009cc75ecc1b61ef48ec9cb50a5e6284970ae0f5629adf417997efc43ba767a9a5b8b415a00c75de99a5ff517c1ce5e844fc9d4d7b7892afa73fc31b2449af05a0bff7232fcd8b534942cc19e8171167af0a3cba42853446491faa41c63b3592c9561144caa5f7ad99002526dae0a2d564bedb57ba590d28f1798252c21f968ceb1e2b78aed6aaee49bf80a6e8fa1239cd934bc62b7124d958cb4c7835e2eaffd2ad8151882ed035ffa8462424dc54bcd5967d3ccc5dfc099f6b3767596437c6d98b72c26ce08903b2e352d327de023cdd649448dac8fa9f6a8fb03e829349aa10e318bd4028435f6a86940ebf7ded3c74c687f3e8e8a0b6ea5423c7a3cc171b4c9ae885a9f17453b93458988bbd77866499054d6e32ab6e7644b81f9cc0c0126bcc9183c2b5440ed7c3a842a55fc695eff3edec2e4cc1f7e3a589b0a0eb25843c12a477da39488837c72d0d730d0c29d270ec2cb03fca7ba33fb2d7eec4061386b72598d5503ec333a0d17856a90c5196fd04e9943e7dc23a63eeb6dc3031e5ae10a53630487fb316e82887cc1b85fe3b70bec653646dc3d17643f2d0a1f5652a4c8bd56a12f7db06bfcc19f24d659accae847de445765f5916a8b84790a05028edb4e392f0ec4209aba663e2d9e9d8e83e09136e079bd3e2d1b1a45b40f31c503ecb86ea715b2a6fe4e3d2a81459e94f1d275abc018a0d04ad1b615fe6653723a3694199036ebf45763f1a558a2557b935a00602e4e05de12bcdc6965c61bb923f67737595028bb95471f2235a2fe326174e32b821fcd4e6499468a0b87695aa1d92a502f5fc5c8f01affd5c8b491e3666cea40a7fdd4a688a8bc221d7728150dc47e51a2c2400ac0aae8a530525eb30d6d2fd4d5c3e0dfd86bfe4a7c6724e8556c896da8cc390e7fec566b16472f2df4f4b21fbdd994c88e21c9aaaee5873ad6c487d62bb269b37cc0a8c2a37b380b10ea7f8d5c6786b7cb76a1d08985573a2f34b244cc4f727583daef90bed18cf15deabae77c6fa0d11d744f37052a352e3cabd6081759f09b33b80f736b36f48f82d052d0639eee4a3492d8bbf415c5165155da37cad39af04dcbf3c340acbdf4712f2c00ea2066907fae825e1c1f5723dba12cc96180553222293be2c39c427afb810d27bc5236f34e93b3341c333d0ec1010ce802c009cf285bfadc19749ec19e35ec26721b32011acddac678f1822197833252fddfb702b9ce2bc4e47954b5cc126a3300fceb7c9816855597db4b7c0eed620aba2285920b1848656246b6468bcf708e1ac87f39b87260b16dcc12ba077bf98ad4183dd9a19a7f7c724be13170007908ea777fafe30821a02f5a7cb3a419c174c6ac09d31154ebb9fa6b81e31a66911008ba60df2fa62316d4b72492b7a9234af697764a9b9d76d3806f6188944cc650db3f45e01f68cb224cceacf59de0fb09cd332b3f6b2b767cf8c17f93484f30c675b1a2d8dc7c1c2c1c35bfc7c7177fb3a5a53f6a863959a80298afaaf8ab72035bf50976783d7fca33369bb6f9511de6c49d9556a666be58e9d8b33c3abe900db5dfd12bcf6ee5618da3da12bc5938d68023751f675903c83b41d9caf30986b453e99db44c6bf1b4ff66e8e25a71869a587e8b649ec7a470339b94cc52230bbf42225c00a936a0b9102757da981c2450f35718fc61038025ea87ab80bd24482292b77109447c32c88e744702a7e8411646af1d1c712d734558883ce4be43c9b0dab63b04265751552de4471f7bd7d37e21f4b28be43c6c8cdcfaf0ba6ed8e31930e50ee674409c8ed4faee77cf347158107004c7d791122b09e731c33045880af046fb02aeb9ec3290b57f502a7dfe8fa94d3f621f1b411f7cd29f1cf04fce461371d95f33fcdd122b50f71822d0c9043258e42f13c992862f0b28c6c1f84ea93f36c3d8fdb93bf7083cfa26df5ddec76332254f4d72f7d6a3a84bdb6e20048e7fb4e2c71876b146bbc37d2827cb17b626607f46369ca8d0d654c9f5aa17d3916dbb5843234ae94d2b1b112c417a4e78b09ab25e09b74b7c28c359e31a08cc42b09e64cf59b2625428007d593936609790e1ef7847304ae3519d9cecb353b4bee8e0a89fe54c2b337eb74e9062420ca113914d5013484980426e0cdba81cb9bdbb4033703cb8c2a77f0532b500cf08fffa79fa57dde37a7916715a38bbc370de0c2b7d577fb203f11e3c9ef819f30dbd79e0e18c543b62ae25ec5e9dfca6dad1c60c021fc8a6cb135e08af975adb0eb9c837cfa10d2486f4c4040fb9cbc844d16b5c148ea847b3b15cb301b5a5093472dc7b958e614078bf862d9ded94edc8f986af65b5708b44f1fd069b82b94ccafaf75e2968598201c114f120c07c5b69ed7d2da8af768b63fb0e8aceb166200ff1b9b94809ca958d7bbc6162833a860a50bdb5c7c6ff2bae978631dbc9823bce478fb2bc556f5e12ca6445057a2ad072aa7a6b50d7ebb7934f13e81748b10999be4231a6afd990efcbfed45af3262e1c4355a00b99cfb90d187ed587475a5058f2aed349367de3de2a1932b5e61b25da876666794d52dcd22865127cf007f0b1bce22faf30880b3841c860a31bf281439d640f563426e997542147887cfe8fb7877d324209256de83918272ae7a3d29c110a9b3bcb45fc0f685be3eab04f455fd38107127c2c180088c6a71b2503f709a9124e4fa6e98b176c257c7549403c56051e2259f27edb8ebd6bc4850478d34bfa68608b1c114cf7efa867588f8cfe138e159d54b678027dd6b14bbb38380f16073a2b128cd6bce5ee01d55065aeeaf6cf6cae4d9c05c7491211e6143c0afdd03a79e2085f986973fcb33e47a1ff42896c2dcbfa046d500d28c93b587367c1718d8fa37fa69678af732af673e01f767db413e50619e81524ee872b61b0318a732b35e14e7673bc944dbc615b7ec10d2daa8aa2b9be82e67104c0678d627e7a6839ffc457f786fe216705898f3d6acf602cc6c4ffdb476eafd1a163afa505aeb92705aff8a4a8ce82f431c97b61569e526b609626ae69d66befb28e1b591978109b37ce9b5dbddb16c886ae88dd8f26833f55b54f6a3f7ac7d0f8e9abbaf55e7d5dbdd5f91ea3685950703cb12ae01b207002303569589c5cde440f2a8e3ceff7e47e188835fe95226707aaf41f64bb1c06bb29c47e2cd874faf7b01585f577779b6b038fa793db800c64ea47ab5f494b7da804a2c38bce5236935609c466f3e949e26aeaa7a5e2527e1e2d28e022d9908fcb349f7a76c229f0933293a4d0e1359c201872dc972c0c30b478ebd1e6846bb6d9dec26ea9822ea95dd4c90f6a78ac5ddc0ea914f7bea0979117efb76d0c8c30dadf8b6921abf5087c4d21b8454d8a3968a32e112a033c5adf8510d3ed9dac98864e3e15f8856aceff3e1e4b389181c28e8fb7866a175e6f07bee1c940946bc9f83efed97404d870f3c70ca49dbc6dc543e1b1ec492237104a27df82a7a4d6c9267fcba258b6534bfd0ac27a1e4c31f60163667cd66b57792af75d63fc3c42fd9ca3cab2c6ac332d99e727c727b4795edf11458a90570ca47f80fba3ccf36516f3c894b832f7d26a6c5da826becd96c4503c080bd774f8924f4ce9649218b5aaf7596f1ccfa6ef04e93eecc81d75e0e89a1efaebc3bd83799b0233f69360f6346cd9820503df0ef3acce8d75343abbe9bc44b6ff8642f147f019bb5a13489d3d267b9e1c5d3c5c7124e14653468bf74aaa43b4f67f9d993fa0e8ea38fb30b02b1081e23c5b7f89b883bf2ece4d93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
