<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e477770ee47bf0bd30cc567992bb12a14c6795b17ee11ede1aff3209d6a0a92cee311a7a99f8d5bbc54d470de8bf42966899341f550fc9efedad694842cf7f838045dc11c2987fc0b16238529cc7c14b77aa87f9e0f7755cfcf74f5f3e4058deb09d11238551e0ecfcaf7b04e1ca23e8a8bd5c9ab95d0ddb821b57cd076dd3372413517c67686536cf35d3f60449cf57a625b80dd394eaa0376c52544b1e0d43daddba32a34163ba853cbf6508ca043f4069bebfa5e5da2b02b615956e807fe3fecac41cb16c91d17bb40362c2e1923b762b3217a889937c73589ebbe2e3901d4e359ffec40ecfd3c471bf6d0034f8681304207b05f8ed0766d0ff546d9970f845329b004a69aff98d3aba21c73c3d97f5d2716b68a804dd8d6c182d314851b5b2a2944a46d6fece7334f1c0422addaf7213f31e61c6bf67bd103893b3a92620d7b3135619a9835213336cc570d0bb48e2a6c120a59dbb7c02b1c19a27c8839e8b063275e23f5e61235869dbca059108c0a0b8529c970ccf429236141376b49ddcbc9da208ac5963d0418029eb6dc8b3ea6538b9aa090577be4b5f4195ae2a8bec412cf4ecd4a8b7561971b8b8ee650c6c37ddc2012aff43aa273c0530a6b83f5b39dabe57c8c4e5eca373e3cbf65a385ca55ae7745c5a23f9bd5544ad14e9c988df1509fb14d9588792ebf0b7d3224c1afe00bf1fcfb0ba6ace4ead72a6dd11163fc56935efe82d719078f2105f1c358fed20b986eb7a9f15c5cbc03436238efcfb6ae99755c4e7b4dcabef0141ada7ca1f826d5138dc2e778a0f073798c3392d0ced021ef05fc3f58becb70859f5d288347ef534767d4a143f0edee8096e287ac160805f6d24a3dbd088b6eab7733a673f8eee9318ae8cffc2a35ce6fc0bbbe497b996078598ef04178b889bdd7c844c98f68c87e46664d2e4ccb5282d69910a37871c4ff2e84fe57b5684f738d663ca8485336edb64441b9a9976fa1d26e4a69fc402b0e4ca3c3110d2dc453718e223cbff4219ae1c8ac279f21333706762e94dee217567c406608c8b5ca283dc1df7217b1ff4a9a3b448b70edf6038c88cbcf854bac63b1d8c363e833f5c105b6a19ca86221c17ac5792480aef19b98e0f2055e4b4b0f28a5bb3f3b9cf625e55aba487f98cb37e84c823763426eee3be98d15126ff1b839b42a7c22fdb7b81e65c49c5596c1471c349a818356c2dab1bae0c082feb5b85c1dc8788f094165a990b76bfd7b134891ee0589cf32266fc2050a032067e44ae0ba23099aeea3417e401fa9518d46f7998282249f5af1d5ae804e457e8acf5a079d804dd68a98a469b62d1c990f4341a5ebf7db8de79d2ae3f560bf149d8db3b1bd55cecaa7d6a968a165bfb9573860e4966bf063376e17a305a82775b7c6bbc4e723f4aa54a306887ce1e29e1d796e846678293fd0a7d98c0b6a176c3750f7ba5eea859d7402f88fc30de5a7e2023751c2b9a662e694de245752fd2a9b68c735a208c367394b616f53246c74299053fbe64179fd104a1d75e224784091687f0e8c5f229928174ff44a565628551ea8a09def3328dce54591d52a3cc8e1dd11fd3f7853a311c2497371c891c49feff29d3153f4be7cf8e2f337ed0b7568297d74255c60f58164f62b634df4ab504cc6cf4db99cc0b2fa6c65929ff94e7a61c34cab482ad72777d8c1d0682fecbe5786ff1a5a3067dc9fe5f39ed44396d647407047a46e4864af9fa9431de8f02ad1ac67ec141800f272cc8d7d54b9dc557da9c22ca103c0b4b52732fb85390aa13ea5d3e05235612208a77c2292ea023005896ab7899edafa88c7ed66a7afcde1e104edab080e38f3c8f294fa900d78a24e69511dab0c7b2ad27b9ac5b19e9a7ee706bb30d3d2611ff983abd73e22097497dc1454afbae8508df36f87f1a62ef93a7ce254508126ba299b443936681f7b048390467fcbc201a330fc316b196ef0e467bd2de947fb7b07ad3de8bd21a8507bbd26af113c3483803e321e144c335767f561e9697a2adc7ff8f47d94d016f798d1bf327e0179a85ea425158288694495dd532000ff6905b86ba240c1d2792e5bde16606b4241ca988d85ae27552a2bbdb55a53307a4ca6740a8f9784e71635074318bf9110b9055f5e8fc2c5fb2dc482e4d48e8d997d66b2257fce66213c3c84bafe8488e60fcfbcddff8f5c2b4f562beff5d5443023b6176c2163e068313e05840f856a1106cac071188ee2d4d7d6b864d09d9fbb3669d50f1057ec01e6ed02f02dc7f6e912287555bf2d1ae8b0f62c5498212829cc4b981eae04eb71a6d6fa8547daa0090f4aa51c5c82d20b62c020ede67cd24b2ceeed267c25a846c7afce89932c02bc051f9e1b9e0910cdc4c518d5a58d0de2a0f7a090c18d439b12904cf4b3845f422c67c15187f32abc2c14697aa7e0a341c9c2c0c3f78698718c44d8826960ecca2865886999b1d4f3379614dff1ccfc19929b6ec05142d4f3265c87af4f096d19c3371952b12c458c33abe9891689f933b51e0a4268f1a98d0f252b0e6bd749cda56e9e7222eded789807dd0f093b05da6c525d5c9750be075c822a8bb916d4676bf0262758225025777ddb5cc6a5f51e0996820f86ea7bd2dbe03019fde15c210326154acd25cdf080cb954b62ea20bc723509dc319392d98537878193dba3d627004401422eaa799ce0e665855dbbf0050463e69dd2927b08bbd67333d9c197316248306b649fb1868d14c7ab7e5ddd8dddbdd438acaf143d5581c42f7f29b05ae5c966481c6ababf9ce3ccf079ada067bcfb3818108a02579252c9f198e926a676ff12fb2b321017e0fb7c8bd04abd027b6ab7c48de40fa1cfb281290693d043f4181177c7135731723e4f2a3851bdf455b91a1f4377db637a00975ad29544e708a7fdad1c5f75e46064cbfbd0e7f44b956598568b3e8501bb91d3de20edab0b1b89a2c52afccc984cd9a79e79c92cbd67ea15d70b2ebc3c2eaa62463fe0d280a9008abf2b0e0c202dee499d609cded142581040261197bfc77ba5bfe6aaf2e6467f193e1373641266e8d912b1f6eda7c6ffbe273109389627400e1829fbb7dc1118b7d66a3cfe93ba14a710c5461c2fc03e5d638ead807735712106cb0ebcbe7656db2e827fe32ad66692499a97a395127631df5ddbf3cf5899d683759e23e5b67e90848e4170e0474b1e1cedac34c37f540c77d0b97099020d8be90390144b54afbf5a1da6d21322e5b09bec15061483cddca2be66f71b13874fe6bc17da34df9e164f1aac699ee4542b26b4936494bc3bf5ac64586106c315bf5fc5be992809541fb718ec31745787e008624b6d4482cd9b0d69f6fd15c02d9152d2f5e29f9f66a4ad9401c3f222ac6c8aef7683017bfccf2d738155d085111d2d59b7737be30b92a0d23b31658d2d558a886c7dc128189c62cebf1d1298a595c4b91ef0105ab48bce41cf8edf774069263acdfb7c624e97b094e83b8b56c98c00fed785b1af8e44c417be5ad4f058eb7237637768d926e64bd499f6369e9afc0c71cdc2b823049b98ccf600583d2c6d709007e8499df003d10ae7abf6faaa70b6c4ed5d1b1bd0a852d89855bf3a1314f381363824960cfb5611110909be2043651650f8fb01b5d5d866dcddb3609d39beb167bb48f301ad29fe23f302b22e70c50d27a2e2dedd468294733732ccf2fb17315aecdd6a7d8528c834616961085aaf475bbf9aaf58d5b0915f52506120e5c2d67e141e88c3d5d738c52d2ff92be07ebd5fa8c9bc3ea9adb3b22363d816a6df59aef7d9b8fa442c9137dfc515e81825d0809a5de149040b59687f6ae107fabbaf2570c2ca9215db8c3d34538d5c03084e0c5ccd308642408987eb86988174daab84fa9038480e440763cbb77a5e528b6e6143894077d6bb87f6237e66c2f5ccb32158e26e6302b99092b8e84e322c0f6e1a244af81268a496ef21bbc8b80b93eef4559b339f5708fc21808e278befef225e9472cb61d70e51463db113cf091da93b780d533ecfc2951ed008564117367b388925d123164960c1238a6ebfff7afc40ee282eb50d8b001b081f2a7c7d129fecd898cc41df41fa0365ecf2b724ec705c3cd23c349ca6fccf3b161a4f284327bd2df689d3371b54271bf2dba6f7afa6b4d58fadcac786938487d009d705debbea333ff5219f64cebeae7574b13d4a7e679700a284d8bc375ea52a71c9aa6f4b4240d5da7b6ebb296a89e086d4e31414ac13aad5e59c07cdaf7ca209f6f9acaa33f41f55b1a45c93c61e221bddfef7e18e847e082ea8807ac03f49a1679eb50fedd164eae863a2175c479407ce209faba98171451a4a3daaf7387c9a1cd25d42853355a3873b7f3611f4dd68d5ce3be4dee4371ae92b693164d8aea87794337e29f681bd9c1c45e9ed9c997badc59107046bf445f90c07459030709b85550731aed659913050cc073acfde2ecf1726f4226f2bff67994ea338b7fdd6714270d0928b36df9db76b504e534ff7bd8ee83640a8d51ca10d681ee569a5f00f67c6160c34a2eb29e03bc5f768af64394ff58fb025e09208ede1927ce26253b12ef9c17b99f95f190cb608330a3bddd94aac228e9d994186645a2c23bb7370f84aae5d89451244853d1467756918122246eba803442e68475f64fb9839c3e2f96aeafbf553f06cb73bc3b453f545526236cdd4ec32aeeccae661caf5ebc803c7d1e7349f7616f72f9ffc85d2bd4830a6fe627c3c90d7245431141ffb85f6c09936116741f8ceb6107cb4ea338f19064d92bdd5bf8c0446dda5734af172dffb272b2406c4daa0cb828f371ad86f7e555a1365d7111386ed309b20e5f3e5e2c9359c3551866ba48f9cf4125d3bac4693fc6d4482e28f80f3dc07f77a543e4df1d84ea22f8f53964e5930e2bbbeb7f190987a5fc6f1ae154ddb8f6bba5c8ec7b593bf1a7201a1489bd74d5846a8eb7e58b171ba698b54e8a1debfa588527ed6ecd64d6641672099499f3a55b71cbbf5bcc57a4ab2503a7700007bcde91527e5c6b7150c9265e0abb765b8ede33025f59ea95aaec18528ccdc394c33eef947ec09d372a46a1098391e8f895cbb1a42d4563d7668d3d857dfdd5e70481bdf2c0800e6a284884161e7be6905fd89dd37ad54ca7cc030e4b45635889562b9656a35b9cd2f7839b81478ed8841543564794be99e538764b8a5b2f7d23de9b74342147c0fd181989414c5412fa39834e27e4f444b00196939d4604af58e3e3cd24a3e8e79c8b559f9e3b6f465e33988b1feac37ebc750d989c55b2c646d9ae3a982d8fb6e7be610eb0e51d25502a1a6d6f5de66c7cc7a2f0e1bc840bcf6350050e4b4a766c69fbb7b70186171ed68612a7397c6f6b8bdeb2c95c35323377327c6cddaea5fa2a38ec9af4a50bfa665c4e6859a50055c7772d12110f9adedf4b633a567200877749f7db9eb3aa9f94dd5a42baeba14dc4ab0afb9985c7c011b85df546871c55d790f84f31756a36c7ca7400a5eee46ef3d9690500c125c36ab96b0f076b4b3f0a21f67ab982409f75619e1d33ac3f84b0193bc21fdd7f448be6513e6e7635141d8b144201db4b33da62f8b7e00b9e50025da05f22b9c4bb291c24fa09e701d50ff132c33dc8877d8d22344eeda4dd91f94b36b8c5b4f78bc52e3528fdd02f42afaa0473bbbf7e61b773f686dedb080337223c0ca2c5bad7a81dc5e54db43bbfb060e6cda17eb8d67263712714b08ae1fdcea5aad22316996c70c62733c38f62a66523f368077357f90bffad1d62d952fffe5e4d1fd2feebb7e1342d28a187144944bbd4d12deaea73c565226e93b97080b675c92bc271b7f1cd079aaa068e72895462d1dbcdec1cb94afd8d32545c6dd962279d502b53c2a5d5b36564b2715e4d4abe1f9042b8e7102155f08214e981206b36f347cf8f85d072c112a55caaf2757a8a0d35400d81e5220cb4e7f7eca750ecfeddf3aa2d3406f2a593a6e30caed9b54aace23cb7bebf128acf563f76702144cc4814cc01abff9ab9bba9ba48dc1e37a7bf2efd7824c62408c74ee7e1adb910d280846b0e2cd4590a9c6beaad9dce092b007ca995ce4d403fd75d2de675b1ca669749ba65e0a0fc5db9636f3fa9e6be8fb92fc642bced18a27fb430a294c3386e045f3d1393d9525f1212d5a53fb6f9522b7bf2dce5a2ba9aa492e46e267986e37cb49e0bffdc772ddbaf4dd52bc942b0306b160bb5df28730233a57a290da891c3bdf6c122c6fd697b97f9bd3d70da080c8dc24ebf51370a6a70a9e63cbab686230bc21cf1b59cfc3d5f4d7e36059596c2221c4e053e884aaafd536a33feb9d789cebed4cb4026ce3645cd120de742a1418a27fccf5e39705ad1bed8f911e6af828d4079b7cfd38d94e89f433c26005486cb408388208dcac2daa0bb3346ccadf7666dc84b57f0c56c7d0bea8bcc017681ffa1ef40ab2f4174c2ac7d60cf2380c06294513cac80c0af04f253bc3bb7f69659a478aa916816a856e45dd3f54d2a9917e4219e50805b0349643d22a27812f0874e5e3b1a43420a6586f00677120e7dc18653441f1c4bee66fe2419811d3daaf99df8c35c14d715ac0538ef5738b90fab3b01dd75a570177c8a8712e4900b46145e3d39309b027fab2ee884543107e074f12073018b0062efcd07796dc4b961af09a0460009c5d7d48bb5663ab32bd86fb3cad4ba38fe64aa809e1f3de848fbe8432275d98df8bf111052c6245664f257fc31d657c8e4904df6006ac840e69b2a7a225510a6eed552a13f99fef904cec7408f99513b31124b73f94a6437240788f42dea947b6e8d11a8af42e6c8827f8563f012f52dd283269bf48282e7ff430f2181d8ba0467468f61155170d10814a6e3b41abb960c2fc89ba25f5d4ef252e67047a7195736a9fdb193ea02749c0d7565bb127a6ebed292c104e4686017df0f5d8a76e5b40c878f480099be897433c3ad0d9f4779ee8798b65b2a3eb0bac124b2249959f9812c4a8260da295b29a605c8cdac996bb2b613a1ece6e2c64d040056ad1e6a5fdbc7b662de840ecb3858b4c22e976c71ae798e5d585a03da203176b1615feeb392ebb1cc3ae31cf4db16d3d9938c3600395e1cce9b1b75ff9b910e30c1925b9cf428449c113323bc5f7e4d6454c538a3a258b89046ad487802585c9a8f8221c0af4eba131f86ff878d5cdbf831eb568d7f0b85ae56b3cd95aaaaee36eae02dc36657fd7662f20825b33f78fca406f1e532088e5d334eebc54c397d61efeac84be696bb03a8767bcb597fe82e866c78d41a4a83d0cea2a8249a00d710620c4b2f68daeb80e7be97c5bb26d557e0fd17ec4988ba17cfdb53bff005ac724c23bfaf0a55f0a38de0ae26bbae1679d99604a6c496bbdaa371a59ddc8caf485f0f7735bfbf166a96befb622d71202643d2b83a617e484e742f174eb90e41ccf8d49afde5d7730556d662edf766a885e1528e7c774013c76ce44aead6115238a7a0ee90dd1096e55e231f003cc6678ebe97e0a7e3b4c144d7fb3f76fa06566bc762f65df0810b31e0d7a719a029e3a1d94a5b13f719af7a29dbcdbd6c2444bb19cceb26dde6ab3ae73fc3883c9f381bf2f2c511e76f17e5f024b531148333ad6d675fb0f13bfc415c4d368d9197269f26345714d91f0b9d344999d2c740979dd3c37a84102551913ac9d38db3312e0b22f09f998503edc94c3b186b4faaea7298c662d7569d71c547f1527cfc72add01ed736ef462d2cd9dbd161d05b541433fb5ddccd23bfa257afa76ceb9a0088eeedb0e6c736484ba9b5ee4c2cced72aad3c83f2bf553ec44d0e8bd12e9734b84eb8655d4faa949273cd54166f589855b7bfb9f998b7ac65e9c80e2e0ad140f0c5abe251f1bd5db3ea8733e90e67e74859391225b633867d6adeaf51bcdea842cc3c8a0f248799b9ac7c0da94b38dbc42823ff3d417bf530ff2ca54bc69f9a04fdb428f018f7052254d466aebfd6b4cd128e7d4dfebe681ffef088b328fb4c05738f988481a9d5d66c84453065195eb73a039df557284d0172b526bb9c14d60716ecbf1b6cb4ab80a0deb798c821ceb4964d60f007ec4cc7369cc26b9e9a6e3cf84edca8b79a48cafb77d8ef39ce77ea944bfae935d644ab73376d4458982f7a9e281aaad4d5a2164c07113f6518d64be5ba6af7c7de7d2f05c51f2ccc429db115ed63d7a3ba788a892e87599d6550269dbec0816d1461ebb3ba98ccbb0892ee33ac64d3586a769398e3fa27c397fe0c7f9ffcaa1ceb2c10b2d117fd36c2e5ee7e49b53ac704d9c598712cc4d1073993961e6d9f43a270fc3841c20de5828f75f6f4e0dd1fd7b4c85b67d2a1eb14e828c2fe5545e0d20cb6840076bc2d53f99da033832b728fd4696d724b27fd7efeaa3385c9e5dd42eb044cf16e86ff230e0b8c4eb0f381b583dd6e33efd664c307d1eae22895c62e484d045f69b7fb0b871eadabb51678b40e60c86360099a9bc96476f36b2f5d7c4ba6e822e28ba85453c069f621291f1c4270d70e258b2316e9e341124966484b86f0709e550d6db6ee73e8a63fa8171880df5d7b538a01658bad38b46980bfd1bee868277cb7e56b446a37256ea81a3870e078d351fa11075b308e01cc894aa9710a396080288148af9d19d1d50907adb8e75916980454a33216812a780fbdc74925d6649627daf0ece6836753e70ba22c9728d2313bf5461af828a9a37b42dc4a1623723575e3bde0a750b04f5df82bb5e65de8dbec2c7149a9ee2fd33b0073fe357e9718d92a96580eec7763b08e474cabd8902286b134e9487c5fdc323e7de47bcd25a162d22c6e5e3e42f3073c0ed4f95f89713f7c5fce4dbd787676b9632d2d174aec4a7c303a13a7bb5f128cd5072a035d38e04225f5a9f1852b2f6a8af095077ddd2dc279bb2b561b9031e226f1afdde5b1fb61b466376c9cbfce0006fd5212fa91637e463e75bdc5a57005108efa571b8406121e7a34440ecdcb9b2ee3a531d162f1422d66cf5a897b5d8a9b9a0bb26204e2c10d921e651186d7c6cff0f4a3a3e45c0aaf7094014fcf71bde615a9dde0efeb2d3b8f6f3271b75c4e27c94e845b3dcce673913378a42572d5fc1c1244329f16cc4fafc507e7148c3c0f2694477d02c5fe814891dd0ef238706e6536aa0beb88dbfe60a7103513edd480eb76d82b34a80b41887fc526304e365ac5d4abcd83df803a49f64de8f193c1e91b2f6dd05c1303859c0f1fc33b403dd32a210eedea5173d5eeb73840737db7d7abeebc28a03050224f21fac1fdd12c72a8b274c748864bc1a00306cf4a71b4426f8b88d143145e5dad83959bb86c9bcd15a481329573e22c72a57035d6c195ee6d24d3b2583eaf31b627638eaf447607fbe55898e2c37f5d10be5c7e07691cca292ce3d4c6424fb371928fd2c65165d7827bc5fc79b6b9a27b0c2abe0c104e1f221ae0ace0d8cbca44205511be986248a5e868c9e965fae287dd27cfc3981fc45524ad6d2d29f089f4054cafe99b9de0cece0dfdf369186620636b1fe03dbdc1b6eab291e9fbb42b2868231d18365b2a13bb5918f1883cc86aa93a6b30a1222b8e2c991725542fd538aa4308b5df181485f6b94558f56042dba43a4bb532e7719524da10c183866dbbebaf6f427ac4c416dbdc70f99764e77b616e8b20d0620c1185ea705422f8f92744e8f816e88f5f0ca4b3ba3922e80b442add520679bb04639413bebe2cb44c48be039800e29cd02fdef8520f6dd378913eacf0d99e34ee8b2e0636240e95bb6a2e0ecf357c1e5ca0932cc438b39f8e9db177788ebc41b2c469391a0c6ae4122426b1c8c50e169cc5ed82f5d6addfb9121f23a020054ba6531f1e814615a8f02f20328bf074bb63269359a1c52e55f157a36433dc97ad2216f390533accc6271a23f0979268a3baf634711337ebd8892457672e95a1ad77961edab88c32be17db1a806103c849a78a52f88c2d984e2c1d9ef878b2b4fdc9893e5c791105a3bcd9bc61306adb68d5c2cbe17923aaa874d3f47e8bc40fe2dabaf4e3c58fbf81a6203677d4856dd25628351d8cb7e303e37a59c91ba9902db11f7a0166fa13a68f5be4cacb138fe891d51ce85249fc14de7be4d05761abe4ff5d976e455747ac870461e3975c815acc0ba302510dbc1303bb664ca7b8e4f8ef7206165173791aeeee6f7d6b5bc2f3867a8b585623f51b8cf1b9418f086040a7b106a8367f3afbca1282d763100716b21eded97f6eb8645f719a82ae3fe814c634078942b7b8a4e534a485155acc228ef5379c2513c95fbea9b315466a72341f2c9721d2d037749416bc682c4ed70daf21dbe1fc5e3cbe63e2b56882fa8d7efc84e4b26a88e720f53139c5831f3e70792b917988c4f75b92c44f23b2d51ead8f5032082fdaac2e4809746f22f3271ac4082b0308eb99bde8196e870fc406ba9e503d09da9f4a2ce7a14a37d3654d3966a3c58d64c301556500a2482876b52b0ea766d2d3ff061acecc437d5d3cbee360fd4d1e050afd05bb95b61fe5b89f85c6bcd9ff6c06d93ccb3bdac268f26ff23e9b19584bf0b80fcf28cc70ddf21711ece9792b2785ae64cd12172f36fe08650e16648bb736f879091b0d8152f54fe3fb4d2801871bc766aba4fc679ef8afaea8406637d2c1a55750a10933e551b7bbeed032722c38b04532c847a5333f7a7b34022f1bfc516e87de627643cab1a92c73048b78df76e378c50b8960cec0ee556e5488b999ac9fdad12dd5db68e54cff8db4b5e957b3bbc142ed20ede080e401331bf497a55001013d515becdbf4eee229a539282147af0b70e0e9d8d821f9876d16fb684fd14d4c89046bf845e97813a8de9f3d1e7ed4fe1bf3481475580c4cd6756ceda3caa6192b1c7e9076b008cf4625d3946196bab2735fddc005cc7d63e2d2af91dba53b20074b573bec39f7b9a34fbbf311534d86c46835cfb564235c11c3c53f1efbe2b8f5ce2c2b50f4fecbfd3975f060ddebf64b02309ed2857f68ade7c23decdb67355ccde84f30cd174b0350a5864e0e4d2d633a9c74199a865c8524bd3228eadc5276fe545907ca606101e9a10550221ea3afd4c81d2f980972a3668e42b9babf06574b4476f578fdee847249eed13be18e59a86b69b1df491d7baa2bdacf600ccc0fb694ec2f6576760b62e1d8aeb0bd5a9456f6030989e1bd6e883210d1ed528fa91a3d3932aab43c1637562048182174ca93c292b633174cbba5b8787d5746c3853716a139a2c75b4d8e5149bdd84facfa663ef25cccce76d7f79ccb70c7a37804fdab0aafab5804e15c30e8e597c2c4e08c7b7d31151dcaf6a3e9e8f7dc4deec09eb8e57c5145745bf0a07abbcb53eb8a40679e06ecad7934d49f6a5119b53e5b62d61b1730afe013150085d1c987ef25389fa5f7ea588c1f14f334939bd3eaf0bb28abae0ec61a26fe155616b9d3e0522810450a3aa967567bed59a31438ae021be245aff0e320cef356961c93130f92bf82d56e3fce8e591b71736c7cbe96213ca961dd12d72904e6fa8ab4fee1e9f2c84e9ee7299600a4c9532bbf653f84bd5a4b29cc623d9fd1060ccb43a000e577084d791699b69aa5100a407b7693d1b6f8a1c590562f1159036ae711d1f184b43c2a68607d5436728bfb0a356efdbdd764afce46bcbe0270247321299491d16485140b3470002a48ed9ec52b057b8269f080e9cc5b0afcaf3fed273054784811fc72f811c9d2a6daf52256d8f06fd5bac4f5ba51e4f8af15a5208e48e22521db1ab4fbc60750e9efd3c98085798151f71df269c8de5d64da0d84e31205e254181e28121938c4bc8e7d0f2a0c5494119fe4494419f7fbe3bbfbdfe43547f237e440455907ed0a7a45b51be2fe2faacd0ed23fb17ad2437164e27568756003ebad87ce50098f1744c48914e8717cc84180438dae3666b856fe22dcef00996ed463f0fc0e869cb4db570c588115be92f367e3d3a8cd9bd2a197bf2cfc7cdbe30b4fdda58b16b8e4e22be59c1471221b204a6cfd39a1140143050b9cadf1f0387e52aa16e741bbbb0f80978166a3885abbbe98f16825acaac35ddf279cefaee3419aa9c5b765b3a6c2c992d9b8dab951adbc0d6fa824275d0e5cbab6168373deaabc7b8f22adc7529778f4cab2c8f89d69dfac5c4a68506197436179206d082422860c9446daef90a602423d060bec9a7b03ade6e583d258168d1153ca79ba8d01c0f112e2a4521f52aadd453bab928af5bbb31a54de937a4564f45e82bd87cf0f16d285b1ae3c49ef0e89b01b53c7514eb4e0f6fff582e00143c2c2207f07eadff511c901446bfd03025ef3fa5ede3433ee4133983cb94d00ac983a54b954899c71b906a66523b7c5826e1f31f06092a85b53322ea9354fed7043f41e5c4f32638b002ccecc668e3e0a74c48784b885c13a921e7048f1b14003f6386972f3962183debb789d9ef615504816d1e41f82e89766d8d9a36635dbbf8d555a16934fb5b2c1a54a11d9a3bc6fc49daa486cdf606111fcf43e9523a2424533a945392d5f92dbaabf6807d35c6fcea5616de911f57db047b1b75c55ae20578def40c566fcc38866b7dc02d962298765745fdd345de8bbc040128e1f81321c001267904f2a393d91d8983c6bf13885e7e690bed62240d6b393e733092c7dd2c7fa9fcfc873db928c8a7fed5206de351ccfc22665edc5b0198775ae7cf9e35b81341b5fe21291598079c5461b7e0bbc99fa1b3f534521f0c052983bfdd07550fba0f8f871502d04a651718cc7277d6add7aca38384840583ec459c064dab55cbac2f51f14a026fa34f7d61d0126a61a7db6e93a0e877c8196f9a0f4d08a6dd9a38a5ca3a7776f36bf6791efb71ce1364d0420a75d91a4fb1fc50aab6ff99eedd248aa4570113590a2fa6ddd15d91d021fc3f93aed90842cdf6e23198c1a52b6d32f4f55b96d489aebf27d591626e2c07d32f22f001b03c5a86bcd867dd2942410ac85aefb3ed038253a37c804bc7a89171af0ec3d4bff3b1c3d703ffcc79fa02abe0021f10c31be4bf2e6a9ef99682fb116d5dc3e187e8e547fe56aefc0c190b0ec167e078b04747a8617a2a18bb57740daf2e360e05500d80190a363da34e98fe48e2919b85ab42642078e42d35c2b25b31a912ffa7a8df91768541f7511ed1a9d8894a13fbb85f4d6d5364de4df41546ceb92281ca38fce5c1c4c5e1d0ea939558859f005804a8390f10afbcf06a8f47bb2087f084924f1153cf0e7958c248faee6d5110ab1edf01dfc725774b85f433c8490457049de6a7f6c33d0904c0a70a67461bebbd2c3120aec57b9f3046b5911646b8fb77e45eb191adde7222917f8186bf2c1fa5010a1d01af80a42ace2321ab016512818172b1f712a9a40716e69161c1fbd8ccfa4bf9a83378f24f9fa3ae660592d1d89bfd462f4511f73a85cf5cd2747464d6f30a9b8e5d990e31179d296dc156d4f27c0b5be5ec191a4e75eca022a1c64f0c9e5e0a8829d96bef1b45be06b77a8714941b6acc224681e7834b61c273379f9f9f34839847368c7171fe01cb0e78d9b059f6844a0c0ebf2805e37a9f41aab5d8c47384e22b284ec24ad3b02445476988b882cfce2ca5b7b34f4203808bf71ea0621b45dedd125e6325b3dad0301899924dda040ab9e76fb626d5fd902de0185d54014e3c066b9aea82412b5698391a5ac4e862a79a713c4a0b767d02f4a46dcdfa558c30b9bbf970ad6fb9c69c5cb5cb7c91bcb10bcfc76aee812dab73fae930e99ff458308d2af51d59d483221c1a7f09332036e5ac5ed71e7973cab3be43661787fe4445d6c22603f7f08d2f08c806ef1772026a6e29ba29c767a669564eef645a9b43ab7137f500cde55c1eebd46aec10101aaa854f333a74b9a27b746c2d67ac8f66e4a678a0eaf605727f04b80e693d01665e1a643148153129c1c055cafb6207e8b5985ee7b0dba982d6af532ef9cd42cb7baa4ede415d14351e1e27096872041e3a56a1843ef3dc393e8763b0dee53ad371d143345019a73ee40816e07378df4a02e7e59bd8807b4fed76c64810a088791d8a0dcb06edbadc072d51f400c69085d4c2aeeb639782dfa32cacc865f393c0c5df3b87e23345da7ea59bb0d7cdc61d6d1b2b88acdf57eb52f4ccffecb8740f429d933c515f6c883895f3f7c5ad41342fb45d7e9c10996028179c34694305a9364394445c61bfce40fb2aeba6eb5fc03b4955dabd42ce2dd234c72b4084e66568aec03f71278a6a8322d13401234e1ca7d6f63c8dbfe325bce8c73eb5f378cafb37d57e5f41ccf9e182c8711a5077aa4eb3ed9a09bea561368e4f2b9bb95972bb353c1ddc5d162a22a4b0820e7e00c9be637e722eabf58d217110919db507327871387545ec8b9ca746645e208329bd4128ca7e598f929453dc0a35d9496a544aeaf00df760ce144035d46ab8441ccdf6f94b5b3518611a90d36e84a5b26427e596780e3789cd733d8da0af8d8938fb189ef43c959c9f8cb8336f1125bb78045ae448b0d72af3ce1b41ec3b3b75b8cc1e67d55e45c193ea3e37b1d458d42674772bdd1cee32f1902823d639f4c96a6ab9f43c8c95a2f18d1b6058439fbd03aeb87a664968a42e38f6a246d2624757871fd17d560be97a349041173a24dbd68c061959178b7f81cb6be680f59fdb91f6feeecd8429f6e685c05ea9384f3c8c5f4efa351b6a46037920063c9945cbe19dbd92bcfbe2373319042861a409c4f3b15720e2603b0a33ff1c80951567cfb003bb4c841bf638e1b5f967707e2174069f7409b54e97a4e2506c67d43b576514fb0113d9b82104dd5ecedaa015791008dc218a6fc6f2e15c8f94343e58cd4313998b712f64f01a27284c1c7f4ecfe75de04d873589b75053a3bb26de11b5dbbcf1568e8359a9bc9f1064145f2bbb45c90c180722f9af1280f9c10f1b83350945dbfe89b639a208c6b20fc6508cbed14cf2e3971f2e82e6ca3c99c5314d47dc638cf6cb5c0f6102a8da3d4b508a807e2dee965afaff08a863ff95aa1d08dbce8cfbf61ed38ad691e98cb8268fe8d4bfcbcb81c94cc7ee3be46a2f3ae5b21b3f33d07672002365dc2f4f319d8218cc3b958f742ae71062c5e3ca132072ddea7c27567151978ac06e2927b9011ab801d98489ac75ede03e96e161d25c48c1a5aa4e671adef4d18efe62192bba2ac0f215226a27cf2fa982ef2e5ce0d625a39500c297b86a005c7d817b0fd8511896ce6c26d214f6cf0511e370ed1bffe3432aa730cfa6307a11ead64e1a50ca386c3f52b43c3b70d58d00219724f1fceda96e07523917940207eea4970a7052876dd4159e6b900ecdd170be2dad23c48200bb6db5154e3a3e0a08501321cddc8a4e25ae62d300bbe4996cfe50855efc9c3cf52c067ab172552369a589e1dc213bb3d9bb9a50421b5759b6d3334407c6bcd128919b0eed7cd3bad3e7e5d142b2d68526ba73f6b8874553a7161533ebd9e0b5782bcfdb986cd087f5eaa98cb0ec4975c8c263a8dcda58abda791ebb1fe502d7c8e70bbf2285fab48a4a86a8a6592da7973ad5c9a2e63a2253635401e4be056d70a7a1b01fd5615b0c2491d4c249447ff65d8419d8c8b92e589ce31b80f3f2abbf922c080e1a8970eec45c3c253b0d8cd9b8ae06e93a2949b2b8bdb71fb48e88f2ae5a201b38fc4addb8388a8efa0088c13117f36ccdb5ea40280e6ce935734ea04093e8b81ca028bdc7017e45a52d1409e4f8ddc9d47e56ee799302b81f8b1c031d73249de023d976ee4fb88f72b0f4a0336af9fc8514c17be74dee5618fecc51e20f7c7bcc3edee045498ef8b63f1fb75ebb352ec8bd8f5d905643dcf5b3c58406bdd56662bc2d2531082846f950fc9ff98a8de5c056f8d1f5494f05a13f9eef644953211083103c0e5be52c64467ae4a478cd256f2bbea6ad116e6fdeaaa04d839458b03449f76afde0ad88e5382f5c795b6a594029777794c8db1bdf2f196d01950f70e9c541a09f4b4584c4f80c1c94eaa9a1453185280c0663d59c39dc567288634b3cd4f29f3ecbe8dc48d3071989c9ae371d908815be8c0d8800312e713002e6746127782dfaeda29e9d8276cf50b919acf3104dcf815b1cd442a7a4cdf0ec34a4027843cfe7b4bd5cf2efef2f18576193f71b4f031e79a7311c47889694b408cca99bbed780e142758e3190740dae2ce0762d17cde9c5d4a08a02b40c0c402f779006f61758de3dfe82b967e21f4af6918074e4eec3cb17ca7d086c07fb328d1c70162e0036deaef6f87835c55c48eea7d0f33f5b8d1aa718c88bd0994af15666bf499f2b9b3954228968659766dc68d60f0142c4af581c63d99281eda068cd0340ebd33bbfcb3812a334eb04a0c404565bb4cbb535bb5c400ea02630bde62e2f120d36ed6de4e33f851aa061a9dea4d98d81f1f8f0b95339bfb75f89cfba15f7d5fd702e1de3397aac9a554d7d9c00f6bfdaaeb52cb80d476e1d910c5b33b8afd3387f4376fd33040de1d4c5ab502622c6cc7d590a04c29c19c1594462b532bc6847e7f2283c032415f025e7a78f8842c52dceb40fb1f829cfcb7af5beea264042a57b44822c480b3ad501911f3808859bc51e57a1923d5fb2e899350291e12c5b48d71d9df7e6b17a0d3dd236f96f9d27a19886fb6c4ab870e30c59955c2b4f0f072ce2cd6dd62e32b65d269a0ced6c9ef73e7311d613f4d3de5f5e73ef6526472f35d62f552610e38c58cb6f63ffce201b6d12def75717584757ee5f05fcf9bfb011b6da6b0ff73c3433b4fce2ab290faf742aa2df371583aac1fc9d6a5e54bb2dd260781c3a29ec73f8328ce344d6ea3f9e0271ce66478c2feb56fb0d11b2ebcf412350209910a166aeeb18f079b2d6bf449e59b6f227fc29e560bc4a2a23ce0970c0cd52ee9fecf51a1e525287a398497259b72b28c9e2f5f0238888ca40debbea44fde9b14ca3c8ac40262ae8503b451313adab9c9404e5f1cbc438e252c07daf83f705e30e330d216c4b1adb9d726cd9b31d0fc491dbfc59d1af22fea8d152d74df3d96f35d9048a9f9e9e08cc987fea3862167fa32184a5f6d36ff96ef8dd770f05872cb6394f12603942011eb4b59e822ab70b45798dd6585f8aa214b5cd3a6478c4967e2855c226cd176cdfe0238fcc5470dc2e3de3333d12167d98c0bbaf41fa012d9cf99a4de6d2cf99642f9599f2505ee181b638c6451c6f301673cd67b9e8d9af358f7233c8fabb847feda5d018f73b79a6a39bb15d9a95fe9c3879d7e88318fe20a1d64125282800725a6103d154cd48fd76ce95a0761b40a15ffa212da0b490d5b0dbb13eac82943740c0f210a17271193cecb9d88d04d6bf5ea83ea6a1022c049ea647b0c3bc181c5a04abe8a7c7dfa0cf5139a23536ef4415e09526dd6407d2df651ea16739bebe7a48369d025e91970fb9524f665256a4f2f43f2f7f485047cb5b51f91d59819e0f02b8c8d6cd6a42f4e81f5d5d9a77b73c0d56af945fe8d8fb0904e95346048abf128cd95e6457f6c4a8cf2204743a811ba89820c1b7eac7a03cca6eb0bfcdb4f26bd4cc2a7058bc4c7e515a3638e8c3d31b2978249221536eb2fd37bc050b0925c1258725eb617c2c62b6f18587e6fc2ded4ba9ce11d2ba8610d7755f01aabb1f1e8efb07c18bcb246057153efbc56e20aaec8ce4ce99ef7a68359fa8f3cad017f63b0a0e9cc4b6e7a96294a1371b3d3e3666ca8ef713faddb71a7083130544f141d35df1a2e642c3593b38fcf4a30e8bd46a833d9b4fa5c174e21b30131d54fc167f2580a94a63f437dc0966de3fdf752b797a78ce63d229ff45be5b92f1f25c360c5e0fc0b3d055b29f830f95e2030dac4559f5057b048192edd9c939110e8c1eaf18e4fcbd42442da9097918fdb48c4f5c89ccbaebc31a85d9e38942fd3396bda4935d87c6cc63c669736b074c5b9483fefe716d5acfb1efbf40dc7ada83aee70e1fffa07711e1e442bfe5c4255db4ccd7b31e3481fe71756d51832e220ebd77fc44aba28431a1e2f9956fe3077225fdc9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
