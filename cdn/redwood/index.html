<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c112ad070af5430f49a5fcc0d24e590c3bf1743bd0d78887fc3f258238c859b8269ff9734d90a484bb62a0bf6ef3b8836d78a285fc083e8a6d43ec812cf6c98f10857e9e993c31b93be8b468f242d82c5ed820ac8230a35e5095c54b88462976b6eb350af7c10a0bd76c67db7a69aae2abbe5f54ea16832fec163c72a41b6f508a9c0abcb032f6cb42c16b9ce9192c4b33d5b5ba88d130c2c068eb9c4217764483da4c479726178d752c598eb7bc458d927a4ff8f9407724f6455cd7daeef46290e64a1d5c9d6e425ee59a55407fec8f252c2f242560cd7b7ea83238175b96bb1f79f1f8e904de0c6a1367435db70cf09c37ba618eb718f6500de6fe9fa9e78b137154560c9257538d7ff43711810e861834de20a4903a2de086d2c78b5d57b28f131646bacda8de00603b82c367809cbe7c81d8717ba01280bfea61de3f8c18a6c6f53b43042793779eff6cc6149cffebf46481bddca562b3a176c04b38ef988b317b00937c5344ce5ac70c072004cfdf48f0d3cf526075e421c3879095bb87748aaf2d665a59b6d3e1bf1bdb9ca667acc7e4fe6a309a7a5b760a9a610f847b75ace50bf51b04a7906db9166b63fa91f2a21033d64386f6037f8832f7937a13c5fa3c17e1335b25d3f7a524c05e7a53d66ec091f0d38d628aab5694390706aa79f1771cd8ebd39a95e46fc667c168024392566d94584b37fac26fa05f77901524073172cd511cdc7b0deef266536c30af26eca1dc9a266289979aa4738723fdea6b58e1bc167c3f107ab6eba4c2a4f90e1f4baeba77e3e3fad9125ae2cc1661d7ae02f224f552fd5acf773275514bbde0b534f5ffd97933555228ee118cf9bec078abbd429074821979ef980382799a450a661ecd7d7592a203e3a64764a9159afe7c558daf5f6785012c514e8d819d40f957539ab62c98c4aa6784181a0b7ce991993b1d5081684187110c13076e12ae25ce16ae0db562917a0718d1b4e01852c019c1cfa1af1088831a3ae37aabc7af6ef87824cde6f50394db02a2a903123b5f35c6b6dcbe3c93ca080ffac95d5397a78cf261664252bf4d2ae78dbe822ec69cbe336f048dc2693e85ca758e14cd41bfe6b6c49f54a5937a85b3a8c3589242976aaf4e488cc0bfe64e5686e5481a11b3a2f5e5c972f03b30b0705b7c6a6d6bbdb98df0a4733ae8f458fd114559b4dc2502ad4ca5ce538ecb7db754421bfe67cc615f650a5e6cb95edd3f1b9ce030f19cf1d0d23ce7d97766f1141b30f8c1ed638a6549483f7193f24bcd61c4784e3700a4304d12adde47c3040c4d9979dec31ea7f46e8ac27f55893a49cae8b883428a0bb553be22a929c8ed84e3c456496d7a65f372394acaa171466ded8f8069c4be10bd0d1aeaf2ff01fa0b014f7ac8834d87a642756700656ff6f071e1393c00494f367d9284273ef39c648981af1d8b4c4aec0e274c519f4f6207fd801658991e2152773e7095b0944cb974d0fdcc4c1c2ee1eac1a2e7a91b76e73062e053fbb01fd868050a5b40ef0f5aee843c22325bc1c55e64152f0d21584e07202c4d491e8209d2c275abcdd611bb16f57bf5e3ee2a02fdf0f11c2dc095de06f7e370928ef94264b409ba79970052c562cbca727625e7531c8afa305014160a7a408f3de5a8efda65fc3bd21ca07623bba912450640bafafb729ceaa9d41205bc7961f809c57b831f096b2ecd606e204af6b5bf20ee8be8a1d3cd9c18394e8a4da06c3861f2f3944d13c7451b4be29bdd28d66df679a6a60ff9fde57c7527b8e7474897092ba17f757f4abaa335956516a56c5a56cb4c5ed6a6cda59a9209e02a1c1e5d9a36ed848d67817de9a94c639cba98d8824e2289dcd54ceb0c9e970febe035645a4269188c4939fac572f8823bfe2ba6932c18067e0d0498e9dfd0fafbb7cf7d4947418dd7fa04b14a6e8748b1f5e0a489dcf19a06802f1f59d5bb3db11c0a057cf0654920d5635608c6145e17115cad20665e939e49f8c565b1512afd65f96b62b4bfafe37c14d1f4d529167aa4fd0e3a76b4283d0bb1b7bc4d164f0e51c2fbf41adae3561f695d0a3c66a2b7bbb0bdc8e2724fc042cc2187b01d562b6a8af0ca2091b434d8ec3b58c683b9512098bae1285029032e7973813bc4bd300c2ab90eac7048ba1ba451b531ffd99f92f5f93bbdcc923f744dd627ab445ca752c7d1de7106e131d845cb0518639106c9d1af1ede39778c88b019434539cbc6b3165dc66c21cbde96d0d25a82584ae1ae5263838ba4c6557a27a260d06719cc28da5337cafd7b3a425588240ec27d6a952e39b0182a025df99a81c44540d2edb7476a5a747a8a053a9f8d2a59a2cd3de503957447abd6c3e4fd934257d9c5be335e81234ba6ccacb6964c70e42d9d18229a8fa3d802de11a80b1a6c434cead41187fce8f0ed61e58d3e573f5734ef9a51ecbe0ca7efd2ed13c7f39c9d221257880d5527d67b42a331c723b677f8de96a4f260fc840cd65089cec6952eb812be1643b6e1537d304aa1bcd3fa2731852cf0f537cf99a563c458c78872ff349a22ee29739bdf8e254ffc306252f71bc258c8221970bb877eb3de20bd489603b2848872e062bfff221d4811d10237acd90e24b67c748fe97bee317fae4647087a132b58b19d4ea5e9335c44056f839f35e28e7d6d56a94f244909afa0c629193a774098a81f87a248b992dbd5d5fcfed31812f8232a057d45c336cbdbe3d6093240a1517efdca21e2552b843dd1bfcd08f41819b2771b62a44c1939f2280ce227461366032867dc2aadef8a5d22ed87b852d7827d743baf13cc29d9d83f48f70d4f5d467cc939470a98f7692a44cabd58e0443c6f7e706567f0a9e7c8fd8d4eaa205728c7034f2ec21ff6a3d7edd9547570d836d19550d7879e299711ac8c15d814738608521ee58ae1d60c84de0f4013c7a43e153c15d14597b0397935a0567d571135fe3cee04af797f2e30242ce9b9948e5369bd846c83f4355e2b3c77fb9350515929de2e1421da8e2c05ed0859d72ac47c3b110a9653b23b69ed07a11843ff7698c112c329a695e6be2f965e228c813204c4caa3409d569c664cab737d7b083f8b279902669d77a338c2a6e551547b4dd33fe5b70c80cd5f99710ab1756602ac674974b9bef9650550ff0f9ab433b4fdebd61de1b0c743cb7e5ffb17ef66b882fc443db6845afcddb5e6b5cde160543e19767ee91855eefd6203bfda0ea0e026e1ce0fce87b07354c77f53d3416c2aa709737aaf55befa2eb43ba986c5fca11cd4426349c1bc83dd589d1ad48fda28f316171603918b8d1b782e30afc8935e0dee778ca9b27e1a90fab2803f64328fcf71da43391c4318215355775b314efe138fe6400d48988d65ab00c431dfe10fc4fdb6d81aa5515ac3dfda5b95919475fabeca3cdcc021ca7412050d02a9bf77b65e6f4bb17d0047f17e08d8c43f7b48c5b3201a4a5a32479d41ca0c5c3e2928ad1e61d9322a63dcaf21541bb81ce1212c90d8fa3215c7f54935d7ab18ad53b800054b2b2dce560ff2a8e4c6dfb1c203a31261ada15e973c7974da1d894439e6c58bc549832f2dbb1d8ec6589667b42dd57d78b87db93f1647b5b249c93327695931b9b2e2237b1f9e3149d695bbc71e6335baa4b17bb2368c699357ab8b7818eca102fe2ee20ddbc5356538b888d64dc871fa94ec21df08bc821a5301a7b7c8e60b69a1c32861381afc7feaac2b6e01f3beb685e00b232d48d80ca19b518ab55e9a6e060052eb451a6a4c460dceb1f8ca0787aa8b3341511e39a7f80c744a2ff4bd9bf1f0258112493abc51d3c042fbc8012eb2786ae327ae2020291f13a3f492d8b7ad74805091cd315da451a7904a6e55dc5a41217bb6b002b604fef14182c9cde96467f0723988b5b91c54789d5533aaf2563214a9b17ed75263cd526a6e3145fcdc303355dafa99e9c53502191822f987883827b57669d7227e5694ecb9b77422a15d65306b60d9f67cf686fb1235c16643a99c4a22e21f5e3ccd0bd1aae3b0a2653db132a43ebee411927d887b08134394111c70b72f264dc2b4d5d627cb5cd8cb19fb7e108dd7f17ca6c26e019d6a8772a7735556d5698073e1a623c215ca5b5f8300efe6320e1237e9ff924c69f8878452948ce05075ea3091cd6385249982059be5d2cde50d84111ceee2c7b6406ae5177b8f2c44c2fbb7af7a4c8d1aacc01f17f3f94d9562af30c30baaf0b7ad93325337109af9decfaf88e3bfe6a4c8e4606656d98e20b1d73391fdd4aef35ccc58e051d76b4a3ea7c80c72a12826164d2dad39fbd98fe9ca5c1658762870514ef1031fb31fbdb69a3bb602558a9657597d7f571aa115bcaf5689caf5ecae9cb0907e9d4582905e645d6baf792b8a9b854d0c875b132f563b2f931f256bda1d0ccd8e7519d59659fbd1406ae6b90d25a0f663d1d77a8480f683bb6d371d8ef9a0ed23d5e5045c05a406662bb7b080379d6f3686b8f8dc25dbebd5162b1aed8776c27e40c39d16079a85f7635d70d3cd39d571de904add94bc8dee1d479b12725a5857a24f21adf9ebd8ff50ad47d820261cafbcaf5d25ac119f0de58947184362706c9ff4ab279a0ded26018c321a5d0100306e1ee83af1ab75a4f5b8bc09f2ce8d5f27c811df5a6cdd8c29e33bdf2f89f43f38ed81fa6b61d3d09cea6ea78a592d5d40689ce5bbedf2b27875e2767027dd380b90cfd57bd07217f1b7b1d73173ce8ca41eb53a89220cd7f2ad1c67c87515577e722d214cb70af34ea810c0702a2996aeb739ce4c317a2abc47887af226ef87cf515d34c3101fe8840fd145845df03cf2c2d9c81b36bf99b2022af1fd4012262d89d74aecdc31898a4eb9b40188198a6a66ee70700211323f33f5dbb59a325a24a639bd4744de17c9bc0b49ae1fa7fce141e89b33526ead9954cd391e536ef66e5fb485cfb51e2378aca4dc25cd95f2c7f429f9bbae4e980b2a9b1a0a4dade414d99a3e84d3df87f5a4df64cce63af2205bb23c7f90b36ec14a50311da199e8906e54dccd077da160f54a4a72e4d66e871bd6f1008c2d734898941b52168e8f0c9310996a04edf8e03e38802c95cc680f84a3ab54bd475ed5d5a0617f9418cb6fc9d1e3d7d929816ea433714774ee7784f80d36f60cc1b657e65b855bf52d4a9f5c2fe0e796530387f7e744dd25228f9e17433e8b547dd5098ed7a68455c69ba60afcb3cc4fa47af428c61a1db643cfd00ae81b87455cb48eaee7a3c7c1f690926dd7eb64971132f5c10898335838317c8c004583fa257a91ab09f2ba3f3a16bcfb1c795d7883f285551c02c1516bcddc142243d963d701c9445aac135e8d86770ba98296ac016068bd637d5eceb378ae65510dde03bcd749fc21af3b37f3170a008b46315988e5dadf84b3d46c9256abbc00bf204ccb6ed9f6e25800976a8856f2bbeb2b433e5994ef3e89836b3c6ab7053579a008548860fe1c641402c3ad5fb5c21ee72ae1523379c1d0d6dd98af7550eed92ba7ac100095227eb2cbebe2c8018cb0ca648cee53c996bc630f483fdff73c10231e3d2fc8538b6f435e4aff991d9f9b71f82df2df792ddf911680c2dab338741f517339d4685cf09e8570d8bb67492c68750be6c9f3ac7fb47d39f9e598f263e885caad536b3cc10d8955b6ba90bb795b4644dd7199801da928f87e1638e183c2cedbdb422d4ab1e9dc22bfffb4b52e851aa4eff76c0ffca5fdd6ec7f8a9c45f039fecec064fb0eb165bd192fbe20da23397863b52f221a96cfe3f11db495548c4af139289a0f9bcad963072c6052ed6d08576f4456a2dd170e441b6a772e1bf983354edc761c3b1700239f58bb73ca1cff775bc5a7dfd8162e9921abe6ccf29bb14137702751fb307326e1ffcdcdffd151826836c82043c8ad6ce06f507bb1ec89abb29726770ee83a0345dda948ced60dfbd37f1a04b61fd8f17cfa000a99dbf575f2e0df9adc604aba44c623a62b286dfb7b02bfd481eeffeab2623cefb6976c1336749e964e020187b7ec63c77997d3db786a51b36256a449f320aa1832d3bca68aaf068db518c725a3e411289b3079a63dbf5197420bc8ce96cf32056cb7ce62abe74f6dfec757b69f1ce4139794d77f8ce5a3c8a4881f3a4db10ba3f970ec44ccbf8b374fd6d502d7631c6e667e939511c57f34d54f554f81975c8c1af929d8f1dbb5ab3265bb084f9b7d3121022ebd247775dc446ab13f24005f0d4a4aef4006d13dbddee1e7e1db4cd9f939cb1c5cef1d5d33c881f9e843f856428c2ae7862b7dd9283afdbb498e285eed4511c39bc91b92581030c6f6575db9591ec9fd24c60552d1246c9be94cd4d3879e098228615d5a62300c1894d6e85492316c0a022f1a87db0476aa8acd33dc2efb048964200c5f93640d232d8287c2cb732ce55ef8d450ffd5079c20c0479de488d18bc647b4a8bd358ba4fc8232ffb429ac235d392e810587d31b526f353f7e10ca59eca2c0ec5b24ab2a09f0093ade466137e9ef1edc949cedbc80d0c95985cd7933f7cbe2a08d8e891f5434fd5dfa2b3a2e825976f090a4a0a973fad5cef3bbc49c9d70a928f8a51482d01255a75ca99ea95a3d0ab90591ccbb4351ae8d3d5b6778483d6cbdb9cd54a86cfa8dff12ccaba26a6d03e16019b8c85ccd489b34baae0b68d5027454e0dab78415c725841524d9c9a4ab69ed4e987962ff54be85f33c332bfd0b1630438a671b08f336a5a67456decb1be17af5367cfe7a9a504057bf910781e3e2066c632c3d2edd51d0df165e1a33da585febde9acf005ef503e9be7762323acc8cb91af83f9bfbe92ab2e55c94197a9d5b929a831356f3c6717d9ec8f2ec127fea79d53d65a955d83ebf0c9ef9992cf124bc585bfcd18855aec150076fccabcc06801a78e5d1351588e8bc244e8551ea9a0a25866a2a309a4ba04f83d1d37490c0dcfdd6de05ce3db37aa27c78fb9372475f031d30eea155929d5653934ca2d08a78d07130a960d8a4a6d74df531876a96327065248d33ff6a544c43ede895163f92b407afca56af24982ef5bd2cd8093f9a46e205a19441f567ee1373cfa8a3c6a42048e79d40a3dc93b731a35436f550a26b288e1bfb19ff96bae92ed1ff09cb5ac7a5c26379c876e416de881cc8fc67c65a329e91af676b0fdd171d41119a3d9ad53010df7979edbeff637eeaf4ff128b6047388a4e4ae5d0821d35675e430800ea24b568d5510dc7c90a44d59dce78608ca736343af7d9d0962eb7292b070babd28299cb42a738edd453217cb6692fcf6b0a5c9684d794d69810f2980321adeb3a657eeef3f04956118f69b375df62ebf66817ff736c1561e09d7ee3b4ef0bd7f9a547067d30eaad7f81bf82017e4db98d769f6bdb14cf07d8da25539a082aa38beb1e26cb668201ee88321369d0b0f41522601bfe41d6f90443b9bb6f7fade1c77372130f264aca9c64a927b95574e5de91b1dfe65c12e641618a6bb6ffbb91a94e19ca636fe50c4a6bee38e42b70ff4bbdb7eff509758a75abc92ab0d323d8f7c82e1458ab99ee530dc3129411fc25d2b947fbfc5c7bcb570fce979e5ec26cf7d94354c80cec77cad718f9091840693f397bf55e01b843df0eceda75f09dfe97cf9914fe7c2300d00c68e6cd4e8be52751bac3147c90cee28fd05fa355eeffad7db38cdedba7db636cdc71e008a957c534e5a8309b32d7544278f021c68614c7e12ad56afca4f0656864d83d65fc5245c2742cb2374fdb23d3e78ddfac664480f1aad0a321f4cc87849e077b3edf8fa85fb3d09491f612b9ac5c48b51c85863cb5f08c71ca9301c901d9ff2f0b55c008135e4d2e4f785363b52758a0b473a84124290289012f71b5e11ac46a03c9c38a4c5bd699ebeb743b98f2fa0a22fbe44db422ec68c5cebc6e96d71b3f79424ff7a5401f509dc7605959d171e4eadd6c8a88253c20e1d848285241bc7e78d4fc86c42e6b8739791972d9ce9f93ab5f0f142e6e73bec7d6f9edae75f7c2a10bc292d77c46818cbe0160a5387425eb754deb9b370f3c5615fd440e039a68a459c3171f8fde38d7b0cdfe30c3c37b6f50cfcda022ab4b3cf4bfa47dacffeeb849e97ae10010905c91ab90a71ecd9a47104d72c71a9857eaee556fd7782b873a64df85e900fba3f8d35217c7b11b810b538ee0a92a4a0aec78def205b732eb43cf4b963b2a52ee522f1dd74bb71bfba140640adcded0c0829b35c946bca3251ccec850c4bdb660a7b51ffb94dc84085e348e24b29fa76c988e356e438eef6b1e212ed962dbd02b5bbc394c70bd683d5268464afef8b7c0f93997e7daa4826b7c46c89afa1094275e0a48c12e30f9ed02f4cc7f27ab70146f3f030c962ece5088c0f85f32fe0df5634891bded704857ae7d654e46c17feeb316f97eb10112c6bb85ef589355106bdfd29bb748dbbe78c8ae328d531919b4306a3f1d1faf6050e624485ab5f83c66654112d32eea09f56bf2f1568ce4bfa59f62223638c54bb50773edf9f2bdc5ce0975bd432db862d3b8a516737342c5a8017eab134304d5a16dc639532507500521da97bb444b3365c3f00187b1b891a8f56d010e45ac8395a338d9b38d063429254af08068a1eab3cdb06b75f49dfe3bc96d6f938253649e6ebe554f6ca4e6e6682e06d39cb475a1c5c3e68f21273d7f0254a52a2ff2f1afd364194db91af8ec8d17b21a6d78d480682a21a14b38f865ebca9a916302d76ff15d74e0dd90569a0f658364b330041590483e1c4e32fd92e9c07f0b7c79c462dea718a497eccaf7fa8e9140158ecc3fa1c238f541735c13769dee2ca43efa843da0ea0ed5cc2a66fd2c349316d572025fb4a00738ff493f9583a80ea1ce69bb301776dcd4167900845de19685e3c54a56094a495487bbe2cd38c03afa08d6ccb8538211e3dacc6acab1f5b320c29bf07b114646ccfd4e38ef4720b1a07fd1052b2875aba5ba338c7ff89ee0285bcdfd457cbe0d866c4a0bcfc0a2d584e3898959dede0e4f1eb2398170c281165effd1b548829b2a2b66ac513320d80b16f591af7e6a52d4aea87c580c531c9895c6177830f4f19e9824e284c7b008c761588afb1abf8c04b530766e4e4496d3e68cdf3e87b549ecd248ee4ba2e9b201263b82832aef2582ee95098eb1d719440c155c9e553d3fcdd9dbe85e82c0305774832746f09137661a1ebf4883b168c8d78c2bbfdbac97d5b9e3be66c2f48873b791905507d8a19944be124dccbf813eb01e1af0f6f7d4e53938cfcdd2b0306056f50988f4585b9e28f255c02103a748ff502688fa908e738af1b6115c2eb4a71a66fcdd2ad67450091e6a60bc77d28bbd79405be08c3466687f1116d91aa606239d99dea0077d7dcff6e10e19f27e599df4f5103700e8327c99011098ed2223e23d2dcfed045a24ac5e69b9cb985f4ed5ea6d0ba08b80777da326ab8cad5b64186eb368691724044f99e691119bb9acc568505812c375f6e9f581b63b89a7c59f2c687633e852e5bd62cd96fd8a2694b8193492776a2a65badfa04e3135701e5b1909f3fcb817a9c3564d86205afa51da9850c425ba27e06c99152542a06ba40611eebe0495cda241c0e60726bf73967688913ba78d84b1bc16005fca8d5eda47ce571a59d486cd19feb31b8bf6bb0c6336b7ab83392f334abd52e72c395d7e2164032809565d61bdbf3909bb57f4715c2323b740aefa8ddb16b6b999a3fb886068c8074c5aec3bd0adb5290d3151d0f26a7d87b4b27f3471a06aa12579f363b9b05c9c753e7f9fbc8fec39c202974be98dd1174b5a8d936d9ab986fe4e58a83b364fff28d30ec6fa448553cc342ceb773a8d38f25557056945c3d21c2210ffb25b3d6775f8a91b5de6dd12aa545b463e36839b2fab774c869f1bdce6710635379be8406e61f2c52830f2ec696b02b6ad275de52bf98e3bb54a9c6593cb21e2d4e826199ca5fd1ba29eea5d6ffa2a2f14c4e93bc20afbdb9eca6c4b8472434eed2b59821bf001370920dff547a08ab80534ccccfa8159de24d08197d7fa7a3ad17f9a0fa24d3fed456bd1c4d39ba3d1095784d30a903a3b070624c71b53bb6520f17a4f979f6b5f2dce0fab3b26e55b3e0f4c7147b86b08c57c36f168b19fdae6e9ae37bc67bed9211116123c3af62c08af430b53a4dbb880dbdc968538d9b42c1d0c8526c6d9975e922ab64fdbc332e37dfd2d1332282dcc88d7dd2a59be1403ec9b9ccc5fa9201bce289449bb9411bf013c167ba0672970f594c08f772795984c3fcbb051fb9d0bf9e8068d1b4d8719614777d4851edea6e39f98e90302ac20a1cacdac8a2095392eff5fa6dabb6eb0bb542ac5909b84db39049a3268d122d06cf2115f8f8de97ac3395f8cd7321d40e28c9a3294643aa69cc76d18848ece405103917e1d0477292c81e9162d3af9ce6750dc152b0e4d6d54abf6313a0173a4c3b422c317fe955dded12fc5ca2e793a25336e805c423fd83c35ffb27bee53c724b4f61b5aaf0ae23ef3b832fa93afcf88e0f094c9357125a663c8a0adff4f8bea210e55e892a29e10a1a4576e359f45e1e1292a950261081aabdcd58d7f4e758fa98fda309854838ce9adcfe4c5578c06d3de315c20b8b320538bd1afdaba7797fd4eb03a5b2f7ea583c5f60d422f06ab2adf19adcdff2687238e275c172cc4c6956a27f6c9c323a95da437a3e65940d05816838fb9b1cc983f31206fbad6c915b271bc6a2afc0d306381aef7aa3d14f61e9b43a40532ce017c4f23e8bfea70209d8afc9ec6ef8b09644d059d4fd02e58b3fb7a3f0055dcdff73bc7edbce2cc168a040cfefa5cb16f310821ff2490524125ad2d76101ba3ece1fa55a7ced743cde471af9551752263a337ca967f59bacbadc5a59d044e463a59fa5a505d8f6538ef89492390fc90c380c8bec8c8da5cc5b49e1519c47707aed77a521526659c532812987b36191a560bcb0f39ea732dcd9d3101dae2d5fbdeb55a49a18287f212e340eede7355becccc6b35ca68a7218fcff6e29f6d28b65457b60880c03ad7bb4a16d3dcd01575ae2977ab8128274a2d99c695d46774b88bf7ef805c32cc3dec34e2b0e15b30166193d9d555861840db699305317821aebffc33848997422660efed53f8d93d75042d66856301050fbfeb1266e2be7e26c8694cb1ea5f4b0c229609c678265bbbbad6e036bd1327a753e3f32b00484feffabe784563e32e4d660eaab63cb368ec6edd10ec6a1e495b9344563a7cff09c7b50006657c0ed9b8f04396f866f1b477c730de9908e77a70e0e0584bf61d24e447d6d5047736d2715bd05778dc1d83b2aa4def1f81e45fde850163c5c94fd868fa29626900d673607301698643893b0ea489a00875808e7088c450726216a53de01e5bf64394ebdeacf0b323661779c195c44d0315d196670b57b1d98091799b942f43f20aacf2e2987585c26b816c57f2dde0cfb1c124bb9a7b0fccbc6955d7bc750f81936bb74bc95085e9cce27303c5eecaca5ea7ef8d46d103aa4c8fd4c783a16912a076a83d6c9d6809be32e07e267a9398ea0437146b9de7748a94027d42b1ee648055d94a6f1f37527ce27e5553c1b51276ed5d69acc03d8e8b393eddaf2d91f8e5e39c270ce89e678ab8f4c30be2a78e948cc1d6471e3954fae6c9ea41f277d090a947215c80896a55ace57d69f6d7ef545c26cc7039d17d2baea47d2d372633008874c68f5791e5614535d396fefc05c23f5a6fc8025bab9e01153ad26340a7dafb1d9573d08318704a344c2ff074b9142ef0eec3dcd673e918948bb6c0257e57a538ae6ebbe344c45c6f1e1153aba586cc2a5df5c56e359701410df4f12ead0debdb8de8c65136c433e3074d72fc6583c47d8b38bdc749e582fa4abbbee75b4e8624e5939fcdf1d88cb530fb9a4e41fdeaeaee0cf4709fe36dab8c72cac28bb1d0e71c63a71e2344731d622ae2a99e8df29fca1aad356de6c6f9370e350c48508460bfe1d687f5d1cc786212e4c180571a7bf4b483b92240ccffc64c4fe6b4dd821eab226ab2530249237e967775925d80022f52f725ee6edf90d5e5f1929a8cf1948c7d69b88eaf1feaaddff98a9af1ff6ca220f5ad4d2cac64055003692e658303007917f17938473758f5d389cdba3d487d2897091c40cb5a2e332c0950e5b294489277cedeed020a46ef60fb9d78cc5e12f5c6b7b7eb819611c58b9bd6ae87fd38967033610f3be7ad87ad19a92c98fa5d191b612d62f590bb1c78cd2134bcb3ead4a02f610c45ad10b626eb498d9b687994f59cbe550694802813e3f5ae1868711dfb5bef9b096913f4e78644e480994b14fcbd714c5f88b4cda84b3351de6e9c52e778a2ac88bc0d2629c7db932a83d09eeba1143cb2ea609fd2465df103269083c3ff8ad38a10da2ab6b0b46735aeb4a4e11f13a24109454e6dcc6db78aff43ceffbe41ae013354ca4d79fa3712f65daa5d615b1f74288f3d34e855c186093061cda95ac2abe5c3cb6955d7b7662d68f2a138e2dc953aedf6017ab208ba7fd964c4665e2dfe51ccb67fac357eb54ef5ae6ae081523fe8e1979418eee0b81bba375ed2764b967fec2b4d30d54147f08a6bbc0ce52e221a0bd26b4a9d04dd590f95db744b126d86142ce805becf032d77252a664f89511af80583417a775f94023e459f601a02d3ba5a314090f81a3e3eca120dfce3d40169674234e19afd93259a12c27a3bf56399ec7c077731982b05dd64d7d3955e9943de7ee5c328bb67e80045ad2c54cc874c1808ef4539808ca006ca83aadcaa32676d5f1757b3bdb0d9e8d864144e4925fe6d78665dca024d666d4dbf73e74299d3994c349a93b1d1d37f62d6c451e90a8052e83aa4cf5d24bd6c58bed4eedc171b55ae5fd61d6c433f803003a7d3d467eeca0bd48f9bfe62c7b3ab4d4fff4488c88f2ccdfafa18d34f6304cf77ed6b2ab6a941aa513f962d77adbaff66f25c95bb48191b0939136b991059a844423e5ca4d911290fdacb81c734c3df9853fbb212a08624094129b008e843265dcc52ad6e7d0a07dbe398a7ac195de8e013eaa71bed97d76773c2350617608f285934a2dcf99b0a16ef342f5647258b824216a1026fb279103ed9f346f7a8fe6a23fd146014027a4c0ba8f334bf2395ce634267c07e58d94c39a38877ee72004571df6ce623dce1221f52bc455f8728caf18394724a381851674638124d8d2a571633b591e8ffd8cba39e61dd478126aeeed3fcebcacbcff8f25f0706c962200762b2145bcec6cd838118ef933f8258e85dfd73d50265511e7288c7585661e803f8dad8795c6dc037a11bafc26532323a77b45dfce5ce2003094eaf32967b7278c869b471b0e97fafec804d5269c2c512a3d72322485c36faf2f23794d6ea296918d7666d040effd90e92a720b2b45b8c54ed6d60d18b001102798b9a0391608d9d42962dd4cd55cf7bbba4cd1b6fc0e7dd8fb23a97b5ba76e01c6243c3851cab8827f65a2cbd0f0f119212b11454d22ad97ae7f4b6fe6a8effd95e811e46cb0e0e61ec126a22c73704a3d3ce5aca7676220681d8ae48f917ebf4400d158328c2aac54ee93c0f62216ac516cfb4bd3c6fbebb559984d58ee2ab93b6aa2ed3966606c4d14df235458d062cc6e62d7689f0cd0d80830b6d12b5b9d4f7b1cab71bb16a3859cc8b6d5e94a5e3e4e7370183c0cf1a8ac4ef21faac4965280b05442d8b48ee8fc8c9750786a47700906bc7aab6375823239ff2cce79a496d23fd837c0fd0df237870ffa83e71f6a57f0f0dd2fea7ab78db3e8c9cc658eb10d21efe8f6eee8374c96c34ba2c20e876e6d4337a641bf5665a468d1f3e7d04634fa9f44485ebfde2e89eb2e70dd3499fb3d723c1e9b03ff68f05e14b9537cbeb95929cb15d8ce1ff28e3f596a9a1f2cd99cd905a83c6a2dc5a04890f74fe57c6cb5dbe14c4001a6f0e0201c9ec2ad91a689e3813e296f3d8f3110268255976226c89ae282218ca3705aa716a4eea265d30babc9743e1aca69dafd3cdca3cfad92742f2dde9c62bf3be3c7d064f382ee20f5e746ba4eba291e8b541f95fa11df62a1968e7800e1a538b40b3693027bd9b680f5916de596736c11defc9bf4def7856d54ceca94b43dd05a115820426c8d30fed10e0a09edade1f4830f19f98be36da3c8237f2d7051c001aa4b1c889852db5b0ef896ff5dbcd01d525d23e7c1ccf8aab0745f997113f63835afc62d4b9ae47274bfea366fb762d08cea339e13f761d65e8a1c3ddb7d9c7b3f61ddbd20c3795212f4395ee0f8cb6de67e9cf98a63d588f1df490b10c0d551c4964332774dd3d1b2ac126a1a2963a80fa9cd08c19fbf8901b9062b6f7e7436e81faa0ed312b2a738b47c3a2fa3c018e1da39bec5d37bafb557da0c33cbe446a2aafb22e6296008a0ffe9fe85d02d2c0fd916e807b5946d6fea8aecf5a5d66242d89975f4b4dd14cbafc70f913bf85fd4e495d34b5a574b7da87661bd83b5c8fc498337049ccdecfdc4c2f318da7169d887cce2964177793375d239d395b8423395dd80c7f66c294e3141b0ddc1db54e16435e0575e9a3af8a898540f7426405740508178ef120cd999b97fba1e477577184809874691d0f9d28cef5644a59659c8cc493884f345ee57f9a116b5c29ace3aee0c12c60e250d53be431d17e585a67e2831b6271ea962bc2c02e87e134e9ca91e60ea9572072606d18df2361eb79706b77c60c9b3602ebb7cb9ecfab7cb4a4425d7fc2e116a094fe0096fc0b330fcb6deb054cba417acc8f493cd70383408440b37277a20fdd6555166f14edf2ffd6d43f0534f4d57a79d43e05caf522b5a5081e856b1845d2d1e5fa791f8e5104a40c8f4b278bcb23a7239e21e37a8d3d8506c78d51f4a998e37014e1eefc5705f3ba18c5a89de80acd4deceb105861d8884b71337b618439a098c12622bbbfdb9692987c3570bb352055bcc788e17d50de2240f4136684faeb7a6b52bd2158107f732806bdb99eba43e010b5f3fb1dda6ae96388aa751762d84025fb46f98f40bbaabbefa29d1a2e534ee6ddbe1d2821712bf5bc9161c126393d8f3de59456febe22346489a6f53b88af5d5e0beb913719ea65de506a150cfbbaba9e9e92f04ba8a44f54191194650434f908d0424e5e3ff3c89b6d31d8bd1c1ab350035ecc81f6a6ea4048cd910a17b2aef0057bbfeccc9edec6e6d443dbf0abef5d54789e61703beee72400778f5d15daf72832aff9bff70a150d277ad7ee121e784142bac7a6051bc2d580f2169bc58d08ca44db3c08fe3df5f914c7a2153958c66acd3407fe06af7d1d9ef3962736cd9bdbbbeb4caec1b426b2a8f275ff839233a774c70932adfcc619b55977ea8a7c88caa13eaefd286b0ce18ce7638f263416d013b45a0627fd50f869f7a156f953aab564338a12bea862d6f8f1ceda10fcad6cdbc95cc2d340f8ebdd56ad5b77ea454d07a46fe8779bd7947f99a51034a1679fc40400b4e7f090c24a8bf710240142e33270257b2f115b92ad82cb508a0e575b4f69549538206a93bad93e9e10215c189410ce47259765527dee4c74ba89d54708079c57e1a0b55659d787578ecf608737bd668c989a9d9cf12c83e0d47a6af8278e0242e3adecb838e6659f48a47e9b7346fa510e2862aea5dadd51ed5cbe2e37fdd0b22f20f472d829188b500a0a0ef823a2bb0c3b55a1e687d1d385c6910eddb48d0738700e0259eb55721567fa1199451c18e87e0021add103511c74d64ab51ddb0b0a1567fbc4d551a1863a185bd02439cacedd6d63fbae63465f459dcb0b5a956d850a5dd6d85724ff6ceff3958dd77bf4a5253c8542fcf6c395f4e9e5063c0d4774f3adbad0e53b7cdce27310c390f8c4a9c9579033ce421aba389722d7d540a815c5b10a83067c3075ca8a09f5138996232c0c7b9f501329f8bd61eee7305ca1211ea2d319090176c24aa0e38b739f57d333b444e2f35c9650fb69bca8e9265a99d6da971355329c3d786e2d2a4543b0ae04c13becd0ad3e5eb3e0a356dcd3ef932bfd3c843eea144d10ac2423a2629254932b1b59025c91c3b73eade23ccc2b2ad730253d52e606e6d384fb2447d5565675357e09a0ad668e60c68a3cec638977fbd12ee8edf15ca5d777179df66329039dc2dccb4bc6e884f6ad532f6c7087366d7417bab987363aeb4ccfc5689f414f4688cfe2099599d2033ff95b3f6225e75961017c8f656492da694416698fa29f36ab43e0c31b11d8ee6c378389cf4070ab14f5b3e8407c91fabcd43d8263ffc637e775bfd0678b01c8c5c176c9fa653e2da672b4dfbaff197a17622752769db7111385692c47caa8f54cb5d50abb5178350848f8a67b4527938a3e74417ea3eb11efb1277ab6e5c7d06cadae51dc7b49dfe331ecc585db2b3e4a29f997be50c7c6cfa0cace6394dac8d9f870de004ab7e50e672d70c8d88c906d2238afd397a4d2f11b37d46c06bd6aaa10d3fa642aa0bb7950e1748fe6805f07403e34803d903839c79bc0fc5ba22bf60551493a72e346438296fe6e84518e525594bc041145ef9c02d3239f4b317b6b019c35f88dfd5daff148ecd27f65bd1315c52c045653c8510013c64f3bfad89002bca053c3067be6d7c7be4347fb94ba4fdab1b2449f1dda3ef9f52d2937a0fee0458b9fa291849b7fbc64caf917e809f096960a2a1d8a11c0212fad03e5ac5c46e4c2f73127c2e52f8425b703f0451866610d0dfea29afc2dcd05cf58894154d445be4bbb9ca602357ffa1179653886c92ddf52a7208385e1cff8d8e07a50c890e97b0d0048a4094c2bb97568bec98c69649f42f8cbd21a06db81c05a661c55d00aa7cde16462e0b06d20be389b30b49987bdaf065c1bf5fc40e19b4dffaf91afe35781f309f483aa7d2a995fc5d8101467bdd4f56c00eb76856eaf6e2aa3ad18302684a5a7f38d850092225aec68e12880d92c94d59785aba3a88b3be59cf7be65a0779a2b73fe6dbf4ee2725da866b4f8d9ca92cea4b3761e5483ce5efd27997beff65b20364d47ff420cbd2b6aa2bc881abead8b0aaa398a580626427ddee8e64ec694b8587a3cbecfd51c47b7d8f4adae5a168b9e7be58f8362adeff418108a82ba471a78224b74d2ec131707d5d3aad2b578cf3732c1bcc7dd558f7ef4f04e07f5c16bec6042319b937effddc9a2a00762f7b96490aaa5c8500478f9b350c1d9bd726446146a02be19c2ba6028d1aab18a58377d4d04d61c3b612599bac593195c26f98f99b763a5d2e10c2d5e5a4a9634f62334ee2d0f6b2804ecdff7f73af48c931090c50e5d0049cdb7d08b59e61b2c412baac1cebf3bd61fa8523922ca18dd34110b1d050411398fc050c85490866fc2c7743ee28c6629acea00cc9c67b33796c890e655db5fdf085985d655a1ede302040a9cd183daa3f4033052bfca456f6275be1c99c1dda1a549633b4cffcd0601d28da72d5c1c149eed9f74e886df3e60d27f6ed1643d9ff34149c300e3aadeb6b0be79242d497cd388acdad4f00d4170954a16db67f57d2f9f6da9de0ad995eb3486b742a1118142d38e8c6e0cc167d895ad32a2a6ffe3765afaad336a48e307c93eadde7fef383b05412a1264a73f9e145edda75aedd1c6ee0ccf5a72744c9c5f55167b72dc051daa0789577a8ef71c6f79d0944bd1adfe364016fb18ecd1f29058ab9c623d7e8b04c3351dfa966d4f24e34c3cd2b63ee79e81a18362de55df63862e2e5b2e7d58bf28d74336f3aa1e6cd9eca0477a5de9e71d461044a4cd4548e57092fd2ff060237f8bb4718bb71b13babbd8fcaa78debada365fddcd319c8710871873570ebe35a5a1cd63d732d2745dc979ebcb88617546b6658f5d2248c77bfa7633fe96edff2657344e70d27abe0a053bc0de491c73351cce02bbbf69ffd75c1ca95deabb39edf6b62dc077159b0e6fb5547e411019f423c2b533ebc705a12ea8ff4b28a10ad6325d26837843317a5af6193c5a43ba26d08c8bbc93cb0a7caafb99e172d8074de49d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
