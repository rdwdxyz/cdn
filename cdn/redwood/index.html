<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b76344de48cbaec7039db256d09293267e38ea7fec912ece31ddd88f74343ac034baf4225a8170566c46a7228852d5982e9ee838b24253b76e5e7f0471df5dc463098389464da40ead89a0fd6803dfdbfc494b38ba38397353358ab987fee0ec38eb8ef3a07e6a79dc9fa39fb2c38d5e0c542ac960bddd6f4a3d44086166217d7a8c8ca4ad05b1bcb37609865226f39d121edf47874abcdf09c11ad032c259e1e11e9ca11d673e43708c617404b1516366f9ddda24b986838db432a29b86035332ef044b11353b261eec6d0aa0cb841ed88199a72f210d2a69b7bf1089d0fbf7ae8902c126a6f0242f4d882b826c4bc020478d00ee4d0e7c49e770ab331e7936512aa5a6c35b7be78cd17f887157e39a440eb5827e63039466049c6ac5200b9c2038798306e1b912e3665327fcb175713e02732432675c005857fd5fd18e4e38b01d5e06d80f4634845251b2118033f51eb7ae58dddbe8aeff1a8f29e57c99f8e11cd3b13b626a0250b5e2fa4410090b2688678e4e30b18514fe308499a25833bf4f17f54c1a63d0f0c855a56b6f08d80349b0894623faf630cd8cbc3e812dd07c3e756c4f1f263184c9ee015bf0516f4179c8d130abb72188f23229cc48ddcf5304305ccd89da4f5ebe4b1b1c495e85aace65ccec513ba88ab99a1b08bb30a68b749d410a087e23efb1568c7de9a211665a37ad952e518d58db5647114f600e1ed54b95e88acedf597613d848a423713cba512d3e2b7a20a01a9127dfcfc9f55b65711e39ce588603c43d4ae089cc9df8b40eba7985657ec729f5aa1ea75f84da4eea60fb1f9ae41b7257d2c706ee6fbc219c7c680972b5c448b7ee688c6e7912246e8ea8b82544ea227ab512e2b3c5caeccc98dbeb75b627dedc07a6630c74d255a94b656f23a4a2a18ece8834a9765354f71b3c5daa80279c57171553987ab4aae8ff4cd7f0abc9f405f51b97c0901d0f41cdfdc0894f755f9d2b7f98439389e1163f85cf6deb2ba7f181d6b4f9b00d0cbc6cbd64e07cf16b36c1366013564798f481d11b9af13d36523608204b1469a085ea8d92dfdc4a28c1632e07200e63592d8a3d20ded660f3ff4151f0aad6a7654819fd8baf498ff6fb0108a6b7c1dd32bdaa2cf0371b9ac413d074a5d8e2784ca8a24fd8dbc5fff5fe0843649ba19143c2309fa619cb9981a8293aa16bb0b38784ddd1cd4cf1a8b43c5726525122c6fae4d16cb05c331928e72ebf8f2f3405d380a02e8f1af75444efc01a4b43fe9d85da91f9bd950a42d0c256674fb76bf5fa7d60a5c0cf700a0b0130122bcdf02e45d813f64f51f4ec24bb5cce1177cc027bd094682f2db579c1f590f72a2ceb5432a29a129adaa82acd5530da204a9722232c19174519d7f84726e842d8316b4bcde5ea53513266dfea820736add9a35d7011bbea844b8f692d4efbdca768a845d4e139a6b4f6afc6195338af64e75b7cfa852bde9ed05b22bf24851503ade4c580daeee9a8c4c4e41e1405da5fab73d89e1270da2dcef365dc5a32e634570f6b07dfdf8c26f28a5ec72259fe569678bea971b93c64fcc2851b47eed9990b76735d108182b7e1014aa71b76e84936c1fa86f9be05acbc58ee35184129ed67b6616244ad9f11d10583aadc36db82a8dfd476f31655f2c2711a8988faed07c21734224980e18dce3a2155c1f359e89b6b77183757d0d40a9cd845fb7736765d47a283e97b4b357d8b1e91a96152e981afb7a7fe7fc2c01fb8abfdec662b8213a9237e49586d745655188a126c7946bcd0d51cb4714d38d576dc2afca426a97ca1b7640fb21981dc394627ba41c6790eb305157d56217d79e92b72d39bc3ba07abf7d503a1ecc408dc88d835d9f8189aa5de8a5b592ce85e7f47eb6523ad2135fa446bc797216a031aaedf81aed732d0753cc905a66b9855d36535e8a320c2839c97ab534685e14d3c527fb1faa2525e1fb958abb0d0f4a03acefbfd09fdae01f6f12d689b8fb3de09369d0ec60c90839a1de668bfb21b653533c5a0fdb82c30b5cec5862be833635a9f4bd5573f82e3f2489c0040dfe1407b5965dd447b68ce8805a78fb2cc475f2a0ffb578ea12957a9549dc9c52bd9aafbf0bc1765b48445c8247e3e4248c0f0a5622ecaa06d5dbd2b41007bcb969eb6fd51e77010d38cbf626a36a2489505b500091ca7962f7740e11ee967d4c144e55805cff6263867eb5f81f8d86f0a4533c7e06c1be08c247c6f9c63c78f915b4855b3b7239aa37ae40a084045d8f4c7ce1893894ba1d2fdf8f29d8d1e645ee2260a3a85cca1eff735434a00d2d1e712a36c2fa40f6bb72f61fe778cec11d215018efea942ae4d7b68728c3c5e100a4d58b5fb11a1280f091aafacfd39fea97cf63874bf7cbfa5e07070da695be89347760fe393ab251e7afffe1df00b3a6e63026c10090a8153243cb618224c235668cb5fbaa3af569298e937241a39f9d6b28a98660cd3dcd6777c3efa39b390a02f51be0ce1d32bb535548e4bdc8e9aa8f00027b2b6e093af305dab6944f594c2495ee7c15c4e25c1a089f42e062964fa317f61c1685181489f112181193f652fa87921fb29d53dc93057162a94be06698e7772803af7870ba9fcb1291f2395a03322d55f360931d1f707be7c7d63845160a73ac7ec550a5ce89a31ca5c3500bfa4556fd638def39f67f03c38a43f0da5d0d03056a94bc45ecfb67a9d39af9d808edd66e88cd9050259201532c198c3a220d7d3bff110a08726313cfda866f71df3e065e1817d182b2929b55653e5c0d36eedff57f2c96ed77b5bb7e6b02eddd43194d9d10c3a9be6de47e4a7e079ddda8f25032e283397732c7f42418a8cac9da09e44983c93df6c0addb7375a4656887b8274c04d13b09ceb945c25ce3c491819b5f31a86b3529e53f6ae7fe7a136cc4976f10514a392e7aee1df8ec9ad945c5678cac388eac258cadb9ba9757bc6142f338874e7bbb33851df16ba4d02e4e1c9116b8a9ebd2fe2837c1937b07f408f68b98ac9591135042af124359af6c36f11bfc9c66346e85f7d2bb7c859f8187e16dbee246d62020310c29094815313e9f16aaca9df799fd1503bc9ba3c465f297793a4c82f59895d328d674a42bb150ad552e30ea4bfabf22126bd138e3e481422466235a83449af2e4135c84761873e8868507e61b6e7362a11b76e654cc07efa04e7a0b0c7407d2541968163c20538f23cc6232267cee6f55fd1a9f41f79eebda4726b06cc405fa171a68d7adb56054acea058cdafa6d51928d01867e179e12aff7c913bef7074ac38197866d9b5f3875d1662ebeb9ed9baefb277840d013b56e25b724c0218e04892f47def099c9c76fac369235d68206dfe410a60d8fd133f80fba35cb164b5ef5f163d3c4595552327c24828e706084c6a53bf900f1e4b70956bc534fa04f1bc43dace0aa21d6553a143fe129d6c3147df57171276cf20eebe27face516c049df7c877d3fb70f525bd4f6137dac289ceff92218b03fc3adb5c12305acb09e5845fc2edd136b9ff00117d1f7337fa0c9b5fdd1cc5bd28e2703ab720378d4abcbaa01775f94d381955b304f90b4fe272ec8c37f54f0326be28947300566232030e761b196e19f8034e41f2d81eb9b9572b13cbbd05f6cecd79adcfdff02c6e3b1979e9954799bfda9d6f46942d3c8beba8610383c80af6f219e39e1952721f154d5d04e0e8f9ed5b723acc75d9fa13a2f429ce35750b4c6a88532b307d16a89c54663dd555419b66cefc3c8454bad315c6a6281f69884d7ae4c8283ffaff7db99261521da036435cf9ce1c3971acaf11ba63f3e25c6b352d06c24afec4c4b335f160495a0bbaf91bfa51719837fc96de84446be04f7ad6909df034c47e4c73c3d7b3e747cf607fefa2c3a35e153c1b09213a3bd0abdba62f7676f12ae3998f9d8130057eaf7cb0cc5262a859ff433614fc61e94833597f4c328183a99dfeafa8d806fe7fd1ea3076c2f00db06953d6c1335f0327e20e1bc524ad6eeb40772a13def0b4a4b0b12e5e70ecac978328fc0aa64d4797e491570f795c089540d676a1eedf9b7c5c0bf6f931d8179dbb6a6761c96cf40fc73d8fced6ad5490cd846316b73eb238fcea76e6fd1052163a86c4e197a110f7efe5d8cabaa1edcf4558f00a198f1f4fcdde5ae7346b181a5da0178ef4c14ade63d87b8cc64d2e82e0c934d581dd8d4d74a381fd0d5e4d925662a23b3312914aaf1998d7508be918f1948dd9e73ee0ad54b5f15a69ddf81a188e298e723ed20bb28af6cc0763831258089a33b4401ec3ad5bb5bdcc3965e1155156ce6df80611d75657dfc439b3b9586df93c3d58b1d9144845857b943523ebc005af3f21529633714c23993e224105eaaaa77443ddfc6fc859d3848798e739fec9217c2cfd56723d0f4ffffcd2b13dddb28bcbc77da9ea646285548f3efac72ad976a54c24c76daaa62c269c9ca8d28eacb4a5abdcb310c3c0df9ffb79cbe47c7b78cf1b4d7c3982828784b3fb29666d4d79912659246dae143456fda220a3a10527543412eb17386253126d719780c0c1218a8a66c216b8fc28f46a6cfe31f871fd8cc80518ee28526b753105672cc535fe6bc636ceba8a225ba972bb864eb3b3050533726c6ca27b9328aad1537ddbcbebc8677eecc55ef0731e762f9d5c58050a7d0748bf119bcc7c50d9455d8e762a53f458b625d4c09e8c893de9190542ba60c340fa16bc6575dd0e90210f733c3bc29a469e2b6505575a4ef5c3360840cfa5f4efe7fff3c8a97ec2cf195f1e40d99929ef60f46295617878883784c4b0bc0bf7a0ce855ebfadc3875c3d3a6a7de2609c61429a6b74345b8cd5e828a55c35d1c976c13a3f0eff84d3ce2efbd11c2dc42f12b275a9f13bf3c89ec85eaf7ab7782ae9d61b2dcdc819db4c30a7b978925429a7855ee9c9d3d16ff65a7594ece15b0b89f9ea57d67d89fc00ef3880d76b06a98e597b92b5e8bd4b8a1a6da86eb9f1cb5c3320967c19123cf96ccf6fb4bdedbf602f14c5c727102987eee7ba6beabe55f447d67f99e3d7886a02cd1af42a3d9c73a5abcd960861f6ff3ef6f9b9bea3c1a93552fcbe0d6b14641034096702213c690f10f9155bc3ca4a73a4556df249defac196e6f0998252f7d8c887e17e70945c3cec37d6b828e6227d00e578abaf743d7002caf26911104dce2d15c23493b740e65e0e0f8b9daf5cc5de1d11ed7bb412f687b9a180c2caaaf1ca6d2815e3830bd326ae1e0931eccc452320314a6a8d265c3b5b4e3c100d26d9a051d38189c77042780c8c274c59c6c968a00c8b4c34f703e2e38ec1fff3b86f86575bbabde462817b53df30aa0b09eb84bd6a21e7412521c66d19e831ca53f32fb9c469d23f546ed00dc6b9ebe86b9266d0a6c44187a2941ff6bd182b2afc3c0a17053f5e2234a61c65fa00929ada2d849d2448f4da3e08aefd98cf59132fcd0d825f8b3b495ad4785781bd8311dbc415aac5ae45b93bfceeeadc625fd9fb790e3e79087d46e67ed37b4966c839015a55d1d9ca51cc6dd280ac26476fe28fd382cc5fcf69960991c8915c744eddcd3bb08b4c95d307823e9f745e829c9bbe358c33e2f74d5ce29e128010c17e3c75b3f677cc06f2f1aa9e4400ba7b93223199a0685419add8650b95f81c32e55568ad740f40fd17d0d1e1c67db6797251ea165c5e0f96190a4c2dcd17f8a77e370eee27b03d38ed96840135f7c826d21748f4e8318827ffad08f49b78865f1a9eea8a24e7cc2436af9010470319d0f1e914a62a2b1732005a23d97cef0a53c0fd83d684ada06c3e62ec8172967679e89ab9d2506b3f23ff754fc3661a0d6d5ee97b94708b47e275c81255ddd67a1e89337b0db3fc4ef7abcfdbf6b1fcf632c516c9b1ad347c761aa0bcf686b5910121cbc26c38f59b9a4d7fe0f7da4c2cb26b11588d7bf1b06c1e8f2835c88eb0e25c335204a02b024c9dd43ea9eb6134834fcb464b7a035fce4e86a9da49617cddc2dd55cde134dc3da61d566be6bfe003b37279a6e1b279d92ee3a79a0589090bb03c39f62918ab4392070f00f974ce571a8d007eda16d25e2d3e2cdf4b3b48d540dcd206844a41e33082a85c245bce384e40baa755b634d7c6411dcbb1b8f10ab005357aa69f12bfac2b82d1ad0029b24ed9bf3169d0d623a120ab5ec8fc69db35efa5d179a48045a53485c99cd1eb97fa68fda490fe23469646b7825ce02c892052a0050e1204c3acb1cf1d4e0b7832b34e96826f7a15e522c776bad02332ccd4786879a992c65316a7a6b72e1a8190010abce1a18fecfe3faaeb0a5fc7f83ad6a586c955b95030cfd5a2e89b75bd983c7b2235da489d55925692815113de9a2cff5b5c5425088497edbee3d3c1cb9a4b5e0cc401fad39641ab8b70759b64c017aadd0701daa65bc80ba3bd4ffbe4600136b2f8b637b89a41ee61127d8e9ecf06f5726e366a26e6ca5fec6fbb99e49de7bfb8bdc8e082626a62bb3b4ba55ef121fa6e0d8ca20dc5bc14501b40ac23291ad3c86735404325413c5a781b5a4eabffb1fd36e559462fa567a353a90f82325faf0640b0c32246e54f44a743dedfc7aba8d5e584e273c64956f24133c6b5d703d0b6431f29e4ea47b002b8f7eb1570e36ad25fe9074e0db39d9e434726d647c09a90858a26b96f38f435ac1049d8f5e01b1e47c56b20f8c4cac2a7e80d4220ac14403edbcdbf0aab27347badb87a43d8ea8933ad43b9e458f76da7d12093452c27d86a2a8c05d49f08375f748cb1b23c3b0d919e3edfe21560d77aa0f8878888260efb14a22ce9f8f68949670e4ce45008f56a2f27df4834e38bbc72fa5bc3c235d705af2b57e6df40f4fcbc3e78b829e84f1039577388890dc0508768fb12239dc15e4b6f43ad418dd45c786c9b3163d87c2e45491cf929f11feb888d6903acd03adf47217d1b9aea965f18ca0c3109b566919eb3d16f5145ee5015c24ed43e5315e035f12f60f501303d7091195a5e8ae0478baf7f7083e343b48f485f05fbccd6d1011bc825a1d26859267d296a652f7af3f10fc2ff5a41b71cb79db2345ed53175212dc29ad10ac43b6e819b180cc23cc0bc355af3978b4346651a8bc7be8815a3d596aba24e0d1c94c86d906a09cc7d9d5999c0b09d08d42e86b7b5bd3e3463be092ecdb2fa04f6d7b80256629868d27c26eb016a38f55080d67b20d2568a6e0d993d2733318d63761b999a32764dabdfedb0f92ea6b4101ad008c0888c980d9e0e3a2ae990aeaf9c75c05720395776384e1f326d45ab7bfa070879ed9c452adf414ee64ac67bd37fd08debbec35325a8b5942fbc0d615f9fb866cda333c5fe4614b33b272828a9af13eb6d9cc9da9ff1c43c72794a8dd706faf09efdf951225d924f7886cd1466c69c3754c40879902c376c7d6277bd279dea6ca159ea70c3a86612d283128987667f81775260a70a5a4829dcb135938632e5a9a8e968e550442aeeaf14d4df34d1ce3ce541d82fe2c565a9231716bd83a3be0b9868f3d1d802027efe685826b9dc0a258e5b0046bac0cd73787a5292f5e418ec0f0ea1e3c0a8856293b175b47a512af3b14462b5e3940cf5445b181fd889489d7021156d380be10ad37c370c79b6be399757d1a38844d5a78e7bfe9cd72d7345733d13b9c1b05447a2f9e04a7422bbd30e25a9a2c5302816fa8b74efab886d4d2641696ebc2ee2ff7c201ee2729d3cc54aa6e40c3d054072275515490f350276750b84b6086206da96e3e0bb902eb4b2c7a501b39fd5065c162f91ce21a899f9194127e208bfaea951bc8fa906710b161db7f1457d3bf0ab37d334798a23e6c46ccbf5a31b39137a2a76d610545a067d68644a9f612b18bcf2ceba2a743cb3b697cbada107ca0fe3237dd74342e828023e147ff115a207e05685229f6e2895394cfc6628aa2470ff07b75364f1e14b4d6611d526e5e3c28a7a0449f5982311575005a69f06563a8a30c7403d2ae51cd4dee467fc6a9778813e17aa2e93a4084af0549f508409b979491d42c0d9586fb6f7e53522e1bb0df95118723e90c234db3a2ea78184bd7523fe19e055baa54640f612e258fa8e36086b21e20d2cf1e9dfa8eae99d4419999448dc7951568bbd17ca1d0a21e51b5d51eb30c9aa642e744c950b8b3fe3adb988d5da582c39e01ea7a68dbaba9c42c00e673ab32540b7887239648ed25efabe7e9a15e91a13849d252ed85ac87ee3cf9af6059cba56f0c2263c0e7a2dfe6523bfce18ae21e39fe35d1ac670e82dbbe02830ba7ab17062ba39a791f2932c485be13e87ea7d4d027ad5b0accf216d94d161672b14eabe1eb70ac5d063ffc714261f3d3d4bd3a32f57ad72d5c3cc602885ade9523103b34cc382ee2263d203c91a841d6ed32d67a6fa77f876dd0c8e10066afc0022ab6ebe9fc9a3a363a19a2dad5b826333901a257646e607b3846a4f9d6075fd1b6d07ac9af6c53f5c88e31d7c4eac24e3b878b7e6ca197813e4181f3737aab217db727d5eefdb5c865a15698e8982d7a4e8e6ab092683b437d1ee6b7a83f21fe3abea4f6f7160b5089d4a6c1ed5b29200907609fc9df434d9da2ab59afbaf01e96b7e20f8df2056c5e2fb39c20921124ff156e40e0319d80a46fd3847e1b6db8653739e640643dcfdad3b748b11781492ae9554e5f9b48a2cc784308d355bce23071d929ccdd36c9ba06e31fd0ff652845bc8cc0f7dab12a5693c645af0152696e290af9d687948b6dd5584768340ceac94bc14b749f73e2caf5920ec054e752145f2c2f858e068a505e3bc726d8cff255a7bffa0ddeaa1827465ec8bd77f6136dd754fc758584df16c7aac60b42e0e999ef8ef70cab94e6a3426fd997ded182160eb36452c78819766b7d46eba4d4cdbc7cdca6973b761c898f91e25717cadcc2445cd6805cd0ac216e4048d9cb128482c697c21012f5bce40219c31fb670f4afb2caf9301d81e4421aaf1db6b8977ca1f8128e91711eb8282bac0ae76cf98e2988696261c5d7404c94b547c65dcfcc52e7b672cdb1597b3fe2e0bd5ef1fc3479bb9ab4322151e6a9781c71a781b6c39bfe9bab5c34d73d639fd59f0f13d7b051b48556efc4b7d9b6cd6c84690de6af09ba8f268e8b52954f84df62aaeef2fa35bf093b7891ac5b8d8f1df32b488a08c59a6854b66758a66a5e4afe6ca6ee4d809177ff30ae1d45fecce9844a3640ed4d5b717f954224cd8c4d4d94ca62c7443cd5b16526b534e2cb913b04a0f61470ea98055ccab238a4beb412cfb4640c83120d6f513f8f44d35f8b9f0485325016214198a37789fd9d34728d0c776ac203838f26047ec4b8a363f3cdccab8ac2b73c5f05fe27e582ee90c7d6e9892412bd758eb82967ed14cd8efb2f3ce8e9d3fbb2e8357c6839378cc6fb964bf840c2e07cc1afbf6c5b8fc661038d106fd2658734f46a382b3504e809bc80b49a49a5d7585439cca191fd34674b4d72de96ee6f8204840114339b7349d6ca1707d8c241546d8ae4f1b1e6603e04005b4c750cdcef1673db39d1acec2adbf6e017fafc0bd17c879804dc6c7cac7624efa69dcf1555a9d40965cba668ec5d9e8532ea64f79b0f4de4d975d7124124c9c42d35ff04de7b61e59a1c2d0b53c8cb78389482714a96555bfdef1a9e8dacce063fcd5bd03d659a49cf08c3e105661b7cc63456ff5a9ea6dad25bb762e181e089540ef5c7fc15c44dc9b2e0a0e90a924a4584c1b0d4d2bf88dea568f3938dfe8d1fd63c7381bca3a84565c5e819e83deac5c565ecfd8559fd1f8bfc474be6b30036cdf7cc5290cc4a51ea239e9d97cbd640ed7f97415e16876cef4da559646f4ecb305540fdca8f6f1159aa2d5b1296ea5de8c68752ab04de95085c4104571e098cc134d597ee7f0848b8ce896df3420374446be527604f2b049332bf0065a2b054b6368488c4988ced62536e8e421199b1609a9c1628fd2a50771201be142436171c5b6e999f31ad1a358062f6a7841fe52facfa2506a1254f062f1df4553afa6f9df376d476ce243a91868bc2432c271fb62cdf30ace0864ae9f076708cc17cfd1c7a0485c32d28a399d55f3997abdfe5f50f4bc769d71016514784bb9c33ed36c48d66b6b2d79606aeed31d8971d112daed2dbe856c635836867ce33e2890881dd9b50777b3fb60297fd99ab9162d222a99b53d466ce033e62b544cf6e863524fa53eb321b24f795d0aa4e4eb91296519957187c54c5475d96da18c45de51536f8eb24567edbae88cb8b03d1d2130dd16b2987cffac93f865705b4cc043d4834c806d6fcfe3a96125be404d197a824df8a5c35b77515b98d9d0eb058f07b7a307ef5ce93873e157f5d279fd9dcd1ac83ecf9e5660efc404a18fec33a9b9b8bd3c060014a9b6045d0e5f0e1d30be83575785a9a36997276872f767e3b1aab01731ebc177100e9479f3791f5770275fc0c472256ff72ce03eb85f060bbda740cdf50ff34b1924f568c666c6acbc7d5d977d230333c0deae376c1b364a786547dbadbfb5cd453402da6ff81313f29abf939c843fe98448b8230bfe230acf33170037f8c2b41a848f8a3c0e0750b9b45371e71574101cb49c2a5b169f2e8e06fc7367de72617c8d47ab237e57dd8517432f5505dc6ab768d5e01f38e4ba1785b79f4116effa13444100601e22ad20db1630e4d1deb00b8514a5a3012aedbd394b07fee79c847114ef65d679c28c5ab82418d87b7b3d7f1d345361b2ab0156ab98237be8a923365076d88e1fee904b52ffbd9439d475522ddf3d00df67b18c2db1cfcc4ebf2a7bd281fe361e65e02410ad6e1eb31173e7c162c4d5bd305ad0b2963d4bb2aa5cff966d91598ae48c72f296f42943a97b5eb0e653a61901ec57e2330b6af8251c7a58533428a6a761599b6dc97c607eb5997b5c11ea7ed4a3fdc87bf5b410c53858010b2a03f5fdbbfd06011d52f2751c19d2ea8d7eb5d49f82701235209487e77b8a634d44f0c6a4b2aab0b95ea8884f3ded44b2c3d8c64013d8e51d26da2c7565868485f87ac54268dffb2d4f44b256508ba8e6af9f6d711b89f1651d0bcc1672655607cfadf7dc58d9193f1ccfcfcb4d46ffa0b066bfba45df2dba5383a7cb032b75dc08eacc347b625e6e60b9bcf5586838ff7f98c9ae9c4dbeabc4310ea0f0f0a3402f298ec657e83ce6787feea5b35df220e63b6a919f45a8573abca0f3ebca2ffe69e74ed9302729b95b9afde641814ba6b48b0ce8b04d660e60b24217b821390f5c20d498f462bdd5cf22dac3127e6cbfc4ddd8e525f8d43611509da6e2c5cf4adae73c0d86db24cc88b3f6180db1a968ebd6671c96806a73f0d71b6b9f4e274c19bf93059ae14be3cd35e636628ade9fdad69942e675e90f38cdbb1cf39ee94af5714eb2c53c99e87cf9ae0c5ee3218f99e4dc3a073774363ecfa8202edf467eaeed5f87a2ff8369cc206c4220a4b8b26b3c13aca625c7dfbb4961f7abcb21bb67a8aeebb52d06a96adac0f0cdd3634c4ee99aaa970e995ed84c8c274e7b169d959db152cf1f8b306c5d06c075b17c3f7eaf6f525d617e0c3a48fcce05bf8bdd6debabf84ac9b013d4693580f3dab76d5516b2bf22ac181de9b9518b838b292886c60cb67c18dd98502319232a4b113876120243178aba5f4986193a63ea3deb17841d00dc864580c4089166c84d26b31325f00fc73949391e9eb6fc371b6d95e98d4b5800cd5712cc23c08cddf62df3d25f716510b217699102c416e9840855efd51eee5d0db37f01a571104cef86c23413f5497f1a308b9e2537077e8d5902f87c5bdb86c9e3a412dcc157d9f98791fa92903bae772d2e22190566d892d7bae167792ee90f7e21736e404cd17aa48b8f3b82859b87938763056b846240fdefe3e68c1cccab4f30bf0365cdaf49ffaf370b4a77862c649a5a8e307193b39f548426dccc03d63894550820435eea7dced41d41f22af82e9f195c3aaaf44f207b0296c7ab6d595ab239b32b047fdfea0067496b3f7edf139a6fc47640a23e4881fc55a6618e4a1715fce4b33c047adb5070c2b38b99a278dab63a13595d4fcadc43522f1cadc7f59ecf704124130df95b9b3845e6cc75e417fd083be490b808d04f7882f3ffcb7fe4330fb133118d5bf17ff2dab80631d5860f0177c783a61aaed2b7fe3d501e61ee9452528628af68f5ae7ac5b7327306f3a29deac87d6fb645ddd11802e70d9dd209437d3c048c006bed47765a1532a3cbfaea43e95facd456c94901c3b1ba7c0a4de037519f99163a3ebde9eb5a50fb26d192bb38b64416a60846732ba02c17acb72694ed59035b17dc6e008841888c58bfb8e87c5ad5c6543c298d10df122746439822fd862ae71e7305bb1cdf88b16f0227170e721ef66076bdad77bd09ecf4ba8c539991ffdbc282e3582f3dec7d6b1a2f2f390ded0308c3452d8d1251b6a8b52b7551a490e02629cef4c05785a09c07da5cdcc4517f7eb97e935b3dfb8d230b95624ec68cde4447a9d1fc0376e55566b3662ffd10999e9d7a00ef2dd589beb36e9bff64907e71ed81eda44bf587826b52a6f276abe999a5f6e6241bd030cf50a4141bdae7cc52c96f1546fa224f9115a5c1a6122610333f775811f5c364e899e47756a385a7f4413579f1237a35db1ddb4d8e9e540a9c62cc0335c5335b6e5eb10e1234a126adbc328ff0f902b4fa8c1d95a40b8cb3aa836f3b0c81475d09a7968968d354848ae87da454636ab44980fe382ed3e52e1f4ba814d32a8951b137b4f20752d078eb847e268fe5b9b96af58ce1b678ea1e547ae7b71ff01883a1b196d5c1f709a11119d9a3f16096edecb00e73857062fb30ec0550bf9bb74dd2ca29bee52922bdd265ce7ceb1e7aecff4fdd740f2d20e774cea9708dd7d0670bd754c0f03a29d1a1be6d5a932468feb43d15f940c87b460874c6367331d49eac68c948cf29da13418a3986e56265a37cd6297c478f5e8342b2c1d2d48d895d797b06f3101624379f673da60316139bff6687271872eb5b7afa564808ae9b611d2eb7d8b28e1ce37e16cb11f635bd1880a0a8a56daa577bae9fab7cf7b08205d3cbf169fdac5bceb913479af885a1cd9ab4ac3c47daf79dc0ff84e7693a78788ac1b8594bed90d32ad7acba408996b77746a51953da5ee48fd10f6f2898134b4fa6ec1278887fe7c2aad599aba202e64b33f915bce0026c2844aef85b9097c19fc916699d8bd610cd531995aadc85cd966de63a544138a67d5414a0bd01e790a7ad18bf48f8ad7f1285a4134c24385656b7207d200875da138ca41a32579689c06a2940e56dec8d67bc638c2212b22036ed96f809589aceb5ba2f84ffe8bdb8ef67b69d20c1ddec2b3ef92e026130176929db3fc9c35413aa897a72b1095e4542531552b2b558a83b5f9decc20763ba023534e17e8990eb049fc44555ba022ce00f5867c234bd2cdc1f2dcec046bc83640f4b519ffddf47200d86868e93113542fe8ca4722cf5deacfcc94ba827fd6eb719a67afbc21fa2498e25def3d61ba7b0387f0f237388357dd39116f7eae914df7bf2a7b1287b935ab5cc0030d380a1469b01b26bc4fc996eb750fe39ab2dae890f9f84f718ed687f4c1a71b3981ada3c0ae63194811269b242f93d712177ca50a621d85d6825f66989f74410ffda024c139ce09deb8752c43a18f224306232ebe4042c9670b48960a41df0762ba16f08532f33a34ad682efca5878f62086e95534991bbcc06da42457ac2a51eace9c08a1fe93d74e07535ad65694b34545e6ee7d9ece1ff51904f949ab17f1312340e4db3cd1256aed6171f475dd72ed4291a09dd8ee22060649bb755790ae4ab6b91df579387c18d57c96e257449303b013907b0d70452debe58ea164521212ed2e2a62e53d71cd3abdbb698248ba2d244a82b91b18c3c199d348656e0f90b05bfa2d96179caf7efc48f53d2009b938aa4102636da891f416a2dceac7ca8db2767baa217112c95dae48e4bbefd8eddbc8224f7f57412bc6a3eff0a19e5e7ee0b51973e4cf5e24111fc3a443709093b935371f30e8c923ca7d4110e4c1b07d6763db637677064ad8779e0e9e2cfcea112acb9c25bc4a6e78b813cba4eaa9bec5909a912b5c46a662adeabe24bbe8ed1974ef591b77afe1ed05e238e4aff6434ab5a3691a039be12bc375fb43ba2f467c8cf4f945bbe82ee137990cdb51489dfc6c4a217ee6be3da62298f7c54297e642152d389ef1a54cac73a598777666cd3307a7da73f2da6d0bb28d7da460aa5ebb03b4b8769e3d27eb0d3335608c868439c272f106f16a8ad0ced46655f3b358216bfe1aaf8ccaf17199c66292e29537bb477bcd3ade90d6ec38aa7eea936843bfb5eb40a0ccaab74522560dcb6854aaaa2d85985e56dcdaea957d378a72f16abc82e4d45929a10b07f5cb83be2c67ea6066e211701b2ea7e5fb1999170489636cc96d01619bea78da463baffa4ce9b75188a56b3a3874fd4ef79269427c787b9b5935ca96388abd58caef33a118535d2e820e77d774e115697b44cadccf3f4d58194d1276977288ee7241b02997af001a99730af2449757ac0c7917a70722da87fdfddda16a30071057404fa4f6ff9e1b63fa2eff91a5b7687d237bade95a4c3751b3477888b6fcd69d83ec119661cc4b29fb0910e8cf64515bc70df0f843dfcb77726f4913ba9a01930f7f9a0a97833b348acfea35c83b9aae00f4e7e2b1d9fb9bbe2024fcd45621d935c613c3caf4506c46b8b72ac4947471ac25fff9a9996cf1424867b9da5fa317d6759c09bd923e81450959404a1e329d9b04edfe5b803a10a5b6eeea96d72e39f8c7cab63f2e3237994b799127cbb1d4e0f4941834b032e1b6685f75c5915c9663ebfeebfcc35ae01c73b0e90e83864b55c7a5a5a07616fabc09b67db7197eaa1bcdc290c63e49372ae7765887834acef5c3e3c365fbaa4da80102ec40f28d2b1eaa2eb55def5f73acd3abf0c5c5db53d0481b7e65969e7ca9d42461a11395733708b9893bb59f1e1fe3994c4fcd89fdf6c5a07dc98b1cc6c8e44f785463583451fecc02e7cf42dc557c253c0f829e76c73b939dfb42d134c2f2ccaaee84db6357d9775bd2c4194a0f63ab863d1f50b70af8192b44ddc3975bd1e7ffb36855375c49361c2bc648ce8e993d0e4219fddad814a5d28d94488b762617bf2af6c3a409fec56990b19bbeab3522e6733863f32c4ac73ea13851590e479319d9398858c0350d33bd7ddf4a6ecff413bcbe0acd7f3a02c7aa4ce29883db7a9a2d48d66f7d94943bb86980e6d0f92769bb69d896ca812a1541a6c33bf0af4d4a4aaab48943877f5c592e91136fd55f9661dbb32d7d45b2b8ca0a7269f3263993dca97f17213ea16922503dbb1d889da7b05dc6004ceda16bc364ca2ae20205e3c3b157caedd007d69e6140eae3ec7fa029db1668a1b83c57eeacbf24646efac1b7271f9bced3dc6a9b9b08f05f670d02e631ad82b6b78efbe86b7edad24146444ce31610a31bab89a9b63fe683e7809f3438cc7356b39e9d31a3ca9758dd6790ee2012cb0abab3005b4ec6e1093f294bf278aaf71ac17ede9fe0df1500e57f89d44d8ebd3afe344180add8690e27b48c003305c7e102d3f18a6dbde9c71d3b94314b1ca8b9fda8d43b78b2ae22a927c3abf7830973f4db9dd1aff6dd8701448e7d011d99ea8139fbcd919431202a046727c78cad2259b3270defadd3a842392b917803b2a235022905cc7e7218327e0baa33fc53b0847ed82505dd3be7ab251a21fb15637fc07c287cb5793d7d7cbe0ee0430a5a4cd70397a730920b5897f592281a8486ac1a0aded1b6f33e25484e2cc0462fd008113b6b2385145789873dddb21bfdcb36f93e375991a4d6d01940ff7fc227a0a98a082779d42f365ca614310bf3edd415bd7391b911775b412d618aac8a15d4f6785970a023177b6eab9805bad46235b87d78f23ecb198a428a9a010b297dea3cc4310daa7f781c93ac57279e5f7f46c3c0b8e9570ce2bae2070558dd8e7f0bbb39998f3696af714ef0b95d54277b3aa7812f3409d7165adbf91b05692ebc86b0cdabca06a66d0abb93e249eadb75854738c88786ba4dd01e58cfe2c2ffddf4122c8d9d390a0fa3694a135a08b9ef1b16893bf7ca8d5328d047e605bbbfe6a545c597f9abf7c04ff8cd541d4b6a40ff276d8d068287ca7538ca134c75559b3b80f4a0e6f02f96156d11f881f211c50e98f902bfada3cae18476588bfe8233ef5fe18fe59c1ab09d18e4f20289b5f271aa416817b722ad97401366ffb0c053274a6937123b59ed06a5eb716c67d9fbb7baf01c040fcec9ec0f6daf96352b818cc04a8794e2393741a50e9cc2f588242f725cd302f17ccd8a600857b840416e15894fc627c4a68c3e4f21a37df42ba7556794d3a0bd6b59354d26901ceda738308022af5f13721db0aa9b43b62476b13673cda03292b6d82a6d63653ca93995b9017ecf23db2961d776b5e587ebface543672fb8535652ec18f4eba3583fce4f5c46c72978826717f6180c003d85218b3e7c17f2d3fe3a91a0a99c4b9d2960d484dc3370ab53b8568bef27e4fed9587c2cc583ad3ca97b40014c994b545bf20c507bb143f513318dfe9c7fa51d9d75d9349ef9395522416281964fdd285b162ee65ba14d46f32b1388a8d3cce11b792b1b5ae5155af6c9f9fabc71012671870e238e7a09d93273a77849a45de0104243fa2aa3dd3b015af587ed092a6745db4c0ba46007a04ff4a263060e23de7baa31b85014c2e0bb1cff382bda614d374868c0c00a25ee71065bb96aec2d41b52077b5e5144b4d1afa4c0e8691a0c485a3c0b1d31fc017f6708ad191c975d6ef38ce8f5858b557b879536b1acd77d9afe19c3ad70b472b3f2e48195c76b1dc1fc4e2c4bac234fd2a842b1567d2c808746bf0ffafa33ed60d9f5a831562a72ba67de40146678d20ea282f4f3e765c04187e30c72c27c8b89bc7780b21584a9c01ae828f105d1f528bedc238f4cb9cb40a7034c873173f7730c901f73f018ae851746374bc8cc890bee3bb544ba7494329387be57e7e81a577b40d9286bfa16184f08776ce55520f48fc8a8cbe561530a064314dda693ea77e82da79102f09fc71cf296e9620609da2fd8d12e1a8c04eb68842f04b4c9872b3506f0bb13708d50874ddce476b356bce13b9450de069636cf43d1cf1c80f605e8abd64599c589b6880325833670600cc2d9458effef697c1aa2d3fade902838af878e0df2132431a080b2aeb456b58ce8c8b6d6ba06e7254dc6d82eabb0a8fec17ec9c96c7464d79c849881eecf7200a65d2db8cdc32664355d809cdfd92dbf9eef4ec446576849c3fa89cc247e7c2724fa274711f8448fac34490ddc49132ec007c73a3e369b9ff3ee0eec3922f4b3c0fddc88d01ba7be84b3baf1c1d9bb53151744abbe98fd663c696c03d6bbbc2689bc123fe9c7bebbcc71b454f84d25530cd02d8c6cf0db82366018dd4327a684eb280b804109c57e45031f263254f270c239549a99468c4941f3dd8068ebbf15c4d177faf61c9efab9ff9b5a43edd11a51aa55ee22f4a1cca076bdf536bd263cc234ce9373565aacbf0291e57dda2ce4371f4bee7f44eafdb6c5691cbdc9342e6235f2484afbc008d695a40871e7ace5ad5b58d9852bc406a3fd651196b13a57c20d23868c07773819c4d03593f4e934701e3899768278d040b1567a57e3f967cfddd699c2703100423e40d76fffa5748de751a09399bb72bc24f45622043f694025892a966d8a18e6f634b11728bbd2175902c52b32a93d14b6bb293530d621fe0e070f37a7a10b2e7718977e38582bfeff67b6da072790faa379a7e42a120205cd334ce4b5e2bc990a1b77cfe00928e52cfa05bfdf19730bdab0590e0eb3c4e52c063e75c824f9bde5b3d01ae91181ef580f0aa2fa97a7979059ea4de7fe8858c488dadee1836fdf3dfac3f81409c10d555948c05f2a18650dd80911e7eb1563b5f145aa9333f7f2bf213","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
