<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d87ee43b69a6c693e109378370fc19bebf488876260c54b278123917d21db16e68c834636151dabd5c9933f1e55ae6cfa730d9d0d294996ece7b5383b4af0c43532b72e1a6a3719de18cb49c025487c30ca560be5a7ce1f1bb8499fc9888efd18e4fbeec767e47b9f9ff2cd389961a0849e2f20aa9e009e9577dd2b68b2d1cb3026b7fdff04a17616d345d6efc7ed5153817e5566dab528c76be9136887e6acca23d6fc6d255d2c22b5e1d1e9ee6818e8aff9b511cd4c309bbc28f0a91ce2f1c2bb1b5ac4998f7fc7d420dd7e1cf0a53bec7ad46ecdd9a82c5a1489f0c0eac013de6831a134e2aec6a6228a25455ed011552640abd3cd93067cfeb7572f4daab6eadd2dcc7e79bd11f7546d67dfae2447aa94150a5d60400b1bde787461d3ff3f0ed862934335674b964c1e65edce41224117d427a910389d65784875258cc2cec7ab05efa75ee68985bd3f4b4fe124eb3d50cfd4b0ee80f0b169e7242b99deab9877b22727b1b572d2bc6c2ed5d7aa55c5468944a802c16220185008a3f473bbdb7675735a9b5090e3651e7cd93c5ffa191a8b96bb49231fe429321c37d5b3d0f2de5ecb65e12819868ce4e3cda6ba55aa7db2ffe016d238b2648dc301989c7ae42ffdd8ade8d2dad39a929cdd79354bf2a107b5827d574ac0a2d38f2642302b6700a1569bd854bbb139c94478d67f79136b9e06960df7bdb4a891c2542727948a8f70d75522107a2de2ab67e9d773f84a50d6c7812a7a489b2b2d6cfa687eab76b2356097c398d6449bd02fbe3a162529f380a7ec15a1f826aec4f0506524aec8553c25462ce0f71b813208f3cf8b4bc78b3b2ad50ec2d42d51098cb506a38f9621ae8041cd08cecf90bbac798bce23091cb770aadda400eaaa74655d2829df0708a8efc81f711aecffb35d4b94dd134d57ca9053e91d6e831635dabc29df289601e8cbcc0eef4ec1439203b5016de38afc89c69e20b8486dbcb8fb12d0098880fba23e3810d7bc938a769b35b47da91b08be855bbbec7cc57d20314d7cc8e97298f554705dedd1460386c846c5e89c965163ad409e4526221f868d35d3bc4bfb83ea6401945fc4dcb88b5594f0b3a629e72ce57390f04045c942a2d1b69cbb319c8a80f5e62771ff9af3bccd698fa501bc9fa7ece7f6807f9341035fa6f0e06873c77f3e2a35ce70f39ba266b8c47bbcd00f4cc9efe21868442a8edb2148da8632bca19fbe45f4ff29592c06c395e6ff9287d3e0bea6bed748031025bb4706075eac1de6bb7d0d7868af3dd650891d0541d57306852fea79f90cff1515b0008705b26f08ad3578f49018ec3814bc17bfe190a9699c0273b2086730b45b631ed3eef8fef85dc492eb8a558f3f200227c6326c71ec17c468c0dcb8685940c74c19347d1fe78d0f7bfb0ac5210f5f204f3cfc36496df2500d61acb23b118a2f124844bda23f2137c030eed448d3af909bc24199622c2de2372a2bc3c5b557891a27251a2747eb775a8089f1e14f6fdb7210f43db59c7bd3d3d674c3fbc66c640977a80cbf8e26a028f87cef69e078c40b2a956e3deb0d9679f8e079c79fabadc3efd5f4dfca4376a773daad4386f94594845cac3fe307a7b8e1a37aee7f2c94a7dd0ebd56b24ad42d2f976338b6948429718c026813f9bf5c73d5505ead3f001960142d63e5e53056a740c07076e6152fe037ca9bb8937644aecaa6e0d67d66b9f346505809e342928fd2b68987de892ed65e5c9fb2fc161a184b7ea6784033379ded12ceb4f984c7f02d13330e3067f1e077df8e785cfd4def9f2bf40563eb3abb5bbedcf945cdd2d0d356342f554370e7e3790e9fbcc92d01b1756e5f2c462886925e76a64eba6621c18c70ef2dcfa9a535d0566bfe29afcfc2588ccccd2d8cc49a8f7e005aa8d754fa89336fcfe7a5e6a4bae5a2e9d72b62805da11aee657e2437083f6f8b46f8e7ce94cd3edf02b2035a0918afb14125761b899a4eaafdea79ee158314fec433474de4e7ecfaa553f5026e0ada99fd14180868bfa0f59297afa1a46b353ed7a0ce61dd363f29602525c7d2318adb7ac7649ab674e8f9278e5552c662e72619b94ed584ca17b2f3dd022e91827a116b4360a42777c46c7c191960a462dd7c438bb4de9b7029d3014e37bdb1b74bc259b7c8a2defb824873f5bea66b32e21415e75983995e036175c10fd4b36d5e440841970e461095c4642fd73e6443afc2e7536779aefb62dff851cfc7662214692ac7c3609944cfc71c7e67db29d3c61f826528cbed34461c0dcf4aa0860b91ef6a644c4b0230ff59451bc777f64531ae3d627fc66dd990291c59a7a9ec4ea147095dc73e5d72b43865254555c4389f084fdafb68eb320048fb002ae37aa1087cf6ec23817a58fe4462fbb7774479548d29dbbdb084a53777ea03fbd5ec2a07b142b4a0cb53812a527dee95b3f1eec67e69899f9518eaf15ce17137b8e172f8552f151e6b4bd9fccc3249df94bd374f17665923d5d0e9bf080176290dae0b1a2a24d9818d71f94da7a02003cc02cd0362dbaf408f4934c6dfd3ba2fafd4de86a4cdbc65677bd3d3a8f8d7af21cb9eb8e6b39b5e832427720c784b787c5a4364472fe609294b56bf4a9fa4bb268823314ea470dc172181c4e173462414e05496654bff9953fea2e2e61317e18ab8db3bae0ee2eccd916d4ba424e6bb16f1cf49f2e34a6cbaf8f1e7a65abe727acc753a1f47a298858554520e0729e3e10aedbcaf14f409788831d9468401692e9244d99d95c96f239ea3d3254fa7351dbee47136b59150c786a451438560c63ad18db4f317ee3d27605e64e79ea449c7048e45d6262bd337b511cad568e0dd91e16d6399eccd866cbc86eb4d3dfee5a23f6457b91ac183f0b1b2c3946a6f7a0776c9cae553fae95a4fa821ac1514a91ba78591657b06df4d3d6ed3f7de4800bf4bcd96f62ffad0433e95afc5d3b89e8df0dc93ce75a51f073cdadcb641212eb82541c31bd0db45474cb7e1bdfc4dde47b50ec4f08d546bc4e39e79f9807fdd2aa6f74cb1a7b3d99caddd3ae60d63237caf53c0283e441bc8f644510ca32c3a75e2e7aa38076a8390ce1f97e18b260a5b77e0284de97d38a3815a1bedaeff455038ba0ad3620fea0aeafa229509706e3ed48e7e2ca77b5c4bff183a303368438080dbbb61d9b71024994a5282c3e3e15f331bb0690a247aae103740d0333447f1b1424f394b8667a66719ec65ed045b312c2903ad7b9f574bc6a3c557a6911872af68ad9a153ce86522a549713c0c1d8cd3e765577a954ec9ea0f50f6ad66f2af6e2854609b0d388d9459d481099fc994fd764d963f15231770053eb0131841915e86efbebbab287045b2dddde6b5510dbd4246aa9c38516cfde3c245e50e3ea3e4d72d8b8e50e2d4caed7fee53226d0d71e8ef06fbe38de54ef442ebde921feb33f599e7c6e55c273f9901323e8a7b640b44aa3ecb9810cbf46f7d28d4ae07e5cf3328355ab2e0769fc2dabd8f20fab0caaf2334041aa71b0c0f72200a25b88ee5faa542d414299b257fac8bffa5c2853d714b7c867303c942f710e852074ea192fd16e666c724954d85c6b7df19a8e70955d1e5713b403f1b471d57c30cabf581c16ea8aea98583176699803dbcf4475d7f09f3e8b9a46291bf82bef8b35a28cdc21fa7dff2a89fb05231a77ff74407584e0938f695c414c0223c020a7af36f33b940a1fdbeede71c3c1bc053a802edabd50a104fbb1d5c7c8b7acbae23f84ff3f3102daf7471cfde26ab2ec2244fe0481f41a481aa45b88e7db0292184facec4af8eac01023f9590fac39ab1741133246555780d999b67ee730baa9c77d3900b1d2f6a1e03b856c0c415a3a05d98e74880480298391c4eb34d2e2055ac938e141d969be7f1b81700cbcec28ae101b37668ff6e83b8853fa838796f4c67943d169d60ba1470d2a22c063da4c2903674e84ecd6fe24291e0d866f50b2a6861797f1f92a061360ea192f5a3af0be23fdf43e6918e21f094ea9800fbcbcb406febe75727fc3ccfc86430aba8563b0be01165884de6089e2d22164a17521d3f4cdd0da1af03baa130c4c35f300ade06b4fe96bfa630c82f0e8921793e24215ef02ac7d7330c6755fd2eecfb4bd485d358a4f0a820073e16e5525b1977c3a190056575cb71d4886954fad234a17b604b9024b4719d63cfef980873245c1445690d6ac86f1088a20673ca6209bece3cc6277ead7139376f43b695c37e8e0bbcf8cf6410d67d09df193857625e97b18c29d026d9763910dd5ea9a76f1d0f32353cdeb223305bca0595a8dd806d15680bfc62f2dba4c8c7925fe09870f5f6c525eb829bb67d2364e905e70257c65014a53e4ba03b9d00185ac6ae4faa04e0e622526e3ce1d8af9f37897b53375476519833c2c6b705e9ccb08692a4537f4afa8e406c2ab5b540bf2f87ef8d7b77f0a27ee61ba9d1f4f7ff0a6fd591c0c986a4822e82ff2e5389dff813a7ff8b42209d8fa6afb1d0984215ead11268a8ee2b6c7840f7656d23371ea9868e9806e2ce4ef8b2a676f76292870da096108b76ad7a9cf7d957d820930cf1c737ec1ccaf136b15d3954162309bb5317eafb6f351b9a4bdb37e68af93c704146ff6b9628d553888217c3a9d7a605d181c77cc536c50fcd25791bfc9f8df18af4638d5eea6507c7e7fda6f2ac3854e48d0028f507777c6fd586c68cf347dc43d756a5555bbaff389bde02077cbefa33f911502b9e91374bae4dfec1e7ead97f4d8ffcb560256d7d0c26c128139423aa26403aab60a9b6e8f2cc78bd7e958dedb177ec769e0dc28e5f80516ee30bcfe7b3431b0843e4f3d5da1d40383fc8a0479cf48d418e583b4eb8e21c96f85cf0707afdf2c42772612652c7757c432a62e9451387facdc04fdbb8387334ab3dd0be0e984823c0a728c34733d60be408641a995402646b6d0f84afda9f295ec26dfc26c2482a1abf37e3a64f120b62503acb2947fd3bcc1ab505ea411e6e1a7f88f8e58bdcbb342f1a665d337630886a8753a3baa941cc13817fe41778a3fd07a7ef00aac78262626352fc93ef772e27a2a57db73e8ebca717b144b46a0411dac72ff05b6ff189d10926155075d934bccb8d55cd4792189972605f9b6d1933cd838b3c1640ea1a7549fdb8ffe3f56c2d5fd8318e70d58f72dc5f1b6dc643b526b4679c6f31e0013271cf4a73fb0a17d2dc4db1bdc7a2a660697264b349ec89811a66223c4a67639797a795dc634f17de804d4d5a963754d0bfea57c4a92ae925404badb793a2b3f10b22ebd5a72a34e37d433881731241362af0b86579d7956a7ee4afc0fb864d559e593121afa4ddcf225d0e807a57b71644397099a6776d0364b495f6154ec24d2e08c37efaca3d58708d09db73e053747eec8180598b951ab8cb60503f629cb28bda826e42c4654d764aa2749812f8829f888ce61b2032da0d23804cedf3d70e3e9c7b80ec3578ff46d81baf98bba348542801fc5f6e721870dc070b901f9c516dfe6928530accab58a4e57a99438df9d57963794e733bfed63510b04525b5abdc8f059f7f13dcf23eb9c325968e9c2679f742b8d2178ce7c540e760eaad79094f199f2b301fbed4a742618082911ab221314cc5c0e79239f53ac933b8afb517c746b7d1982b71c6ea95f8234368e25da63862a9c4ca0502fe578c67d5b1dcf2096cf1b0f4d6295154ccc78943b5feaa625a866d196fe2fde58aef2da816671a30639243bd7bc268292862172897433354623a620ec089d36bb318f63ae0014603711a95ea9e6dfb234446ebba3d061fde419ce2cc40a71c22fe7b2603a96138f78a68ca17ed33b7eae70ad3da06e185fa671c3cebe6c4286ba2b928e55ab3ef938919d8bfaa885dbd37ca2b17374f07204a92a73cd3066ac1518e0148a2e69c0b1d8161cdb4e34ba6e537aadcfa77485d20c738674af058a340a9473bac8a71d827b968956abda3312950b463b02e8af86b4645e3d9ffb6a3cba8e81b30c1fafea49f5dce36961142eca16c18f25fd091ecf59e19bdca9c6261e712cafca97df5bff6069faf6ad38cdd3505f20dcf01246d89c6481c1685a1b12e769d1590d18d8f663b2f8c628ebb42e491a30d8a0310a727bc80397e1249ec7f77b96e7b9e1896c8e4fd207cb447632f754fb96979c730ae654bd702df88c822f165819e80a5acf08d745f6e8f724e59e3ae91ad34e3f8e92ee105fccea79a1344826d6b619bb1e8b5c04aaf32dc21c92d071c5f7023d75033d37d73fce14547dfb4510e777ac6c6865196272841e724936a025b41c61d390e3e776003053be94ec435193b8650e7a3f2844aaf7cc426fd5478b2a765eb7820f2c87b230332c362db2bd2a453e0a2581c2861a5b393d572cf3b85b2c01d834adedb181cf097192e39e7dbf4af10e9c35f78c397381e62a766270db911a6492c1b5d455bb436438ab38e71781460ccd6d1897ebfc6006da914c4024b50e35701f5c83a1f60c5870a990bafbe20d17c4d79616a2c144ac89ae4fa0f7f70aec3b1d4f70db0f898df1a79512c55ed340e025e5b7ac3a5e320e9c6bee6bbc01ad193c6a9eba105dfe7da2247eac229d176b5f314b62eb2f97c9c487d62e58be97c7a93c83ddbe94f8f8fc9b807d62a35493803ac5e1e241544a2e3136ef57cb5ece8451cc28390377a9d30bb87c269a0f609b93bc19013c0b875e88d989532e159682e4e9273b312527d81fe2b5591dc15381e81a278ea86b9d86afe48787a53ddb5996ed63a7f37688c991c09361bbf986da720e87309c0d54f4a4ebc7cb5c7e93167e4fcde397cb5adfc520942b8fa8f131d1753469a3cb5a48a0f7408daf3acf9a1721de9cc5b44ff810bb172652ff61ed877d55fff5fd803406173eef628750fde8361d5f8f0352520c616c43d4d8f302e774e5ca2f5d18a27d8924885c6396326064cf0d233b04d83cabf7fcf2389a19cda4beaee8a466129754c217965cf995efaae2358176dd2fabe7ab1790f619328b0f6f4036b7c9e4bde502279112d414b41d057ed1f3eb51ce7e5f4fc824f2e5839367dc31f9fc4ba33deaca880aacb02cd8dd69e1a39e2b96bc42dfc3efa4100c1213a375a85276145e6a2d4938fa2387fdf613d56f389948ea23e5598322220a7bc31f20494bd1650e7b301769a9e1fefc0709900e95a914b80192ec0f290b84741a3d855da87b319e0816c2622108ad56953472a90c782b00b1d8af9190908faea87b6b6a20cb8f93871a2bfd6e93f0e9d8df70d3220904aef8520de02df2c44bae74812b0097d054c59d3396576d3c7ccfde45565980d6c617dbb0b07be0c174d37ec954cbecf7b1d820bbbe7d12200f5c990bdaed05e5b6676cf1d9a8178c2562989755fc7c1c7f17891ab74b3e1a91d5c8098b806a9fc6754753b901790fd3918dc8a5726659b461ad7860588107893e27c02392e03368366c39e6adb2534a6f6490dbd79631ce5a579a428e85229189d50fa751320e7804b2eb95b2598730fd7f4fe2e547d023dd5f4f1ca69de1654386372b30ae925c00f49a7d3f90368d2b0d7af7b23bccf03d1e247ab94eac8052f672bed29941e65f4392edeed9a9db2ffdebb359aed3b426774854f260fb9a8493324658a3c1f54b4c3d6e9d586dd610d5c11667a04705fab2c0db8755fc52d4ac0e434d60dc10dea66c1d0491767164035cb2074724556c588d8fd9efc71cf657f4252e545bb5b2c54707a93436f856363e48376941c6b2098023ac9189126729bbe91584ea076d90921439ee2810f7aec8f9460172a9d270b0f8a4eaa83d9424ad52231dac54359270afff6327dde419393d207a9c0f95573f1d186b119af006caf39926be2865ec900c78ac256feb05d3cd56e4880eb159303dc1fa609a390fa72fd5642ff5cbf71a267e2e3edf1c1e4ad0a1aeaef79077801f0735b06cff834c697740b31133a5aa9045ef5c22e5dadeb0f1edabf2c726cd182f9afc80801b06475dc055fc7fdfd4b1b14f35e2362cae8b0715c4a098aa9a17f536ccd63a2b212846fae343f7a61e6dad32790c366540041ede6f78ea613fffadaf74b7e9aedf9a83d7c9b4ad243bcc6d68479544f45a99cfa93bc2d75e731e7f39b2f79fa29dc5c2f14d0f750347f9ea113088b0aff68ee6563dc9497ba2d8fc5862bc85aebdd51af673d50fa7cc7d3a32bde493dfbfa6b976ad7ebad7754d2b9ac52ca66abb38d191d828a571d2b904ae0b9080aee5092e3c02668fb6d299a4eeb4a1f007425085ab6cec6946162a3d2a14f016010cc7b9354396e96d9ea44fe0df0a5e6b69697f0248a1a41e13f9204cc54fc4207373d120132e3d3cc859ae40c21f1e185816844f4a4769133a706d5357ee3c8992aa1815272b65ce722c693c977797467c8fcb7a983aa5bfc26e92d6b83076ff5f1841aca1229147293cae46865f02969cfe366ab72caf78e2cbbbb5fb4a1f5610ef3680af6dc65146569915e786a0ded60a45082d6ef8e8421ba5dec4cbcc49cb8ef4c239be7cef2326074aa1edc013da16fe9b71b30e41119331267315b1e0a0b43e07e9e165bdb016b23785c2166265aca4539733af5ea3f852f4135b6859e742df238df5a74001d0537dbdbe2408afbbffc41b2d5df58348ad7eaa370e95fef2014c9ab6c7ca8938a36fa9817e10ee2576fb37380597d71ab50e342ee8c6d299436ae44cba506a22afca419573a4bd5358d29de73e6f3fd952d99666ed4643c5420632f62c49ca3188d8d3c5baaec51291bf3a083fef080099e9b3425d9f2ccea7caefbaa69c248518d5e0f44c5b6a9183095c69e0d343292c7c68bdde8e5169611cc0a6347f1f3fd918fda601cce8d00e3b7b605e32471fefc91e521f75d65080ca5da48faee057b85358089ddbf0fdd4bed0775737bbc56aff656d55dfc36b5cdb36e584a054c5c3736a95153d13d24e5527c98a91fc98dfff9eca204fd335a0ce4c9843ea891b3c796dff4c5f5650921cba84a01351d74a2469e0a89341fb9424643732a7e58c577f97b5016ce9f9aaec53e625f999d765ac2f303fe1baa95641073db1f127b87febb4eb2962ff7f99ebc7375929d32594d3c990c194aaccbb6d4fba625711bcfefb4ff38ae9c1812a30f3e75798cb491a280d8df562bcf91848e60a45d525cf98e6f5816411294e8bf02d8833c71e333c013adc8fdbf79a1d7fe1bba1a22918a0c7eaf0b2bef5a502034d9a31d22632d74a670c725651f0c5709c30ac830f3da21bdd709230e9890a27084e3e6dc0718ef5b1d51e836b4246ccfd5ac8e3d2dc2957b31b40a93f6944ffdc3a1971197eb2c0e9b73730e8a9abdd435c54bf100e5aa0e76642de6c3cf18139b428dbea926ea45f6ad241174d32725a431bcdcbaa7a082bb3890bf08f11473020081d08d34beb900d961f705c232be40dc8055dd0a88541a792ce485d6b290d3484a9632600e37759e9aef840436b3242a5fa314ee89b4f182cf096a66dd72e33ad9636054d9d252ddb05cc5c8a8c42ccc137fcee000b2a3a50caa7628ea61e31661fe40a200e3991d1be9ddc5fc3b315ff8fe284b06c6674366432cd343f164122a0e5b538fa5fd5961d4050bdf6e819e5ba0d2dafb102dbcc6ba1142a2aac56a8010c2467a5ee810ac0d7f7d2b6158f72c11d1e606aca157c0a55348ac4f9efef56637d0daf0e43d97724c1865a26018d0bf6bae9581381d08b8417a767bafb21e46c9187e1c4fead1b3f740b85396fa9fbe3d356550f5bca5257317c0480f5f751dc1c5fd4d47ee4beafe80814615fafdaa9c6f93fc13b77e491cbc8e40cd83fc1bc81f48d6fbb53faeb0df329e452f6259ef3405b274c5fe67b9a4dfad2143dea5aa2ab0da3b87f04a013a6bd4c73fb3ede522c9b39293b58cbbdda374eb34ee7021353f72aa4904fce55dfac8254d70bcbbd1f14be085da1d027637d3cde4529188250926c5f1c09136cbc90c3d5fb33096b8a27b242c6be5f0e0baa8c71a40f3388310ca950f6557a6c88c98c56026702172374f05e461dd79cd61595521e366266c0fce6e9bc6c85701342e3e90fca4608fc1a2174ed3ced777b07189610e58e941fbeb2dea05c6ecc79e3b0d573f763457dd22916cb194795c637990bfc3f3a2ba71f24cee13184bd00ee2d38b79dc25eeebe0c41037de4e53e6cc5e60311e111242035e3d14ce9e36ad31420cb3d822664b4933892220635534ca3e4b3baceb335817e309ed8de7a85e5d6475ed5128fe6517c8912ab833cfb97739c1393099ed1055465446da55eff6c3223f3e0dbf1815860fed74f6e1f26b362dd0cde4962f2d12da656f0e280305ac151d35a4f0eb236388a43d93b2601e39d8151ffb9d37823b68a459b2cc928fa2b4a6e1f600047fae6a512bbb3279e08856a5715e8d7a4d2659f9a5e0396ac57a0034f9c1fa64de2fcb6966594a45b45007bad47d76d266820775dcea6a456f528444dec8205e33fdb9f6bd50919ca541b5800add138e590d6599e04e9ff596e2e81930c080202783544641d7c2e6857c8e833319d08de5503e227c3d9954005a0899286c7e891ebb876ed031e0eeb8edf653a5b38df8e5fcb65938df1cb2a55dfe667bddfddad8e9cb93dfb4df9dce53a99c26da926b8ae75a4bd31e84f4a67c95b2fc97239e722767a5ab331794f70b9c539c597a3e5dbf6b51bfc23db4cbae9347388a8f7f7a19763e8ce1383936b17984f3f15bab8de7a4c1484c7c42813e9ffe05d9eeca761cbada1ca11afd724582945689a1e9d1e9424cb9d7922fe76da4a158b3533a40ec08f0296c49eb4d152fa827601ea40553981b75739c224be0163f3c1464f6b29fd4ae224d90c3a1d885139a6ef8767f1252f35e8519fa96f8a8158f83988ba1610a4e3351622ce40c07716a7a1651b4ea1e45e6a8c8f36392e94d1fc7371d10a3a398d95441f323e14c1dc57b56bdab6f140a3dcfce51e26eaf2dee2314e61b214937ba83c5a4b1eec83b1a426f177270a2cde6b70dcd507d18e5b8439da88102542ad03aad4fed06eb5daaa74f009c36d1076dcb18d37baa66c354e2e77acf5210c827661faffd4cc40d562de6f8b4189b4b29385d0e1d18c0072d234beb13883d7d38fee17cf0ba00ab17b4143dc6ccbccb7731fc594a74a6381e1b3d41c8d5db46cca84009d6d69f6d703761f5a62ea24a56e1b208111c9b37e1fac819971e5efba419d224947bc538715dec46197e6626c65f57b1d8c742a03e79d8b92bca4187c75fda00d5459d0fc065cf811fe267734d06b068f0277bd67c802880cbf436c7744722bf4d6d4f93bb9a8ded706d625e3172627d169191a0e61ddc39507896e6954caf27be5bc9ad44e0600a281a895550870ce9d46e1fa9c1c4cd80cba73ebc09bfca42d8873b54713501d59ee1a63db7cd378942e70d3699613b0ed677d4b92b180a37eb781c75e110776145f05e39b4b969b877c3ccf80f8c48e263aef5a2723324c2ee1ae065f106b0fca7ee9a4db53ddc8cf0b6e9143cca69031c93a24528e6caa5b6e9f8b9e32a1b407de66bdea5edba9cd9c4192978c9ce2728945f5d2882d5b9996cf58aab472945635a24a40cb9d429ce0c81109b0f0db44442d38e5f5e1279bf4cfb3be44028ee5cba8e45bc2bcc79be36fdd5d9a8bff08697ac476fdd92682b033c778a0de99d92b8b2446c2fd857398acb5fd3096e95bef27d7bff1b1759fd441a065d005e106e233dc1c7a8bd5e5a73672532b190cc8c526ea8d3b99ed08a6b7a68a576a0266b8504b4e6c3f70048b5131d465fe1e17744811b7fb6ad1ba456410e73754871d4bd669718f9722df60bc13da8d0f3f05eef26a3c3b044bee71bf303b0827cca3719fa1227c9e5427aac409b7bbabfd087a56ec823e26e4bbc372eadfdbad7130bb8807dee475d1873c20c70219412f09765e27587c4b48efadb3464044fd62ee2f1ca54aa57dae2b40e8034363cac552a0ec914c891a1004849b7d9375caf9c558ae391adfa97e507f6acad1875b0fa4ad5a0967f3fe8eb2a0531deddf748a7b13d9ea4fd2244a98bc4bfa5496d3c45c8a1086990488f7bcfa888061521b3a34d6ac4cb389ed5ee65a1aa928a06155dd792667936449144348b8fbeb9e4a45b9e08a076b267ce9ae409e0bbfedbf17a058ae0be896ef0dcd511a75ec7c0004c3d19a5e4e3185dc800d359d249ae9281688d8752fb327d34c3cacdf427d4b0702863033cdf31845121da29c1037eb13e3556bc40833c7b585e8854bb6c9720d229b237dce8743905b0d228245b42dde580e9bae368a01282c57856eae181e20af86b9382d79467d542e9598f9a3abef521a0593ceab17a38b8018a199272af28337c925cbf6ce3b034f640cd850081ce9d94de26ade657d4fad5b70d18770e899fcbea0ff6874418a1125d6ee0664a40eae60e822539e29106eaba725ca4e8ac049f75a7f7809197e644f926dddf1cd936164749579d82c7425127be2632e08ce8a90c5603e5ac8ab43fe985dd013b521852a40ae7ef258235d378d50f2b707490388fee04c10923e929fa86632aa5265ad4fc35d5ea6b3ca0f722f9c42b7e8ca392c16b20ae577540218fdb156f593bc9a3bb575d7879833b8f15195ccdfb5abfcbfc321c5f08569603385cc030330ba0096c9c8653c5f42402cd657e4255dcbcedc5f546e45c9cebdbfc951f1601b8c4dabf54d14bcb85def2ec285c2702819dae233d7d2b31bd0946b7a54ebba1a427f16be96dd2b9a48ac3780fd4a3f31b158ee7e45ec3341deaac8238bf483620c20f44d6656ee4c0734682d228ace521554afe46b75b53421727123a1d7ffba9dd6ac031dbc134a5a3b82a51c14c07fc79895d22575dbea90db6910ade54ed63a3e20c617f23975e3410fc57f1fa61d0558d30298dc5c7bc4a3c68879fcc17ac8233f412a7a7756694e26b743b5c0667ea48d7a9349137ddbc2505cfb478200c6e7c93d777e10ffc851960cdc40929b01c51d8c0e38303d87c12b60d983276e4fc2d26ce3545b091c5d6dbb577332d4326bf10d889ab4628540fe628305688f5c7e29ee59deb79acde67320c7b30ac31e2fe2eae8e9fb661a937169435ef3e23d91826fe24576da2921115f8f9686a4a21b1965086f7c98c601f07108dfa0699cd00410dab49c9ca8b4de55270f064d9c5d1f91f3e15d43da946bc29d2d8146509534c6eb8dae0f9344b6aaed37478cec774fe5879248440524e0877a2de9f71ac151ff4165586c7974c1fdb145bbfc444a68934105015da1da09cdf86fa7130861cf50cc2e4ebdc9e4d3910370cd4b5991b03d3ca636c3681331cdfacd6c3abd3d4c076296499b7b7f9891c03201757a26b40a121417786314d451aa693578f5394695774fd022cda4a483f6a48d7f242b13dee1a9caadfc696162dc879bafa74791a32d9dc25fdd68e7140f8c3138723170c39945caa548ad92ba349b9137a881026c355237c3805be6b78a59a390df6ebf999a5d9d6661f5a6715c04fa9c4c887341d88c3637970c68388400bd6b9bac7a15ef4947a8d2ab38b22815eac81741331f68d4a1984345c2bc9818247184f614f116b3f889dfcc4a2c07898c256087b126118675ee6c5130ccc4ee7509533ae0ce41332b98f0c50d42d03769244c10ccbbdf68ffbf4cb8a0cc7c6837422a0ae9e19f493980bda5ffb26130ddd0f16f77c825438b7ba06e8f3cc464a81ea279f9bac263184bceac5c74f5a4e7a1ca415c989b63840cb64a34cf85adb0bc8220c41ba45cf6e4ad8f47c6e61c356d9cc4e626a377391de3ee32bfd19af303d0b55a6d4ab20fa1760d65497963f4634b0350fcc08afab8679f4b336bf2f1654355e4d02aff0d0cc9bef870e5018600d32d13289cd0eb28f9bb5d50741966f461fd39e8f4204ccdc66b4d4815fccf1c757dbbb91447e1bccc1358237524672d6eb2f6005191a6fe408f6d8c9f49702cfe93df414d8b31cddbbd06efee700310a5cbbbc1090995627f7968ed24fa3c8e38fd1cbfed24ce3d57f3a1e3f7adb931529771fd844201eee20ba23243cda7ad882831c3da66ccff176b4d2b3a9c5ef9d93507bdfd9392067b9b5ccf1d5435665ee6daaae9246f641459bd03d2a750464784c65600682e48f955af7c6a1c4b1eff3bbd25755478719044b8739664bd9f7aa7b7783d9fc99bcd961ef57a8b6ef26032c2fd48a87107c80f822df242d40226627b005b97a549c10fd98990450f7a0a50b1e62732d96a3eedbe9d670dc7173fa6f262229d98c2a4db07a742ca8d307469e913680fa2642a2d8b2d2e72e2cceb4edecc65e79d52ac9c3f1277fda836fbf10db96e198302050f09020d22ff15ee9c5827b393f4199bccca04f09286b0b79de4e632943a1b06ed754a2c01ab2571cbae4dcf31001ba821d2062e3915d33390e0356563616c4884da213e2f8f04123207ccf16ba76851d3313563c69e37b51018b34e7c4bc0334fcec2736f220d7fe0c6d485f1b09f0b8c3213ee19979fb06002c3fa49122d59a0355a4ed6b85267cb2d01b02b91d41416e3dedb0328e0ccfb0703a2db743dd63773fd6af352d7fd57c2623c8450892171ef449bdd5d07d4a5d21c95284b315d77db5e1a0137e8245e0092f80492ce486444b9421795b6d3216a7cf1d1fb900a89a89f99bcea8c8fdc41405655625218eb3158e846afcca576216868b9cdc2f8e929a1956e6beae1103efb6f83eda84ed6425beee881abd7d0e8b1937c399efdc4592e4a9a82f887f2817fc9c158f4e89befda414b9207b873049cd0d833804ca8148ded5be92b7a6a5b259f4200b39a0490cb866eeff3966b9a7fbe098e87edb2aafa9cda25a084cffc6fcb8f22a7da49bb31d20a649e7131d94818ab3a0d73f247928477eceafb4653351bb207ee6f2cc87c3d637a80f1958c283eef9feb6663d60f25bdc565958dc21ad0f2ff276e1121dd9266cedac69e19a63e2b998163c3e8acba4687276ff83a8a68eca661edf71a64fbcfd142db07417a92493e8c7e5550fc3a44fc735a236970f2417becdc0c34363028b2caffcf65288186f171426ce787c4225b5b4c31f706ac1e9de0f245edb2d077aa7ff1287a7a566d725a82449997d45a7235","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
