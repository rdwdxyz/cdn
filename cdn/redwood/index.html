<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2597bed80254dad16654f50c7292f663fe463bea2d01449f2771d6343d6c785412b38e81f62c8a06f1d46843c59a11c78b23319c1a7257b94fd4b02c3bb87a08e28777e0a1df07e42ab187697a6e5500a2e6980698d864fc1a06a335a04ef3dc6fdf529cf170f5aac5ddce1f0626e4fd2677354d07008778cc1884150a7d6f7eeb33fb1cd28b0b04f215c412cc2154dbf3fe91945a03e62c6f108ec7082e254d64a98cb8692a057702e6327cef6a733d1bcf34eed456cd2dea50a003a7f003dce20fe6009b092ab8464e489fccffde9d67412aadd0decb7dd13300251bba24346c28de0f6a96f760f00973b50929d7fa899bf92c7a034d35f34b8e267f259dc8f1010c44a1b7e1832c3e98cb257ab11ba943f11f3115d8c7fa04dec5680e84bf25cd42ef605f6cddf3b6b4096f203da6cc366050507911be0ba3a63119c6a7fd958071a3f18e7f1d813dee41602d9cbba5a925bd11b53b9af7585a12a5e29d3df3d592ad8b83bd37531836917012b23a7768c43d7d5bbc42366986844033db82ca465266c38f5e100e0ffe38fcaaf5aac454b6a2c9ca05d5081f13ab99e944c81bdf3e7ae70efed672a14610f2c59c2daa141e0bff87925fc7c072c331a9e2f583bf59eb024b33fd8f60d5287928127653684e8393d04d275ac00d6927c94a3f0686e8dccddc8821a9c1e5532beee5e6a29665393a1e5cb56967892a4d738cb7adc8f0e194fd8eaf7a57736560dfd660d9999c7eb0ad25094a08f79b67df2113566971a9808db241dd121fb0a1cac37454f617d77d30551e9585691de31ff86ceaff7e3b6c77c991a1dfe175bba27ddc53bc3d7a036b2b9f6f6ea3c69d9b92248786666b3422b6ce0c4d23c2b37180ae6e20c39dd84d079f7fbb953aef36862c58fd4f63ec4d1a9d7c7b2dc39f4b9f929234f41ceef72472dab84a2858c5933d24894450e1000ae816b6010fd1e7f2ab4532352eb8dcce97179d8cf44b101360923943bbb671d0e18eb36fb88b692eb5e18b7a730b708634858fe2c70f4d7b471171f517b72b86d09640298a9487912f2d7c0e59108848175a86d6a5f4c1b45de8d117b1d75f455f02cdb177e84d59b79ef1e4a5d543a3f2dcbe1ab8351259e9fa8135676dcbc9cc921a9d3d60a62d87f84708010da29838d5518502ef6e29358fb2e1c05b28ba15859fff8e43beff3b951cd0fddf5e2e1a6733abda25da686292e6d1c3cdb2b70da8698afceaefab9ea1d68d386ec0f1b00d18e7348831e9439f0f479e4761a18dcde03c32e57994d49c4ff3ac8f6c57e949a6f12432c83e6edee42e71464b4ce92aeb432bd0005a7041b0ab4d83ae061b3e99515ba2e0f05cf0825e2e0cd13afb9bf8ace52569455a514c9717ea1debbdddda2e036d4ea1d765df12dcfe4d7c9979ddc33d27d056479db834376757c6c19cdf7926bc11713d7c91bdb680b7832b39f0f3c7e348c7fd45157a1ecf9534598cf19c2b6a4288dcf716a8b632caae66522c51fe1126beaa08d067e917ae2f27dbd4e4b9a72e542acd47be8e98ae707440ca36a48d5a3ce2ce6d5d3e18cdb60a039c817e64950e1e305740298b72e7a2414bd1a427ac36ede1ab2b8975ef8a777acd3862c5e684bda3837e591c251ff0b5d4130cc9c0f736a2823c70f9004cc9a46dadb3697b111a2d15e7f2e5959d371ed2a151395cc1ec069f276f29348b4c2bca40cdc5cc98ca675217e96ea4d05c7e0f1287732d4d5a068a0429f64a8ef829e0f58237b1b4fca211a88718101422a9bfb637a310a8545b268b065344717ec071aa9265a51ac6dbd72aec860c10c44bf3a0566eaf3f6ade72167580bc0ad72bce0035cfefdb44809d1aa9d056f276a8b4bdcd8e20beaa1319cac8b5a89ebecd0b85ffc49a0f4d6522f5601feb314b9594e5db4c8af96959a236b3da79be8b9d3552cf173ae30a3f51628c18129dd07f50befb7f26253c3dbd00c981316ab6513e99905d7d53fbccb4fbded75aaf3b6e0994550793d2f38c67a32f49e637a88b3112b9c51ce1a93c0db218b7d17ab12f3e9e09564f96e2608fb3be5a38779eaa88231471abd222cff216810fb7d12166702c52f9cd1f93b49912dbb3f850af08614d711c70eab0346f66bd523068f9abe9fc08cd0900645d8faf375d27402fcb6f4b79e503574b44858adff0a391609c68320f10c91f62b253424e96931bdc5f191136d2ef62f6e0faaa0c6ad9aea3ad9477bf432cafe34292564310de03a7fd4458283c9de7cbb29e556486038f908bec9ac50a96e9077a05111978afee9b4ac5096dec52d1f5ed0d8b0748cb9355b9c0f5c39bdda11898598cb1f408ddde9eb09a2ac043287c1e49ff5956403eb35d148dc147cf5f0c7c9e38fc09015801b283b9e718efa32cead2e3da9f4da875c209a88cf16a4909ac9c8189885522c9e52b6efed73e0355b597246626982c49c4ff018e48da63ed7d96e2fe7cd31bfdeaa9481698243393623c011199734554b3ec6823d9df842d3ca3cb1efa4eaabe502c63d73da6ce2368b15b509807b3e34f3df84348f492eedca54f8f4a411772ec660113c1ff281faca599fe98be2f90e40fe616d72545ee73264e73015cd654487077b94531c5be6bbaac49ae369fb218c80baa8da9259ef2a499383859d3d34a14868f21524ae235103f5d26dceed4231563b8f2b23c7c703074d8312040ff17758324ac13ce62e0cf3407dbbd2ab7c6ef9bed822ce51781abf247ec35fc47c137fcc6efcbbb533d2f13d2bf433cc06075bac422ec56a5cfefc08f81f35edf9b66860c469adde9137b1e72c26dabf5f60016068ee741460c42020f2f0f4bd3acf31a186e53fe11c13efc0abcc147d0f283adf7fdf0324b8284f7d035ab2e455dbe2f7a1298cf9889cb843ec3d39ba0397887e7f58b3f0de1c91a6fef506cac0bd595cf66901faa847bc7c21d3a3aa65f4412ee52793c834ef0511641bc491d6c9f85e23d8d9c091f4fb150ace8d10ff54ca0335347878b09c5d1c78d1766e76e4f5a3c8b877934212359aa0bbec0fe272d3f1623015f7858745f531659dc78d81f80928c4b9e2c5b6483be5f3e1ea7b704a9c5a6c516e4bc44a575475de94ed03e628e3f7263a2e5bbc80a69953ddf88eead40c008b244fe4439ef763a9eb1299b73aadcf31800beb49ddd5d393ee9bfafd65df6a88f6a8adcd6d52593e060d4e4fb7718cd00bd6fc0326a3bc0514d0ac0085d53828c251a6bd1726600b781dc31feff3d9810e92279e54e38b2bd70d9c17917113e35f3b5dee8b9284dd9df63c3c8fc699b2f1e849fed9c600f869fab41f8857e077de0e4f5ac012521eb800d91c16a6335882faced0f2de06f4c764894b97e8b6ac354039e3fbd3b44ea61b558087ad8ae566c7c0860fcd2c33f8cdb86b0392c8d6dc182237f1d78d72ce03ea561eec891ce9e43620638e7b063a1802123d964ade2562a1ad539770bbeddf8236570032c7c817026371bed0989af0597ebe1715c57f03ed5d4dce81c049c12c5afa06cefe8f6bd41e2dee36986f022e4db06fc399f2672ec92d3086c53c540f8437bc21df850a3d7deb7385ce226995808fef25224d11832dda5c713c0db0f85f3f9b3e98636808d709a1aa233fe6b050ca103889cf29949d14bcad5e8f4af76798f55fc109a1d30cf09fe1eed7df455ecee4db33821855c214dd0c5a6660e7333418f39de6fe9336ee22d97a7d8b5c651c245905aa73f58cb31b5197a3382282b13648e8578235d7fdd4e20b1ec2ff1c8c08c6e61208379d6e9320cb3150d22cd870c47c81e7c3394f3849dc24c0a009c51a9dcc12e610261669f3a3afc6b658d1b452fa0e97c095a016d77d5414ce356933e09902125cc2c604dee95698e8ebbc56c2b1c93480044dffbceade1f07642f7bae8a6c7ea6849fd7f7edff0229aec72e0e755c013ca0d1b99fb5df52f94f3f38d8c6aea3710589f7f7966c980266d375438d015534fd8cc9f876622bdfc80cf1d4612511b137b38204467214b3548349261d6de26a4c04f21acb0a7d1b0463b04b67090b1919377e95564374a25fed4f11a3b31548b3fc7fef7c211629861e846d226c1ba1271f83ab522057fb368a2da4beccf60d2f08725041319ba294622d05dee6561a0a0619df6f45d947a3f9045ed13b869735bd01c21b0a07e9e370a32ad3691df5346569a98845288bf4e34c79ba3e900bf85161fecad5d2f15fe658fcb898340370e0d9c4dae531ef12fb92761d84a7f49dafe6eb2a0e375dc551cbace3b4a72527c451913ce45c06926b147ed59e101d9eb902cdfdc4683413136599ab2d4424c2fb5647fe097c9e9223ef956fcca54ad8787da413291b668ad87169942c47b50eb81ab480b437d1822d110f98dde840c6d686d70950a6863d49e4735b0320777afc81a5e7e7901393f39ccfc213e397bda359a16d096efb54118a9efd69bb3e517827316cd7522d029f91739e52bd32a02079bb2d9965536839e3f53f931a45ec4dac865330aa0d7a922bb313ab412606618be0f06db9d42e8213fd67d88f54487927db74a66ab6e9fafcd0ec9bcda778ec5c8b1fc69a1243657b2fe70ed836d12f29c550bbef2e20b8681afc07bdd5a973e4d06401ccd7788ed0424bf7ecc47887d46808522dc76cfc66f9fad5d35d0716dc6763d3d020de32455b795d2c8cf6f2b7c6edf8e079546ba828b1888f7803bd648e47b9b3eef378044246123a1b11d8065c13f2f833bd697e11816c61afc05e1825eb083d28950391518ca313123672086beea9ac13147a5ffa77fbfb8f696edd66b5a24b348d423afad96099fb1691bb130cf568c7e9114e54d112476babe6c1f179e4a3050dfb34072e843f81a25d088b0140f2d17ee3c1fbc7305b69c55098009fce18588bb00156c57db3fa37b326e7c77a50b003ce436e40e8b955240c9f82260c3589cdf63092dc659c77c56418a6d826a2d3140977f2935c3940b0acb0fa41759110457b24ffb58455d853f80429a5ad732934991077b4856c6d9f520c5391aa6d7c3fb5baa8373086e9c0422816fbd23db020ffbd59cf07f7296c2880c670db3252604d575271412c8d61214d042ebca349d0ed2b56a9265565306d8dd8f78037ae7a69886663afb21e91ce2247680292caa43c7ed057485cf01cbfdbf2aa111398bf63269b9dae250fda7dba90f43e35bfdf478425600f664087e6732cbf224e3428ac28f00f1da1deb6d61f275c489d8911e1fb82e2c379512b4cefa19f477ec560fea4b82c8034d74535312a6d07a353b3cf9f65cec61951889369ecff6023df84d53848fb3cfc7fb40bfc19c3e0fdb7b65d4937be664e4a597344a0102e25b21923d1d62a2700033cd4e986db57ce52bbb70501d7a15fddbfd2e7c01f7b022f19c72c86a4e0912624784b5d54b4f037b365d2047744ecbaf2687b6b13d5f3ad4eb627331caf1de8a911a528e5389bf98d145db669f019112f51b08dba1168fecac0242c7f2776b3c0018c10a75907c0f0cbedb349644752767f213ea96ddaf3b74239f3fa16a319e4c726c5764f1d73a9f8a2c47829422e636f01b97f461dd9c78e6ee33150687a75c815a73fb2a9d197746d355727ddf293e71dcf8eade8fb907ff273c8f17ee0cf514346a11834f6ccb7cf4ecc562891975789e96017b9de50c7cae6fc809c44176c2c3203f2ffa16b64f6d7522af6479564a8328e2cb1992b2c1401e723063650e9e259fff1fc9c4ac82f328290864bb6a411fc77871f06112da5ef9d65f1abf20e35f7b4cbba1403916695f87e0d9af300bccfae1ae1b5450aeab1945ed18910608c5a16fb2dad732bf5db5b146d54297f8ef39ddcc601776c06956fac5472f2254e3c577ae4de2ddffa9040db8969680dde339ddd8741f3aeea5ec3bda9f6144740eb1e9bf96aef41bcf3917a97e41d288cc22f0f3f253cb7eaba5dd118bea5d7952f913dfcb279defba2eec6740180bc036dbee3ff077659f114ea26075520f9e492ed04dd347606fed0abeb53d645cab407fddd24abb7d0f52d9089ffb91df8dc16c2aecc28d1f87fd2911f7ca6067767d7b7e8557ee6b61af5921508b32b35027d1e75f977a39daa78fe68fc7b364c4e008520175ac6623f935130201190e79a738c147841d569fc29715eb1cc4bf26fb7adb68a9dc457805bf28d8fb4fc2fc4277f68b5f857dd141b399463a0c83e45901474d6b744ceba6102a536f41e5a57c2db365cd4a0cde834e44a6bab546c78a71721d2297016ad138aaea056d4a7787f2baeb84905dd1b8d5688df10848c3399b8db03bd0b0fadd2ec85eb84ddcc85db122d1acd856d7d6453aa4b452f5cebb96cdd1b20b866eeb986a2907c81e5b57f8e079f5414e94117e1b0095a2419d69981975441dacc326a929da4fb92296c1594c24c1b18ff1e1e107064e9774a00005175f1f1922503a32036efba951e9524c37e3c5f2a96ccbb147e66f6c93505d81ee7152832b186d226dea8605770c874e99c2a7442336d1d77fbb01ab72f559160693550d17e09c3adfa3fa4d146588c151f8bb9a703db514d43ddc5c4dfff7b6272b810eed4649199a09fa82583775d77468241bbe0a7401e9c57c61011d123c9b122eef2c916f4478e0e9305676de26f9b95b1e2362b3381e5bc4a8d4a553f33312a645a674213005e74c967c1ebbf2a4501a6b2b1a74fcf910b7687a2dc293d7b529c1e0d8a4cfc2bea12c8c781342f0cb7dd4fd75b13c71ebaff413f04d3fa0de487acfcf1e60e2dbe52231075ec41aa156cf565e4046c8336176cfa7c8ebb96584b198b8fcbdef47add1b4ecf6a059bac601c124b4b17a9e38b3f5a7d0d77040dfed4ff6d9953074cf531c57b7012f0847c3badabd2c0dd476f6c2749b3772da5ba67cce8f984e40ab0094004e317aba7618d68d0029aa24a20b24fd873cb3c0eb1e48cca4101943ec9beec0d5be9d15b5acc18dd50c76e79de038d171bc6b314fea2bbb2e0f334c1c967529ec8dfe22b02952a277d867b6c136d382edf6dc3bb739fd0f1db2d412cd9005ad898532374ca2f3da1aae8628ba79c69e8f15c887e40631ba5696b6cb5e695415adc6373fba416083219e91bdbc4ad8b2b5bf86a1e1ec414ddbc4cfa26ed1987348ce4a0d4ae54461eb58b69beba413521395538f118f9ffe5b406559e6bee4c4459dd7e780f6859e09ffa579c111a6e16d2d867935f192268bce9b1a2c0d3c9411396e7b30991b8e82de45fdf6e3b58d4f5cca6c63ceb668b62d52aeb49d81433a8fffb7ea2ae33af3c2e283a5f448d1782438a7ecc83b168939dc6ee8a6309f9ec0f7eeab8f50e28f422a0906f52689a68d226ab2e02137265b54d791a86ee17552c9595bd786ff59ab57a4ca9597a56479836a6f1b9d9e290dbd0c1626d436af399714d8cbbd845a5a82075534315ad763681fe3d35916480743857a22f4985db2fccc0a56c0b06df4df7b3f964793af4b1846e5b8b26d0e2f3118f94abc72bcb9c317cc0c95d05a1f0fe2700e3e8a5478197820fbc7022b60e5275361a51d35228f61ada90924683f2de4ba2f6951c2806d2179e668399c646f596755433293b0d50f049cb95e0854c8fff499e61333353e55d068ff36a307f0c0b4ec447d0ab5b8d5f0d3fc47184f12610477ac5773482541cdd3bf2b11d901998852a28789faf3657d5a906326df77ce1070f6a86bb9aa232715907870ff91aeade831b493f9bc1beea0a62deb16940cd0c4af54d89cad814e56813d4cc1781daeed5e891774dfb4875412ceef9632b721f14808d99c966d7cc88f28be564672528777de7f8ae678af7c533232d1077cf4a19a917079556567bd1e4ff14121be1f185b51ac948d949938b89aebc418db73e0364b070ff182281d17dd5a45382344d4d0fdac99c8b22640b454276b1fd36006811ae970d91c63040d96c23fd0431186cdc0acfb702f39ab94cbaacdebe34259b417d0ea0c5ddfc1356aec2b2a2db8cd52fbf5a8497b00da8c190ff52ae47ee2fe7d1e8ba63f3fa66c7c09a8e4df2fb5241c866869b6ce4b3126d331c997676246e24280bb0da9d5e8a549b60461b163bb3cc02acbf2f1916ab38f144241bd7ece14c39e55b6750885b71e9341c7a7d23ea41f6a5ab7014d8c45dba16dfaf4797f14479621bb77f598943d591733030247238d2201aa54a4922ff69489772878e8cd8272ef43acab0fb7e6fc94abf8f8271da4bb0ed9575616647c02037f10e1d0cbd5ac013560144cba1c2ae460dc8dfb7725dd1760ca04cf93b061ee10df429896850f95a3aeedd8703f4fe647d3dafd3ba18fe5a30850a1e396cddd6701f089c4b3e0a2e616f894fc988e1859ce13cb145b99bd5721c9d539f3d93627b32d92d711328e53c7fd191a1ec168278aa279a46b9533b736eff8c61303d91d92b336027aff2f2267be552a19e8f72c7482cc9a0f6bb27f8183c9be63df9d7e63a3e1335156e82ada1facf4fcebcde586e6c706340f251e82f0a52de22806e3e838a6bbcba7768a3c2fdee65c4a9489593f8fa3cb0b91ae30dc9c8a0d341cef7476c3f22230d002c681fbd7be218bea4beee47df1f602eb7190409e5671aebf847dee1a21a59bb9b0c21adbc0a73ec78e63374fc702c2fe2e1035b81e70f5b9d7a03267a2eb110896b7ea885050c229793be46f838bfbee9826bc1b70fe58ed86653db1d6f433cec1f8130da1d215c17cc7215e9944dabe42a60348abff9e2a680d60123f77210f31927f918991e9bd6b42368007fadadd3ad6883d6f07f7a616457978e2d2f8f719353f3126ce3e3db74e65594c201da5d08eb942951fad8bf3418747e56dd83fdf9eaac72f2f810c2baa1fa4f267241577aeb5918f6e3d9c1ece69c265ecce51a6c80567c435a4c2affd318b522f5f0bc3b9a708f68d94f28ca9db559b2e74fb90bca88f2bd24c7a71bbb3171065a401f937651a64294d9464deb59c21e722d0c96050462465d0f4183aef227a862517c9debba10db45378f80b323f28ddf469adfae07617bbd3b8414a756a0e96129750da1b7a7d8908af090a2bae4b74d986cde64ac7537f12e428f904c75c274a9581a1e126979dd64967b1e5df75ddf33f362309676cb9f4f1b64dea4ab43563c49af8f59601cd9a2fee19169b8fe03781744c84ad546e6e5c8cd200f2df29b541bb3bd5d2291cd8678de0ab86250835544b34d33635a820673b0c9c64cfc94fd106a44c197f6d8b6b6a3e5ea1479643567b6ad2556262c3a46ec2677af66c7303c8ad921a5a53bb6f04bd2c5abc829c50b7ae2b98851680579d28abf111e4e19d53a0d468220db6657b07dee9e3637e86d0233ede3bda504f1cea1166fe0ebf49758652acce8d6482fc62c22c0958f75929c4813c04ac761d8824714575c8c38063594de0119e53dfecfcc2e6f8f39dc5d12e003fded8ce91033eb51b5d1b3ceae18cf283bec22bf982315ffaebf3c7d1f63aab1d0701f9a57eefc7aaf23bc0306e1f2b2f5cdf00c040d949983386cbccb7c33bc1963f710464c34f73197816aa1cbf1a53fcbd666691f916cc0e7d3489ff6fe9785db479f113b1131472c8f3177285b1a88ea611940304cbd20f7982474c820af66de7a650473c31db6886ce4d1b39a8d1f6322d69e6cb6fa9389ec2f981c0238e322941b723d78cd9525cede535784131918be4e7dce6c4d407f5daeae5949245739643d90725f10240932ba0bed73e85be3028ca9c7cf6f71d272e702cccfe255933c02492b8ef1fe0ee858a8a243546707a4e1a9029fd1ed2f94a3daa3f8010c387df795942a8115310534b9cc3bd44ef78a3f2787dbc1466b72160381505ebd25ac4ee7f0ea4a706e3465a998b2c66f01b659545c88f9120aea07cca6c049f2577441816e54fb10dacb495d66720ffc76b85a661ad2c400dc648034ff48404ff8634463bbdc9f036fd9569e5cc414c9abb16eee78c5cd341579de9be2a1245c9e533b01ef0fe3f2a49b162b7b96b30f7ae811f8676e3853649ab3f4b0d6a821466aa2fa11be27e9ff5eeaa5f160330e334e91de5178bc85ba9fe549327eb40318cea2ef5b821919a54f3929057cae5ee0c0ee7e66f760429aaee0fafd72bbaa8867d3af9d036ed8564dff1a33910a8e34f94f5869d73d72d0e7721627d43385036cb4542d17e22a7b3356fd684d933bfd397ee2a65490758b30c52d83f62621dc7a95abaf30ac4b173761afddb5cdea22f5b8c0f346ced0a330a03b3710c6c11978aed4663eb9d3de732085e2cb36c4036a309d2e5648fa1fea37193f1eb65775ab3f54b8f331370bde16a7ac870cf313f2432ac83e55c33700b49a5faa35fb618d7e30829d5cbdb5b6a04e4f1f2bb7c61c7edbdd5fd6923aa131346fd8abb3a7f6482f40bab37519f8cbd720c9eec207dbff1ab328f8e1e853a303b4b6dc854b60ffdd536af112df085c8fba827a6dd4472cd033ea849ce3a05e0fd98db1cc7fa3805f7103268a4d531596c46d134133db30a1eb09128eacb20d095dfd10bd7ff1048e9d62f1258302659d18932bf1fbba71079a63e140b2eb54fdc6106704647479f3c6680c39000d3173c7466d8332900de70c9f4ebc37a55575722bf4dc60b41a55cdfa7bb5f77edd9365c8c0fdf6d51355b500d1ac31beadc5c5ea604014556c3ffd963252a5d9ed2c6bef0d5c0e07c04f56828308fa22a6df389985eca1870566031a6ec1a9aced4bf5e60f08e0aae649ccc92decc0a072f66b4ca0bda5bbfe66ca91afd04681e58723b62ebf518d43c31e80dc5347698e7fc2727c6ea8f35fc3c8feeed434cfcb4e050a6fb155648753db602fa3a603af009cca89c6f37bc84e7f42418a3ce0a844abe2c95db50a6d7d6d62607e85d78cc63ec6934c1ff3ca07b6d9c00248bbb28999fcf4d4c3a00d45208952e1950a6a3d10840f233f9158357558568f03cbafc96fc931982f24e58f718b720045a8ead48060bc62eb26a5518e38548c3312206a39cd36bc79880caf457d58605a995fed02e36e4f1a9749aed9d1142e182a444719eebedfb76dca44dbd917e0b9e64849fb58361bb468e16a5c936f8e4f52afb9c0935535d232574dd0e3e0c3f77fb71aed1eebe9e2b31a81f537bf0e5881ab29848dfe155fe564c14c2dbb6950eb03ce6598d152f240e3c0287b7e38999a16e5b0d11758dfbc575d5b259a6e9e30dcf2137e65f970dc86fd2aefe23bcd0037270e5905cdcb3632b78ec3deff81e36221455973f211320c3f966228a43b1bb659c2654da0e12f4970128182eea191fb7751f00651f84d83e7387f621120d0adcc24ef8df523587ef6309442455fe79d760b455dd00154a7a430b75a4614cebc667402533a238ad519954b36da4e1b306f4f0a36f59eadc4ad506f5290bb9844fa21d1ca083675b3b1f0a7b62d3d5a361827e51cb3398b0c1c9eaedf31fc3064297959e8f0d2ad3543534eec4aceb5dca49f00ef77e360acc2d250bac8391a1437291bf75debdd8e939457146700758a054374c916dd7ba0edfa2082ba05dbbf8116eeedf5b90f66bc13d1af811d8148374ac4edb6c8f2fbc94581745fa4cc2fbff7b4a66cfb2af291949cf9ccd92da1fb9f09506c60fd65e1791d394c7ceaa6f7e309edaf5880f5bb051431c5434d8573549284e4b0968e7a30aef2439486d39ef00e7b66db7bcd99adfa68f492a92500e4a3f2e8521b1410af3879a42540b41c276ba2b23da46802e40bf885f85e54c1df5ec8c5210b0c021ee7f5bc559e42ea1576ddfc78bf2ca19668f69c83b117448c27b2bb680f987c818732b68674ca77bbf6ad4a6f29677e6084e0c3a9f91ab7246f24d9c07d6e0db1064da5ddc703a32b9a193669281d475a9b7bea1f436578d9518f4c0e6b95676b8233939fbaf89c16e63f7f2e90e1391a8661d44aad851cd05199f1124bad4bb5f45f6ca225977c63fc9bf9797bc93462790be8fb5af4be0d2eaec84f1bc0046df758c179567efe07c8ade66cb48e5666959c79f23486a964c38b41a14166a9dec6540f54065c5a78630efdc0883fdbc34c7afc4f5c093bc523d08624bbc4e1b31c1a2b4a56532914c839bd5d2908b678aa7dee9ec2e86780f37569e8e3ff55f0fc7b3791d41e50d0b51ad8c35fa1d5420b91606822242e5b13abfc6ae4cf1a3feaca31c93cad0f791356a661aae382b4f519e153824b09957522601d6d0c734cfee2ddad3f6bcdef64be405647a38f2e91a66608f370db04a18bb5849bb83369e651eed31a2e41b3335a783e406bc84eb6f6e24b451ac1004a7fe5bb8a0fd7e5cf4132b128e201573b42a4e24340d52e066d4235ca210d85999e80317431bb942c98c8d465c24a9eaa850e179adb50ba0d17b9e0e70935d1e8c8b94cb12c34770b3c91b2df6637b1e9b3d8208bc6e4d9bf40c5746b2de4a756b6a53335c9cdaa893ac4c934e69ee4269cfb6697c10ae493bc343d22696ca9336625380ecbbcda31d5c931c0ddfc5753d39c555ea24ba65f1aabe2e855d65eeb32a61a684a3a8b441dd6ab59c39eea4f59022b636ffd6aba5fa6c1d63dc79c8c41b8ab7483e7134fdd987d200ceec44f248ac1f6ebede316daa698def272d6272bf8c3205210042eedd458ef214368384c8b47c2c632591cd8717307b4d250b379bf22b253f3d2a0bc63048534884f17b331913ce79b9bbc12a38c2932a4713cef0d1ece85449f4eceabc876db692eb80154ef36418f33cc4656832aef4bac66a3f05dfb2a151f235d715eaa01291c328a18f74cbf545c07d898dac6aa19d0079736b408d858294a1c1c54298b2f0d7b6791adee2cc61c3e256639f1b62ed5775085e20308e47a78768f0bf16b3de4c6f4d5888638bdbfa8b44677308379808701e98c4d60eca90359d712f39d54a09ce35ecd4c628133063034594d51be3d01639c186f1d537c82b0a741ffe574e9e08b5bcd680ea2939b8558318ce1e4152cfe51be50e7e71e8f4d13c6819aef2bc8ba5424f6286928834d76634f6ee93052bd35e77679c6b1bf894aa3fb5424c55dd6bab7c8229f2cc5f9e30c4b49efa62093bd3479a6b834df8480a1856be575a718a7c70e360a6ca627704fb2c414dc83edde6546f63fe29667345ac7ebca9de738c903f60bd42bf304f3b6ea93b720d9c9b209a22cfc63c42042e25750defd177fb86fed9ffce7e3e5261ff4cf91bf28d0e78a5913270def5ee86581aed04769fe377aae6f6a07773cf10b660e9c8df5b2770a06b704c49f0448cd09c6f13f3481fc4a2de17c4e8a6883a444dd770d0b0705015f15160becc43e6c615156102262d668cd46d1a155d71cf42de76a89682216d773f0b95cbee949ef2300ce04640f8f8c3af13bc6092931df1e615dfec9e24ad781513f52b7a684a14f27cade3bead4939a0d90ac77928066d55f8e63ebcb4624d388799fdda4b0f9e145455bf493938caa66af317e27360b36dac5dc62e13a15f55c84a2c832d08717f9c19f0df0c316a931b92728821aca13237f8e9f37729900390bab184d9a56f3582918d42a39c30f90a908c74c3143c3b892ea6c4e4963f9016c1bba54a2707778b363a8e92720ecb19829ed570b6cfcfbd40233c3d3bf9c3bb1d1e91ebe3b7d09e00331e16e57d5e81b5c9e79a925a858bfe3ca87344e60fe76c58316e58c855e88d98263f699e276e3ff2027a7d65e33bf88b25ef156580c45c337d16ac565aab97c3a1911166a560a33c28d9e3bebb454e5d6ecc03487f4c31ca4336719297387bedffdcb4dab53eb2b4a2384e76d1912e235619b08b0dde6b4f6fee3b9f6567996aebd819d0ec22901aa6c2c2237c3b8abe88074b3f88750834e834597f07294db7d9dd9b2dc38c7721142a0f4ce24afc956f5c8d149f5751ec6ac8c0adba5e50913fff2dd4237d8d81baa711a64d6dba81a960bef847180d2ec87da75e895e2b5e9dbe7ee1f4b56646b11980bb70f50845170783c86b8911f2c5a4115761f8bbcfb1f1f47cc4db7195d2dcd5f43ec7027da6db2319e7efa572b8cf8b38e29a766fe512ccb04a9a2414e51a4aad2e0ff315061e2b9df30596141e4847ae749bdc61344225cbcb89d11be9cb3c66da6c7b0a5d45be33644975453de886e720e49483d7891617bbad76666ceeec57d224e5bc4dc7310c75333c92b95918151f803ce6746c414194650018fe7cb76b808a3c7a76a1ef0f35ca1c5f12ab703ffa0075d4fa9190736e91fb264105c8f9a42f3d7f28b84b6c45e275196167d19ae385973d4972f963fbe22f67f8d73d655dad02648f688cb06e88f156ed04d2c988e74c7f0581d49728340f8eec5084a243a754d7ccb93e114ca1a45d1caccf705fb9f1e3f0a8dc12a4f1cbc4c29020f86b79820d4968a472a53f041c2c5174d1008b15d6e3f57e6c5bbd4b3cbfc2974f3bc8abc6739e26b0a7711128393d3a77699ec9fac00721c171648a8b58dd6b57ee29ef394614716fa2487a845144f1f28e9e961b440a8e7ed94eb9ef57f535c0f8d995ebb4270427aaea35251f699ce91c9be6e994832839260abb823b878e6a661de4abf041d2715bb391504b19f8b16dd1cdd6bb7692d2784630e2bcfcfb9435c4921e103dd05fe2734cfa5388cdfd92b886289707eb33286346dd5eded79741fc165434c13e5e30925648791e0ede3bebaa5eb8d9a8005c6c9214d28fb0b5363c609f0103fad74b86b4cb8d0446e8925c4af487284583a117e3db31abf0769012d4df6281ac2fc29b9dfb5471dd963e8ce785d7529cbd3bc20bc41c0efd2751df65b1e920b9257318eb319a01d9d57294643a2c50879c5d2f5b48a5212d8963c0c8a6eadb8edb10d4be0593471649227cd3365eca51ebf60f65f90903ebad25e13b5c593942c24c8b241cc3056c0fcbd1404add7e2f9ecade52a032cb0d20884e92647302800a0d656bbe68a1aa3cc830372d33da8f7e7a7a82165ce512345879c85e0edf98dc8f2cad47e65bf7bd7a7c2d93f821cc644fe220a585d57940522a513c3bcd8bd2f4af02cea1e6b6af2fbd6082bf60bf2c879df85889dd0b808a73fb2e2e7d672e9d08f35c7a6976ed34761443f0feccb711b470599b0808daf4b95417fbb90ac169395c0d762764464aae4c006cca4ce020a31dcf9730d2e004a3e5d50e4c1c52f68170dfbd08a4eadfb069d8164dfa3ff21c547ef4f727eb204da61f3b46ab9e4995998044e1dab187a224295dd1642758782fa2b6b1ec07ef4d1c9a84a73d2f1aa95aebc4ae8891610bdacaae13dc32264c2bfa932b5d2e0c2e81a368231e8426aeebdfde7d5cc709d2a2c0c1b8090437e7498c65ecacf57a0ef91028996e9dd7f5638a76079df9af32bf0deffa29c86ecdbc2da839c237572f2e72304494dc363289b714be0646ae1a20bb6ef55a10658937247618b805bf6dee7850f727f155f13d6c6316b5e78a103679ebd4c46417b632cfe411762f813ee994ec31d9e5aac01f3ec9af49832f39900b0c3cb3a94a1cd178eb649bd4e409cb387612b78de4d32bb9f75814bda33c16a3358cda17ae0bb1c3ead5fec375d09f9cf1b6ec6c25263880fac7d829d36d6ac1d703f03f74f1662a1fe05b9573d57699fa36e62d3fc47f3be62cb5267cb1c2a101551be796205711ba98b1a3ab121d9585c749a02249aed6c0ede52325182a835a80556e74ffe94bf9fc78a6678413c6a516791cd9b36b2da808f3ad89578163fc4e1e7f33c62b2b24d8f63f8e9586b68d42ebff7ee459c41cb6e8bf26a584eb6d58b7ef46e3b1ce9ac9629d0858639e7b754f372ead398722dca1b3aa62c0d9d006da86b617280a3f33d57ad59f9ce7fb08a21feba14a261555273c81ed4adced2bcde06b6db0e111892031a2b09153150984b417553f5c3f6d90a3c61f316ac74a76d75401f8bbb2731e4e22c218b22e7649184ce3a59550f0760f5ffb0fe87d4ccb82e34adead186160e2c8c1ea701e5b732317583b16cc1a00549ee5bf928d82299b3f42f24fd449d4cbf9a39a1bc47e422bf3c5dfe568e053eed3a2f0cfb38fea49bd3c5200b84ac9ec5bcd62fcb653ef7631dbb65bea036a39e06429f6f7b6798c1c107807867c0a0b0a9c24ff0ba326e2d088b75253153665a8e9d4c43da05679f5e53a24b6f5a0bcd2bd0da214528e07c7ca4023cc62e44365c5ea1c90b343c92ee53e1e5a3b09a60992d3e9e5c8fbb9dfe83319ca13417d6d48247135b4d88e4699d49d08e13dd542337f079bfa6cb0616b56f7609cf944e75f4e38d501dfe6095410ce9bf55098916b84cc6cee0d938bd6a7da4d7b36f49f4e3b9a9da3cbf70f37506163b9d408cb737365ab67def357543b6313b6d06963ee65fbf223a56cce0f0a8b93d4f8599145ee8654792f6f6d23128f1fbd91aa868a7f24bd21e4ebca9c1ff8b304d98839a7a6db8945323e5ed4214a03bd2104a5efdeb84aa9aa1ee80f5e7a7f285171afa70247b53e8d152227da3aa43ea1422dccc16bf1b8feb2f22920b9ce7ba9e68b1bcff2b976e3a9f09258b14524a58a8cc2b3717e9a64418a5892fbc30af0e988dd797fb58621ff3f8255ff649bd461997eac99f2e738cb3d7c4d2fa112337095bf33fc66a736d6f86984bac2d6972eadb7d13052834d65d23738bbb0ce74d4e1cd9d48f158c15d141b08b2cd8cbd6a32cef79a7cfbeb3b94fd1329d23b611fa968d7f1cb4904bad64ee0aed5e3d2b4b34583d3457bdff1ce11ff482a67f27be49273f5c686802fd6dcaf4a8807eee89a0fd0b323e836f86f1a4e82748ca4692066a99dc935b673ed28a66da97aaac882e017f4a41dea1f7c25047144df6cd91030b936844ea5fa7d7e57d32f32f6993af11b7eb36bfe5e7f8e64a14313fd1740bb6eb2321ceb2dcffe0cd67bb2bddc8c82f2a40fa17248a2bd19bcf97ebe2e02427bc9c4de172f46fb288d3ea04d9ea075c4b1f39e0332c7fd0dabf62059162f978a161e08f6b0679340784ef02dc0140dcace60132b98ad1f682eea8b26a2acd7ebd9b2361539de74e8be1582178beec89710ae33bf0b5447e85c53c603d130318fd6b824a3deb9fae686e1dccd302ee18945437e8b5e35930e3a5fd10dace978508a2d2764d20db039a49a9dca9c929f5b58b0ccf8a34013e7e338882a8f6ccf2f83c434bbc0c552f96bc9ffa48ae5b07ca4a1d587ba76e1f22e01fd660b83750fb6c1bb808a949e5ba44f2be08a74c3ea8af06369387d7c79402c81a21866e290f53b1243927f1a6a917e34e6618a2060eece40dd8e4bc6d3d85a33b2d7b3e0f5116dd03094b6f8e1ed244a173a3c806ce69ecd63baf212a43aa6651c26013d6a2fb6320c9eec1ee1ab958b4dd6648c4372e164bf572b6f8f341588befac775af60e84a4d71c96b8eba12f46621a145fc197e5e644ea3a5c85762093f75746855f07427d881321943e75e5b46c1158a55989468684db494e00268686936454fe885c6ae709328de06252a0ce8478fd80dbceda33f5beda647622333e180e516fb55ec09bbf50567d7531c7030394105a02a2599c498aad9ff3faf1abec6a4b03ccf8deb7e9e0b9d6797372fccf5b43a8db700827b205d5ff64cbc003c92146a2b89cebdd8a2f53311816f95563aac56c67fa90be5c40a9bcec98e6880b48569a0805b59f2e2514b928a87f667878b5dbed80a5eb5eec4ff7d03eb2dbd1700a360110f0f0de5c16e2eead00cae3c0f4962697decbbb7360d0ca3be6ed903b9a2255ceb31490f0cb853dd83960418e7e7e760e87a87ba0d218639752117bb686db29d866312f63b2e368ba8e9ad1c341fbc389015813a2b26aca1afa16c7269d253ef784b86fc5b609c04565546b8539cfec0387acdc32708a06d8390aa58cf6b404d67528fa56cb1e2d268433def995262ed1468ecf9a8d0370e40830aec2e6290f877a1b823a309c114df0d1cb8d691dee4db0dec83d98d7e01059fb16ea876d7861d545455027257dd9cac3cf330a3a67a4e87c390a5b0e39e3099fe8bf69eb29393298564f3a8067f0a7100a6268536d2fc179d4f4840","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
