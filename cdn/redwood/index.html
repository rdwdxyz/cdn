<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4aac809a8a751053e295414dc47540870396ec1dd753795d8eeb386ef0717d914ccbafb99a9f1cc59d0dce9ec82325f00566fcc338047bc76ad6bf10648600920b6926134681c3626d0a4f6aad083426eab96aee1420bd75a0254ca279528556fd16d5cd0a1fd7311f529b99f0998cc5eea048fd0739ca532b8781237c89debf0b04a9f60bc6d4be11a35715cb9168a1cc60cec725d74d02ec8128c7f26fbbcba396dac35e97ddd191077b17dbd84d1be7f5c8da31fcf9c970b1b6c060a455c2319cf5db292fdae3911d80c6e925bd189f123cc2a7a8c3977f2edc21b7ca493bb09852ad9fd706c9e27496ff422e3f3b988f188d8a1b003dd9d0806e40b40e02e0e33d807c44ec77c6487e18f12d6f70c7d5fc470b4e274ccaf68d7ff4a38384ea9cfbe86bc148b2a4343fced48a4b7bbffe1e091dc63baea6fc933e600c91399deaa7f371dfce7d8538907d617df06fe608ca6c997466beeed02514708d5d17bfd63a4cca8df61ffaa267c7c750b1471f1a421db7807f4a18704e6fd15d17d0efbbb3146580434f1523cf820cc2956794578221f7ca465bee5b133a6919c2debe4a783f8ecea3c8305bffb837cf5423a16f32e4395bf37b9e637b6873e102db0e8ee5a97ff27f6112f1254722a0e399c2b209919906a8452b58cb80c23318729a29cc479efa8f94053417d7ae19ba89f1a06c8b13a6bf1e10a48c40738074daa6ed691f0f4e7740bacac48cd7dc627e3f1d08fad389a1f2aea4a3fb8cf4afc61c2bfce5671cfda2eae0c0cfe26e57e65323a439e9eeaecfbbbdad80b7a17dd653d581c449fe60fbce753acccb25ee782f3241e1a2c127a89bb8d48919e4e0aab3eb5eb426ee5e0cbb0441186fb3e1d82f332d0ea096f3ab8bb46dc5f7983ba4572a7c4904f1665b6cb5a47d9e68ba2ccfda9d959b023b0b210135b4ec553a0d5e4835844b1d21f83502bbea04e63cdf90b7b4dceca4c009806ac78e1d3973598ecf021c3a40cfe43e137d939a5458a1675377c97d71561262ba2af73f3b6ce20b7cd084382d48f7cb9410abc9a37bbab48ec9a7276c87b63118c1d7baf1e90480ce7e3dfa36bde976ee63ec168ea79b73b6c785104d6a3c5027b46473c4487d988a38ff3712ed8ebcd84ad94f80487af63d24a00c109c06e2a57af39fd63eee648e4d2091f09514e71ac8f2325bd60371d1d1bac0a860f7adc3c8aed0f3fdf0a9ceafe2cef31bceff806a455941d3e848a0cfae9cca8f399a7dbeb78986c12e569d88a3237e34d9abf048d69ec5da7932e9a70ddb8d70a2543f05ab2fc549e8bdb0e7890f4234c9955b1d68f57aeae42f3d0938145b8a08c6d71505ec50fe783bab2a0c2abfe52417947443f717e1fb80d39a5f8a3da2fe9b2badd06e617d029f0ccb8df4a33f80d1d37cb581277c8c285926c6c7bb33380123bb3cf12ecd88d56eb2a1c13186fd97f576a4a3ddc644a9ec62e1beff05c4ea21b301f6d6e1aca9282758b4c60f56d7e66d194be7c2bf31857a1683d01f3b20e602d2950fec0beb8b07368c97345220a04297f66779290f9dd8a392c5de95a9e555efd63e4b3c2089486148875cb3814fd7de4d74d7d19d4f33c903db6c9b03e02fd9d6b89c920696606337dc99cc6407d828925435756c778762ab8fa5c6c8121d7fa790b0a80ca8223e1fd5c9336c27d4ce9227d17cf898cd4b21abe07dca9aac6b2dc099340ba5ecbb29231be83b5a5d60b219500cb348711f82f40e4258ed1247828c7257283211f50382b5dd6f2cb0fcf8173ac130898c2ba0272ec8885b86e0c5d5dad7c9eef5299bbbab1a99fb60f4d3783f4716d064eb13a1d0f7a1bf17f8de6949aff48253a2f5843c09d10bfd6516093af29df003517bedad9f746a9526606f72aea5826c70f938c8740ddf141c6383af4f96c918b0940ff1c9f6901a9ac324d8004e3bc684eb02812faa74bee2d28762c48b42db4a9eaef2356f13050b9beefd4dbcc70c6dec4b29cb24814abf3a1b5eaad2d2b2f98c1ad25f9e7a48bf6a9d8b5bcad1dc250c7083146f6959275ca49be4e9ce4cb4b8b2ae5388e63cf083e12b6ea1624cc8af9ce293ae33755c753322ed613ec66c609e8ade553f312e7f0aac4535620afe4c5bd5e328188ff244fcdafb9e1954f140538febf2088d8cf55bd11367b5eaebdcb6df5e758431e1263c42e37fb49e6d0963f047c555b04af1e901c7df082fe787e22187d01543247eef33d45e314eaed1f9db97992625ceefea06a5e75c63c07f34612297a2c4be2edbeda9cf6bc3282421e368a625a941637f54a5c4a2ba4e9bde0df3487d2eed4683f8fd57c9bfbde3e688a99cf7b7a0c16d52c84e1afb0b18405e8c8823669df36b134784d444aa34ee47d494834d47840dc20206fc80c70f1c90afad9ae93a9c9ff8e93d0139f6ebdd41c51aa235f26b72bc660dc7a5dd34a923c7b07ffad1c8468e9b41690552fe38e2c8b3b3b77615a1f93ef1be6b5ae22b640d1383efab307881a6c67158fc14be8de5b434b9b0f6285c7c6931a409bf9f817f268980c7093d999463579f6cbb2f3734caf2554eb1333ebec6d14c3528d896d50883c891e6bae49a99586aa704c922ad1a8646cb6e82366699b0cb805404fd51d053a991e57a042b18772eb44141880c49b53ab9894b49fd2128b63b666ce716290596478f4423cac48304013d790b5d450857e51c02e37e9beeb3dea0e0a5e1b9bbfad8d5b56aa48ccd0377295bb89d70a1363c4a6d25b393691616d02d9f894bcd960d7d8d9f30417682f4c545f17163d6aff3682621c97482628a621a27c115811d60a1e04a669d824f91d9fa0b2ca84efaa4c77430b0dc39f0e884088618f1635f30931b4fec2fa551c4d022d6296c68c9cf6d9891b7a4ef26636c32887548f0c7c2f76bdf6dd6589a58627fcb5193b2d9ac98761e539aca7f0b8cac03da28eaab8100558ddee6600d18fad330f385b58784dc02c52d147975af5e6048c4d0032155b2cf06e46d7878b23d68bc9511c144d8bc8be99a682a5d8420830543abf155f42cb92e4dbe472b2f190a7654669a42407e111f3c67fc762a2e5538aafaf1900847008ce943545e3b1586234e32354e45f63612f97dad86086e0bc3335bee1ea971cb6a6476e0421ce283e0d9be5a4c6c71e89acafc93a3917686bae64d75ab0efb06b1046a6ae8496ec7bb1cfbc1c68f4ec46502223c63b9bd0ae7250253e666b550054e08884769ae6bc3aa7bcf9e5d84a618c9709fd8a8893a3e99f032cedc74ed4900d3c5d720ba3623163e237008c5a31a42eb4b03fa6ded5e29ee098ca8bf218837518c64bbc6ee4199fa69ad91ced6c92c22a1472f2ffeda07d1332ff2c33d97cecda3c1a14f28cb124f6c456d544d06ffbc7e850b2fc4c0aebd725ea933f6dfa3f44d09e5aa7bc9bdb298be77d8a16a812355a5286e66860026aedebd5d18fcf44f530c7c59c8e5d8195766c779758926438084570b6fafa5b25cbd76858aa1af44c64784435a5641722b9beb5fb718e7cb454f29a9fb1db04225ff0f38d1ea94eff58f271fc73b377eacb607a9a28573177ea580ddaaf073331910cf5413cbad8401e634ee0f824b4cfc6613f303afbb11739a74196058244253dfc15266896501782c8d542b461f6457fe1fac421f7827e20000bb04ffbd1af0e61b4cfa5e5249afc48eab5121649271133d75352fa9824b5504ede3f0df30e6a57e66f145f36f59f02e9a02e1cfde99d8684e3f2887408a0af804b5047a45b91127bbc54e81242ba816da259fe1b2286ad33f1b34c09f66ba7e437f64ef14394f21442c831a28b101ffbb36ef86112cc9cda5e4e32ebd5fc57c484febb572429c672442831ea4aacf52fa28733dcf78de380cfaf637aa0002698473d92ecd2cc74bc5c2dc1ba90af2237fee12134eef51449a0243b99593d01f65bf1af39f6d3dc6478b647ab356cb8d97bc3d633bfe9f665c3c3189149773723a41932afc15f6e852d314a491896843fa9d5ac9e7424ff703fa4eca45d01bd23a9109d9c6b72f644abbc0db3420b29235e7d6e697643e6232dab5866e70599d48dd948398245ce6ddf7d01bf4e578edebc405e5fa32e4f1dde22c0ff53dd36d907343c629f58268d97b0ca8733c26c544bea42bab42e07d19ad702640fcd223bb05e1b709249dd9da09c6d1ba251cd6008c4dbc386111b368d00c59c2a614ae3a2076f8db1a7d927c9799f8eee06f5a9051f1a0761428d4f51284e572a25b6f9db24559c8f70ffb3ca1adb0b34321addd6df8999ff3c58939bfb185040caa58f3d6db9e411c551b752e9966a3a376fe7a201ab4e84890545287de46ae2b42ee6b54a18dbc2cd351f2aa59ad8ae9ed0a69d337ed842a948ad58c94ab50e607ec46edf5b4c34751581f7e818f6f5f5b50ecbc26b203bf7785d5e45f8cac150f05be2cebf81c00c28766ae0802a8dc01c3639c53185db90a0a40b32c6ab9271fbd40e9321151d09c0761616ee6485739429206ee25c144f4817adfeeb757f4170348bbb627cc3f0c1ad1fd1fae9c44c8641ab16127ce56b5560d3df265e90944ce877f8459aa172fb5f760342d1f7edaeca852cc3826ca3f937ac445ec1fd277c1cf0f1f5fa4a98af03b31d852c8ca8e2c30b63249bc8eabc58c82fbb7abb3c27ba5e974d63bb904e4dfd1f848a05ccc3640f9c3626252c3c7ae925b56e47b632504098ed3dafddba5b02d452176c7e3e7ed483e53287d721b1e3415fee3575f8a31f02f606d56a4dda4037e27714f81b9a5c5bad1c90a0b6dcf684b8c65cb577b351b7a64625d3db334d244896c2d30a41abe13b098663729663bf5e003e6656d518498caae0699651264927c68fef5db6917fc5d30998d08699e442030c559166c055adae5c4485b68f14daa10ee04ad96216a915c59a530bd7ebf33f0c271e9e750aa950e4290364b9abc80a59bee4322bac09160cab534540313d654627819e6e7aacf40ca6fc01dba6234e073618328c259b4bced21f470aafd0d68ba9e2618120a0edcfa872c34419d9742b5b71da1b520c72f31a3071dcd17cfbba3ae959f5dd3b8a78bceb39841ce8e0e61ca1a80929e75b8010da8b4740029a45338c53d66853adfb80ac679d33b29f88916a5c853b2b0baa598b8236b80afd75783aa1ca0e7d68ffa8589919e5879660e72d8e034e0ab5176708a6fc63200e93b086f9e00333745ffc5574e785a4ea0b949099f0620fd7a0ac92d919d900d6bcdc1309ff7dd4986a7b42f35a23d77821d6c8f2fb1d92404e7028c3745c0a2d8c8a1764f8487fa44e5d6d56bdc25889914de9dbdf21ec3086fe89ec4d386da9f26445b052b191fde908e1753ceb6f18c54585981481ce6fb8215eb5e9a35c7d6e2221ead8eda2c58ed425c7010f642188148645219765d8d958a7d7fdcf96be1bf907da6c0494ad6f6d6955519db47920287f767ff342ffeeaa4d94b212b780d16c846edc6b01e01bb8dbe9abe2d52963e3694cad6fcf65c9a35e336c36ae056f5534e127c6f8dae877b68d26eb3f5bfde79291c2cdb5292224fa3b3592041dd579b8845b71174a315ce7ac4e35ac8ce64d54ac89d6802777960227c5a5342c84d87c2590145362041a0408ceb5850b27ef4b35ad1a16a25b63b0b96c3bc6e355355f15200c44d69b627aecb67e824ba3ffbadb9b1a81a589d35d91bce673fffaba632f48215a0c104a9d767eefcf8ae11d971d397ee77ca0ad3dffbd78efe4f92d52113d51dc4ea9770e6c6f9db79e9b60314e41f648a0ef11234602a4f2f4b4fed5633ed1f90ea661af745d16cd81bd7ccef0fb5d5bd8fbeb1c60bda6e2e1319ef492974a3aa87a2bd70d2da85bd8b2a820df4f8c569ac9cd4f29c33388f5af1a3924375001e47036babf50dfed7f2d958642fcc7164cf4c76ea7a7247e484316d3de96c574c472d5fe8cd1fce390723ad56e8f9c08e5ceb44b178ea6338495b7066063b8d96f8db88f950aa5f3c37cd21972e09946a6c13f50b84a555234a68660320620b426cf794f78ca17e532d436a020f1bc0747f53cf7db7954f652ef9c530130647a4d998405e2036cbeafb1f46d2b8c616a9626cfcbd238a0a253432b77a3c86edc5b4101c0aebbd85c6f2144814c91e75de549d7c478809156074d2847f4e7c9309d6096bdd70b83781c89e2e7cf226dbe04e8956e9a4ecef6685662639214f9c9679023157a6470687a3504c581ed58cc8004d031826410c3be2463d0b8efb46af7495397493cc4dc127b10d25456a6ab593c7698d3b5135d1e767ff4c55421b4515c44d6a114a61feae04f42bfb4552d61b2c40884796f6b9565ea724036fcd0ed25fd4c0718681d0a5be93618a142422c9901450945940297ab53f6e4377523afef6f4a0737ca736206bc07323a61562e0d7ccb0168ca1c29e51801989cec60c4c3fe2136c951fae169d712f75bb19b10b811e8fdfda9c04ec1bf8a6ebbb7f2d89ad62c574ec1252c53e5d63981bc81b74b366357814cd468e55ff73b1eda913dbedc2d978ebe4a67275ad65cc88ee909898275db4e4aaccb6ccbd848c16d1e7bf7743ce6f0683a8d2b942144fb46969e807772982191c031fbc2305e26b764e4afd63eb7a25a211471ebcf2b92cef288cf451de6e45a49357e4b414a7aa8d691448d7e5707d9065b6cd6480319f4307bb73ea95f4027446683a9e52c07fb1e77b01d1b0880607c4a40c1cb89174897b72f633108c37b9c489a39515a03cd45e8975fe2f57cf16ccee9b44d82b016da03da855db7d5a1e823e47629ba6eef301ec368f12c1204576b410af043f753b7fca788b41bd846fa41a2a7ae909945e499bf6c2e22ba6c33f8c2aacbb5fcfc75be3c71d5afbd640245abc1aaceb79aaf6db952249bd312ad2cb1138cd09a22485cafc1dacc5ed2fa1caeb2c71c0eed3e53a87b72455e77ec00fd6cce24f96b5bcd068d472ad11b90076722ab7cd2a493e1244bd7008a2840f87d94b5d7e7fa39a7e34a95d9bcbf8a1c704236fb28733ea8bb1ba93be25b114a3eb1a695aba2ab7d4da066ca6dc3fb13a7ae2608d15fa98722a9aa0c731d820218da34d74e596f1982d4742554dbc4da4d0b17e60b22d815b3536a44f68a96fe3329fc97d64602e39e10de9fa4f81c04084b028cd0894b8cde55ff4bf0a08e1806a939072fd0b2cb7d12371dd362012df0248713400d1211a70bc922e8aa09b4f93f7fe91c82777fabf013c5560d631e3577041d872fd00f23fe5a265a07d711bc265ae0b93a3af02b8eb1f79d4bba4c5bcd573c037215089de43eefac7ef1b67468c8bcabbf853a7cc7341fa1b93158ca5d41ce0c8a1ffafa56136d2e3e130808578bb9de2e95df9540191a7404bb88850232a7fe6ed75dad5c8270dd6e93ca7f896f6422b378d237932bec510e98343054e606c25a3f087c8366bf16660f65d88582dcf604aad011f9984672dff4c465a9e317c414d44a27adbdf595d7a9fe20d1cc95fe45fcd456221e65df18c6ac5a5739861efa9ee992d19342095c6310b1387df551efe63884a5dffad22c068227291eb3e52c7c5565d08996d4d1f1de57276829d4abd4675d2955fac3f6f588f4982d1c7725b07fd8acdc5b4473bdc2c15205d208db51049a77a2b8e4d667bdcb9214ded798ff24b20da8951d7206cce05cba9646251eeecdfbaa0a60d64ec728d4066cb60fcd36717a0ac334ef55cc16440172a2501027da4d9467e720bdaf7af882c54db396c9d6eae3beadea571a70e0ed91160e8f309b2df9ac6c2cec795e563c3fc3c5b3c5042a5040cc744a2dcc61924bdca6a56ead9451a92887632ccb974f1de8f82cf30e691b037263dfa982e675013083a181633853fc7692f0b9813f4b6afbe87922f29fe54752a2dd78a9baf1db4d12c0c1c335e87c49fed961da0885f75a18b69121d1a6c1d5a06cfffddc87f66a1ad46d182cd2fef1c8c65110152a86b46c58c8d5df459309771acf5570e7cf97e19fb7f2f8e31ac1d47ac53f43e74224282419512c92170835d36a31b5d8be27c12f724af98b7190e30e0bc4ade805f31593a89c99313e9d9591a554e6e54b7cc15af379e01e11f4f45072b8f6728745c77ba00fc4ef4e1cab1640ab98043b8a23a957887d778d3bfb39fb2d65b63afa546ee1c065d9cee3df97d863206dc0772a97310a85de8666c1385375db1f34b85296aac3ae65220627f570a739ebc34843ae2bc9836896b55cec8a621ae60d2ce00ae614add4845f5dae0e1f4b4d07d9115b8937d77dc34d3fd430554f0baec5991dfb3e7b8bbced788812ece38db7f025d7307cda2a5dc0148582d9c1d96c93c6ed2c148754a8f6c970c6b0156e157d75aa81352d49f44df7f0aaed8c30121c8367a6f6dc7fd17d1233c35bd3a2f62b4ca0fc4cd9ec071a77a8ac9526c529ce8481f87e7b89a8095a6c5a50c56cd6b118fb04c44b3962c0e7ec5b435ea76367b1a65634bc82a7a1fe4aad7686572926fbd53f66dc5fa50c10c94bceccdc71f44dbb758cf0ea0dd5607aa230d781f85d07c4beaac7f3ff8fd053026739223ab3ee740be49c8d584b0afc5cd8c0e2ff956e2d705301ad8b8430e7d76ea4344fbbd5984636469a5b0a353f25a99180a1fa4fc6772afcce3d818ad399c297b982f29533274567c56d06bf0748e2b14ff923114d6c2c786dbbc1f47bd3c78cb8b1c11f001c93a04dfdfa631c72700b68d58c6e5285759f51458ddc64d24ba8add12a4a62b204a5806fb57d97c6270684154dac4c02d1af735f429076cc4ad16429552a1a121ac8a17a721f0c42b4dc9531334163f3e6d58f283929cd1e5e0c9de726aa6baaae20ffcf5137faab52764f98d54af51c335107c009327a0caec7ae92d78327dd0db7d252fbf7196563c103debde14ec8d80d98ba286a51d615f9beef85065c97e1545c91068219226041794983915fd03b693579e36e3cd9c11b7a1a51c705867ece52f6c4b66a1ef8b080891c3155417da5ef4cac760797e0565a64a8480d11919302196f6ccf166311de9f1088c094186d93b1973f2b748f728dd04ab041d673bd7b70aea929cdf95ac4c5a8ba4e71afe5a031994fe002c2f2201eee5e316dbaaeaefe801598040b2edfc503ac5c5e662d36f520e8cbe205654a0711d3eefa2fa6868534cf4303576c244df4fa16f8be68b5c03a772458d4a229fde5b6f82f41f970a45767d6c2f1bd74e2dd4a285d7590a88f86026f6cfb68faf9187b7ddce818c1b0aa38c1399e362095847ff351499a87d3940370ed3392a3e850c11afbf1337835f6c068583de36f1a790c18cac45efa2daa08cddc1a3930dbb04a6528a250e988ac810124112016fc23a834b33d52d386fcabd6c224612409ade3cfbbd89ff575bdf049aba4fbca57d1e568764a632d573c7bd16c55171037c7e32232426c387b4bb5c1db5dcc741f36f6225dcbe07910e59f3e4664f947b72250b9fc99d14cd651b62edc95849a8ba1034f3fe9c4d96af8ad711b32f6e81682a2adad4d924cb2b10da2862cf7384119536eb3618c800ce147c1fa8f5303c1863c7948de1cbb6f009c89f77cb01b1729ea6a46d8e0faa9eccfd3c137cff9677e25ce01bd645bd6461795242fe18b346937b302009be052328df30423c2355224f836c2603a0c0f7ddbe4a85643213146c5ad22c2906684655eb8504cd3cedb03f7186c57885ed4cc6dafec669d542de502eca554e96f613613d9eda4863080bf3f8b755d08cda91c0d00a962c1e1e0e50c8c8c87f05f31b36f87389ab74b67b80c8cf14b5019384a63a6238d3891bed1d12136518b792ed901a47c625005b0051a3ffd393b358a27cd6f5a6c05d7d66cdaa43f91f4a8f36e647c701f8915fa2037e9a825fed65a1dbf8fd1842ba3f143712bf2b010a8e31b714fbc2db08a47a0d44f8c8d8a4607390ab8f1bfd3b844d58436b7f626de0ff0183a2b77f4a94ba06ac5f2aeb26e94835c305a1c5eafb226c42cc48dd5d9538d7fd5e272c37c02b9c0826a2d5832a49a124506fd5fdec6b24b8668652d2343178ea6380c7cfb875c8c6fe216c3db1041c4743995ad63597bd2506ec1eab2fc89f9cfa110a098cceba5b53bda6df15674b06c7279b75a24c35bcce3c530d20935892d5cae4b4730efa0eaad4fb2730fa1791e468f8978465f19deaaf314ec7bf1715edf2b0f6e6bbaef9e6b7ba33dd724dfdfa30c5c86b0ed7de6ead805dc1ecdd66d9959f44bc87ee7bd33ae972d2a603d2794c88916b6144669c4103091c3561101ac6ec1db1ebb4ef3e3c315c51c03d527a45422ddf894b764985647aeefaee7c5d4693f7c1be399f55800a802dc1f00ccd372d3d2d26f4c22acf290eabaff12875cc2a1f4c152ddff83386db47f2ffae35d744b76cc4ae4405e5cf40de5a65ab157bad4f6bf38f7f083f4d13b324603c00875c7143c6eaf3dc0b24b0cb6c72a72c848b8f5f66529dd01250ead3cf056972b757c9144c7a644a946e6b5ae04de83046f122f230b446408f509bef57cf755aad006f68ba28705b70fcd6233f3faf6f39628f75261b4fb9d212a5199a268215ebdbab13fabbddf2160b5f04c403c86d46c757f7272350967c8842372f8b37b0bae86a060f865e12396d700981d6e4329d22b6f8a3dd763a260e5431f2a021ef2021cb1ac486e254c95785c327a7154c0da8e437341a735ccbddc25d4b1d362d6f4fb10ea6199c7131607679de92c4a4f865d345884afa498542c3bed80af7704a008b21adeee09ac437a93f95a4605a99b8fe2fdf07364ef786efc8705e5fdc449e3f48cbad753e53cb895d4b85a7501730b55492108a5ac6bb47033276b6bfe13e8e791c0dc12c9a096f2e27206601e775c75006eb4948302cb1ed54787eef41074c7e48b94c543e3a2b70c6a1f405bdb43bf6cbc5f0f4664c6f5aacd42ca41279d53452539959ba296bfec18cb9ed794f7b682760b4f8f7e7556c78e80cf4fd812b03f828b8eb91a0a047dbd6688c584976206d5a79ba56e7e2cfa26b2ee98207dfff2cac22c52be2b6e033e9fb1e579b68288c2871e175df78eb827e962aec12c9e6d76410fe77b4a4e0db9819b2179bbbc37f15c7092f492319821d70e5e107e0da063bd224cdd048bcff3c88c493b8d55594124c896f905982366ee528cfef4c22c879dde43293ca6eb180153a949816af9d47c146668c967b6389142f3283f9d43b90cc46166987c22aec5d5d7878678e95c2ea42de77015b6713b081b9b68194b2eb272f02d7a923130bfcd2341455e11fe5e83a4f038de0a348e8447113190463c28b114c91f5a5ab120c5bbee16c2a71ee799ea9f0fef6e2898a7e3663a47d36c970657e4ce213c2d2a2fac15e85ab7d02cf7dd363a94acd240a0156cb27751eb0cad30fff6ba662cd08b0b4e8aa9a9a5c02f79bce4807875de7336079b9397a6b64cb3cff7d643db471ec00f1bb71020d9fe2f94e1072d7074f7661c20eee68d33276bc55426f571160991b56c0472a551a4b5c6ac790c8661877fd6c3f0433565bb4defe18a938158092befbbc5923856ee0c9be356f3e01a5e7998ed1d653f544f392b74c92eac0cdcdb4b9ba1e46775f12093a12e95acda801aa36dcfbde21a2763cd574e11aa8fe2d535269eceef8821a5ec32a4156f318a7db70fbc66189f7350b3104f7956770619aa7b2af04730d4d06caabd473b51553e31e482d7c819999376b285d2f3070e0cdb08d5298e8e73945796e1c8c92b7d833c20bbc555b5968cf6e9addced2b960f037fca1d177ccfcae81aa85b743af49bdd1cf02fd288246d1a3eb16b151ecb5f3ee73605098b9aa06d285b0acbe52c0f17057012db456c08c0bdd8da4a4e81e5687e777cd81cbcb4c201ca47de557a332f7c60523d7fed1b6004fef909163a66b68bb13c5dde5ce05d8a09146e3dea73ad298cceee100217373f4abc0518aacf2cc5a2a77c9356df982ab503d68c808fdef156cd5575b5605eda81ef53cf899ec49ae56da4217a35574537c79065c37e1577a849682fc724db066132e78bd2e898643190c0a67414c592637f0364a031fec4cb07b6a85e6436fcd42a4e3182cf040d6b9edb2892a7a74dfc42ebccd9c5692299068967eab035fc735d6f7817fd578958c3111d7dc148012e2564091f4675f20533056a5d468657240863345f869a6c91795374355de43afed14e7d5f492ec30911a41f4f363b891778c6d8ff16431346619c641154970dab679d7d43e719df7e0e5a4898f8b928da2df8e88d5bcaf0219c7671a2432ffe8fee10149b2fc0ee2e2d5d354fafe355ab627907d28c1daab2dae1ece4f81c29e862aac648fdb3475fe6648a017d2c008f83b9d65ec4624b3e08a0c300d48e1c10e0f8acbfd59fd3fdaa605fc7334ba3f09b3a86dc457ea658cfaceb363be6855a4f1a3f1f0594a0c2992b11bb1535588b272b8179d2084a738be52ea2b5bc591a9c4b6459de90c0afc1c7a446508b136846f8ccffc44acbb5fae1b00c33f1ab3bf4de7b6fff18a4f32fed2cf010bf7c296d5a64bc98e570eccdc65fff1b989d84ce3ec8067b49fed55116bce4d4de737be53fa6d43969102db76fa331298fb30c434d29faaa8307d77775b02b4c34f4d3a0cf1bf390dcaf7f39f174a24ddbfa878628ec8ab79e8a1ed1ccf32d87a90af33dea31a387f3a3fe98acac764117edb22a9b9ef4ee88c353c43e13212c05f5549c2fe295f6e9e651530794680748f22ba3eaff0cdc34aebc77f783b13a5bb669a4a39877e92242e68e77dc6a0109968b3884902203085539736628accc49c625f8cb5ec4065fcaff35f61a9050cedd3bf7bfb9715db18f202ab00b1cead02a3db442324a7edcdd064248fadabe82a1196e3a8a574715b09ac03186422ff06723dd0e00452488556fa9c6a9f8dff1700b0a25f668e07bec51a5a398086d22077e8ac9394da1aa92f0aa064610ea3f0d923b3fe1eda54a6e908aed018ab09c3a75b9922dffe33372634f320cd6ace05e35a9f97068cc2cae7f2f84f6ea5fd3e0952da66057ff58f472c8deef70f802acf3d88b5ce574f0a51fa850c3f8cc3d6def36d12f435b62eec3f1e47dbfecdf22cf6921f8525ae4e5bbc959da34fc29676ccaac0e588a79bf7fb9a8c44e441cbf034e98b3e9e4c16f8aed743fdd81dd7f81823855c4b3a77c43ce1d0edd116a265644a7b98a27875582a69757cb380f8cbc8477380f6a8cf363bea86712beb2f72a22049894b12a10d67d9c9d22f1eea3beef3f202304928eeea060996584b1ba71d3099ba4a43a68b9f1c4ba84c3e02cf03765be81dc95deda2a3a105a1ba696bbd72276d17492358416052a8a5831ea607ab0c26d8bc41026d00e1a42e2c6fec9f4a8430a507dddf05caf64ce8bd51dab89ca1ff19f4a1c5e0bd800dade2c7027282d46940446e311c7428827a8e1fb6e2f701237ccb1ec7d0e481df270b70f94bbdcdb7a0ffb53a73045f9fca349677c9f7bf0f249a90058209a00b52a732303184711a125e17e10ff27339ea814c732e2d7e5eb8f8b7463a75611d7ccdc0a54fdc5144580803eaa06ac4648816404fedcdeb248a91b137dccf7e2b166e69e417c432342f4fede2f8b435ceb6ff796204b738a4857bae934fd13d8a53aa05cf1c2e7a5df3aaffa4b4c70b8bf26d0b217c03d36eb71da55ff3ef9e6766c87042b293f86502e959efd8e08b61ff657801954d187042d34080195e4ca2f040d89f9d66ccf9c6a25ef97cd38753f94c845f20ee9025e3379732ebad348c7c1a1af5b51d590f75297d4518f5a0cdfdc8aaf30bedda295cc729fb48fb9369d267d9db50e1ae464cf96aedbae811d42719c44c4504a59b8098bd0d3f216b7d4e619826720d6929ac1f16a7cdc7c0a545b959c7c79d4968d750331120528e121c0672754f904d5a32b55562e3e1fbe7617191c65872b6c805a7a85f44b83340d5da0402017fe599c29f7443746167e9a505d802c204e6daa10b4529b014e77d0dc3a7963f01426c980f9464a6e12d2c44f1a136084c1caa60cabf7da14be4f4b07b145ad8f761c6064040373d0e4a7a57ce4fef32afa05b1dc1ece365726575e3907297b85414f1fca9354730f9aa33efa1382409c38dc9a9db10986a966ffe5abf213fb3b7c8ab0e2a9434a754c42724e479e2924c835bfd1364e1db9b538173ebaf574611c7eae44e1c461a17e5af86c9704ecac2dd0244273564c1aad1888cc4061711113fe2572072cfe4adfa152bc46dd6834071f7802444ced75c4e976456fa935153a6b69797b9c2536e9a9472d2399bc1a9b416cc3adb839acbb447385d7306a704d476298ca806ef00cd15d47de70b97453d7304ac82da61ea7634102199fed393bfcf5fe9792172d77ece4a0d071d33f1d768e963862e5fbd2ac3a29977a4221616e52f8977bdcd8878e5e06d2aff25d179ca63d0b35a0af4eaa132599a015f4d60adc600597b27a1e4734f4ba02a5c7ea261ef68d51bf52156169ab2dad85b1ec121e7b4ef9bab484b4e88c4afdd8db45567d269f8dc3f18f54ded6f939367e07d373164e5593711a7ba34a53b0b24ab41def84d7a1910a2258a4a967550459c00256cd87d0c43525bfe8099d5493c6e664948b066f7a8877f2eb007266ca687a5266a0201482ad5d795ec4eff70ede6921511368828343b9df968cdc4c8848eeaa4680751ec39543b750028d3d1d26ba9e3f7426f46376226739131d5880b05323995951ee1600dad535a55000e798b9b32daa1627dd6ff10a3c21ccb62dfc1abf1e530ffada8a09d7f06704a8fafe52e9ead415eff1fb15096af387d6654f2dd83a904073570719e572ed9f392a5bb7c5a9b0e166def8183bd3ba9f92bf1af56e70007176c6341c8a5a2b6f5c0a32d98bd357ddf0ee50cf000509fe07aabc41b0694dc9f49613d71020155417ff5a3f435c69af4b73e30eb1fc4337e7e73af892f2a8f8892efa8eef6d6e2d4952318fa132ec4d8ecd6f80f34a887a5b44baf6632ffa1a228661ad3ed385a999173cad0e519a232eb1f61934cdba0599aaee536824e37943bed557cd6cf5bbeb350f980058c391d24d55c9eaabae91cf5d9fd765c6fc3c758b2490d860336fb2d2f5d178ece907ca055d8706f304a4768be2a80c98a4c9327fc8787f38cf0f764e754fe797c20a4684a269c5acc0a3b42883559c5df4169845ae53153a31ebe9d874fced3ce1fafbc2772a8122fcc5094ec4f3f8c5eafb3900992a51b123ce19171377b93167eb1df9822cb1b6fbf689ef25b153e72bec4e82a1ecde108f80f4b7495982e958b72ff6a01e0d9d640e5f739cb15ef60ed4730309c9e10be76d132793f872bdd898c1c491dd36b23348c9504bf0729848b66ec3823a8db7ef9d1a7a276d76d003fa7e370708357950978be1620ec8dbe62318638e59615160c0cdf10114528988b851c22b20b9763eba358dd13c34e56f139c588abf12e06c179f9d734c1c562f64d91d27f3615b2323b2f1bdde6c1e012ec7c8a8649cc8e1366414a56876291827de0f059842d4a02a7a207a666e80e21087b3bc6def953736a71783765b75827a301d687e34bbf3f28477efd00eb5470c3c2094141cd6afdeadea70190f487cab4bc42699f245d1bc933d0e700d5745da6d7a5926eb5a8f5710da491db847d4e1bba939a9d992a9862fb54c0373fc61bb57bf6009a660a19ba853917ca9ece879dbb7b109cb7387dd7a590617a61d3c2520143a70be9c563749bff07cdc10c5ab42d892f31962f97d9b5c6902da9eb9cba0e3b50975d8438d8ca38d4db09c79ea28865d6963c8fa379db25c46e08c27da0f6e2cf03805aab2e91e21469b7cc032d771a74cb373788d9fe08911c3fa1ba2bf5c66b955389a02dba2c63497cedafcd7961011558fe184bd7d589fc68c94a02fee72bd62bca7b5944b75416703a8da289c26fbc2854aa6829eb1272aad4ae97607d5381d2ac35be6089d8524cf24810d008ad99f8b487a3e5a41c43eeb21f070170de60ea78f02bdc37297143ab58c200d18b9b39457e1fc7e04d1830b7a32a29aa6351946c83f0eeb09eb21cc3eb58d4f6c2897c5521e18991f6d9597e338b031e46195c96b1d676c921a188322994e986bf37d0bdc79e0244887c0728dc752ceb880b9aa81558fc458304f2e135e7c01b18d696b9522401e5e669d8f2668b7f33cb1b32438fcc49d8914ba7fc6482326712a30902f0fab76eb57c9542de30be89fece3fc800e1da9e643b10b2ac1155fc3f3c7ba3ab28460c0cdff3ada9f37b33b6331c8d0f87ba671dbb211b49737c47101edfe928d71807ed8acb7cb6839057ccd6367cb2fa4381f9cef687f7963b294d813bc7e2b9d9eb8a0e9dd3d1a4e6474c38e132c9fb1719004a59d318c5ed7da06ff0a49e69927e569ceb6d660aa1a1a7f53ad42c79c3f387e08d6ded241fbc025c7b1cd5457a405fd88fd8046e0fdadf431d1f4cefdd8bfe2d451998d9a598e7e9608843bd4a24f7b0135e46023bd585fa27f17867cd0bc043208d9ece249b619a46a2097d68b8624e05ef921a13fafa3299e3f304ff2311f04ec883d6cbaec8ddd529527834d130fb3e7ae20102ee57597e712fa632e9a36f9088f587aaa19b6784651786152c889af67d60541af814253442e67e7701ff57c29ada6c9ebf6f669e017ac3043e016ebe2924d259a654bfdf994b34984b5af45fd7911aa0d1a76a60a6f75af125da800e6c8758a6382286c96d2a528b0545b31c80b528df884975f850c3064ff104fdd79e0ee365f74db4161f24b222467967e20b9db91f168430fc6abeae092d0fe1753f26c2bebaabee45cc1fc940e2d7c1b36edeca77ddcef74bca30eff63531ad764bfb3f23de54a7d7dd7e8757f702c4453020114d8a7de53e32b1dd0a3aa29481d82cbd3c95938729bee94067515c1f7f0c20d3ae59060f6b5f56fd91b9687394dcee5018386c4e2144117030ed976a14c2d10b585d3cf9db354eb8add7b0b908e9b1ab8e6843ab821d2d8d55d41a82846260075b862eb689dd39f109d5f72367e0c9c021daa5df6e05387d6f9489093d20a20d13deb4d90a29bc09ff57c9ad11bb4a1cf09b9873f81594f9d063aac5947665b15a1a5895efd3f64f21bb60da9ad7cde00004f2a95a1850671874db232fd1da6f3813af5f873e7055adaf96407cc1bab65599431d2a035fa736ab28a217b1f9ac6122ff7c03a96b9c2bdbdc6e306c3678b399dce4e70f4b11eed13342294b52c7715d923586aba203065b65a8175e46893044d7f79778084bb17263825dd9ba08bc076994c6d76b856f75bb764711234322bd8fd118e308a7b69df53ecea4f0f45c15dd712e8213063efb60da70083801a1f397e65a779abbcedc5307b796af7a7ed4621056b16deeb614482f326d3d224dbeb0d432140c4ef8ee146a03a5079c729c6f3881f038b841736f191a177a71c755446bf3b7af77d35db0241bcb727866aab962a30afcc7db539093037e34730d79f134f67fb4e90a9a739831f1605446977c51cf1fc52eef8b9d22de6c5a744f3015b778c1cf2e02dc7e326d8c0621f0225bab51246bdb137620d8752578fd98064195269245ce5aa04e22600c79eb46aca4c5125b30abf986543ebebd2e524de73684960093c2d0be254530d31bbe7f195c535e5c84a08ae262385849bdae6e601ca73362a951fa19c50bcabfedc9fa1314feadc4849a6ed750ccd7cb2d689bbc9f83bebd32665dbf83df416b31474d5f9d46c4adb910974ddb474df93cc2ac30d1520007cd86bc78c14bd9d9ace50df1d7915d1ae3cee0abac76aa5dda6b7d1c1d6fd00780668377716b806e07de33374c19466559deea6394da6c84a93d90c96072e7d4c9e3a9946ad117056fb64a710daef00d5213b60fe19c5b1edddb683b52717d67c82587f44b2c2ea08b3bddb71059ccca8b5705fe994a18eb753e78288104c0f90a3194c2aaa07bafb5cca06d936cc0b45e92be4d9e5d1b34925aedb1694704353093349d04c91ea3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
