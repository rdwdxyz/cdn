<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a5c992aa1af510efc9bae0fa0f7541d2ea6824d668aabe791f91d1a8cbdad5c54fc232b9518fa03a37b611261c712c474c08898421016e2e585b5bde5fe56985f24e057413c12b739665a58f35c7d2b437e4636de997e69d6afc4e9e27db104edc665fcc0790ef13e626d8b84d223ef0554201d34592dad08245e9da7258bd02ac9b421dd8a404af17aa01a3660af9ea49c40e2a6bcb8ff5e9153e9c528feb324ad7288b99e80e284ee70aff9b20c247bcca8e10ac5463e86b022bf0ea613b927bf376b055a9a7e1c84abcaac90bde53ed2aa7c87a4777811786709e5d53af4c92155ed77160b9abd3a036c16a0ffc1dff8ac6cfa1e99d16f9a593be6f3eafe9863d0acd303d32e4d5e03356a7f42fca842a365039fc4d65119e23c028d5932424a374d66d1db7e53f0190bd7f3f6784940ce3bad055e02ed6a9a057f089a7e33b68f04a19ff35241aff3fe7119867b753893188c283d363b250a49a944dea3e414012ea70c4a017a653feb796b8d6e77e6ba23ca6f21c4c21cd52a39fd15f60b97862a7510b2b87db4677df5dba1cfccce141e4f3e322fbd7b85a7a841dd7181098fa1362f65cb8eb9f387007940741ad0eacd92ba5a3bf887a9273026979286afb32cd49c490a26bd181e09b55c86431abace7dd8bfe52f8f319976c2ad89c558c8769bee00e9240fe8d8156afa61320396c85dccdf231c16ed3aa1c0efd053241cbd30ac847264daa4b30cfaeb2b8d19a0ddc7b503409af6fe2b843b91d59e380ad242addcbe53a9e2d6ec60742549a28a3197b742a1517e278f24634f3693ade76ced959b001c0da4bcfddb521e55c0f7faeca06d2cdcdd3de00e7c36ae9eeb6e97f24cee4dcec4bb02c62f5db47a6d10e446156a5513a9ddef8d845ef0e12f4370d7dc11ebec8270d08e42ad7a529f3b6d1756005fd92efac9ad8d72364b6a84b2dbba7cdb12992b472185bb0e7e461206271a5e14a6b4b777d41e77fb89150ee018a18a79e46105db7e427743b7bc697dab9422815ccad1ca2c8e1466330bbd5aaf47a84f73dc711743dceaee5ade7374228e383c2eb99d53b9a1c39aca06b09dab2ce50bdf84388fd6d64acff3f68a8de54186d8310aecf7c0ddb3f97501d27504356400fa5046a89228b371234f53fbf245075409fd03b72e3de777f6b8385def9c1a9fee0744c536f1debc95d666b9affaef23a0486807a11a55f76335a0891577475757697f867c3064ad1dfd253d4b2a108c40b671702538fcbb34ac231a7a018a9c54acac180eadebb175b2d97e45ecf07897f552e9dcc0f6f4eae4e9cf8e3c8142fb009193371d95dbcdbe8c75b902eac1ce63571eadd3a22c639c18519a2a390b8cc2aa4589cbeccc9c7edda69bd3b848891319f65238570d44d1ad4478d492a0d1ccfac995dbf2a865fc80b084455f6c529c45066793ab89d4cb0d1dd5d9ea86733ac13e15539665b155480e11f8e7009828fcfb744c283676fa39f963b16088789affafa493e1606809133a26f037e42621890ea411153b2cccd5c82e16c75d1e1ccf800824d8611896e5bd02321fc15654e96561882c750d6f04f6b14e0be7160f774c758177cdf1bb787ef2cd9bb85f24437f62b09b293efbbad82db3d9aa76f296204f25300f85cf332fdedf26fc406fd1f8c8966a2e49a3978a538147e8c6b2d1881d64123ad41bf1330b85d958e53c5bbd02f55dbc764b1690a67a043efce08626a76f12cd5aaac59f2000a15f45b902c8c41b74d31c09b1b16329e734f2f73aae62a585440b835545d75a4c2c956db161c77beea81c7c92f174d72f268e746f8efe0e3cad58a3b8f369c7640283771f6b1246993dec8e6106ab38bc18cc8b7bc5aee366388e79fa32abc351fdaef30fb0aa55ef92b86c07e548a6d951717113701e4972a8128430dd3af3bbcb17bdc7d2371e8776f305b0e4dbf14bfe2bbd4da9f5e1d1cbd1b5c096e2aa42bc13e2471636fa00f4e1e3c8e508a5705ea9205cca6a79708328567d7da0c791d2b8a09866f26b88314b8eba6b8169e124d3227089a438f559f2b34ef343e9d76a9160a307a3d998504822abf51af01b070f16ba3feeced95ebee308715d058ef689c473e1eaa50c5878fc26136582f3950b72f995607caf27d9351725bd7d5ce4992aa1e4ab9b2815a6ca5d9ba412b37f7fd36493759c6a8eb91aa032458c9025c7d387f03ed003cdc933679a1a67954cc79ca13efc4f0da1287b69187b3f1253b64879293021ee68ab2e9e9901b09e87483ccea01b1340bc776f8b7a373ffd64305da8600aa2d3170a0a9ea3a891f3a54fc1c52bbb0d50f97dc71e065b10c3756ac9c8a17fc6953644cb8b2d4314ef4327d211ec59b76f2c34a5553cb68247fb96c5925ce0d9cc9da736ac818323f9194ad36cac31687580c4c09fe08f2807db0812e4059043acbb7c96af7a3dfff60fcaf997da4b9179a91dd9511839b67718e3d4a856fb963500f430c8ca495df956d0d78b5e496ad51c4d0909a2b1f0ac0e3a745823ca149678b2c95a8581b903a266fc8bedcb3eeb9693669bcf49b85a4b8d374bfbe5416531ac9658437f68ef3344b65d99e4b30691bbd25bdc693dd6b646d5424263b741448179399589fbf8ad75ae139395069e3e8ef0fe8008983d796e0795de419a0215460066febf77a24688f853e5b24fc7215a40ba58730f3f41b5ba6fbc902d9b2fc59c3e7b76cbb64a0dfb9cf6951b486c9286f3217b1e3659bef3d4938a755fb1e892ee91ccbf0864c9327e7010d8689f62c99f3274b1b07fda01b9650a52bf6436f6363e2e752d63e95c606214125fa7023df75fe3e822a105a903adfde1b701af18aa40eee4561d87aab3635d6df1672ff2e8dcd9d8b29b98acbbf14b24da2df04a8af01a3d64593d540acf9a23fadb06f188ac3ee3d1aa05765b2ea340578c6cc1b80ffc3e76f4858392ef12d8c32551bed70ff148b1adfc15f9cd8694113e3a7ee713ef49d943d151acda4538a8936af1349d2e738c0e34b19211229c5069946e13aea48c842642e55402ca6de422394d3c18fbb52f594fbbdc8cbf9bc10cbe2679124a3c0e74ab641f7d7f23b91342efe91c448c70a833c0b3b48d08993701201eb1e25af76e879e0610ff8764a71e4c043eaea0fcef1be3692847e4cd9281c35e4b74b708e64bea00160c9580c5ec072485a1f42d223ffe3a48e97e8a992c926f68a44295a1e9f76c9d40c40695b509b000d27a1697d7fe7c0a17eac8240bf5f7192483cc99d53d502eea4657ed27c5d76c207bda6ec26ae80806b871f22697e9a2934d891a66743f9593c97f7cc60a8bd10030b56cc056f75dd867698236b380077d7ec1e5086b42dfaf98da9bd137e77fcafa4a7089d1f35c86692b374b94c92200d60d4fe6b7960257a1b5615a00df448daffe5879a357c91c4039480fecbf3cb333eac7549152078965254db282b2f9a5004b9e28046e7186bc534b9a79d22e1910205db9d4e7d96d33b628882cd3ee13ac7df33f591c4d726a8917f68e7820af716408ea195b93df4f064d1e0bcf3b2c4cb6717a1c156a34afce561bcb04cbae3216b624695579823ee74f793f0c218696348c7922102b1849f000084972ca941e82f14638882aa39771ec5bd1e80b4ee03e37fb2be752fa3fad7b802d2747fb8cb3d8cc5430f4abf57c62ee55c44ec3f20c8090aeedebf1f03132d03de7a5cc0c2920a83ef5739e33f1ad147a8d2993b1710f91e304bbf17f956599237289888b1e67436a88a8aa180042f8aa111f41ba094cee723ec64a844fe8a3ebe3f42665b56c9650e3b040713fe935e8b2a0ff235290ac789b44348a55a0eacb1e6a0a7eb004c1723b2095eb8b14ccf27f188dc37b8d1df5450c9199e54f6b198eb0e5fcaa736226c0b79cf2f6e8368c031b423bb5fce665f3da1fafd4eaa4c7ed2160e85719767e593d111db24ac2cbd6015479b766831d655bd44deb584249ff1198f99ce61350679d46c40b92627d8599077c722775da54c051d97726add534191aee7aba2367068da16d90714a0bed3572987470f2078176f4dc53d1a1c81a3409b91c6c8bdbdd25d12dccfdc860a46435a26f0be0c8422dea3c24dea96a2268f40c57ff0e217ceb154682fd4cb072236fd4744f1651dae6863caa65afb402b5b02bc49f740474271770d0a466cf9bc524365401f4ebb542c97b463d5d6b3c63069360091a4ba20a1ef791129549f9692833f3c51b9a46cc4cd316f43d03e8bdeb8ceac25823a475b4c16253242985beb965d78eac0c285c30917a1cdd466973390dfe21c2ce200fd8c5b618d2347609db972f50fb001fad89bc3587fc62d3a1a32d45e592e9323e109a7652dad6261733ad189c1052db96a91daa0f28e147309c3f4c483d3f015cbbb18f2bb8f414c9006ea8913a24957fcb0ac6ba6faac6ed913225a63a0183f6a30c082335fbb3a73e66c9daed4bac58568f6430b3f4afaba28c3bc7af5fb9190193b55d93201d39903eeb34209fa753ae149c1f119b6d88abfc93494ad3bae1675908dec3b5014f798c3d907a87a61c709d06f54e7d5aa4715d953a824644697e507b4c721ad6fe704f6b7403bfdab9027b9a17d4ba08e662efb62fb315e98af4f790ff60f6a1cb79530a9b4bac182ee63e2138da395014fc2dfc9993b31801e895262436fb87f08adc7f4aff41dd7a7e79c8c46e8294db9d411bde56568fbda24a5e00237a70954b56cedd638d50a919acd7b29089b9336cd7452503dd81d6814bd6160bf9a23dd8dd2543913a64293785c35ae79adeabd13873dc4c329e61a5adc2558be5af289801466a383ceb9d39b16349e951d009c581fedc70ea057a34cc5e5dcb341ce0e230e8262b32d86e3b6884e14bf6539873c0ac3f34349a9ee67ea7120d7ca8d4d7c029158133454f8f88997cdcad9bbebc769b35d46bc48ed7bbade94c54e2b9167fc91b2101c4670586892ba1f0ad1bb05a43bb0c018d5f5890e70f5f95fc2e5f0694bfb683619516881a6e4df053043fd38df83be91bcbe44d6a1e5ad9cce8befc68d181c288d1c6218b70bdb776c2f20b28883eb6f678cc0456237d0b78b7265b4307586fc7f57a5333d0fe69d9d71989ffe883e39aada474960374c57dacf5f34e3917e0376998336b3e4c4813d8d1c69b2c6a625fa744aa9ee3330809969202a76f14b5da7e52fdee270f08582822e4187eafb678c9e9714760e38b0a55f5a66a2480081513c2c06fae28318b9772dd27e7499ded9b179fbe3dc0735ab189f75962383c114183dea274c544f51be190d5038111da1c6c8c5a20b71439b454866cbd5477a6eecf18e4a30a1a864e1c9de53247ba4038586e49a2e5653b0ffe04f2b7129aa0e1ba2703cb597561f9d58a22aee7d3b0296b19459a04445799c60265a45e085bf56ad769a99a564ec973c73d7ef63b044a813b4957a3d6148f84307592753dc310227e9e69e992f77ce01a33541fedde80463baef8c59c6b9b1cb932b38fa2dd370e5687f4fe60f498c2ba97f6d55c579919e1ac8bb9875e02945f1c7ff857f54ef7e48a5a7681bc844c2b77c4ab858845650aa7c5b7727e92d486735daa720323c8b2e06f7a68f0e1efe5c4920642fd42884b186c4a927e56a992be23ba2a6b35de802f9cb85646d66d914538be530ce97b6403fd601e0fe56254f894e6b6ae6fb10358e43d1b3b6d277d55277e8a7ee5a121f5664a0d766cca5b99a2b7793e7496a7660e91d4fcb2984f42d3961398306f6ef3365129a4ef72069dce2f7d702fa86125af9ebfa984e9608d6cf0a069a4b38b7b61f6f4a74eb0f82984bd967fae6882a732c6dd6f090551701f984abce7f09873be1a4e10b3a19719598f228915411ef197663298c292d9617a3e125cfb3e0b01d19d5e2d999591cfb721948a96c6ca2900cdd472be6fa8ea190f35c9d4795cff5aec11e07dfb2ae46e9ec0293226a8ed18426619abd7961c3a2164cab4eed32ae8a37726a9779e2ca31b376d1854093c5f319727dc000e05b3cbe7f912a8a7ace037d6748ea90c8ed2a4ff49eb982642cf21c86c31a27747336d48aa16e91e85154558176e9189a4a037d6256ab368fcb22f64da310b056bf8f9b94720816ded5973465418eca07f5a62f55c4258e62f0b045aa2de4fc1fb110222e3cb5862e505f180cf1b752563f6b56468c73583a4916875a41e9a9c5ec75cb0e892ee023c937161405d9b09963685df92e0a414e03db6f537e1c60bcf01d42c8a4051991f0ed71239f3c61c832d1a4285566be699be3a576a9d9a7d4ea2893f4a239e85247256cc9371e5bdcc16f7b7449ec3ee6cd2e91368fbceef9ef3ef29fc682d0d227aea5fbc01dd5c91a63f4e49a79be2d922ac6daf9986fe2ed1c0c7cc7f228fa2e7e819752d51cbba41d28951c866e3f4f85fa900fde55acd74336e28aa265dee55099ff76c4d8836dd2360b5de08a70a0dc5cba8e04afd9bbe1dd66ad715cae2532803976309dd24ef43ed680cc1afe03d76ecd4d15e9b7185f62650cd7fe76c3c94d68a34b2e9dfab948f592a82cd93c17dbd3c0811920220b00f030d59b49c6e1a785f32b389538b1d32cbdc0c96c44163a540ad599d72a53447cf354a97371465945fa75a67f072d2600aa5f42b7d0e306c22997507080c959a36482813fdf73cee5641dc3983a0e9e67d8fb24b2830120ac2462e07e0455bb97267b865049b619e6b77e8040e9de28cb1a1cbd1a4cb343626dc8e2445d7fd52b1d3357dc17941612718a837cb54cd42198d14316fc2f3b20b93951f03bb5d1c8da15f63553b9219d290ed157530ecf1be2cb8c87870cdbbc0cffaefc0c34b7cae16ae277b0a8bcde21b92c8c6aa2402a07693ee304dc647a98b9ca2f90bed16382bb85b76700aa657f59fbc1bfe8ed4c47189816d28c6f3f1bf424372c1e917c7a291bf37127453644dbe672e9afdd60485691ce1e010aeca486ea60d8ac3a948439abf20625fffc579d7d4267ac126d289442e91da7c7f01f724edda817eecc3515392cc04c6fdb52ddb71632214875b2d19af7a2a4e71d12a401cca1f5fb8538dbd74e7424aa6a8ab3f8276bfe637f93baf50bceb2a634e81bf3f4afbf8e0c7e593d7c7009e836a5e755a6e669342f1742fa415936454c0fa0eb91d39fa4ef43fecc3cea726f35a3df319f6d4e610acb1b6ae7f9270bf55d120f075c31f6c5a6394e9b96d91be1eae62d6789696e2cacf7cbf0a78c72d2278f5d12e6d4c776bd1d66236868a02f08ca37699d6a69a6cc215454da92e9bbc2acae567102532b4ae1c189843abc26840f33d8c47688fc0000745c91dae851506f05595ebdef2193a8fc39ff9db801b15adaf17588719ebb8bad0cd794bd42a3cee377627f2fecfafbf0dc1337e7a997d037ced6db2d0be4744cf58e4464ee62d36c809caf145fa0274818ff387febeed2eeeaef1b8a07571b4dca8ca28bf83b4c803de7560f10b6e51d0c53a9a2d42c5338f85efa0ec1c1e158cda60a1aa2e90eb55352f6db678ff41add4da2356cf51242d55cdd63d6357062efa1ea2550d2844282187aef161fcd741d1a9a3e39108b4f262f9c7e665a79fc685f46f2f9b86f9fd8f70ae63ceb17afb540146409b9b13cd7945d6ef550bf5f770a07ae6ad95c710f1fd6fe5dfbf15f256bc0ca710469cc274565caa9a9ee17da6ec991610f0fc50c2413a1515736fd76178d270d3c470d55ff45e4f06176592d48675f460def9fbb096354ae396124b734b4f50fbf2d7e821495ea16c3d9eb3941db589329c2ad02dc27720adb56fc844834c78f12d9f542856364127a584a681e7620305154d8a7bc84f89185b39c52f914eb4220e9a6d2e0a7e2b9aa70897b5502c97162eba59e5c36b2756f432f68b6589084d30dc2ba0b8fc6b42febc6ad905a7f0c6d199671d09cc027cf8f8be2d4fe9dcd1a99d5fa7933e14349dd84f6f54cb78dfc0931f83815ea14bb34d3c4451dd5dd93085699cac38d0505daec969d5e526fbb7f7e2880c9333b43bc1aa93fbe6f742d2795ebfab005456a6be181aeb23eaf6f4ac71b9e35b9b9314a91b88206e6515fc27a3cf4e428461b15b6315c125c06154cda822386dc80df63ee2706c9970bfe13781d215387e32d58edeb8ffa76a4b2e9781fe2b0b734694d1462ac2352feb2dd4deb6108337a32291e8d488f9f3efeb01bf6d3ac2669a17f052d617b27d7650d4221e726d025ff1dbe2e8c28469aff8e61571d8cb4a1510d7057f4d6826c30a8b52f467f8532226f6cd4165abf97111ec940737a4dcbc8c6fe704243e0458a8f7895384f94dc56e5535c11646a658aebbe70605a7191701bbd72ef08ae2208c95732b8573a1b33ea76c67f23b18a7f09ba60ff73680cb3a580353b887172b3970e2339d227ef0c0c40bc08a52fddee6fdf488c945eaac806a4d4a18781d28ce28b00adb9e71ed65c44a979fdd1613b4796a025b61869837f195db8ec4f47a3102362b56e48482c57f6c239568ffeff472e90c1417ada02d8bfa803c9de8a1f70ee4d2d29f0164f3de77c45191f57203531d35e08ca083893f386d0ccd0e2923271ed1f95bbf3353568ab063d7363a61f8f36a8a62925c3fdc327577b8541f7d1f2abfb27403d172df0ac05e5dc31da463869030d58d26b553fb2c9a8426aed8523ea19827ebc1f47a305faec7320a1421bc33081a571190d9ae5af939b97a56e7043a0949658beacef94d57dc8e99ab68bdb4d41b55f5cba6900abc625f77073dd01bf9f90b4a61b1aef89eb21bc124c9dd98cc41088a824a928a5afad77f03dd968d23980b13a042d9c1ac63c8cb46ac022fe64609456300c57e857378e7c8075cf59d30cd48aded82dfc773af66d52a7671571ad2598334767680213b6aeac912a9f068f463c02eee88e3ec816dd71041ec9fe6d15e67587417df771621c6ecf18cbc048d31f9789c521db48178498e33f4306723530fc43d4a263843e064520f6b0aa8d8c43faf6e2a9306c8d271239fc6f569ebdf76a979ee491ca0d2f7b647473dfcd5d55ed9e5f9cf2fe9159523575159e7aed55c65ba3a814d17a3dc9de3a0556a8993a09cb1f730d299ae8a16932963662e46c723ba94c976c1bf1fda37302d6b128be2a38a762efbe8492bc7b9afafe1fb685d1866c4ebfd96663caeaf8c250e6d1609ebd8fd5e4335b2007ae1ed9cedaf146ec3c650b9c65bc1e05e15990c5a9b36a3694a07aa3881c472992f827af96ed2f4d31568061f7a5a4d631d6e998de71e7be7c7cc0b4b8a707a97b7ea4f752ec77a954a905838509e503182e610dbe5e6c24997ce7e840e17df7f290a45cf58c533b78331ae8b43de8c6e7dde1fa58456956275ff4894ae8dc79296c310a63b11a344bb01ec6c25bc51382c820fd9924da4e1fcb49a590cd258d504a57ced13f23d687309b02003fccffc5c0337309c558c741ef7bd6dd6da6fed8581d13f6e4c1bd2e6d05db561e274770483539642b5f33d0f4ca9c2a7d392d9ee91c94bdf0634f8b283db0737a959a140561ac0772513e23b706202c17e53fc1f1f717655a17de0b757a692de84d18362a3ba5c530c3666cf097c0a0e85f06d540c8049def707aa20f0fba41702f78039640c965b1a19aaef8e457ff9000167a16f4a53850b4647bf6dd515b021e2bed66308eb79757685ff4f707001e53cf70d32d6a363598f97ca19ddce53d9e52d13bbd3a239ee8fa466c697bce197d04084fce8dfc1ccceae7573f23acb22dacea4dbf276e1a30bfa03f86ef34fca5b0b362b0152f36122e9a301235192031e6318a265569a2a0cd465d91606ed49a1e95a6ab215281e902ba04074e6a8798f6f0638528341857f43b0917463d3bcb24a5a5ab69c5bd9f9984b7e045b1894bcdd3c2d08753f6933905cd60fd382f73d0840edd3cae8d725f740bdad25c044b0e19996ba0c876d9abcfb6bb4dc195e1f3fbdb100cabab1bea72eef0c079ef0442eab185ad8db9ce5f9644ee028460d4bbc373c78d30b3a5bd047fe84f5fe5f8100cb61a44da23ac9edcc2a406b9034393513f67f72c14b3eb27a5bb6a6a6a9b0a78a11dff6f7da397054ddbb48375da08f6ec5f6c5512816b791758aa7338b561757162b8578c6d560500f26b3da25cb7d58c017f63707c96ab37652463bddaa9dfa0bfa86af618eb134b29735dd60213a99a918943748240d9dd8922bd4eb7599a61ba3a6fb766bdf101e6d51e1c253ee7b8f91a0a58916b2de8ff31cc96f8118aa77a161f4f02c110565cda5e03e41de668f4a6eb3550c8f5b12b1dd8970d8fabfacf708846085636c4ac16f66510e1344ccdb6c6aeedb6f630665b29c4b3247c59052bfc46b44ea7ecf84d1f41d022aab4ec89b9422d4caf4b9ea2880a67ac61866648fce3ad120ef9d8f4b4cd446564d7880cc9ad519da14176d2f04d5d1133653b46116e8f245e6ff7a7561fd73448f733e0f809c3ec21815e9d0dece27bf3570cb7c6d232d0eb1598804adb754c5b7f2b485e7cd9c76be4ad7408da58335ef8076c56a5b93c5b422aad21249ec61b4803d7d132841383944fb73249584c5d48e5a8fb586b5b5c183ac307cbca4c24dbac049eb66393e908059dca8aec85533233e3b55ad11e34718416bbf94add3855b5a4d6a28b05ffeb0f42ed454662ad440b0dd55f9b0e2262a729d89a60509cd93b3ec673e68d4a043f656a6272cedc6a4c688b6bdb99a13bda0423e99ce8df1b737c1eb4f2b97dc9697dcecac6a0f30a82fd9a8827e52daa5a87652171b92a4f183a5cf477414fbf886245fba93eb39ad8b07b13adb9845c1a8e8c3a4e7059635de63f59f3f62b6bb372dc4634f727e034cd927851aca150ed2e6d5d1d5bbd7643da44bb4a6b426a6661bcd4678e6165b1acbb946c623caebea41978e5384609da29d09304057e5d8602e35da3740242677b5beeaa86823317361261c271d218d0c1e849ed4026ac26e0eac54b0bb9beeb54ad47a1936aa4c784978929ace576a8961881ab06d69a2a4f2548e7ef0fc1e2c9de956d7a3d5c2865924ce06724fb67cc9d1d43a528e6e7e3ca897490cd2bcd16a3941e72fd925bb66a0959c46d0ca0893be6c2e44b99455a1fa199ca8963feb13bd91048003f6211708b57b8ce31717f117c04249b74cd1827584b5e525e400508a1d1d6c512a01243bd70fa9212ac66f7a4e35a0d3ad95d3d0154002df74ccce206c089789f7e2a9989b2de1219378effe5878a386e5ef0cc966d9c59d472335794435521e89946b0e3d09d3ea291f58c726ddb32c1eb07eb7d3db075dadae333b78180b098f951e640e52469ba751882c17880d1f13ebe1f42cf95b8d73b07e5ddbd20c5a407c302fa04a5db85251d5f62d2e3fcd2f006f47613692fba0afb5ec36bcff36434882ad7efaea0ca00ed58360f8ba00fad2015aa3f3df5b85a9bc1e027bcc4a7ebeba60e44bf5f620d06fc4628cf69913dd652c4ac65c6cea768f7187519598cbe5460a4636bf13e35884ecd96ab177ed12d7bc53973b514fd20ad3aab5b4418566c6c87307e8acc0982ceb73c7fb472be8a6afe2f2b47fbfc8c455a875b22e1e0a9a8127e2cd3f1615b2ab26badfcd8311b3a2df832a9e015c453fd4328933b48cc13caa7fb148e1d60963a66bdc714aa3a7850c439ef3c388f12ca2b3c69005d6421bf30831b823d9572c54ab93cfb318da523e96c53b91102de98498d1fd7602ede86b37d559fe5aaec7651eaaa0611a1c80ce92f3ca5e8b1be6e9d8bb6975c43e7ba8c3e3bb41f7c9df3b87baf996b3485fed500d0bacfcd0173d9ae3a6c7a1ef571ef2ea7cf98e82539d98b6da5e0f80594994720d9d5754590d0cf7c54d8affcdb71ff4560992b971df28f68998bdb11f7c5111c9de058d38b816aa9e599d43fe13812e78000cc143bb689b93ee4b875986ba54a5681bca33e83dee997a3ba80a8a63deb986aedffb3760e28e8310aca3da54f53cd8eb1eeb4e48d5e7fe6f4160d4c3ded7eace6b843a825573ba2b7bc4eac7bef3bee9f11feebd8f43ce166eb53dd420d4c9494065f728db13799a01c79815d18dd9c4c9ccfdea4ddb64003d1424761869e9b562389c96d0ce2bc509e85a27338636fdd49b84e712647aced2023498d6ef71e12487c4f970068453b25f3af7e9f4e82300833de43d0599b166c1d947de997c31916bd1760c93f2c946ddfb944c259e6e18961f686837b57abf7a4e55be653df321bd931d25b2eddb603b8c7e69eafa555b44b28cfbdb2348aa1aa1fa89839479c8329b771939e0a1bf29642c3aeb797518d8ea9a83f7ccb2284e752fc8b11094a8a944b3689a9fe1c0b97b5f73563dd399de51affeeb050ae1e593be37ed90da0ff9f332f3f82f8ef2ed5f53168aef9de0827b93b66c0a9c445a2e7e737b8b56149249a8a946cf35419951af93e7f90f6a0b59c573cd7d881185c29370724cce43891863a341d0c743123f27fbbf770d67e2a71179744c7c15c830b31bef52897cb31622fb02cf14c5a01f5eab56df518fb1d66bba5af8af34364c78b0af45e96c00cdbe391c042cd147ba938c3ee4b03002cfd7cee8c57f1e3fb7038f0aa68cf6da30fd5538d26b8a924a11a0530fca0e4608c0bd197dc777be33a6c1c16fa83a12f8363ed472701fdf8e4cef4905afe89e838e57b0d0df52e7839557f078793d46c64721aed1bcdede5ed1062fec27ec3e2c634e98a16d58951aa10b2463afa2d173ecb19bea70391d322348fed184c2e20ad3e802eb114201bc710aebd091a104bb22e2072b933af9501bdc4b57e3ee05a3f8b40dae002a9d83f234ca7556390158050a0b559bf71587f1361ac8fef0726936132870f0765ee621cccfb63d938698a5098da5a2ece46e341c6738cbac28d65f192381e876a831222eacd59386d2c7e4d61fcb5f3bfa92071f319319b205af46e9fc17ef1a613eeb07be26929ce8d73978c8384fa1151a2ed4d7dd619cf96a38ba92f61790f01a0950e77532f6714430c60cc89e010d3426aec5bfd7ebc293af330b699c1fe43e7210b5f78a2c8ec6752e58d56ea27b61db9ed7bcad2c1d7c04513e3e9c49ede4533be8d0e1f73f4257d5a38c563707b44b8a5489d7e34cb7a9193c26d6a1237c4a3aae289bae9265e9a110f4c28eb7d21da4f3a6ef67b63ca427a9bf2a815c23c4d051974c456c97afc5c9bada6b2a76b14a84a26afd97e16bc0d2d192d8b7d89f29e69e32888b2de98f920277448f9708d219bad82704f53830ac606098c154335770cd3d264afc1c5b4fc86f2e879446d448bdb2a8315bb440f953b456c448cfb26dcbd066a1c5dc28bc506f5d64a9c6d2e607f93e1b5a638d6a91f07698b1af427cdca2e6bfae992398ba5bb95e5011c7c9cfceaf30567a00adf242f345e3a94670eb8f74148cd32a7473b42d7611da7b92c037cf8a1511560b6bcd8b6e0469a0f304d2eb1646b9534464823ed93b6509df11a2bbadd67f42f0f408abf6be85d1072a09eb2f910a3c04e92b2e0d468813d878eea6e189d473c06a54c232814ea70da66d72a7d6f2277ba55a02537f1f0c630c45ab5abe7c8400e54c74bdf872252b058fb7bf45db2524d05445a2fc0aa00a0509164bfc957c82eb15930e4d7d8d18db79197f412beb86478f873f42cff20e1f2740d1d52485fe9877841506b89de87ea370cbc06d4538b25c07a8176a7d96365f11f86c360e89026e606f81d53ff29e9f16f3033401747d6bbab0bef978912066228a8640ab950931c2e0d9c3ccbb76f3793d7a8a2a2f26b1caea1363f912533ae3158a3ebc82db17f18dcbe25055649b115d790b51ea53c19c8b85d0c9098c6fc0b1294e5ed252131fed8245acf095ead5eef569df31602432b5ca62f97faee86c758a40013e33b5b8925ba904cd370d6bb8277c4ef639cc837a8e99e09fe86cc3677fe837d0fe4b2e535153eab3152cfeeba7f856b9b7f203bcf6d1d9d6be3dac378794c6853004be37dc1fa9ef8616148c5f14b90f745009282cc3d1f0b2018045a7cf25480fce95f5d4e44c0d257936ba162a7f4b321711bd98ee8982ac7c67e2bcf8702b161f698452ff522c769ba9ff91c81dc852014bef73822738a6de0a1d9683859e9793c575fc6942ba3458e2d7a4bb7df81e187af04942f97c0b9bca3ac711a87da3e15fa781423ce6f50c02194bfc8dcc7a4f56e4e72bd92be6471415bca8863be1abcc0e14592f94a20c8b3bdcc2691651cd2dce939e38555d38f6b9f944c3173e09b2569e44bdfc287cc92417b233a4fd4195bacc0be3cfa48c054d848f900c79db60c88fa8b904649835a148b88bf4d1a0cf08633cc647f3e4cec0c62b539e96250359b773035a2b627372803e771b8f4c69c08d156a9519aceb262eab42df1a43b138af5088f6c8202a8fe2f90ee626400992552cecf79e323095838d80454fef2e8230c3f9fb367767fcae7db94b974b3c9f11eef17c148ea54573235c7b88618800015074d85b1948aae390eed2be6b989430ab516c77d87a161d0167299b96831a557edaf5832c4094fade8de508f57120d9c0564deba6196f9ceefd68ead09721a9b3b1b934e62b803f75d5b0966ae1fe4cc417ccbf55b90850ace61369844802aedfe4976dec8b4b7ad702eacfaca303a27c5b5946c4b5ca407a6233721216bdde4f0ce0f5c753c60a483fbdb2386756901b541e8ef569491bdf1d917c94f2eb289c6ea9d573cce0d3d0985a53e93371275970350c6c21d532a78ccfa63f0abce86ec5e2f2777b90ae90da1e9b705a58970bf2774504f0ad3022ba7e09affb9f4df7ba438fea5040c97460b575dfc666a0a59a492d415cbec5008cd1e5bc671f56c168a4c42c30a59ab0aff4104cb0fb634a8ebcd04aa134ab75860889971b96ece506e2384ef0ae30baa679d81939dffea9cef70900820c6088e733ff54f83f8e54bcef6528ac0ed0f1011275f5e462fd2ef06dfd6c884af3adde5fe2e63492233fffadf7fe7c1fe456eae1f1fb6309a056690bfdd008b77022cb662051fcefff33500f5335106bfd4003a7725854e169303ba48b7116b7c42469bc434534fc2484277270af9f913b3bdc60144c9a204b3ea3d563d598a64d46fca369197a733edbade592e343fc453835a7c79c76c295297693cf775fa26db1173b0da8365cedc07474b8c3a455865818783bb6b47ada446a6e74cdf9a2579696068a2ab93a16c521ac934fdfec7a307c9e2449adecba3abfaed41209f2915422664942b92086b8f12819005c866dd344e003bdd68f408462f9a8168e6537b755e99c37ca693d316f58bf4883dde518d18a6fb6089f52afc57ff1c2df15819ebb5a2c808de9530ee82763abf849106c801e3c9c3182357fdd35f4013f97af31429338cd8bae60794712bcbeb18e62e1f10c76ab700d8cb1182404c4e024733bcab4242ea8ee9af187018ba5f1485bc3dbe5723720d2960e2b9de10de6efa3a5a3e7795d51060ff7c12f1e9533a24be5c75263bce829117dde3e9d80adde6261c8aa263444bdfb459b706c13e4b59f2f606c6ea061911f6ad9066007513430165acbd1d003af93ba553b8e8c785a20b2af66984be3deb68c575ad15c7853583fd49bbb2147c8aa1050d4530a7d8bf62f195fdd9cdea6e8c17f5cccabf19440e362a11d3a540629bbdf460862d2c13e714dbf51d5ce7ea2e1b94e6c39c6d2b2145c3854c88be48ccec9b29b141161d3df6643f166757269bdae9e69359e932d51d0f4f90d3e8e5b121ce90c8c9c99b01efb9a20b07fe3b618ff603b36ace91f1d044ffea0d93fa0c39ebb9624ccb689add739f4b1aed371ba45edb96ecba771a0906c64f498cabc54836567463ae09871b046a8fd2b3844a3f9c8b06ba2aea51a2f5140bf28cb09e99e8ed5ecbc267334f40dedba2087886f1225fc22405e3d0401a099d821d62bb62552f33e53d9cd5b8e840e1bf5048ec6bb4859b2b693ad59adf44953aec250ebda82f5643ac46750c66d8bd55ee8a8b8927b607604ea51408a6f0d653b282a39e123798dda3902e4561b37dbb9cbac8c7204ef43e1955a115e7f4752b67af54ded65f75ac9a5e264db332fadaf87172131658f249387a7831ca5782af34d92b10ad4eac4d7433400eb337431debfbbdc664a7a279cc99df7cdc2165c24acc23826cd58c7a69f9409394d0aa3256db693db1c19c61f31f23c599a93939a500d5886ff7e344acc13be781e07ea77cb2c1b1a8f9a4271de0b510fffaa569af055aae3a164f30c94454bed0018d7bf2ce3fae17bd377a9f4efd71cd68254ad81006f6969e709eda8f2d81f5adc6d12f378524f036e679f7d86e13be0c7a001b47def7bbc78aab15cbf410d56ff14537965c2ce814aa94a3e7b826c5f1dc3b966008531b15e6eda8eeeef4acd7e77b01ff57d4828cc576a8183ed2f7d1d1acd070a7b961b1122a9aa947d735bbf8dafb7278cc802ccac09e96a534d2b69ace1df456a25996123012376c3019ef88239b00e0b5c7385115388b49425d40600397c6e328534433456d2662125c0cfe9d2d874281a2b04af31c228ce4ee036c7e32d44a47df838d2b0e45254b1b2d3c282df236870a791ff71d4211c5fd69e76cdc62efc9b465430dd2a49cb00960ae24b217d5cfa29eed15f0789c2941ae661583c98d4ca48ae199f4f6231efe72ee094d3fbe50af8c7fb15465d9f53e9b5bfcb1ca8b8b2c6a1350b52b9be24e78804085b9117cf968642de61949c58c136ab166696f8472e5542e8b35d700c95d1139229d97ebb5788bb2fb1fd5379254e23f2d60aaf137ecfddfc9f1d2cf9e1cd4d8080bc4435eb4ea8653dbf49be1345928bf147cdf501bff8edf1fce2a181e950d25f983a6cf21caabdcff750fce3224f85e5a0fb6343cb668c15721efc2721d85c04fd0541e418714624eb25a1f5efe5641d4db7fffde69037fd2c7f1716898d307073cc9fe6d9d937d7e7e33c41fbfe0468ec7a9b5561658618fcd4e51bca588adc35f0ca19abff47b881f92a4fb88919c383250ed6aacf13dbc9359f70ea90f68b2b199a827af966fa66f88b8ffa431db2839d9679f834a4db69165b54768a47cc52f0016b22121720007736f017447c5974ed8aedf479fa06bb3469afbcaff931e961d86ff4c46c42a5726f9268283cabddc2c3b0f8db6778b2c63686979d6e55025ac1aaae0a485fbd727b446fe460d1c776d84fcba1bf37f847b4e87d28e9dae69a82778eb28d91cbeb59c7750a4dfb02b9b288166cd70473662167f7b094066bd40af23aa5a502994923fbb93967abbeb6fcb0a36637fc79514c969b9305645d448e8614eb7e6112505a6351042f2d98e31aa6a65ba3b9be0008650578fb798979802487854a684775096f7271af2b5eef4036455ce3953605c84e3bf9973edadca599ec1fc6298e24c5be74e0de356cc801fc0d6786660855503f9d11d1b25550e71ddd047e95e76b039f67e637b4f0e56e9f4a1ca12ad55393aadab56a58eca0f833497c9c837e167e30992b5d88e63f02114c79b087213982cfb645dc6c7fbbffcac7b87e0a5c731d59eaa59034b655ca2a0cdf16bba0429563895dd103483aa42024722232fb46eb1ea69efe39f758b16a29d07d134d31b520390995ff645cc6572ed81690367848f28424b6f2b43d8b73f7dadf3b79ff00ca6024938b8a7a4e421ca3b52651fd5cfff5fa5901be941f8f94e24432b9dfe32349eec58aeb3b2ef94baeaee35b0ace13f05a32c1b12f51c4a9815933a5a33653edf23f2036b3e8c451229bbc7b62750ddbce1ea039f7a72eca26490bba69f29334adbc30feb4892d2398106488fdd1e6d9c8bf28204537850d2c7f7965b0a8da203832f08b69dd16d3916d88fdcabf591bbc12021ff9ef8bfc68d62962b5de94ed0e16af6731e485d99b83cd87f8f7416730f828106cb527851e2c73af28b239e5e5954430a2be4142fff5481d820285fc946b63f01bd15eb0390d57531541ccd8b7e6b84e5e0290c038aa75ce0a149e27d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
