<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9710efd88c6fd2652ade979513e8b129321b5087f9ea1cbbe55d2e8edaba0c5aaea3f417f42d506ea70978570bb642cd41255cd7ad5e1b96567c81678211772728d06b93c54c6c13d91103669036b2321fd595d8a9eea348b43de771c0324dbe62aaf23586623db4b0a44960772ddbb731dc021ac6d7bf9f67025be496313e0715f799ba3c1e92896a11396c8f3b63ae4415e08b2dcc13ea3b0054340b07babf9815721d3197361a47339208fdef76f94864e7d78f145721199bd6c5884f4ed8c4d35408362391cf962457373ff844f4aa55bd2fb4b875604e938bb52c21ba50d6d49e538bfa0879d6561ac8cbda2da1b6926090a5e30a41618d654b7530aaff1573adade2d3e5e1a5e08b1519e293c65559d71927be43220509d6e7e0916b7dadcc778a5ccd81c6b428cc7016c112ec4ba1a9bda58a7630cc3514b80441060969fd3fb3d0db3cb5e9b80febaf947480ec422e9fb6f957d4fabc0af21f786d17943f877761fb07deea9d353dcd9d7c07ab5945f9838193503c56ad7469636425d10e81d8773e5686e4427f72afe33d783a632dde4bd6a5190babf25fbc35c7d97c6537f6a3971d8bdd8bc39db4f47994ec9690cc41856bf82482742198c6440d81cb7be06dcc763b7b2bd4ea0bcf36d6e090c069e60175db3d1fa543396f538fbe67b04b7008c27ae986489dc8de1e2f8fd53e190b241d30f7e315302b0235487cc1d13f8e269f481a292ef0258c76a9796ec93d55c08ce3e8bf131648ee496907d2ddf5ef0f53a32135f6066f3fafd17d868c4efe26cf295539fd2c2ea09e64a3db0089fa7158a81e12fb3669664aa9d7297f56e4e6ee127b210eeb9d0a30fa010c1f7a2ec8d65b4b59152132e53d4fdca233a582aee5b837dcac95dba76a89811e92e8799c0aeda39175618fb58770e380063fd08d93f5e1d903a6377c90ff3e6adf9b908f8056c6247d59619e838ec0b0392f1bb1665543e01badd007ba0e3ebf4e220b50155056dcbd8a076ba44bfede78c23278a233172cdf0724deb0a68b16ad29f83488a000365825a529deb56507b9344be82f1141e6c3a008721ca5684b2901519e58faa1aac93c1a80ea49355d6b8a457110d159421966b53dc2f4460564f423666df908b5d06d7bbd6efb10f9fdefc78bd093729daa1b785d4861057fa48aca35f60c875ae48d6ae3c005c59b2d431837fb539253596d5658831f99735d0e735569769f00a00e33c427b1d55e0094bb7ce5a9ca1fcfb2d05d60d04487122628a201d9f3aaac776110e08fac3633ab3b59edb0981809f7855fd8395513e27dd36b38ff1bd1489af9bec1fd74eb5792171f4ecc6bc1ae94e94e946483d583e617f0683db7bb6c2d0baf04de0d0b4e958b7dc1814885ad25161a0c803693f5a6d3016ea1eb02b08a53d4a866d2e589354de3b84be5778d517658e78462906a4936293ab3e3c84665a36545b0cdc8379d328003e0e649f12710949787845cf4ba942e5456b9b26d11996454c60cec19972b4346bc107e6a5999595f6ed4a1170c1ef7e4b33137125104acc36aab5f87a59d973dde180d7bfbb1b976b301a2fa9f4b8a2ebe58a5763b87989cfbe998b6f119f54f0d6255e2ce3a79d773b8e59765f871f23bbee609e531d954d3090286fa21acf2b83c4050ac778d5a2a0fce822e8a8f53fa9161a561486a1262c6f126b8a5e5d0fbaa00253aeea0db8ebc049e3aebd3093080bdf3faf5e05de8c0f8c73cc054de28428d7170e9b32746528b67ed5182c1311b51ff48701f4ad29e3a169efe9cca2fe10cb2525e6f0758b93513c9aa51ab329a285f075159fc7e520a5518b928812f10ba3b8d5ddcaf1feb61899f14ae91af9d72ed83f22949371903fcac69819f78683332c6d4be6cb69cd8e1ae0380e5eb636e19698db5a299761e8dbca3e02cf91ae8fd05d1690f610c613a17b4eb23bf3481a20bd351178209ddf34340e950205adea5e82bc6ad44f67311fea8ef62ff182ea9a1b7765fbb7059dede8c0b3252f62ceb856f35e66bc4505874e4604bb38fc5f1906ec02bb43096d5f2ef410262cc090ac414f2c7948cb8e69a96250c7c3685aca03032dee4963dd80239beec7c2e3650630aa5871040b3d48ad1f782fc9d1d0d16a13883fdf87fcf618d4143bc94431ba0845ea98a0708ff24e5c78ab508b7cdf21b0942305f464eb8d0dc93e0ec42dc3e7c1eb3c2912bed11ffa4f172b0cbd695a997b85efe9cecb31bee679367fdcbf1f6260f5428e86101035f3dcbbe589487e7dad5fcf257ddb39420fe5215d3681b7373f090688e551e5be846fdcdbfabe3aad924384b483d572d69eeac62e97e21988c3cf1debc0ae0b8af799b422ce001909dacc520d664bcc407e5d889bd384f9a9ad2eac78185fc453b2b85fada57217c55a0c14f075d1fe7225743ae5edd4164deba61bb3c4ad610c9d2c915dfe9dc268a86c2e9dbefd4948e0a786dc3fc5554caa154ffe62abc2c502c817723175cb68d0fe481f9b668480997a1c7ba1b4a455b0844e5043c71fd4a48fccf8cd12023d85f50c7a82993e3b5da6f749e8a021c31e85b88a62eb0e9ee3f3c0b72bb26881dfd77e2586deec41e898c8ba75d210ee48f90593453329164d630f2cef7e00e334285a02021d33ef869afec623777fb3c71b51eaea1c1e0b2f2f725efbf6a661868b5c56bbb5ee8921fb6c6d28b2f95581c8f8e83da01abd8f8874a318d4e4575e2f798238d2f9d00d6f5ad6ec76918d65aaca4d74c3b7f4291835b0a005b79b3cb467294a89cec4e10cfa1fefcca2f562a57d56765aa5ba266de61171ae148747d2e31544904d4ac0406899f38e42b8156a2d4ce025e70e9bd91c5423a7027c9dfbc078f704e4ac0bd9c50877064231b96dca7fae5bb3ef19bae7380e61758ec0cc31b6d76415d50cb0916d9949620a57fba9b9bb945006f5725e6f174b3ee68e254cb2bad2f88e518e17469529b0974d6a4b07d772818ded31cd2fe7fbb69743fefcc1c56f583e6418c5dc7f4144d513f372edac7566d8a1abca07a38791d09a115100a6a62ce932588a9b489c7c045ce20593a7590f3f3b376787d71d4c2b8b1a498b3cdccf5c9cc0ef5964f93cf713d608644ead8d9ab8784ec2803ce9efaf945bc3c34db87767166ba267a9f77474afc54fef4f5fde97d2a0149c55a782af219c8faade943949ef473b0d4d3547e614ab900152c936e9fd56d2e14385b5addb1457c9e89a4aabaf5a42c7e780edd7948e2dd1dc01e8638909bfb1095abaf21ac2195aac297aafe0ba64fd69ef207de5c5e798f87c43ac4e3ab4f0f7f7472d9d6770ed5a399159e2a1218f4f15f96b17ffdd87e4b9f54c44ba4ecb5902c9f8181ffadabb67eee2aca33588e6e098ee81afbb38e7ad8cdab7d6f00d7312d785690aa2b73bdbedf157dd2cc24a78e0f83233f1195d9df71d9f12235de7eb31117240ee5af3025b2714215054186236b00ff568a7d125bac58a4b4abb7d438155a4c9d91f717b209c277af5566cd4828c57186afc3c3516c3fb8aeb1662f05a0d8a45e1ec9f3512ecbf31b6fffcf87d1296be4c6756e444699870694fd5f1bd98a5a70dde44de331213557701a0a2cd78d75d924a74b2baa1e73f11faa3d0224fe14547e31f28c9446bb6f820a921099e9b8ed39ba0fb223f086022626787e27b10ff68e1458726c96e25e6ffa6db1ed65b533fca2a90132b82a419a49bd1b8919dd837a00ffcc5d22723e35755fafb035159ae5ab2559ada5fb41436af733570b27a4922ccb6902f62368fd0320aeb9e6723e11698ce40a6453d757184fe5509173e4125e4ba50a563258e14d0ae972d28bbc5bb69a2cc13f0419aeffa58ed7d5cb7aebcb555902511cd6ac6f210f8fba150ea76b6aece5c5b6f4003f019a13d288c46e1a2ab65652ff54822f727a88af8ba7b0baa46581428a671afd7ba13514cfa38c0e6efe983008139a1166cd457c0ba55c2791ab1e898adbd39e969e526db54270c65156429a1b46643c87140ddbb4bbf13b4006cedf2d54af47d8fc51114f84b1f4d18a60d07e620e6daa7212cd31a59a54cad5b06bc3489df285a1be24c1d47d6d2e1883e7977e2b99b3d6dd63d9160193361f521520dc0a60d352c1daf0e52c419cb05f6f8e64221e193ace916082f3081025029082410410bee9a5f3ccbd3f297141e5351303245397ec0c751d6c9f8289c334554b1baaa5d8f578ec2de53d3dfd906bdf126ef03e28a39e8afdade3cb5b8ee88e685b06580c95e01aa2a187278d7ec0f4485c3519fe92a99c9e8a9dc50296e84485e865a995148c5c3b0fac7f9a61691f22ce88456faa73a06e382429eb673d99b128cd9dff9c632943cab72d41d6e45c658f199ce23f524df2fe306472afa47fbc5b7a6b7872f3135f10cff2eaec0016a181138b4da2922e4a16849dc66d9c93489acd267d50bb8a90f839dd347dbd379349e99fe760ce8eb6e9edd9a78cb90a7bef1c16b428970beba743fd6d7e1c86a3ee7a1e323a6320fc9333c52989b9b695bd99f897646969c3bd442a4d211d84a49b162f49e4c06b158003bc6dbd7d10707d0f908c4335293f53d232d8f611533111c30a2c37f23e9b155181f9068dff94243cb8d743236d6419ba4d9208073fa505e39920dece61c8458d9a0d3f1903743e35ec7f817fc92d5bba58911dd402ca9da32494c862555a92181a04d5e88442d696161bc34bb9d0b80ade0cdc26b348bcd98e43bdda8698e7616c95600f4521327e837fc92e0c0c63bf1c9d330568674142fe513d498ce706ef0638df2a18d802ef9ee0a9ad2242ff9abfc295a3573f26d5decb45469f5486ed173d8af56dee675acf225a7a0b13d4e41c7a82dddb735f485ccafac3dc8beeab347cb16b737185d8878c357de4db9ed4a32a3f2d746118de6cb9925905d4f7675ef245afc90fde9837d11dc8678d1471b5c54c6ad26fb6c450301bf0cc8a2dac39f1c4531f6f01446becfc1c14578c231ff339b4a896a668e67db226bf99eece94f1c2ffc9a8404dfc6cdd3150a465a4284346d9be3b58203af5b19ba3d67ec26b916897d4985320c98e9a2dd91e7edf61e6ceaf586a1e4502bd57597a5a1b40a696ede9b0d65f9b6c18df1849f8f08284b7e2a758ed12602b404d19dabd0ca864be5a30862776a4cdcca9dcbbe4c7b3cbbaff8ee26a27d55f4cf4d13079942a9d63b49ac22c554dcabdeb4e585eefa19a4e93c7cd725dbdbc51e1c095e290d63b3140a68adf7f5cf26d591980247a68c689d75d7f03790f92e4943af9282adbb0d6279a9b67fdcb454980e9a3b506f2535a90801433a88c487dcc46c50b7a463b4c10043e130ca11ae038c10d58d6ab09effa286af4f0639e22919cbff245e2cb84f2d78caf162461652198651306a5a96790d74e5acc365ed0d926b95db30e96a61cd80d716ed4f4cff14c75a4b82d13b53e5a194dfb1dd4d14cfb5aec9068beab9521909d9729dd75b674fd57a4d27c68c9d3d5ce77ea3629cf4f740fa19e48381ad69e5b32a345a277dd4cf8b2f5062027bbf6e16232cc84b75da8b3aac1ce75c772a63f3309ec5b21a4729d0478b260c728606c56536de597f98e65a68f651485d3ea335d96744eb051eba81dadb038aab6899de09c70df47267a0f497d2e846a72fc33c3b0ff4903a1ecd126b0c340c706130016d93e7ec84077ff951c593505da44c25ba5d68168c6792e948d912f9b5f8a69f3d0e6ab289d8f96f0fc2f86d4ccd8cebce913574775af2e3aa7b46d68eeaa21081f54c21ba0fdd05534a1651c75e455af8f58073b76f3f0b52d56ee67d954e366bee53f7dee841b7e4006768321b46eb92c64662f213cc6ced9b585fa811f5e2d4c8ef3b241ca16869358c81352987d1127544332c00d4a06450b09bcfdcf661b21672ed3b403ea264e210c8ccfca7819eb23f38e682624a0ce36ed8428f28a591896a88afe771861c2b14c3adb0deedaff78e7106b66d92c2de39f20252cccd75e1da3bbc9055e1540b2bfe98d4fe11928346e35e2f5f746a16bdafe86306a07197a9d4b82c44e06d1ef78fb574e2bc65a2b236aa3291d4e46b2ed638452ce3df0045acc81ec1b4522608d8f6a8f636f3a9f89b53373e766f3137f233a914cb19113a2c28669e49627749f80b918b0485b298e542d4ab0222b3cacbdbe4dc077488f9f78bbe71bfa7fd5874a0598bbece841b70b31699ebd0a1d83e2baf3c7610efde6f893d7c0d0356dcc084773014ed3c70b4bcc9afe9545b9cb52962d8732ebe5445c68907f8795ecd494eec0bb59ef29f7a58f0b73363db6097472b6e4bcecfa1e0605210efcf4c70f223369a98b1e4b392b526d9e0d3f2d012596b0b837ebec32d5a8b410d58d0befe783e7da7779241297254795867df22119562668d08375b500865c4b0ab2eea5cc5d8e8999e64b53fd5f9d2591274cf946b0ae965a15c8685d1d6bc02c9f60ee41bdf26edc61dde2b606b55e48a8a42b6d00231df24888d2cb6f3255e1f1b452dec0c46cfcf3ae24241dd6aa12e41be26d4dbfe89bc331e1e881d47648c1b087f6c454fe1be855e6205e4c3df3e463cdb2e06570c914b9442d53e2d1a0e33130c0cdd4d5a203de428f74a5f3dad99dc242c7fd2847b01fb7dbc5387e1fc579b5b2755806ab0a7e765b1402ba234d64b1e99c5d618486a837cf9396fafee8e36e33b18552d9dcbfd90e27dd3399f81e49a956c83d7751d2ee7416d0c6559a6cdd9ba41d01299a5e495d85a5afef4b4645653f43de82413a56871382ca344c9568572a5d1965fd67594de2ca2ed294443c4f054d2262260829118c130361bbd50555673d9fdfa75a2d7a11d63bba5fc316cb2b1a7c298e15ec89dee99d45e3e565aad2c7c7d5fdf7b9de5295a4fa4393711f995a1892e02da24e8d9e010c12e979c46fc98eb9a4b8ddee472f4107ad9f814e314dd3ea5c0d1a56354c1688126eb669a4781556a454b6c0330ac3e6a737273256289b48d7e717bff7d4161f66ac0be6fc85bf452198960445f5d3a56022f5ee98738848326d55086653975ecfe8b012eae9bf3781ce1ddc72c4ffb00be994e8ab45b5967b6590ac7b0ac71a57a1923b066321bfc0242332852c96733d98fd186a36f892398d17994700696337dbe0e657417f79c8fd63d2055e4d5a6930483349a5c92f4d8e42e1158f6ae5338be78a730dbade05aae87551dd035684c154e0bcf1ec171652dc587ea3a1775d8153c358bea8adf5b09fcf8bfd33dbaa74af446a4fb9698c71dc1bdf66f9cdaa689a28a87b5f390e42ce925ccf4500c6af604fc69a87fd97ea1ec23c8f0acd8b1a84868a17828a706bf389c4f77ac71986f734aaa9dcf281ad9305da661928aa47a6b428a4bd68048fa5fedd3076d5b2c3059dac98a2bb5a08c65d40dda864b868c3e8e182c29cbc0b3d0f85efa83cb0f6702c5df1b9afb4b07fae1bcf54a6e2dc0b6133e6f0be74702f4649199af489af9b69a29a25e87b7f28e0900267fd99e11620db9508f5201d277cc540633fa5c74e80737cc6b5dd96ddbe2ddb1656a818cceb3188e1380a2cf00141bf81aacb71402b885f6d00e51c5dffc8213f47ea675e563f811783f7cb76c7075f69ac4a0bcc0530669a9c8f84b192fac7b601a2739f8ef0682bacf8a5ba094ad749675567a94bbc31d5aec8bd1721e58fcb0e1b172bf4b904fc2fa18a8985a3ad121d1c221e73c5ee8b9dce6339e2d256864838b19e67c972b016d828e73297895a222041fcd4f5800e67e4e36284763f637a08f48841de0f05ddf738c254bc081821db9e50532fc756545afe2c5d23cefddeae52f8070d7fb6e837e95cce313fe441738f9e7e112ccd233e1cac0291789ba972f27a929691fc83cf535f8385a59bd2bb00742d33db5827599dfa017d9807b04eca15be9842d97a4de65b8038ae9edb6e00e3c771c0d31b1790aff2d2a237f5d0f1764ae5f3f13fdf931092e4587fe44bcb957077de42f5064984a7fdf0f57a941cfb9476af19f109044652de21598c3c8e8984ea080ea5e8f3094c49cbee746f2cb17d1c4024d25a59b02addba8c015b5622beba4d218420739162be08137de373bb2f247f2624adaa7d529bf660d29956124c6affb54c482723a7516f77b3850303c7b1087dbbf5b6b39262c2a890a6ada2c460ea955ba3d30d16fd34f850f614963c2a078adc9808c36fd5de456afe4c7594d97dc057e893ee072a6c0e0ee57008d05de845dcdaf99c65b9897ebd9dd8467a02fe47523865941eda7eb05b9f11f1f7d002c74ca2a58be5b3fe2606dfa710f68a2fbb2168d532b2fe722ef5246a04fbae2fe2c306d01d302f0570fff122c04924310c7a50c3d2b26cdfb78942e5b547af9e073422ffa99eb51706ec2ad759bc264c8f2ed864a6073d8f70d3d9d36b712b38f8068db402b3c6ce14702c2181dcf7966a0ab9bb55bf13c4e0722a343fc17487cfa04fd9c4dc7412327173fd436b63a796b7170c1b4002217153e30f3879d9e15bca007c39bdffe821cdde6d7dd652baa426b5e6afbf47043a79222ff43e6d2018b362b7b060290535d83b8204c32e52dcbe97d992ebf9dc979ecdcc855b8010bdbb7a3a75a4ba99e7686c4a405096a4eb8bf4bc17da21af8f8333fd6283003be9fa4bd237bfaf051613423665496ce0443c03c5a95c7dc07c6eac7a7ce4b6c1cde36763d885e0bbe79e71eb6283232cc049817db6e684173c015399cf0aded1ce9b6048866461a746c0c4e767fd0fe9d15ae2b525785a4c0a3f7f039f334edc10a7d0264582a135a6138a1a788f832dc58b00601d15a2547036000553d2c2800e547a0aad60cc2c3ab4cc41c66bab6bda162c9af21262c9f20e808cca460536190bb1b83b9587f050062bf4d5d2d6510531847b839f0b94aa408f1305f181c076cb60644414ebac08d28ee205ce8f0066e2cd1f25242d05f660fc39fc6f0d3f8602accd70ce567c18abfc9ee099ac5dc874456e532cd87010e07159c9a639083bd8243a0addf903bbb819b1c12f78296ca579c67554be5d67011f09652c46f8f37f930ebcc1a49da398ae56eff5460c7d735448a98c370b41048371e1c02a12a71eff76fd0921071e481e8c80e4264cdffe8c3d1ef04603711af2d941c425d1973f19aaa3b780d488796b53b4354a8cf23bf6d9b44d4de7dc47e4aa130b5a4ead72e98ce708d0de851b8fea0f65fc5ecf9b282f8ba52f7050896d811bf50e1901a3d6d0e221193c8792e302a93bc6e05afa785414173b54a0320f447b39b8065a2a0eb09489990c3869060f2f727095c6fd682132891a7c9c8e00d2939749eb24f75832fd424d5bf7b0bb1ca7ef8e755b753926908627fee1b53b2f2f7ef30bd8c7b30e2ad148d14576c4856a360881ddb76e25243156b94d324aeee1ff086d82864613ca97b8a833d2cfd56d6a9036f96af67f8c91c4edcb299e073f2c21762fe6f7d1cc0b3e3059b234488c2fde1923a9b74c4464e7b81ae221d6e423dfd63c5920e4511bffe14f002e8b4a2d9c002797efe2e0de696c124c3e66d036c532ae0977312b42fd998b18c61092a380cf4a77aabbf43cd5bac5765c339a92c72f467e0fe7f9402bae2bcb1cb1953769c2c0ac5da5fde0cd021af9bf1b7695553b97671bbefba1ffe43a013ab4a79fa000547f7cfc46b7b4b62eca6817b8ffadab5e45f1c953e6d004c30c07bdc0df3bfa20a0ca400b62551ad7b901b7791410a4ab3542e3d5702407706f43eb45c5f8f139b6f7a133d15c578a7480eae2808712e2ff60c6194e0169436b00130aed3e7eff3f8f874b9c9661c8097448a3acb9cb6607aa9ef15b2c33add6aabb95ccef141c1f0a3290c441dc16569dce25013b3f5158a2ec7ce5bdacd32158452d7138c24c7b4933849af7a259cae10ef59806feae18ad59982ad7448cca3e2defd09b53676040602590a163fac4f57bd75d711b3d272bf8a3760d6ae2ba3842d19167cc3a8e7af182e4b8ee625533c2cde2fccccfa2d4290910269acff515d79aa3122d979bb7899f6dad4049cd3971c70cc634f5e4b36b5cbfef7b21c3a81af05d56cfb0ce9f11b8f4de6e8afebe34efa748b7ce8bca76b0e308633b1a750fc07151c96f0547f064eb86ce39e1cad82089ce05f78bceec59ed3b0afb0781c21b120b27d7784534257eb16a98c32f1d9be54977e67cec3eec2bb5ca0209538ad25c0e9b8633e642ed9eb8d4307677d3ac682abbbb9c759e8d7aa3bde921fedb792f57b4d654da3e2a75988583a38e17be0b9278c57e5aa348335279b7003b268920ad42b5d6cb9702de274d3b9820b0c57132e4d0eacd75f540060049797a5a133e2eb7f5ff92e9ab358fd6567221c9842c2cf0044a8fb5406afde8931af737c49bc1fe560739e6569400cface8754484c43043ae2f801511561b7e0db62274773bddfbb87ba40aa2323e810d14721abb0f7be7725c1368f055cde7a87e3adadfe1126fc7118872ca6625721b245d6950fed02835b595562f1c65dc2206e107183cb33dec60b014c48e5ef8019697470db51f4346655c4d6fcf33fa469a6cdc83bcfa79d6d25a09d1015490c813cbf08862002edbe40f13546552bcc864646076764e90635feb0731bf7577aec1c160827005fb362b67382a15acab76a4565f7fa9012465cc828ec3722e493c949a27af336fe28f9818b37db23f74142c96d19fedaf20f2d7f9b67ff6b7936ee816dc1c8738d05fc64821cf18e01d527d075d7503a5d201f71f9d8eb89cab49df104022aa7f6d884d8e30474d88a1aad287e85b27b2eb982474ec8ecf02036703c2b5e21eef80133c8385e96d585637e758c0c66d262a3ad6ac6362962571a91d2131f8543f212762b86d9f8c5bd2c4303ad8ff9160da5e142b63509846b372feed01663f032b77af6c25884269bc57d48df813b83b23e855e896ab33a00e7995d6e2b7b04b2c9ef78cf3f1b57d7afe59be763d73802ca4f80caa0cafff4d489d1c3067efbdf494b08ff739a15b596dd11162b4b8f4a6f83391fe189346f21d9f9518f9b2857a2a5363c8805feb6e8fde8f6799c1d042ee44bc6c42ab0b9b6fadb165bf9b2dced59d4a0ea53e6df0266b327cd86fe9c409625397aa1590353cf4093c2e3a1aa7d7c8577f2aec9f775b2846decbd39ed64e6593bb72b63733a89d1629634a2f7df2cf25e73dbf12f9625b446b7186901a648dbd33d4accc97712d83e50699bfa2c62c71b5f3c5f983b1ad7e9976cb2155b0551e5ba7709fa6c47366672afcfec9710635e88165c3d4b03d2383694f9044c2cd1d5006009dcf97002da3fc9d38b06f634580c33413288f7c73beeffca54bb4fcb29d6759a03ac4e24f9bb4f52697ad4316532814ecfb1fc661c2ad35ff4df83a02348660a3fe514b517e4e8634d1fce43073aa90406db2f05a7c5803423c2d5677fb12f89eb94f65b85211e7b704511237056cfeb22d4d9a91bee875f903983f7b25479fbfb334f3e7e9d71a254cb2b558c41eff0aec58db58711e1809cc3acedcad2b626ecc300313c083efd0b3c1d156c21cbaf60c5d452abe3dfc2a39d9103d5f1243e07e41f441306eebbb691b48d35d90987564fa5ff136c1bcafafb5d400c9cb4b1eebafc118b17b153c697d146e7a6407f3b7b36dfb410adeee99fef10fd8f2582c37c171942318dd1d621d0e3a2425ae05f958c6e6d47677e64fcf60966fbaadee3ec2a2ffb3542af247525185a425508ba672a58c807677f7858d2b229b1148f39ca3fcfab8a25a52bab2395dd244a743241a9f02cb76aa6372531c7f788d1f5fb4d9f6cd8b800b4955750900a105898c14f85eea8c87bb8fc1938fc430b13c63e97563db8c32b54c2308c841beb18f94ba99d257c531944423de5b3d00ecf2779af35a5de20861803355c47edb055cc0334b9d0bbb1e802e73c046265de27a2df5507aced667a8ce023992a0f12b632485d594182de217b4f9a456e5fbbd4a1c0f670ca59141b1551b71ac2ef483003e759385401c1bb327171c3211f7a89775953948a171fd38cf7f540504ec81d039c4d9b0b4c531e0e72f2431c8000bbd371d06568b93d98cfc3b91f792b0ee7d83a8a9461bb091972f20943734bfcd3b5ed3b34174dde3cc15c2d2457ff43d9256db697e487f0962bbb5672ad6963126a3a9661a86511ff89a3a7ed9f84a5302a5e807fa32b67014c857645c50eb20004a0ce8597f87cda02f1430d7c96cb95b1d2ad3fec3b5c3a7cad191700b40efaad4f3956cf59daadf0d44a15b3b639e91bc60cd44cb701c514dd2a0f2bef641416e7df19bd9e12ec25d69e4906e36c36d9ebc0cb2646286425ad7cfa8c57b10a80b3c71a65fb33ef75418ff95319f685e6e864af9186a0e56b989c570643519c41306aee42412af4e753070b1c8a83d3edd16617ab2bedfc600ba740e5e9a2f3867b466ce0a67837f5f96060f7cb5e58296c4ac7afdae30a7dea6597fc698951b44e4a560092ba37d62f2a82c66d90bb157b739713973aa3d8c70dcd6508c0ac20abdb7987348c2e7d142740f34bb6b4e88cf4cf8e02aa5f7703da8f62aeae93ab9aa78e98c16a98e0fcb81e52b2ed686f4ce071d2747815342cc43d24cba7bd358c2fe84402142df96bc639ac423c951046be7e4b8e80d13e371f0133f02bab45a9c0fd8ac65b4ef86aab86e989d6de89c87e53345cc55ef91103e2cd08685094bb6057bf3d4026d0ddab37d2a7706dde08f944dfdbbfbe7a052fbfcb713dfd6934d29a2f32799c72aa2f6b68c65f055132010d1cd3bc835ddab2f8eb0cb1402814649633d9922e39c0d9f02ee3c758d6a732e85b7a1fa3ae77096795400c8254df771d5c683da47e5789be3e69ba281d3cf26c63b2ebd7864e293d6fcdb8e51284593dd71c5eb25fba288bedb074300c47ab0f0553a17be80efe00a6577a0d46aab056338a1da527f212ea2f7bb15e35f2061db5a744b351689290301e1a984b549defee9c3b1ef9910fe195f64c7c383473af55c6cdf93347413eedaf23d5305f7492d14290542334aa0b10ca39066d0cbc7fb5d41d1014409b2bbbc5ae42913a9d7f98feb28a7ebe06615535bba862d65c4c3cd15188402d8ccc59e1c34d7714105989c005f7a7fde290a8adfbbabd8f543de72282e3d97c093bc6605bea14431bc0ef961573d44fcf47b6dc2cae7057a2e2c0c6d7c312dd9e1adcb02f57ac2c60aa9400ffa9c68e635e9345e793275d6cd7f489a1f46c995ef67aa671748f4e78e1f366eb0193745e0433fc834b55a86586f7bed2a8cf7b5c321e57bd5f6d79d2a5dcbafd3327275047b2242e7197c0463a89d90dd3d6b59fd573e59dcffb77680a8a78f7f8cf67709daca4df09cc2177d1b0a8ee201705b664081eae96a3185441e8aa684c34675987c792badb9cd41e503cbbd4f1e0992b9f4e7d7d83e5a0983a9b57a568dd93eba0df098807f406072f9b6b9f1c52921778e8daf6211dd97635dd133de3bd0bd8bf69accd4525bfaaab28b3aae9e3e5e7135a5998580da02141d7185d26286c07c15551d8e9137ff4bc0333692a6469799045f7fa5c5c6975914c26b18290b11c31dfbe9c1a3aa0ba0a1854e13d96626f0c44b5aafef4b1240694cfd6608143a277e5bd3ff0b325dd5c756584a8470c20022ba1b4c4945e58f1c057051469b6b65a84fa0257489848ecdfb1ccd3ebf0d086c4b78a37c73fee3fdb36e85096de88a0d233b67286565e09e9b5649e09e12f51c370f26c909d8b95f5708909d72c5251145e1c89d77deeac7bc034a1b943566aa555f84ba2012f7587bea0de8e05fd352e4e5b073656a04c6a29aca08b6696a136c342b93aa0de7f7713b89c9fb389949b69d9eb57bcd42de4e79c25d6b0243071d671a22ca41fcf330b77c28d5a2bca230610a8bdeb354e7624dce80bdb60600a8bfc2a25e603390aa2350c407bb9f1c8a016ee38ee69aa998f9359f4bbb81c6e9cd86db7eb3a95c46e5d7c650c8968be270af162a439c993552ead923ff71addbbce20696b030e50d4657458131f99eb15327393b64de5633a20da0f263e9a5dd8b01640532569f1bb06ea185e5e68b216a86cb915764078f07815f5dbf2de1151324e9975105fade85d7c02b509feac8f426e9a7038d4505a11938ed97243d525087302725b7432224bb1d33fd58e4f69be18c7f921e292178d786a570aa57d64c0e7e7f67d7218732d4a76b25bfac2fa75b1093f777895671c3a4eb321e3bc509f8ed8665b2dd1ea1e615bf527ed01a5b66ba84c07a52765b67ff1c22e40b9beacaadfc98efee29cf8323c98fe84ae6a241f752766d02d5ff30110516f3c17f3ffcb4730fca39296488b12a904aef7bb540b302aa795d705ca87209454ba380340499c6c270900336bf4365d807af3573a1a7ec99da022134c1e68066b3836243205ea6bee7e55259e2516754221db0e36de91b0ae6d8886593a6fafebdb66c11da3c80a991a2fed225815dec5f4817c2a24195428d217b6af4620b6aba2a61033c628702be5866221206ba599fd9726c98ad34cb337e25e1834c2e923a28d392e5d4064ffd2c70a4fbbd545dc733c51a1a845c92fa46e1624dce0a54415cc653d4a1d3bed1f85d42f7d7896495027287aef96ab340b39bfb76df962c1ed043b3610cfc5f862ba7836fe1dabf6c237682d10c3bd02298b5448178cdb7d063f3c894d533b7fd616abddc2a56fe7c50dcb3d8a9e277665e1131cb8af8351bfd9a7727ea0ba1b1247835ad6eb827d9fa6a4c70537b36c7f2a4589b9014e2766b97037f4b5c795cba6391aba1289236ea91ebab2230a0ee444ca2d6c7b0705c3f6d261b4e1c4671bedca28b8691b301038f1396409336e2819af6997b7bc9a468f127d18782496a271a5836fb1169ec92d528007a0937dd0862cae321aa3394c7a37b736a6591e7d315a41d3022c011068a16e94d710e0a0eae6285ba7f8bb943af2ea667e05447b7b39aab689e5471472cc590ce80a3c9ce0527691f3b8e284c65880b181d580d3ef343ba5981210b24c9d2797558c40b28260777c6f9cc70a4535cb328db320b63c9f402bce82981e1f19de4b321b15f1c808e401d5884fb801b8156b8b5c14036059e924d3081e574d299b875d365367124f89a79e6cb76e4c583a95be3a4e5f9274e6662c12484ecad51747eac34aec5e0339a4ed4ceb67005cd10028901b699bff98b7b7b0fbe75000e3346aa20bf8b6d9b1d5e019ca385ce8f970ed59a6594f590dc950fa417765e487b4e423dbc90eb7b6ac7f96251efdefa6caf937ff9abe10e573e547199f6023bfe9e6eb3d6b4a7fb31b95a69e25e9b4fb0c5ead658f66d1b9653a3c19747822158f51aafdf1c6370beb7e8e28fa31c5d86727e0fc3f79d79175dd619cd4a57fab317aa4b3c6460874839b859b5210ae2219edb04c7a42b19a0bd5c46db0fc7159fecd474c783730867f4b0939f628ff7b4aa522fcfeb44aa070059f1bb53c2f10c3cc079d412398be84d7c6d8b441e620bee4284bc0d0aadf5912993b9f6a2d9e65ba097ca7b3c4c82e4602b28f169a88e58be760c188f4ef5fb4376aeb323919315814a51ecc0c10578f4b9eaac08f28fdab1e7619628e59c512b4f4dc0444b0f2602590f1c531e9b0ebf455de528e01b094b3492d8654a4b096cba143d30a49cd84acf14005c8de15f666418619d1767bbc5ca46cbf62c64152f456a93667357b0867c9d501883e5fe0a66197f8d6c46239753c53c0394e43163f212ddb364367846ccab221d1651450cd8e7f3488e49fc796e67ef28a999105e3d8b06b6e9bfd4c7c29a97c27ef7a1c588d26b12d53cb8be02e243b1ae64a97155f6f7dbf7b75f124de24ba8d013b3e7b6e26103dc98e5bd6820b87052b05b8a2504eda83245eae1a2c53342e7f97ce52da4dc6314dd0bddbb98516b1b5fcd1074ad5eabf95045cd40f38aaef2efe51a000efd41f6ab71f7c1c35a4265c31a6edaabd428376f80b1384490c55f986b1e3c34a62a4c0cf606eb39f70e340613df51259c9fa91d1f2cb16e8724681dec168939117e6cce8d8ea55866369d51d53a270078d97cc7171e514fcab8e00fdccba67780ce621c9f4f5b5e9d67baae5973e8dcecccf1850d6f90b0e0e8ada82bd02b03966ce0e98178bbb2f38b9f60f785084787c08af6249cbec536deefe188cf9955fbcd1113dad316ce4c22ccf80da332c0fb5db0daa7766704da9e882fd6af8d61d76fd2098ae18c2f14a177d326a81076364b88cbab752a98fdf5a1098e5c7b67e9241e2fecf732c560e6969b8a41a8f0ba536c09dc9b101d46df38053132ef93fc2f18f44e12f01c121d7e6cda4fd0347ceb152c58e5ac27d3283b57a1819b166f495802e82a215b3d290abb60d211c5f035c7930c1581415982beda44883967dde0062bcdbda776a1d5d7ea5fa69692fc57b4370b99bb26e67e95e629114d6da1486d7c2eaebb65a9eca8dbfaf842e3e40e03b3c6830594ee3e886d4244b61350a7b9a004d5b18be8d2eb1a3ea7ece72b1ca0daaa4a0a46854be0ff2f07a0f64af9792047043b6d2233c9f3db4b545f766014dbed33322f8ee68792e64881efeeb33bf63dcc497813bb86359dee4d46e2a026304577511953c95bc4000291c078b0d71120ebd562fc7205da87165aaa3527bba04c749f5e85e60b60db39c842afecb666aaed7563bf23c7db8cef9c3cbf873ba116fec1a0631314a784105ed0e432d508c93aaefc59cff0fdf9dfaae04590775f242314977dd62aa305db5659b2d7a8ebe4bd13bba42277154f75281cfd2319e3329316ed45e70bb95cf7c858ec9597540276a287a3c5808d97d5cdab6256f3b25f116fdcc5c35346281c489a8399c554dc87076f1db36c3e1ba5cf13e16a93a5cf7bf3db6c835426d425dd70e98773476cf96b6ec47e81f3a66db6050c2efe189fa0d15a0ac83b3ca093c354f2f1cbe685221bf84c55d1ddebcf0f8c92cae95f675f52ce6db1b42115df0abd45d521ba03abab90dcc6a572a97f91e86d382ca4c74b0522d96900e5e66f93df15f22fceab48afaf46da3505b60cdb2d1f278906a453c9d497514bb4d97d2a919184cfa6195c17dd33fcfb74ade4742cfe9122a18794bab31908731407fa3db170b0ffdab3f94a0d32e3dc14cff1bb11fc93bf002682d75966e037535afdbf924821ac9931e383ae5e6d01933819295d0b502bcca47d32361a474295894becc21cb236d99105ef4cde6a5cbf5fb9c0c86c726527d7e9df12f7b9e49e566ab3d5a3d5bcda252aa3af50e36b4fba99f529eefb625ab7ae95820f6f11305f592dcab4e9244f6d24273f7e66b88418ceb61528d3b24921d2e4b6481e5309dde727f06903dbf5ec3fd3d0c23632dceb2da4a7581af6e15a99b332d4d21b39774ad89335abc0379812a691a674ebdb971f976bd30b7a6ec0bd9e9b21c0958d0e062dafd8532537a91d73a2b3600ea179fe58ce23d86b3f34203e7a156b8876b2d7257d4178a5c6c180424cbabd7f619b35c68f3cc06bc95b106c719f98e8aa5d7c07832a9e495ef0a5aed2e4b92e02420b5dd4ed031fd368249a8cecdb9a34bba5abda4eb9adf09d4ba2656dfb9e87315c970af7b65192adaddbba9263e96e03313ab18cedf6909462a5e8109128ceeee32ca6f62215fcd9a0426943096267c14417c98ce3c4dafa9f7c75a277f508ff868247a38d2d58be5b8fe41c8e4d323c1c5b74b23651d3081f33f0f716970e5180db0b7c74d0f623fc887b79d0238a1bb437313c426c1e2efd2e2f6f1d8ce48dcce9de17e5686dd5f04e9ec92f7cafb84a8e65c88b6f386835ac2ee1ef9c199308ae91ad6ed300e3288995f2f1c102e765432d33eaad2e338b65163f7e2e84a5e1c96f7dbb8f37bc0fe005de90897053d4f5c94861fadec1a52626d0934da7e81153bedcb69bd1a9a52df1ed8c004fdcd9875a099fb3bf26d5e8e8e09f447164c8b925fb25aca25be9a3509a628f64c0707fadd8d6f60693cd4a01","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
