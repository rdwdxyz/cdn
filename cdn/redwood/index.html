<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eca3f9938cd559375b7aaf5c9b52714b02865d5c2d3579eb814388e6d5adfede7650ef0fc8b338684ee9c377d105929e518f92e2d91fcf368e9b1b5ec25c5ecfdd19ac189071d59133aabd4a49092347d650534594c37f177ceb4e3bfd9e10c12d3a7e8b9cf1c98d6eb7b442b7b702f527500612d74f1dbc78efdf92e6f8853f20b0476e54c4313eb7034cdf603b98cb295143e289ffeb8b3cd99734dc84ef7ee398acbf8766ff941dfed565021227eb04f17215de9bd9ce3ffa2cd00a8d56d235166b1c050f28d96cb50c606f7e8b3c46ce83ab3b1082494b268081bdac171eda97ef3686e0ecdf711c81a3e662ea3ee8e1522717c71615a9e0247281a8cec60da9a276237678fc425127443995dd1715f448f2f5001ef4323cbc52b06a5ba28164611e135bf058f332acc4ba7ca37a05a0b3a8d4b5ccba1d275f40a17f75683cc045f11bddd95af93a1556fd1b5437da86d34e2dd15d7fc191cd7e3b5a7103b100400fd2e8dbfdece32e600a25327cca4d7e5eb9382fd64b51d21843ea5039b8ac933a9e2ec2cb099ff75edc41a67992599db0b38ee6135eefaec4670473e554f36519bbccff1915304c10dde13e486f1ca755ec18ff0b2c61408c0d913483271b3e2466dc1deec6a024ffe212e54c26d5dcb13bdd49ff54f179b5a13d742c9639d5038ccd239a2780b2232ecab0ded249138f3c075d567496a00022e26576cfd3a58693ec1628ca4526b592d28b464343a8022332369c37dcf7defd0c7e9d424b3f76f8a23a465e080b05cd3858c9d69560beafa14e073a03b4d8ca6a1cc51da318b5f56c09d81f71ebf0609ebb602b2ae50943074601919b31c8cdba9a90cfe3fa85506a0268719dbab1ca5c7f9510ecca67ace902391301544e2199fbd8babcdd85f87adcf458bdc81f33a4819ff32bebdcd5036db58d835060b942c64bd8fcac140be93ef7c6834f4dee34e3b59d5c77e8f1830f532fb6fbd2e674e0526ee4564058c3b2ce9d2460fc4dfc3848e40e4d1e9e4e6e9ef4f284ed51901ef478def6724e33caa94c99c54f2e9983af6415015d01e665a9eb2406f3eed6bf7251ac02d721df1f1c355ca9e7281e43c2c2cf5131bd60542332425c92a91e42f23d62f02096e05994ba0749b765eaf5f41f6afaab57b36c83da493c7703e6ef2c434c23f1dffab4a5a884c0b4005faf91f9df077a8191802713154dddef4619e839ffa35df9b4a50fb37567f5bffd9231679191b674f716e27459d04473eb17c265a731dea7ab19ca62d9bdb377a49b674497955cbc2f839c4c73d34e49a8a9f81cdeeb9d2546f5b5abf6bb1fc8773cd74ef9459da5555a457c14c6b22d3d14c7f29481fc5ac3fd5028f0c0b457cd8ddbcd9e97113ed66707bf777adbe2b652d3839be976fce2b20b527d94da902555a3ab13e87a2338cab74b34fd30e22d29e194ca41d411a60a7ec2966232f284c289fd290e6b4b20cca18a81a6c9d09b83d26c134e133a5b9f72886c21aface89e1fccfaf7b52630adf78c4708d80b74e874606dc04160b367ff720bf16ab45b9b687a3c6530083e22c57b1e353f23d18f6d32f62642ccabb0eddfe26c73d5f8e64d2690f062b3aebda61bec7d5a3df4ff188bad45f2142395b3c5c1849617cddf377d6118a9a8ae070a75f525794a75bc2b2e4cc2de7d8e3ea3f57a2fdd33a4fafbf2d03d4310834cb905f9740318e93be8e4b4bcc25f0f6e69fa1a1e9689839795b3bf8b23bccdfbd9038375b5e45aa302238ea55798632e15b22e2af87b2b7650b6f1fe0b0583ad3f3f6545e1ac1c476cf0e46dce2008fe59018ab444c39eb8a5cf2f8c0542582311d387784b290c44dfe2cfe2c1e8dd5faa6ab9b7dac3a256e38a4b5ff507cbdf037828828831f35f9b22dabd3e684c80f454b97cbeba5b211c63e771b6ca117304537f5789355c092afcbfc98a605421c72db3d6ef3493678b7d3441f2b4ae947083e9c70784ee7bd95e279124169c439a412a3c8b82abd07b4ae854ba30bf0d4757b15b25b41481f5ca07273b18ba752aedffeed5316b771dcbc678fc1247a8ac26fe8884272467a8ec1c57d135a91b4e3f8dc03751a34f9aa55c9d6ac9f196b829c6b5950eb8f7078bfdba25d9852b9aae3216be837f581e6abc9531a9843c7113e6c5f09eeaafd55168bb3c28ea55eb3e036e9450db8e9bfcd8457b0329a503291bec9cbccc55a2fa95361f3de51fb2d194dafd319034a1fe5d2e23591a7ce97dc920e47150e4477d5cd7efe1c02620635f9eb2c5cd6514a4db43cea73e2bfdaccb4c460919e096884adc6a945e4d8915d6d7c59fee0fc86b27448b4a7324ea16e97fda233aefd2c9761104cce9d527d13f54e3f9844c775a54f98069a48ac85c80db138fa81917049f3f94b976f25e8206e88954c2febdebecb5d7ce2b7de081de4e1c6222dcdcb1930f05b33e9525b9ff9f037b681bae3238bdac00438c9e7fa20c5a016284ab6e016118579d48f090418d50bb28a28b60181c0dbc6bad5e776a5c44fb0ac14594ba4853a27fee5681ef749328de785e0abfdf1d4da97e2421df4887dac8ac6c7822eebad01f72e09920e571904b07bf18ba448545fc0e27fbec6c0666bdc9e2842ecc4a668ab3b1478c141d2fa24258d9513faf83124dd2f1ce715680bf5d3120e20a5f87e19e100d94383a99baaecc932a3af252ad8fe01fb5efeb4bea86f254a2250f56ea0ede3a8c2544476208e2d4bbddd6bd58c82ae07dd2f7e3f25a7acfecf856987cf3308bb7aff9278dbf4e8bac9af804c6d84815328bd91408ecde0deb45d54ec561d499fcafa74634f41f7e5c1a3dcbda65b94cb028feefe2e3e5f0bd14911835673c161f79e499a9f1f2a80c45b0c9dc150675d37c7b7dd3b6b5b7eb0a743920fc6f468791b2472fb233aeebcea5c33c965dec9910ddc7ecc259900adb7983693fbdfed5027f1f8123cd34fc4d6ffc94e775be176c712dfeb681efbe5e5169ce4bc91bf9d4aba47c823d218fa05bfc7953c016bb7d3fdd40d80a8385a3928059e8893b811a0a14cc1d29b1c8b6d1866e3d78b60be7fa48cc4978bf8d0133bda9a29caab8b2d23d88f3ccf6ace13abc4281a0c9182239d612fcd8abc19aae145bd151dd66eb6f984618f219fcf970db5b3126a4936521091956b099cb4b42541cb8d5082a3557c56a89c9c2fef8e6b0ff801f1d3cb54e5b027aa4ce44c346381026cd66d4b945ff1bf39c60f57f95e7afe7dae14c9e1e4f5aa93e7f1e3e3ee6b6c5e85cfed45ae97b285cc0e2cb6affd93a1285fadc26a371e82196614832a91fec856021ae3a82c1fdd094e321bf4e0ebf4e03cf9d4154db23257ef0013caea07836e70625688c38188741e9632dee72614748461e40b7b27f42bf125ff236428c95f927d8146184be3374593ce5b761b3c29f1f1cdbde324c238f41dc5218de6e466069b471a7ae127bb726b9d85220cc38cc10ca485a2f479c75aa238f1e679b279da45ed7aa94e06bdfc4e85c36695540543a064b68be6edd68fe8dfbaacae927986c658cbaa3bc11784ee71d7fc6cfe405baaa3eaebb85b41ca5dac4b0dee6ff8400fecc9e4afa0172a81522be724d4f4910d775d85fe8dd23769ade9bd49be8a2ce7492540a8f41919a1f23605e9444cd737edd7a08cefabe17910fdad3e057f212b6537b833908b0da814777e4c11e51088fe951bb63bdd8dafc616db8b3501e03092f202904b7d1cd7231d9a011653d08b1c5293e686f8a666b465b0d26bb9d770ea72060a522549e66909fe7ce8015083f96480808bc287e90937a8b2e5c9cf3799506947a23af96f7ff9e900074441760e92d3085c34d495f91c749c3435c4f4036a3e839a3e0d73e8c40676d33ae28bb371fbc8d8dd160cdcaf2c604d04dc795fac225998a1e5d74ec04535b7da4e459f3abb9c93bd035c1d001872966fbead80b721f97b90af696f436ddaa39548cc1b366b3b75dfe9773931c2c617c8f97038381035858acaa2fc7882d6b14efef76f606ea1ad2af424dab3d23bbb072f17dcfa0053f73a32e04493bd7fdd1246093a4e52a710bfbdf3ea649135de9972c13e0e6bc667535d50d032222d0ff48d8fd70e19eef8ce7f4760b57657edefa6396ff41a185a3c7f4acecbc07e8fba8b57363dad53371ee26ec1ea89e2b52825321214f9e5aeecbf23d76995eaf1c1737c0f661d2bc72dd1b66b33a5d0f37f67fcfb30c0410e4447802489034a78992a5d61357e0619ca0f915832395535dee34a9846d13c865bc403456cc9c0757fc7cbcd0d655f1076942655ea3f6eb0bea92351caee01fd9eeaf4c5cab33ccb46480d73be81c459464ecb9e9c0ebb39a9c45aa88e613f802d1fba6cd2a593440949b44ed1757880e4e88c1fd8b23bcf70e825c9e358c043a3a1e461e126efca1e78ce8748be9fb51dcfd188e7f332a9a664451dce24f09cdf74f919ac26c5f6ca1846aa7ca2e8acb2cb15afc506734b19a584779b7c064e4f7b5101a0d71b66e92c6de9c96b5e1d483402232045a0aaba031d8822604a07b7f524eda288c65f7c692ee541338c45ef2d25388751b4f2339a97c25bf30b5d0366e54ba58d90544522307679cee5daa85102b02497edd8d975306956d7317f42930db62f32f7a686d12ea5aa8de38846dc0d7cda220cd50ff28d3a04f063808230822b9154d2fce16a391d8bbc62fc9197387736356b611c95d9a47741b5b8a459f4d8d069609ee339ed75824b3f8f87795bf000817039dba7ae39a042b9cdfa746f12171b043c86418e8ab592b8c2db61e9a4f4492d8918f8a1994f56de5580d117f85dffa605fe51bc223228e2482f8838d42a21069d3bceeae7e2f686ec66bdffb320d32b5cb0669b5fc440504c5141b59ebd05c26ee3804a1f5d0920146416040f562cd44dfa7a942249edc96d86e55f327ddea1cf64895f7afb68a3c0d09b411f891e9bc19a0b4774b0eb34ebe1856485c0af7422cc140208c3d24496f94b144c4f4088562f9b1ea700cbf2b5eda264b18bc76ec5e17fa56e7cc5bf6ea056b7888d7afee6172235672fbcc966f891bc0e1f3338aae3fea30ed3ce70dd867931e7e4370d5e5a5ec5a98377e5d144dec945b130eb1e7245e91fca701b0d8e78148c8a0740f6e2b772b60257c16990ff6b08106c000a50d7797c7225c3c719c9d628b19a623cbe4473b8a93d100a460de1e20f98ea8451cdd3a1ac4ee2d2ce2f16c18a7b10177c576769a6faa938070a1d7a2a6a3c6d2ec0fcc97bbc1f4649ea8c986c1f79c8851e0ade1ba87abce74149c0fe1359fe284848cc0fd95acd17fa6090743c88a50de400d10ad57625c083ed234a6248beb3d5f6901d626c6b89d7babda49f7441bc4dddeeda465d74642bd5d02d992f1fb5144ffda5ac618591a55d1c9b0a0b21b023306db9e3725051d3d259ce76f585f2e517500af52ea34c43090535f608a411c03c91bb1408e1b156c302351dc47ca88fbfa52af3feef0ca5622907a519091ab38083e0fa05716e96b5067be1310912d7eb8cd61a4b422822ac4ce15622f573df9c1d149a3c56b59f051080f3f918e6a3c24603aa695157c7e596ee8769ba9e9cf3776b5e9288809e8686fda17ca9711fc2450a13c84d6837ae0dcdb742bd644cb3730cedd1d86ab6f674c32935df9e0e1c815681998a33b7a70848b351fa91e0ae005b495d8032ad8f1508dced66e59397b1f65940cebe81f013b16891dbc91e6935cda6061c704473e7fcebab164e5fa43aa804d2fc9668354824815a63ff2d85de79182fd40daa244c983d16f7214087a313972c67d36e7717f7e4f91cc9eb92233ae5b22782b9d55501ebbc9113991c3b1808dc0d462c45a461cbec462eff0dd07f5a2de6f154a99a789d1f093d1990a8be90f7bea528db022bd599e19607f6eaf99e5c6a9be9eaae3af7100c75f1377607fbbdc3c9d83f7030954a0d33a7eb253ede296d6943906579c8cf42c4f5baca7b082c1b26a05e949b675eeb22d4610085ddcea4d6ebfba276ab96a3293da377ab72b66c2c8624cfff15654c47190c380ff195ebe063907c5b91680a9072eb3102ebfe05ff4f7de08756b2f8bd880731a7351ad4dd254bcc56a122355ccda7b7c0b3066f3593fb266f56f516f9cd84d525874c39ad1a26cd36b9a7e1ed34e7eca14097a6d24ca1c242e9db56e59b11c6513683d14f1b915f81cf4b6fe93c52adb7e988d53aeaddee03fb7826a67fddea0f9d0963a65641f54cdf92fd87e39fd98f7da822a1dc59ba24b9b40ed53685cb44be9b281ef64a424750746b13585a929aff2d46f76b84597f702826eec112bb190b686533919fe3b6d011cf00cc753926a4a8a0c50385e170f5a5ccd7bfb979b64a836dd77fafb220a6f88cca500861d03c4cfe3a78aa3c3101555aac34f7f5e63ade0bd9a8ad5be66b8afd03c593e584c0417cb5a93afce6dcaeeba302378bb9b8faa0554a51de239807c34c4478bc61f9d3026f068fcbe5aa441e2fc9117bb1f36d10f76f7f7a997865c1865eab365a8691c3677eb97d1560a2bac7be4ed7fb0f07438864ab3cf592066dbc87155242955ab938d1fb2805b758658935a4f27e7fc065768a2bd89bb598c229b74168949a9686dcf1e464828590748795ba1158560ffa8d6b3a9366dfb5bbc1bfabfc018707c1d95b7066820ba02a7ef7a4bdf862f32923297b5a78209fbf960588feda01dcb097e8b9215efe2376894d0be285e7f72e2c86c0808345e0c051791e150876afd7c30f4eaa14771668d78f1a3ffada53487ed7c790dfa1c40adb000a4f8e46582dcb0170cf70c945ab49df5a06e906a38767012c137da4a88ff17cae708f7f58e3924a646dd6ae227c8ca6a91c8aa3bcf0e54f0fa72551ce486d4988011da2479f5a427d3205238443f9fb2b8bbe36c362197488221660675d8f50a0bfc85e4018c4fbe0a795d0b456ab188b805fb5068722a4c67a608507968f58f2e897aecbc6ef1c3ffed5fca1ca82cd70e17668739d9c746ed568b227f5997883c72c7af11171408fef61b5a424224487a34af2f460870422ebb3c6e903d80963329b22163c0dbfe4dd401ea16b161173df410d640d6716e35f60ad2db320404c9438f760df852a06fafc435a043b43b03e0d67261b9a9f4e8f572e2d558663d117111d59609d5bbf7230efe47eb24f7ba99e24c9383939c3c50c12ab34275244b021a68339c6687aad4bc9f2b077766de1c5c1243b0156d5b3dbc8646e88104f424b13a0e092888f23deec9502b8808520ecf389ff193e6351146d439f4e02cae13e19c7f66e3adfd3a5bcd1f19fca4ccfd7f4380ab5b8592d0ae1c05e400dfd7e882de5301a69cb7fcc35aac21b2ae809a35cfded237b8cff079cd32b2149286aa8e666d442950100a0bf8773e63713d30979b00d32434baba7a27d36ccc4281490cdffffe0c5e0987feb911beb8b94a7f6abb4db924d06f82c2362b801bd5a27898f0d9952575dd8f8033a52bd04607b6633a0699230da4cb65d3f548a12ef1213dd2f3de1e1067bf4e42bb577efd3b2499e7922983ed857de17d333d1f253194117684a1e2c34ad3c88432d5007110244eb0dc0f1744a3fdf9edb0cfa26c7fb7694c123835b936c8a4dce072d479a2e0d54fea1d91a0ecb813df5de9a59f161b55794a22e51b38455540206ba220bde822ecc0bf735a534dcc96e60589be281d39f0450199dcdc187ec2d2fab225d536dfc2dcda9818b40821baa1b9868aead855a7ff7e115e505bfe5f7337bb20d89082e9986208cf9d1c94450a1c898ad60144627faa0f36c7d0eeab95b54c25e384637cfe5219218a6092f4ed74fbb12bf5d56ecd0e04eea07854e05d0c313d8b91cc069285493db2d5694c13a4ca4d8bf102b08c99f7a394cf8796c19e16076b3672ba0a44ec612f37fe8a22b589fd089f7770ef9dbc43a0e0154d9aa115622e2beef43e17749967ec505cc8736f60e1dbe47846965e2c7540ad4c6d3b3673fad9cecc94f4de040a0f191f0b803ff945667af5f6acdd72407b6f57392f86236704033d57f29a00aff01a14870f91ee1db740041c9381de995db79ebcc74e5831bfc2e4fe31f853faafc1e8c8e30c3e2832b7fae2674b91a238db95bcf102f122573547c5c276cf08a784851c215695d02ad0a5cb173ba8454016201a592a132444baf1515e33143f48c02fef042ab79661767c1edd573beb1302773c9a7bf672415f4175d2673e6189a0deec1e6299cee8726b4ab0bf76e2a445bf25b47871c6e6e71e578e55238bcc52d0c856bdc45e29ce7a4001b60242daea34eb18720c9ba88a9194ad5b8d4da3d58c81e250e6f96db495f5b32b43736fa2c9673aedaccba74b50e433161c62ab392530a46fcffd6114e448e21db0dce461bf731a76050272aa480a61c07b9d4f5bb9850cecc3865c9b17220ac7823666912554d44d373787738ad1a69f066f996ffc7b10b6c72516965570f9957221500049dd62e974e1b44236cf01af8535beac7c70e9c938b2b25189cb3b983a468ecc060a42410e1434092dbcaf2a04d5d24be428626191b050c066774e8806439e8d1a199a26721f2c22f447d26116ad80d37e2e05b0e41100a0e7547c2901341e60f904948d73dd51fb274229c460824d1aa438f6040c595de0443aa16398df324e8e244e5703fb4f48379be1994def8e713af1cab6c2bec50039790bb35f73add1baea3305df214a3518460792cb098a9bdd9b6eb65476ae24342d1f05cd09d8c768d5d9cff63e6c626c528a29ab80991764b4a2cb90bb004c16048eca53c6437a2b949c92f167c5e264644e051084d9832aa0db1af9c4c9160e043e58138bab62c9e3b36b6cb726ef485e18a5fb4472bbe5ca579e8f2aa1a662a8b4d121222b8e8c795db2ce1437e197e02cba3cb34adc37e075a3a768e265b2edbddc7589927a8a287596e4b61e44071ee8101d5db4db9b6d5768b34c31d4763cc6b07559f7aa1c634354add9f1746bcc0ffe541b1d4849ab64a3a84369f8fe65c109499356cbf97e76b98d093b8325dabeed51eec0eaa482fc41883a1b899bdd6e6b2fe9e7def44771efdebb3ff01f0d15f588b1702bea5faec24575deacd821086a09cb47f0f404cb0c18eef3e5a89636a2267e7a1ef9a63ae0c24893b96a39dceeb6e8d4a699558ad3b5b615deec1c55bb0859758d42fec9f8383ca2c494e9d5af522b5a50af47823be1b11c128741b352050de564cb92cb1103ef8cd247c2a8f016f1c9fb87ff261ec1db242c492eeb50059b66c2b483e54e27ed77be426dd3c37413c6c456a11978c7d8d97fcc9082a61664a50b754d89fd2f43915d204c861a7b7e141517b4524f840e41ae700c0f4938526ab731a9ac278b901930999483c71b2b38e075d730a1da7dc52da68297e06959f7743ed8bff9a8b5ad26fa20a3f48e52adcd74ee97b6d50c396ad6f2af37e93b93c88e224d75b0fb5e69a892e37a6742b0c37c61cd2d34d7abe39cde09fbd83ff2b1e799935e549d3475e294b1e82301e9ae8bdcdc83d5c46e68a2a89a6cbc233be3ef1658cd0a7f84ce98b3cfb281bf304b8960426b745d93116c3c71ebddc0f8c5191e6fab672e584773e1b2326f88bd40c3fe2971bc6dcb34ad0fffa2250f000877aef642317a85d36e584144bfc91083d711e6ec477d4f40f75532cc69b29b9e069b64ff7ee890386e9def76fadd181f4a6bfdd136eb7c0cd03a0df21e61b848b41c917a61f6caa71c92cd26ef53a0414889d6c5126362814a259520ead0ce63717f37859b0144160a14ad807ec28dbe77432d5347363bc95d5e0fbb38ff372dd6db4a597b0a981d4bd7b4b0ce8999b8309027a557d582ea744027088b931a50808902c94b78d5e749beee8aef9aeed5bb5471c3898b4b38289f01ee473d900374892fc154b4be840238519beef9032a3baa53f4170033d567337649e3857278d78585a6b72178a8864816f62bffd245ea7956b77085176c0f4af237eb6af92ddedadbc6db5f872dc6cc0b911c16be4de68aab47a18319f886e9ca108fc3ea9f5f37d64181bcbd93231c7b167f86e1003c469f0d71c1f43d8417a0d26af0f824af630a582375f493290b6d0044ef3c58f679bd412460e1ec6bff44ef9052d43ebf4b08822b446cffde23707e1c58f4b913c9ee2bd1fa682fa1062a1c330ee5953be7c8261e0f913f8f44ee3ca35f527d79bc2aad5723911c421db709bbe24f3d5e00bf9d801343110cc776f3d984583dcf511bb6909d11e36da1b5d7be36354a354802e6f0b9e3dbbbfaa7c8d4bb0b1f554d6f8ad4997fca6b77a4e05c35e2fbdf505416d1f1bb0d24bbe21f88614f5fc1ca8445a4d81a9abacd4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
