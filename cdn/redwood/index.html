<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83dce0b9ba3c0360b683f44cd2643e090eb1c6d3419b389e27cdb4bfb23fc00bd0208b00bb83fbc61462b8af129b5120cb568304dd0050a11c64debd4ac41f26e9db9c8ed8ae53b40edba595b03283efff0f2f61a8e345be30239290ef490ef59a0b0cf2eca883310a4426df42ce2b5a1b24afb9987e4acbef2b4a83ed7397c44f13382c23554e4cddf8a90ac00b6a6295c02a9d8e810ccf3622d1c01150a1adb18e26309449137fc41ca6f92247c16284882301e61b670bd1af461101bb36dc46db482bb88ea8625518f8d176e80853c6a837c69b409c30030ae5c6da8dd3284a83388b24a4735f83fddc80025d87ff6d2d086c21a47f46a218925802e77088a504ae6c931bec458f3bc6301603dc639c519bdbeb3ed8ae0f08fca44afdfd8e586fc37f645db89026c02ce259e217721a8e6d6d96f118a49e9a95cc5e44bdad495fd72f562484aa7bf112d62764f004224e5497cb9c9ceffc492d6980c71f07f8ac645e291ddd3cd9d27ea516a73de1fb6562297ec0e36f04a16caec340fe3d21e3089be0fc8d2048bcfab707e1b2db11160b52b8606a5ca80916e6dea2a4b91050d0a7bf7aa1c238f4d05f6a9660472a7ff66161d947eb50b5c9f2557314ea6c87be10e191a9f6cece6a2af5789964aaadccc2aa49cf697a64e64ccc93c3e3c627e68d18e3f9faecec95f3c8ee5e6fe6a6472c62f4ea59768480d6a49669f720e72c6071ac4a3c46208856282fca9851521df0942dbfc64e6bda0fd5bed57cbc0ffb45121b236729b27d34c5a00e9d14c1aed4eb66541945bc0744772da1377d4bc6a947df28038353358284b5767fc9d07c70dcb83099b5ae0e9569e4a9202e2548f290b89c373a05689e3fa8a166dbf36f024f7683966263834f1ccba607bd4f6d7920ebcd1d533d582f8ac07fb77d9afb5ada31742562a480bc9c08245e46682088c891bcba81a2934d3d7f26e1537abcaf072a2fa8378fd51f3aeb26435dcdcc4eabfa000e7602f3c68982853264cb16a0eb0d7d233e69f72ffd995a8feed0969da42bd7bbe327d84e475f45e70192dfdf345559c530ca8206d98b7134f5c38a8bb2f99f188081b0274a5f4526c86004ddfd9318a35b96ffda3fdf4defda15b2ab1c5dca8b0a0f7dbc6e0cf12df2474cd292d6ef9822c8d10f58defaa99234dfad65a447b7df2794be728635babb90d39faacc8af897a59376ad3f75b067128a47b375c699312d5b6a23b5811683645e981b5119b37d7a7e74de0de8f1e64149dae72b15ee1dbd0dfef6d5946295a89a662bb8fc1293897f639481c551e87abc0f2a33bb70cd9b68b62737336ef1842bf6adf47e5eb9d6033957f3949ba6ba25d16f329eb0543590f64f6393d5adf408a51763977785a6229a471880e38e20c4b2cad0355783e7665934fae9f359ca4c9d22cdce27684aac0a0c18b07abf41d86e0a39aac4175e6d1722b2660d6c2fac00d6a9b038e8aca79c59351bac1052b676bff272558039762239d8e8fe46c3069f1abc74f01272ba3e4985be8d893afbe2ceedc08c57e1774d231cce5af5c4657871a762328a8021c026d14c08faed61a47cc932b14e0420b071a50b80e6597ba844d8f539169b2d520f8c669ed0c216a4ddf5df749225fa8932e631f4e01651599c6701e124aba7740c26eb9b722c4d7cc8ff1dcced4cdf464d0517185b0eae065f8427b056967546e37e4753ade4737753a04b30160e25cb999a358de5f8b21f52baf0bacb37b31b2f50006df2dbfa9bf1a273a155b1b7ceade3bb60eededf724437a240ef2394856d4d98714f0ea6761b10509aa610bf16c584ea9ef2503c50d8fe6681c0fddd428c5dc48e3a996b64badbf25bf105531f31e5f76a0a3bf7872f4bf0683f32ea1c78c5a9a1e02c0fcda2a78cb8e2e4c0dcd8e0712ede94ff32b95afae99d82c1a6ffaebe872a678f65035d66b0168bf3b8491c037ad35aab0a7c3829f7560e595a3ed73db6cf2e53f77ad49a79ca6bbd18a44d1d32e97f2c97bdf517b5e5bef598a6c86cec5835b4d7c38208b2f0498ec3b6f2c3841848a5831f9da5b645fdc89f5ebc43410bdd219cdd167e3e2ade9a4bf5a7497f0d5245d554260e524bf26248f9f10450da9e0490f69fe1159831cf9c07236bf4b17642e79e7c27f7d32d962e76311459d4c5c3f6379065a42b437896c5898bdf35182f9dc53ae1a18c1b3ce6773d9747db43f38b18b5362d994a73d12b553b8a82f4d1886d1d790b003d7b223b2c37db8ac1fcef246e06bdaf8bf85b00711a9caf84db19331a7aa460f9e349cd7e2d4607238310b4db19dcb35aa96073888ede664eb7a30ee73c085fcd11d6ea4a5b082c3b57ad2b873ee98faf309fb96ef60ddd9b5412cdfb999d09cbda46289622cc0fe598b74fddf587ed42a8c18f8d2dc29887f621b7a9b42fd797376dec85e5a19ced7332ee043327fe28321c14829ec21e9f260674769bf0db1c144a9fa25bdd65a07d31a40d0a947a6baecd9e30aeb77cb4095292c5c376227d8a57e20092bb5332647dabd95bae0396a95631bde8e84f5e7f5b55149a6e75d89b6f24ea872647645ef26a093e727753ab6a4d1b60f318f78f48e8b8abd4f24fe452a0a15113ea7bddd08db9b46c59f21c1bb37fe9a8b033df1aa7950a1a450d2f8f3885f419c4fa264187cf1e83e338374a3180f2067c0811ec995f8d0f185522e95b9e1cc689e672c677e658381594957b13746c0e7cf7a0fea85200e6fc397a581574de4677652fa7ca5412ff56d6bce785c986325c154f00b593177ad943042c17bb4d0435b90666b767d90c0895c70e352fcdcc92229ba2de840c587b1c9f8a4c76c4d7a2fce942acd66ce9544d87fb3ef812460005d622bf460e11ee55d49fd6edc5fc46145e2f444a1a980ef0dea47f6060d07da0b50e5aa27bc5f18a2858e10106857580cf36b70a36bf84a955db62ffda9667dd8e17792410678bb03e475bafcc79783052ba994d7da15740934bb01dc3472443dbd419f205c5312492719e85e17ca43362109db67587e1a3eb71c3c3b3943b225e3b0de1d628c142f275c33e91a444bb2c9aecbff587bf757a3f045894c15e2f23db156b27fb269521e0f7515b8885b5399c3001dec7c162ebf06883e779f25b9c8a780cb2e232b7c1335e65e29f618f952cdbda1210d24593edf512d5d31286956d8671b778f15309d54bedeb32656f4ca0beb0274144cfa3810e6ab14e7a6f775c9e291c576f32ac28572c57580d2d38b7cb6c2deb5f3d00eca7f3e5ee3d978ceb3cbead11e7e477e95b8f0ca4436e50f4bde73bc6c68abadea3481c7a0fd0f03ebbbcb3634b5042bcb2b28533e25281207050b1794c1fcd54a242036b36846936686aba5e46bd198fa7e752a369f33ab6cfeaa6f71f1be7aa0f72b4c838c20e26da42d2bcad57357d74100c853eabf30da171e5ded4966c9dca049897f8e98d8d1b787c3d699bb976f37d7f5681f58492ed37e3f2d340dffac78c29a45500c3d70d01e95e14ad2494361de5a292ad7eacf86cfab98a825e93be9a2ed5859c455de70cb78d083e468fbf70b7aa422a929188c8416c2293ce338489dbb8019f1b88360c930688b337f600d14315196ce5d0438491386b2222eadde6f2eceb35462965e19b1a9355c8c6dcf0479d335a4621352dda3ba458d183dea5babbf184243759ab2847627623641a560161978da6b86673dbc812d22040ab60b8bb069329a69d18d5128ac29325777ac3f65633d584dda3e28ba11b76f304eba48947c1acb82236c4f0b811147032ec86d47091a4c5dcd73e8a74dfb52a966a2dea195efde9dbbff321d311e173f1566088fbfa0cbf9fda058252c1ed20cf9256edeb42fe70ae7c10454646a3bab5621dd2d228eba3833bde229a30abbce2d2a0b63e4a5470a78f7df3c870114562cba3b4358f6bb2311f7807525140cd4b20c298a4b24fb91b39d13ffe05db6cd6b07a4026d5064cc8e1ab030c52f61fadd396fd167acbf07983d41c3c553bef9e968c4f5b346d899ec02bdcdaaebe393d5ed32a5f04a1efef656c00671f4036ebdd88761b3303e17aa0887b611701f05ef43c72c54a988f1ddb6243c96c222cd9559a71c8c6d20cdbdba71fd129480bcf936c382103d9f7ce090c00073090a7ca39093471d8cba23eac915dfcc9a6a33f71582fc54ec627cef8cd317ebb9536ea3152f999cbf2ff5104a4fbf941744e389803fcc2a588f1795cccc4f373b25f791a924e342a293e97cb5ce5ca4b0b3eafdefa3889348472a8350f157c684bad4965b69e465564ad303ef1ea86e6d9f428ff122f675d835af44dc3e36f59d1c23c4c39e3fa790231ce9007c21ba5e9104c067f00931acef412b556d9412263ce1cc5e78563a0c1f1d28935cf593d8813be10c9df4804cc7d5880b57162ace66669f8e05625091347a2ab2d2fd8f632937607f2ee65461c7298c0bed9aec4098475c8781d6663f92200dbe42bb61bd131e274c1a2046d9a2b0988b047e75df48f207ee21ff11dc50a581eb8c2878cb06241b625196f52bc639eaf194d6c71dff58fac67f2a5405ca5f446265b90452c56cae3c39b13ae9d60f34852b2f987ad4b10538e4ac341bcb216ef47b9507f3fba1c7fecb7489529a58b8bd0571171a67e15658efe343daf2f7cf0dd0db7bf01292f803bc7300d68f02de0688e6101ab73f4c4d591c9d09df149acda8877974e41aabc6636f053dcdf0a8ce36265dfff6af77bdc38ab7bc602268c20b8c359e496d5355c93572f3d544f420d08e326964bd3188d994b0342ff39af6e23c336f70c95b8f2e36d26894e02edaa3e2e9a3bca9aa028b88a5bbee048860894fb6f4c714a51af7209ed35551c60847ec10690bb2549aea6cb89b1924e0922821f1b39e9852774f43475365e90fc7c25a9e14bec920ef808d1c0650b8ce458948a22fe5f0fa3bfc74e78fc1898bb19ce9ecc062c9c2c3f061fbf4293966288179f310dc8fd26647fe390de1889ca036923a0ee2ede27a6cb6f640600858d54aa0d966c8d79776b361b84971f91108893ef370dd9970bbb5fcfb065c067abe01f492d0d395168dcb2b144bcec8adeea90ee816efa5f700b0446fa63edd246cc6f629298d046de54c4b1ddb64364225ab1f004cd857f87ceba9c0746c481944cf71ce0409847dd05f22b053b859f90b0a2194e0a42746cc5f0c20249bc654d5684b490c2d316906f17321e081349f32c89dca04a49194a1958d84772f15855e3b0b3301b24612456aab58de31f160b38bdb187d1ec548db08cea2073058070a924f1c4b0d1f68c0b72c166cc9765671c63c7b185abe13a1d91ee81bb9c9fe894fa23af76f1f304cc5f02697924d38fbb2c13d6144e37c5a42672ba9df611c2708dfb0cb7ed7db2e4409c9db64ac7384bedc9f2035720139f84013023a366793c7d6fa7fa6152aaf942388c55bd01c3da90d1bbb88b33f8291c8a89e2c785222a11890d36bbfc59278ce571ffaa5ed3f152a3039d133d684a265dee0d2be0f71fd2d453591eed71cc8fcab1531f5b6ac83c46d0c422ba8ce9aa7cf6f134c9ec55ae201c60fe688fd0bfa7bd15e9d0be9a282fe8deac611839aa39e699fdcc9e09d7766fc0584d4262c36ee7c0359af9484e3d60fe31d3d0bb37c11395e443f4bdbd1ada9113202d1808ba81e0d33e7a1faf77898a564efd72f7cf66d9646621dc467450dc999d22f8d5239079208fa80157f01d3159cb31bc5866203e4a00ad6a37e31309e3ab457a135553e721b213896036c24bfd32d3024ea651d366274ce9b3040d8c1efe401d65a5fa054b3c661aa1a871eed0803147e5554ca278f9668798c0bf79d1ff07219bbe0856f1e0b44a14bbc92987ea30a0ca7973781e8e97fe80ffe182d8277c2e5f4c0b9ac0a665e6d4b65f21acb1781c08ff8046a96d577c04e98729b6b8c8f7d1f4c3cd2d5b5f7aac960076c66147f26235adba415138fd14b9a5bc42788d47bc080d42ac02cd241c3ce35e8909fb75c81c48a12784402d74792cf9625a427a841ec4b0f1c273daff453e603e0d7d0c62d4703b8f504fa387ac93a6589476d465a60f3146f1050234c5f29237132fa23ff85325f13e3eab8e01c61d54aa199cd429571139d4fa8b8181b5bc6cc75012212e001861780c437fdbbbba9670ddb8150dec0ad7a491d55e0fe125a97a1f757a81bf6844b5c966166ae50563b362bebf00573f8c036fef870cb20394e896801f113ebde847ab80e7d3f81a5586238a37adeb876e335b5e2f4d71de8ca7cc7f4cc4d0d41eb9d9604f93a06a06d3e23b068e123975931862bba658d5e11c68a2ed4c7e418dddb782f242a5dcc38cdc0d40843d1279edbfcde78590dc03026dea07d0b08c19c2ae4778d7914d0083ea315e84a6d06f876e477d2209f80f44a8f24de29e6347942379c85c614d5d449cf7a0c414497c4d9db699dd3ae13071a418d8f1bd58ec8dafa05ceb1502d869f725df547aeced273525f197d3498136f2823f9bd07d59ce70dd2665d269078b1186345dfcd3605a0041186c5c2568fab105ec53f5f8c3385c4dabcbba01f0fd74ac6aebdebe08fa652cc37a53517ce759a8a077b05537a4d8418332b02c7bcb95a616e20deaef258a3160b795ae32aea546315be4e957317342d548086d172bfd46d04ee0ed5cf5f7b20daad286b227de1268296c2471dffc1c53d83ac2a14ca684ab7731d55fd2767634dd5c6b8c3b96eda4623b8a8c215a371ba16331f2b956f58c5271c0db5b1950383ed11aca1fb3cdee05dcd4071d27a6aa47efc5db6a3c01a81d71ed57d0d30ed714b3af274a759141f7ba31cc0c73c453fd9b7ad8c6fbd18155ba6bfbdc8e1314abf4d136d1f9f9e9968b8020e0c3a4ed49eaab7087cdd5ca969649897efd2427ec7fa8b72f193d430800755dc280fedd379d46f620912f388fc13a6149f5ca24e6c26cbd76e61b132555b29c44a0933e8e92a3caa3cf9935e7e567e2c8a8918949f89cd80ee8514237e81e6fbb111b9b6dabaa42c81499405b834eadd82778a87ba046bd07be2afe57dffe3712056377c29b8f2fc7eb2c1a50862b92c2d6c400df6386d0c189fca9360e91253b960eb87723649ed2ef1fc4aaa9cec4cb63992efe992915d4cde9204abb7706dc741c7fab34e099112ec8cfa746a2cf5427d0897e65760da08f39d446e4ddd06b0e10c02fb53100c742a48c98b0c3e5f290a7678376fb0b14ae8bd5708482628f34b38a3a5286a074021476036cfe23fc5a6a95d04fc4f34239760b150e19011b0b447967319324edcecc036b86a23737fd692bc5f7a7a49e878c6faa258109431b903e1e634086e8caaa29ebfba345b5d61fc8ee4de051b4079401d627f69ef9b50f23bda39c9eb80b6ad8cab35ea9999ba8e1c4d27b008e625594c6763da13f3619e08ac2c2496b5c7cbf14b0aaab0122af1ea84ae63e94bc56318a27b9997132ea8d5a1cce815681cce207da0601391db6b7e37d31327908b26139b2cf4ff2dd4202d034ba35cd679e3a429144a6c25e2468911c3f0202c4ef12720d94cf579cb9356829acf6382fd2f96c9789ffd9941db3a0bc7bc789cd98d61825d8f55adc62494e9e5fbe3b3ac4b29d9fc3817118776c32f729efba4a0482608558ff9cbf3ea45ffd1e73c10cb04c06b203b7013d06c46f18f47cecbca7b95ad577fa0d5810a08a7907ca32381e227d843fd167eda46e02a0151ba0a79fcf5568d7c125e00135fb7b982e72e77d149c71d564948696e37da1ed8bed24d8ef1ef7a4e2c168bd02fa47da066137672a4e1c7a03340e2ce0d1562174b3753f6b642f807cfe31e6a27d74a59cb4a8f46645ea3dd22e1502cab824287db887df3d0549309aab6f1c27cd1cd36a7318a61c2a39360ca3b1927577e4c689d6bb26e972255033b9d631863c3b9760af56015daf4605b6b1781cf167d6b779930b8b2eefe9e6bd626919cae7c5a76e8d7eb555a8c37c86cac0079023d3c3ed73c1856b953bd54ca25f79c8e51e089537716b805a9033f485d0f5d7a770d50d30003ba4e411615fd8369efbb97ea9354545e2729a6256e824abd4ee694d597b63376147be9e2423573018fceb9f72afd8bda6c43446a130e522bdd2e1d9284023b2a07bfbd998ae67bf6fc48d5fa836c17d4a9c0b3b0880e9f9875133be899d98c29cddcf973b07bd061a1ff04cf06f2cd0c1e2e89ca3194245e36a00dc05cf3844047e447690066d050640f34be0d0f4f3c8f690ea06e515c3d26751c51a0da230082fbb0e59f9d872a63628bd2244d9bc89d674339a513b313eabf419db108a1042f7ef27c094d739544ab3b9b554ea277dccaaa5936cc52d4217544bae3568407ef73f6eb985c4fd8818e3999e9e8c4660a34f3f5bdf9854756964e197253d7cbeab51cfd1f5cdea6e6483b2d9a0bbc765212dabc127c07a5e7301fd776a70aa8e16ccd35a691914b4f31ba34755bd9c551bef2083c3e2aca85e51b4e53dfa8b1421ea6321f616bc906fd8fb9f0f67f810958571afb245303b0cc5aa0ae46f1616192f61dcb8467050ce89ba8541678ef2bbb35ae0dfefb7437ef7a317f54ff869a095156717c4a5846ea49f1856e8ecffd64663704e0f09c85b89a27a091bb026633ccd3d82b262e8e6715189d5d4b034cbec26b9f069fa1150846b7e12cdcb2ce5946c98758067b3a828e3d24383b0e67d231556de4d3973298bba4480afb0746b706b7f8b944a4612e8ee2ab99c033c5118daf14ed90b29f0bd9456dfafb98b4b53d97d09a3304c8944328bd729eeb99853a030d622ff97e99b9114bdf284c5ff45d06086278b3aa29da0ac0709682cb4171547e07aff9587eded3b5faeb76a90b8bc1d3d3747d379846d0cd11cf5a4a8d9edc0fbcc6f9833100afc4be7eead08c1f347f87358aa8c217f47e81bd68e794f4d21118e13a69b70d552828d40f2f72e242c9fa99bb830934cf6daaa0de3b16206b7a049cb777295272c472f9ba860d5861f63b0e72727e9984551284530349e9fa3a6c45bc362f7a80dc2fe47c480ddf19eaa831d0caae0a2f9d3edaedbc8b75100cc732b2d98c2491ae8733e183412fa466daad1b01c902746f017ee0d35935d0e55bb396f5d61e3eb509754db8e7465afb4b2f2410cb0dfe64539b4d6be5c37c9601958e46a3b48e6bd277557778605056e13156a8131dbbf1bfd61d5601f316550f1c6a31f9480fbe1b38bac17d8549b867302eb256fa79a89e63f68ab30127505e1dc171000baba89b33a11ec02c65e3c9cefd17f70c375c6c0a36147f716a41c42c46ff8b1e1779febdc93768a36ff416862d40bc2e797971dc9e27cbb9d055395c34045ffe7e2c051313c7a35552ce8aa7703c3034e3b4ba07213a1a07bc89685aae1e447c5203da93bce220962eb46a51eacd46bb8166e189335c860ee66db0f1b7dfc4fdb44969c5d61a167bf44ae2e99933ac938b51527985c6eaa90e8bb281add77de721da1c59f4363a14f6e1ee04f0f3d5ce084d547b9c02f4dbca7975a7a6d94e643f2c92d048f0f2fc9327525b72016f1920bda572768d5cb83426881767a4fa3469784723a5613ec1f5c6b7ff77efbdaa7c4a35a876db6a22dd1094cb2bc34af988c0690af6eae68c197000665ef6cbbae0c713afd3d7d996ddc40025f0d20f6fadbee05a41e6b45401c4328b20ca571bdb5981a1a3f69cf441a8672fe5809571854869e0b17728ebed279125200443536fa58dbaea66698f012ea006cb3cc0b19b0cf4fe022a2d76e4f37e4758635ea737e195db34093681acc25ed2b132e5110f86fba91ccde6d31731dcd840180b17b013373f3eed1cc241ee355c29af03db56ea7d6be5a844bca6854e3288e17f4912bfad8dcaeedee51cfc44e7a3bdc96b4ac027ddccfe96ab11cc5a4c024b7193ac6bdb3c98c648b7750bec0796c43b6e612a8cb129c2c07626f1cc13ef315b2b196f9ff97e5590288d06b8e99a4cb16c057307dc9c4ab9cdab1fc881479c0764d2e28cb80e3151ece7ba04cdde980139e287623bd90e07272604776f33b656b3ca49b0bdc7c78831e6e359794706d6325846f7262f8cd5dc876810cc7723d7b81c9e5ea6abdaacc39d35676219ebd5cc8d3e31f656967344d8f712d237002907ad177889f5b43fff4d0a1d4d7785b836c5707565fb2693beb4eea34ef3b1e14d33afca788cb7ec7e7d49b859078ff3b20ec6b009e89de3938817a46c5065fa56eaba06871014006328ffa6c27ec539bd08af75f9755e42bf3c60bd4d5d7fb34cd167f241dbb5943c23a6e0fa48a8d6069a0d3e238fa76f17607400dd635405043e32c82f866c12e6adbe7fc56e3c1ab401c2a89d29cfb5f1f860f018ea5209d259c692a3a28a33d2083416503701edeb4d63f7de41a9c3ce41ab9406ce8760cbd3b901bb12f08e043aa09bca5d3e9e0a9a65dd42afb0a4ce71ab723db258ffa645ace14bef2cd7a1f60b577fe1a785c39251cafe521e97bb2ca5fc0795f221bf001dcf6558bdf6e05c5239b89347344748ff77c1c0b52e1551069410f5b82d6b2703be50fd51d50155bee0114896c8158a0ae8e9b37708bfe486d8b7d993373007cc4f808c8ecea32017672108b53be9d3aa6b789585700defbaefb43331139cd607724c368a91b2f424ade72fe241b0760037432ec3eede1ac8c5401828d94c8411f8d0ea6edfc883963ad0f4f5bdc9be648991c3085a1a2b9df2af0927a0dd7929413e42eeb7bd6265b307e7a3f966030db16eacb5c3c9b651038d468c7333801d4d1b501e506a5e61363a7f9483c5efa167731bc4f47782ba7d5f0364c6962db09e472b456e0f3670a76ac4dab87d0841c1aeae4a053640d4e3ccb7fea1baf52ce0afccd44a177328383d56aff26b0d7d81cad2c629e68826758cb91793c65882dbe4c495c40a0782507c8d3465b55956619c9bc37d1ec522753327203873745a95052e00dcb02cfc4d413071b01844ffc613d72ee7964cb1423b5a4fdf3951b9986a82b98ecf3b73041b2ce0d178987bac1a06ea6b7bf522ce2bad746ba285962271b391d0072f77572e1a3c5aaab7f11d1729da92ad339b18b822ea80db46c760d1dc84319aab0d38a8a117f2e9bf5fd5ea645e3c872fea23a0775f54d2fc6e1318dfd00634457548d1f6f5496972dd843ccd7c3289cf0757b37ceb630855b04381d99762f55565d6ef8769de0a9246978bdd82bedbe5269ae2e2cb9f26308995fa702c39d7a88c260ec7805baf2b045bff3fd20f6b0e6ac3545004b298ae1b947c2bcce6ffc4fdb50fe77bbec30e01b7628e893b3aa56615e77ab085d221ffa5108c552425911a4f50b58cc42bce3d55eb45a885412113fc1b5de7ac061c70819b957a5d71056574c146afae3332e3ff889715767c584a5f12c7d40459c74eaf579ad17c4dba7544d4c18bb2ecf73a5f66ef567aa0efc865b2341d643732039fa49c27ddda394f08dbe1492b845c4f3eba6a0ea74fbb524f19c8ad1ae4b8518b7240d1a697b53ead1fe51bcb0897741f81c3452ce080ff43b9f2531f3aecd107fe4114f917b0bcbf1420eea4200af473deec154c9f08b3c7176a8f7b1c7ff228f5eb68be8cf6709917325ae9b6116edc76a7e79288f2bd7e0813ff804cb1e9706117dbde6a3f5e3476af777479ff1657180850f9dfd7e61700be3bdecf28cb55f78881248f946df4126757345ad5532c9b405714792dc5984b0dba3f45d2cacb8d98889ba3261dc7838f60ba10da1000c900b4102ceeb10ce62f23bfbbad2ab8ade550af25359d0396beea4f6b6cc8b6c546d28359a4a8fdae7367eda82d4c6ca7f62996474ae16c74f6bd2a8c47ca99b4a3e43cf5766ba156d5135c4f8bece0b984f8dd9361b0837ee592ff339ed23b390a2af9623c40c99989ba3b33b0a965b773e6f3866d6e76bceb990aca515ed10b790ef6dc7d0f2a59835fdf5cfb278f40f64648614bfb901c968dcd5407e050fd6be61883c6c335293f7dfe7d1754adc0f30d24b453b5b01e146dfffc6d79543dc808744dd647c4e3da24fb0cc082670f4375c12b0f5d302fc0544001cede306d058661cde5c2067dd62fc7d636e9efebeccaa209725cefc1693d11d81ce1dbd102ea6464c264b4baf5ac779b0f5bb07d7b6895c022ec4654ef63c8158d67fa947c13779f4b5b1b40aa315821caf4228b51cc6c7b294a990dff3b33f4cfc02f77f6db76fd8f9db26b596e58f799d1960569a0f5f9d66d54dc991181a792865251d7f6edc8fa5d4c8f74c75be0385895e37b18d5d54b1825e2528563df0bc4b29cfa5bd55e439d22db70e4fe6a4e8b7f7c0658b29cf30123570c799a33505df31072f6e2a1ae2e8d9885e01a70efa9c0ca8d634380749c97ce51b2733f06f2db06a05626083cec7f3e310cb204da1c24d8e186831fb4f29e4359a743c9e16a7055b9d61a0d50dd29801bdc7a2c40d04b197614536a9319182fda9130b05e1f5ea1d146fa9c7d45eda1fb0da25a470743a3eb49cf8632874b473240feab4ba6604f46ec6a66424fdfc3bdb85fc00975d8d01ed8251311304db5c2ca194e4a870487e93e14dde021812e19b83281249f841416871943aad08426db96f3582e9d2502cb14768570286af076a83887c20881e32f7b6d25b374a1cfbe363fd70db30822326395224944c0981a2eb514e552e0b5c45ff4cb0639a494ece4bafd8d10caf47e6b60d207ec7c32b5cf132541e70159a8609f63e514437ffa4bee64ec3322c89f2367e2526d7538a9c1e601b50c240173d5c8b42f59780f943c2a9c89e946628231b44d34d44cdd29c9c056f3fcdaa84e3e3bc1fd45114e7f13a8e89e84cd926d4a5e02783ee9c5dab829f42edaf2236e1e0f8732eb022ffd49d2c6e14319cdb18228d55bdcd205b405f25237c67ba9956c66b4b93b4560710ea36747df956f6db19321d24a1641c6b4195ae64f9cb6a554db4e539a4a0f7a04bf1f2b9f201d9483a11a08d53bfe8372d419179eea4e956e41c9cf0970b3602f25c4784ea62b4a67efaa66ef65bdae516e0b584215a81c2d38dda984253792b943c399cd4cc3969444af5828474d64ff1b213f394b5e0654788d2ed1d3ffa9314990a70a9c453eaf4863984ee1f1ee770ca50d0a45b7005085c4c96e309e19888f03caf7a0cd52a9a2c84ce90b67f584b29f39e9a446f839b95e536ab0a79ee10e7418073cbe7d2e724948f207820a7bdb88661dae53a7dcd4648f465efecb4b1cc11ad56886732a69cab4528f3072a3c420953fa8613a3f5af2492b3782c15da02b98002c76798910e9034c15e43abd58e05fa617e52966500c6d313f45fe1e1ef0d642e13502422d26710e7d04c2792b5d0a6f99a4976dad8af4804cccfa050889c932f66e593ba943193f1592060a4c5f27d42c9c9296d01bceefb5e6682f5cb7d76890b225f7c297bd9fca44d6531d79ce4ce83e52cd252c2d1592f4eba2199c0b4a80692404612c9fbee06225900e34c4b32c5f15bdbe1babb6ce8bd7c8be141b3fdb65046f12cf34d09c1628972266460e71e9b7be36d126da5bdee39f80b86dd94cfe9f607f732b10a319730bb0c54b0b86a4d279b0a5d053d20008fe9d451028172f4ca22c4e9aa51619d2656bef3d94b048f3b62774f171be31ecedd3eea91b15b5f60ffd4a6c7c6ed1bf1a1521dacd2fcfff6f5d1be922f6696533cc9cae06de225bcb8ad6da3fc795e7172f30f663c72124d6253f24e4a27404a4bf4c70c19e59e33523f1a40e7300830e1c7c339d9da50fc568a727a97f2ed0691499facb71f18e1a987c06063c99d5dc127973f6893d81eeb23064b3f3bd6fb74982dacab5969f0cf0d0dbc178a697ca6aa844520bdf967d35cdefe1ab8b1057995787359993bdb3f608e0fe73600ac282308b7a283695c7414388c01a642f6970ddea8b89cdb5aeeabf8a2be488f876e7f050d3ae123028f7a0324f0aec60e5600eaf3d7aa01cd86990d120ebc2148f399184d32c7e850ce3adf3226376e3c0d97218d85b02f827126e7e1490b32bf0049d17d95434c5b11f35d0fff3812e5dae3aef5420037e32e6a79f9a11ae26497c3b310649c405035159e51aac55e6a9f5ef275da02ceaa24c0ea5ef36808b7c99ebda39f482cf3b6c04aebace24d9071297db6c0c8cd055b0802032544d1674b10fb253aca9f4fb22fc0fca79e897b0556021ee5b9b60ee85267cd728cbb6f6667de8ef92a3aee33117f68fe498dd1be9a4e49186e51260051e95d2fea86dff989bca372a1ee3e7c29dadb5c0b8125832b422321490474b61df509bdcdbda3d9b9180fd8aed0733ef89d7e70d5460f07720e6ae09e0e76df7baf41a008caf59bcea171e0f8d862562ebe516a1e8c6abcfcd5024b3309879923bf30254b1f2c492f16511b649925ae4618e6fd424b61cc9e70a815fbc1e486b811743a22f092e549c75c2a97637fbc9cae83ed4b6e5fe955d70740a7b4b515ee9cff57b394471ddf2e42f2a1d57fa6e3aff33e44c3cc3a62db7b98b3d2bfd03026f1e2397ddbbdd691cfb571680136c35b1e4ba61ed127b520dc882a2655732ad21c102a7f2e9498e122875eaad124cabac1697563cefe40127feb8056ad0202987fcb2287919884c1289dd41bde3800e11883dbf053af2c1910cf1ee4bb2bcf90504f6dcd82279df2d13449023038a0a92581e0eaf152351854e6b124156e33d7e646bd1e121f97955cfd123b845f76f6e4a0c40762a56f07ce93c417df9e424ad17058c09835ea591667d12b7927aa4a2a1bff77afc0455c81ffff638b6f82920bb7676a122d4215a3013d0c1a7503b61527280549725855aa64536e42ac8b007e036e813378c5245c0aba7581ae83fb29636dc53859046396eeef1659b6f91ae6267464e31046344c230d5e773c32208673885bd301ffa6d5af03701cb4f890bad0ee0d6d3bcd37db927903fe396325fdea28d28aac7a349a7b43aa258d611fd412f5ac428faf8683a78771de093249fea9c6085a06ad9c1df09df99d7b22da3537ae3d9553b93c264e330ab8bf011da9fe6101d6328884ac11d82b45db0ffd8ac80351215c32cacdf8f27bf6d6e1f1eb9ff5bbb1421b010727261f696d06207d7b3442a7f36eba86b54db8563fc7c059500ed7b632614950436c9cb9c3d286f719c1813172df34fdc93b8e4f5aa4b6522a4c460e84c8dcf3fed22d640d63521bef9353b3c4048bfe55c592b59152d737c4f994086e941f2a36ab1acadfb6f8a1c76c5daddb4560704d3a41e9898f6174f3734332ea7be4efde82384309e8e7eaefb4da2afc7f08cefdaa908409eb8c05a094c0aa05a85018878bc8d4c0d5593d52577227243f2a3138c2dc78453b0d3b0d6d1ca220b5c1e83a083f458dfe79615ec76ef78aadf4b7cf4b9128dd41ff4339a082ae77ee4ab46d67000e5449d80a0c0521ab44c288a306251ca05900218583a8405100956702c045c19160d98910fe427d6ef860f0e1360becce86aa11f1feff75dc4eb4f6c761d1bba7b7a9471da158e324149db7577bb9418f8d199d54c3d3d1d89435e4a04af3406b81d824825b93ba009319f077854c1b7f863769dbdc7808b7bb5fd19f60aaba37a83da9861d4f8162ac961e25dfd5be4da9528f4d04e029a065521c8017cbd3726fa05c67a21a839ba00e4cf7267dfd63b14f622889766453a4360fc6929ad3d80ddc2a7ac14e36fc29a1fee56265b9ed161a5cee273f0d9fd6cee8436ce9d35828e8d4d42e8c3c2959fef35873ca4756a9578818b45691a6f6e535d716333ba1780abae401a33b50247c8f5a593fea3df06e24daaee8a515fa1d42460a9b32ba3fb8edce57e7ef5300bc5a501c7b63551195513f7228ecf3727dda414bb745b84a82fabe058fe2b9bf7b016556c41b02d3b45dbc7c722c0c5837e9479716f6a0332e665ae128eaef043d3b5bc876294774f6be1619f13a440f6aa815b624f025aa3f582885dc7f7e16a6b4c17cadd9cd6d2b6008d0c9fc9fa53342de44ee8af8dbceba1884a0f8279d6d8c90123dae2d77e5556326c3a096a1c5b2634752b6361b132a4d63c102e19d551a697dc50dc19f4602aafaac7d0357700a04ec5e66b46bc8c7ce77a88d074a978549e3dd92f0ef34e654e2acf4d6a88daf953d089e5bb7fc5675bf15d2de891cce323d4d0bb3dfaa58b2e97021c985733371bf852e0a9ed01a2f9d95579f4bdb9e92cd6b91dc734e7e06ecf0c250acbc671c07e40bd9d6bb6dde41dd4256ca29a18c78e358ccb84f881708d572532eed301ede58c62ebafc07b6976b8ffabebd9fe901e6dac7c36176055a669e84290697c662f49a6c6cf9a6c4ea89bc1637a5300f2fa7918b545cdd8318b78b7b4b01f22f2a39a8c0d5637565abe3f526eb70e297ab18c0ce00dc36da0399ac83806a248a0f177aa301a27c0929ad275d5c8036adbc23b0abd4cfc9d0a66bea1f7d0769976a5ea3355c5b98f1625bfd1cf70a2eb38557d6bdf121e43ffddd5b53cd5f0dcbe3034c399684c2f72df512253461287d3c8799cecc517852cb400fd95f0ec614a8c21458ab3c00f7195d81123821f45a73d3a4182778537367b85cc7d391be235878240022812b4c42973f2b142065acf90e557e2bb4f90140c091c829fd774bf4e7724ef17346f9d49e1b927dcd46d5e96b535432692df297559c5f93440aa92305cd9bf91aa607162272db194db6cabce9389c3cdc05ec2dc9462b94b34c65ae7d8ea552a212c5030a538901c54d5e22318315951b5141643d705e1ff8fd5811793b4c28f4ad0ef2dafc6456ce859885f03cb8b04df55c023b6135ba3339e7fce8e4140294f90d177f06e0846ec995be46e744717c019442971a3ff09ec52329fc83f54812b6c44513038fa91ef5cf8aaf37c9a31a03f831a3ccbb6bfb027ec5b15fe0e513c15151434b306e805ab09ea1508d50674f416af19590b2fd3dc5efd76ace1f2651bdda4c48d9c42f58910af7f4947929817ff1965a17e16e451fc99724f38f7a46889d469485bf7a4e200a3412bb0ecdee4c9a02acba8a8ffe668ec043eb31025e1dc08fb81115278f851eb4c80b6d6b5831313d6865d53e986554804b943f49ad6d59e6ac053f1b4fa8ae403c9115509b01b403db0035dec0278594d4839bf0d049aff338aa4a3a95a9af129c4fd1948c1d80edf2aca273bfa7d2d1211b0c164796a9277e4be572300663f17b3a6b21daaca90ca718f7caea9aaa86cafebb3090966fc3212c669216f7feead093f596bdf730068d90abbadb1c9507f4f3906b54d7936e328548a077dc7c9cccf20a9df366cbd0221a7d752cdbf64034b2d9dda873468d9ae8af214649f9c2228fedc0dbcb8863e0a9a45fd40501b704e15ad4647f833131b72212d4b3ade7b72ca3a26e05f28c8bc763c897e73245bebaa00363a6f7a89fc30c67e9ff5926e051c78ac923340de4c3dd9b48ea7833b3838c5a793c9c414301249ff2252f7426d9ef013478440532af3a0c8f25a2a6c85442ed39150e699247163f9f4a92d1b5792bde7e52c8e4625279534e14043b60cd8b2f94dd03e29f66c02c9d474ac7d6976ae8a8bb3b3a093be1beee71286c61faa3173a9c39b1373a3f2dbd4add08567d4cdcc6594d620790dc9b4476891a42919cfbcef5168651f605171b98e09126c2f91447caf1aa48c7c5f52f95499f96f1d1d0ce254110f6848ef390fb21a027a8f7b8c970ed2395eb587af636e4d32a1c64c457b9475641e6d98ec8f104d7d0d20e06fc627d490513ba6936f6884357c6b197d92340ef3289d01f3a0ca2463befde31a44eae01d01eaad5fc4d4a0ba7f15a7696818b19a9232ff910f807fa04ef32777537b949938f96d0a3c4a9496547f62c0cc236120dc71e168ea63378e5ffc23e26a794f108a7ab03bab7bb5783969d76bf338d2d9771a860ddbeaaf2ef5c598ce7e62ad33c2cfbc97b91f137bb3076b1ad9ea4eb352fbbe2f4c0eb35fd5edc5421f8936fae81f8b021a3c4049a7860","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
