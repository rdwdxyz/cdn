<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f26a10a34bd50fb7e5704504c737271478097c2b30cc33d4e9522de0bf6add8f2784094002fdd252626021aa872b3845961e781eedc41b8806a3d582378b979d6a73687ea3865b2fe4210fb0ac5892276f7757db0cf24e8f1116a8b7b4b16944b2d1c0fbf9f24d118ace7eef70f3026a34463d1cdde6bc8f4faea7142ec429c9390a69d09d35bbe1dca554406f436343344d4db964543b49dc3c2ce9a3467f19b031b08202c328176f14564a4e0619e699696366b64bf8a41009d65aa0f0a8bd696a29fc6eadc3dc022f17ca5a53644491ea066ce955a463e830e2d8462797dc3973773caba9b2c79c4504caa91f4a2eef2dd852665d5498d140cc251481ed23f8c4c26e4ed0f6b718020815dc39eee4d7f306d8fc055294a9183b5c7495beb5c1ba76d84aedfc774407509cd608ef55328af5d72371229f640325d6798ffe64021302bda135ceec1057051b73acbb111816cb2af79850cedbf690dcdf15c8b313677b618f94dcb171682f47757a276e68524b170d3508996129ed15a8aff26a65b6935dd62b6ec2950b6e1a038aba72258e9562b2fac162687c34449fc60972f2cec48aa34ba5a87f7a429f52f20775bf8fd8bb55bed88d49cefced1e93c4e87ee5aa866ebde508ead3461bd41c1923040ebdf5317a05f0e4d0ea38cfdca91505799e422745370153587709babb8089fd59dc5e077ab2efc622a02af7b2c25ffc05ac52d0b6a3c23b4f095bcab22ba0b04848c817c7504e65322c6d7c5f477599006a59280becda5add25fcdcd11388f67e6706f0d2a80ada1932d735dcdd773b6c7d9368f829bf20b0f7a4bb15ae7f4528f6e72f12a98b1f54b08c85b8bab29e8575d35d76770cb70d770b43f6053c3c8abfa5b137b1b87ad40a160d285d0793467557713effde54e59761c2080171f56304b350be9800d1e4904e00ba5a6d53069d0b9f88d6fde4efdb971e90d187c273dd639b8e79ceabf212490fda33aecb5aca1cda55a5d12e85cb9f228874e22de31cfac17e1f83f8a9d3f7f22813d2d7ca368fa6f276865e9e87a4a75039ee04e9b422c3b8965941a0c47e6aed36c9fd5dd31342ba06e6d86951903b9f322ab8b6ea97e7ac9a2d377c0a97c4110f16cb6a488269219a11f23bf53c5aaae753d275598f82fc23cc34e629ad1b7bfc3b4ef08a14f5eedad0035b34936856ff38b5f3a82cdbf9e2e8f3f31bcff2b0c3b8a56d82c45d49807affec2fb58dd6ebfae39b8a0da9078646e4ab6266f59ecac199825210f23657b42d5bb3ebf3293b80bc875d357033c561bd863282a2e217003e1972e7d70d7a8a28cfb0f8fd3e4a6610fdaf0e8614f451b4c9415a06151797045f80b5b335ebb8f1507b218e1e134d91f260e84106fa1f873b3f0255261bfe7cb90c80e2413ebd4e8d63b4034327d2613284f3c9ae2ac6ddc3cc39db8b5f7edc0482212685ff42b1e739dd617ec9ebf63d14c7cd32045cbba7b97730b37c649742c45b94a4b60c3d8171092910a5567cdea930a1a14f0e1bdaffd11ee4bb5d77a962156957b62054f5a369bf7fd81c5daa831907da402f388cd6a5a9cba09565674e52f3464d7acddbc6baacecdc3c1c78ebe5a339a57be8e80c12687b15bd9ec597bc35bc9e598522d49ecf497a2e9faf97fd42eadf723c88f92b62fd1210044fb3bfc8f9423c5a66c7ab6692b6cf8d2e1b367f4f23052ddc5eb7c50d1065c7d875b9902970b35159c6dd40ec8db739f44f72a5faa06ce921644925b85c4dc0d12c8cd13ba5fdbc51bbc0be79db1393ff3a51483e448a1481e01115baaaffe8a2f4f6da2436e747de30a133905d1f91cd1c37f79dba4ab1d7ef58f3df43249c74307c263651d73631bba1242e75581e25728c1f3d4f8bc9a1715d985f6b476a3439c3146914f63d264ac04d8dd76d874290f636260d8b2b0ecb49b1775605ebfa55d840012d554138e4ea17ea4b5b7431e184889f31fac85679ff3568a592c5c16055c7183f6fa6b6c8335efec3da438cf483b1329e5c928f7cc16f2d4f0b77b0b31f65b7d05d862f9d8c7a8e4f169949ebe3ac26085a0e619872d9023ee7f486839bd93217dec88b3be244eb9a5375a2c4d26b9d4127dcaf9ae0b92918f552df64dc9112b442079b5662498fd5cb06198f766150fd7b74fb423089731937251297a85326b6eeaf6b8c10630eb1bdce070cd235bb883ac9f9f082229f5b93e4881937b2ef9ceb85602bcc368e60d1831e837c295847c39ee2224f6b8ce3f22a6115557373b5c0399a0ca39b743178342d651a7a544d587d1d108f814626f857d378794458d31b39fff8c3bd1cdf04987cd6b36360e524e3ca261d66d9e4125af89c47225f2b9d306766dbdf1abaf4df5aed2532557c804fdfbdaa0394fe084c288dcca21c3dcec0957fa41ff3ac2476559b1c2d774926f806830d52a2e61e8860510663b72d4a3f0e5509a2dcbe6c657d020a6de77c6c184a934ad88aac6a0e50eb3a56da60c5e2d91b3c46fa0955f67a4b88bbd7d1a5f0d63378106ce721b1bf66c56acd71a3681d45a358581148f4ea14e2a9efb016d98bd3bbabff4124c1245fd5666f329c4e5046ef1ea82ef8658b3947ab94df88cf9bafb957afc36412d92d259c4fea7235c89144ed52f80d22d7e86c86f4e964d3d0898aea4bef1116b494daee702a950f978cbbdd771e8ea08651de1b83f624516ac7eba0186f12cd7d89ce959ed87fab299c5cde86800797f7168e3114449cf7af8cb91e8880c2e41c78c2f3c36789997a543ad5d8600438d7eeca62a4969bb00e2519950a2b4b191a5b863633300430edfa15de178586a759837cdbb0e4ac49a9ad01a66fb55e0087b64b94c8b31e219a06d8976b9c8651d67bdcdc43fe9d400889e70de4303fd64bce57d91a1715080385f93f0a6bd67dfd2521cd986eccfe94e16ec8079fd179de73eb364e142261da0312a829f2d51b6f0f45eef679988e543b41da8eae9d2ea64a4967f848531cfa25d4c91600a97da01b076bc1401ca16bec1b938dc7e2f5b2c570b337d98779317fe9c054c47a21402d6545937c076ad919a5962f3cff64f937c6bf979c5305312eb69aac7e718b94ef230b89b1c2bae5db574eb414547c9bd5614d2dd914500bc195d0375dd2a80ca2d26b8a724d1def99362aaa323a10ebe179c043a4e1c5671bedf301f2d1791709d365855cd9ba633d7ad1ecd87c9fb36162d8d6f56270a8bee857d4162be2ab69b2640ef9afb4d9590fbea738cc7bea1c8ed4909f20168a68f3657bc68305cf2b60dfa5bed31ef5cbe2c77c38136fa79984028636f4e96227573a8ce750bf222a227f2dcbc297deb96e18b15691f9c582dfbf1fe3b53dfbbbf44a00bc10718a0e02fed4317771ba5cf416bad2487cd0e2d66ca4794d7c35db9e8a7e107f18fcd1dd519d900c580592736db6b0a2bac1ae192b5d75afc13ab65af5d26ab281bb2185b0eb1c9b0a36d0bdadad82a52e42a093f5beab310f6fd1d25f0fc5bf1328e090c21f46c9b124f23c431604e3c563f8a34551bc0dc03c565d87576b71a74363a560d02b04965cd11c89cbb9b40a3f190f8b732766462c2b0ca3d699dbe2bd6a9fa0ea1fc534282aac6e2defb78b72012d6053c3433fb801fccd9c9044a950abfd4b3d2e85c27c5d3c850f47d44926f82ac6043308eac0845ea2ebd247e9f4f4223ddee3648f05795a633df0fdb780bf42c3ffea47bada314034ac3fec26860abe20a188c75ab3ca3915903b518c4664a4f1d627e98850e22f8082db50898d5d39f43aecc7f8d2849125d37a58f0dd9e9a251ecb4f031597a4805c1ba25059fef13cd9d61660fc80ab50b1a526bf85a38cde1376c7a82a9a76ad93039a068b2007fa812e64f68b564d60d3afa9338f0e0c9bedf88aea3ce1c9faea7e32d83943ad719b865b18c07d9cb7f5f070a593b519c830e46b0ea287a677b6da9b974a0b28f4b37fe8240b5d4276f46de49189cb62cc77d6e69d45ec404be2f53749d643303801dcc95640499fb9515824042f20be72bd6591da4470771c4dd390219fd262ee74725f1c9f2e3e9a5e982217769f785479b1e8a7ee1723417047cf7fe04f049c33f719e06184aa7ae9e25683d0a3c334fe289c20b2976eff59039d6e8e4ba08273ebc819fdf09ffc38a1f818ba571ae5aae72cf9797e0c1dafea96f14df22fb4cd979649fc740fa180fb891992f9952873c3208d8cb2a6fb1e652288447b6e9c729ef33a5bfbbc1d9072fa4f84d1ff828ed7e6e376ffd51c83552388a44030587580512496aaee4bd885f984bf4f98cea45aa559a9f3846cb669c06c5792a0ead9d85e8b51c9efa118ef0732eeff96d8c9c1701b64c31bbbd2d2f0025f477907671f808f9c1e9914644b5fb381429760f17d18433fc0a6afbf73b1add87a1373e5a7a53b6314f424aaeb575be9ef2be482a0b80d72eef344dd7fa4fb6e38d914c6a5749e4e09825b9a37616cb904eed4de53ace123ab508bc405831bb6f858bf55f52d15043c5fa1385fbd8ad682f596e684a12af89eed9b558825311598229c5de591cf7a1659458451e0b12d7374876068c35df39cddd4f440e646c050a18add79a75e4e98c25edbab8672c37151d99ce78c9c5bcabf59b1360763922610504c102231836bf1958c813f50cee26dab47225628b0cdf7f371a26ae799c1c70f150a53aae184902c83110a8848a7cc15bd2b7f280731e9b08c1c79cdf883df3dc84792236c68725a132b8c5fcee0a57eb5071ad2f8975432abfb06c37a1c685ac03ca59f4ae137abcf9f1d4cc5ad246ba1d208e9f5df1cb09a22094ffc5b21f1d385e55d40d034a7be42f4810224d70e027fab61b5920d17feed77a0a7a65c7629f26c13f65a941d125fa3165b81cbc61038836195a43699a002d3f93fc842ed90dfdee263ccb2118f24487bf91d5b6b91519102c6f8bbf3e9b6e43f911cdb28150b18404e65c4755684998e6b3b9207006927cfc70acb4e6d73240148fff34054339a0389fb575ab31492727d64850d2bd5de77ee8faa7d976e291d0857b44d3d62a33e30a3fb4d0fd4394af6856f92e561d62d31f3b071a3419c2d9715098df1a8a8dd48113cff799b2e23e6d551be050f642cbb81a950af035edd28f57657392c84595cab37dfa72f3485654e3b469c10b4c6e67cfd013626d219c6fbe03ec15d23556e9555e66638cc4582fa4bdbe4c9b7fc23d91db72bcdd13e262d91c4e20cafdfd3a13ef77bf38c895531f79bf9b69883493f40f193bce5ccc16d14d45da8c534c2df06cea3fa975bbad3c01664b163ad3184d29cfd68680ea38c245d3ce988c9f56dc434057200723700623b918dde4d439562967724829faebfaa419c886bcbba2ca1371251163515aaf9286d8f851220bda1e360cd56b11031abf39eb179b6a07b4257f9488c4bb6e453f8e1656eca4cde1109ccd427ed07ff7926f0df95bc8f30f4fcd76df9735ab7a8db8d079485ce5cb58ff6559a42e18847dc6975d08eeda3e11e64405fa9b752379b788b05cb7ef13992ca1c8ab68d3f252141e815c1dbaf5c91ff06fc5d2738a22f95728cc9591a11dc13e8ee42b013eb72c5696c8ac686506ac37cece2ecec72b507ec6bcd296863fd7999ace9c70f2e987f70f5f2437453bbeb92346db4135bd43238bbb2d101bae3b99f7204fd615fdc2e3c84fafa9ddf81a549c635d97369b6a34ab1c10b9d7fa9f33633e5b07edfc75b86f08d2cd39309545e84e5544478aa6f4aff511602af26bee6fd956db395e61b15b5b1c5d3689bb4f2531f956b9ef21ae18fc66fd5b4aa714737eca8bef66f42a26257544e2fdf2c7e91be6305c47cfbf6187f36eabbfacabefdba47aa0b34c1a52ca579d2c401c8dc32d84cbc131b7a8faa82ae63a13508b1093b5966371e5e367ffadba8ea2291f7ee72bb181690fc74c672a4e8becb0ccfe490acd48a25f07b59bb7e52d55fe52943577600ea2981a39f7fd052ee78df3ed3f147d36517742d27a747d2bed8cae82fc16dc7eb07ef1ea5f8ec28f90d19be5ce53ce4e501ec1887b80bf1999c8d8b95a31f1f43f066e2fe8de0aad1448300843878e740ce4671b8a2ce761dd53905b17b233ac38d89365859df9fb9cd0b51b92287de8cdb7061e9ca1ce15c5b25b77963e864786fad7d5095a511939e3acd3acc1a4159841d16ed97e04f5c36c281d6c7b34479e3930e49562246151d8f86338f879ab74ed1f9930a1498e83b323730634721073422b8bc677df0425a808f339ec7f7bde5808db7cf4e3ba7b7e47f5caeba304f001be3a343fe73eb221a90ee87f5c735827c156c222bfdecfe49c9bb2d00e3adaa7c8a6f627a2e1893639e69fa2179b25a41b2e8b5342b8ee90ddf3580734877c802993fd18eb565118dd0e2ee2aca06e98747840b017ee42868171145144fd7ba2d5710a459458329536890462f08bf3da3ded0f46477428d7ca0e3aee7d812243ab1163451c948276bd4693dc439ed5259ea3b2c04f66080fc013985bb429197e02da628a152c9a8ac67126d9478342a473d25abce2e5d4c31786b594e009425463510202fc1719e73f6c1b252e2a869ff35214281e69a5098e8c7a46427fb7bb86ba63c3258ffe71f18abccf4d2b9b2fe805d5cc9d0ff85dc147b7836393f57dc9594ce2d42add42d2e1776231e6c297d319addd2b096f8e4377a8318bb92165300e493bd2da3f7fc75a8383cd24601d240727577ce8eee284c584f1b667b2aaab372968f9377cc8c0660dd7d7067109f5b96523375f4132949a109aee82b906b684fae64d36e9f198ac720d0fb1c55e34b6b24ac10c964f87f3a8279b99cb93c87705cf8b043505de8905b889f94a928a5d49ba50f0388224801cc5057092ed8162bf2a78917d34add4e6e534b3fa46f79bf486616c36fcde97af81df0d7eed7dd98931fa32a38adb7088fc4ad3bf7867c43be2338fe9d051a7da31566b627480a5104168ad439dea4e6895a7ebf7b1244b6df4b1b280eec63b26efc58d02fc64a3ec948dafb5b93f37d250d98192805f0daa49cc1bd96c94bbce3094a7e3bda96b6a1eea6ded4bc4804cd9e965e4cce172e11cba0c1486da086159cd6965e33a0063c2f0cdf61f4600abe25045baffd96a8f420c5f013e2c7a2e604ffe93ee3d43b10be1eeaca831cdb2a8704a6dc3099cd47388e72a0c8a677229705a2d988bce14c93a6b2f08954ae68f356f814c2b1b37bc056fcdb5ff9e8346528ff31ca6a489132165eea3e27c9aaa406828b3a047a145f8c6b7b3aff52ea7e734b6b10695786c21ff46a16b5deb9181f10ab05eef11c83dd5999245809b10a4974c2b10f2e15b36477f53f1ae62c07eb096bfcecacead6681cdb1c8af89c755777a8db9383bcdfa2682691518cf55cca7e96ef70b5b262bd11684c814970d383e212f5d62a4c0129f6eda88eeffbd5af69cbb3f0e30eb8fe6cce68046cfe4f8c63fec64428d10c93ff0ab59933b4a870f7762b6fb612b4e0eeea4c18c7e0f5c616aae3334e319e71133198119507011af8f6ab134dba90d849ba633b8e6f16b9f82846534197ed43d8883f38aef0c932128b0f9fa68b519d4e66c3f8af385ee312c47487aff355225fe304b3c632b76ac8b74407ddcefef84b66d60b3ea640a50298f0c8b96acec546b634cea2f50d18cdf42efe297150961b16bff3f3b982536e2d717153a8763e6c88ced33ba62e4320ef21d34d9a7331457c95d3ac190ef5d7c42b5a3215d05d9dd808c2dac655159821ec565550d39866234dbe4727518a70250a23264bf460610ae3ef71ad205fe45e9bb2abb8f4587e8c7b3d402ba5c0ca5dd495e915a8ac345e09af3f9b614e7104a66ca0245f1bea6f1e77c8c836a7311612a65c2acb56443e5486d84792557d96d4e9ff9d89b0ad4d1e12f2729c2d0a2422fd5cd9601cf9dc653773ea9c296521be5fa85ea5351a4bf8406de286fb742d05dda0ced53494a562686d507a558a686025a633da48c78a4a3fbfd54b4eea0abb6e7300bf7ffb6f2891ebe8e9625868823d984076896b6739ba8c9890c97daad94cbb2c05ed9f455a623490b51325c061c6b89616020af70cd0e1f87344a3a6414775beba91d7da9337f4324d1c156d70a4021070caf54cc686878cd097da259215fe0a6ac404494aac2dc9a9950d69a0980bcfd29089c7bf3cdc11597f2697bd1b11746933f718283209e3721ceea911f05f5c2dea813c31ca4c14ed571acf3b926b18d79d9fed0983b4175a72906e30ca5143b736c992a7e6123e6b952112eac910683039c46d05ca8b5562974d813f29460be2b217bc3e25c1dc0dac10d5ee504ccff0a8934ce3dd8b9cfeabdc33e67cc3a3abbbdfe4399ac30c3d39f95b8cb27cf1c066d3d06c43bcc36a37679998cc800422993d5cca38b4702796a605e65ef0ec94ecbf55fad38f1b90aad3245e11dd2059a8016462d0c97930e0a6c3b5b2721c2e52853b2a7119f2a7a91a7f20e3747b24d3a464e781bdbfb67137ee3f28957266a606dccd7d91a5473d5e74b52eb2e2ada96717948c78e57b503d4f59bf0515128b94f867e94404013911caa656328fd6893f1ee2c23daee336a015405a655179c11a3456780ddba08d906868a80b9c953277df66cce8dab4ddc0332bdcd08ba01f4c2991de7fe1506390f29ebe07860d355e549b1cdc4a2b6055ddc1385533f515a962a788cf90c7b93d0c447bc36bc8823750483b45698ebda606c26ac2f7ef77323afbbd6d2e5248bdebb41ab2d8d7ec78fcb96821c660716f3594b6797edcbabde60c68be511485fc1b705c7f6452937a6d89d270cdce9a2e27fd020f666ee27b8b8066ab222cc61bd3c7c04f425a8607590a5b3fb142ecf980937232122a5471a6d83cf3712672486d8f223c6d9df5a00d28cf489dd6c2b0b0bc52bc206cf48f8fea388490c58240b6e80a42fe9635d49b2e78b179b2d7290779a8b0603ca2b7152887b713d07b9b387fb0d47b90b9868c6c6d7507d51d47f592b8d3e2f70c07c5e4e4e5991b6c77f8de1a98e9514f03f1233824e9d1def1b8048a3da8d8a747a98405f52e4bc2e4822a645825c52d646980daa8b367595fa2062624c5d5c5aa7bb6089f72341b229fdec67c40b8c21f98b82edd5258f2f904c2ab27a318e2651007c43ecd26f89226642bcaa76affc8656f2a13fb8d20e2b30a92b688ad61a2178d68781c4b3852f3b4f7d2c062f9d09dad0789910fb1ba35add239b105c6fc92a60a59a96b1b95b4e5e25d77156a181ba505f6a0b2eee2b51f83e2832df1dc1a08bcbfe1310f21c26a7cd9e1624a2949eb0ed829a933f0faa1b654bba7476d8ae0f157e802fa00f661334c2729d1d0744323bb4bad91757a6afa04efe5386e77aebffe9b1d0299417ec46789a65a59e3d55233f18e40f4aa3fa7dbd6a349ff6cfac8fff5ca68c56e70c6fb73104b1aa796ea1bedbed35728bc532462f805186404b8046adbc3d50871e7e5208343b82e451fb1fb1690c3d8dc0b7492df0d3a6876376698c300c2a5bef8ccb8b9bfccf467aca95e5e07a77e3f972fa8e10221fa52e2f391ebe31052fda8133b70f23d9366672eee5bc9ba177f8ba384944c848d74ca36f67ea6557c125dc7875ca77acc9d52d3d032afed1bc85c65c77ddd792a2ee11326aafb381f2df932328a4c5798494ce6ad6d03709d192b6a8ad1d63512289c0bbb156c30c021d06d46d74b15808c205872355bdf4112389710ffdf904ea671970eaa6e8e675718276db3c0fabec39ec220aa253776b73224bd677c5f4e96fae2aaa1045b732b5af03d0660814dbb9206bd5da88a63ed59af7ad829cdb6b55f49a77767af4028181473b15d3c396572a3cb1f1a33bdeb11971caa1b9359d911dea6f011ec9f0d3e956ac5d583505949979ad5f90ae0adf58a90e16ca0eb3bade77e560c8a1a2657671465a982e7148e4726234039177b7761fed34412d841d382aabeb5aaee5e45cce45f7ee5bdbf1545746a8a0dabba66b50cf5c06d2ba24fcc07a8bab4d22fca0660ae80253662279812f68a17cd5a6063f3c1b8c183db04845e6d0e076c2dadfa159852497eb372625422a03b2a1db9277e91442cd43819784d04ee444be3f1992de9b17d7f0f53a5651b9c1728548d89ebd26a24e37099d37f54e817912a1f3615ab83c413dfb4d857672a3a178ced93fba4eed805b4a971e2f2683d91af980a1dcccf9cb47e92b0c2d7327a4249beff4347a398d04214ba816858733dfe23baeea27fd3f3345f2e867495849156c649e46994646b9b6954ccd0bdf3b6902f41410deec26100459d87ece00291ae31988681f0afd5d0b7ec2c5ccf6d16b23b35afd46539a955d5e6e65689276ff32d768e18ba91707552f2e92c9d4b6e6fd387307fa7e033a9a05a55315b282b052846f87366d06d0b3d9a275a66f25bc0ee006de94efb2f8a2439bee11806ddb56bb7a51b113cbc9caca7d0b57cb11bab5c938cfe5df7534aa04d11a3b02105661bda43c08816a2598ce9e36b53158f0b316eea2c572e843c0be85155962c8d7fcfe20213376f30719aea389b451f1a41e081561ede0cf6bfb979fc63ff2ff4eef59cbf4cb4127c60cf44fa8ddfa8d87755a70883a7b120918d536c12fdefa039e2e5391dff5382760c937e6b4f8edc171f5cbda449ac94c139823ee8abc2f55e28f31fe1c25995e334a9d3c343031e3ad8c1e4f26da6f6e9cbb95decaaa96b7eedcaae0a9e53b2a463d3aa17638a0bb4cd2fdd85b203e00a4fd08dcfda0e94cee006453400e08348340469f6f223be92526490c1f26188c9da36d26fc906479a396c2b38220c391fc7d9ca8f36ee6f1fd9b09e21eed89b2675f95f6598bd5c47444a0cc6ecfc3444a5bafc399798e7341498033f43375c203f2d060a0e3a25a4910ce2a5f7f27d8e3584a58ca7fe5dbbdeaf06ddd575849a712dadc72b55aee4dd864f63cd19fb33eb1cacef301a6e4a406411a5720edf451dd6d0bdaed0cb4ff7e681773d789ae0882452dd1ffd888be5f42430c9f35081b015579d02c9cd4b257d36b9a5649660a300fe6f8b16fc79b507c619e9bd4005ec4b5b5c4c76b7881daa9144e9dbb406461d2a68b911ee501a9c5ba815ef73b186d28d100711aa016ead62d1dc643da462546bb84f5ebfcd368221eb9fd683b1f92b57407de22a8b449924a2515fa25d7369d2ba2a7183509bea31dbf65df3ebbca1f02e14450322727a0fcdbd205f61e3af48172e1f46ae0e524e096526e2e7c56f72c51657b27d006c233e89d98e9aa1b10d96e385f7038ca902fa3aa0045bc5ae145ac437bd9bd6829d93bfc4e6d3cc6aa9d097c439685f4566b880176f7eca86afeecec5cf66ee2e86534367d2d39b6bd493b8554417d354089c81fb292bbd722df13a9c1a2d109b582b3ebded603446fff37a019dcc1041cf27fd8dc5d51c64f869a8a4d19ad2d6a69743651e29fee0d335278db044ef142e07992219e4b8e0867f6f1eced28954f56531137593e46a9bf0574c5db5ad288a28fcfc880961a61f10253e26a66b8f9bcbe7117b7b8e297767e86b88b4a84c1362a400f077060c98ff7cfbce57cc997d312deaf354fae05c24d8b4f120359b0ccc64181c70fde1b9144f6356fd6fa843625e34e3898f2d2bcb4609d73513e2d62db48c1b809c457598f4295a73f235dc921c432dc2e34f9c0a479180f94aa27e8b257d58038e95112b1811729dc0514e0710a20b97c7a1656e010caeb52950481d2f0606081d51a4f2f6d73b1f72d40a7c56a45850f013964d1d2ef1ad81894f23fdf9941e8b59fbee04207e0f585abb0974dd1e646df192b072f6ba27fa56feed407632cbc48f8e28cbcf55c4ed4d321d01c074bde2b7137791bce19b577e1720106d057a29bd6a9e8af007a2def259600cd4c0f83ee8586edbbb9c0d3de88268e73faccd333c441f6bb4c5ac418d0be307fe1b6aed996c3dbf6a14a02a08956aa401899c1944c2091d795ec13a197cab41193905afdf32219dcb9667e739a1c7815f7cf6db0fec1b5cace563b4e110ab01a998d7e44182a11118446ac5a7f4254fb0d85036893e01663c0bd8336707c1f867f2e9cd1b6c4385ddaeba8091219152255de2bc71ec89cda7affda4900dc505855c95ddaf30f15f90c6291eb36156b1cff29abdfc0c89aaa8fc391bd9f802661c79e3e8f3aadb570538c49de41a374ad97d168aafae867dfa50e9109075dc621e9cab26f76751cbb75d33865a04346d71b34f4dab63a85786f6e4cf675b439f423d4e35c55dbab193d94b03190ece6962ba5f1e4b818d5c6363a4c3d59d65d6652246a4d46a2a5381b6ef65a34ec2f1fab2d62dece4b77805864015375104f81741c6ada0dd7ccdeecc5807ef64972383c4a1d25af6bcd2e6ee32ddbe1879688f569452968d9ba445692e61a163f1f8e2c375d3a7ab6157748e86aefde5bd43956e49241b23c16f4eb5e2b40a709b297eda9543b3a3f99469e0913d8ec2fa3397a256c23ce3bfdbeec1ffdba04ba14c2653dce1bfa803e729fb2f7506e2cb67db71622671b7f085223999a3e33a207ff3edabf8ac19adc042c9965caf4b4ab4ea18ff86181501944442dc8dffe96cb1d91800121addf13eb5fde5544de6db365e6a4d23693c697cc382854c5b9ad90fb994ce158f3bab214913c3434c09159ba70ad7d8893d7bd28839d282701067cf0fec57a7ab2f88e2461419caacdf566405bfa05e493d1afae555735212a3d28c5d89644916e023bc09c9ceea22ffeda91a55d734819e39a6194479f2ed0919f4789d5b76652401b21983d447ca30cb1545709bb2bedee782c57726c62c1b2d40a023a13564967b7556d40e0b94c4f10285b38b3bee7cac6ae8525023efbc90442ff3c026d18a55cf5f5ddfcbac36521ff44ab79668b08d8d23fec64eb1961b27cbab3d61972ced7c2fa7d87c4b4b7d3939a8252661521c3259b19059fcf364510b1102e9de8efc38ced732e0b1726aa96345ba29e506686ec839b026af709cf96b27cf27c611f8699247d0a593b288dcd971800c1e49475dd412f7517efba68879199492fc1337ade2042c8d4fdeb9e72e7480e696c7ecfc538a82a59c8f3b6f4fbdfc433f2c9c67a50446cc269e92f2f197057742f9e4b0dfd25f8c729f82db1279729ff4c27209d8b215aac8110ec1bf6ca9f2102725274d0a4f14f719c9e8fda8e0d0a80878fcc6b27009a4919ab5f823ece4960cc4eec57f442dfd6e280a801e5cdfc44178d1c29aace3fde708413ec19232d52fc142a80ee21cb0c36a8a25bc7d2b18e0215c8b38f60e94196dc5e93b5bc54e64e3d236107147bef38d9e4f8f6c91e81d8431a51859d951f2e9929cf896b80d95a2c305b2344092c202fb1c4c2556b0c51af4715f17236cc50b03c689af96074cde88c70169480a6ed2ec1864ee1a13f864f791d41dd7d5a3d1552935e66d04daa9a385bd114168d3bbefbff29d2ed9e2f5c8eaa8635c79b285c04a8936379c995f74c27d8663a857f5e633e8883a861b61891b5182c627883b45c159d2364ba01f73f4b93f8ddb7e5a34c57cc46bed0caa99960492010ec6960720a17b509ac2dc4dcb1d67453062ee90cbaabf117127697569f010c9ca323dd4ea8c2d2762efaa0b7fb8e655d92cc0cde3439bb622500f5d0bbd3c0b48f38c95d681551b3828d38bc9eb779ef3f8bfac8011e79bb0b709a5f71927d230851c2cd3720fe183bf55346f14b16e76b6841678c297eee76530e6982ad3a08b0109755ee63bbfb958b2c0cd2bac3bd0829eb52922627c9d63df390901075b022ae4d96531056ebf35a32a6566222dd4158128d12b9876518a678c62468acaa5a488e719e6d351a6655ca34c7551f3e3cdc6ae4d58da94a263e60834c9405aca8b803bbcfa0314df969a0befac1d6e98ea3c2cb5580fdd2d0bbc363429c9552d6f56b42a5d03b068cc94a04871306097fcce833131361a1388b162f6d2228dacba01b4a2b147f143ac52a2780c5f0ef1ab40032ec0da375a882fdba8247ea8514473f6d22af9934ca8cb3f6823e397c5a55154fc9c8e5ff3627d7d8ede76a6e3ab6acbaba53fac623e544a590f86ce51282f572750deedf05292b0dc603a7a9040b793556deff894652f7b33c6cc209723bd862d94813840d198b7a83a1273d5e0f3509d3c972a210f7f9a170e73d4c868607cf1dfeaa91c65fa541449a1da5021a4edf37b2ca1086c15d719f95dcfac9184f2d996c09ae04f142690e127546633739775b31e188cfcee8089d59fbf79870a78aeaa977ac7fe37e6985359d739a232dc715086eb516bcc53a9278698e897f8362f70bb681a905aaf7a8f8c7a547d584595896906d113cf3cfb80ccdc0a1d879f773c5d9587574377e210e9a2c3d322d84cac8b1aada4c3029d8e1c00d437d3c678ae30aaa57469c97d9a0f04dac7482eff6618e398730718956f2b6acd1635fbe7373be2694546ebe346fd0c81d6bb5f52f263cb17bd46f9a499d8780f56e20bb59f6d29b2e0789a5a13b5eeb893c94cd7669eda33c15b7e584ee298374c55b2a0b6d87100d1e343b6081396ddc76ca394d99e95ca4d3b2950645e9ae613206e6575c8f2c1059078ae4701cf6f7e1594fcf6966b64fbc210548f4d2e99f9b285b5f289fddcd9fd71c1ad2ac83a0db5a4472000ab11e0be1c5b4311156f350dcd47988e46d72724e1e41e2cd734acaef5285660f92eed094c1de24134620768b890e410fde4a62e278a2a1fa699c743994862a2250abbba139aa1328274a666722f86d108511b547db42f40224f1f3a4a7ba132da18a634c7a4aea31aa69b17375909d2051a170a4599be903e0efe50c536f49908dd4bea767717c943f7211f13cc59c3a1606defa74b762ee6a9e0cfc9ab7c8ecc883f2df966c31863df2d178d964935e040b505962fb2c02ddbe1b9ec46775491244187def55b6e653dabeaeda6db821914171591e79e6d8ff2c9e92fad256beb6a5eace9dee18e01d27712930ec0da0ed558b0ee3bb12302421ad22474ec931dfa627ea59d12b5bedc920c46269d1c696343eb02c4168b15e1bc3de7d1513552b1fb88ebf198748428c8508c3b4b1157761554bca6199587a02354c2bc135863905f58946369f3f4e57cebe1b1cdd03f163246b4a2eedce673064306b8378eca66938ab4b5c5ba151322b342d29c5e1f50de5394be985149d85b785e2d700a4b5b692c0a49190a5cc2e24921ea12a0a79a4517ca0d0d7f9b5ddeac988e1c5bb677c9c554f26cb5e95e75269ff6eab9baa03ad80a9f81d3a24f7a210867673b0c65bbd55f57ae178dacbe88b9ad30a3a5a0a77f9dda690ab08b0814ea84149f70a04c6c8c32c3d6b42e293d265e80da89eaa9dd75704c3c99ba06d131b1e2a2d1c405b44d64fa72ad96440c70d79f69414c77d62da3b0eb85405dceaa7c088b8e7400003f5f4166ccea91a627398cce54b5eaab0d537da70601182f35cc5784e426be2ab8208d367effa6e6293945f89c00bee7633a729cc8d1cc633e59937895ca83bad794dda79a094e184a591cd109eaa7f792981e389a65808bbf1cb099be80ae1fa3ac80b03df38bee621411a834bc566e1f6d6fd26c83bcf16347297b6f05a09593599f5a1e2366848787c256d37f422c7c603e76e60fbf014ad6b83a8ca8c48030e7c00bc842510ed95ab15caad26d87f3e3f8ce51edfe835b19a67bb0b5e4465cbfe40fb41a42be6550606fbffae9adbaebed3c4521020c8c38851c0dc5a660b0ab65554b239f70851d6e8bd366c43a3692e6aa0a81e6162ce3a608b6b1fddc6a3790a6d1f03fb59a5fd2d0c7682e673bb8e791fd629be1fa280df6ccd373506d65b4eb0b1cd9f427eacde0248ab9b312c17a50e952499b1a2d3dcb1baab826604157eb49955216dfab106fb8b3060afe3ddce174a9dfc55fa959ca408bc2285fe337d6e34244df69601447f535171257de9b52572fd3dfa8595d97e244b712ebc6d23c69e6834a8ad08c46cef6025630d10f1b0693ec9265dd1d975f2d5355e7aaf70d589ba2e8f7e8bc67fc1b5e23a82f8223ff5eadbfad9d45c5f73a444f7718b3f18a397e799b16c5dfe3c3d031b5c8f33ccbc5e4a260d00ac1a1eae3a678d9ae1d2df8b480a49a04215762de612811fe10f4227616ab3737815f79ba5e61439f4b0c5ad7ea29ad7ebc6acfed65d9ed7449143f54e5dff5b122043ca2cdf68c6c3919cfa9a301f268a421c30c21bc0668eca2ea8fb982e148f81886125fb30122c9fb84dbcde02bbacb2f9e003a33cc20c20bed4f4f7cd9108dcfae0abd34bd6ebbbdd4f3ddd9f1bfc10ab767087750bbf5dfc0473c806969be7db747a55c64aaada44300b74ed0efafb587312eaad5224baf8016d85163e524589684e2edab0eb40039d2fe5e4e1a4d618198d1a69bb9ffdca41b506f1f65218a949c774028d67e0f284e3f89e29b7d2e80f1da177ac3198e4223eea37e1b629ed2e466962d9a60c6e2ad8188496421dadc4aa4391b2923cd4aed1090a47bd4ebdcc1e111be46c61d39708e0b3a8001772c5908360e8bc7e684f1c5470ab8ff67a7ef8ec6da510300cd697aac6a6d281fb9ff64ba0b4994cee658796488e791eeee9caa824f3400376d2ece64e8f1b033afbe7fa490107212bb17d83e178532bb9d9632e2f3cfb0d3cf2512783fc30499c4c08c1b089cd591c0fab5bdbc69a8b55041814deada695e749909011b4dd87a9130ded0ab6e22cf409bd5063ddb1fc26b2ef26b07ed0e0b5ceef102431bbdce4d0aa6af5a99b8605b8d67c8d2ccee629ef987990d0ddb12a69183a9b2a4ac4623ee39af99e6224a22614632dcd8f24581a9bdc51ef7ec65c9987dfa008846d2a88896b69d6d0cfb1e037ae53eefd3a38491c99b149322a740dde7e509d86af30698953873d30338edab5e022a564a3044023f489f70b6ff09c5deb4aa015703ae9115c2d79d7aa0d1ab45352a0441b650ecd382ac881b0da9979f1bea0035428ec6d4b1f0c621a52cff8ab4923fad539cc7fbaaeeb498d6a7eefec31b87aa85b7e5eedd2b14f03e7b76c2dcaf841b2ce9308419a2023a729ce7a9af42bff7011621d664b54e920fb6018703f8723bded84e330c9bc77925796a6c99141ef238486cccd1c80951a2974eab3876a81e7759b7beda36677391c6102edf83b56239641602962469dbe316f40c1b5923bdc2a76ecf68d3df2b5fe1d3f0f9c1e60094f2113c656eb7c81e50975d1541147e94568af0963cf25bf82d4bc61000b054c3d5b8c84eaadeb1affa24c7452418e0008a4eb2624ce5dbf43ba07ee42dceba881cde25854c942aebecd852c96a9cf0218391d79b8f17cdbb584980c10e3ce5695b2f1e107d0a668135c2686cae116b1368b6659cf1b9e5dfe4875e0e95021c0092982781683da48ba5a2d9e0ac7c847eece587b6ba9e62418888fbbdcf9aeb7e1e1187ff8022f4bdffbc5a0b07beb5c97fe6937de1175dd5463683bbfaae3b62db8cca9ef5ec5227f36b77550b9c0b3ab6800a3bda4352ef86e5cbd6b9e891b730699d1d5b74cb4c480df500f3b3bac7b7b4505c0cbe7421768b2b158ba3b2b1684b8145fa0149b2cfe4ff762d6980bebd417f0cd591a933b15c5abd1ff5c780ddf3d4b997a5fcdb5152eaf68a6649762eee33ab525a6625d8f423a217aaa3d6b4decdf4c1c6237eb3010325ec4a0450e368720c80db5ae4510c9dbebb9d3158e1026eaff9eaacf82ea166bebe74c364d2b66b0d60db046652bc4eeeae420384e43e0b52401eb9d953a638273c8a8409726d8102026b11d035e6a84a15f0ca37239e33563d0b033cb2900f146a5c94e97f2dd44b0c61a9136cbe6b58184ca18028443fbad157ff6d8c74a987b819b14db5f82f70d5fb1d26b54202d23b9adfe482f1044750e18bde829001ca1f07acfdbb17c85a02e390a6aa04dd89815cd5f4edc4c053e671fc39ca12d739f2eef272004a872d6320d9a0e85b32c54c5f1d09a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
