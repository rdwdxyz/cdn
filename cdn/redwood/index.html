<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94c956215c03fae4e7aa1ff1df15919bffb951195f3d969f1cccc8cc9e412f9967e84d708630a6c6d2c75ec7d2f387e6b89ca2930b6d9e78574f7d40f5c6dfb1ce3eb9da506b6eb4433477f6e182e39db2082fce924b6ceea5e94e1115faba23b73c5ff9e9996957b10c3c1f66e119b90a41a09dd48ab39bb8ead6dc6e42ad09c1e9dba63a2f786d549cb4c43b365ca8b528856d9db347e101cd0bfc42d403d52e1003b9cb45a2a9d92a1fd96e00a23a2059db236eb4af3a7df7eaec43fea246388f3e96071ffd5a396edeb4ab38a4b54bfb6a523273c46c83af6f0df2cf64aada5b827df09466ff9943c6f8ed816f2d9500705a45be27f820737f78f0cc8cc65e24f25243d72bd602beec2efd1f249f9e1fb0750cb30a6cdaa2c3f4edd54abca93f685015df06a6fa0450f9050a465ae612779c8f70d912306dfd7544d4acd012776b6ff8d72b62a9b6c55ac0cb92c417697d8e3cab28c40b6bbcf3e7a429676667769742ca6e284dfd1aae87c864bb620610998b53b3b293f44391d9c477a1eb7e67fce77a002855f268695093556610562b7b6c325d87fe7c68bb8640f608bf65bd54fd20e0523f43b5df67ca8657dff3ad7be8c72c2742c0b9bed89f9c1eb13115ac4efbe81ee249bbd0cc8175522852345ee5d76e113f67a9cd918e0a2afa4df588e7d9ad086f001f380ed5383d0524ad0369ec184c5fc755042b6652ecc7f3d7135545fb4e95e0595a67068b162f841b570acc50f77f9aabe31efd7d0fefff8e0c8f36aef46b9da583976c0d0d34395e377fcbb2f64726076dc1733a2bb88f4fae69905425d871566a3edf03ddad0007075667947bd06238d275ad1298591d7fac94c28346c4a829bb04e26c684f2e1933b76f9e13f6949e8e14424b61b51f390546c97e7db199ff9e631ccc647d80731604426fecd2f520e0cfb4807cfb6f81e0ccd0db3a29b7bd574812a705934baaf782af76f94eb80dcde07220b473e14adae9eb10f6c639efa9c999f69a9db82ac7e2f29dccee0f2fcf9fbd776a45fa47e0a82acfd8ef87a5f5982fecd490c212a6394a653fe73f9e034612c5f6cb9c7338c7077287ed4beb68e141fced5663c3ddb79232a44b61c70254da36a71c6e86df10b7a21b32488e8f7bdfa07516d3087f7c0b29e6a812685e21458368483e0c32a2838e65f82f1014f2290f48b9635c167fd9e096b800a633bf77da6af1e3123dac973f11657e07ba618c731f46b86ac0521b364422fd3fbd5ff8ebff69a008e1f1f7a59c158f1a205cbafbf3cc2f158a83aa6216896a7841011decf3e5ad4b942163d6f659e8ceccc07fa2f07ff251284e1a2d4c7536086e52b5ede5d810a878dfa809c565be1391583861dbce9d2469e5904c499848f7b8ae0845bb8facbe9a163d3db97d5b85fff8ce40d07a9ec42e5e25c4d2a6a4bcf9016f5613b48d0ad14022aac33849c104b3662e4dc5deaceaf38adadc80300e4f199747dc94a9211894e3b9f31568c3347d2f0d51cd5aadc4018f23d623bd8cad2aefc96b9a821c038293b3ad62d64c3bd57301698d9cd4f7da725abb6a5572971e534f935e494e4355a479be2c83f8285d6d643b1ea34e3f2a76d463f0c211274af42b94aa3d909fe7b06bf02f97172daebb25792642b3567392415985e42c94049fb28fded4f530c676bbc7da0de88e68202671e07a930dcfa563a6f19ca260c8d571717a17f2c4e44e7cbda1b4f8c247d10696c41b795a6fda041aec0a24293000487e905580388e2a2629a3fba5de3210e63782a406d0a731fca452801bb639e3190177183dcff1eed14d77def822713b3e63e6f7364578cf6f1814a6f680ce688237d7004d0234dadf01300a31f853da106cc303786f77d2522b140b315b32220ae05bbcf289b489b33af4f8130fd01024da12371efb1da2871cd5115259d951024a95a70c2304e7702eaa20dbee5edc9065b084a149e53ec2c655e9b0369d5baf21941cfb951de855c9bed16137f423f9fe460ceda5748fc6f6dd06c8899dfa087d3484eab239fa44a36367eb6f684993766365c7a3bdb9cb313765252b765cde560111bdeab1678e3fb2006f0e016aed3a2047eaee714ef51a6283027db33c4c16d5021ef36fde7f6a1da5f6ba615fd3f36224a7afac6aa325c173d3e95dbcdd25a677d35c667a8bdad063150bfa6712212ef0dc3610728b0944d2d94462e105c708bf8abcd8c1cde40c20880a74c6333cff016698625fbc03720f0cc94155628629b517e25167c44dd39efc6d8b1310b3b30def20b7e6237256350a26806b4bd8a20aeaf8d820dffdb41e80aafb6ff6865933e773c3eee604be8560344bd0a419b3fa4f90c775a450043169f49893f0db4c5f4e2d778900ef91264458f4ed3f691bdaaf1da0d4380a40905b2b5c10ff64410a0eced99b90f386c04ee8e44ca3ffd9664aefbba4b6a81c852f29f3695a801f410f4737f922b316ae546090f3459527ab405fc26c75698b7f736ccb53144404e2b1ed7a20165c10a4b0c8cc2ab47a9b7be961e087eff02df2563963bdc19aa5298eb220a6c1c785387281668cd54ed6604f1f776641706760b36c7b28e35e2f6ac99a88e0efde63aca5952f11405059ed4f0ebca62642e837ec3db745fe7fca3344e22294bcb05bd2a7b454dad13fe6ffe217ca4d56e9c78c615038b29f7e022272faf0d83929ef64bf525d2e45ddc941f2ac1a492e19a8424ed5aece78d1280791c02fcb60c4d7edbf0b786d1a863ab4b174ab9daf15df40750dbe59908b4161ab47c80adc461d119a2de400b0bb63a66c6e6da6d95630db259b1beb1396e3412b3ba4caac25be8542046ba9a128dbdd7b855a81d17e9b56fcb6b18d6ab4b8165ea21f71bb1d071c300dbd1ff4185616ac93640e48e27b00acd01451cc32c03daf8671628fc77252264480aea533a186c2c33db3bfa6ad1df1b7e9b96156759d3c3d6528805e91365cd3cfa9e37017100a316000efff8160a8fd5ac1fbeeadeaea0d8a50d243bb29d205f3cd2d71324423f093d65feca02a99a52b22a2c210c0de52dd30f3d5a2f773e35524689569547a9e0c4eb9f96f1f27e6fcda4d0390af63e21a5e1417308ed37688f9bdc824d53a63ae4ee20e1a863afa39573e8cd26381c0034058a14108a540ed0d81088db35d1db4e2c5a3aa10a5ef6b052a4e341000b37820ef4e6286048bb79d7ba61257eeb0e59861bc2b06fdca317d49323092ade087d55ef01aabb34358c69020f1e7ac01c7b5c19c9e6142bb31b2478088b825ffa4fd65dec01fda0116fe03e6794d4d1f4ca6e819dc55a391476967b7c1789efcb606f61e33c853fe251d4ad26f10b04d816d601b028e86f36697e6a2d49906b3743a2735af1a9539eea605579c6ca8f6f5743db8b1445cd184e4ab80a94c4f261056975b8be806c932c0bce9f480c6ec4051b7bdc9e22024840cfc9545e042a4d961f40ef0d138ccf73c83aff441b00c47ed528dc55f568135a67ac7bb8c5f94863ee547b9f5784106788187d54b9b8bdbc3c269f143a0d2364f6a67409762de3526dd6d51b956bc04d0c88962b5c8d194e7284b28d01bb2f97d9049e967ffb645baac5ca740abf706c00ccfcc49884e34480e3213f93efe58dad0727ae831696a5f25894ea4793264f9196da68358a61de8fdf6a89fc0ae569f142b02c77d41cb910fc4e05807f6ff0934a39df34e6d22b4ff4d1f66944eab47e539928575d629c0133dfa8192eeaf00a11551a6b845baf287dc49a19bd1f8867a1145a6015a3e89ce1aab8036ac36d93ec37616eada01710acd68d1578f21a6d514ace3312dde18bd4fcbcb8d83d701d43274acab691279e9b28910d3702038769d53dae7b536b4ebb1908c5f57fe131e381762feaa2b5ddc5e95877b915d965d70487f1eb32067390ee739ad7aca988c14671bf67b6520ce2e6c0714ade0e6f45a50f6bf8c6b924279d8e30f332de5f22bb27b5645d219fbe6a1d372438776ee90aa92974bcce8a000dab5e3f21ed6d307a3aac2f23dc4d609bcade53bf0353534217c4eb3d0bb8b784714068f7512c2fe90eb0f48783a2c290b4ba642c69fa230cd623dcec1c065373a4fa0e4db9f974c5716ea44e6e2b45a3904ec67ad35b4cd161cada6a5cb2bf62294c542c70f863c678652639af7094d06d5a79d0a8c3cb96eea0a62567e8aa3cd1d827d0a99211478465c1bec48a365b255ebdb61b22cd42440ed8d86b58c62f04b1c25cf62621003c5f88dd1633b581978232691914c541bc9c2f33b901893f2ad95bc4516b1646a88eaaeaaa7a5f78d830987d1bdb2b1565366fd65317b836607158aaa05146916148310e0c52d7acf6454075203b757f3b1c7463e82e25869c512e040f952beb647360b425c95c730e68fc80ac6d9d7ac7360b136cf13ef51099e5e63ad110da0cfb1ebf75953c5ce1ad4ff267dcb11eecfdece8581f260b1af6c4c90aaaf686022935e3c9005b7fed024a74f386352bff7531f8358766d471efff89bbc8a958eefefbe4389f4a98b0a110905612de07e4ef8fdbe4aae317ce4bb55b837af116435d227b131871f1985854375e50e821b293e43ccbc4adbccf16503c285dc1c5f4288e0ca4b85a4a2b074137e9d545696a00732cb61ceb25d807ce0ba636bc1ffab3a565cb76867f8894c2d6f750edff2e20da414e9997c85a3146d650016ee1c96da02ca6801a7fd01509f259a9c0c0f8062ab70e35416dc5fd935b33b18256c2237ffd5b3b7f08740e3e1479fd348704fab7cd22bf57ee746497b6234fe173311888b63a9b7fc7f788f37a0905e478f7bccd045d844dbc36becae9b19cf4c86a8407182f10dd1e2deae995313ac1294f92e666d03105ea4d230c578761b828868f6f436216dbe28b97c284868b5e3a4a206a806c7a497b34fe7399e0ef9f527ee37eaa5f4ecd7272295347b5c1f4af330e9bb2ade0aabee005d05c30801ec5444d30e5639bb41e90a67d3afe3f4f3b449f13ecb9580ed797842f82d6bbb22f4555a6caef7abb472f28cf2de72efe4a29c8dd913fa5cb8bc56bc82480617883396f7b5db1482646126f4befad667355d66ebf02dcd256863c5cd6f73b352188064716586f96a084d9417426f9497972cf6d876c84d49c670e8a236ca3fc82e636033f6ad3954f20c38636b97c9ee312bf1842bf824c9c621d98d704121cfbb3703f7bcbc07f566b8af3202e40494bbf0b4c16d90c9fa816a9fe8989e0ceafec584f8810d00269a9b9520a5e772cfb60541823108deff880d47a360f17fa74310d351b1355155044618c8fc8edec34d7ecda66877aadb4252aecb311aade6bffc38a2b565acc47b5367319bff7999da33f386e9068d01a0c540bfe6a082ff4f301ed134b82574fa219f1ebfe3de4dcac4a955d04bec6880be3c2d1a294022657922740d4a83ba79458546dec4fb7cd30b73bbd8fc7a68614a1941a0b78f70b7834127ed3492ed091a1c14969a1293375cfb7b1ee36e0e5f6fe06b9abe439bc852c36e7edc2e7804de2865471ddab794a83fe074c0d41193df1c96422e6f22e022d82e01117fc58e72ce8726c680554fe1f585ad640b78b8fab767bf86ed88e7a6ae60ea468aee7b182c23fe19889cd26cea62770af15a9ccebe1aa5a26f2c4504c06a36d0c77c307408dc15c96b40934da993d2c2417ee98493cb6688ddeab66aadb59137a9c8c7a9d92e5e73bc4bdb289e820d5de593e50d36bd6805bb6d5566b4f779cf66fd9b243c1c3354cb6727bcacdfebba8e3e6201487ef9ee356877a433b18e6f7d00d3949810e6e2f83cd1490601417284a921e5a0efe5f8df9ef30a8dd8383f10ef67774267be4c45a91bcc7c3ebbe1a5be49821aeb691e01ddbc94c8107dc29925276dad44d9651e1a9bb2152752d01e1568b716d3ff0353afdcb629df044560dc13a5028b6524b1c095f50580aada29fefdb0b8f6840ba76ecdea7a6c93d1b03d31850d148eb30e0b936f28ee28f2b97fda06a1339c8d2c1d3f94cfd2a1fd47b424492d0e96249ae84009ba8927aa094ff675dc430e8368fc3913e400dfe13311c66ce7acf23f758528c12e56c8c323537be5624c215d45ed3671699a076adf64b88f475806e66296696dec9a23598ce601b46c2e522af037a359ee49d3f028fb70bc355908b095dffa703d0a7c43a73c07796142ca127bbb3d818b57dac0f921bbbfa2cfc437740c91f0f09b877c979ec95f0a2e61f8d20ff0220d9c29a97054e5b25ef9b80110b6392e6eb05516741949e4bee9fca159463e59fd4c80704d5f127d97d0c561114c9556270108c98a2f3eaa3939db4cf176e281fd77f5ab1cb2b616c30328cd7167c9ceb246c701116090c831d1f136173962b7e2a4a1c1713dba73edc58c6beb1a9e56e7de63438215dc89b601ee6e1efde9c9972e870df87b31f067c5d30205d18501f894779be0469f9c13ced26d8413eac3b8c68853bba5893564c409a2cebe4090c97d554b0231dea1ad3985afe28f6258575e5bacc8f944b7accea2105cb7013f1e099b43b0045e0719346fe65755125aee26eb87f499f7d91d037a4507012f795da5e3a21c1d8711ba748748196c0ea5f9403beab8724b7ba9e075e4c9b31642a83b319250cc450f1dacc5c9eca1c27584c51bb2c22387b1995309b44adae1c7a09a9a457aa72093916a8be0ae47cbfaf48ed7f7ec2456f0a785a13357aee4b918f2c75af7aec8368cb988bad5300fdac3ba7ea4934d2c92a8c810a4d9c002f8a9aae3dcd321635351da23e70475238a8d21b5fed1cbc60202a4041aba98e7dbf1da5554eb269d7c67609f9d1c37c897fc31c61032c4dcaac15a27bc0851030419bf8a1ebb6df1bda394afbb0739a733b7c445999dbcc7ac0a124d5b6cf932603c91bd3a6cc9710b54fe8baeee1ea264dffb3ee77fc776f07089ce522e7674f7bc7571b9fad186b35765c1d3b328ea8eb3c7c8b90e1d66135924490547daf62eae132c9096207604da2f9de54a5de4532aec750dbbeecda8c04eece262a30e5f4a3354414c1f1dc57d4ea17f5bf7524bfa49e2f9249925f23f153fab22c8997206cca7446009d201c5b10c3bb94cf9534f6eadea6f6dd281eb211b75ce9a9a90d8cf95d8351a96ea9804d3bf9296c176446a00fcaff8aae54a44902da4b7fc0056149264bec32a2542e61e4f07e8ed3ba9d188fe2cbd39105e6202be4c8c47f41e503ab5c4027820230125eb4b833a18898c0837afef157313499e4c8f17d85864c6a82fb9f981335ee913888e533340302fd362a53f2c7a9e9775fbf92431cfc47273da881fc53845ef93bc483002b1fc896def169fc7f3219be2ffb09f002947d12206d094176a595d983c8545b9d65d0aa2180aeecb58cea4641163f833beaca4f70311751114d1ecc96715bf536b6f2229d1deb87f665226ca63b8d7a12cd3d2537409f008bf256b85b643ad42f1bb40fe27f14b4424a18369697433ce62643148b48acbea8200476c9e17b7e96d1139865bb7b218457a6a310d2e355f2939786a8bf8f545006931719c4cd70565b94964272710e368b8bfb47cd3d15adf495663eb486e2de4ded34f913f45bdf48dafd550eea2912baf0922f4015ddc16d4c05a7575912b7dc3536549c79bc76b806d276ab7d4e908ce6bfa9be80281c4168e34fc224455c0f65e04da91dc59100da5d4ac325698a9b6c76264eb9b70a90883a0cc84519172764c2160088866d84b83e1824ae83a64c577425385f8e0e65944fdcd5baed0b2545e47fb956c113d5b280112ddeb91c9ff3ac4dbf95e6ec0a8006d46008ad40034c2fecd37375d632eb371d346ff575a17366f8f065473bc7ade83ea71d06397619c62891df2b5b4558fa2b5431b808a6ea5d35336b785f2c410e1ba254508eb1efce80e5bcf6f41f7aceaa2c3f2e92c084dfff372bc2f28733ca350e96db57e8fada0cdaaa2899430e1ffcd868e41ecb9cb4ca777a1be9e696af75e60037592bad0e26be9fdefce4861417af2ff9e1e50ef370654fb07c9967c4099c79f8cbb5667b6db4ee5ddfaf4af4cba38490a31ee45d92a78b5757fb3530580353a01b329582e8e8e837092c64b41e5fa5103b1cecaa91cb54ce457e18f5cc5014c623fb515cc2ce856518c3c78831e0bf83fc2d0902122e7d22fdfb7c5299fe6d98c836a77bf6dc85f524925b31ba186cd59fe584d62e281db8c73b07d03d0bb9647039f85f4c2017bcf8127e30b301989688a3bdcc7bcf0a127a0404dde7c459d142905d59d394468e56a2c5c0ca9754b2db797b3afb3e9d9efb722dbb8c7679479d53c315711dc454fc035ca7a6d263b82ec1898e866353d5791aa9576151f7529159e0fca73737b006404aeb500259cc01613b3278397a9369e3dc9b091c2e82955870c43b71449624b4dad63768f56e7795f2f57b307fc0057edf2d70d2a5b6399c70764aa076dc23c3f59613640e01272c4a7a29f1b4c73d84ab868883d43e6e3d3f1da9b5e410944ed0cd7c577191ea02863cac7b0359deab389da01ac3ff81ec8474435a9c8bcb9827d1ea30eecf86dd05acf885181b3499dcdeb53b040fd5fd6469918cc9cd8baeaaf03300ee43676fb258cb5bcc4b0ddad76b29cc947dfe22065dbdb951f60756d90efac0a1e70cd060ae80131693e3026cbccd66260afce27e892d04f2a99abae48d9e123a77585ed24158ba052e50a50b27186c6f8cb45ca89c97a3aa46b9bd116b466941c2b7dcc6a727bb0ddd6250d3f4e4f4cd2780e18d0a9af2abd949c3aa475862b6c0c2753820c91a3591640b4d648fd639aa5260f7e69450167ca9af948899a28cadd96631cc2cefb418e664254bdf81dfe79fcf0a837a55692d44d057b4e3a450187c622bedd576974314f81d853ed6d831ed0fbbab76e69c5e7e871fd44b4a8af1a12a6aa21476a41450e9a987303b0d64d15ca2df2934b75a00a8ea35592d4cf7a12dabe9a64145da105ff8e5ec68a68a982389f88f020779ff8e868a366f9d8262c4bc2dcbc0d626f20643b027d5011d5263fb6d624e9926b23eb511c7ce7188d9eccc9d23901c7042aaed77f96504df6456ebf5dc6fb6c9f2d8b2d0c5c18541bd0df6643d8ad1ca0d0e3abf16af778ea992dd8fdb581c5a0086834fe76eb78621ca0303f067eb42a5d35be36a52974ca535e506508d713a181a5572056fec4ba375218bfab873f55082666981cc8e590b1cb792812a245af5a2fb05fab7b718fd8ebe70927af17a33f86a56e212fae734c93cd8358cf83277f2c45048f032692128bcf0e1aa6219c1219ba0a9701756d99eba7740f63f65e667eaf593f69c3a6cab90275e91d06ce3b199093a535f3c0ed324aaecd2be6d5777ada98e8c51be6a3c24766c789281f745f10a4003a2061282eac7cacb1b40e58ac95eafdc5086af9178dbadce2fb2dd2e8efaf0b1f9ade51100c2ab2679203a9aacbe693155a3d2c0d41180405d89116c1f67948de1681a3c1c4aca06f713903491397ce8b41af6aae4d6f74b714aa681e1eab17862bc51334515d4ed9551550966becbc473bb08347f4477e940d84b3ae1c895e69d649322bd81e4f4e19686f0eccdd84c8dffbffcd5274709e07e181a59222a879d7341aaf1f39f2154039ac724c0886ca5f7a3104cba9a59f3ef55b0c80c078d36bd6a39fa6b39bf8d3bb5eb3093d6754932f08b22ab2cc64818791d09861173a8d753154b311b6cdbfcd6e6eacdd15fb5decf48de3160ebeed748cbf6252cfd5a15996b8573d8181dc797db40cca31bea28f1a6a2bc740672919190cb6fcbfe1267357d1dc9b6029dd0ebbe0c7eea908b3c5a7cfe64b86ddd57145e0928f812ab50512fb4ed9de6eb5672b844e83b3f7cd309095337e282ce85354f33c818c02c15fdc08756e144c3f5f8dff4e87ba848579ff40481c5b45ea95730f536481da9b95b365f1c34e7125f454b804ebe622209aa8c86c1ab094de2beee00e79e607ddb3ca88d2978591bc750872ec45fb8cb22da37e739e528ee5474bd2f449c36a313ce826dcf0758d99fa7a3b6a966c86213be278612fa96d99939f40167ffde14e692fa07950dbc45e0af8a21d817f99db73252a8e9a7977c207006119ddeaa6a838b07cc0dba0381ab02d5c7321effb1d75562453d4179c59028755d61646c4a28f102d8f810ec8231a15d1b3dfbfd37d1f0666920e8a87f457077105e34310b55b3b43b79fba508ba07bc8622fc7d0596842f07a89c73d5d08b0f464b21a068c0d6a7298edc8df6e4b637456a9d04f4c4c01676c8e9457b1d70d35823742898f6656ba0726bee7a66d67783902a94acf9189b71eb1f758d10532fde7160a14d99ab4eee5d5a60b1d1683b52a194ac1ac45894078e6b32fc7d27bc729865c1eead502178df33e99cfb193b1eeb50c0c0614fc270614d268fdf89cc16d75e6c6a4fd58e238d804bda48cce4bde00a16f6ec2043c2adeba15c9bbd0ca9d576a91ee951444aef1154b436a341ac2d8c7dd72be567f01795f541b163d6ccc669f586fb5f5a1bdd60b90fe004bbfd202bd59e2c1cc4bda7e94cd8d06e1c807cb30ccc93ebf0dbb5477e9d3335accc491179164809f4ab5b439894d4f6e488de1f8b9f257ac8db684f15147e6e91ff7e155e452e5d7009dd636d4c41cbda49c3a720106ac461a31ee84c9a81c3bc08160e9fcd132c98d7af6e4f37d18f78f863db28fa4aeac8794b571e5696f341ddecaad67b45df4483a180418f586dc31f49a2b7602dc0de737dcea56eab8187bdd92a9b9c7397aa84ceb9ca801001ba7cfc0a736533d79d1801d6bd688b969a6474554c0254985c780f0c3a6455d10d96ef122ef28dae2100130b592d6c25681609dfd892f03cc79da525f2a95899d034eddc6540047ab2030c7a70e250cdf850c201fdffb6d17dee4859aaae3e785292ae1d44a3b8c67e6de7d1727c88f8aa1a417dc1eb1de5f41bf40b7e3bfcd8ba8dd82736dbf9c0ced0d37cf1f0fc007d916f3c73bfde102b2c384aff1bd992bfa386e37a777cc9f61281c89d1a0d1461c8fb1d58a74a0bb6d3decc2c2fbaa6f7b7e5bea6434753c4f7b0eaf2066c6c6b11272ac12708f22a206c0b35548c80dd6dc37da54ed808b5e899ae5b90cc86b76259a239c7044b2c61088ebe3cf2771e41c190c01247a983a37968ddcc6ea482145683a846beebf8d648d1f50fa9c52a9022bd07f3e4d43fbca80105e8b8be79e1b72eed76dc6a40875be121cdf1b571b62fbc7782f52497f120f4728df1eaf454f6d2ec3f51e4646ddd0fbbdf0696f3a73648b68abd001a32d204a9faa748f321e653983f019b9e0b2d8ab6494791c91c6a13e97f5257cdb30acfa125484ba452c11cb8384748bfc0962f41c727469fee264d8626e79c470cc7f4ac5c897089999c0ad20c67638322f39ae3ca8dd735dea5ebf2a9ab567a7e039e40589601607b345fa77f1b51242cb009f1ecedfcd6267de294f9117dd5bcc63bbf1139f547c52a11eb62f55f8eab21539feb3c7356b7bfecaf340ca45fc11282764c53b1cb6a0643e7199058d0ce5a114b551a486f29449167d47c0b8673d97cb62660c93fc0c3b9200a44dfde8b21ec5bac8ba5e258889e0c8fdc2843e21ec5bc2494a5667cbfa76ef67dda9f5ff3e59bc9471a8cbc6d83e5f02235155471c8e98a810897805f6567ac0286d6b7bae9c1bcbb3857614ce536d148c59ac51f885123e5fd1ea1d2f15258058aec2ecc526acf829dfa1371eb944a8f1fda79fb34074be90aaddec064ff5826a74034abcf0e56813fa900ce1353953d2fecd06caffe7a2f4a9ddb36694fb9027e47c5684cf30b23d8b4e68f6ceb4e5f5dea791543b4b2272935b2267c1505de09f0adf1ca58d22eea6c9513ebef7e595d1b300c05c0422ad46869a801ae59cde5c1967411ce1c6596c3bef45612434d96d7f7d8acf11a1c668d78fb45e1f4198a1081e89e2f75a88dd36bf75ded3b8f4496406180e1c8d9255babf6369f38d98f23b62793173a444e256dd1e17ded072eda295304ffeefce962f2918fb2f0ebe2046f7f953944ecec2b69182c3b4a17f138481a808c9d202c53bf520c49e0833f4d998e6fcff80b1978ca1bc01633a6461498f1c16d012ba7771a521ce82bef180e64c869253a14f89a278aa7f0f22f92dc340a1aae41847731993470a8cf352e0ab2184a7ef4983e601b64af64bec26e3749a9e37d4fab53f8dc0da9fb3ac10f9fcab9c10639ba1f1c096ea02553ce47162b0a39b472dc6032bd134ee7ad70bbb7345f6c616090a71ee0754186fb823a626cac9bfc6dd302962c31b0d198974864f5c558a8a56205a1ed1c8fd929a2ffd0807d2238abda83f13b4cc217ea463c5d3dc7043719ced5522147b720d04eadc42d78cf4d5a6649ebe9c7e86b83865074d4f4843cb5cb7e54eec5431df5b42ff7f2e83ff0825d7dad6788a8563b0729cbe18f1fc62b89910979a79cdffa24a154790dc100c4f9f1dccbbf574b4df0a662e12a13b408c63d8c157d10a4d80ac53e6e750dc789b84049d7a688de287063ab11618e579f25260f57bc69304c21537e327927f6819cba857fb8c951140ba1c50f7296531f33bc4646eab426cef32a18684362b5fd1de9115717366ab820929a0340aa8bab0c63476c63d907576ce2237853d46d5a7661129f12f46e132a0ed024e6e88e7a995cdc80949cf35b86a1b9dfd49b3c32e344dc37154b3d2e975340b8807424208f2e56652a70cd0ec4b2965396d14d5b942f059797675eb840d995a2987d5cf1b108cebad2fc5b76482796b6547ccc01f884011f5fac0be13740153b0225298732d3bcbf17ed6dc517525a7cbf55839c75f525c14689da56c8d95abf861a81439fbf413b23c5d324b3051462709aa219c8e9ca4280fb00039ccca5d71ab44733b97d20534f364ac788ea0ed26e776617c50d226ccab3a57bd7df9970da8efd68b0a4268d24cddbfd4dd8e5ea2461cea1003c75c988f8aa9a17fbc16273ff31f1fe498e9910c32d45159c3455b9b09d3b9e005ff604d3defce8998be9e4509c1da692e6f101fa571b2114cdf6925aeba3ef29e98ec52b427a967c77dfd0506dcdbe9baab18fea8f68a241c76c0155f8bb5768886df0aba898302365b0a9a5512087906d08b9dd8499afc92d6ff81a7a0225a245d6d17efc38f4e0ed6c94776eb05f2c13ed7299774b7a902c9cccd4e2ce96b965516535ce90fe11fc44267262bed4e796e903f49ef74845a3fbe312ae73d89eb92c8d1a2c5731563f9cf7e8f4de3a77d2f4aa7315893dce4e1860dd31ea3547a387d134298687019f388d0cfa0f073c6ea2451f5226a90a61fa431cb736e0763187d2bcaaafdc9ccec053048e44f7fe0fe6a7084b9605116d93b515d1add3aa30258a97d083924191ce20a76b41d2374ae07bb1bcc154d088b31bb420055302b844e47c13eefd7282f474162847cfebddb8a1672472899fe2095a22047ac13dc936b9b03afecda1ca634d60c6244393c6ffd9f5b6d0132d58eedd1a1480ebf04d10c0a1b4345fb3ddeeff1475cd4901cec264837ce23caf20fa5d4dc908bb94abff5bf727c3b7718d68488406a246c237a559ffe7986ded5fd757bcf402e032fd97029bc47a35790d6fa082277c62788d1c2060fd8b5a5114d1038b09770b1d44c06a02746efe5a99b889a9185816e41ea8f2ac4c678a6e9a323ea5c310285ded1fab68f72f6384a54ac94e5952475e764174f9311c954bd289195623e6729752a23d9d800a8edd77f3c5ba7a4816440eaf2647a8e86afd6272328c2d6ed4c8ed3bc1ea4e0114cd288cb32a306927c49b22fde9299a1da985acc5195d073ad5fec6ec6cd83bb1e042734080dd82244fc11e7276ebd5865ef7c619ffee8b18031be7f3d3269e4292802c4bd076df7e41599b80a29b7f13a612df371541882aaf524c21704abd6c76ab69dd2041ce3d0debe32e0624bb61758c3e29b46c48f9d41259a9ac3b5129a54067f86cf7310d01f1aa6d47aa22795f3eac7b67fa4c3e1905644b7e05d0de343f352fff4f09d8376c24409cf7dc2db91f0883f30048eb1faf923278165113c13b8f4538f4866a7db6670f2886758897636a661bf31a0d2c0d5d527dd31e02109636645b726aba51cfcab9e820dfdd067d07115fcdebe4e78552f90f8d00390cf53ed839c3e753b621c474bf93506be54ed038cf09aa19b8a4ed38da5f84f866f5094ccca5a171d89db18ea3e33aa1090adf2a63163b3d33153561daa2112204c23959a58ee4252c15ccb84941c5a5b13f037bd7f6ed74d143e54f496720b61ccda1d6b03ee46d189ee2b57c9bedc6e5c60ac4bced344c256c157155cdf430f9bd767611053837a9bd09a2b8b88ff4d2647601cfb2353b9e6cabea05183769d08bba0e6223fcfeb277d42050d0b6aabd9c07ca723201bc73f8f39d1abe92e4788cbaae0da000f9ac418da812468883c49fda7c78fdd4bec3dd8cadc5a7f8caf4872349164457c6f9f00a1629536e676a48054af2d658c4916c4d29ae988885f83d1f7145debc08261e91f8215f074d45d85fb0f90477d765e4e94138c083b2bb0ca6c762e9ef86640ae0da404ecd1f9d71e869994b556973aee466744c3cba71be7369c8b4096649aa50fb6f7d0542e6756be566a0121f3f5f2f012e4968d33ff1750376e5d6c29607c48c4b0ef73f95032eaa0970669ef8436b4ca58d3702dc5e870a548133162e988a21a9ddba44e2798c17d7ca0a87ccd8ef310b5f35cf12ad113f5b21b8ce331a540e34c395632bfe79355dc2995b2f0ee22c6593b37f1579b37e7df1c381b5d4ec96155df214e253ea20205ddc0b0ea12d64fbe27de802f0dffd4613866990aa61725eed22599f2aece4a1ddaa43ed66af995f1ae5954076537f153d7b940829321589c302037f841bfe3bfe1526dd1af8dedc4f742c325cc6353a5d1cfcc4eca825f28939ac3b9bb0eb10148ea064c555c792d68f7d0f22a983d7b9d552e24344f8d0b7de3767863259933819bfc5b465cf97dc44faa7828fb5f004df11d4225902f1cf52524fcc2fe4d98f8fbde37f03d5f3d7c3bda8a18d90a88f49aaa5b2080c49a8ed5ccd922d31f9781642f8246bfecae434fc339023f52070c49c7ec710e6a101f913fc3722e15f3e4c85022153cca3559aedf6fca2004c326b2d124870243a712a71f0d082b0e1c13fa8b9b31d8158e391551b54258fba646c4c39505c29bbf8f4a0bf625d9b22d7e4e3c6e1b130b8f64155b26af8a2ea18909e8d4f1ee26a3086ea50df7ac8e74dc918cd5fec58cd623d5c7037a60f26a9cece7c6a35808bba8ea768f4600c0a5b4c7f12bc444ec2e4407a328f03be70127b319ea15d0807b51b1bec7d633f0ba36fe3358b56a9228df3963f5d3f7add254049282876349534bcffa76586c11a6c8eb72276c6c7ba3234d693505a92dfe33604adf956c28245ec9d3c1c045b932c1a9d6418737c834575d183a821112528bc534849b89bc8fc5d2d0a7da06a0806f1cc16b6ea1a99b5ac76d8112aadea55a6a1f694c7702a67f56f6352195c7f514f503e40b46dc3f250395da959c9e4ce58b2020d9d737ca1558556044e9cbe50000b8f6af7458c7a77523d20079e7be03629bb389c676c298e7aa2a0e0b067e1903b5255a14f1a62cf0886f50e32f64f2efdf7ea16e7b014aa6b5ec02900c71c538bf5cfa2efa3c37a0ceb9d31dd0b0166ca7e76cc99552e5f252dc13d159cc61f4b73fe7847de5c39f2cc4f82bf2bfcdc029e95c88859e947019dae05db9154b704188526cd2c0d602d7fd1dd7156fd3e18ebd8080054688c7bf5cc22ab8a507ad87de331eb1039c305e4b14f5510b292cace084b02608a0d551337e4d444ad9e53304849172215dcf2356b3c4ec30808bc57a82818f281a9de1812988a20758fdee919603841751608ea7e8e9b05b00419f963d6a896ac20de5e5d2d4f4dfdf4b9cb66c3c061beb19079a75118302edc51d027c65a0fc6c34288a790787844c107b2e7925c7c6d53bbb318070bc162efba0e6467502cc8e5dc3b7239875233acfe05f2fec28726f435c28a51b27167f15729bdd9150837322c1564f365135ba40924560020a4ee6944114824be450eb6270d3d4177bddd78ea8064e459378ef4c0c1c661c5ec02845240a4d4b3bb53d285ecbca7333fb9be387a38dedeb21b5093280911360d81721e38a630808b9fe4c4bfbe4b0e51f78f83f1e9bb978704d3144a3582b8c89118cb896f39f5b1e43db68267b05b38b6f87c64e61fbc0d1f1bd1c5791a20e4080c0e22512de88890a94235cfdb23fa6c1cb8d3dae0858721d6f9990ecfaae7288003b0ddc68b054c90d4b23b73045667a5c92f8109c4611b24de8656d597160e2ce55c302d5726b1b15f3676dbd0a6282d26493de193f69d214c9b4564b64cb5acb1c392f541d3277ca4cd7987d579302d45648640a4dfff8127018653f6fe2ffe7277d71fa9fbdf4e1a861f77eaa740c57d0d6c63979385be05697a9eb144d6c8b53bedd853028e41f21af4c01194b210f4c75e47b8fd4f2ac956d02842b12b3afaa5f1f1380a75a76f31c12467f4dd76483fb27d291110db6ca66e7c33c77f72ba68ea6eea6c8d873aca7ccfee55ee28d826c5730f64ea7801aa9c20dd3a25c80be48e6ab2466e3e944edda7e4f11f5e39b48b759fd59791118671b8a27030265e870574a5b3640a721ff9556555ca39ad517884ba58a25dfbda6c7509cf032cb2380b81115588d28dde942c0a1c1f90fbcbbd30fa83214e105ba6f6edbf0407ee955dfd5f0f629408d2a3c1c16a8907035d240bb94ef43f86c1315f2ea0ea4983eb05a280051f2a79c0d540c8b67dc519b7e53940b9b32f0b758bfc08b73093f73d8a5e8cb0c34d9d89e0b8f40fa69cde073523aedcbecb51815499902a045954696649c3da9c5b32ac920bfc2e6c5cb4e9aa005df4536e22eff39f6ae234111f41009af371fb89a7d57700578626e2b20abba7d7dec34a3a987c2603353f23a853bbba3e2ec87f618019bbd24d672dce5cc5eeeb6c2bebdc86dedead76c71a8c52caa67080cccf97caf0932866020f2e475ea87c7494072eb0bad7214e9883f12e06eb3ed7b4adf32c72e6db358a766b8dc990c0127ec16be3f9e73bfdab6e920b52cc56889feba59bdecd1232751a12d1ef3647d667a2cc7eb0ef905c7e36b9485c2ad93de386fef9d27667c766fc677ac9c06e963dd644dd934a17bf2adf7d7f72612092e947f981dcf6cce45879a02cc703d55ed0741f22d9a90d2bade99f7bb9877c62691a3e2534df59ea8073d8c1a7da238bec8e291faaed705bb27dd33246da8acc7a46796960c59845a1433f9d0afe6a5d351bf04ab77da2d0c4726b571fabb0f84e7bd960992ed8c68199bd1381a03a7446295de61b75978ce6e4f1352ada3b69d6b231b99ee2d08f563b4e9508476708c443b8bcad3781a15b739da6acbc485de0428f4afb392f3490125f8db15a9d146fc35929bcb6672ac0fefdd6553c327a566dfe531601fc54e27019bb33a9d8e3c7a68d2dfe4be76d1c795b9ee4a54388dbb8a447f28ad49dc78020425bb4497bc14abcbdb25b0971b52146baf7fec7804bc5d4a09f879ea8e83f3a6c7d2451b3a1f7dcca2585363a858ebd4e5af704987071ed447fd2b1dc91c051ea4fac9ebca8a3d0b45585ff952afe5fceed6c30f1715e026134abfbf35b4099b4911e23010351733a971b0db6d672530437ba380d36f58b29bede373dec498f0894b01c78819e819152d9c5a34a1b4cf4935bb36500886a10ee626b242dfa3851862226c4954bd2ec948567be01e04d8589524c1d6da639278ddae35df725c5c99188eedf84ffee5bf26b96c1746515072ad2e7e45a9de86c31c369e4706f97269b1684cea23816eb6efa9dfb928ec61677e041624b31323ead3c1c1659261f1706833f8d241f7791997df6123d878d474101ff1059c25052a3e7dabf89702c37487382f558440d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
