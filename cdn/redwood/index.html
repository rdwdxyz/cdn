<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8ee4a587f24ee1647ff83df46e5ac0c5a701655b0cf760100d15dbcc6459402e6e2f53cbb51b9ec5e22d8024fafe0f7c17177ef0cfa04bfe6738ced5309766bbdbc7742dcd611f14396ded256f0109d16e719244c488a08b1bc40b801294857cc090c95ae80b9ef61d308244805c5287ee80e7f0aa14b0efab7a9b6e187960cd46f6c19406381e4e1f1becddfc4e41a9efa9727ecb1caf2c9ebf6927831f7ab57158ee43af73e3e77494eb2a01846f21ca9bda9d531fc19f849f07dfa08ddcb7257ae4516f909ececf15169a836f422b7a2efaaf048da0c03190a11b6c78592a79475ad9da9e20899698971fc37a6bf4afee51150d069fbd668ae8229b2e41683920d683890d9e4cb8fa355dfe3d7456eccb005262a2522034cdb93a14fa8c3256edc934383646aee5046ec075bb615302e736f8a2296fb8735ac30a281df2eb0a98b541c22e3492f75ee4a02359db18373dd0a44d7d1ce0956f0a67bc626318250e9e2fa2e1116f7443c1dd89f9def454ceb11fe0ff3ab66723fadb9dd4fd0da6c15ff7cf19fa9b38a1cb913b1606e188466c08036556091a0c24aa3bc4f3e02c4bad07568f0c9bbd792e83951a174130428a70d71af581fcdc4708753171ae53d902758e808075310757f530586fb5362d8fc087e23cb7954f9a0981cec11660a1a90f14772e9531b5da4f9c083449a71a05e75f2e24e7d78285bf47138ce9c883ae02b2481f55b662fdd85802992107b4f47c816271fa0f86d601cb0b2d1572ccb6a385c2e560173a9af40ac67bbc1b3e247f9a559b9667f09d6d0dadee192feb718e174fde517d27ad8b1053c2a1544f2b9f9f5c9d3c1aa1f8eb99e7a94091b5c859cd373cf1520c9399f458ac0938eb367541e5ffb19e29a30841a22cf16f8cced47c2b416c71e660062ff38ba8077a5a1d61dd617d8757bb226e12b040ee378c80b5824c8d5ef6bda62e83beae1a637cda0bafca81151b740e6d0aebfae9453b0d22f795b7d45c28e3e1c933d7c635677b6d7cb81982a74cb663cf2d138518bcba8dc95bdbfc0b7895362c27e6449affdc52890342786f5db1848c38c97d5c459908b062a3255b319c5fb148d85a21f694b5e9efb0efc2be8d24e63b8c3c00a13e4db3cc9b58ddb2f0ac9c43313b34260985332c896e6538f423266d4b99edd25ff714425d41a557adb25cfc75536c05b9e391013ddcf2fb60c69952479ce92350e794e7acb4bdf455ec05171cdc29ad7422e9703fd089ee6b474f00fe58b6f9fc272f31c2ee897253754fe8e40b7390e2f2973d19b30b1a7e3d85e79d6586c73bbdba8c124f0da309891ab313b347936b7943ed9cfaff3e538c59f0cd11ab4710ef9e59f77b4c021de4fba8daa4454983df593391847acb7b0518d0bc16720c195e599ba6b154782e6f89893c415f22e7fef0ab4609423777e4795755611d125fcc0cf8824eb2be5cb4b7cab8fe147f2a29ffe1b7e047c6ff8126efcc30f659fdd3e4a547409ba6bf76135a32e699560a299f08aa26e80c5027c05d5a15d5d0decf5164eaea84c53365da203bcf3f57828b37fdb71027be28fe3a498c06561551550d4d5bbf3273180066e46d92a061f0309518cc8b3cb7712d7b3958f2b89e4d59dffb5b12497dad5e4b680fa81e57097eba620bb3d9b2ab387ca0e16ada0697b5630bc4639072fb1390ce0858c69326c5e3a423d5ec15921321a61c3b2f4753351b2020032e01c1d2d4ede4a4b28160e6f780dc5896c3be92e43fdb6e60016ce99cc1f1e044c0fa950ff33f54c959d21dfa61a08b57bd0f27f267a57f4494aca0a0dea75c285a5c90465f50cefd91fb783771fc0d921e53a6a90cc176ff702ba336ec80f0598eb672667b4b9dd3e8ced0f1e3bdfcc9f87fa21a62e640ce9bce0806ea2043f4c670fdedd8bc0c8047b26d70cf950cd88f31e0943732b4ef576d697c5f12f8c791a195ccc2d30e15f96be6a60f87b8314b16ef39c571bb7e06b08117195aed4bab29b9d322690cbdd4c2490aaf5f97d852a429f8968fa9f8cb1ffc3c43a8fa8a258de3bb968d7dbb25799679dbf70e18e9cd59f1a58da66489a280e0a8f7721a4f8f60d2d9e549b920ff4facb808055ead6d70ca765bb0b5bb41c78d57d164da230514f8b0c0bbe374809bdf36124df4d37537eaa2f92bb6473691fd4bc704977ee39407436b4bc83ace48d2083256398cc2783a9e9e2b7d384f5541432425de00a2a69ab771ccd16e5b466d8c1674f986ddf491b9024d89d236b22936edf5664c2fded868d1c5c9901d4d0c8f3785f1303d0276708a0dd50f54063231899fc93a0852f76841a1ae5d14fac198d4c7902df795de119ff7b7fe5b5d4d06d0616ec5290d14a21689e17a9575b69d56ccde0b708f5a607c157be8b90bd53edfe32c2b666d80788cdac04d7b24ef45f2a4d63532f54846bdd81231b7603e23d1b187cd12d08e1ef218ea8e1f3d143fbe29fcd0aa3ab45e87de07c0887ab569a571bcf17c63b228b11a270ee3839cf1c559d6c113755848af9685c7acf36dc9026d54621517c996cc46fa3ce05c638c67dc3f14b747e3e159ca7fca07b6594ca1321afe4e623be954d48e97c9a76d3f7d1ac970b617e909abc95be2dfb770f4d479054ff948045b6a4ab3fe8ba51239ff11556043edd5d686504bfc2bc9804f8d954edf51e65795082f5b61a68976bf7e20e7f65b5f2705057c3a1e4a7437142ae80c58c3f21948630310b547ac79323460b2d775a07515d660526f7f3ec623217a0e8712253cc80c3bd9b8cad87859896bc948b51929a4ad66583ee2f3d96e51e31db6af68e7ff4e03a3e9056fa7d40d4264d7a8aa2c7d1a717f1f0a76ea23c2442756b2c63335051d250955005a8449a94bd2642d166cc04ef853bc8593fdef82ca5e2e1b6f6f9e3028a2877e679f9c4d42a3d1af139ff53f762755e7a0507034416a8ae0676b035d8859218ecd52123bfde98becd19f22ccf2676f27bb59f6a7031b1099fb842d7989c86d5848333438ad3cc03a3fc6a57c3a7abfc9b11645ae12ad9fd8d11adb17a2ac5cacc3dc506f6e32ec820f0aa63f347f6e62daaedb68ea8cee8e3af410655495b4647e491eb709b9886e9d0a4ad77a0f3b81c2940fe8708af6c0678c535980231d62ef45ebfd6355f4e5279ab724518c87888967746473ea69a64d8c95d0185d21243d8e78647b283cf7beb75db417a5146d74e1eeaaddee64c62c05774c67463390a41d260e3031ffb1d22cf2cfc5e4fa1700da8aae7d8be7436406fd9fd64881d8f929980f841ce3145bd9493c073f7fedaf140374a7e5fd0af77c011d095fa612181f16863b7cb9f46a4d1e7259cbac479774961fcf4ab51c59113ec51f4a8a234033a0ba5b9558e2496f6eb7d2a51b0ac4503f1187bc1947994efb75dd63340b58cff7fe7eb926996df2bc8c2e642a1448581de370125a1e04bd6463c38b47ad341bcaee60994adb315bc790d1bc8edc21b3af4c99974e71a2fff39819b1230ca6d04c6c03028e88eb4c2c45eecba744bfb107bc389ae5fe38e2d9b65ddfc8efdd8e1aeb08227c8e8853aaa631cc93d8aaecad46642da2e51c838d2bff9841b97a7f555b57ecb6c7aff1627021d528e3062602240816cd552cc52d7b985613009f7e49e28d421055e9105f69ad23ceb34098d31c1719201f9cdb7da83d65c92ea7a742e67561635abbdeafc0a9e4e12124c0206889ce5f0b286e44102f08703096092311eceee7f537621d7e9bc78fa69d00cd6e4b4e8249fbe110bb9d2b20a66d9971ca24a896e000668b0c12e9113c2eb2a0ca13d11af9189ec43cc962b73350f428c3ffa34c6c6e5b2adf832dae81865a6a6752422d76fd8d7edef06c1e72b5004fdf3b36865c1c1efe74b8d1485b60445d66757bbfd78efa29f39526d254f0da31478ca7cb1096e9b0e02b1640aa91804469baf70bb1bca8b4b906c9a8361156689167bf73606118c50bc0cb0a2091e563bc474d9856ade2f463fb8857b7c94f8088704501c410c26b548c317b9609c7182f79e14f84b7613aa5c96789248f6ef9dd6660381a9bf050b33213e7625c739b211f1e708613aa8299b679fa307a1158a09b5533db5779ee9f86a6f8d443e3249a6ab6e4fb18f098e757e23c5c6208199fecdb6e441cc41b571412e10e994a73c54d8c3046d318029160e4a46f220e73eedd053a677105b3191b5ecc782a40da38db072cd9fa5ed1966502b168dbca248289ef42a738bd0159320ebec1fcee9c0e6bed8311187035805b2d5b7e1e0bcd6a2e953ca1cd86dd3a9a9b663c54aa3d4acd55da9aeecd1aba6352723b819ce3ea41e20302cf32f9e81c6d06ecd842cb44ad145ec7b1d1fa5a5bc07d3373d157fcacc5617b4580fcde00b24dca44eb52dd1a48f0e33a5593f5c17a4f7a2027a4e97aca48b596d3780c15222d8e72dfa9a8fbd977eba623b7c317733bd80e2c51f0f6d6ff1551cb1b6672be8440504c50ea3a4a3c669127f8c055dfd32250d817603873d67e363b3de2c12716e7b2c855bce35e70d34081890bb647a3fbcdba883fa4d3438d9bccb25aa7ee39010f0654b454ba0a6deba3c6bb7894a46a99b32809bd6019f09d9edb6e70bc6175aed7bc223a130baf4fd8551551b367d439d190b7004035889bf0dd14d2a10dd29d47fdaa19de49b7b829c72a083058b076a1c9ebb1db91ba3bfc94bfedc671e8d564a96f40fdd4f63481c3c074ee48530f388ab838d238742624e74c4039dd661731347a5c193f8b6f906d9f534a9feca3f00672dcb227813b9b2b4c08cad43a45c0ec918987e4ffb82c1db4b301ec8adca2d34547673d913a90a509939df41375f5f3801c1ee6b0f70c6b6550078411beab172fc728e207bbe1635267384c4552e0fe18526f26c5222c4a50873162b35c4a3e413dc39e9dd751903544dc128d6d5016a8379c848dc659ce9753777fc62b413c60424c5f3ef4233185fe215fd397fdc833d06f344f75547c0ccc2d8779f272c5829edcd44fb70b040ee62790892b5730177eef2ed950e1567bc809d41d11badb2592512348a182a7d8d4f89b65f1ff5d2d0e46d8e809c2e1e5bbe698c4b6f1f3c2d8664df329edf8b28c2061a38ecfa32d5f1ec43877e08cdb62ab7130362b0d23dc6a7762b434eeaedf235cc6183892f9fd19a982bbe52fd0d91a31ed5987824b713a8009c1a7e9a42d483ac4708c31446b8078868ed5d0b1ae3a1715719d3513d516c95fbcab98f550cd2d688cab7640e4a0beaa27944381af0b8f319143e952583ee7fa8c5db1df35c9ae859ca6ae0cc19fee80e76f40bf3a0218c394f5e6ec2a03d9c0b5cb0d8263730a4d8a41250f193ac930d95b9b27933fc9949575192f71c8dbbeb44f606756b4b9f1fd0afb371cc24788b439e8873536ae7333ae9bac9a5c4f0c651511fb7254ba3f8bd7b1545efe69b1c038cdacc71fefa703782168ea1913160039424afad6a8b12ff196081d7761b329a561e7d937c78f10f75965f870bf7ffd18199d65400d780a480fed91f0d0aba88e085cc92bfe1c01d4258494b1f98de1c677637394ed23fcb383769cc317087e06a2709149f1f0fa4825230fdb57e92733da6c269938dddd0827494a23213730396b5f206d457a0afaf96015a9466f245cf70b1f7a8080340beef9577f732e6fc8a4ba81231aa8dfb448b6c19bc364722aface98cbc8be7710e2c251c9c8d106b66ae161aca70d6d841754c59963dcc049deed4c47eacc92a2f482b55f2f59466bc52b1a441d23f5a80721618d1a3b5b507060941e8d1ce4a6187165a2d31cdf40ec15be2a37d57c95a8ff6a94f1bdd3cd68a99ee7784b8a2b0585684c273862b32043db8cc1b325b08c4e3e8a89635681cc40eb58ddc79473bfa6d372af2e5ca84b9709cb85a3c39be41fdae4f14e6f56595c002c20d939a3d3415d1444574df47d2d02a7a9c1afdae7b9a0983eab8174727ffcd6de23ff970c29ece22ef903769e80cbbcd129db54b3dac408bd0765116306a87d7cd5431bf4d0b1b3579621f8268baac3d44490a9b068770fc9446cf048f78074d7ee48ab8dfd59aa13baa3d24fa777809c5cc0f17cfde09fd3a7422758d6cfa81223a51b7fe5ea4b7b8d8ba73b02a5f65c6d57c6c102daf2db208c880699bfd66b72d08f6c69983cf98e89652d5c113b0ec196f31d40dcd474c596d8d300359e38423b57384d3756a4387d943972e533efafb8787f0d7b999c48564be5cf6b4bda8e5a465c87b9e5048b3525744af75b24ce77af457d7b7edd956faaae3616379dd353a55f51dd49c2c25b055e60a6dfc4f420a0829f6c7af385a4f27598350affeb2f111474ab0dbfb5d9f21fb210f1d571ce2cbd2b7b2197cdd98f3dc9904120dbf1bc1db4ce24390113e5da3c7580b27714f1d81b4fa4fd4b5201850acd42c74352d2b95af1940ae93bd0a9ca9b877173443d9f90be3f83d85b7d2011d361634f56df7ecfdb7cba0966647dd3a7f43b6e011668278b56a4d8fabf4b64048f13da19f7a288a24034997c40305dd4e9ccda2e1abb7c09bd9a2e0cb2f068b63cb6d88344791805f75514d21e5bedba36bfff3584ad9bb9ea15a241ee105b554bb4605e384cdc9e03bfaace519608fc76bec0203b97cd2309ad34ac2f3d341148638959d9765791ab3b98c5e65d1a0bdd3baa7a0b558f779fcdd036d4b0f239e47405df9abcc48478c6deaef47be27ae553db19b53ad53e41e07f18e671f9dffbe76da074da09a384780b079c32c03a30dc44a3baf3d3a53335596935414edcaccca6584f7f3929e67aa66de754d3b7abc19865a1e28e4bc2c8e050cbcc5bf405bb330bf35ceba49cad4cd8f2b8d1f33d19454a7637918cacc30902d7f77b3102f7bfae29fc2ed527cc89814ae4a06c8c24601ceaefbe82784574bbd7bbce97f4d35179ab4585e16fd4587de78fc0b0c003a2726926fbec4bc374258ef5ad0b365b31811b08044291582dc7d2680a7a66fa58dcc5a3a18a371b3684a9e4666227cff2bfaa2bd6fdcc59b05acae99adaa285031d4cee666f6da5595874fd7b4725d280e7d451af724e5d4cb061ed79c5648f63b766b4c605db40a5f7984de9619e2b41a4be21d1062cc6db22e90343e911e07f934d22d5bf500715b419fb56de9f3f5e2607871802bd093f4ff3502502fd050dfcad6fcffa5ac55097691e31c22e477dbdc819e23526478663dd43414ad2962d993abe3643c72b890af32278e7a033fceb2afd35e51fbdc8e5fbe39850185cfe9e1ad49a9f44d3007157498289f3f5f5f37757a8e5a3d838a200fd3f7ba3dcdb04f638f1b85374c5941860e62ed19e984fe74d224155021bf1defd1a61fe4522bf170553786837e2df225734495e19a4cba81cad54c0939bed7b1cc07e594452a7f8ea49ec05092fa381722b61af5c0e2a4864a145c1758bbe036ff4f2a09bb2fa6808d3dfca3b1f2a0b05e1cb651ccbfae967a210df334848c34c378c690e2c0ce493c7e707435d12993515e948b1b3a4acd3cd552a1c1a2f804861e0b94955022008142741a609c6938c3f43e94c613a6f916594ea7fc05688d3d5fea032d3bb8572accb0d6f3e9f3e147ebf729234339b1413bd76259ec13a7bfd1dd84d45ce061db6f30bbf93726fea9dd7be730b5921f330daf2698b712b17a3d8039fce3a7214e213adbda65925b2c0790946106a50302cfda120b77d4ccfeb455a8732a05c4cd2faafc64205290fe6db7d1c20fa13cd7995e1e53e31014f9f0e7ab1312a3499ffc282d4a14b9a7ec73dbab1bbd496d48c819ef7c9b1342cf79db9af4186faee98c3f4de4751afb6e85840b516d24c38a4008259d8b9fb597b80b131c3c7a5f3f26cc3d8f4a548e7debf4ed1c32e9393cdf503f6dd03e3ee1c6e11bc6a482e062b802515c5532b477368e9556a377ce3c46407e65861bfbb8622d9b403d0bd87127bed4ee886c7f9d79074ecca29c2e339dce32e088d062ba13bde0fa2b2a7222c808f8b5b8dfaeecdc09d36c7a33b6d990082c4eaf57492e330512d90c4404e6fcb69b2a301cf733b39ddb93dfb0c3473a674363f92bc0736ebb162bcccc9d32e6ac5e40e9fb784187a4bd67aa850805371554f55b1ffc00946201ce2a679c01bb2882cd20f5091e16d71ea05a87d7642739cfff9b199ed204b73b8c494c596acc200094bb35417ad30e5833b9f83810de42a916746b3943571bc854c5a01e391860c88efb7548ff656ca07989103651f039da170534dbc06be06756151437036517c7f0c73a097682043311cd4a37279b608489186d375775a4129738979f2fad3c63ac5e8743e620e816569cca1ff4364b4b87c0d38c8990157d173c44ab97bc1d13fb2250ef947434a3da1ba423b10e1947ce198c02c414835c47c77bb586931b65ded7ac312e3d0989cc9c870eb30bacd1b0955c86220163fb2248e291340be6b9bd3d82fa115377974aca88f13872f6a70b06a2f1040b1c13ee6e964f7a3123b81d85e0575e1c63f323467771f829a43405daa16f89e4df6b894e09d38068ae92ad5efb698b374a10eec7e8849d3118ac9acb09df7155693bb0e401eec620febabf8b2556fe9ca1e9bb951193acc3a6196177a893f330d0220246b9a8f48e5b81dd621ccce23a32bdb4329e635d87d8fdd088494c93ffeea5a6c3956547ef4aec7c8300d6d48b599a6dce892b4c1c4da4c7b3a558cdcfdd548651e0e70ca45be92b02f77700d41274373b6ed651f4512f66177443463edc18bbb428e00037418edf35adbc2e471376706b86297a2e6b78c050218b288c8b08e11419860157328ef72953980038ae73a859c1cdf2350ba8dc5f3466e02223aaaf9fdcfabde0baa6e3e8ba8a97ea64fd70ce2c5ae892bf52651fe04fb23d5d5b5207b5129cabe3abe4e5f462ca7cfdbabec22559516bbe311b039382092b20383f7dbac920fafe232977dd0de99fe82433a086a798c6eda526707bf4398623515a604e1165e1945fe279adec500c5a9c109923fa22e67bce697e8b4eaf9182e2b1d4525344b9769d5e61c138c891e3f469404f6738875c91ce523ea71c9219e52119dbb4013ae9ddf29b5e4c22c64f8308e85d6df43a68d60ae436070679ecfe6df44604f64883ed71bd012ca053b7a7a15a7a1292c305ab39b108bce5ef44f54e5246890cd2fd4c9213872eb328d5f4d0447c1e93e670302ed4ab12ba659ca2ed754502fc72dd63c4c3e6e51519207e8e6b9b123e576b6aec9cb78eb5280d20c1d83a97e0555587a8b2ec8374d82f51d0a9f03fa8d43fbd681c824c6e8ad5dd6fc51ce5a4a1283e5de61ba0aadc4f73e4afbb912498a2314c37b7232042ae6ffd5fa5beb0e382b310389fa3dda34bd76c6ba64affd405ebb53d86a800e3c09f5363e708e87ddad088c7cb56d754a2dc2fcb782f882d7396f29016b57903e1a15a2b2d8336ddd2e9e2d336cd706081268b12a2a1db2b95cfdad0095c240a7a00b8305a0ebdfbff6cf92cbfeb18c725808b5ad0c21edd5393fedb9ab5ea4092f017a33cafab3d4da220c9a53bf019e5558db9da82386eeaf684d14c824c1255d659858fabacb1df7189dec5d23279bfaf6400d2de195f994257136e6e354e8250866154ab882deed6c33bb41d5359951a07a3f84111e5eee1397bf2b9c658c40a4f7046970c20ac6740ee90078cd65caca713355408795a0710778ddbdce2f82d3b579ad7d4da30e579e60afa3eacedce9ba0a4f3ac092fc62a180eb3883b1594029aece092240f8178ae6d49d79b2e69db90990e1fb2da867997a84a0a943f431d5fbd12fa3d34923ffd6e160bae88c2da9ee32b28e2167483b2ea5b99cff7ba91bdc505be63b37a751b7ed3a681c25771690c13d1825cf1e39868d50b86c79be06520e8fd01399acf0ef55d4e58cfd4a4a2e963e4d11637a4bf47601f32d4956168e1a501acf1db46ab1074fe12ddc135bafb586184a250a491baeb87763eed8ce186b654cff54ae839dceb8761d0dc9d6be6ddad10311c7b3e1d27d1715a3fecfa5f377042d9b2f48df9c997dc1cb585934ca5b1c8bf819b2fcb2077452bea28b8b7f0ee639e538bc9fd333c3f1ec056599c69a64cd6d529cb257171b8f3d0385f0b95f2b53ca6ff9526ce7c7ca60ed1d781ab730f0a0f3642a66e9ef4aa61cf72d3364a1ac894ea33cb34e2ae7cffc10cca931b454bcfb9f7d50dc279f3b55a085d29e114ad68eda48e1772e33147f8e7736659646874908b6e4953b4151042c647315ce6491375478133cdb67c6e06cdfe80c5a640f5e267ea8c2bd253f6ab3207f5b7e22c370b781af57ba264f776d67540cf6c325ba842c3b6afb1edd28d2142cd67804da47ed645c2d97b6c3a324a3c08af500d78e9732d8c879e58bde7747fa128e5521278de50da473aa2ffbfee3e49b624e6ca868879fcb141d2aee56367f0e1dce2768fc572cbd4c55bc1e486d7b508b4b42ba1328ce6429fc4fe3fe94ccaa807e252e001d4bda104563b9f5e0a6a293b70cbf7c3f43ff98851230961a4759c90d31c9ccb47a9f8a7ac6178b63cd8369d4ccd7189caca59e92db4b97b8683001f49deb4b6d4f2578fb4d3561d3dcdb9f5aa1fc06280d12042dfe1c6495671808ccd420ae54d3f5cf83746b82b9be921e18484cec1d641b75146c0b7f1bcbb5c4f71f5005d8804e104eec175a589fa3d7d55040342669296a7ce396ebd7e9772796cc3dc5a7a0b2399d84df1eeb1504dbede84c91c9b15ddad4c5426572ed11f3883a02d1261d0adca80de60d7d418ef5966901ed7310092d7e1bf424a5b553eb98d8b7a8331011e1e42efb6862c0c34dcb962f7bb5ecce6e59831dcf2a781d3ae169c23e7748667f28940b20086b0def293f6436954399e462677d66f72101088552105ad63f12348206f74801c7e92991e1fe6067b2451e3d706458a8a3e7652b6fad92c4e02af8832104dc53d2351cd12b2855259d224aca8cadac63d856b0d609c93cd63f8e6bd9d0be29afe9c11eff66823822a79a19376df7b131670128e5adf544be40c91d04909eda800d193d8801667865468e31f5607ce1509ece346cb121ee180c58c48e8052c61f620d331118ce73df641a42474cfc97a6ce281faff55c5bc4775e1c5f6101144f0aa6a7f6d25cb189252dc221a9aedc275a3e4b2a1658e54d8c4b6b7426ac70ee9d54e8e609137c9bc6a019cf72eae6b9e1eeac47c21fac9ea9a9c3f6df7aeefdc002048a5684308cf0a49e235c4cc065a3f5c28c8634620142b9f4a18a8a8580c551cb63912a359f183c0ed1d4411a915f26299133ea8d982483205cb758b7ae4f43c77ed082430c2fcc74ab3dc059307d20947397aaa33b08b4950bf9c51d2f2ccb90fce0e4fd3761dacfcc7b10b9572dc3ad6198779abed005d5b3874508d86647ca09bc8d53b5b6d15b9cbb650d3fd8de5e5ba1df352ef4d8e91425d215dd9e87d0ecc4704c7eb9f4192997c0f45ec5e7adb3ee7a7ef10e70db0cda3f1a92b6cf9a17dcae2cfe5e2df3daa801a724923fa506e1047775803de4d7a487ec26e50ae10f704ef82be6f088aaf18f2fed3ae66e216ecff8cf3b453749c3ae7a29e77d78c5101fbb4fed7f13d583b5e1a28a6d166fbb30ee31271e64b041283038e9d88bf113727ab980714fe0db2e4a7674debfb765668ab268eca7166db6a531a8bf08c7ac1cd78df9f186b5d76d9643fb310f6805ae8a670e8e7f1cf15870d265ca1e11294b63f99710fb4bb81bb8167e73571b10df30f498bfd0c3f1dd1177391826c0470718b28390de6970152de84d5f95875e907f7c0dcfbaa21b0a18c7ac734e683499697c4bfd108b4a3169492ae373307d831fda279956fd57a38ea1bfd5ccae8a05906b8c284fdcad66fbd29e4a423c89e8b2898788755f883f875e1badb7da556dda1e2eb63337d21d6653a76ad29566311b2550d7cd3949f48d8f13d853154451a48b2528ac9f7b28f393f9cf604f87e5dc7235048e709456f61ef1a167f2cf8618897435629c45e1b6b062b9cc528b2942f5fb74a2097a9e5c3fc20a8b414a271b90751fdbada5bce31d6cb06c1c628f689468a5e0a6f9118a4de49417daff0301d6cddfd01f4290c759f223f773b9ad46e00a9c4aa3ae8d5280d1993696d01e48f599ea280091576af7da445794ab1bc95574a146e23585a6cd83ea5e48ad0d792302266bc43cc23479e69facc9f8761a8dd50055ef1d602fa84fdb768013b0ef3e0d3804cb139c4d510431111a5463218a86afb0455f9131fc27fe8460c6259a4cc625f210998b109208ecb7c3ed251573c5a51c7524faf4c50004751b2f0925f672a99d8e19baba57169de69747add08c322f04e1d8a9994cb38353e7bda5c57e831e31258242f6fb895342d04f288f85d31365fe1ce5be4121941f8492880a2d93300a823a5b5a93165b65f50369ac7d963589810026132dfceb344f379a0a47a10bc18380e4fcb42bb1a6b3f48e7107c49469a0b7431a249aedcb37f3d017ccdf5a7bf9aa0f3aba5cb31790561541ed201a7e330a95c5f4a9208dd60d5c2424b94ab3a453796de71dcbc62876aaa9dd7eb268b5ae6e9a0f1ea4af2c6967bced22a7df9ca41ac5ffe6cc9c88050a4ea97730b69f22040f68eb9847b12ae4c870e4962886199f8abdc01d040dc438d160b85e01619014016a24cc1f3eb56bcca0cdab0b02f3da9620d47219994357875802702edce81c078a71481355fd6eb09d13b2165126cdb5ad31d23f19fb5ed2dfaa6b4d91a065b199565ea14042d749f075c49bd0bbcbe18f5a6aac9e7d9c80ad5a58518be452c0142ffab70a7b04ef524e6f13fa0ff7898354f0ac68848b15dabc6e0f2d573bb3572498c8ae218fd6cea3afff4eaad1ecce36706efbcb77fbf580926d9f21417e59f387fc0e192c703172087f9abf4e240ed383f148a990bc2c3118d35fcb5c1b6dd9579638f135d290ab554d8361a1318494cc03b0e1232a5de433eb22fb99fff43e83686d4e2f375c33ad84879ec9152706eac6db2f38412dacb5bfaf7f711a1215cad83deeb1185b153e8a5cb3887e009a034fd146264f6f85d4a4ab67f6febe0c34ff365877b00824003b721a304540769d197b9454d907054ad04791377946ae56c1b849847eda75363fd4271d313410d14abb6c824791ad3ab71b255be2932c6b4c8f662d118d319d080a2d5d3913040d289a57ca3d9a2bb058ea9f49b23ed42be54adfecad2d31612f7a68312e4c459f680ec0367c138c08c9a292e0505e58b8656cf2f85be4fd19ccb9d80db7b492203e78a93ccd4aac408f19ced6bdab41f172d3b8c6135729832eb646daf3da7a2042902e05b953fa94c8089722c1f4374de931bb5c05c64be71f5868bdd2344194644dbf755e87a30f7d5f661426d9525c3917fc02bc352ac849ee8f0581e6c1ac1b67d5256bbf16825870f8de9d4492f2fd81375e0b6bf2420de004ce78e49f28e010cb7b113c38f8951f6a318ab52509865fa4c4f51f16b499568aa9fa98fa9b4bd18bbee64e5f2d5a5cab240d222b82e6e8a5d2fb3071caed3259f92ddd4a4d99b0dc2e7de17220b2a4679802c44ddb6d4496e3bb4865499dbe422d6ce64e6c742b9668c70b007296e0d58ee7b0e58b52fd696997698f02ac2bcad72f3018391c197b613e08cc25a83a64ee203d68b6ff72b645ca5941514f8e1527d532c5cb7dfdf7bf5055160332c2707cf5ccc1f3de07bc2cf598f268a9a923923de81472c1074dad70de061745f4945c559406f1b7f58a88cb0bfd098a7a4e477cc90ee4ccea503399bdfef65a9faf5d303c94301f80040b3b2da517de94d2d67c128d3bee4976d6005ba65c570adcda60dfe34ed417e843610e9ac61b222f5baf11675edfd4316b1558db83068e68e1a63e9728898fb5803e5fd425c5d4ee3edcf2719be9032843b0276c39d30853045b1763f4a8814c3f4cc90215f01b62d46dd6450dc4c595dc4e52a560ace85ae0233ad91548a910439867699ec1a59e4d42c7f7908fd0a613545ca7bf5f3a44112fe1681e3bc587b992836ccbfa7b589e7bb36fa8253bde5bd11d5c27b3f4bb6a726357a6ec0388397e19faf36ec11700a12f637591d790845805126d01f66bfb299e314228070e70c3cace92a395f788edb45dd2f4d37ef427593eaa3bfb19d43b72c938e5c38e9e9f6455ec45809a1aa8d50964fbfeadc0d479d78be45f21d6cac4e652dc23df39d3a4a98fef0dd7fa271de611d789226097ca9ee80e56635c8383584d946d86dad8bf1f9d21430d33c449852670f94eb7ffddb465321f3a2f69f312eb904555d02ede0337ddb7f08b3af399325d084683c72fedd3511d3adcd00a6880b476816577b9461d75d3a15f27bd3252346e1390b8f55bb82466dbd602a7fb5adb2723f043de038bdfaf1fc283c1d828eb75edf09a18e1fc25de04c473a4bb9580bd78734da54c16fa1188332a03bb551dbf314d67fdb76513ad08ad4116a4a3abadece7624fa35661817a0a0a940f306f113752275f71c095d1af5f22b74071578b4ceccb6763451c7ece87abaa6efb245c13b2860ad14716bbdf3ddec48b0a9256a3d6327f2ead0e8bd37dccb388a0cdcadbca9c22c73ab1c5e10e7dca74f2554c04fd611676f8353b227ca853ac08f4a525c5d730a3a3088516b7aa00e7537f1817601f5ad953db5cb11cde14efb221428bd878fa99897db859bce5acb8641cb30fbf575bf5722da1d7bf73f372128f1454988b970be77222b316becab137ec720f14098f75047434fdaa8a01370e05281a9b4ecacfce7684289339e503731d98e950fa840d50abf73b84c51e208d90e92c51c562776c788550ac51be29a35de2a5070a808e867e2faf8f8faf0e915e91c9da2ee56bd7639e8e4d941131c0e149f84dd2650b2c95fe4b77a5f91d43f79c81fcce264a99d0376cade7d696034534a856de232268f4869513f08c6e603cdb07bd42cd7881c63bea52ca271b7cdefbfd000cca9eab5005baa11f1685c46ef7ae46ddecaf0cbfad23fcdb817035054c6850afeb3d1c53b233214306e61ea36a137afd4d380abbcf86ef70025e089bfb076125919ba6a8afb540809ce6f32da6b44ceb37acb4180a87e582927af54dce7c3a84d38904bac17d3d14c1bf1d5a78729cb90e8ab0ea743188b3e3a6f126eb8f0c9de0404efea2a58480804482805e266075c797b60aed30128bb4e55e5882ad854f09d75b3a9f847bc5dc738ff8c93c3eb94f9b594f7ab857568d1820654094b370f300dbb334a6b903151b59375e9eb7340ce0e85a41d4fb7fdd40509e051c61d71c7ce8f1d20d6742b0b6e8c0f68bf923875cca5e3bda85ec164d16292828f699a62030822a265b3811d30f5905bd17b193a8a2f28eb0aafd66b36a673bd22079c1237a230416a8f41a90f128ce496aa7f26bbe48ec339ca141a2eb467df2fd7bcaaf92d797bdb5cf44e7314d009a466f900a60a6bd4f0788d3afe9ef2964186da9b2c11a8988b5c3102aac5a98c501a0c793968c08a3cad1354c0c8f881b6966636838f51969dd4b5c9e38cb342444c8113ffde073b63c2034b1384fb569a01c089b3d7a221e37e54fa6ef8760764dcc44ab2860fa8e77e7f0e7dec7bf55216265a779b574984067c8a142016f150dc8e08d3e3a0c969657a1444548738f0f78678cf2a3383ee921a95e241600f416464450a54a8c28711c03b4cfa7403931ca1d65c23f3d9afd186ee1c2dd8d7df385fb2b50826d9015f7243788ecdf9f752c1c8dd9f4cce654718287fc2a19085887e282d4afd1106ff124c5becaff4b4e33f9267cc9da4c6bb43ec5b7b734a562ec3c28fb46c57c6fb77c982c7667f01379da8b60eb4a215ab3efa9ebeb7bb6180e11c5e24194f6f3f5fd05da10fd1523ca64b7239da9b581705bff6fc8c461fbb8c60af67e83badfd69c83d84e8e501513b90a035ac224862b0630e43eaaa0843e872ba34170b0d207c7ca6f6abf57703331b651aa3608e2d930fee86d2bd250821df070239bb429c4eca4b9c98883c72cbde668ba66b96b7f5b9caf56d48dac987f7e5e9c90517321c2d026181395a40d71f54e5d3ff0c0142a3d43d54db9f45b5e2467d0e1f1932fc654ea3ea1be7fffdb74cb3a0daa7855657a00c658b764902832552b09d82f9ebe918d20cf6eb1c38a2e01027493c74ce37276c2a9f7f5f24a0897e13f6f9c8b2ab7777adafca9f77c872b256c13e7854fdc0983675f27b8b580dc158d015c342d35f1377c343c23b7958889e4ea76cd801c47d1130e2b0198e58e5fb798c2120aaeb2ee5b7c2b67bd717a258c36f063c2abe76f17c26c6630398006d27924931e6f6085391b254d216b5b50ed8b7ce5618bc15083e1a951e1616de8d4539969b99d7ce776b5280fc09f5cb6378cfab7f333aa2126ac8f97bc8e26b0d4e25440505577a75a01ce2af597a35d80bf2d7d44d3bcfe73d0cbce01f366c97f439f422253563532fe776127d29b99ea6bb452f6d11334fed49a5c9efe4654571492c934c87468c6200a1b9ab776c5c43b35422c9670e47e929f94c8a629e0a796befed73e6c6a110a1f3eecd50072e1e95ad4a175dac24285624f00445739385725e6a9ca2403b466b47f734312b8b689ed823454aa7c87d319bf3e8328a05c7c56c00de4e7da926b3b22a4233adb4eb9051c3e3710e8d66bc4bafcef6f79b026244171764c7dfcafe92b1ddd74a5ab7539386956f19b97f8e94a2bd027b60e588ff80046fb2c855382da14f8527fc2bfef3f477fe07a8b4c54df051a29fffeae66121c69420c06b53a368ff6eee9ae11b1f5b338c544ff03305db08bb259c267e4d4c6661a7a688ba940da126bd4d81704c130228b705ae4b9fba1783cf2b206b90c8f3e12916da243dc809ab90444db2536ecaf29dd9a7c34ba55885116b334bc291954a9bbd3b90a9bf5cb957cfd031715842c2b884d779ab503f472700bfe07c6742ecfd64d57f9bba6ef8234aa18416d4e5dbe5b0d5775038f2f3439ef3992e4742e02ccc260278e7ffa86eccf76a4f33d0cfa5f496f4e6f8788ecf80d8cdf11dc4f6ccf59537930d1805b083a2e7080356b5076df0ab67e4606118297bc91845bbbc7b77d6a6006db7e040fed05189c6a9dd93c7f8d701dab3eb10ff4a10bad0bb5cfdcbb9b09a266268109889e0c905e11ae02e4049cf09bbc526d97e01b164633a778e8c46a2017c61b0d83604e9bb1adc376922fb9c2c0fc4a3de30e97303a89cb3f392c3980047d97becb800430643f784111044edfc1b8792510a1e37741ac4703cadb17aa58a630b5c732b566c412f0f066db5b3f06cfa4950fab843eb1a4724c530d7636dc4a180da45054de246f290f019003b3f593f5627d10f53bb7eafb42ffe836f5feb889d991c44ccc983be3d91ea7d9aa7daef310f69533200f2be7df4755c74f800c0fa35813ddd6ba5953ba04dc913e92c3964be55fcdf4d192316bfd23e255314c523b59dad0757af5f746e63f29e50f2958b954a015ab9da1b28444c9e6d7b6f6314232bbf69146f82d44b313c776bd332b1a316b73abbe9bb5ce4b910af8479423e9b4b49de49d7a0e9559fb013c0c11c72f2fb438cc9c601fc16f746d837641a378d77942b48e7b15fb859688f14b40989f8786a40fbc50f6bdb7267bcbdc5e003f61cc1b0a21a3b4ad23c2465b5ed4765eac9b928e31bcca78f4a3647be703fd1af3dbd4e13fba8c6fd8184d1a632b3d7697eada093cf548a1e8ea668cb78ef34d5eb13731a0888d5b4ebcd8b3e5ce14a530b103d6f0e309557607e9a3248c96fe751281211eca5db52820aa5f2c7b2f72cffc77833a515d4b5caaa75c9782700ce256c06b30165cd88549bced594cc86360ace0a72350185ef686d897a076f9cb7d363338a37cf40a8cbedfa7503b97f9819410be85dc1f3fee812e1289272087512f192e9bb640309deb35f26f323912fda6337df3c12abd1f651bd3119c10fe4d4badfb3215ca98f5361f4d8b042","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
