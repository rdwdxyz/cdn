<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8db8b2e93fbccd07a6e7282548768758a801cd69c0ea4971a68868ae9988dd0fc967ce8b319d983ee9ff4b6cf6f597837da83d5e352a7a16056b59e0e7ab2f9bed4ce9c910fc3d131236e3cfa34bad1cd3178d9d486b8b9396234ecda5df976746c7ba9ab5b8e73d7637805d2158638c7fc11ba5e12ee23a5a083530097829c0766d85e8496a9ebc8916851e2c65b19dc87dd5d4e662603c23790f15d05c56a1e3cc2cebe3a07f0d6a68e8e701581257f3380c32ed74ab57f89074c1fc649027eee040e208e610a8811463d1462452e95949df4aaa2178aa5e46045b2c8b133521ec99bf08366b285d12643496ae38759585bba09d1d9ef52fb8060330a4c5a994ed177aaec698bd751b0f49bff775acfc116b0c19201dd6ca557bcd11a5e346c6ec9167c4b1ba7e042e7b5ca6abbb2ef47013af8c6932bbe9a77ef10442044d2ff1c31b627ddde2cf3e1de94fa4c7019689a22af9fad7fa38e00518fc047cf888bce76aef9ca84425ba1a871d41d3716d3332cedcd36caf99df022ff5ab8ef32d781a7712ae22652e192d97f81035a864e84215b10be4f29d113311728475b0f4129899d6f000365c2ae2ad6d706e8985107a29d0dc6ee1995b0b7800e8ab984083e7aab5890dbba58440f2b03ee3794bed4ccc119d90df52d796897f7a357341333d7c8da2d9022fe45563a9b8fd0dd1b6256367aaa60da721d84e1e8e4c06e6016916f0680e9a195d27a04d9bcbcf158921af8d5a6b4152b8544dddd9579b6bb3fcf39a3856fcc56240f5e852c6ab879c1dbdb2c634ce7c28582b4564fbddb419ab633b29042247d0b154e58082df3a5db32a4c2a91c797393fe4db7c9d3956e54cf41da5bd3696e545bb54d5f6734a494fe0381ade1c3cbc941ba9bc7ed1a5d7eb9a226475d39a77a3bbd977c5c9b24778270502e221427587b54887e5c0a1f91e349189c5d941f77a63389c121f2249868835728d90a6602442a5ca3d1ec5733625bfe37f214fd63205d56400344dd4fea7a3ae5ed342641660b796d925c636bf4e62354c4fe2f061fd8711174300022763f7edc1d53ada83b3de277cf5850baf0e445a89e60b646b8af27eb38b96b0fb24e5a10a6f8095aa1cba5e2bcb71f88f4e30020c2b4320e4b3bd255c4d3074ac315c2e6794f6437e6a487196d1bbedaa1ca4d14df98f9fb4c226bd21e4df07dc1938a5c0a3649606b96075299e7af9a0554a8a0d9360b94294a6d6ce8c614fa3c6d89e5300b94ea0356dd895855987df1c6a6cdce3d56233ea0264423b53415e62b07387c2d636efcb0a15660bfc988f923c2b0b62459f6fb0a7943ba71aa92fe824138ac49133e763028b5aa0e011f7661267e8afaaa93dd78cc0cbea4a1d6573470770a8dcc6a1ac05d3526380a7e21fee69075be784a2dc805f7b8a45909f2172aee260b9c40d0fb2c63cadc90538980363f01c9572a2cb0bb466ae12c5b80ce8b7786cbcbcfba14a4335f6a4f14943a6f3363f29ad5d9946de251db6285f015d2832df1c0fd15974030688b7f08838e7004bdf3d7de5590c3bd5ff5c5cf1e619aab76ac281cee35e9bbe6d030aa8204195db78060206a3e6e048c35a645b2895fb42aea2ef5952f964f506611fd60ab1e491956cf1b938b3f581466438ae3e27f4cf4927d5984ef0bbeb73fcc2ae19f3972de3264a743f6e139915b34e47e699e0c3ccda6c332235ebafd19bf45ef73ada5cd1969d8864b2f28e72b5374ae2ff3533c5156ea22e5eb8bbbaf842d6c972eb2a75ac7e6bb6015b18bb6e57494daf0b8265fdb5580d5daaed022093337e4bdc1b858105a2107122245a3ff6bea53fba30a8c34e775c5b346dc5f6b8ef5117bea5907448983f1e7e1f536d16f526620f0c0df54862d734332f01043e8bf14176884c199094a403fd1b3d13e1adb60c13887fb51de38bc0ce3d6df3d42f69fe8888e4c48b3613879146e4040ef7a0483d5664f26059dec5abfea691aee2b3bca15dc68057859dad93e5dc0567ba4079b875daa79ec7771aea0d5c4894c6cd9f181b3288860f9de020ac5223bcdc700440d30ee5ccd77635e286ebd51db290b21e008cc3876c611e7cd1f592f1324c597a9db0bad9c550785acc3850e80a030e9507f13f1ad16b44afb2b633152149b9cc04799190ba511aacbab363e6227c31e1d3779cfc27f99915f7bce3b88176be843131c448589fd5750ad92a4302434d6a727058bda2f2e7d8e8a8143d60500037ae142d41f903fba47998f8f4317ebf3170bbb2802a9a2d1efebc948daf7956d194cd3ff81a0610225e7cc67d70a1b048c02587f4603a917bda237fa6edfb8658b7ea7cce1cfd5a618ad3a44313e342b44ae410a21d884a0cd6a38b69cf367c3f541327bb8b90d2532cd0a2c1e703adbff27382d147a951b261ed40996de13ace8b4157de06a678617335de92eff2067311385f190a2a5456cac783122bbb234f88e5bda7b74b80eb0c268a8caf37cedfb109dc36ee94ebfcab89add47c37411b5a9794af98a132b9b62cc341af5a435a275607013f47d561c05e1e02b372f55bababa88fa95e5de78f2de231f226f83fb555e404789135b1a52f40d1232122c9ac2a181be53196007dd2e5485de1814da15a3bfded05dc2256b47b17126420c0c8ce21c72e19fbf437e0c74d197b346dcf909e9510eaedf3a72ca406600f358bb986129745175baba69eeafdd5cc1cd11eba390698ecad9de0434048d604fa93120dca4138707afee3bcf0e29f732aa4ccc384985165e2f52115ff2996edd875e5483c780dc7796328fc0935473443d2102b520c4a184569ef10c1e053a563cbcaffc846f6a7adf7def75be86248a4129c7410a08682193d094ef9d22d8c3ad083491f6adef5eece53a6dbe58034c7ce711ebb587766f22d1ae6bf9155f186cf6e147b14db4424040a3e959552b33e1e42ab914ffc888d55b397549ac2c8e8b75523f13fb721bb93a36495fb130207503577ed38333ba9255113983749b776ef86d70c679cb5b44f6e7145a89a9e530ce01d8663f151d69f7dd48a2ba4a44239d7b1f839d277b31dfe03ec736a26836957d147d173fad86ba75c8793c83774ddedcc1578aa913991866c8889784dca77bef395d9e7631ee23de2b61e75ed741fe4fdfc41e168521ee1631aa654cf8d8e9563d29c80ddf398f54d47b75b05a9eca2a29f05c21d73b688f553662a3c5114be16c11539d47fc3fd5fc121abb07eb058fde814b1a8cf6528ca7c03c4d571b6d1a59d4f147dbe6bb08029f637d52f254e88bad7e1652beab71e886d15e14f10524e87f6fd9bf7275bf9aec01d1c4ab320b10160fef2f1a02116b18f677a755dd65debf20e8b38bc5c37d00df896af1cde2a4b326152fbd0c2f151d2297bebfc638fe18adc3839dd984c203a4106239725d404ea755bc05b6e3ff51d3d0cc37d935b561967e78ff89ea8cf2fb39332b84630c5cd6cf3e073f0ff3f92b7153a061b3306244f718ea2707dd540ca3785e3cde95eb90457643ea497e1e72be8dc56fa692e34c5041a0cf1ab22f6c011aed356500dae340eeccbaae3e1e19f79306efe1d159a346dd956b5f55e65bccd9c61fba0414b4def82d4860e3e9d642b1e5be2fa35ae7e9252d5c07c77465e4686ca5294a6ef01ddc568e4079e1711f800c725ee9220d8ff75e7db76e6a265675277dd020a3e0474579d19e41163b4fa017d680ce73bbdca1f23c1ad6c2d2d6eb6d37efe47d017ff7e09c503fc5ff5f49c0a8dbba1d739915107e5a1848ab7eb4ca4de0d74e650a9a51492f521752d1dcf02b6beb4deba5eb9f3bb9807da9ff03a82352f0bfe201a1e243db261c360942421a04a2f2b37d7ae94ee2cf86b4a9d9d52878209f196c7cdbc59f0dfb046d1b64b5bb4d00c2df7afc18d148dd5fe16809fb8e08bcf99203bedbd5e15f888a0c8a0e3f2ab8b7ce47bc1596d7ee1e8b465c12e555e02929480fa11341baabbec2240aef7e5bee4b8d8c8964e8b56cf16e9db26794df32afaecb5245e5670c5ab6137d616f2bcfd3effbd35c5eb57bafdc8eea07e9f531509df99cb87ebb08096f3adc9bf3145152d036a2377ba3aa1574afc4ec6d1d46c927cd99c7c14c299d9b78495178dd256505bec5f8082b8f2de04fe70dc2593c9be5334e3ecdae90b546214555aa66e1b7b4f1ccc71b8c9556abb6d7efbb19f43a98d9195e0b7199cb77029e62a5a30b0abb75391e95d618a3e4782d19d8ee1c276a1fe76d05e3f8fc8af9fac0ccd90326db8ba05c1575a2102bd405fae994c1e1563fb437921c0bf5db24d7e18bcd5d68db0f77b6b703eda371bdcddaeee4aefb5f92a864ac6bce501a1269a55b55cdec56aa7cd80594a8edf2174cf1cafab21bf374a208d5814a82ad7b7cdbc66c0a1304077fb71e0d3ebe7e5de0c1471832015b5fd4eb074e9280fe8b7c7962dfc3c0f5563cbed269b22e92702c97cfb9e1bd64939181d1469592be29a2a4303ff0d6e5c22408b7254ec8fd3f5036dc6a7013957b581bdc6b0970a5dc743592459e74ece28c6a5ed25a89638794b9870ebcb9cba1a7dca815a46cd7d10805224dcf1bb7eee48a7e7cd060ec76c13e740131aecf65737bdea7a49695ea2eae80cca4fd74a854d17ac5dbe9a20089a3ffb3a51b8b5b0dfba452655d18b57d5c422e3abafe0560e3b868f829eb42d56dcefcce7a0483faf3ec3aa93ba3c55700cc9f1d83420b02cac3c008594fa9f157793feae4fd13f7f03f309b87afab7181fc75fc4c0f3b17bed91c8757a4abec385aa5dc71c9aefe799a6ee2dcfa1b0db5a5fca92d9dbd1a3eb0c99dc89ac06cb09c0b91f56180e9ba58e2c4a67558083dbe5a05196fb3f0116cf0d5239abc08a8c0c74ba81129e52e75cb0ea618654f0fbad51e5860d302b893efdfbea94d2df91eb71465aefb78e87f600a6159849af2ad93edf4d2e373344d9a87aaa0605bf7e5635987ddbce621bb2f1f346cdd843de88836f960e8598c75c2433ef3c2cdeeb4de0421fc2ae8b13b9581f08485c1c4c2eb835fe871337f5a7a310707e12cdda1d1d36569c9667a854b9b6298b97f9412a56faa4ab1375e3f96ef599417deb41e2d38d056de1400bd5c15f2e593fd8170c29165a044a6c624bd6bb75243b4e935ec792a3c09c166c7f69eae49fd1398674327a1a415da5fc2e465cc8467090f692dac081316a47be668221d1dd273f6889c34fa6e60908b8e2b45edc1df6e5ae0c3c17730a683cd90e58444cbc30009c5f5ecb61533118ab5cdbf485ba269345de8ba56b31271f504c25220860fe81c0733812ac89ef0920985d74735b8b2cf5dc61fe31aa0c37c3154389095ca6611ac019ef191b965708c0c3124ba3ca942a91d10dfcb76bf88b45595a8408fe91444c8a76c5b3ed519420ac58c705d58589e925941ab1a9717316fcf9829989fe58df83ee461d9688b1d4cdc7753957531319a04b956d38a8a3e274271cc97eef4ae24ef64cebb377b6ddd8729b62a6877ecb79e5ca9e058eb3933d548c3699a2f61ff8d32ce0f87e39ab461b9632682ba23aa013cbcd6a8bbaf474bae7a599a7300fc1d400fade94a5c73c88b88b88f77357dda4b5f120c29be52b8af0d2eb321f78321d8e4f7bef016ebee9c5c960ea155d16dce16069176c10e566c4f2354b7c7158857e65b2dc5c86cf44bac56f59448fe992db5822fae85a58441bfff8d2189b291e99fb9d02722e67ab370152be53908f22690e470c5414b2ce0bb4cb925b3dd3d4c6f023ad2d5af7880ba9280160f8ef9ba46330b4add352f64fbc0962de6edf3874111780e02e594d727f994af68d99324947c6796676cad8fa9806f32c79d21590bb36c7fd52795712416c4fab293a867b629728bb2bd3071b067bbed757af0d62a969b958b472dcf81a43ec1c1d364ece800875c0fd6f3e491a74fad592990a62cd221f610c42732e1c5f27ced1a8a64291a09f1905716b406a19d34596751957d962e15cf8c0db0b2e9f597d3a383062c604894a22f1723d61a4e4731b92a5f4e1e78fec815ac4b5f9157f61b0dafde341db187f0309bf88a7b440bfea6f1e626d513629865e7d157f4e14b4ee36579fb355cf481757f5b29c72e76f64b0f54cba0de108f3e907a1a068d1d10a045dbd7a85717f0e1ce7edf8cf8134af67504fb7bc5596976954222d4490c132d5cd27f3ef4deb2fa26de4c8350816ca38c115db6274cc0988a218033dbb6a46ee4cb27e8f3af507ee0a0c614ff820ac7f5cc145f107b358cdf51f08faf034a4d2518d97ba69c4983d0ea5dec152304e0b7cd6c56fbbbd395fd7690ae656e7944111da206a279626a76667dc9b0097548e09b8cd1d3d9487b779305042a25a893a81334d6ce5db35834b16ff5b98d628067c913399471837e8b237f49199973175ac6ee5d5f643b26f39327d4371acc029c3b651907faf254ea7c7d9f4940fe1d2f3f524e579a5671c6970647269c6aaaa36187563771e9a1a6f1eaa6867b29bb8b9d271c787892d1e6d2864eecf951638d65eac0c35561649a7727c5efb67c4e10221fabc0a2776835ba24ce492957e04d916cb5e27e4d407b6d0e75caf932b73e7e6defe82acd8264015292e7afb970d245aabc63bd4fbeed5a0311ad9003fdb079a7854d820c013f483a6e73189c947db2d5e60e0b52e8020a2fa926a419334588b4b4a500291a093108283d2ee05f99ab572ee3b61f7e6681b712da86e767b9e9de7388b58f8f074abcfef409293d4b925b786780ee96112a6dfa8222f2679555d7b59354bfc7d940880e52e2a8fc497827a260fb7af33d96cf006e410e7dd1bf080e72c167508a5c57b32271a0a765036d9a761880c10afe6f1ecfe2b984fa50714911cb99844a89c4ba80cfbf82c13591fca828c07763be6bf8312b2c465a5fac51bf95a69de579b66de5cbfba2c7f6f6e9022589991fa9922d446a9383aedcde86a1758dbe3b4873e6952f41d2cd43f1befa824ea7f0300b724665948d29248cdb6cbf7a184dbbb220776708121236fe22db5c12b5cb7b1adbc8c4c5c68c09bfd1bc2fbe8d4577ee952b3934c8d6e7a709869384e879553ac94c90dfa92b18a1a52b9f0bf11315bed772d69315ddeaf681f0f22aa108d2b6cd2407f5f0a0aa168d11ce6d374ee9554470aaa5550665aab1ac5bd361fcf9d154754d16e355b146854711d5a8a68a7a51b4fed26f1551db2858402b42d2a2f3dc198658845d60e46676708ed81c5350b908f78af9482c32e0505c1e244463a89bb279c8fd9348cf1e46967ddc5e9ef7c8d965c15451748211a8465e0b6037608ef3ee240449cbf5611820b54327821c3d4f5ce204b7960e5d227fd479a50a92ccd2e8a295b696dd70e261ff0466a4b20040e8a5fe9c7600aa499a6c3756a31c43bcc1e08aef178ad35a6da8558cbb15ff39b13b427b6d3a0c9e96e18c51d2ba72b68b0c6e814983aa43cb4c843ef9c9eed655ef374ceea238ab27c8c6ceb80cd9fbd40137f37c7f593fa47f86609a46ddf124657a0792339e506f0a559af9076ce917476ee1d07bece0fd13c04d434d917d06e65b662b587366f19c41994caf2159adfb20eaea71913946c250f283f103019fb4cf1ba483709450d588dc5dc5da7aa3c8d8ae902e73cb7c476457a239a682f58e4b48f91e473115ef2c7bd8ef6a70bb601a56e2301d707bee3900df61e0a3798aaac120583de18f87b866aa10c5f1a17f84208589e608fce0ef9c426eaa19c3dd66701f2d74955a1c512d847e4db70f555e003c7b864ba1817b3a7e325658c5db2c7d0798aa3915d4c3b52b554a0e79789d3339a5f676c20aabfcda48493226e5e6ede62029ef1ef6cc3cd450bb1944a30f16d1e2b7ab6a4bca0289886f77ad070c694dc37c3cbc83e3d43c09094910769d489efc55bd174ac8184330dd3230bfe770d92466b46207ae28536d0fc1ead9d5f4f56b240864330e1ba0918e9609e58baa363f18b3449523e01aec89049347b32fb025d6956cccca08e844038865e4274ea5744f16a6b69c204b297e292ad9af1e8d02742c0621972f2fcaee62f0b353cf6d7795badec79b0e59ed6fac0e9f8da15f8d9d835050ff16918ccef85200781f3ecc873ff30a6494a2b2819260f1e3f0e66cc270e3c8d3568534f3b1dbb8624e81e8ba71abad69ff0cd8195587dbf46d9a4cbf64d43d005c8fbe57b77d7b50d313fcc69990c769143e899be31298b4ebc33c019444748c882e22bc8c0312b323e1428a287ef79d4ae67680c5cade7823a584ce4e28bb4f0158100b8a22c0a137416a33dbcd3a5b983034853886ecb96dec0d678ca52bc71f1b3019cf8f60a9917bbc4358b1c97a1b4d76eeeb5ad353eed63a492730c62f852add7414bbda08982a0316c7c1ca31676bca59a7d37a35792d66b86dee8dd55edd4a8f99b03bb37d3ae27ee9984e18a83a932fd9104dbb5389e08cde371e0bd2a185b157dc5bf994a9d4036ca2353d8ca62e3b7955145f4bb836918e0001a2b99ea3e47c1a0a4cd1daeff05ac8439760c28b87c3a0c3c2f5cf22859e4f5d9c916e74445219480e7105163fdb37f889d45833f19fe82f41417fcfaad69cc5989fa0d37795b0bc720cae05a0a4187dacfdfbcf6bd3ffe1bbf6e2b9a7b0a2b6cae8c8c55307a63fb96771d28b53d442356ed037a52dc175352e127eab635d1cf8d2024032efd3d66f49c46854399505344a3100ddf837bfee546c14a809d1eb1605eed17709d452b9c673a27d29130556c7cc0840802ba0f4bad483ab9bf61a8ec95a07b79f3bb93dcd9791655d256a5604e327d1b4d45701a4e8fae3d07c916bc504f2b84043c242c1567526b906a500ec5d9cc6a5d0d22ebceea196fee782276ed929308c7c461842bff57912d1a5697e850e97c6241de7849a6dacfb6307a4a7319e5e0810d6317f5284ae54dd49b6f26bbf4d8f04190defea5b681e26c2ecd7a7d81f0ec9c8942a790ffbfd9c8d6c0e259d266fbd1024311d4a2c8c4f61818f89f4bf7043628c2eb564f477e096292c348144ba3d0edf9250c21f6b7f1a2d32e193acebeb47b73d3a763d1433369c99509ee916183a75ae9689a4579b572edb41a7401d25b8f1b361142f477d69c522181e27e41ae1154bcadfcc25191289b3e5ff17a24757ab8417d0438abc058d1448639f9f027ffea503998fa8841028dbc1e16bf7dbe4ab5237509fe19e8b969dae6d80a7789b826e41850c9354153ecea81aa48ea989bb4c9a394b8465af2086be775958e2c05e652748e4290726375a8fc2b78ab9d265f6a3a503b42f85e4b958956a7dc592df93fa28e4c108d9b2d6aaab57440a259773e4be1129b4d1b45f16f16220bbad17e5a6176e9b64285a7ad06f3df84de04fd81c955decb0644ca3636cd99dce79d80c814279be811c56f4722c015cd9d85ba9836fb76d8fc3f4b18e22d620e974c16d16587705e7a7e6e60b81ed518dd78fc472bde5eba5f3daec40eb62bd82f0b467cab6cc1fd5dcf63eb6d2c6c7ba5ec0b4030d7d6c19199058f742de882a425877baac7b08666ca964eaec0da3ed12bcf970b41c572629a26155061e5f5b80a9e2109716107e3984d6f5bcbb85dae31f1a749c35c09ada9d0d16550b603e5eb828927cc9c02d2fbcb2b737ed51628a065e4f41ec5d3539f00765716111b5c3e3293b0e9f1e0e5a36a12d7b56659608a4546b6d2b532f023aa93c4a3dd09da7e5b282db6a4ca8a44d65e958529d32e80335ad0b6e597869be1b7989d20f846ebb35198e8bd527f3aefb843b22980dda47538c0e69034cd25d75fe05dd2b40a76ef256d4f080aea8e73bf87d3e5ac9f75762943485d3ab376de7700dd5451874d6a0d2e59eddf7c85cfd53052d0965a7c07782bef71251a0b29487a8e29c9c2bc55332f15c5ebf5e579992ceac7e17a2699a959d85374438d3f09e3af584241e0a7af45cc30b56b7b6e2da227b6cc9c869466d427738c3175f9a679cb641829b69dac06771e4f63063d76aca36bc3f3459ad3b5293df3c00285492e2fa2ba93d840bb9410232d11e72174b0d30c0ea77a3415eb67fcd33baa54de6f66f5632ea4db9b48e16fa717712f75b6f3ca220875c049cd6d982838ff1ff0ad5a9f82a5ae74df37aceca580a298346deefc1b2c4c78ff32aab16614ef7635cb0f5dc7c7907b9ec2d32093c9360a046a96e8e31d16b3403bb83e01fa466cb2653ccada1db1bef8dc217d284ed3f5b1b6fbddbe86211317b1da658e925554b953a3a50103f5ef3b14c7ed6666676c15dcd60f65caf99cb9b2ff66a4414499cfc454679e473dd0ef731bdafb4d99d0695b38c87f19cbcba0e763a4ed1cc75536e4a2eeb9629f351f399ed407d937a54124c36c8a9b48458ac369005071c281c024f7732db5d0af56ed5b48f20ebc14ea3935cc76e47014e53d74c7d410ae4a7742911c2b5189e7a1ca99ae883ac3aadac287750850e6fdadc41f07b8b7863e7b4d6c451817553ea6cc7e4082cfc28ac2fe85e9051b2b0ae4a319ca8881a62794b3c3050bf05a159239c4d6dde4dcc339661d1013c4038d16d8a92421e16c0feb589d7b524b59864a0a8573a45f13b6b1bdd280c275b6a265be3cb9ad04c894e7735e59b1844e32978db89e03dc3bba2669b2d1667fe055746284c008884e05d4ac2781c2304a1b9993896ccb226e8d77b36bd4dbdcb8ab0ce1c44d91fae6f93a32eac209049edb9a44c5463e51e0765e7c5e8489d19212f5c208fe5a3463c82597251c279a5b2c69e8c73b30d5c3ed0acfb7e3f586ec6ad992cf56c9b76293978332dc8145ee4ecc09a604bcd2febea6588e4b3270ec91f1910af677024aa2650c497db6d9638b2536bc627103f6879f79f90620a19a041076319c7256be28b213ed136a933161d7e6ec500bc0249d6c77f834372abfd8fa747db283912b756079bde041d1b4f0e2f63b4ac0c20f2e41d3252f936eaddf1331222224677602c4f9a0ef1c2ea9d36138921ad0d6dc769e214fc513aa5c398c34ca0fd39918b69618c3b1d094aa5278568be2df367ca4746ff9ea92a0a78e52f75097314e8cd253a4ac77e17accc0c5bb4a4fa0ba40d910c6a69bff74b1fcd397234e0f95915812f370b52875e9cb30b1121fac01def54ecae6f0fbec2dcb848bf53d8f290416f3a101a484944330a262b13b07cd491b306f77ab62e0bdcf04ebced251db2c0496e9b3d8a2b213ae2a4f09f4321f5798c22d147e4b3eb0dfb51994b0d2875ffed6181fdbbf593a494467a1450071cf9c9d9f184c9f6d615c04a26b03bc14a4fea0284a27f1bc022e732555796441dea9af5d643348e116903c4350ea02d92c5e91ce834d0140972113c5f95fde30c26ad588a0327bc41b7f21ebc537d6f338b8c65b95ed60e33001d04cebb29d0cdfd8c9c7c0ec12268d9796e6a4c15810d2904859d9dcf185977c1e2ed80d7bc7c4d25880ff94713f342fa4b9611ca23b9ecd323c0ae4c63aee6204ef8f9d72e3539767a603d174cda5e6fc13091f8994910de1a8b42cf41fafabab3667185bf314f7b10823e158a096d607c02d02a1e9c9d575b6a70508cda94cc23fcc7ac839281279196d84fa3d59ce65b1cffa6d4966fef8ee00042ee89ed258b0f7b810ef9a4f0580e391b856ff1239b598bb123db47b00410dccf65fea4e447d75626db7939194d99714e1d452f88da2f2a215ea4162a2d3b7cc80a807f8098b750a2b9a5e585d68cbad6107c328741eac61db0e94cad540bcb1b78c4fcd68d99f06edb45ea908a81a3d1b92395ae8ea4d319440088bffabe473ef01cbe90c6a09b484f029396bf54b18bdf4deeb27662769954eaccdabb8f730a94f5a122470eb7245636c9a021d4c2b0b8f55e35c7c098ea56e4bdd367615bd67e238b019e53b169263941844a660da6ec207e06364cb6b4fe58439769f96f62f5a060d01cbc9ebee90dfac9904c6c9e3de9dfe42d55e791eae0c2447621db3d8da561a14140987c5b6dd9cfc5d435847036d85e9aac6cabd01cf68e04dd81481eb22b33ad5551ff9e3e8329d794317d2e2ff4670652b61b508630ac361f72f098d52b5980483a7d444138268e39647d2b8c136b064e102bfdebb7c35963e95b2bba3d67ce94aa9df085b7e98fbf5d617b9f474d95c23a5aa7a2e19ab0da72ae87c380d55bf8946528a7ac91af9860ef18f49605e29b0011c1e3ee95fd6c4a3f22f5bc1f3b5fc0e1e7f5f20585ea427d85bcba8a9cd2c108ff353463795e831008f2ddafb1f71d3e89532d446e0242a0b9e020e9177a5af420f98512492628bc110a96baf5e7a1113d44c4c995d2ca57d2a952e21054e904307bcc1eb3fe65498a8cd6957234695d2ec03685e01045e24c705460af87e7ed1c767d8040ed9599292a9fbb784379c3b6da2c41dd2dd0f192d4a29290f613bde4c956f60bd66eac7f2603cac8935967eadf5800493ee29fc4a0b7ff3f5261e9e37eb0be266e2fe6847d9ceef007fd61e60d6b8e49dd9adfe57692138dab2c5c26ddf42824a2af2acf9b6b0ed6735cc50c8d30d6ba4eb622e5d20ea3aad0ee7ab0eddb08d5e531fd0c623384ae7871ac53d5a1417eca45fdec22b2488d6a89adcceea5cb36e625dcda0c58119b418f5a4d60423bd89097ec3f93f1cc026d8ce70648307b5b265855ddcc9e0bba4ae9b306f1bbcf747e37e8873f131e1bb34ce226b5b70da837620c44261a091e256b8ca71c91e687f64e5edb85359d5d274824558cc91532b24961de88d15e4a310897a4dffc467e95d15cd7fa6993e9398a82a2eeba76cd4186ff9459acacbe978a912365f0c1bf01fd581f1e1e71198e94dd02082a85e1cecd35b6a93e0e7726a5346cf9fa496492f5ede012b8dc46009b15988559aaf91aa3ff798657d7c85ffab30dbb16da2b70fafef2175922ab62b797bcfb8cca75022e11198a49d178ce32c5aaa9ac1ff0fe14151d6537aad3078d42ae51dff4950a2a2b73f8a843b2f80a5003f0bebe2682da1acdd43bccd4d69086b58a11ae2e32bcc1d21fccb79ac8484f00f959c77f74807db7923ceff9e220fe6eecc954eea994f0d2381ee9cb6213b6222688aa7b2b60b95818d67d3bce3d5218077795a912695c15e57ee29cc4d89570564139e15b7396dbde8e61e82b6e6a9159253ee3f1f8f568819644fbcfa2ed0ab40ba1b94337ce3726013847de147354bcfbf8f433083e61cd57d6998d31b74b0c635f21430a37ad9785996cb988ebcf93387484f3da671445ac56f4fed7be3e3dd18a06a4b70e98c9ccb847c6b7c828e15add526eab2817532352e7bc0f4ed3ce0f348181e76e72f7b6cc783f5af676eae7b7cfdae5021564b1b03b46d1e3b5b78d2f1ed4cc229cc5894a00ab4f627b320e25ca611dcb4fc641ee04933e145e3200bb650c3368855dbecd34c2dc7d4e7356b55e110bf8604a22f733e9e60e1226748fe1e202cc5b4d3a1d8c57007031ea0ea5cf9b9d15dc6146884bab67b9548d53f67b4d926529e563beb54dc4e27d2ad463439e1e121e6a0754fe167516cfb61761cc4c31fed18853a029c3fc779e0adbf8551cb97221a748705ec79f3bc55d23fdaa64ca26af4e2960cd21c4bbfb5fe1d9751cd63c2ce883de7f61b660965eb8b0b0740a7af77d1618a6b8bc582f5a72a0540107b2b8baaa396b4de9b9eea6250c731a6f48d39a4a39fcfe9735c220de0a4b0d45c3d40cda4e97d25937708bc642b305b88c8cd3a4b5995fd1cfa7e30ad766e3ce5af0ff88465317cabbfc57fce41430a4b53808a452729ddbe4d8f2c49d969f32a3136f3ce2c798f01087d55cfc4f40ec434aeec6dbd019cf4e407003b2f3152fb1000bc00a6f39d41d2618785db2a310c952370a8b7361203ccb171c8983365a095faf2d4bf4767dd3ea4fb47728ad6e0a7fc8512ce38f43c236d970d162b2b8d2cc0ef7d72c227f2ca1f5a8f3c0cd962b5b47e4e06a040bcd41b698a0b72d3c7dcabe1833bb82b3b9c0ef0ed48c337e8bdea5018f4b26982016b176455d5e4512478776f13a1b9d34f757f5919b41fc1ba55496dd068a1df49ac7c9cfdbbf728b935b1bb595ab77b4c6391290b6eeffc5a519fe989c6114ede6fb6857e8e7fb18b9c125ffce2877735c3791815c2d514cd72f62fdcc7e141cf85226c463ba4e2441159819b3ad7bfb2aa8a6fa73358575395a7fa7a70fe3fe454a406ae0a5261b149a8c1e74cf8be3bf0b297bb8877cc72e08b74b2eb8058dd54280d64537fd2bc8047138dd497a266ca0d9bf7d34d7ed2a8c63cb5d59beddfe1326a9f2bebe5f5ec84b58f4b2d8ab15df136d6ad5cd365811b6abc3cc4650825053a99d5bf393989e12d7e677a5324e89cfb2400374891201777ed5ecff27faf347e06d2d9011aeb4ddba3a6185d4c85b74bf3ee596ef8d26936cbcac40310ab6016ce82f526b6c1cc7e5e3e55fe35e0902ef52acd522fa9703fed01e479ed65646ed852b48cfa9c9f6f96621ae2acdd739a41e0a21c73fc9ca22119b4ff668aa93befff2a1217b1f1d1c8f8cf3f0cd74041e58fa16d345db2804b251760579807015e0e11b936d2b6b27ce463429f00d828b02d486a48f0568cc373e91e7c43b182aef323d54d14f390920df1eedad260d2a8a93c2362528073d44b7043913b9cf8f54273c91adca3a054ec9ed5272c872283d974a8f9cf4cd86ae5cbbcccccde8eba9b12c67afb19bc06f0659e99fb577e0b9ed6424566434cabd9c4f4043fdf2c9e2b42ca3bd526e456f465507007e0e3b9645b9d1e8ed0b603f4e6913a1fda33ef5ea3646080c2818662ebe6d211d545c98b11d152b4035920fb166e94c339b52c27c656d62a7518b027fb369efa7b9957e16b42a89e3ca16177f71102cc564cffaefb8b244e742576a7f319cff7ebaab3ab31e53f9963e281e84dbc0b6e758a04bfd5a45b3102e9cbd9d56517511d26d396d4ec536b8367e9dd10532c4ef62439e7bd9f8b46c7a1a37dcf082d79e67bd5d1113732b3a796c30f55ce4640ae40eabc8653728004af3eebe8485f31fb7c28b7f738a554ec15aba0953d363fbc6e0d9acb5920ca574a7510cfefd2b182c95d61d5bc98f577866e96b24f0380cea0775cec04a79e765604a55ce83ae936f9f215e4298e55c735f00e3ad380c8d303494aca31e0ea3e050fd74dd80f6a0691e7a413113acebed4a6be4ab5b9f78d5e8e5b84f9bb54f27af4ac4d2f7f384a099311d452a228dbba814a51c4d920dff00cf41d86ca3e96a47d040c8c473d583155f701636470ca5e4fbd56e3569487ba5f0963c9b910857410517c3e32160a16fd9e3bb10fec6a826d76497e79762ffb978eb36140f766ef0916f8610c0a149654a6b5253dcf9e75adff56a223bfbd54e4db9cb018fc1e9bd27c2b44b1c72db224afcee753a3804aa6e084375644122591c4db9009c703989ed34408283f8f1ee6038dc12ce30bf74c30dcb7f8d16904bf74cb86276fb2aaff43f7318ef498d0ff71aad335a28b578d23a28f200e427fd7d728ad1a32060a6af8cec48f023b7d102091026f1c36c53459eec023c9b4a0673d23cee9809c144eb876078d31568561aa435b3db172e5cd9ebf46d6588b0d5ed168b391db7f63e589ec0e31f8f72c25b503844b8085fc004324f303e720871437bfe530df4c3257ea28945f2618f37bbe24c575f3d86ac010ed494c4dc6e012b5c9eeaccdacf58fc679435a79d8e7ddec1f43ac626189cf365c9cf827af8b9c6b9efa32e42e113d35330315774aeb55e6d47f8e92e292f8bb196b997edb8cc6d2aba81ad47a7fa4a606db271e13e7c664271032ae6ad940c4c4cbe19af378521803537419fd1cc2db25354b8bafd4bd7479faaf124464c023274b3bed4c73726b1dec5260c2e48d6ab20e5796ea7b4ce3377f4f68a621812f7753e6c0aee85b9d08d81385daeab4b6888468d7ebd32f6b6f8deb0b9ac3fdeb1d4817fc7282bd3be44ce136af784924c4588b06984d4bd502612d82557c45c7fc86e9f44941a4f3cb681c7b556ee082bfcd2fc1f3dda4496ca8ce59d62261cae477c671fb4a2964b621a868f3538459b9e0197a2084dee8e4424f4e408b943a71f07c35508f6d655b48db6a069537bd5873e6ca9e21fffe6c7fe028120296fcc84b3f47d42c1a7dd7a52aef8d915b3c3bdb86f718b7efa12297414876873847b030bb89a12752435d732d66d25f0427ec45ccf947d7160d99f107f2e9d4e480f9817a7fb465214fc9962ab8b83b62f804217875c6b329c815c4e6bd351f03bfb99ad301188a540be276bb8af639b1d85e86a3543ecb8bbf4074175f1d05b59732cfc606d3a546dbd5916a3cb1fd9171000f2dcbcca7936d6d9c5020a9442d1fddb56d51707957b946e605aeab163b00c5301b23183064560f4c1ee227dbb3f44e2b1197ef478787cd42b242b8b84caf2a33787275c6b4d9887f5662a68de123ea0546b85f770a76677577d3524b4511ead5b28291ee5e4dadd0d4afd723cd25287a76c00d1bc516eb36cd8319ec0a07304065f9584c05d0da22daa933d8abdfd664bae2745556b9e2f51ffa0ac1bea74f42fc3adf434a24f82063ec033091122092ab06366c689c82c07883128a57cbd38698f4db378cd891571fab2ddf9e96c7e23be5d9f7d2623c8d3c386f88e2b070ec41570049eeb1567a8a8f747cbe8815584c250114e9641df8bb34b3c5f10502874b1005b02cea5789525264f90ccccf1c382fe3371b050c92004ff0d3b763e77edfcb44730b9d9cf6fa5d8bcd9a139b8ba6aae38170719d504a0a6bf1eddc2d695459726bd44869a35a78bad7d47a1ffe3cb18b98f1a03c82548321e49454a8fe145b31edb02dbee51d77b475baa5507946e67e7c61c49a859038aac779ada21fe0c5acc577b8cfd9b1bbe34b0258d722c64a2d546fcc2112f5a773ce87290d060f6015d5c61f77e031aa48d120486c63c5b12cf3a35d5864fc4828ca3321d59f94f5be5bbf1f3bf20b4dc1f8e74e143a45e55680f2686f4a09642eb10efe8f24bdbad078890c24b5d3fdfd85ebae668964cbe2757d0b4473bfd033b11eb3141087643b68c5d38bd5a9242a6c1814fe435b147ef3f8e3a513fb75d8522ca2864f3148aaf048ba16b2bbf034537b31bda65e107ec45b53d59c7827ee5c1a19dc8c63b3c5ca6f4793391f8b42e44f6c96b27ceb6fcb021ebfd62a166237ca43ae8e2ee1ef05af2084bd13d01b8d29b75e49b7cbc461f2e3aec5c928a151b59b348a42a8dcfdc5c5b8139acc029305871c6c572501702166a8740e6ced6a64cca71852dfd9e0affd05145770eccfd2a32b05c606e9ef990575f22d7db661a331e8261bae0e86f46c55a6560c2fab1c9fcd85878a39a417dbbe0c2b3f35e4a8f8201e8f0986cba36d892207a08dfd8d8b756730aa7bf552d2c9ad8d0894ac4804c1c873a55d6e715b3450728bcb8d02bb90452a16bc84eb5011cf8dd468d56333d67bb723ac45a94e83bd2bfc4065b852b0de748a77c61aee7a66095af6a69598f335e50712d14ef1bdbd2138d5837a12568ea474578705cb8dd517657f79abbda9b6e113378055809456b7ef4751344c24fba4e3c5f2f2ab6f37f35914dece77d77235df95477b77cee79136d95a4909c4331d7ae0d97acf149b10b797452d99f8bbd1e51c4916321cce8212025d1356b0fad400122d72177d1aa645105061585d6f4a017fc22c3c00e83e74579027e6dd82876b7954412b09ec5cd1f429bf6a834a105f1bff7456f2691c9464e1a8e6cfe68fa62cad128f42934c81cfb9507167eaf123b8dd4ee038184127f71e8b0d0b16707fd022fc863b04e68a9f0c3586ef306aad99cbe7a31bac34785ca7820dbe374386b4ce79da5876a8943c6ecb5005e6ae33275403b5ac74630750989cd3b7de01407507c7fe0bddd23580e7c8d9493ec884d7f334efe8a4e9b75221e090eedd4d19356b7c51d6338c90d5d61f70449c6f243abda7148c8e45eefa71afea9a1e0170349203124abc6b7931dbd087b1da9e77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
