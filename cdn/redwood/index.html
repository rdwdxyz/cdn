<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"556946dccb65d73f3f4ac63b7e59421866d8aa57356b3c896369ad374566a86a61397dbc119bea3714678d3be6b8872575e8d627db615a5bd886f97cb30a92652c7ad46fb955ed8679d6ea22a4cb2d9a09ea12111b6b95a210d394f24b6967030ff054e201fb8d300fa3e82b8a543f5c2f8fe27fe5da5b7bd88236fbb7249effa238174fad0c3044b8c177427c8d5edc6f1abab6ea18802a3842e73ae2b03aef76cb353754961600da58e288c5a573138ec77aded30a345100634dbab5f8fb2c4d9ace1d94d525e315cf62b1fec397d5f63b780f96a073a1cb36246f4ff399bf24944afa54221041e50d5f1ab6ece3ce631f9ebf0614d3fcf69d726ef84577007fc17c8fdef6cda7c4495c94dcb2f43b98e5901eed9da8f9c439576e437b6c7e2ffb7128554719198c1f42460983d771fee7bb07bd1380a069a4b8e67f9919e54964c8f9e007d29e36ea9ceef4014b1069c62448756d21d331688fd1ce9ecfc58d3e82dca03648a01180043337831ac8903f485bdc6984407dce0e864d5883ab693b6a3d3910e7d523f0ecdb1a30474884213be9fd0e75442448663a4c41dcbbdadda5418d25beaa0ec418851fe7b477e95c3ac1654f3ecbab443798ab17e5a5bad0023e7771d03ee3c0333e2b21c80084d7ae3ce17f23cbd3ddf0dcb39cc8b0d210fd8061bedda836fbb0619c40c8ff33dad64698997f28ad5b244b8968d252b098daee6043135303f60abdc928b6803e8b25bae0faa9affc2ed146177cfcac2d694efb92791155b2b0be39d14bde9d3ae92a92db43a27c2497cf78895b6206a069d683b78a79d1e9c6df22393d059a44e92e3ff2d33bc7d75e9bd51b99cdc06ee5ee6b22188c1c902839cdd166e0baa657d0c3b95cd18f98bd34b8cc21d27a6736fa01a06af936ce2629398d40178e6b0cdf22edf1371fd4ea3d8a45d0f973c02fe83954d9d79431df41528bd8fefae153d8b85ec270c9fc0ae24217afd61819b467db982903e0f1461c78d98d2a832f42c2b9c2084f132f1be9bebe9704604b5e1e348b430fde29c1a08e434798fe505739aa22dc34c88c27c5414c12baf4c03935b5033adf29e917c8dbc932b8dabe1e6bec0856a203019fbfbea63e221a51b449594fa4c7b63fa0a5d131a8e25a7f68b502dbec4155ffff60456d3c40024e3d57be3c8d555a3809e8244f205c66b1e2b02d1cd8f89b9622c16e3b126550fa826445c5c88716301e298f630b4bc549d44f17ebba736c16fdeb1d7a59e03e143ef379286dc6d86548c8d49f811dd24075aa0b663bcac46cb9576f035e8a40bb00e10f6dc19c7ec0fc1b5b5a5ad6771fd7d450735242ba1cca1414e74ffb521d1177626efaf08fb1a8a38599e5b74d6a2e138bc2c043af614a91584ca066e390c21ab0fa7728473e6b7c736a3163d6d7c4a881d4a61520958ecb9187759e8df5aca73ca44d7c8ad0251e64e439ab02fa715691a1ef7c07a0f60be146330f39d1ca2c1450fd74e33b3f742510edcc589f298f85adfff5342599752440d43a8910e7d9c08b820ea5644aae92904b8f23ea091e2ee27b2a4481051fae06533396a986f989afec5ec7a2c170398eebb3b66a09b1b2dca47b1dee98943fd5fdc580b8011e04f0564db866a93830ed17b676ee7660052e74a41a6771a944d0a834ac82e579862a698d6d1185cc94820c081ebce888ef6cd9069e22a74f8dc1ec94aa1dc80c087333ba943b9c0b9c647103f9da1575a88d301d5ab1aef3b0e0505bebf9fec47da8261ab0f65ee5d752af85d76f33807d025986738749959d6a9e8460904869e6b8f51e2bd64bfa4aec1677021d6d942ac4ae251d6d2109b297f6448925b1b8eb5fe7a345392467caf62a133cc482605909e37243bf6e78769ed13b2a72938415a70025c833154b145ed152d9f4663e9511c269d0140cd55e95474484cf9a57f54b25bc96f507ecaca502bbdfc48345db7bfdaccbb50bcf81be2724da1cc0a866d8f8c0977f0efe6d3faf920ec149f1b3953a33007ae1b3e04d819c58738cd49c028baf0c979aabf32b9a0231b8e6ddfb4997a2aca9626dc5158d0e1432c4d4ca0460f89ce61bffaa931d00436bd98cb19bb2fff1871e8d3bb413d4815fd7b7725105acf91b2061908ac499e3ccc287932176369713333fdf5bd986bb582468736364090dd97cf1db174554ddff4c82b26863ce7c36ae54a3c810931fb12cd23a1b75ef95fe7e8251b3a23f8ca27d72cef8e1b734f3565542ce4a48374b9ed347ef9b2daea6e62e575de89ad57000a839b47c463b691838f8b24dffe737cf9561c8602b2c2bcec77b88d8b071bb6b71dfd40eef11600ccb377f80d616cc49df747f57dbd0a44c6a83d6190f4f110d798f003a62bfdab8858ebc7dda3afbd4b211fe5f43eb403fa207223c5050f3d8cc44f8ab8698f308b1821988f6b2699be63a8284ca29e9c8e9a09aa03b36d4a01211c667a2684dacf6a13ef7c7316e497ab01b6b7d292b3364f7b8a8fac80835ae12659ff830d2f3563ced33ce4afcacb413400523a660d9aaf27851e9ed53c6cdc5d9180761efa89c01be8294f07a08074dbb0f3c79f1989cd82d6e1eceee9de15cb27c2d1f246b7ab355eb51ae3f54f00edec6c4850d0c8ea0af57da5f7b0b436b444c7117bbc51393136a593ae1b0e08e6ef37d12ad4e29e7517392d4ded3fd48d4e9f469603f2ef110b77e78098bb2a719ea0d2620cf3e96797a1ae81a44a3e74c127dba433db242913182ab8b627c883c2d63a051121132e38c1be34370ac243cf457bc154d17c213a2002e77ebddfa57cdb05ff419e9b48c2a28eb89d6ae5e58da30a53dd1b9ffe697fb2d502fc66c8709e453ab171fc7ede597c38a6a09624385ab9560b17f8198c0e57a5b80607ae5240ea2eaf6f0522eb1868080ad503ceed8c02128b56cb037aa40dd762ca2c838f7f68e9ce987d118310b50a3047d3ac497e80496f80392320f205f4115ba161ec1f408e3e41fe9d674911008e2160c745aa20b03651adccd815ee6383cf95bd80f3de38949cbb56c4dad2d10e2fcefd6a546b267811a423f30cd683ec4f42f2f105503ce516636fafea8777095051cd7f36144ff453ca5a7ab28f52ebbbd7cd518747a274f8d65851ac37dfc64a3b62d06d653448a76504eeb7240096df60138b5909d56603f93fde4fa32dc9a1c1a6cb1a3097759b5c63ed076e39689c3d966701b48373dc027aa7f85e2a738c3664f4d63e4688ca645483da604d14d70faa61bd467fcbe0d2a96e8002fcef15c9727a1081c398b8549bcdae71930d739fba46398c7e1f6350b31b24bbbbc04f97e693fbc352a8853ee98b4b9ffeddcc0d6cb1fe93cc0d54394bd1d0f903c236a0839c0af3680a5e22fbfbc39189f733307d6729427e9f38be170c8b545bb3ea234acb297d6e0bc844d86f50d0eba182b42fa64b2b6cd1789ae9562d73818d36837d2a19346ba6abe34e4b729f761a71d815d9ae29a3c98707d5a325efef6204b33e3997421089bc810b488172301ef5959a827a3ef8d837f5e18ce8e547d9666d6e547de60991ee335b18c8fdd7d1c482cadbd70c311c697399930782e77c40ee258e64d24382bd5cf03b23c6ee05f799a53cdb53d58dafab285056904ee3eca070bb037571a427dfbcb27c53f2faa9f0f2ace75adb43df215972e010d351c9a9abe3a89c3ba90d6ac56171b7abb2c6886c90c495da1299c97c8d40a528463b632d3651c7e6a33b0c77c7ad841ea968e681e6d89a04e9571fc3ef66de3d3b4c2a5f640a0b0cd4a21c79b0175ec14164a68e1f52a100bebb09d62c1d4bcf467015205846a568b445938c2f330bea39eecb66daf4f3e9046b553e40a68c2251851a453b51a0d0dd91fd89ccde57d10d9e16380a923e4e82675371abe0a1e45eb739b77a087cdebe52f57afa7f81c953a814a14cad38dce2dbf28c068d7c12d758536600adc5c2462ff56029b4c96a2ab88d1678145a2dcaaea97c8f28868900a220607b4bc138f0d3a2ed9dc813e8d198ed28218d4f050f2111aa0261b7b56895858e79af2471ba8f52cc2f9e10d6f1f13faf61648d6e9e6d3bdd445c9108fc6ee046173d97a029c84186d10ae662057005d22f3a53bf7e2d81ab0488a52c7d494d01eb69b0ac43d544f179c060656c8ac4e5c35c9ff04f5f402ec94a184c3b8dc5b501107963d179ae6009d6e9471d0042d7facf77f8b8dd93e13f43cb3f9014b5f6424fa1f82cb80b124e51ce80eecaa629e3e27ea58eb90331321d23ccbad617cd4cdedfcdb8dfbe23737ca395346eec726be7a4cca4e3e217be4c4347c4b339e12011b973f0bf31a4e78cbf384e46f7eb8a225ad95f836cefe0078cc2a9f0b2852ab5a91ed1d4a96387e1b5f3ce271471226f855fd881ba69d226af742eee1b831da5e1a5607842b7a4b18b77bc824c1a587ef0d645af4a612c9b2eb17ce0cd42d1e26a2d6f5fe16d5e37bcadc3240d8d334ca9c471beb6df5e2c122a86fe95083ec2592eb5dd24b092a2455794427c651c5ddb9f1cd1cb63c194affd087caef1cd8f65a84a48e9d27707ead7e44ebc89d97f967ed89d5798a72c348411a8dce5f5b9c3f8e8fe86b8bdf942a7c96756c79a6dc5500f8ab085daf0e183dfd6cb9a59bb55414a7744223130bc50544c9856121eb76a7fc30219c8bcadff73bafee6b84f4934eced75952b2c4a3b6ecde38df040a2736aba9c35aa7167de08b8f2924f0009f4d77ee08b9884e41a0c0a787075dd7cf53b57aae62f469b0e2e54e03d5bd696ce333b3e016a22a4193a75a1200302a9df3862f94f99b46ac61c87efa3acdb8924b9a4452babf5a5912879fcbe24b6c34a348c81b351ca9a05362890ed2dfac21391102d1d485b9846163ba8a04aaa8e9a53a665b3755b183ec4134a70e63c54b654389a774f9dfacf05f9516962b8ed1cdccc8fe8499eede350b82cf5e7943ea0d5871a1f49c93726c72a09f84888726278f19a05e2e5970685970db79c3ad1344b5034a9bbb2a71b60411ea02a25a17d0e73d713b8aafee6ccdaac8f395cba704edb303db882202b9f60b0377de8da9955c62420e1ac89e6e1a6f4709ad31da64f5b9c0fb1a48611a605474d8480aec8cb88fbb10ca5a25410da504a430a173b6456ff49d79cfef99adc12563fb20e18e37d2be741b178a01228989397c57fe3f57598a51de3de9dfd6d3b88cfcac92f83d55391d523a9636ec402bca2a3a305071e942be401812abcd3906c7316c68a41e49b644ef5fe17240d9a9ff2662f32d2b15173d5b9e01a6a0fe3fcea8e4c2886ba1529fd19ce694444750053e58a227601d9a50f94e9c6b5b8954c655690b7e523e2ec7d59f5e36ca58a71cd069e22abbf726789ee7b933250c54160ee6ad43552a422cdf810edd59ed1c27e6892a527392b5abec59eea28d138003a089b907584c88751c49719593dcf11f810b98a98406ab0a8773748a689f055b0103bf5a385bade10e4162016f95b154cf7e40745d5f46045b33ea9085df9d8ab7ae9f036dc37283dbfad8f5f09e71801912fa41a3711b187d61f2092b40eafb41bea26831053c9061c1c746620fccb08005f46de1efa5f879b7e5217ce8bc1a423c7b3f5fc25ca0416647cff41140d02f2969ee094b73fa693bde56aea64b29f091d808b279e3e6febfb4d55b04a785572d63c45eedaefaf2c198ac9059ddfd235c2edb310514c69d31233b3ab1a615eb16a7e3281a6cc89910beb895541199ae4c0cbb4fbaee434b0b07ddb006d79a881bd0e26bbe2063941ebae910d823294f25a458bd2c60d03f916994835ab7f43171a7b70e09b75df74add59a5d8462ce83daaae2ac413883b61f8d7ac98dbfa551dc53688e99580f9cc90a8474fac50d172062bdb8b8bf404ddc5e370f7b3ea653d816cb218d1f69dc027ab095162aaf00587b4cedd9a37b82253c6fda3ac9a732fc2349308daf0f745a6b1ef5d9701f522f692e70fa0947ccf8b91cc8a54db91a1b459aed54a777411558e874e6f99878d40d2b371fb3a61c097be79b5bc9536099aad25e2f570838fd6bfe64fa159628802cb1214fb1d21ccfa241251dad6656b93791c1872c18bd0978446d1910708d4a604ca6589e0b82303d4f68c5d37faf2e100339c678ad712635d7e12147963054bc414fd9053167654bebeecfbd39e5e215f5c022d17d0f0f626dc25f6ba05ca4aa8bbfaad8ee458d50e63a5fd2632ad64ff2841afa3da19f8b4ef5f23c63124c5ea239377c9fecf1d99569130bc1b53b0f1fd545f598a7993c40a4c87ff9c81ad426946baf308d236cb445d2cbf9dfba9cb9bfd33cd9d9df26f856f9a4c88d5425a5226f4a0e68edaf590cc9ceef1704ef35a595c82bf667b98688b4c2be6700e6f938f6cef63e784780255dfcf39c813e9069cba4631460a98924fe128ad67a5687704c73829133d21ee5cbab0097245e4ef3b9b650ad5add2851ae03cf2b97fa72ad04f09f5ea47cfe60efc29300064e4e3d7dec7813557543957846d41681a293e362834cd46a2e8eaa0503d1599ea77be03f42b2d5d934ae20c00ccf9b913529d67bf43177798d5d8b10dbfba2334e3eba1d0d7478dbc01e0844e3adff3162090466263807def9d7d520e730d3539705645400c5a5aaff76ac4026ea1d3f6e9395ce9c062591372e79820a9576511232525269ed7af64db61960880fbea4562c5371d157f3798aba8f83bb5b1f514547a7af230b40eae6516fa864c470663693af19cb96d3d3784f6e9f4a2f039bb5c715138c52c88543ad945042ef82ff197310ed215e39b28457d6f99b21fef4ef5197f4c5161df9f77ba280696308fa7481391e3adcd6ef1950435fa6197a5bf7c14d0d75d7fa5842138bdba7b7857a86801b3a66efe25958f9729286510165c1159f8b90ce4c96f778aa8c788c1f6f1d0345919dfd177bf82af8c558e7efc1b62cf23575be7d14a162ba504a70c92175f7f53adbc71eea08d25d91a07aa886aaa7a2ce459cd322d124324cdab01d73d6efc7a4555cd707c5368f1b4ed00a35dccc425f40556708c136bdc4ed699211973b2cfbf71257c1309ac6176ecb6babaecb6ef4e929cc08530ab557a41d4e0319925f8bcb241c1f6a16f2d0a1aa77a3392d2c5203412365136fe1e294d4256501a1d8bfefdc7609a8e6175a95f9444e36e117c536be055613b6d285f8ebca2d62e1dc5993ee59a91088f2012e514ff766a435580a423db9ab0dc3e69b0dcdc2eb75aead26296cb49c4760f1ba695c0b48ceb640b1a26d88ee1d144b940c5f23a8594170ad67174f0ce4f07b2d775211889a801a22405a2065777db327643969d5646df2fc3e6c5fe3b37f5c714d8251936d7f90f29f20f92459f19b7a930a7427e5c31f174f91ec00ff96953dff66d1f183e5dc3b362844b833ce37d0233fa958249333535d44f2572ab7926e74d0bd622cbc3d0533e26f2a6b783962ff19a6c3a1e6c97109a37ca90d2f98caad9dd87c26577e44206abf4079d965b8051d55e9a50cc11ab31b26c472533778ae6c6d8eb3a3388ceb3398b68b7b08877f2e6378736e0b2f3c5c298b29916b7be3c64974dbb7f3fe0c871dfcbb51e52c0b77a2f79325551dc42977cc8c1ca4e914b669c87471e135a99ac472f07066e782f05b2591c1e0dea9547b31e9eb3c6b5dfe63be51b2f66a1884e7dbcc815a5bd401b29c769ddcb5696ae40541c8d00154834c1b0312d8d4d881f234d0b8fdc500c7d6986bad353226032a37fc6d241681d6c738e9fac2b2d141128a06cfd17e8deab28d24a5299a0b0b11496582bece5baf3f2daf99866f90391c506d46f76fca7b78795b910488ae028ae274ae95265c24e4ba02c178a541418b37d13c372ed473d60e62b690ebf4484536ffd68e14269da4a5f92230e917b6e20c0620defcb12556bbeca51532cf2c3d61992944fffa4e5a2501a9e254a336014acef14e6dc47b0f269e0bb4d0bf1b619b61227f1cc473bf34aef25c2eb3a74ae7fdcdb2c4d4a78bd28fc19a61d90163b6bd0f87f95123f9af4a9fa1c73bc8465275a1bac118c06a3f1d6e93b822ac0307671cd05795a1b83006b406720e13c30fc448e18f97dfdbc178b23caabade25f9fc4561e5ce4833522f76c47f46d80324981e2c12364eba597a89389fcc6c46c250deb6f961c8e50aaa8d75468eabbcc33e838ebdaa86b2697d98a1ffaa2aff209e3c65f1a67c0d9005b48ea12e166d34bebcde7c97e7f5252977ba989b5d58d91190171ecda418e3f26fcc2448ec5eff63284a65ab628046eebd04eb19a29e9f62a3f0d987f0914c727b8fd142c7df2c5fe133a15cc15a41050123cdc9240cfd47d7eeee1ab14efd811ee1ee7e209e66f9392b068266282610e42bc7915c26e83a02deb99fb09b95f6b3b3e39ccb0424fff7763f4f7707b77f1bacaebc2fa99b8c6a56a73d166d4287a3b6e92d52f22bd681805dbc71eebb0c3145ed287488cb976e688b2574019516407642fcca39c12d98c692bd6e14bf075cd1c58c0b4849dfc6089501355e4f8695aea10c759e6033bd7e5ff667a759a75847888c9efd6a01a97cae915724d27bde54db4aa620329d3bba14786fa115e5d245a19f8b0f723be7c074d191c12b58477bbce4d96664c70c24bd4a12596964dd1008580f509090837704f436988840c3d678a97693f5e5a10c98783a9b78cfaf33849f6ce5eb0e65d19b53cc02a98e31c7720037ad4e0fbe04196db50c29d699b9cfc48a57862f666266066aef7c47e99389d3208c9b5ce65dca39e709fb57fcbab320c290b2c4eeeb401681fd66cec62f8ae80777d7b1919239d3649d579439485491854592e1a69d9d1a36659e61dd00d02342b2c292cbd0ebacde5163fade789865a328e9e472cd1dea59ae9db3af202129b5debbc65850264760c7adac36eb22419f88012e7dec793c2211c02e5aa4fb2eb4b4b4052eb1d91329fe39639942a0784ce8236e10f08c4b2a3d32e56aba0f5779af7a7ab36f879732d0014f0985e73d52325fe790e14940ecf9b6e0f970796a1bf452eed455d414f0ffef39775b11c83681c585e3a7556e0c123083911433b69a4ee149ac371ada03fea57217c19fc2a79f71bed8c3ab186023ffeada47b474145795f4cd838cdc91d41ddbe8e8b3a080e96d0be433d8f6ab2ccb26ddc6adcd5f28bb02909ea7b8ebdcbc7c1af006c5432e617e204ded61a0a3833956541221dd932ef27cfd9df7d52c4ec6bb844b41635a435377b4c2316a80f044ffe0f177ff5db10a54fe7fb6fb61dc5c30825106df19497476cf6d25e99d25a3aa57dd7738084f1d8cf9c1294db7df6abce20127deb9af90f35dbdd26170ea2b190da09a6de82c556bef600b68c1d38fc0fd1c4c13a0c949f73bbc2b0753b903008369d3fcc0ac9749291eae106724d32bcfa2be5c9a2d6cfb396dd5a0b826e950a19a91749466a53e043852ad3c9133fae3238a24308bfe48c973c866d65b4c70f8fcdb45ad166f9bb0fa395ac313e3000e762fa2040a17d0261869443894a6afc6d730d52b887b8557a6203e1a696c618f83ba30650d0d81b62e87239e889bcbbc0cdc457affccad76f7670d392e68861fc80aa6228fb079a56b9bc354b95143080dc04142fe58e086f740b929c5b314d73ad1b322f2dd6464c853d01e16d91b40b60530e9fd301c4cb978d1f80996c054c95a6c74e1f2f58e5a48a0a51a1ba1389fd4d8a94df61a44768053f978caa12c1660f1a0c067dcaff902abadc7587d490107b9b6e4d1d0265eaa747934b05735e7dbf85f8a3d21eec2847540b396a2f13c321132dfd2095928ca31abeae1a4d269e68df66353cacb7e3db7d930cc657f9ff2af39a62dbffd75e9a21b757f9adf9b9b3816452a4b633a2246ff71819e0d6eaf6fbfe8ac3b9cbf8852af4b6baf86ec8854701e88ab54b8d0ea082d5c4c3ab5cd23edcdcd360c43e6d5dab051d7b0b75f3c7ce5fbeca321f090b4ca1fa93f65cf26c3d85f690255884331e16785b50331ab4349f418309b28fc922bed1b762ccf866a5286b137cd035b086eb31351ed69bc474a86e3ae8e18b3fed6855a41a7a654a4d5d213b1d64adde874cbebfd77ca180129855d1356ae01682cac26d7df63576f5c037ee4679e7bd5874b039294813a61ce1f2c2cfb40f951803da50c33db8d1fbcc4b0613c7ddca2cf3c4a2a2e5b7f86f5e9c49d472681bf376eaba2d4c50244730fe3fb076dca36084c9d5841ce4c7a9203c76c621b326503763acae5fac0090bb581f74f9fe0aa199b83ae9766cb27d9ac7f1e688e7aff8a6fc3b8b0b1e89d7dac398b502e9ca54ab8f01036d2bdf580d95e81827ad7463b2662196ad1cb1621167f0cee38d41734abacbe026d1a615dc3580df297a2e078460002d3c074b6cf87d398393cd783904680522291fbf0781f75dbe7213ce886a337a3b83713561daf7e9d58a428a9f15a02778062e7bb8809ca7e95cd78d0cd795210c0d3c3e879688ff88904c5405accb36805e2e3e8cd61fbb8b25020022278d0df0b306d5e46eed57e5c14bb3d183043eea7e002a7bc2fbbbbc2858888169ec04e762dacf327fedfb24e10426da0c1cd31e353bc98da9590561144ef3caca6262f5bf2ac93cfeeb4257492a8a57dcc7e0f41bd514d61d8eede5b86e38206ca9cbd2b8a254db236bdffddf47e83b6016ad24b38591678d765cb9cb6ba92f7e5a304742d67c686ddcb8a297c6af68cc4bfc3cf974540df4f7d0241a65afc2a88a058b8f21caa0d0ebaae3d8d8fbd2bb64ae5d182f7d2b1e7bfb180b6978d5f20b29ddec8f8a614c6550992b5e1f2049b3b2b41c2ffbddcb556c43fd6b04a305c349629892b49787345488f573892ff6899a87d04f89d13b005d36ee5c47d1ab0b5cd45bb5fdef37ec9ef2f48b0f5d6df1acae52c27b0ac17d8b0aa6be942907122839af926fd49a91d17e305f74efbfea5ccbbdd2eaa4ff5054c3281ac4462120ec86671b881126e7161abb20f61d23ecfbd9fc2b4a3e596d4f3a0f8a86c2d81beb9ffddffcec0b72dd3ef1ae085c83c319cd51b1617f377dde3cf4647ffb1ce7956859c01a872c43c73b0a9938452eeaf84dffb936d48e7bac009aa09a192eead2d6969038114c911f03f2124da68274c8e464274474d7425029d364ab43248967e677f84c5e3eef91127e2cc02408bdc5fd9b6da777d62188556a0050222cff2c67da9bc9473005faa50616cc02458456825bf403d9e7aaaec6acca47919c8dc66906c96b2ddb8f6095ad67e7f83e7b9603a704ca3526ce24a7de3d545827497ac11060d3def1ad417f76cd70f10b40222f12a3fa0c1cfe42871c89df157e360fa07869450fb8f8d6bc6abd74dea328850043dd0bfa57845ed9eea150d3cf7eaaef2a7bdf5ea8f349f818e8011316d8ef5ea4361dc19bb09689ed93b5e96c61067e8589198308cb08ba6dabec8ef38464ea5b926c0baf2240220defa2309d2fcf11bd584cfaeefc2642aadfcd791b176faa9cd745017a2cb557967081ac36066f75eb1c0909c692173c4509e6bbdce076f22c32e0331b51c86af68412f68480dcba03ed7414b66b69be4daa16f5525b33fd046ffa8242e240b44969f9f2c3e0ff73fa81ad598d149e992b7a162d02c3197c925e55c7ac301b1b877d206c0c90d6c081e0e3c1e5b834bbfd64cd60cbf918f365f010abe5907d24d4945ef745145c3acc5f2fb3459d6bcac103528b6257b4193dfe090be8683547c675e920a6f60220044a5580e4baf52b9a3c591470f2f3a8608ffaf94079aa392ed7e36ee961e26acdf68a38fd1027d48c84e1c21dc5a8ceb2de0337fa1444cf046bf92e5738d02f462ac8e76d4fb3b7422304deca16865881c713da4fce46458a4d32ba2c6a589c787628d282a2d71be6dfe5ef476de1a6f28facfebf0abd58b836eda8a63c794ef805365e92cca29df093f612a231eafe2b30f2967e9f27226e682ca067f2e9e5701ea1368b4e3a9c741d5ca229976336776856abf3d0fd2625d108bd9bc13f806df87a935cea9d0bb199b8cac8a2223fb029cd7bccaded1722926513a65ec86b8a228711fa735bd2ed4fec97fb440fd0102a783ba5ea6d57943dd3c1b34b81b3f551c97b18dd71883f1b35a6a32b5b7fa96a7a1190fad897d0997bd6d93a555169076e92ef82c8add62478e050359ae489a56e01c353e0ebb92b5dba811e3e40811b1cf84845154ff7378823b3702257554687d0550d227ae92829c7e0f57ff8b427c26bfedcb34d11879cfdceb5d428bb6dbed5517dc26cfe043cdca758718fb6a4d65b81e0ccd42732cd1017bb7e250fb5a1505b903594c15b3ca8b378750aa0f7f01bdeedd1226461fcf4a95a3e9c0253506352869a06e9abe0f7532603ce005f126dbf82bba6bdbfbd8d2e6bbd6cf2c99958268a83990fb5191395f32e4b1dde153955e7c027c928744e23779d7669442794e718ad6e41328957975b7e16e999db8a1aeb38fe1aa85718260957ee9172c90bc20deeabc34a8f380df82d5214ec6afeb48a66dd1513c251abcf2c4295048e1fdd5818b1e76f8cd23a9c952b1041bc0ae7e85ee655de58eace04714e54487619e9cdef0966cffdf60c30db3fafcb5afc5adb8d7a1a3a2c1a615ae971a059e3dcd8333b1ef6d90cbf8f980144512321b2e0bfba7cb85335a5688defe731777a9b31ab83c0dc8ba9b62f231e5a2d46f17cc2c256e0df2c1b107fe528a4af7ccfefa526064d3ab54ae89c864cffd4e9bfe3e441a3fa8200c61de490058d0b43c138f0b7e6f15a97d4f21e89b7a87eeb45ba8af4579a04bb61d0592806dc65f57f575cf8ac703d9e17a5aed6e0e415ed150fd663f8a25fc0a3fad12c57158d296025eec188713c41d462fbfc34406ff600a1df6c6b6eb6dd4e21c32faac365f2e26ff2681c42ed0b3b7079e30715af1f1b1ecd7b93680b4395632131c62d7e76f4eb3909121395972f1acbecb764eafb0d11743bb3a8f4955c36ec00830e84bbb4fc164e7e72598d66e3e0a44ce330112cdbdd147a2a8129653985b6b6201961d2786a320992ffaeaf271481c1c8ed1ce3ccb08cd23a1d324eaccfbef81d18fc84308742c1806928438b2a76e73788f3dea168d3ac30670e5be47add05aa1a43964dbf1352f56d4e7b614a80526d9482568113f06cb67f4fbb92b1a66a0e118d9e695c0c2b7650e3b281f18d747ac77245484c4857ba71e67b37d850bd611c16c7059b953afadf0726167cad8ec3000a1e90826c9ed8b1b1b9bb7ef1f426f690069920b1dcecca46eac74fd8400c827de915303204e4c96e59798ee06779c034838515f06f67f945fe88d4d2c0824cf1e7f97f384ab58560c9a7ba117d60830f8975614de21483b17ce163349bffbb74ebde6ec989280f422ff063a079d4c334c96852355071367225b0b4b83a069fd86ebcd46313a9c3f9703993a40c7202f90e00cd99eee8ed9d7630b7f87fc640371c72644b7ffaac2e8cc4c6f707ca2513fb66f4d390b018f333557f50f8795a74640e1cc7b3eb355230ab9c5fd4cd2e1885fb356127a3095f0594641f2eac3a803d2da3fc6c243da2195212045393ab3e3f2b66b19103977681b6a48fe28ab1410657f58422714e97bebd76571fc1064773d1792b6046de9d85d4c76cbc0e6eb1ebc03ed365a9c235d3ea239d3fa32fb6dd6dc3efcddfe821d5b7e1676df605edbd63429055d5738fb0c90a0987500d5dc6a82f3d4623258e8d3bfdd5f9135fc27efc971aba3a4bfb5928a18b0caaacfb4583cc2b7a8cd76d56fc6b8eda1d3845047ac599bc8b82ce5c7d7312232cd7dfe6071f611aeacf6bf1fbc49f3494db2d3df88229cf36a833b1f23b9f5af4c4263c343ced5de6f6d58c059738cf2f27a8ac237782905ad39651cf61b9784102b103ea8e825fd43edfc74d21e26df82294bd7f89e7d56d6df1a68f951213ebbd2b65ad258c4e68e86a32aa3f9fb2c5ebaddfdb5896faa24be95fe3b2d0318e053f4a0afad901819fb1e0f4545e5a65dde3a50ee6d20d090df0f7d475048cd35710d9b7427335d3c684bbb0af1fd0a2ed3a44d6ae88fcf0dee9899d46883c0fd1b090f9c462fec8fc44a5b0f60230e83e5642faec4899ce1aaff8e237ec2a4167898fe1e1678e63795f019906c1d182e76f24637e0ebe86b949e24f1e0d1688c928310cd08ac260ea39bf8462d8c46cea0bab4f1cf23da35cdd385e0f35f1923fcc71cd3ab9503991543ec0e33b8300e30c6eff85cc1ed545b1fa7c9d6d49142fc08a436ec1fe0273fcb5cd8c9023fbfe3a44e8a9a07960c1c6bbfbe1931bc6f4f68d4022a2dc183e05018a403c2a01ed69e679721808cc58e33e1659a3cd094ab5f82bb4ea85bc93578b4b3344058968bd8eb2c5e07b685c9b9d7083ecee8780faab6d5b5bc86ef35f48b21ca042ac4b611874046058c7341a3e4dedf58f6eb862c29326b1977ea8273d772fdb372de8468c27d6cb1c25a5b83671fa5717d65227305abaa0418f775a0907d1bff7a972b7a579ae32c00d262e333d6d3a31f5bfda274473c2524a23169ffc9bb0d3f8d1117a4f92f5b7a6d700a0e96282f80166c8d6c23538350c4999ec3433b9ccd01bdb037d752325b0a82aab78fa64e828c3c5e5f8f77c27fa0e6c574f35791546a9583c463738a2533ad32521793c6afaa69807b163295e6a18baafc1f3a74a25d3c5de63977f056dfdfd471c3e4772112ea362b6a62830a68440f5a236032d88051fbecfc25e1d289c930a904437924f705cee01f60475c0025dc96f382a67c4eb7294f6d2f6ea62ff13820472420f50039dbef2c1397b130819bd090ec91be8881cb97b28e3ebc70f63c8b0a30e3d8db33433f20da1e60727fc2e15de208a3a98fd14fe6540124be7e6a32e5d82022d2ea3c2a9116e0e7276cfcd4752bdb970c5b262c9b8f1fff9bc40273d597b795e5d65c81e2c7f23d5369149f3c202b211da22b10491e5a2722a4f19782996e04349cc282cc9ace070195dbd139b380cfdab346f786d7c771b18ace6f2650fb7fc82e128aacd23ae75fd3327f1c0a841427f4cc5be473aa8bbc26277c070de7fc3004920f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
