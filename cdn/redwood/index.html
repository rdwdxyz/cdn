<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30756c9382a7d0c66095edf40110b2301a567de2a9cbc5056332c0ff5bfe6474dc4535a9920bd0e056a858835c132c02d9a1f5d7efaabf15c1aab6294e116e137ca141144659c6c5c82e1936f0f1c2959c2e708c1d9fa5e34b35f1b3e731b460c790897569ae9c93385fb39a04cc000e5caea6007a5e43c23e5b9589d751414ec257167784b5c2cfc49722dc8c031b65c9fe1af648534f223a86fbeb4aac1ec63101590fe05b526dc90d2d1e62f4097437841274652a4c6eeabeabd7b0fc21bc1b54d1d9773a3548dca96c8423906048fca93a8e6bb27d1d295e0db4bd4c6dc750fe64f7c074d6430002fb0722516b821bc717a6de8987e3c3f953fc51365b242c35fbbafe2493c74fb31e1984e4e69314643a9a1d9527b7cf364c390601c0737c7252ef28c1bb0327a96ad1ca02286c09096fa84279db50afd057d7095389030f6a790123a280971cfdf3bd1242c22ef0acc5123848c86e30ee0854e5a8b69f56da28d5aaf186c443113cc1e92f58862b946e3ded51a63da2b219e5e78e301f03d62184cd9da431f5f0ae056fbd303f6cf62b5e4f56707c5bb8b4fe1d926df976478126f460d0f0faae39580dafbb1d02d65f47248e3ed6e3cfc5c821a174986fddbfb925af2f18a239f1a64e1f8d3c5ee3bdc16296689c32deec3f24940fcd801e70ec4dd18b5d195e7a9d86cae9cc6a84d07efa184b5cd69643389ac170fa50edf90840a61d5721c9d2642fa7aed8e419a9bad33a06473ac73bb75dc1267e66f4a3ce22b0ac8866151ec5cb9d59e7d094f1e0683ba12e1d736e979d0698816cbbda7698ebbf617478908476688036b65688404f118f06584a977d44c1409e598143637c03455bc8d76b619c78d579fc5b8a3e65625c17049c8ff7fc84adb1173575ab2e59c9beb5ccc85a5cc6e6958062da51819ca24e833b79d74ab04ce2ce527c482e3a5012e31b3f10600bd03982858610b9326de78430a91aee41f8276a7037e33b5569df6c44484b639439afbef083c137882670e4356c3abcb54203c63871f5954644241c347d3984c59fd69a4ace9b2ac8290058d525f74a9c57a394b09c1c7daeae71eacfbd5ee76624f81ec0291f2ebe1f873a0a2b366148051c773a2a9163f8edd143e9d5a7828e65f8deb6db6b5eb3667a2960e2613db3dcced8b292ded3a0f37e2c79c6ba49cab1e075fd4b1eed8988afa09b817ac9dce31e222451a034d1a09143b963bc10862d484d4eac4b8c61eee2193f386295a8d90392bee0604ca3422f8b00b4a6eb9896d6630337a2405ec8d80bbcb22f18adfcc684d67a2c6716a17b83d3efcb3125a7259276edeef846731159cc4f69b706f9a92360ab4c81fba7f1dc2fd4522a41d28c0148d4c3d1986cc853b7d056c0c84910c74ff9fe6a6e161863282758614f633846f2010ceef4ccf5dfd32663bf38663207ea74cfdbcd51a139563ce0a8932decccbdb705715ba09da19f872e3d920d7aad34a463ff0b2f016b503f627b18771a7054b14aecda5a40d252687016ebad241d7456b81e0432a4f7977ba7a68665a0b725ecb37fc45405d3783ab843ca2270600fb42592677d108edb463c1ea7dfc5ce6b17321ca3b7b8046a5ec7011a6da15dff665e187aa4a92b28c326ae7a7ab9f72b661af9695c64c45c5ad9c03b2ac09fe925a4accdca2b0a54e369a04f2594c5ba2911e1cf019defdad814e89aa8bd6c4757f4289a725f409a15cf980258964f42ffe653545a78943aced66f78cc5eec0151b9a00e2cdd49d5884c7b83a183f235f4fdb060a4a02bb72cac89276f1322943d644fcbe64171deef52cad934f8e4bb32c2e30fbfe4e1a534534a07ebd200ddbe34fdae03d9f4d2fd334ea15dbc15f7adbf45ffb458751fb3c3146861bdaa60a9acadf31d9e345d1a476030748381b70c2c944669f3f0a28352bfaa6ea7bd2496f4d1c839914df832a424e78293b289992977d5a150d7112ff6728ebdd30a06b6861af770b121f15d048b6aaa9854abba6c60ac0961a1df240756ce35818582a984af085c4879811451b97a03c6919e5d2ee915e67cb811fcf09ce766d21997e9fa2ace6efda26bc15459a89a269583fc497f2d72e413e58d6f99a4b13b959072c2192e0c91922138973dee052aa8df11ec2dec97e42481251b77bd06a8d5c68c3e0cc4ab89e09318455abcf6fc7a4b8614194bc43d21f8d492f2a1aa4082c72c548f1a87a0d467528ebbbacb6e9a31ba624e12ced3897759aa554759b4d0527ec8070e9bc3a717262e5e8b4ade4983e20d5af4be7a2e195c1594a413c65df28702fc99cd167c60f4cbf7b79d79523935c11e04c73b946de22e3af194e830e7dbea7354e8b1e92084cf41273f1caa3d7f0edeca4aefcc5ee1b956b33dccdb398105503712e2d2b8cd8a586f6b61280ca3f0faea1bbfa686c3e2bc425160756dfdfa8eb5e51a0a4cef25596886bec26452599bc6589c128d434bdae44a4d25fa155110d3aa9bb58dee8fa92fd17d532beff11f5b52b7ee0ec053347e701eb0484e8a5071a6d7e6cbbdaf38e1599ef066b968ba9e6622ce98be2a31cf46a65824540c6dff4c322a58e6ecb7a29e4fd34c4e38e9fa251c17ebdb6a97bc49a4ebd77436e78ccf73d9f0feb2ec4eb24190c1aced3c956129994aaa4c273c2faca89b807ab01b372a0a54844cdc59df7378abffef418d96751fe54df72a7fdd4e042eede0097fe8d96507b71da8328e48c7b571cbc0244ead23ddf388ef528415a126ca52509ca15f9e2980622a8ed8edaabf549c7514a5eb2d73750217d4e858890333f29818f28956f330f41d873eec2666f0152178516ccb68f1aa8c148ff131c65c3d4ac4699fff259530e6250cf646b83a8f04bdab616c86172753950f498f56db83f29808350e2772eb6aa61d3f37f36ed8ff229870d7c249e49f99c45a8a48f52ffacb5678fd9f869bbe5059cddf8caba91a24293a7419ca3854732591640115e9bf08db46bc2f199644bb8d7d1d7ce63e0303d99a8a229ea5655344e92cc2051d1ccab37f7df05b251ae4e2292600e6a0a20363cddeb1351fec9a46b4e5e6c5dd30a1c7803c913d7db57c8e12621b461f920543e56e37784c8daa1c616e5b49cc0ae2e1438b18aa76575abf89eda8886cb961f682904347322262a39ae4cc73b10d7a1971eb1f1109903fa7a279dfb1aa8fb21c1209a34a50b290d438d30efc5dd990c0f923ba8c804a3636a5e54f36562fca020d5bf870d62be7fefbb27eae87327f952ca73a7873ede89d00cbfc9c4a8025351768e431351e4df514180a158e9ec31d7b85f50fd300f53eb0467c482114b0b1cf33f7514d8fe0e5267432891fef173c7819ef0f39533acaf06afc42c706a04ddef34bf89df51574d4623fb292af43727b9b51d7868a201fcbb63d93b032c924cf7ac53bd1d4fc6088f16f2523eb9ee80f854f3dd9cc4ce13e382d1c79459a59084874235057e27f4bd1b6598e2dadac74fa2d49b7162e44596b4f6b3743e88e16a67bdce0ad85a03c750c5adad3a2ebebcac7617a054a83020b7faa55e4de6cf7788b54d3a3fb53a5946186e80391438b13a85ecfba8700002c930bcbde82ffb5004abce069f7f861853f180068e2b736515f719173251149982b3c305c926db42b8b89739d190c54b481c5d45fb10c51e7f9537865a1c3e1aef5f56e0f94cc9d0526e93b58a3e83359568b1f5e2952d9348a8b90e1fe49de7239b4255f82c61ea195ce49a432f5ff1ed6dc70fc3e0e07b8543f902203619a2815fe120d3a1b4f47dfeffa59c5a9f4e54bfcd89f559e494e6190968700d7abc6d0ab46f35e09f1c5719c7fc8cfde463fd643cc2b69dcb64772b0f8ca7cd7194eb9a07ca352224c5b6accc8bbef73019b1b99631506f947c834b9a59ec4073a7e36ca2c76b69c65c8a330a26d3b937d191c2a3052c2b18a78bc9439be721db922c774d9df0d92d2c9688cabb73fbbb2088fde832e6dcd04798e450e00c785abe80b800acc641e49328c5d28d9083dcd314082199435aba64a695b0e24d4ee0eccfdf09613ae2b3ba9d33269dbf73ad78a3982896039acccd722fa3b42603cccb1ada4ba57500c4594b59cf8375215b143fbba6d98b584998adb0d0903843f5d43dfe7e7f93d3e51bfb63bae7ce996da13db83eec5e979fb1547479072e6bcde4503a423e0507afd7d088b966dd9c06d82e5fe69e082233d1e7b7d8b0b21a881c5914b1d89febdaf0366fca700f684a78533a1b8dd164276b3b2c462ff9d8bfc242f0a9c6945b51b25cfca34df70db8185d098056e515b27c7a9ebf1ee825ecc34b444e58d662d61390d1c66832b3770e5f99694528e2a18fc7eeacc781c9f7d20048efb1fa0f32e376969a60b90d3d2d69f8d2d4a7895d8891161da313e0487486836f518b3c90a2e794789758238de1caccf8e8077188191d0adcad696719df8265bdbc5cdfff78f1ea498c7f0495e0e692d28b9aa87a6b031aa0500a2ec0634f368c4536045a9a511136fac42d1cf4e0058c93ac58f8e7915c926275c99a67c7e6824dda5f89c232de5e208db49e07dd1ef9ecfc4c4bf290845e353bc9730ba2e967508e227b0ea7a68c601cd2acb0382d61deb708f12dbaaec35b46788335a442cbc787973abde165488a42224c94bf8c90562643448ef949dfe3445e7b57e5a724f20c8c9bd8921c841565f43b1790308f9d642b83929c41a100e30907f1e2f8a1031fa81afb22faa9fc96c3412a0f2f0437dbbb146dbd5342b5d4625e99c01bdd734cd63fc549ac754ab374d3e1ef95c21d48847ab840e64559115364f8bf279b28a01738946c1b59c2aefaa75c7d86123d605b679c6a8a6bcae1db106ad690b669a540ac03f3fb1ae29f29cc3ab9b3cfc3bd13089417d8605d2bf6cc1b47f5cd21654b55322d3908908b90126aa0b06402fa57e26a6871fa8fa78ab3a3445f8b412e3bce94520a698eb7ab3f067cb83968154052a2124dbd0bfefcd1df56fecb289a6208d4e7a74c5cdb1e59e2570c70d89c625fcfb925b1eb992ec9ef25bfb062b6671d63cb8e25223c83b94b7363ec1f39e2965b8482c7aefc09d80aed86ac00d787eab2a5467afc5bbc947d5bef41d44d957256e37dcbc97fb771fe02669e81b5a8f9d6b097e69e5f6ab98968ebf7f0fbd26591620ae5b82595e6638545dfaed1f663ec84e51bf66fe7776f551ad4115fa0acb4eb6a501114641110087962598df1925f14fab39ae75ebbbeed077c9451b371825ccf5e3b8275596502099dec6ebca0fd0fa1d2516fe3f41399dc7212b68c1884d1712913f50b59944f8ec306807d59de7b90fd19256a2be0d4aa2991737df1c815f1f962358a9e8ba122dcf0d97ee5564aebedd4a00cd040d4707fb8798385519811926a3e37e3047466d9f9a7ca8b1ce718ff537d9f9410c8cc001f09d0660f0534e1e582900beb49041e13c9875f8a57f47452a4801e00f444be1119979c8d2ff2ed4684e72f94a83d61f8aa6e37ac3336776c928a4661bf2ab3d7ba72461d7b02dfc277d9c47fa5a386ca91f66057e3d0a7e740f8b1f289b1be438754e37c40f4e59f3330b6341c56622c9580ff401b555c8d9a840359ccbf56f68d0b8f92384669ecb9df6e14e94030b44e660dfa3838d1a2ada45dd6815e81ab7a45a00e921a8a5d43bfb9f3b3a13f2f096c326946692d419de7cbe0ab764e31aee0bd25c3d8dec062ecf121261103a989bfc8adf6746be3ebeddc733cbaff062d59469af8781496695e1e8c3205d8a9427906d2db22432a9673bcefbd3a6911684d1122e4f2238b4b726d2d140f4a93e8b6c4d1016e9e5c2bb7db7caaf0e6bf73ce5c3af314e509ab9d9709848934008b10faa8ac1aa64eb6a9f5d4fac4b9de13cb14b48e412ef8e4f2081aa22828435571e3613880223945c84b2889039faed1ee8a7f97b35b560a0d8dcc0c4ef83be83015bc9ac81e3734e83129c9b50b924ed3950cae21d0ce8e8602194624f6e3f6421760785952c10eafaac7a43f6ed492f105a5eee148a249b7bb6a26fede3987cc30b5e7cadcb6526100cd05fcf89d9b76c45f57b14f9f828db2692438e9452794ef9f29feec437d34049782a33fae05c6c06567f5d1e83d5d8ad78eea8fd24423e699b0f10f805c017a7c12086b3f0bbd403d170e728fd3e3ad7cc72187801666b2221367b13b4b477189b83ee0570645d6443c7baa8ffe827da0fee9d4b1f273a3dce89f861daa98b0b53fd228e966077b4f2fb8aa16d7c9616c7bc82a0d60bd2e2739a88c85c12199fd550d1a2038c73565205b3f4f129f66ba50b0e8afda5bbf29d683ed8fefc6b3dbb71eb5c0dd570672e74d67a0f3468aa9c150fc6bcabf06ddb6cdad4b72ec26200d1046110ba5969734f083651bf68c71236698679f89aa273ae915d7cb471872ee284f164715b7a57b6168d70c032d27662aa8f880eceb75d021f60297f0fab85fb68a5e5c88ac4f74e0aea4057750831900727cfcaa01c4a053617bc58f3247dd817552996ef40c68c5d2bd4c2ee44ca09adc30e296bb34e2af4f8fb1e44ff68782946a4a0492c767a7c02186e5e6edc859c08630498c5ae24d9e680a2a84e9b00132efb42248b93497d53d3503d6b4a1ca57ba7163bffd1889473338f71b1f8e580d28d72e2ce6a193ec392f2950b25495363d92801a0946e430292262e1af2c907bbfc45acb2875774bbef9be5e41173daf71859a65db4cb943566cdc7dad5ef9199ff01d8550520094ef90c3194444f46959802fa333af597c5e179965b9ef4a0a7c932d69a8889e624abd55904046e616b741baa46608b43c1b0cc5703a868e71f72a971d48f1a23a875a9df7fd3afd54a5da94a20bc32bced79dabe35c178b2be259abee189952720a9c85df6152e6ec08d197125d21a9a736bc3f594b22103de9b8cdbfcf8e0806a651b1fdab01c41dbbab82afeaf464abc02f50ec9a94ebfba0109bf7f0af581b8f20b817c15192a63ef0af798bb8e1d153fd79fc3fde95327dff2a3aae660447f2a908bf99332c527d7ba8c1e3dca2e6abd38bb5d95fed6edc585789ee1be24ae14649ed64a3e6effe59ebaebfa1148de002d50d49cf92871ed29493003ae62efccc032042f9112ebca1e651f9f383807e693d2c657876fd04048696e7c988e63379180a1a83bbc0ba053bc149ddb209cf1780a2f66e2bbdd5f01dae367d2cc8bd8bcfe99d03d4e9cd0d21dd7bb68836bafb98b04bdaa5e569f216b41d41ddc630392392aa5d72e6f728b8df6b5cba52bf167e46b7f88b40ece781ff9e72b7c5d4dc92935ced26daf3634713203c49fc47f071e99a4d4de7d85242f21773a365ad78af0da24bc7003cbe8cd0cafdf6e63eeb5add8da42e508d4a5cd0453517bcb308e3a92d713db68c8c354969c5832f168334f79d174c50fe321314af479f1ef1a32f334bcafbd6a1526261b8bd3b4a12b4c25244ece3046c6203ed418d47500e6ddd9dd482b224de4d0dbbc63a9e57948f21c59275e19cc6293d395708a4591aeaa4a9e80794d2cd09882071030eeba63e5bf7ec9f6ab660347843f6827c9a950652517cbe753d655e45069d9b0f27c6d96bfa0a4d5790230ce75ea5848ea9278e3118643f628db755830e7e3b4ed426cdfd63e177114156018d7167c3f6ba9d79fceea803ac66cc5c3e18968cd56338a72590c9226dcd00f619ae086b5f81cfa013607752e55de5cb48db0d406a2ed091cfe8239ffc196870a391362042271dab0c1015d3ad17192fd8df0686f4b54a1a0a223e651e941b9bd84df81f72d4b35b0af5d173451ffa6868f40f53e6111374d90d3c649328fa32589c18f4f84e04dc9ce8eab972baa2223e61401e1f014129dcd2f8c8277067a01a028c6829e478054e36a6ef3463cbc049d8bed924f36e4f851b690a49200e48898ca26319d55ec39597b210f1b4aa61eafd7968244f4535fe6763f4acd0172fa958c9eaa866f32780ccb021e1e8753cc2e19b553976ea5107579531c0a0cc051d37b2a929ffdc2c65b8e414a747e7afbf35346c805b55e5cdd3e2fa6f00d9a3d65a34c4ac5c1f76e2f8520d8ad67472a2b94c0320541c0deeed7c31146e3cb3c8b4cce0cb0ca2c150f627bfef727e265ca1d1949a7afe698a9344499aa06a12e53fca183abd1cbed308399b1dbfaa0e98aba385743f3418908567cd0880865f47ca45e04ec2702300737b53ad133f2eca11a7975bbe7cef78a475385a61dcf31734d7e14d58f258fb1d4451e21003ccd93b6024fa4ff4abc9c16e445422509fdc68b775ad34c74be59f468294b38ff46dbce2cd6bd99f25f1a2d196d8b1fa782d1cb62c8b65456f4b3369facaa6e7e45e9a18dc0cd05e85e734a72f01116f11c01c33e28e7eff4f9e32f6c8e74e9172f3479d71bc06b17c0c4acd8cbb28bfc841abcd6bf719554dc4ff25b924b861d7c5c4408a111f76939d17614663532f0e41cfdf20c033f578fdefa2d34ea26468aa0baf059acac868a9cf4e7fc06b77764f90618873047c2608dd8bc3b00d576a9d25eaa331e3f2329af67f65a484deb89c58dbdfe909b528ca2c6537d0ce10a1fd5666afdf16fc646ebfbf5800fca2f081cc419cec16ace299143a3f39ab5a699a6dc8853ff13a8e6fb5ce17a2eaa95223378decad535cedf5915a26c216c9e655e18e88cbc7e7fe8a7c97ec8e4959564f9c0590115e29a5d3638f5bf49a9c244318339371549f5e9445cd8e86d9d016cdaeb7b3d727f7967276775a51ccfa8bb18a552848fc58471b333e51c74427cc2afc87e1d97cb8baeb7f59ac0a8492a34910430f56f2769e06942b47f93b11e0c8384cfaf1c71870e5fc9afe1709e7e17b8b05d9fcea2a24ef8129fb233ebb8710c59d97461c587fa7bd1e836a0d3541757a3d76fb4f241bc0b85d1bf021a97d12d879788bb56a9c2e5d8d5030d66680ce1fd51e7967898ea6ce9b9ad8e5048e2488b20ab5338dae02b8cc2e4e09e2f49025a113859a5ffee11bbc13e2aba9c2347877e404d975021d101754cef7e1c97a023f3fea83cda28fa74018aae9e32352765b4f74716faebe010191bc890f9c484964b1c3b01de83899a191364a7ce17732cde32ebbee55e870f549d383f9524936922d7ade46c13f61d2a9887810b62ebefd6dd1db119781ca03294cfec98d68ea4f1bf95b6793634d22cb2e9c26ec1ad82e70f9e9e26c6fb3c685cfa7868d03c785ee8cdd695f38c67721f73fa72df123e375ed3fad06b7fa4fdf0d955e2fea8fd78698bb2b4ab94d6030b3fe61a7910c62e13df07e053221d7f6b58b60951e0d813e74e5b0a4ec6c47e533adf458599725937a3c3415b3cb228af391f4dc92d9dc1ba52da45c452fcd27d77f1b6186908b2575e8d8db0d8c2afa7f6890de45c38b7331ce3d38be0370452d791ba42f36978b0bf5b43c349c67f1558a2f6f66e395475088809a15018f115a19e0605a2a995ad12079a33b307e4e58c9160749bdec33220622863c87ea282bc32f1dd72c472987bdf1883ad82fbcf54c4c67e8297e9d51ab8cfbb7e16c66a25deb003f2582be2982000cbdba7c3a3bc73f8f6e77f1b7845921dfd5876e43471da5e88778ea2956e8ef092d6dcf77d1a10eca4a7dc983f54b0507191812a769351f4e61ddea7adcc1b94269605f18aa3e7bc9a1e387a523221a99ecd5986df243850b059716cef7fff536eb264f088588d766fcceee8c17e58adcada21cb6e5409b45481831919f70ece919bcfdcf5cd6fd12a05e6788f94a0ea28d544c3254965898544ff277b02b375b477dbf2a6ea50dc764802122fd568f85189acb4d60673f847b24a87801a089ecdf8d4144a0c93b28c42adb28ddf2c9707a79d83b35e1c4cc14f552cc514f63f3df95daf57a3426ca9e30b181243efe708d4beceefcba6a4a9b50686a79e71a67c4fbc8f9523fa590d1c0bb4022ae05b9d80f98a414e217ad1eb88cb7aa429fe4f8438a5a31ecc26eb055454a2114f0b924410dcd619c4ce8ebc9f63466d836e66087766356bfcbc8914e44951431afd52d8dec911c2881c1da05568d2285b8cd0c10ed125c71e9a70d3c8af306d52cec525abe98605bbe86152565324b13c44c926a30bb991623773a87dd204fe55d9223a77eebd470e6a33e76d6bca5d76aaf9983808055f1926b74dfd2f6e7fd395c0483c6c90b06d214515cc0396bf50f0755852731e0270535d2883276f0de2105c7aa226776085492f58b2ca938c4c881601b54c4423bd8d7bc8e3f82f7c5742c122f0978ef1b475efd0554c7a67b6ecadbffd9149b07670bdc0839e83bec5fd643556639cacc565c0422e905401e2abf52be84aff8a178bf0d7e758dbf2de94833e759944e581e552087b38168be46d2db2cd9c468d58ecdc6b09207fe171027b03884c03bf0989ef1b653a279f94cf3c117e4b1f792249348ec544a472e47d747bce0879f6a59dd3c6f57f9883bb71d941494fba85843575fc4f1163fb136f1f9dcbfa99eff562c629131ca0a54ffd4062c80a7776de60f1b2e427e6b04e146bd5d5697e67fe325d4abb0edf67cf7525f0be88e257030d601fcff6b3f40a9009518297d60f31a836fd76a00cc490ecaadaff20b4fe7df695f4108a6985014ff100ba865e1b6cb2f5d8ff3bd49c73e310cbdc77899c4ed235cc7d81b6db9a548a160e3287c7cc259693de814b395f0e96571c93bdac431db395eddc8a675475e43dedd8ae2eaebc444e725c2e9625ed838d990040ce521a53841eb3600e6bcd2ed41a252a93f1563d35683e80e621d34a478722f19d0789b375a720888aed7b5b94977bbe8e989c7d37f8db50b11dd77a17907b24b533791cec90b00ddda4895eb9d872c0311ccba6eb66c2f313a6652bf8c5097eb6a3de7e6467c7be3a359e2c45cf7379245f1f556ff1b95d00f92b4018db95752c3da87f5fa477857d438c59f404534d5bd0dbbbe97d9cc87d0dc02022c326de8ab65d2d217b64da4f02b9b16e8e28b6d9281b2dbc8ecf02d6f00c0b04c12d1be5611fb4e88fd684bfc911825036246143b885701a698e3fddf772269521b3a587aed14e0dad9c714a5693f3a20473798a4f207b24db02ed0a7bdf6de39ca86b01ce55ec887a2e3d0271f678a1ccc5d97b0ac6f15e34961b1f871c30b690d4cce048d07bdc3fb1a431f562fb59302ccc6cda2f32277c688d767cd771178ea742f1294c94ee69d9ab4582a8e7e7fbc1146a3d552500711c7723e92d6434ab271c5a05d90960b6f8171d140b23bc023593189ea0aef0804d298a1e04a8f1c855503db91e96a27e1414f58ed4d2c16ecaec5e707334decfb0fe30e50385a6faae1fd22a8ccc26a9bf556a0a43c4114e73061d4a463643e05e06fcf6f86148f7a7dca72dd87374db1f0280fd3976df324d8c882be8c01153a1952090bc98ead7a21a56ac332a93b818b73ade03cc3a1a22c8888caf3c8136d35d9a29a660781ec9641f55d30c1a8fcdf48281c18d37c7d0dcce2c2639ac3c16fc2b7d52b563cfb51ed1f5cb66ea0d5877172f185751ef2a07d1dabc63b9432430d02eeb583b638ebdbd06104c42c2b60860f15905081e77470175e7dbd83c180153e9cd6f92793683bdcc52ce23770841bb6e2ebd60a3f3763ab9919eabaf1908433c888ee8d231bf249d87e68d2c668d70fd016acadeed808ef08eec5d0257391c574f2ca9a3d60a5c6e6f9fc7eea20e3f338fb3b12d890534afe6003158a9e0e22312c62bf6b698ebc0cc823ab805534edde8bd130579dc974d724a57affbf04ef350270e39a4bcc1242562a6993a76fa604a4b78f399a67feccb3bf5dec5dec2263ccf9fe62237a83a1c00a2fc2ff699255bb0c8654962bb5e42daa1fccbd1e594f3529c44878530c2fbaea0e995b860b5ae2b2161c96a59f07f51019af037807747186f56866518fe3f3b7e538f7f696e28bc161bd4f45bf85ca7373d3dc7b757fede2919adda9bb95eb2e505a2b78fd40941ae11f7fa147ebcbd78dd3574758812a12611c0527cb06590bc2acaa514c31a246d2c60a695fc3c8411d1856a5e28392bb9caf3c3ea08d59542fc97f2d572fd0a040e853743b4c15fcf1a6acc424d2ca9cf5de4bd8623e33d50649b2dde2a599b5ef5c17aad9b858f9903e417785f9e568571496105641442ca721592ed0ee0d8e2b3ecd0251dd499554e5a465b9d51be18d5544adb8bec2a12dd3e1f180479a5fe43fa3b2424c97cce76e8a5e128eaadeddb6f406e9c1e1ad2ee507aec14f04b449a0115c9c3718a45dad3c3a78f288a1b28198d2f8568f8206b1ab6458e121da6cc8e4a32e72711673b472e3dc4d580087da31effb6db9a229fee5e614df5db339be1e24fcc0a3431c509128085ce95da7f7551af36aa1708887370ce46fba587bfcf96362f0663f33a62fd99053e477554333f62775218ce0fba2339c4728f5898e6410d60dd291c56a4381d48b9648367e040e5ad0683a50b6fa76c6181a4241d3461861e28acc6effefaf52cfe089e8e5cc975e8e874330b46072389505bb0d40753bee2cfe4a04c029185b6ead383acca700e8f32684a7c7d30651f03ae9fe70ee8bac4722d1e98e6e0db2e7ca38a1dfa66d17ed42b5d204f4ed68022cd38c2408a9f2d769696b0b65b9e75cd49260001a1ba743ba51ab35b5a5b3a5b4048af2f82032220e3ffc0b47a2fec29748e2199611dc355c71b3e959b34160ccb76a4d067f2f94343acbf4d4fde9a0288cacf85651da06feef8545db16016f59a73d6f609d3298c8e48f5b3a17e3adde21f44058e699c86ec1cf5858e579bc10c31759d0052c6ff4e3eca8ad3e10af4f81e54f8dd7dcc44a97be1a6f6eb7a0e945de319c355bafa83b3947dd76bbdcd7b09200f7e9781bf2304f7bd0d8adbaaee7badc19f00aa50bdf544f6727ba66c88d3f053a7d1f34f14e7dc172a92f06fe91a640917d9e5f0475552253d99c58651e07ba97885cb190b51eb51c684a1c8c45a2866f91f4cce8553b34272be3d76bd584738b0900c024ff87866137f981db8ebf3a8a6f88c57c86bb9899ebbf1a504753e1406bc022f3716fcf7eb8ec1ca979557149b80e4a398227f4eac34197d4ae7a3ae3f86488e9aabcb6bf381d0b1edc580fd7115a45f8f137da157247e64ff3c9473c1188bbdd860282901d2ce8bf76c2ae8c3e2a695113f1430ff53453bde424ef6f957f158d3ad5b92c38352d1a65ba57eb6d65d6887361d3643b4d47accba0bc07f4e2939442c75a4480efb1332b719d99acaa9ac616f66582f39b1a2b7ee71254b6d4e46140ba57987b88c997206821fc9ba716145129d387dc60c5902bebbba8b4553033b9da93044cac480c1e8de9e22b6a3ed7a5aef107b0bb8d19ac52e424f0be9c991674f227357a969a7183eb87c6b2b8b2e2be1e8e8789e5fcc79f4b232b5aa614bc875a3a479e4daf0cbd04a771338f3818043faedbf9afe6081d219370fed7f261e2815d362cabbf44526fbbaa7ade16c76204f9c48e9ecbdcc9fd00f4c7c717eddb8cc6b72a3431129fd9d0cc51e00b0ac76bf862ae1a23eba62d88009ff4240cae198389c1982a80135931fdbc4e14468e97a57002e64d70c79571824d73f84586e0c904cf3a799a3153dd6524242a2c36b84b50dbc56537c4f023fc87cb00cca7bc7efd3042bef13e2578f01def5cd66a10a65a4fb85a0fd3eacc5681db4add973ac920e86af429d8dfe22e86f69480f79616369f59b2b337cdc8e1fd23cf62c7d9426ffeb5afff8185f6a0a4bda92547a7509c6e1dcae00faedc00c8e106347547a9a34f1cc4b050244b51ada79db39bfc2af5d176eb0f30d8fb37866596d1a66ba29e3723a7bf8a8e1096ac70b1cd0bf25a200564bc4418ad2a0a218fb0e0557325f1a1886abb6097ccf3d09df8c4473bfbe6add6f10ca248c64bcf6e00cddc5e7427d692e9851922b27d6b81f744624a9106963c04ce00e2195a427e9134985e929aa2d1aa34b324fb18ece099781b4734681e9836c861864f36cdc5ba383e39d2f61e1f672b0c762ebc9fa1b36b9ae9441cf72bfb0db7d507c26781fde80f39a586bb0e6a3697213c401c76604dadfbb83ffa9738753c50240e8672f700cd3274187a41377d451782d797fd017ea3b3efe66721e7f6881f454b5f9dd098aa705102ea4b59852ff7b1743e84ca5bcc924c16137fa456b7854c70f87f48014e483cfa63d67e1546133e4f5e600589e527c9ef141051b142551984cb3594327593ce63051fb420d8873583b5e0a218f1f2d53cac40a749f7be944fed82a5cd546b2a6d5c6bc13437e628f3158e395fd56fae12ae7089179c30f985d32f3338ca61df4f48a23e4760795e020051946a65293c40f2486c221db86d3b5b86a055d544a7c1069c414b367ba1c5d861556499ba8c57ca4829fc837dfd1e6ac1e24d68c07fdcfb8c72431eb06fd2da11bce6522174744f634ba6467057b3810fa2254d0a94d46be4d902a27d006452fe64436a51e3842385ad1b34232142cbe5228debe83357bf4cb739b5dc2ca67ffb5ce244ab10cae29178b2d4c84e5156d582b8d833788016d5cd4df2501d65b7a79bac1950ab17c9204884e578a90cc297b942930f39c0066dbc61a53a0898bd2da927478e6ea8e84bf06780788e4d65a28d74e955828a900eddf9baaa5f3399150f8e76eb568becd651190eea06c7cdae6c98deebe552e6240313589532858a8cdc8364f9c65a7f92aa093b977c85f9f874de52f918fd346a40d2c49ec8846763f7ce1237c5d9ed444a595cffe18c1e9d4d4f1228c6533af3908d89a84cbeefe46a698e61ef17022968982e409cad4b14356e623c712ac22080c355789ba0c63150fbc4239e35b46fca39fb7ae4a1bfbc25995bb86e8d0019da20ef54f3ac460ed856636b9ed90b90dce473e6e6fb364ae126cf40fdfda42b74bdfb8c4138542d7bead2dcc1d73d16ceb852e52855a89d1cb702f6f07cef28d3c794e6b6a70f428e936b6dcaaf2522459dd241fed416930c917678cb3158178a650890ab1717fece34f582ebcbd353655a99060d533fe732a1c7dfae3c024d5db39d042f8d8a81df2cce592c21cbb0baae98ac9753d3bb8135b6b143aa587be3fae51ce53830f9117b2be492d17e09d5275befc114774dbcc2ce68c84016db583ce536d97166e21fd820bf0dfc6b737edd84324101f0e431ffae2d029b27c197a77affa0efc407a92ba41916dc9069e75d9ecbcacc2fa72d064b605323ac94b08da085db5573926823085e6c01d0aa2000e87b3f6abd839e65e19752013d0166d1acc75da81f5c1072204bfd53f99e6890091dff8c7d503c68d7313c05f0fe3eae54768448ab8833bc220d2281a9113d25f2a4c120dafb51a6d87e4659092f92734dd46cae2c8a6495174d6434ba521c0d3e629f8c504fc37dc63585058dd80b5698ce001ff43c4896ed8e4fbfe85490675e9e9ec77b77b0cf08e082ece4d1fc0e9e3340b6c74846269c1f64c203efe5eb8e1a1069d1813246d824df0f869c06016166c185639cd8c2d10e1c6bc58dd70f591db0ab1036a6a32195cc966663e422c894b72f577e404481368864ff75576c885737ed690ef0cd65eaa5dbc59fa81d26576f12a2d334cba040332da68f6826bf80598ed74ee6229caadc56c584ef6255c77919d067453a8a40831cbd179cd5f8872c2b50b44afd74508e4df8d8556be03d33d2407d9d2368bd0fa5d30f972ad45f4f23b70dde8a10fa9abdc7d479059bde555dec086e0392ec032dbba9c57cbd8a1222959452177943c192b8587342b3bd396cc9cddec2e39ed76081187c3f607be5b1d7ba23604167ecc64ff7d85aa2b2358bbbef0510f54a068d977cf86e0bba543feb5e4432c4165babdff9edc43e46d50a588a291bc715bec8f07678cbd41c310eee29dd9a4d3ccaa1354fb3184a24936b0da0731a8045cb07f7f295f3d02d5cc04f1f3d5c7b8fc9f3f258f55437ae7fe89d561e51c3847c487b47064ca1ca20814f21192427e688d869eb1c60fcb58b1ee27dfeec49302bca12238f86f1fb8f7eda176fbd4ba8a4f5521d7d48d03f8d948850290e162a30ff49503c6db848e4c11f519c239e5a10b29e518e2e2ee8cf3dda915d6ccf20b2bbde3bd9bb3b3f68cc7c8e665f983e76080311dc0910a89376e97be73ba455705a1f42114f30df8831706c9d67ef86c6e94163b409366acd75281bcd926899d46576a029e908be8859bb09b8ea551394afe2242dc304cd7a91e4fa2cd13cf155308a34d22edf52ccf3d7ea8684114451290b3fb6a4a5f17edb8f98888bc30b6e02c9bce3750ac69806b379d44c6f0d8229d43f95938f60913ef0462869886df1423fd56bc7a6ac42b13649119df7e31f9c73d72f67a146c1f5510ac41b4e343e3a0348f5a094065d8a8f0aac9dcaa459a70e750c38103ba7516da17bc7274b68f054221a8e9dc731d03ef804f11ebcacfb8beed9236ee5ca210fd20d76762f648ce0fc0b10397e4911c26f1c17cdf836b42d92400d8ace026a663dddc3da628c1ca84f065b96eb6b89a502b504d6a91800fe91a6e09a0eee269c8f54d744b3023d69c1d6f8807e77e509ad82c52036c09abac9fb74aa87d8fa196d27456cc0e79f3744f2f04067acc02a303a9a73289de24176fc50f836f68aaff0b90105670a9662d3a5b4f47a7923480f846ddf489abba7f3b312b84a71dcbdd89e8af10120cf2c62179cffff256eaa7e2a689031ca4793d7c199e4d7c36517e02808bf4995b2e0e471866de83ae89695b76b866d76727982c42259c529e1c903ed86dc199764b7bfc20ea71f070ccbec93c080e242c8aabb64f7413c8d49c45e8c1f68db52d71d539158dbd2f09e51551438abdc8c87bc019ca75e3343f1050c89840b4421b733e6625e7674b1431a6966cb49877b6a90ba78aac5d74ff1d7a48cc3743b96d36b24954e4b587aed780fd8955f52b5ea23d37e7aab1ac89084ec3544a339b4337f876d765b7defa9d0fa18ea03a4bd52377061ecd91ee8da1ecafb2e8f4a0d66b733a0fec8053e1df6d459893c8996ee889b9cc7c138882a4be80b35d9e530bdfc47d49646bc1cf67f22ee47266eb515aeee7c6c5c6cbce067c080c910eeb555fc2be63b2d6887a40818ff1d6576d83b1ccf0cdb478b2098fdd15c92b828ac803a723c4608731f5f5d036cdcfe1206c6527fdc021e2a5c935b4ae0a9f7dfb60f2023e2733017ed4f6772b7b35c29fcdf49f915373dee6bb4e4530427facf04bdaaa5dffea55818e12d17f2863330fe09b3ec48cff4e75eadf9927795abb2b69fed6a1caa83a1aa27246679677acf42c37b161d9de3a7fefab87fd9588cf044b141f1e5f95d3e5670ec1f5ba7e3c89f0def467be12d254057cfb180c60c5f427b2c47b879daa7fce10bdf7785673e1ae4d95f8444cb3306da26fb0cb2d1980f6ff27297cfa421870d02a774d04ac84ba9ddfc0588d31bcbdba19cfb5c06c1c7244e88124c05427407de8f420789b3ebb615d6b01ca0329ee9df66cd2ddf5709f86aa6dc21fe27140f6741016afb5ff088c8908643161d789bbfd6b7ac1d13b8b13d30c415ee706d74787d1df33c53de881b148898a27b9d12db0a056449df533a186986d3c34c2f12bdb7216300862a0264e74c9a0a39c5acd6c34fb25b259f0bd9070c132da83d2fc0fbebd86adf655896d3c67c136acebbe350525cb5d233b277bc138e427c607ef887b6f8a76c31d82c4ae6ea199bb61edc097296f5ee624355b7cb8e3721fbaea80c4c597fe96f39f5693b3f992e56c3997e6010defdc63477a4c3658634664070add291b8a4b844bf002b1786f3b651fab42f6fd6fff395dc1cf01cdf083459df1e9b3703873a153527efa05145e1cececb8f97aa912942716594cac005815f1b3e7cd272a9c161c22bc58b2a569266f3f95190f50d6de5f5909739908bdd40d7f455d5a6d8898816432166460742348867124abac159c338a969350f0a53782ab2e5549eaa533467fb7ac9889","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
