<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec8c09236af372b3ee572179229e88215f1d112d4104ae51f6b309343be3ac8811ff4aac3cee26734c33d68fc142e55bfed614ec6d1ada723a9aa0b64c70edff8026eca41b09d25540c83bff4fbd6206594df26e1cce65d1097143559016a41fbcaa2a358781ca7c53dece1dfc57ddcaa0e2ecbf28a0890e5bf9f4ea24286ef8774f286337bb0e533d199bdc4ecc2b5a6a980c84d674002c0592e1a9cc431570318b56ce72e10da316dbe62a1691e82818beae574a0df8c793ec1590ef671ef1939a376cd39b8762bd37fd55821ca397380315008dbd94d6560cdf2a4dc4c0173313941986402a30a1cd938b8fdba5106ad164be97bc614063ecd58badefae38e8eb78a354341cb687f440210353522283bb49ef764598a786ca232fe0d780f356fec29912021c1f3a8ae2c79568f1143bd3cee920e42237ad9491eee18e32b5d6088a4f9d5043c30afcf83c4388ecbd7825e38a104b909e4836e52d5a68370e4ab465351ebc9299ef82adb287cac569366caa580394371bcdc886bbef142816a93a8d01665c32e7e10e4a78fff6f92b5b57985e596f5e500ce9dd3339f1147e75d305533654c0dd47746d9120e4aa5e716d84e27a442e06dd6e8833764dc7359a7107a76b5282a35f2ff2970bd8b02cc44720a0abc7e34a83e68789ff970394d349a9ebb841106763b1bb509b3e7c8f9b0cc0cf6b400fd48f2dbf4cd2e34370ffac64b3964333d0a25c8d8c1ef1e0218fe1e88dee9e78a0376fe5d8f8d3a6f980eb35d824a03b083589268fd802edb4ea6070d951173c35f8a4a4adacee7df6b346ca77f78708bf0919feb614957851f2f213f44666ccae10b5af43e5986b0a7656c07769045b49fa5657f51f616c1561c255194683127e42e0ccade036616090108129e34c6bfb2780e3b61f43acf2c38e439d8ef79a2069ef81f9d9a73818bef484e1959cc388efcb4be36ea81ad39252760dd9187ec610b70d6fcc67253b6b34dd732d43419901b3aaddeec56db5427d852a1c5491f3711d40cfed0352306683d919ba21597a915ec6244d17ac700eaf287f5440bfc815308257066e785301f5937dcc2c43602972dc0208d2a0305cd7c078c5f7bee2f7f81fed8a8b7508446808b72ef7130588e1f600f30444a8d0a60a7801a1eb283ec6004295c03c5543a94d1d74b0dfc24ab6da631e73ef8f82cccb33df61d302ec78e9fd2d0f168f4e6c5d40d96d629627c1ca1d9ff01dae7a7131dc36ccfb77bd9c04dd947342c35f0e3f3f989a92e6280162da053ab6915d80115ae8d63d989f033fe070dffb89d62608f0c6dde570002bbcda4879d59d12c503b2a3fd6cfe029ec1cbbaa5899b6c5d091e3f2fdb88de9b0e833c772972f2babbc69328b749776023d2280782491290554331cbc24f7797eb9939d6bec5b5caee39ca9fa825034ea14b7c6e0fa7a54788d2aab6afc8eb8d6eb4281e0fe6b103df2de55a021e14abfdfa6705d4a855d030b775a5df20cdccf07d33c2d52ad50edb347c30142d9cb566d616ea6fe450d54dd41b4114565566e62876c89aff6dbb21a5813d1d6f4706653ebc641a2b18c75f76c1aec18f4390212d716c863baf1169fb80ea96c6d747713191d8d3634ce9d9417e25f21a6c1e237ec971703e88da6b9049dd99551058aa792029cacb4cc73135db32a614ffc3c64089bb3871e03eb98243e50e841adab768aa0352ef8e76c80802f09b68aeec4d2248d74ac10601239aecbc02f022a885b5538b8d9165391685db00bead945e79f20e224a8e781d8838dcb08b94c4a13f6b3353db7f80cf995a9d357fd7196dfbe46213919cc415173fc53a60a11737fec6ecbf59f845dcb79faa1909e38b1a06d372fa8f89f2ebcc9e3748c10f72b976c5ca0321191a0c311274da8ca57b7095f339c2ec4c9d51bdd453e706d461df4d4d0d39ba9fc7bba236a7044de89338b6654c7220c035f441ac438d2b98aaf36347e4eb1d022d79b38426ec508898d0568afb09ad6b96394421f2e3821b3a8835681aa26d7b358440714f50e0e900f7d1a02eeb86d65a2aa8fb7fec6ecf28a93295dc250a567c9df324ed1c87ed130e901b393a92e160d329a50b24a2f1bb779f2df3a6cbad690f6b278566939ebd7197b5fb6d36eafe43ae987d428da549cea7d04f3f7a291590f2660670b06e6d52e7db209c9016ea613fe6ddf76d80326286894515dac4fbe7a24c445919d637e59b1d94335160f1c125c1f78095984f5ce80397f1510d46d98081e6a2b5c5574f7402ad2fdb7599a63bc41a18e621cbc26042b864f2d7c6b12be4a25eb95310749a6b9cc8d1c3bf7df4b80e8a28918c0cd68b297c35ce379f4885addf6df41503df7a48f8e685c873460723d960121b13916cbf251193b6f412b91a71e944963d823e8eb280178a5b72952e494f5f821ae252a7cd07ee58d4d871b77db37efa6e8fdf10550b161c217348f58ee9b63c2e6c4936baa005e6b5cb8ee9e2bbacbe2ef180c10b7946f04dd445216304ce1f693eb392f8f928de45d8076e7955ef41ff118acd2c41b9d0833be719b3766f31b37f7d90aaebf31bb2a796350435eedac577ce82bcf874e244408f700a9de6c209f55efbd19421b6b42bc318faf0dd6f631d2bf0ce224074f01e1fd7d248aafda2f1e470a5b026b443f30808b8f9b7ef90dadd962f284ac92f4449e594e7a00a625931f0953119de377acd5834071863b6e804f56a52a4e95f0f341d96c701b28ad4622539f6c2ade522aa2523003d051f719969cd174b8e8343897df6a6b37f4615056fcbc10656797419044d234fc28ea7da947409dfe2430f74c02c5d903f12b5c07ba26e5b389324ca3fa4203b4348c8f5121fc259faa04cfaa8c471c0f635457e077385ff1be68172e9debb4f3d37e32ef8f88913feed675902d6993694c932cb09ad2c0b857b9de6f5639f1ff775218789ffb2ef6776005f972365dfd1fbc6452ab6aa5d26dc25ca379693f99d1dfba7b65b589ebc66d72c7e5d5df459bd0036b8e28a504da146b2d60704406dbe640c1d30ca7381372d6b74613577518b9edd0a151c8e23ba7a8196cf71d44c6a2bc4cd0b25327e94c9246875dac0f56a22a7b465ca51be76c775b3470ee670f56c16a36d24c6d47684c1a61ebb3ae3af5f9c3ac3e86d2ffbc5197c1de9cfd393e43fb37fea307e318ca1a94adcb7559368d4e7bca652ea8ca726adb5b6ba05811e4dcd528e8e8917cdab4c0504834f8f4fff75e94fb3705d28d5d73187890c6eb4fc04d00808ba72e835f7c120e64ff94c180e7e5f4e85b06ed4dea901c0a6366b56fc439843ec0c3560e455d0bb64af41de9c496a7ac51eace15c0ba947ad9ee37b8ddce3e2c48f3f1d503bd2c00fe09ad47d9f0ecdf58853968445e6d02d12825a7616dbf385121189c9e4311e70ab2cef79a6201d60ff1823c465b05d4c89d4a4d4d68ccd099d2c21e4a41a052dafc60b88ed822631925c8ae8fb54b889f302ba6243a989e02e43ebe0edee662dc8cffe27a7516ab7b8eaa05277ceaf95a0de553f903ae2dafe502da81eb833d4af9d90c3aede28dd41c914675ae20bd7910ad5a736494f1340358010233096ccc7929e4df88084bcdb4e5175236ce0abe4b72d133c80686e8309faa43854e48de2c492a52400b91208f3fe2799765e4145e8e30a0f27f5303132302dbc073a74ffca4606d5620dbcc2f10f65129e6ec5762e907aca5056551693802da73b9fcd908efe4d9cfdb67725d16cb081409738501694bbfcf676bba1db16f813ff7080f24b3d3020b1b345818c97fc67e04887965e8a1f5f85d70de180b896ab6dd85ae37e87b15638b00883ff8dbe570f1df30be0c445ee2757276c68c545f41a85da097be950cc2e251e9ac24e04b8078f690552f2a88c7f8e97ea597dd4c4789d2410880c54efc9bcfb0c5db93beab2fdb1e1abb9767c5d2c410ed6dfd825de9687ea11b317c0de4008a8eece8e2de2eb265637b9badfcbc5b39c0381fd88e39da8b3660df443f8c7e84a680e56dbe57b81bb892a51cbaaff0eacc3228b9c0172ef810950d2306f9a9d157f788d401dcffeb3f04fde130c89ddd7606ef90807015c271d16ab2074ed4fa09096e493d8549c22c0d1678374195578b4d6c47a2accc0fbf0091a9d6df517dfc8fbe24db31bca704ccbbe9420d9ca924e00d903ba9a0c6472bb37a5b14aad004a427e3434b27c964ae4185fcd6de34ef452daf6da949e84bbd1955c04e8a53d85e380790c6ce0845c4827381bcc135f3ef379dde2afb3f5770b8ad2568040cac1a56744632c76cea86b6749a4e79866c43cf1d5e8766061e4c11cc9d01c6c657216853d1cc2aa2ecb94e3d763d79aa92651cc6a58574823d5cba98096487610a3ffc12f0ac553a411a028219c95dab0c80fe2c234eaabb8fc5295e3832ce7809bf4fda4ff87201379077b5df3614c4f67baa9f1305710fb98958a45bf527b8e480525b3340a5d5e00d3d28ea40b9bd524d07b7c466d87593dc71cceed16fc86b7a126f873834b7758e8548b54d29fd9c6e9a89ae1edd91686b71a17ea0377f93637e64c81f5f6848cf6807f1a21ef79f165c9fcacb8294487ac6d233a2cf45cff644b0ad7f28755f89a62e4a989fa67e29d28e9e3f2e0788798d17be21e58663231fc778bee71a9c5de9594c017fb25905e6aa91f68ce15f48946c7e0fa263fd1c9e4b902c4a75688e791726081b2694ad2b5027423eff04699d1b2bec81bb83184cc232ff2c733d4243df1929742fb5c5aaa4c510123e481711876b1f1046745a27da47afc7b254a065fe3be119e693aa75e9296a2f39b3443d0f1df963716c9605a1dfc8d9ce342d9bc40d4996285e1ad4f0d95fcf1d1977bd06c2dbfce4313ffe44c6ca18fee905abe57364ae588e9b5f625269f1f35f4c718da8752cebd3d881d24513439edaebc55572499b62b7bdb64b58e5d1f44100f8b1fcada52cbf39cf9647029c7e4e9af94745b895916dd1706b00cbb357fb8f464016e9308e49278cf4a485de67ab045bb49a658b468fce5f57d8e062b8499613bfeecd09da79741fc098b75eac4bbbe55a37d2db4ba38d77ac3765554d221ce46738a4073e4d4352459cde087d0788c1e392ae4a1b7632ac4632e0bd02c58def19c528dffa8131b47a0d2c2e87c5ea7bd955e665de5f14048300e23a089dc0ff226a69166fb69000d46766ab50ced9488f6ecf265f141d74e0fe00a016a0e873aacc14b7f05926e7e3952e319b06616b6ffcf6d39d0c174108e3d5714331f0d94fd5a62a5db5b118dfb03c4d8aa08e9007c00adeaf19fe51ecc33a41259ccb7c482f64230d58dc31487c006894f729f40f4e69c4c369089a0fda98e6f16cad10aa1d082ea37f724f339325ff1b568970b800818dc738aedbc34639e370616d24f225a475cfd15fd4f3c7a6f60831299f80e4d44fa6040e826b192105ecf4910dbeb70b91524c20ce42fe96c7218e68b9fbab5a2bea5069e2521a21c004a95b7083b52c796b4a7416815d8812249c37fbe50cba558e9158f74ad5960d07e1e8e7e844cc87ca9e308c0eafadc2cb915d37a3ae422b8212970604a159d19c36918dd30f335773089d7f0a9abec52de910a667eeac1d5a760959999a13170b6a13b84dec9d6d9d6bbebc5f505fbb02ad11e2fd300d1aa9c14d5cc07357189cbd51dca1bcaa792611f2cd44dccaba9feec0bb4ca2e19fb12e65d54069d0a5b3e2d45745d266badd82d30d27ad13c19f0e4857c1e0a1b2645271b037671e510c66b3813ad6fea0d744c51517bec0d5c257a395080907f5e3a7a7b0bad15ae2bc9e33f3e56118da191747d0055bf63ca4e97d14b3549c5d68a088fe8a0c703925b4adc5d8695354771822d979d5cb1b62e5bb4c324e6e02763994858fbd8af35b15f535d356b0714d59c57440d4200ef6f2a70caaa2226f41251120f19249d83164017fc371a20ed584768ecfa526eee3e900c44b701e423253437b204f01065719b447d40f1b02e87e56b3cd139e0131655c6bb28eae47aed4311f62365b0693a7889989c3211f642ba064d2535f58cf9b225c941d00698ec83e672b8843258c6dcb3b5cf442838f2738d5a7d53bccf6a138d7a1d2e8eb070ab0da8f6e26d8d7d17d25fa1dcec9c75c02fe78748d1376c522b429274214bbfcde99edf175a86efab7fc1a559d2d9c63b475faf3f8ec77d93c1d4846e0f1e213746e68e7e35b7bda743b3cbe0ba597abc661b1e6385a153955659023abc505dcb2e0c1c6f7a9d55e255be57c4d34db7bacac17092cfeaf462e024a132ab879661f35592563c5ab73bed7e15d26fb89757086b43e2f490d8703f6a2fadca61c9acd60cb5b81d147857af6f2a896d134609f5af1cd64b1e59f1f6121474e0d6563bf2825ba9d9376f25774131517592fd231f7df88be91b37bbde2f6c3f4889ded65bb9124ce7585406a0d14c377f0b07ac6ac178959155ce21f1b4ba8111f4853b910b77751e3a5d6bee62f0444dc4366bfa8568d06a864db76e4b9d6ca58f5c33495eab530dfd1582750c44b257fe9a235219b329da2e7527334824b468ca25c7c4483f86055bb62898f024604ad14bb7ea93a61a251fd816614c479a846aebfd44b169313e6dcefdb8b3231456d709c2dfdbb40f0a33adcb0ecbd0f9ead072bbc8b8782c1954cdaeb310fd3914ba22b759a6eba907f10cc53cf396444a32b069ea9843dcfce7e3f7fe0ecc51e9211ce2cac81a622139e1f4f67edfec7c166396d0e7929295f8e99e80a4dc36967690c911f3b98714255882eae20558ce65a23df92b2e8af274dabb0d48e0175bdc85baf97179fe77988a84fe91d146fedc181be240fbb1bebdd52ee9e158c31162710b62dfd8f81df85ad16d05d47221a10cb7044371d98c6e09caf4e2f794adafa25532cd15fc29ca5416f4515b2d967ee7120eb9178e8edb5d4a4109e1f62184bcb4c879ae8f385df0cb727362de6d5ad147c91bca8541cf6155e33cde38d5e622bd816716cccb3dc7b06dcab677cc0b18d0bfce471753b66ea0c61b2c298d7b4b2ddbc9018d8cef7b3a1b6c5e310d3e7a8449bb11f677ad8bc0c7ca56131b83a9bd874863221db570d03a2694e5edd291d803fdf606f80197903ddf9d99b4b3161dca52adba5b210203d428d6053e9e0e98897f8189e4079d7b2f81f380a0f8c7e24c2e87fbb78b5d80a7ac82e20e6d84359b6308c2ee4b248339c5a9dacec286c87184d2cdebd1a88fc81dd9e067cd016f99291ab2d9731e71dd334e667ac95ca28b5fb4737a24555137707e2ed4e7ea1f1817ea6d36fef9286a35e8c988f9e4eaeb7005f8a2c1b46e5a310115ac40335b1330e684b7ad6b8bc078a806ca8e9cb91068f2711be2cca6434106db1df153349bb26ea9d6ce3a2442c6fc1bd37896e7934c690856c7d874d87b03202eabbe1321b59e2fd6c30bd16f3d6ba40e92860c1e4de9cf535d2839b0cab8b2ce9cbb8287d135788bbae641cc263bbdc61da48e36111a46384afbf973ce51d5cfbe87845d39ad429f33ac00908f3dbd45de4fea94d1b0ee65e5cfe2421d1a302505e8fa7111f5998ff61747cffa08cd9e15336f8b933d8f7356c12fb28960bab9d9808f5e0cf8164d91313136b927f85619634ab6ff17482095496de1c5113f8c4e9bcb8e48511f340f72c510231773df98561bcc493ed493d00770fb967aff5a73265c0ffb49404f7d9210c0825d1fc0bb3592fcd853b58acebed83c20419c6fa22e183df78508eb43539b3d4ce144bb1194490d7c402d53090386e8c5c773fcf3cd5a371f223bc28be90539404afbf9b618fd88fa4ab27d383893765d53cb94c4528cd9dd616df039755f55f4d2043a12c10f9bca63fd3d1977d7915614d45a38c1157e4d791f74a166b7f6595f729338d098b7b0740d19088da741c8e7dbc6a7245312ac81c054ce43ab3838e3e34f6b8f1340589af95c95dc75515595975258c756ecad5fc5f805cd405e51d6233a56d617b607ddd7e0a2c6ee24e9707a896d34bc88f5d09ef88e808f2f378d61acf7783a6f735c63bf405c1835f4c197de3a61d49b6038cc4865f0e5e68b070996a45b45dae5d01e6651b1f52b3c6ddd0d19114a61b463b0a2aa43a2793c5d535c410cb6b5067fa696cbb28795c809265735dec479be9c5cbc90fc3dbbb77b565276747f5feb631d922f01877d131c496400267e3ef1081eeb9a67e3649eaad77e215cb916d20045ee08be3db6a0aa2728cf36b1c84b80e59f1533f49b771d6197a7ce298267285abba57873440db362bdad1807c0958f6d4cd1a2bfc8341101e6ee48eed9979da338dd2caf942c8544beb07177f19e02c1c43e27d1cbcbef9b2e49ec7b1d4c741c1f687a9c332bbda9bf58945878b8c87d26b45ae9cc95e7dae0a843865d77a2132ffc9a353e2c884b5b05ed8e205dd7b45facf453be6b9bf223693549d6e847261199ea067c8836bd435ef1d2f3825d198e976d03d35c3aa549808af187676732b607f320a9497d65ef55e33964d5917f3f9b78dc866cf3f38c6c2b285c1d27e264e89ce83ce2d3916e48a400c1448df047f2edca0adf0dd584c37f90f8f03dc9acef896ab5054decf84ac63ce2ee483a41f0d43c0e1d71f582ed3efc927eb3c0ffb2d8085ae4f8064e36dedb62e762371f50116b2ecdb42c8059d1748e2247a8767a92368b4eb9a8aeb7a7b5117f4893f54cdfb88d485fedb14b210743f164602f0729b0f00940c12611b250a5a2889ac41ed9c1bb3595f8827550a7a2f115216a15d9d88d8bb5181cccaad47e2e12eb7ea3eea14ea2198bffad7f99deffed34388d4d4afe01e52f1f360d0e4afa2a70553cc7235ef783fba87163ff507dd46aaea68db46e3e5e0c4468523c0f0612ddf084d86d913253c75ccca5d12b3aeecb576f220d233e326ca159a2f47b6e162cc7b32b35ee3acb07770c03e371ebfd9d8050151606ca605b8baad37d27573a0f9dc2f79450f7502a9de2fbbe08fc9265ceb2a8f72ad0f3b03b917aa89bb57c2e946feafbcc1272f13d7de3e1b8b9b81de091a8518654d11c082b5a1b09fa7af85c5ab3abb82ed5bdd585dd915698c5db5da6aba5594fbd931449075dbf3da00aa4a52ebff28423b77bca8597d3149ea3ed322289a4298509e291b09e8ff593ba9fbc9edda95ca3b529a2e0cd4bae0afc67415aa0cc5c5872241aa12e1810c807872dab59132decc58194b574bff551dcb1281a7a9cb6105acfa513b6b59f49e4f127947466758937f2358e3bbe57c74fa93c294f0cbe69773f31266174e095d41a9ac1cde212036ca6017fbf3efd0b553a3100c6f2af1ff65df96af1ecbca3637cbf131e4cccc7efc2fdb5cf95cfd73ca8a4e1c713308a3f71148facd9a05ce53fbbdc032e154cd5f28d0e7305e1a00b1c0ce145b7d443967a864d5a449a7baa90bf130c8ff9f23d654cf19c7538308f4dd255658f8d7abd5a6608426819dbf99ff7e2d9c96142ca72811f3a3e9f5dfb1dc91631ab5f0ace04f22c98fffb0f41d106883e43ce49b728a93b7437fe7f3a9e46394e3d3aec8967a77f72156f5aa97c464c0765f8c040065dd35c22bd62a87ccf2dc26e08bc7728f2544046587c0261b4e140d10c0c5a67862e6f368d5de732504423cbc08b838e667e6a43042d46370462e45b289dc15ee7df7af5758944cd8a947356affecfac0d5b03d1bd42f19ccdd0a3f0c11bee678e0b7e9382a25065a5ce3f05f9c9e579f669848b35fab58aba7f5c3fc32621f1f715c5603634d8448732151ab7d81bc180b2cfa86aa7aa9cf600a0564a074dbf0294d8c7c7773386e1b36b26b15766e6c5a03be19624e7fef1713be0b23ebf536053f137e12bee03e61337be64ba8aeff5442e91a3707d1cd5fef173d7ac67190abf6d4069cbd2a4e24887f9db0fc598e18b7cc6052cf557e51251cb722cbae9b357177b504c96c3e9257b9791462f55de44a51fdba0d2664a75a5d10e62f0fbea756282788065482b77c5465a843c696ca5fd26e501b61bf6f82b24c0506d0c9909dfe3253291c234f126c281dca55ed7447d3cca52cfd428f80c43647806c74695a46f9628c1589a2691f0a6f1100cb7476bbde9e76ce284d84b9b01986c027b1e195009b67b200a586391ac7db04494a7c8cb9dfdce2aa6a20f2e91c7c90652665a36f5e20ecd08752a70d7d6d82f0878d5a469684053e9b82317abc51b273f305bf98507f65d65e58e256f5d67dcfa888e95ce2be050797f74e9022121973f692fc2bb7d77f728c3e05cea716f267cb29ab4f3dab7e06fa8aab0a0ef277cc0031d5b0a7c50eb1fca77e7ac850494ce947115174f1bd31f85b90b4a7096cd46695231d71091bc6f88788e4e89876bc103e535481016051208a6ebc4e061beb3c484ba34eb6a9b46f0732ba797210256ed6f87c2b4aefc9f73d08049d4deef6c4e8060094e6592632e20509a5d18fdbff9b2f8041ced9346df734f56c3f0e3e1c0a744b29eddc512fde7285ca6716ea45392ded40f64bcac45a0f2afb0dabca4678c14318a1f1bc9188c82c481d72962f8ca87a8df53b857edd46e35d9fd15a9fcb577adb066dcf138aed97aa824985b49d8842f16c73ac8cccd19400d4161e8cbde9350413a8821df730118518104789fbd44c1aeef1408f6d442775637147b9769b5d2fe6c9c85734d246cfce9597fbe71a2b5012be301deed6a4c07e98629a0e34b5c6024b9ec66cb3c23ff4723f2260cdfdc8b59725f6eda35485287431a472b3547f61eca51dd397a2044cc3f11b9329f3a05157c0f9482baffc466c249398a9c3f66a791a8fbeaa0939f06b5c004afb1bfb37a8a73c66d80c15e3f9ad206817649a3187bceb627946fb01a5f2fba8053c2c2f9e8199c1bb097fb10e8fd5db7c271b35e2aabbaa15e8fcf3b36d9238530de81703a70640038f8cb0bbb68d3d0ff69d73de975fac981c2422476c102acf8adcf0d857e49b71fa35c6e93bcd2bc3bc78cc3317c160e8b37e451069f0add03471d6b77982fca44df4ace2e73666c2bfe1b297daba4c382aca7d917620cfeca5abb6f63d7dc02e19b3284ce89006946c92b5c7efd5a2a9fcd9f45b1a46caf5e5efd027e942e860bea5e636ebc03bbca0c59063e76bb74b3de05b6ff73076e70922e2e34f0eb990cc9e120c3222fa0d2e38ab352494b5efd0231da5126e32d8822dfedbc24fd104c4793b9ca341e42da15be6240020c8578ba475878900297845db1e47ed067369d8c213daff8b9d5452e37886de953d212b4a0970b7be8bda2b208c7e594eefc9cecb238f5aa1d83bb19ed3188b0f1675da009451b95834be72b71e9f35cb0445dd2249663d18c0f9a990ad788fdbe92e128185c75328bc09725ceaefb5c8687a09fc77f058a4fd482b5a551897d25bb173e98addc97dc1f797aa7f8c1d8270aba22282b057c925b891bbacaf684463eab8ccff5b9b70aa2c9a4d7b4c7cfe39c0575264e616eae40c0050742fc08327f17a7b1b816c3970fcb6506347ce4fc97c052d0ccb62c102b3c152475a4df7bd73014bb19adad6bcc205f2fa57ad537094554cd94e12984dc62d502505b1c49b2706b7a113bd3279eb67de02067f3966dd368396f4f62f28cd6b46ae3adc413e295d79ff00fd87ea35788dcf37b13a9b4e4b065a6ee0ee0e6d20c7b7366adc06f61c3aaa60bb465842d4513d06d05707e46b75835398d705d6f24db6ab80ce414a233b915e1756aded5237175fb994d776302cdc5fe6f0f922da52780383ef03f90b8cc69b3cdb9f04d7655ef54854136af14e7f702d69b0200140e41a0a1b6887b4306fe92fdfbe1811e58e09a3ea796f7d6f7e3a3c9303e863940ccdf89c68f7474545009175933fb47eeb24082fa7ebfe5e06ee769cb3692f14a6bfd11a0ae33bb3cbb3a730ef27ed3ac15a9ebcef5399cfa5e98d16070f3421e573e96af0c7d1a22109e259efc0921011a3608b8e668842c01bf5ed9cabc2aebc4371073fbf93c60d7225ae85d9e09b1a203f91dcb09191927879b88fcab4fb909a42804ba0b7775406a55bb5a0f8779355b931ba05c390e2d1d2af7719f5e0768159c9dc125ed276a3ca44bc31cdcd0cedf87634c7fbbbe270f5fac8fdf074e5ef04005e7ad81d262fb3d78479c1cd360e9c8e69e2d30cf161b326da91eb050bfe276e19fe3bca2d1a8d83cdda4eaf5c379ed211757a53598b5b51c7431ad9b5a286c27994c6014674a5bb69c100551c55e2e3ccd421205b4b0b3aa63bbac2e90e31b6aff4e0d34654003da839cd81626e310f0c43f896c4af74bb8b3918eb1f559d0760d8a99fd447dd048630b9bd3cdfda324b1f2742a3a0a6354965e28058998daae2f6609eb1d2e590ac5388139c5444d14d1290f2fd8217c495c1ba2df8a008290e22bd8ed9418dafc98dcdb6e387d1b43439d4f8f30a0fddd774094027f1039fc8480e7cad56c4ab6e2466530604b736a646beda88af1b1644f9998a3be79c586fef65acdcd44344e6381bb7a166c3d8bccdd631c8e0d77dc1dda6b7381397dcb0b2ae1a06b7d778ae41f8a91cb339a96e50534d9e5f320e1f80089010ad4ac61c19789bf793448063cdc5c9fbbdd10f909ae812e78ea5a790ca4843ba404ca384bc713870532c4cabe4c1da817db42c18de7b45a68dc552161b54da5be3f8c783d1432c305ec7c32b404f51a2eb4e1e24d6db6de68f8379888317550373c81f0a5366ebee641f2f332f9dce3f9a6124214ed49b00103a3dbb8ad7e7068e5d9f901f47a5212d882c65c495b974541fe14406661ed1815812016af860f0000d9d0d4589904c13a533959df11a67e8149964eb6fbc6b6b9b7ff5d499e7a0d1e114ef910eb3896a1f5b084954a97469821969aa28a588d591751e1dfa918e8ad7e02b8adb42175c93a97965f40f6f86b4ef74f14867e98df6241aabd2e0daebf191e12ca155a522d863a74b91f43f3fcf3531e8bd33a97ab95431f9ded295e7c7b16394fff630b84757127dbe7821abb56eac1c41e292a72acac67104e9b78dd61fca0ad64a2a112954bf1166058db7a65c5c21552557fa98492c0ce3517ab191773b81c9e7435049423146da5c9c53214ad06e6f50cc1e22af6ea2cdc639fb0bceeeb21690ecaab01645494cb9dc8bc00d4d3b58b2a3d463440875a0e34756291a1fa520e30cabf3f9fb329d517ffd386a984ff97f463b31f54e15206e1af4a466ddb281f949c8bb0e5cb906923437a00843a8e87c20b6ee4b90e597e803c508a830e052c759df7c83d59339ca3f3b9211b5a783483e69a31de55d326f792ffabcaa4b679992c64db12f0d063cf374207b7af830dc97c7aaf23aba5e3db489d3961f9656e4c8e45d44a9b68665cf7271ce26ffea6f76ef44c4695622e7ff4b7611bc0073b3fdf5a520d9d4457d2c8d3e3682b2caf7c8ad8a725741d39485a731316c39c6fade0d17ba2134058a78c741a3f5b0bb24131e6b5b212705d5454fd9ef2203bbae1312e2eb00c4ff8d9ef2a95d56ee6e08eee2bd166405c8dc1945b42e5d500432a48db06529d380f9feb847148d8dd94ea7543b08c918afd9da5e8e17a89559510418280d159311390fb8b12ba0ae3e37bfdda9713f14097a211837886b138049f140beaf4d4d121a0218bb971ac33cc7a48bec0c4936043c2f72477a06e628eea22f96113acf821a56ae9d925ffca3ec14f8c4f1e2ed4044e339f24f3d9aaf682b75ab0168a32d8a49b95d64bb29e9aa23cfdff3e9c3f5705fb5485ad9c0f4f66d73ad9eb4094f99f8ec4bfa6a3802c0401b020cbfc2eaac5e028417c27619d4da82b620681b175f1b87d9ef7bb2e3c2c19b6c9bc49071c004cbacdd49f0bb347cc039eb571b0ccb097dab975efbb484591cfd11e44a0b222c21565a501804dc743617f4a4bc14ae55576d3af077ff90b77e8b9e999bcb60f90e472138e08e23a75db49ad70a75f76900ce6397790d91d45a7413d48ea0f6eadec03b086e9b1b4f4a3f7138a8acdbb927601b40d7d243bccc9c7ef5d4d506a1dd51e1ca26b63601f4a56b30e9705d12d6b99ff73b7779fc2f561935759364688ccd3f2b22ad6f46a7c2fabb3c227130b57e5721c231d0350da341785fa1a7d23b684fe9869fc8d0e0a104b9f64c8c160fffc555473ba65a730a24054155ca5a8146cf45234764576c2a507187f22327778802ef0bf39530ed6ab1f08bef6cfe11faaf0b6e57a7dbf2aa096454e12c17e7e495e868e672204435cfae56b48c30d62d8f5ebe839356f00d2c97d9e4c4f5dedd18dba6f5d5d5724ccbc5892162e42fbe4112da5763e223fc101e802aeca2dcb95efeb223bdad88768f80f44c9357dc7720a464a6fded02893eb77e33650e3e1bcbae9057f5e8fc20f0e00fdd0c3b015f5c9928a9caad2796484b9196f504664d52fb12d90d5eabac9823b01d1853407d7fa7753930397a7fc61ea2d82c68f3dbe485d9facb02a8800f91ad00e4a350c553f5ef208b9642277962bfafcca76db711b0ad29fc4b2cd1ddfe7843c4d10c892b92cad1f419089ce0b019242289bffcc4adf86066bbca36300eac1a6ee11045c893f7b0197f4a655d7572f6cf2bcbf92dfb881c64f8ebc00684087dffb6059b0ab9e47ea73f81e7f4a90732aec5a3d244352a317ab3b0a2f676dc737a747f0d5b4b34345c9a0af507f08cc12efd43ac1cc9fa07575c7f672f1476716315943021145bae410b4b12a275b691d043a645890cbee9b902dee9a853508371a898c81e7d095764ff310716167174c858989fabf194e15a1f97c901a65d8b31dc04b68b83525cb82811737857b35169f15e59354007c06cab22c4ee67df52382cb9dabd089c0fe126db1bec59af63177c5d7c2cf5bcf28bbc14e640b65bc95c98f6ce0d468a61fa7ae8776eb70ef8b7fb417d1107c7da062102876dc9fe1deb0b2b73f3d024674c05aeeb62a2c09b9b82b48031e069c37ccd87850e3cec74d61b8bdd070bd89e34ed7478c9557b2371317f5b255b251174cb4a1d8fd798a835d060166b4046a966e8aaa8fef9de8feb5b765099ebef779921d1324077a2a1863d5a7613a1f84cd7ffdc2b44efb1d0b7e5100b2309eb4ce7263cd3a330cb0d1f65d1cc4d4286ace4aadf674c37f3d1745f4308a5aec611a80266459f5defbc1b53a64419ac615f1ddefc0c27721f4dc6eca24aa9d9798368dda0c3762a2f5ecb8628ff31c307276615b09e6de149f5c6976097577f1afffa9c054351ecf70ec9325d52226ef2f5ee2f3cdbc0d298befc7806fe78528c096d93415f33cb1a458c092263c90d459fd5a82391ea82a8fd30c1436f301ef9edb7a503d5e600b4433eb839a98756a1ec1378596b83d0e3c01b131ec5c29ef4c98d803c3c775618f207ee936fbd0f0ee76661d2ff6932a616753614f18897150cb0be2817f3ee789bea74eb3b7b31d8bfac4697f63b8df07e5c8587d122dd1238ae43e3214088559333dd63f36fb36b00a6e6f959d3c70fc43e655a76e2899a5114184fa8d0a047733e64852ef09050461a9f22c3f76d3028e829d02965cf9f47b964a7024016a4648baef5baa629614f294527e13aa27ebdf2f4f90a3916cd70a7cc494ba89e16ce5d7b6629c4702cc8dd4a46552e3616360f6e68628f2779b55a665de37674cfed70aea2a5146de05a5ae353526cbb97ca8eaaccf04ef8440050723445d5a2f3bc3544e25d3c292c1b297b1b9bda59750798bdeb6fefc59372bacdf1e8f8f27d67c6a1881c12381acad1518e1f43baa4304858fe95976563bc2c6dfb439d064a0c4e2e0698f627a73d22a7d57226b784691090ef2d46982138ba403dd7e4caa0ce56c828bf116e3b2f7abcb290f14554ab7abfdfd8e55fa64e67538bf5ca0b9f4ed375ddd19fa95cc66e0750f0b63ed5c21332333fc1e79bf8df1090f624dc24ebff17acd4f8b185a50282c02558643e010d0a3c1794f4ebec86de83421b04adb8080d464685fd7666643ebff473dd850c0d3ee13a4908edc319724f441cfcab857de92c625af7d888e94837afbc75c46f4be29a81e46b1e7ab651dd6a6445409a51adcf2ac056f84c0821a5b5d02f687c2f6a0548ebd597874eca1ae9fcd87ee133ece47a4e6ff7514a6e9bf2b5d1a67e0cbdf40579eb591574aebd3d15a96afc3ea13ff319800be7eec80163a34a83761382a390c782aef51d3e4fae502c5baf7708b77348a110e197b13e0226f67742f83d3f46cb67c6c4f25fc8174facbd8ce6e0f23c1ec3d6c560dc825f2c8f9a3bbc7a09766431d110fd31b0c1b3a17eee73cad05436351a22dcd746333e22d2ed1fa04102fd6caacc194937f43ec5d648b33d34eaa2645289583d63bea0a2aee21b314b2d1ca758c217e1a617ae49835d5787114de6f94c49ad6b7032d7aad1f7d30faa8b2352c1865d15c57833aa90b5740b5bd4fc41e06e8a49de8cbcf70ca36762455543066d0af974a3c2757a4ef197f22135ae9b3c29c910f6b086d983f5fbd8bdbbd891db6b7052b5c18a9db4a0f51d2d23d971ce54e524376b3bf385c6e49d28d8a1f7ca1b0d19b1afc60914801ceaf3c31d697bd82c30ecd71eed28394563e0ccc86fcee0fe7564caa4a0bf940331b8436755b30018aee2c7ba06d60bfa8cd8643b735890e7862abef8a1d532e193151ee39cfa9d415aee6c768f44a6c715fbcbfb32a36e97d13e4516c765e40f4a34a521d09b348cb6c6a274bfa985d4c16e7a56babdeaf03120ed466b2566946d4b5f884a16040e7aa90f76f85e501cf6dfeaf7fd6459afe1c28f70dcca34c00a8cded336bf0205efbb5ff75ce33a49e0b4d20a3626198488094eb1727ab091ef42d58088f1ea0ec526ab64a194ec4d6baba744a14252eeb06ee6fe3a3feb3c3228d1ee144dde40e214cfe6b5122d7fe6b9a7d7386b3744062bf78b044b8801f3355014acb81ddc1d689d18c9d244d7fac73f38b5f7fcfb90865df4cd313218866bdf0c3d5b8de7bb7da456fbcfe5542a1de258dc19a12b4123e615620ec95306e91d8ae4c517450083d42057879539f15ab756c8536c92caed73735c32afe35eb489cec679c216d59a052d203bc78e067e84f55a75f478284abcfc0f60ceda7724608d763ad20a8c74d6772051730892dc43ff511f6934fd1dd0ad46077d03a52168835b21a0ae4b7d7ab8e03a85070a93e32dba93aa4560bc6bedd710ae93960ef670adc9480e7a1d55173b3d8efda7e0d4134e310ff51f547782e24ac7bd63f10f4d3089fe36e25a805f149d0fb4d2d17a365c55a20faf4d40c7b02acf97955bd47eb6a431299426f1686e3e7dd3f9bda70795a3b0f1857940e0a966fe66ec83c6c37cd6dd2037355fec9956a4af3d35c693752f9e71cbacea968c09ea42101bc3554f8fc1018a72b2b5f493fc2d61fd95b507f44d47c7d004e18187e79a1bf0145a78b40471ef8cb13828933143a911597a4b0c512899203c4a92dcaaed33a7167df75954c6119954283820447019585134fab8f20dea7d0f025b8646501b81c793027a4ba6fd24134c331d9722a6b82a147acf2a279eb3a45653f14e5bf16010b35f227061c8829f4747ee8279b4c31e2fb066c65ca6a6f914dc075781041499e5ac7e00b598dfe7cc6b2c9a11fa156554fa46a2f9dfb5b3b05bc93b7b9a922dc7f2db87dfaf4169fccd2437bba51642b2708a6f3a36355de9a45c169a3260d0a59e64fda63af0f0da4454f5baaf458835842f7ef0fbae0e5fbaa3f438d1b892ea694394f836668f94c5e47f6895440d99be77af3d64774f939d3dfe16ad446d0d5f302a3408277f8a79189cfa994310949498824dc7b026f2095cbc15e32632ce61f0900b42475d5222bb3afa783f31a7a99c8f42f5520414593b443f5a783fa5f9a9ca6a9100aeff4d52c1491a551b689893718d671aa3f5c61e2c1147d5684460d1da48b313e7fbd1caca69d9d510e8361faddf203c2447068c660269e828bbc0fe5797bffdf2fd3d57d15e755e60b8ebf60f65a29e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
