<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0ed21b1cd2c3fc630f7e477e97e6325dbf7a5e70ec5c126dbec6479cd0d6cb1b5b4b25f00a2267cef5fce33e9d2204c93e988a87cd68534c0781089230c816de8f57bef77f1e5e1fc584551571ad1744d8c841366a500cd797b6063c394818c7a4be44db67b6589813c218278d3b0d00fdf27512b41508b89e555123f86b1be5eb3cbc3fba78463cf9afd67669cf4d8d45bb1b6e8db249ead1a6e54b1f3323267dfcc6a52aa66ba58e5f0d19b3235eba3af0ba0fc98cc9bd6e054dbeb36a3059a5025c5823534f3f9a247458e3ad47efa5492911c52ee384687d4c624029d89e9c3cd12ac455e971c2011e36448d4b2bfd2ac276f6059673b96fc1b496f02b75599eb77de2c3556cf9163cd73743ef4c9eb4f7d4d7ed890afa41b5f83d7738032b0248a2223f1c2deea9e6f37ff70ffa2ec333d34c566715ec89a7e50dc856a852d421f75c69911263ac2f9704fa55bfd2d26becb6b19e22d0f1a812943821e60d0c9b69309b6af92e7634a725a22ce6eafb82f3d4f662dcafebc90d392238f0b0f8f00ddb42a548b5f75cb2df979cb1905e3023cf2b6f15ad7357997c260ffbf647408b471e2b987644e834d5580231385c8455ef91d9b352ab2c70381fd947373fd5ca515cf4c05b9ca5c36e7a201813bfc0f82e9dc24cb9d95a4991b711e51439ea481e528ffef9c61e8fdcb7a3b8eccbe09dbf8197ab33fd1381cadc59a6c851e8530f1e9146d616701aae2e87d22fa5377d58007adb9c776c674e437765f24aea1914079f35b69bc77999ff36a1526d97653cc1226b9ef0fd8b36529239db94c116041136d7462d2b7dfef0a1ba37dafc42480a2152b1bcfd6f7d54d16ce2d77ed2722871aebfeed9c3ad374dab5ba64705077b4c86484649b97f7b060a891b64bbaa125fda136d07ee4dad6cc309508345b614c685b49935b97d157da6e2df90f1cc015c9041bd7742940ea8c9b20ff3e2cfadbcbb1850f6d06bd4a31f19842828a2bddb3664bf73f179198a86ee684a52f70fe3c10f2668a6e290586b0500a0eea78f102132b4ca1a426b14ce8598d37aa9ba917041fe2fedfa674e729e690ccfed91f135c669ead1e3e3b84a670206f02942f724ad4daf5ec51650b832e96644b208d6215363def65d710b17333162f27e56c50a63817aa24832d21310394a23f6f5a0ab9808ea7deef48721e741504c10df6610d826f7bbb82272d3f3761f4f1b6cc320eef043c6908bdf70bb50f2c9ad64777a3d25dc3d84c0a5fa8d51b8f02f9750f30a4b787cfaa46d1ddf33ce482482ff7c5fb4a702c0cbb1e3f88f648e97ce9e606285d765f0be6b9cf15ceb4e7a30508f12dfff50119c0c4eca3cf13567f33253e15fcacf48a279863339eb218c0ba9effd7b7bc1150c2d14db86628e1ab54405ffab89dbe3f2649bab73d90069314319dcc173d35221f80daa66bb46252d90d651e86c8d6fea319862f23130bfd2ca9f4615b740a39bc970c89078aa00afb1f9db52121f166f1ab6f97dec4344d621d7a0ac133f125ef727b4c0814b44a69063832c4976878c1eea0b400530003276a97d8266a124dfff2269008ec4c1f57122cac01b5a824f10a2defcd98cfce74a34f4741430eaacd5f990c30d67d9f8c23c32b3e8be1473ec8410a3814a3c75a40fa3ef9c504cedde9b5d3fc6e5530a58b961c5ecbcab7f28f06392ae1ec44bf498a5814cd777a049e0a088c85f5ad46626799af7bee6e21a504a6ebaae30d0ab516b0c6e15eec2ea6066d5575596b4b197c2bff814a51d4b5ed6a883ed70b9d3d6fdfdebcbe55e206c02dde61e14738d338313971ac0273a49b9c6098cb3df486fc635ff660cb26efb6468ca5ddc4df7692140dc6a25a66a047c97b3059154550e29730afd06e2aa0d532e9fc1f772002377f1bda16d028b4209fa2374e0458e139315728f36baeefa539172b5fbf937736a2ab3f46deb5b0e8a93af430cf3ceeb34d1295a94c5be4262bb353c5da6f769f170f702cbdf42c461d34a2be03265466b4a5709311163600f68f0152ca1d2ce90fddff5d1e30d1d8f0b7b0dfe9ec8dca667017fdc6be445aa64af360e087d5197150c72c9f16b507f4e82c08cd1fa39889da0eb4fde255cb99e4a92f29467986f372ece80f6fe959a910b9678bc82339162e47bcd6eb2c0dbf3eda3eeac393e121510c664def6e0127478ccf007f1b0191b620abd6a22d1ecc923ccc3df8889cc26983458a9dbfb2cde98438371cac61b35a8221221703e231535c58ba1ac4cac37d1511c6139700fd1fe6e8fc8f7d43d71d8bf9c50ae4a750bd20a001ffa377f6981b8e0d3d56d7f312c506a8e72133b3a40f82a853c77ca3da4186dc35cb88bc498ca767d93bdcd54c6bf8d8b2e624e33c60e368bc82270c5fe9ac8d4c27ae21dce0543f2766f459f66f073a07146406b9f65e304020d466ccd33f4a15b14d9c94b16b6c725b6f889836c18489025fcaca397b3e4ea6d9fd2b3febc36ce1a8c6400aca13eb5478f39c9d8ea4a8ce62b008038d8bbf434aa59e9dc53678abee95fd090d4b249db8f6e1d76d4b0a7ea24da5948f6dd67e59f06d63f2ea7903365a16644cee41400a31868b2d8ab6c832b22df486cf1c45d406a95121f19c55233a5cc2d9d1bab8f238f07d107bee32f4bde40227c6346d29aa9396f9e328c68f39a2d6213cadc11e97872857cf4d42e2fcf40b6d40b5b0de059e9a982e4ce99f306ff5a181c82b7b9e8a80eee1486d58de3e218827ac00b0707810e1947c1b28a169908f6772ae91a6a8298cfb56fff998da8236677b11e6892fc51ad261f59f2c80223b97789596a40c4a1fe04515373a416460a7cc8fa8556bf7edb98f6f17ee573c6ccf697db739a1f8318fe6b7c8a39284fa7b35fcbf846bf25f18d385c9a90ed6466cc07fbb03db1827f5ce040d698cd22c7c406d651335cdcc26b3901a3b8d36c1ba2e103dfb8f8e6d3add1944105861e2fe86cc1f969a1fb1d14f084d21150efadad8b18b5f8fde5b9af08da6eba351629447f53da5ee29005469bca0010473ba491e3b9a9512175614778ff093c5a975f851a37a7e9287cf2655392bb0305ae598c849cf9034f5cd846a6a79a7a8690dd4f94e2c57f0915771553655418358ca33321bfd9eb705a3cac61229892654629c16d1a0664bed8e95dc1dd982067dc6b46c9272bd24eafdc9915d26fd5c8d69f3590eec3bb48b5062baf9aa6a6a98107ba41c82a75530092249de28d6d77e9ebae89233980016e75744c895249130c2207901e4098480d503ea45ba7ff508465e16e4e05751d85e814c9c2d751aab26eabfa7f4c2dcff23f934232c1a46e61469a045a42c76262df2d85e17b8c4f0b3e2283c13de3c9a5f5354333be94bd23d0fed4faf4db1bd175f0b46675ce8225d0b44b510c1dfcce6d822e7a23a871330518ce9b32978f1796eb5e80e9fbb5262931b6d00bd11123327fb032d6dc9e92d55c3b08e381205568aa330ca299c1b4da7243cc9c77b54151e6bb0d8577beda6c6f428557297df977d566a5afcbe55fc7a85381b7d98491511729c4d6cf10a244070909a781f8630d8f0eb9493e78386b6d4e756ae804f1d3462ac6f8ffc272ae437573b2478d3d33aeeee9b36858682dcc76710047c3de3cef53da5e6d3b153e2d5abf266ae59b67bb1cdcdc0fc4c9ed1dabdbc455e39762b9b0542ddc7221778172be6ea03b8cea60111642ab53a1f95d68fe7c5fb69c5a7dbd938192133e283eca7cc7a29a6e9594f1efdfa576a010ff7596582adcaff1b61da2c3af87f05a1b68f45d30e67d798c17cc5b823896b26cdac817e72e0a870ad0fa88cf1e356c9017d658b306f103582f93f17e2349f7d5ce49e61d18928aca65ef5efbe054a5a32592eea9e78c8e5cda3b01f11667b3892a2c5e94651dc7e590a6fbbc8cca590e97302f23360ff15fce91311f416e05c12ae610733a258e141106654b30bc53513a4d0d113e108f148811a49778ed9079e8ee90fa1882869081bee670edab90359a773f76d5146a7aa560f846385a4784166c5c6bfded99ec1ef1d8f2a37ed42271fb151f6d77402986fa538dccce2f534e471444b2eac93c5099eaad4792f9a55f7a6813b48bbcf10361dd90900097b745130137ce5a0648b5e96bfcf99c640b09367cd1de2d92205a830da6cdd89ddc5ae8c7c6cef66e91759a8aa84392cdde7fe7433194b90ba833e550a59f554128f52e04b5f3cfcc984e450bbafc2f3e068d40643bb3ba161d0f81ece0e5f8a8523ff1bab73b5dde34ccad4a9958a3a8bc49ae132936405540e453dbc6942f05a01cbc907d36532e52ccda0e07793a24d75acc35b170f6a6fbd6fca1d771cbb0d6459b5341e2735d2e906abb85259dab6710e1da256f51ff80d7844c6f38a84ce8c9f066dc4e18936212986453126dcc5def80918b62b992e3250b5d0a665350f089e707794674bde3ceb3198c64ad2cd0ef82d12c9ca917c0152649afe3011c834a01b6f38fdfd8efc51cb343bf3340d7e9ceafb2a8a4f4f6aa92ff653b91bbc1ad3c400deccfcc9c0105f5800aa757fd3ddc729d91419e703731a2dc0f0211416014e3b542e78daeedb9f3fdbb94ddb9478d6ed1f2d85157f291892fd4be92ff12ad2f0f797787a7a9fe9f298879d95bb4f089ab66e910b202519df0f024863d5e7b8ec0afcc47cc8d158ab09e041bf520ef629524933d71c1bc5ffc2aa6609eab1e30a74af64a9bdf24e1cd07a4e89a764a4028bb606f9f623de568a9ae2821c8610dabe7adf8ba54c6ede29d91d755f26e831bd6a69f09161f2c5d34ff04040aee1c6dd8f265a368198a507dd16c3e3bf687e15a4fc74cb30bfebcc0f44e05e577386034d3f505b915e65319393d6fb7a3f1c8f0e170ebe5697a09d5cc219ab0ceb19166553b3b118bddaa53b742427137d3b1ff2daa467dedb0621fe7dee8aabdbda93b38026eeab99deae43188475c83a594f75cf63e744354dd6486d142868a078597f4fe6461af90bfc29148d307361956b700ebd3256d49687aa5f4b05d17bdfa16b615348db7305f64e216ad7eeed879883ec46bfe988dfd1e89babe67bb9dad9077a56180d68a9bbfce4e7f6f134cef16ca863fb6f3780e3209cd4c8a912763558fe0020fed08e85ff58b126a61b8af29ae00d96c13f88577c3bb029ea204bbfbf0de681f414d0f212826d354c9a0f47e9ece5de6d4e32b207a4df4d248afe9d11c4c87620d1caef05184d67ba108e6f58b8e2faad6440e5362aacd61b52990f3c3e2a78920b6abb728efe579e89fa9a47be3397b4a6ba7afea5daafc6f04a763a180fc916c3f4b86df01f8b5cc9bea5141eaa0c688a8fcb2a4698d7d6b09c5c6afea349a2163555e5c0c4dd64aa4d553aaa0621dc3305795153aa2d79de20ffc396f8eabd114e96265b8d0a42aed98ad2e9a610da75136877d7e9fc80f92f2e8e05b8b0779ae36ee87057f191cb3ea455854eafd2d7dad2f36298660f9701a50ba544137291ce3d8604dac4aaa36f80864f44d6a02d7aba9763906aae913fa2e4a71559f1ce4ebc3eb314836a7959739c25a462601ce25899813a0d7a83b38bc20896ec79ec542d160082176890e586223ced53689fbd31e55c5ad52c2ca8758cfa73e899d3c2193afde6ddc794d1e40deab781979512562f3457003e404d3efe93c940d8f4dc74f5458bfa5b6bea95b365c67ce3a42c2a90b6db018c446506c8266c5c5ce57a4a9fb4cde7bb46fa6ff64574283aa1394309ed4a4383c90a48c828d608baf52fdab804260fc7575c23991c6acc03320a530eb71881a6dafd0b4071e20983b6f823d7f82b8c10be6b84386318928916043908447f01a26231ffc307742c2cc6a932b040102c971fcb02847c34d7e07f112bcf586c7928e7f0baa4271ef2ccb8cca315e62038f1b0f424bdad63fd75b68854d20c99ed37f9371d8ec7577c9fce4622c5810271dbd3c96cd2c34512a92793f5daca27e1d27e379f49490832e52711dd021f62815aafc076dd0f7c3b5dc60a4d78c29ddd942b953b4c0f89aa6fcc2b9041b64a3a965c437da8e046e994e150e4a0bb9e70f26e8d161cac52ac37e48ae1724003719be19ec199e37a53b4d4663eb2aa073ce718e7b8cbd7572a57fd197cf7648c30489fef288df5e5c0dab46fd5aa2cfe6d661cb768c1a35d6fc0ec3a69797cf95cc45c5a0e64eb887bb5e9fde8d18cba5f9dc31c8a6f722425ed0a5f30f8f1c0c4fd08be99482024550297b7d2dc3d1b33e9d7a3015b9ada7b960bc9f66d68e867db2f43bbf0ef4f38e0a7f481bfceb7da60517fccbaa1f49957efc39396d9152b47d5e5e80de3ef80a176ced9ff8a3732a08d30f4f56647efa4f67efef0292866ed71950924220decb3c3578abe2fe543e20230f5b93a3823304b8799f244554fdfabb591ee68878eb8b81ad1392c4d961165ddf5f1c357319618f1be0578b800ba941c835e893ab8910d0308783281c599135243252fbbdb0ec2f31c0f102d828cfcc48a4f403a501aa1a862670d9178c361855a39debc6703d787af057c2a83ba91d253ca627058712401aac8beae95175ce4611b155992b1317082d4bccce08028e2df193ab80701c3466321ffa5bfe8e22431da5c63f66c7a44aca2aadf74d8cce9b4a22901bc6078f144a397ed9f95b211543a6faa5c6e75d92dc9e8f9ed6756dc34d4ca1d2c3c9fbd3dbac768f46b144511841f2dd59c11f7c5767b8053d4e324b68c60822c4efc5c1a1373eaf98cb8f5da4517ae6c6bb77fa0334f23ae357c1819dfd24b1664863866dfe5fcf96719ac95d6004747875bc369b8081c47b9b8c1a561aa9dfa9e1bdfa0680d3eae7bb296e71c57c8d3c54930fc48309d2e2f931246de3504697e64a19e059c20505db23681d8fd994e8315563beb691eda28aa3eadbb90257432836d1f4819f0df6676b692b41a199971ae8d1fbcd8612912ee6460d235611214ad49234afcff6b4de55f55272b7a8baa83d4ebfcf7f698428daabd7919170ad943154eae4f5029cac4a1335646831c1b6b1b5f8d54f828bafe6e9ffec871a94ca12fa30ea841b4e349a108d0f65bd4ae1243bf28dbd863355eddea1787fa1cbff1911410fb067a70463a046e22c9298905a46087f44d1b764b1e2e42010a5bf69fac34e00e5077c85353967458e3554518524c09656334ce06a2aa1c886aef08ac8fc538249e5c1bb9d956f5517bb2c8b6e2d63ce70f186597e453bbfd81d69da6e2f8ac94544eb800cdb15043a0e34245bdfcf01e1fbe339002b5820e808906c36d8dc386f117ed9d0865af2944f44367872eaf839d48613ce812dc8ba1d17230050145678bd534ddf61c47041c4c761c5ce9f50329242798ee3e41b749e2a5db7f3b9a30cb3fe1d7e67c102ba151d13201784319788909fd34a5a1038005832dde9a75002d85806c5d4c9ee5e779120ad23f7d0c7c9c7057267877aaf81c86c527d9a0511653679db7d571f3022a8c1e1af5249bf8459e3be1457ca735c49de01ac4a8202081e3fe639ec2150d9716765b2034209cdf2f8e2362a9bf34103273a4b82371ff7c199c398108820b57c5f651aa59261a6e059423fa49baa7da480d2ecf419dd9d4e44fbf876aaef1e95ceadcf545fab62fd6f12c1215af390d25aff4fd28ab532d700d20064db7536a19f9538b2215b579e94a3476c1b016574c104a2345d5125dce9308fb8dbafd92f889e0e337ec6e9c6472301fa376b82da0a1f1deafa7eb5f5f7f43ed60eb7e64e113fc88e9d0ca7fcc450cc60716308f86fc106a6ff7204f302280376eeb4185894e377a48553ef7d3a2b8507911f2c34b54bc43a7ec01f4fdc97dc3ede76929067ab36c17b00ab11edbdc9c5c83c87997c261be5c543b94d4b3e2a3b4f34315f3b7a209c5af1f4c3bce329f6e08a8238cd8baf0dd51b7de0101e857fd401686c87ff641795ad244216a69e0b848a0c49a7059769b4573961c4d76b9a7e96c3b1db8ec08237d1d2d443b2bcd937dc3a93d54597e074a756875eef42fbef5f3beefd7c7af680b6a01d51947d8d74a73886d3e6c8b29ef0ed9117997096d0827394cff90bea602c492863a8104643c240c4ac9c6991d87882716017814a7e5671f0a1769f8b2dac7587f385eea1c7ce683d7dcee12cf4a92b780d6e4fea2b8ae94918f854420db040c52289b3380d9f1f9961a7a96332d659234e4673cd5994de37d9da169e5bbff939c478bfe004700e0743701540204aa9858b3241c56cdbc2b1fdb4572fd012d1c9f9ca214ea82578375a3d320a0ed66c8e1c597831e080d7d241376cc5e3b7c1681dc156cb936eae934ce832a64fc5b55c2132d1474a73eab5f94cf4f044cf607bfc98c7f0bce71471bf5ecc13574d1d0ea020cdce04d997c7385576907986af61ef35c1abacd493608f31b0652d2dff66b3c1093e5f7f1f0ba8fc9abf4a9e2000838259f7b137068afd0095d915ddf223f0436e5854c4665a9d5af9651e74634de03a102adccc717ba3abec93f8b612f573c854c3a9f4c046dd84ad2eda394999d5692786af27be94b20b1247fd5838692a0532f7da66717bc0a271d4f2b29d3b9907115e201fa7bbade7d4d7c11c80a31672126eff264dc2ca321a5f173bdc1acfbd074459f865ef6187b154720b201a306539cdd79135f49995d5d4ba3538962af2848136dfff539312ee8e8cba377475ef41fa141beac79e46f8fef0ae15414e992101f48eb69c60c15bef2ea36d0b9792b0fdb3c57df1946581aaf3c69a9d573053680e60e5f3296c114a42b923be84d3d8e99e4d2575903326b1ff0617cfa5fdb4a1010a8ad0e5fba32db2f7c3a4f1c571c68a5f550ecaec6963cc5080ff254b11ff6f4df62f133e10ddd3b559e9cc7f4d6f7cdeb2609c14e2ff65dd403f7f0e2d3060a6912cec7d26543f6466c23441d0d3251d602b9a9e8884899115b79d812bdb5a4a68da042e0e61e30feaa3aeae50506144bc1e2333c9160a7bda7d47091f9b073724698902996783f5da4e41d2dd227d64962eff406f5695b4fdd082372cf306219a278c8cba57325cf4f42167ac503084adb9b8a0030eda2fb220925677755e6dc566751e9acdf22986949cad1d5d84046f5a07e9a1ef09a16ad1ca7634afc94b63ce7c6530bf8ca846a4bdcf889b691b6d8b7e5459322e7411a0928fa5f197938c778b802b097f034fce792f8b592c9aeaa964b95b6d44352713fcf281af8b2e0b568280996c6a524d2c9b68dd3e0a8e6f2453d3a3cb650caba11450d72d2f0cc176a7b96c5423f931c4f0c5b0d4e683ae03f4fbd5395721c88155e5817fa298945c4568974a7a17383d46d71c8494de58b674345b867fe57fb14800c39424267b6b6dd87d8365baf659da25703784d810605472d97a24be1ed1c41f3e5ccd7b468c51c4f4bf97bf7e88100909f8724a79dbd78fb725ef4feba8b3454e0dbc171c4134052d6a140ab61c42d9455c08f2cb6184008200a3d53d4a4892c620c7db1b452af73b91881177fa6eef3bf72577d8a62e2415614ce05713fc1e6d457dc1be6d22825dfa36c7b3786fae9db91ea8bd5899dd55c7b89c988cdb54b7878e2decbd63e790a02ff1ede46fd7d596eb8a78fda100ca264ec438191e5d530b211d9e243301cdc76e2d09ce97faffe1aa226ff341a6df7b5b93d6231cc2ac017ed0d4cdff8e56b30f4ec98e89a6a7d3771c799ff27ad34be8d8470108d02231348e357f26e57b0ede7033279351353dca686d1cc1540515abb3a96b1755cf131879a599490628b896e3d273ea2a8f45d3f3339e8d43d62e2e2d1f90f77babd6d0fe534f105e8efc4e18609c6399c7e0cd1f1b03cc8cffd55a4b891b1b89d5f7a1f98d26ad574b02fc8c3437836ea02dcd6123f9a0a084b85361de892106d1ccfbcc4564bbb55d4b944eba58a0c2ffa7a6fb3b69ad5037e49ac8d6d43abcbb22a219769de41aef90dbd354fe91efe87fe158fcbf9cd8d2e601f985e07b01786f16f5de4f3bc2a39533cc7792842a1e2b76e84c5968e07a710d79f867c2dfea346d28be997d2735e730208fadb14994ce3edf3ce8db19658651061230e0bfd079cb8bbc19ba1b05c7152c7d22e1a290523973c0b6701638bb2f0705785df280862c81446b40bff2169ce9042871f7907297866eecb829fda19806d75297b701ba82441acf70dd7d3bab96cd48f325fb68c611add42f3e3bf57e03084eaaab2c92427c296e630bd47d906eca20743e09dc4ba1b8e85a88b2d711ca0bcae5215234f1bd24fb61a09581de39eecd873fb534d3500f2330e3aa2abe79511c67459b56c0f03b06d649d4ebfdbb8f72ef443a3cd246492a6180f37f28a6686e2499fb8909a70d281a374e2a8dcc8866b2d9ec35903c5ac9d64b2d2d725b1f8851dbb8fb8a53588998d98eee1972c8c44befb35765ed084f24d7bcb0aa3c68500a748636ea3f801b3ba05b0eebb1af3161a68137823948335c6c35a61595f5eb7966c9b4307cade3be5ad72c9c548e3c27bcc3d2d05b0d7939bb0db3c9e17fefbc058e8d7d45c59b74894e5c0cde4e6e22abcbf876c5fea7f99cf0062bf95ed50f6eecbd2531fa4778f30f317db358d5a0a98088f0772a64f55defe1a46e7b3a9c80f9f1202f4d8edf1bc89693d0d5f52344c750cc575b56176ea7ea07709642f912c9c9278c0fa4459422946b771b37455b80eff31e4ade87959b451d4657950fd81b7ca595ba27042050adc5a53b2765b7e12f17a31eff2b0ea8d42bd850eae6281e7d89c4f2b9e81fcb35ff66bab2c90e87353c512507bac5c04c3ab2bd8b4eb2b636940a317b4ae81c8a20a1a605b746b0f028daaf6b151a05b70a54d235c84f043f1c7c07bb6cada0816162e64bc5719b75740c18b5b049fec53b0bb7d2612f637819ec6f298916dccc8dec0560220157c2a4d46d18b4bb6c5ad0457771d674ce0f5687eff881475b0e00bc6f140aceee4891ce7350de706776032cd9ed016a9f9342ee9758e08090ac7c4872e6eaac8d081a20c3721b1ec3abfdb5021e0e9726aa6c0ceb0ce3c879d0f8797666b1133890c9a779685908cbf1b7aa684b53ddd39df7a62bb3df73e6fa9a1dd633dd4992c91aae4f8eabba4df21b5429ac47c0e018e3776781435a8bbe0234b53050803dce2976455629fba467470299e5bbd2f13410733ebda1325c574498cd95b05c20cab9a82f51c8475578111a28c15e9b124902467054a125a5b6ec6c65004a3a308d29d00627e77290066725ff0a29e3ae2b1a087ff001eafb14fa2f05eb9b10ef88530d67fac08b484b9033e82f625adac3177ae05a7651680d7947d84fceff5531ae76b0b52978411388016ce13d803c3744dcbfdf2a1303734a9dc6fe157d7d9cd606805f8a6d31cad1c85356962bd973d27d8072616dbd4857b13894e6c5b9720443ea24394cb36cf2442826271dc30da583ca9b23a68b1ae7ba48148f3b7808c7c5b7c6acee37c482ac09c84fbeed34c56e6bdd3ea27249dda93213440bea9bf9744e0411f57188670b1c5d74c3981b27c49d60893fbb06bdf1aa5fdd51e925cc184d08cb5000937176b5e395d8ca621f9cf4851c3b41f923ebd524442b4e03feb82a162f802c31a31ed169304de98897d1eb60f73c218027ba596b73e200da19eeded57e4884cb8c0256186c4d38d0c1d45e8906c7476938f9946546b9b14ff20cc54c54fe00244c34f3798fcdd15f51e67a7611877269fac960f47094ba6de3e99bffd684b3953407d433a2b46572fd249b2aa6f08b1e0c8d0947a53c4c188d3a17d277168f62796ead7689de96d3d0ce70f4a8a3413df10fb66c357591f31f19555d0301f0b048c957e81241bfe1b85119d6a9e8f7c4e7b9db01826eb3627f6f183d4d0c7dd202acb2c7c4efb0c65a7824c46b4395e22866badde67af34a1d3a6f3bbdc81899a635119c923b0fc345d2750e05318488ec55f12992601b6dba2245e883bc7985e1487ec50e5f2293c77d56b0bba47589079e24e06560c9cd62daa6beea5214a91674015e1f12c2378e2e480531f0255ade895ca6d4ea5ba100ccaef0166cb35b46ba6e482ce49cea1669814230955423a47dd15e150ff1003763f15b56e49cbabe38f6ab18acd63a14afdcbd92e50c4e66d89925b9c0c5dcaee68f7478a9a7d38761e7f0c6ae6c10cc989a4a0d7b7c274901b72b31b9ff91d5b1773fccc6b2a9fa0ce9f304821f75eaffeaa7445f5b327f4ecdd629289ab5f1e00e7a2942ec7a460753bd09d7a8d733921a4266ff226315b9cc9061ace0cc49a675211cfc02a50677a16aac3019fa8bfe41a19618ff534a6adf14a131d9ea7c089c7104d7de465f2ac79223dfea82a1a0383adcf14a978ed38fd691070a2b2ba6f33dcdd811cdf9dd8ca2a08a366ac18e20002a91926b44ce612056948a5d74383fad7d2e361079d95505da9669e8d8fd73e5d8062177e96b9767da01fbd75d29c2fbfe9affe376d475198a0b6f7e81c3dac8c3de69b2f5f3c656b555150db507200ba0bc21861e4af76b118ba1722d5068c318e68dfca5bcc241d19eea996d335ea0fd3b03218867b16607e6d05ae71fb233f84f3c66ab17de06da91610449f551cc2863b4c3f1bc96bbe41d5979449e2d2fe45f754cfbc540caeca5147befcf38bb27d57e117b76289834cfa1a0f370ea8d8676469a5be79ddf15e667f1051ccc2ca6f0ca7a09447936066fb3837537289811e176042d1c7d0be4865986b9e4f171ba1fdcac722e8fe8d892ef83fed0a46f9f1b69570f52c3b73c2c13bb7a0f3a36e94117b5c7f9d045f9569220ca51827624a2e3f72284e7325dea716f1f2c9ffd1103f509c7a05f4a065b02aa47bf41db65a5e47ad258f6692f174518ab33fd0ad64c1c5d9d32f46f7fb1cc8404c1c9a52efeafc76e6ba86b8d6b4b166333ddf287c95ca350622bdf36b3e4789c3feeb5359bc5e99adbd2f718f9c7a1826908afa124edef62345426548467ade85354f19b6ccf157317d7142490b95d17ac5714f7e94db4d0ec88babaa304d655fd972a18c938572926af3b707e0d79f76c6942396877757a70362a54c509348ca573a19cb17766fade8fe8bebe946595bad1d7e05ab33d47252a30a217490cbd0c9aa3a716aeffd4f1e8d05d418eecfdf2c27402223b1278d3d5e3f641748e849f5dd839a284ef326e3eda264d95ff3ab4527759a86cfae2bce65f9fbc6eadc6a16936fd2b6b1d904688d36c696a7b999ceb2f0bd3820d3a0079084d2d1315c45edcd64b96a35b6ea559e07f42375825f260253dc639234fb929ed4feedd2f6f83e1037d87834f0bcabd8c8396016a21bb7507538d59d4421245be38ea897ad2744766b5e9e71eae576be4c09967255f233e54ceef1fb72b714f52e09c59fdb519d135bfefecd646daf170ec70994c057f43e33563795012ee086089f66291881019ccc0a681c1966f9ee570a5deb17d03206e653ac371e92e8720468cfcb0f8a8b3383ffe1302395fbcecdb98b381ea472f926a07f95ed3891e88c5678099b3698508ae511157a4ed7e72c655e27bb1f8ff550ee5f829ad1f39b228c10526b63622973c4b5568adbb6271d68ec674e429feec3f147bdf87db3cb6b405c1cc5149a58e0c6ddbf3be3385b2723a5e67165ecd1c43b40916150702a0136b436fbddbff5cd9281004e9beaf7f0f9e690a00e77b64b8aaf6541be151d2351adc437d4676f8f6d6a10f480c2c8222715a4b0daf89a9818e532949575bbb28a733c946a7088438dfdd43dbeed5736e92161e5f1b39b4658d03218f8c56453d74e731315dc82ad9ecd8ecb8333b1c4ffede0535ad044bb5dfe1531fe5f1420e0482d0b58d81ae7b38abfa3e103aaf118d5146ba772b114fa415a577d71a5d0d4b576ddc4eb61066a38d25fb3ff20d1948541ec7b86bdcb674e84f721d5ff52ee124fc0284b054b776306387879a2a52836c79a0b6fdc1d0b7e840e9198c9e77ba34b18d26a025625639fcc6cb1377dc0dceefd05f6398b5555589fc02ea0f8a6e635f1d2438cc04533850697e6dcb864799321d2540fb164ed452171159d83a8322f5c81554b0bc438aa44cf6b4d43f4b4b99ec26f8ec15dbb6cf864e93f54bf8ef6c6add1114be4c825e762fa4f64090a9bb79cfbe72401172adbd36e0f4888ac367201bac8fafd7c9f7b5375d5c336a51db9b46a5a872eb9420045a3f7a3af6a0c890e214e8d6d3321e9e33d15481a59cf82ac63633d444be8d29ef9dd9d2ac3844885003757676201e724abc98431ce0217a8fe24eaea0b79f4343390f5be737c8f33b4130ac388dbe2fcb92617180979d3d5f88ad7c18ad71fd79536d8297d63cb3a3a2a94cd26fc99cea88249e8ff28c6929402fe61c164ab1dc42abec65c327a25f720f65d4025f3725cfc76e19c0a7043907432dd3b191d9ecd5c2f3280a93618bc0c428054c32c12e9997a423908c0baf0f9489084ab3ff5bf500e11f2d1e21bf91ad7ee07cea58851ec05a75d4448b21dbd47a392790fe8f60719783641caa7f7a2db7ceba9bab7874ba4e7d28c9e66223ddc07a234162d2761379213a9b16daa617204fc3914b121e0273c63a3c88fdb5509be816561e3b720847a774b97850212f88bcd307f5e7a492d956a1ccd2857a12bcb8aacb1075bcfcafd675775521e1e9940a4da6302bc28dcaa63569858f995f618a06e89dd6e1056d56643ce91df959389918c9a7c029d9710c8f4c4575fccc48495ae0241108e9366353195c046f1a82a633c348797ef50bb14099d83cb644ea7381b1a37e19edc6e1455a7437b1bfa884242265089e5c2ee0b7497a1349343262ded4de8b165ca216cd3e4d5f57dc636548af6ecd8e803a8086301ad8aae405831ddf6418fc3d1d745d64a6b54c8e854948cb5b1824b272d716e4037002e5ad0891c44e73e676db312223b80b76542e5c744897f7283e4622ee93fa8c4314d7e0fa0ac09925904fe650cddf103291d97accd68e60a209c1068f9d8077b2120c3cf88536519a95d8d18b931ab4ea812efb6385bf60eb62287949be8d1ba2e8523b8f869d4b133f719034b279c71cb3d6dabea73076cef6cdf646bb485c7209033393efa966d46ec97475cd3af93195866804db0f0d1770587f6c22329556176d1f54da7172cd8224aa39476abf158cce5a57cee062c4c98c106737c329d73e5bfcbc403b0b939a62108de258c9b33257e0b0f02419ec3a5500eae59edc52db1a91533e8f3cc5f30c9d4af6e95e098645cacc3b0c25eb7a70bc2b3f11b70af16103ee87a553ff4b956c67d9330850644544c9dd595fd3b92222732201179f811b0dd394e8b2f9af183ca6bba724ae3e21d688549060caa8b0670bcd11077f56e87070a487f3c25354ab14fc9bc83e8606378331d148fc96e33d3129713a0ba26eb859c8331eb50479d9cd3ea3ab0db0bb3d1f28e149dfdfe5b6f2e1622c297dce63378f5fc69f904b4ac932a2dc367fad064c5ea42b4f2520040eb4fc5061fdd53d0f9be92200c3cfc9ce8a10beeb7be4b1ae26d6b9b471e8378eeeb51450672bf4dd7c9a684cda6a451ee7cd3c95a0b6a6b03edbeac23475b4fc270f0d035d4afe7cc2c79db7b4c85847a0a7e40613db7fef5898293c66c28274ad5293ad0d784f59994973c1e691780f8be2944fe289dc8f801531a91ddc9ea96a0141b4ad98200f985c8130a1614b60560a05159a8f5da5fef2cc380f2456ae3f6edfacf62a174a85b38ca0550e3d6a5848f9217b38aea1ca7b907e5d7ac355229f041743ebca8e6107c44662c283e4993f9d3e8c380879944e26cd0b0400193420a7c438e740cfc5e460d0c67653dfa8ca8bd3524d3aff3708d17863c0de0f7adf4523d7addfd7a94b622598dfeaa57e359bc83e6e0a0d8a433308ada5899596b9108b3b8f4077e86194e25d708dc03540b88e5068625c2f9620b01b5766ef0f36d30b7f1fcb3824e70b2909aeaf6b0a85c39b993a93b16919ba856896ccf4d8b87832102b0f188c6f33cdec09c68c7803a58442baf55bf832401d557a35ba58b30f18955c00b0851698368ebcfa9a4c37885cf289613dac8db0279a0c1df035e041e91a98bd0881314c3da0a9b73acfbdbdd3f73d08a70d7c71132f3c13d4b8873ba3e59c54fc06c38aa1e49303320fda9e0f6393b3969aa0cdfd29642a2394566424f24f7c2f407b7df493b5cca53faf8d8f02fa8a72dd4085ea5539e2a439ec70056d81de59d370f713205e8ea50b7334f9f3851c46e7a942cf0ae7aedf942bac86f15072a509af7fd391a3773fe1ed8f50a7f503d6618c373ab6da4c993a8d5c2ce7ecb855f68ebb374e8b6b944ba50a556c23ff789e08165e64343bcae367a6b96686013c0d7f0a4f9295ab8212eac6c66e4826a8f0bd6e07e5425d84b1dc73d6e19201dca62aabd78c514576129067fc5a3f9990dcd2cdac2add47d06ef1e5520c11183a506dab888913803d1445bef01b3fe9680be62d745a154cb5e0449e78f0f6fa3cea312977a932c0cc3f3b3b83b26ff0acae31322476ea1c1e5aae43b8fd876625e4cf8d78c32ad92c3ad799e68ec59bb69960eabf9401fe037a2df2f81d09f83d1b08db40a3685b6a163defb0918945a3c2296fe7365a5f511fe56149d937bab8f7c3a8b506b42aa59fcdc0099da2a6d40b0e9b94993c2af56cb7f38c9fb054d22b4c51fc4778a26fafca1ed201d3559d14982e9bbed04b6d8b8b82cc0d0ee0d814c0f4e87d9230936a8823632289b10e65662461aa42973d85af3e63c402a5c5ea9d441144be1c3baf7da3bfaebb7a9bd698fb0aa93213a8cc7630b7c1e973ddfa9411eb25853921e7fce3f37ce91124a3273e2c40f3a1664dafc72b2767edd7a73fd1589e8d8d4977ed4fbad0978b3904e2bcf8e06632c9330b4d6c47a77536b173ad61f36af0894a6718eb64cb881d96578e5b54a84549d17a7c68a7f5df3e1ea101cff31a08c0e30c87ce15f4638a7edb5ad071d47d0015c481e3c38fb82cddd8478d2d4fe8501a66478574470af1899f2248f4be8f4574e5a21b21f252902112671ec8e3596a7c876df744cad656541b8fad588ca0403518113873796aa5fb9bf771ebd5c6e9ab50daf6a71ebfe4df9fbea94557a529e0fa512dc86c1e71509774a077e64d8b2946fc8fd097ed2e77c03e92802e21dd0b4204b5bcb182c4f10b4a069ace626fd65f9b77743721d7ed987634a04b1bb614f129b59f46b1c13b1c6dd5dc60e12e998189a929e0be22e2ff933aebd26523a23be495106c8138d6118223916a1c010d77db0b6c15f9eed067fb58c88e421c132f217997117014ac21771b6a9c4900f5bacd7647313f633c3e508bfb2e782e75a619979d91186798365ef7056eaffbbc2021d8ab22c2caae006a48554c419986e7142be18016a946dcec42a6afa6502bc02a8ff0dce8b081e2b9e3c5e7b58fc838452b81a0d81d5d0e584a0b555b318b79a753fae79ed888e22b91e6f253d3140f792de64f574a06840bc68a5f120ab6ce2d18ddd573984ef95610c973170962361b87b7e2b06af4afc3f2727eba96240cf5c2b2376f2f4a44ab66cd480905f0f32d8490372cf767201356bc34f4ea1307ac662551e931dc601a212a984b9c8349bae44a5fefcde6247c5aa2d62d404e53be239db34c35e67a8243bb4d0d40c4be1273e672c05db6f217c7c7503b47752cb8e804643b82f4279b7ce9bb6ee7a06834a54531d24ccbaaf72620da0db921002bf0d328be8aeb381243dca891523323cb6a0ba264fd39232954af7fa8e74d432caeb9f72288fcc569b74904463dbe08f023d7aa7e7e3d8e9b9e4559e4549ae59f6cece0d5dcd85166cc2c79f44c5faa066b8caea1100f83def5a3343fd5e6c6ee18c97eca7fb0762b2cccf6a5d53b9ec418021e58801ffaa5dc5d6d6e0dacab1812218ada21e8165153c391c6cb975946cb375a87f3ee649fb0793ed1c7e239b524a6d7e973600d5a681b08cf3801409983f5ff55dcddc3799001e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
