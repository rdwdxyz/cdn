<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26b38b910c32da6633d1230710db0a4a11cf215ed2766ec11149b3735ef7ebe4d4748607aa2e580d2b56aa046eb25571be4dd7b7b0aeb87fd4c3a44122df4d82df1955acdcf15eb4466da9490a8de56cc1fc238a4ae0989d4b667860745dd82e4d78896c35e972be2d8c7940feee5e223ae26c8a8b10195cc46a5de6cc50b1f3a0f4cdd184107f8d8a002881b0c0ff776a7757cb3819f50096965edf88e0ea00619c34fea3c20e0d5cdeb7ae89d9e7bdd2151a669f39c3ef19d8f0b2218e5c71a2933204ea8444de7fd5d19f587d220adca391a46cbcee92a3b0c027c3d29f9075796781b42214173898a3ba1228008113d7eed246a79a56cef1961164521ad394b2983bc3de700fd4400792368003267aaf4381d12414bcbe69729a00c2f8d56815b6a6e904e7df753d0b795886452084f03d3d7fbb43ce9fa375ec088130cfcaeadc7e53953b4dfa23861f6086721572c17aecbb0e9dfdb9794850ca6d82f7ea8d89ffba658fd788b4da580c1a53e41c00548a6ee66807dd56dbab46daa22e031afd26ef13b6ced292b74d86b3e4630ad8165c9f743d6704196276bb4bbd07f993b49f3001699909b5239b8f93d3810404f7a44e26b7df817c47ab5a5d1cb0b134f245abd5556e8cf72dad4dee5622602e159eeb294be3e6e4b916b6136cc4f67300d9e4e6c98098b7254dd9b39de09e4cdc433d6eadfd2ee61b0ab5863060460ff9253d7c955a5db0891b9857c39c091af920ae42e79b9dbb937872045b1acb32559c0330b9025b535f9380042291d5fc90492e7daa67bdb46e26d76e7540089562254d53659c051f6826b91cb7e5e0566ff8c176618ff28168cfa31a65591adcb599c686aad5bfec62d952d889658ac25d4c5ebdf1cf91d69f8490efb7c701785d617ac1eaa4cf3007ebf0561125ba448f5c3c1b682d675acb4a1e157c3079aab9773a6f6017ba347739b37cc9be3355d0a3e4e12660549291ca1598c8c473f4cc9252f010f0c7366a767542eabb9753f02259820785e9e21dd2b9c349f3494267859667062ae85a994f2f345d9c0f8306845279a1901037a61ffd69b2fb1f036c61450a131c652ab07633cd6c59ebb981880abfbfaafa7ead6ea8b4acfecaff3679a57fbccea0065fe5605cf7b90bd681dd25b69630d5226c4f22aca9cd1822b85d30dcad0130aa04a3d9ef7cf67ffc8865a42eab3aca384effd1c097dd6248ccee3e3bef414db315814129e7e0980a2366372a3ef76acda23ab6e13b189b1e341cdb6753243c5d1094835cf8f455a2219df89958c2b0487b0e08bb27d48a4684c38330edc3b14a1421bc99e98fb65362521efe7c59efcb88d488d392fc8ca3963d6cc1cfb713698b0594d13a993b84bb629464ab5da84b399f76a7c855a0c470d2b3ddb1c33a6a5f5e16809d7a5084addb0405f3a882629a400aa6f6562412bdf8380cba95fba41116545dbbae2c195a43b000d0226e28290e279917749d35c481a1d36608ba5d88c1bcc6ed813f1485fbaa31c9eeedf1bfe687b340c714ffe70d0c0ac311a0b9826d3ce093f7e23260199873e001798982d16589fed5af0dd6f90c6b1f3a08d27d1ff69c0546a59bd3989cd9b6615494d7b283f66a827d20e3605cb1a912b73fdf4659cdff7f341bf4cae21bc92cb3a9f4b72f713cf995b2fda8ac9fbe2f891933c4c47b2416fda439d14943b4ccc65a505bf1d3994e9dd583cbcbc2c9b36acb6b8661f586e0750aeefca520cb04acd287f5c5c6a3bed542329341ceec514a7f1b2c12b53d64c295772b77d0bcf8b8ab255075bad18819049037d4331d5ee6e08ae6e5fc0fa1ed9786a73284280225462bdb37062e15d8aad2d29d3ac95e9cc268edd48ad9f68296bec127bbc1fa22ab38046f63313368211a3773c3a5f0fa003c1a6e4c5cc320412e75f92414aa685bcc93be5cddab7dec2e809f76dbc5be62f41d9eaba405b13bbf26a720604c49d3817bf59428679b365db082df37e85f1817606f577b5c65e22ec2b4df51294f2eaf7d467fe3933d8f175d9745896b412501029c23f8bdc3a0b4a5c34d3a9b919dc9ceb4fdb141d490c8eab5915eb0da9595b12c5fcb7e1db66d657bf44d24a44cc9204042a8e6ae17a4b2cabf824f5375b7bcd11243dd82dc0f674b555477afc6346413a9df1b82dae1ca169268a9e45c24aabf7f2c040f470e3f60b6de2699d46291ae1e09ae6b07276f342d82a414a655f9f928be6ddf85af9bcda2ccd18fc3a55451b8cbce863ba7c81f2e6a2f3032d24803c42b4aa13807636803d72586e91d3ab44b77b5105e0ce4e9da82e2c445cb480473c65cc6c751964d4348fc706d048296c110e20b6204dd398ae35d6a187eaf736cc100648845ba8db24723fd1e0c7705908ac12c5b53f4b49eba48fea1b860b20ca63c431fd10806249ab5f590c091aa202566d4cfa0eeb48a0e08b6139aa2795568c59f4c4e5dd05338ac29cbc82bf312ce633b3c1e5a79ac66f5ec537966652b49a1cb2d8611ee72680c5d7608cdd2ee5c6910c2022b1ca879e995e65ac51b85d4f26aaadbf6cea40cc07d4b7030e60f6236a336d0a0e3397441d42039f40a282944e536963344b022eef7603f86f9977a73d421bd1f85c69e133f89866e7ea24038c0670e4775f256fc3a5791be43b274d5cb915c18317af8b079d75789287b6fdeb2b013319d0aa33373265d7748d852aa6f069ef903a25d3682084b257e7130bcfc2ba5e3530f7cece1cc1c05e4a2917a753a352bfa21d98e4c1a7c8849f1c037b659804784a7523494d8a62f6a12681b4c061a9e4ad859ac8d6def7e6b5d03c97746903eba62e8d9fe0a2d40612824ae6aeb15d8872ffe913abb4044d0a1e0d2c1ab0edf9505f1f62172ce62e32247bddfe548e32e1f28681404a401258969945b358e3c8ede2348d7048b9da07150674adbfa218d5495edc721b796f9a287694a026a402aa64d233f76dcb11621185827d5a187b96047755b614b32029ad177bbe2f22e68e48e6b182db93446e1711b7f1660864b16df4d7cc220c8c51f4b204eb3f948580a57a4dac373efa48c606fe7648b33e6f8e4c40806aa48b7e22f2a0e0caeb7eef52acb7664ae18a136d177cedf4d8de772a1a70d3cf9cd15933030c609a88ed83f7ed9f65b1d7879c58f6ed51ff3b583ced0d8935510e6b30337182eb99a89ddc0fd410fa66a1b6284de2b343d4224cbe2e6e339bad1194f027e40bd01f3323faba9ee32cc7877f399f5c72ceee7ad3e7b86a1e71dc15ad44aa12a22512a5322dfe6f2c8fdbf110e82f8b2e9e2cdefd0664e244e91064097afc744ba0dc4800881626922dd1e21aa30724c24fdafd446dcb71c8bb263b105ca4cecbb8182111feed5c56a80e67af7cf0842cf51d4a49bbfe6eaa8a0e82661804d1c2a512bf2ec7f83be103c4f89edaac37fa2e6fda0aa946146a2807ef616e87b733f8f33c032472e1b436fa2ecbf6ab2240e332294f1fcdf3c35818a1d8286547d1a8b26dc1ecb343ce24d0d173475f5c9162cb74e5b7a6958150787ce489fecb7df9824f762443d3d036d1e6ffc42428a21367b399166c1d8b3c9a076218f37e4068d68992cd2c1629a7ddb04db35470db70e241aad137fa4043367bcc2c02db25fbbe353f7c753af1a4bef3e73be8851cb622ca2dee8c90302c5ecc0243c778ae26758316e754edaaf470715ee5c682edc9502075b0dca66e2090dbe5d5551fbab865e783ac45058ccfe16203f1173635aed3a8efe357103f3ae5ed7025e0c105143041b5bd0e768dcf083e12ec83bcc9cf0af83af96869370021ec9e3ad7ae7e75c867affaf2425ba746c2fb22c432e80fbc6c6ee120e847a551e685434310bd7a30ff471180e7717678415d3121c091d3603ef4504dd42ce42e8d2da439b1306ea4bce0892142d71ec141df7b871b58d622cb319c492bd98981aba9fd18cce95ce5bdd91e012dfdaee24ff08c351b97d06ba6fb5bfc28865428c27b76fa869bb03b4e5c8b8da1722b843e8f9e75b779815b3ba3c6c27b83aa9958847e127cb2bcddd03dac796960f35541d02e70b44b8cc80091f635d91db480402c0ffdaf5ff5215f4bad4513594afa4be445973d4681d114b989fa93bf2f44c64b9de88a8a43948f302c9232091d263b3d1060d06fde2346cef8b777538a074bffca75bfe543d24a724d46631200228f762895f4bec4f74e509f1da3b070e56e3159f8156eb95d8e3be11ebf65c569e8a8be189f7de6d11d3d715f9017f6dcafa4716f844bbc4b21bfc435c17d7968b1f865d2ad9c1a7eb8604e0a5dd9de01130e3f031b0a5ccd155f6deec1f0f85c17e3e48526d5143673ac0b09fc33677eadc330a8dc551f4a31aaa1d84162cf7717e9087925852f99479637351ca4e9af785f0cc71700773f7a2f3818a3fce33364d4caaf5bef873d77265103e7fcca21d2db412b581a2627034a540e7cbc1e60d92b57b946174c67035e45c6a0462c922b4db67f34f3013db0133256224084c8e27dbcf7312e579c8884c25c26539cbc758f3c2bafa6b459abe8af310186662ff96f8aae4d9f7d16788e4dd69cd96016530e681c6825bbb670b5d574c27bf0e481cc9c0334703207314027bb94fbf44363b13d43e2b0665045dac7cda0017d4125a522b63ebb87f28260072307066c4f352d446f4cca51bfb68c0065a2c7ed5d127babc11b96cdd6c8bc9cc1f9c043d5b14ceb60fd0a54ad019e8c81b09e26619c368818b9ac2d2d3c370ca603902b0a787645bc5351d48f99bfb65a9d9900a4df85af3287e6ddcfc45718fcf629c17f366b0dae2bdc462e29148868216fce7d33b0345b17e40fad51f3054920101aa0818e61df9954c5f3362fd3fe7a8ee990c8205af633133118dee3f055d1d869fa3d99143d67ecad7af4ea7580280786b8ea89dbd7f09eeced739291fbb2c9676ff1aff19255a184f540b20a956febd90d656b893cfaa1f0166680c31ebdc7848bbb721c6e00a354cd7878c7b4b22efb943fbccb2597cfdc3211dc0c8abdcdd81719a70fcdfac777cb487177e12866e914203125194b60148024792373b00d72b7be76374f29465486ed06d44b3c2dd41ef729067e42d70d7366714dfc97bf306d67711ae3a6eefa416d108f8f400248d1b73d8e87a73815b462b37e6ed9b6512de74905a724b4b6ae7a5d294ad0e20989643c1b5da741ffcc06d37babd953a68edf2833f3f163f49e52672db015a22d09387feab0556ede807dce4e990f75924cb776d2f7f96c4d5a00c1285b1281a84e8e7c421b4b14d74639993249b6dd8ec875d9e8f5a83f4fca4dfd6d8e2244269a3a4d57150c44aaf7844e151cf3518195e4edef0ef53ccd9067d11ace98b1625b7c4f656c36030b61351b510ce32a2a288d24d2ceb5d741f6d002dcbf961d904d6cf3b803917e4600ce7bc250fe05da7140b8bfadd0732422fa7ddf33bc44ed720fa30a6f6c0c291da3439ff6bb488f5213fd76d64fb4967769ceefcde7cfd349c6ad511f7b3484a4b2ba3b78ef493ac66615473e963fb4c7f9b647c005a4c0d70e34e25413aa33b356a2630acf6e6be04fbec8aa594f2be8ffe0d1c9657127e1c23d0776279965356fad968f89d8c1c0d4187dcb4566dd7b5e7ba3fcdd280931be66d972cd1ab6bfad8087879a23ebab5fef585d9d62f3819967baf0e60ac24149ec087309e3b242773a85881281c6f52b8b30bf510a4439e411b106f0d58b0b98138516cd788975b7b0a59e7d303f3800e5921e7eac1feeef2c54a6d38e1402f953377b661f597305bd7b94dc26c11b4826d90863c10c1bf57e9acb50a7b0ce6ab21dc6e83d5909cd0513f7cc4bbdc100c894c6f02f1ab8d082319209a2b1079471b693af228c4d0a3a85078a99ee3a9f790386d3ec78b06c75e19ed0c6992ab5b277f99af237e93ab9ed5f8b3d8116bf26cf891826f184a9dd5cb7c01c0ee811e7ec518eb03e8028e17d8f87d0c162ec7578edbe6f798890403912c0e0600c806fa48d478b5c3d52718e303fa3cf5d97740b69f767eea4b93bbb1adcb4fd5fa0e9bf9d9b4615b23ad16c7f974bd649dfc65d7861ad142aa6c5d3e4227bc50c6b2bff7f1615c8cd0934f08cfe3eedec27c03dc7de7133db1907c0b8030561a9e23b7e4d094d096fecdf89595408151cf0f46917fd2ebe2bc42a462f378177b7fb29384d0d23b8ad46efc702765367915df20f2a42b64656e5b3aba519494de72e5bcb8c160811cdd243417e94ec496daf45272abb70cd952a2de86dd251455d6024892dc5891c500ee21a87993fd3abddbe52c88a5c6e46b3ef4c7b333eab3cc5181a39ace110387ff4743766c8323275f9a87c9b46590221d56136e5cb8b6a92636f190018ab11f2aab5ace63e2d313d3536f76593fc0a9d2c395feac7f5dc62c67008724f9a75a110bb6326ed3f200c53c631f6fe9b09bd774f72a44c64df133f3a9e3db2b8923feb2e0e7386ac3357620f294778d32abe3fa64e92b81e43ce12cf667a0d6a8d7947d907cb9643d812290a9b14ceffcb29a8f63a1c6517a9710f5a30392d4b82d81f7f64222ec06a03c964609a89da2ffc47694eb48837c0c6486802e998ecc715ad731230d5d918f8a269ed1fcf3fd018a39277f3290c4cfbc1fd61b63e6dba8720e7ab3b70a90053da79aed41b682745d63022bf2363de8adf773076693d66c338a5b7f13648bc5262f82ebf724684f69246f9cbd46a6eed69bbf793ee9ebecf02d3dfa7087c38372f076d0ab859bcd1458159d3adac7c0b1f5c48fba8dfd4b7c9f57e03d6538c35f600aa9acd8fdc3e2cfc56197976e88375da2893afc6ad9c0b361ae7959f84dfa22bb5bace8813f37c6c865d6fd7a3f7cca556885723a4ee8f3ac584a1daf5997e2c68c09b8c75cdab99694c78f7c5f13d6dcf3f38507554f16c5b2c05def530c01e1817c4268a5d9961d47a9b6aa330b315992bbb94cfbbdd323594a456c96f33fc5fe7f30e770b837c8f4fce4430d717d5fa60fb95e00830000a57469efa826987bb9e60fcde6f97242d29c81a861562aee58528274d7ace33fbf64f22cdd8162646cd7f98421e2a9cd9019f0ca8e180ef4ee27684e9d6bdb3975965ed19fa83fd9c297e56c385b678c34c253af67ea69bda8107bd8541552b9768c6ab7689ce56439f2bd99ce49d2300050cdd49e9f4afae30590ba09b2325321115cedafc0191833e27e14d7fda147bd9409138dfd9a1ba99ef51177168568757b3b327d463fb0a7cb99fed3663a52321b4340786ccd1b3322805649f984b320ddf8ff0e1517d58ba455fef3396af466af03cd5f08cff82280711f7207037d54d8f8db128b9ba3bae8fed684934b6a95d97fb9ca1741b3f42db615e8cc14ca9793ef60147db1ab9319e49bbed133ba8bcad9388059e10a79db6a1d5ba1ee07fbf0744989b0484f1954c3fdac46ff418331727936c4f4a50754c7469a41c407f80f83e3fa4d698fe431e6c4dfae5d695b1323614e5c5736a03abd5c902ba3896cb82e159ddd9c5a17799da69078c4f31f2134a1a0507323270fab040f883b5c56a6b5407add1eb67bc8bfaee47ffb0876bbe28b2a80ff1aa56f5a3dd26d664b9dc05cc49b0bdec8b988417b77a70f179c12cfb541241b7b60ccb4bfa9ccb489566340730aed9aeb4c6c28cad6add16c5b6e4a7e5b5b004198b2d662276802c1bcc317001a33f82716dfac75d5cdc80978c69815589ccbffab6b86cdb4badbb50be6ae4fcd56bcf918a2543e9efeae8f32ce1cebd46dd15a99ba7cdca9c7c28639e354589a4c1dc01ae20ed6ba8e07b628c08d24b5cd052a76e18e712d37f19f5a1c019dea5b5a20fee2727e9c38e6f0f9cc9b7e42f9b64832427fb857a6fe022fa91a807c03d2b5f1dd1da12229b8f2a9ad8493bbcd085dd13510d59444c68a24a560a91d3d5c1693794e362119ebed9ae3e06b7511cc37fd2d4f987c395096e56e7380f18f32560e8c3e0dd0fa93d17637eea7eb8b4f6eb40775c11e6b2c0e47537696874073b508d0a6d89611b9617d33cfe8713896db186e549405128c00bc840366c7cb0e8442971a6aa18bd4380bf7a2ae41b3071110a22bef8da12c87ab941c9d4d261207d43d7e9c496de855e067bef9f8c01cbaffbbef10b9678cb996048266d24b3130c310055ee55925bf4055c99bf622672c650c5cd511a2e5cab5034b346eb27a747460d7c589e700faaab3d1bed3d60a4c8dbdb158ac8f722ef8cdccd83a1004129514cc883302604375b7607ed1e116f8388e359531acfb7d7b7fed6fa86901d3df1b268150318dc93b44648beb4bf36f09392191cbf9ef38d363191890645bbe0b7ea17c134eb01a1602c0b1775e811820fe28d6e619445b04934ae104d292a88293fd548a0bdbbc8315a391d2f26d8d41b154e7b518d5d1bf88b09533e5e147fe283b40d188c15edadbd6c38cc90f4b2b43e60e8e3b8b32ea33cb836ee02709fda41f7d5f5269f5e4480077bda44575bb782763ee5b87fe1da94a5daf4582a2e75f9592dafb5b3cc9322e44964ba78b2c2f924bd81a1ef63b456b7228b5c0a35383f955bae4480634551a3901089d515bc023a2ef9cc9e89411f62fdca21d58479497c34278d5a1616f7c377487f26388a178c2018f3f2adcc888020f6ca930b38a70a3d1f57abcb49811cfa20acf5e730c4cb1a6f57e1860e6eb5285b45dd8ca924e52f09615110bfbea75db65372405d8920f4c01596858bd2cd47ba0740603289e7ef4ba5ad6ad16483b95038fb786553b15dcf2d91df7f3353e6fcc324ccfe74b77e879f379b01b4df8995caf7412a64254c17a0856da55972351c9785f6216f82625f2594a5e9545d7747df2c7ffc14f71dc0e1e30a6c63f9caf63a4045b0b316801043bf12bc9ec402efcc3f0c44d8cdec4f6e12fa19107a6c65496dc41c6e9c9bb1ce0ec00371918f46b44ce6cbf8ce80e12693466cb8457faa3f923bf0e123620b0d1c5e0b978c105f5aa2c22f5b2df86d9e5895836e8cc7b3e97a7379acdc5109d4d361a7e8412d73b1f3f3a257a5948d42920658905da68818e7b89e91bb5eb5d6f5750f1eb5034e54dcb0a60e67a6ccdb502fdc0fa64729f554ff3ce1385adffb7d46ff8062a097f5259778b110d6ce99219ee2cb3502a65f07286584bcfe9d33bf97453f79a237988493aeeb18196680f6ec1b32e05ffb12bdef9d76a22a3c3426b5ef00a367d53d72d8c2ba1a16df2e252de0c9a717d931c14cac4e2ddff67ea9e6cf4406b8bbe7957c60012797b9550eac6b2f5c48d4e6fcdd0f0023e9a5a7e4481ecd21d377d7e1eee0f9ce97b78b81166c823450d8d238d29a281dc1a8bf0cc3dd95513dd27ef6c23c3be261c572f445588274fbbef0c67d27a8ea3fd31e2169063e315e725c8987732ad6034f80a608a53da20f8c9ab333f3dc725fc0e3d4025e71f110e59800fefca4493b5a884b96fd1dbc0063486350314dd529551be7e1d04c601edea943d224d7f433b2b9c2d90c408475fce1148705d282ecddd89c34f0177f91bf478f4137d70731b8b8f8d707ff9e4acf4c85927272f0eb67eb77ac87a3575f8a99461aa99ef9c88ce273f04b9fb8fa23b9b314e75d29e1b7468a1d7803ddea993d4fc4c5c007a87a2c591e88289b38123422349b6c9c22b1db64cc819be6c797c3c2b8bd5dff17fc1f612c4d275a4b803e230b01cd663e3fe59b7d1c7cd00c5784a4d860ee85762da7749f18f556f2e1c89844a9310f1323682cdb260aad95dbe99910cc539625d1de8c7bedb4ac2c343d3c8314e52d800a8e170a98b51be4b74eb9c8579242a7a27833d83d8cac1fdc50212846156dd940d496250b3441afd785d5bed3e2360979fa48d123b8923a46e4f5c48e14a4b13c7152502576493e92cce7068974753e68704636e6eaad8387b3c8914028113df1113a7080218b6c5957cd35257c4e18e4a1ec0cc8807c274b88a555504c309399a85387a994c60ad5b32a9f4c63767553e62bcf535672a6080d57b4d47b1e1ef5bef244daa9b14ee8c0e6eeee842d8d2e47b2dc3f00ec7fc7a59cf08d84f20c6b6b538f81860fe71bc1095283c2a4ae5a4e101c7a9bba967606d0acd63aed9e1beac77287db2d12ac3b0330e2766b01ccbb1020434c9792e527b99eb03a88a2a3c7275be40363e58d73fec54e1ff572b53f90dd6a7b3f0975cc94a2f613c8306dade5a6931d72eb50739a9a5688cbf95fdc5c664571324b51f98660dfb0f947e47ff8a1d14d476990035b7ed0ffc01a3cb6915a3d7fb67385f2508439ac381d826610d9a7ec25c7797f767aaefc9bb5ce35735b8bf533dc5f82997cb2af2b0948a866e9b0dff3bd183074565757507721e3cfa3dd558e2bc6935e77bdbc04c9716c3020e266151fe254431f693d2ce92cf79182b497acadf8db209a7f59d270e0008ec43bc4a67b44160ed3a0ab9d8ad25941b701da46562bfb068e3a075f3c70d8caa6d67d98c0606afc77dbf0fba8a016a2d614a0d06fa41f71827ce0fdb282cd80f3bc4a3e02d69227946f219585e9bbdf45d8c1fc7665fa5abe0316bd536240af41d0cda0a4fc8db961b727678762c45a11438bd26e6991325e384072cc694132a97247c79389af51d2bea76d93d229f63ae3739687a2762ad62e21d5e2f649a438a6c1460a85b1f079ff4ee6a8fe803cf0ddd9c4d0e60cf810140ac53ab6958c623f563ac314033943113a498663525e19d5459576bf4193ae282dc2e22f9830e69e2b54d3d90613b1524c6a68c7ba6eb81ae0455b02023d3aa09ba7d9548f409b57e0e7f2ad00e0254b51ece98fa26f9ea991f389de369914f58b0ffc61fdae1b0d91502e6380aa2df8b9663ee560dfcecdf797d15da480cd76c856334d55760b6633eb3f36c490f95ac35bf8479ebc12cceb2caef9bb0d732a7f07efe8c9b8a48cfe078046d0bf507b868d10b78ebb6b6013775d644bec6bc9317fb38dc4ac7e92f00976d3c8ca6e170599ce0207f4f475417691eedb5865c723b4c5cbb2b106104fbab89860c59c8273dbd4533b3101f5d5bd3b9e3eab48f3fb175d518622a778119f96a5032c1ec2f6f729416a8181ab29ab8a938632663f6c6592b76f6d0f14f83914330519a5012204a06d10c869bf613d724ea1a49aac51186ecb92f151b07019ceea9f56c829697976210f7d0054b83f7f435aa67ee72a82d0bfdcacf8b7e3da0e5050fbe5403404dfe98674d8b274d8e5a7eec0568c2c8a8f833481a3964698f83e5aaeeeaf9e8bc5369b5e03e50d4ca135a6c5c7916b5eac67f4bf90ff5ad8d78799aec46095076577c4ed97520341d2d8a0b49cba00af9afb1eb0b82b922ce36996d3caa3b2fcb0c9d83b57f9b6fb9b82b87cb10d75dee26497cc10c3e21788d149148be7c9178da3b57316a02b3af87facadbfb5939bb11830db8df6fcc8669fbf5e421037fce81c23039977febfcf84ae6a0f6db93b6e6e2581bc1657cd6469aea034891b159d77897c31e51ef91e021bf5646eed3ac5f4ba54500d558b2c8c300a5318ac03f500056a70fe5a95518664ec42477f41a40c3a1bdd13c42f2699012bb68b506f7717d0e0c7100daf38cc37ac2a575db344fb641404693e067b8855765924a878b851252b980d12cbe9f9fa3b5c514fd6fe31a67765298a11c976a4ac9f7ce1ea110124cb3fae7b27fc77e64a8b11021a37f34db77bed21619f34957de9482f6eada428b11f0aec854c0ed4d87982b1de60e99317a9fcdf9a22fc98d2cc8308059cb3ecf8759f733720aee1e9f33116f7092cf0003e497172099215a3793537ce8aa95fbe47056aadbec09777941b5759bb8e9e4132f3d9e700a3c9663c35aab423a2813df101876c936a89daf20154325b481fe259791c3e1355ec4a88f0c339ba23bf63260e0f2f217369300e90e9fb451955c2e09009ba1eaae532321d62414cf53e4a3fbef27e926745fa95740e774132ba5aef5c57798391b649ab0fb7d2ecc5df706f4f4a25abdfb6bc1d9d17b6a0db8ed3487a33bb459f9d82e18a594ab5b9471c5ebef308413fb30507ad954a2fddd6373403fcfcecb75f917fd64864f24706f8b9fbd825072485b5bb81abfb3f6501459bc3ab1b6786349cf109fa09407b14bb696c0ae0f36dedf038a8720ae1d17d72042a99f7dc1072e646710f931719983cd4ebb4ecfd8604a14f0f3e0101115e8b984cdf742c3954cec4de163631aaffb35135e823d25e1240b01b0d5f17f899c1d16e3b493593f6ffb33b8c23956a247c50474fa2a2340fde6a1b49a09e24066e7de2f10575f49403a3a87c6fe0386c0055288997d068e96c691c27855b5d6d1740f2a26167e8fe960f8cfefa9057a94ddb410664130f4f1b7f3e287c49e36a53dad164f47e601deb302f01792e8b59767cc356b40181a6b00ad00cf535740feb7911e11259b66b4e0c1d60e2b934393761371cade22cd146b9db3aee586796be05261e74b4909dd08815652d1ff83e5e7a18a3cc92f54be6f6178048bac7ba4c411466b8e1cf0414f82c16eaefbb486ae5456f79be018047bf59267174b7b7ddfb6df5450c663963ff9f472b290820b3165c66a12515cff7cf8ab5a2433e63c7040b195a179fe2761d90b7c4bdbe908ac007f7b4d67b73091040365edd643926641fd69a7b692564e471ff55b42d012b8f2e9bd7a572c561b7114a09fa8dac12482ce55b3a321e4419b8bfc0ebc08317d410625b0aeb258864b8512311cce4e083e22e4f661e7bf35fb9275edb58e84ef62ff71d8c353c1284a48de07b94869b6d0713e031fdac77ef24340f1b17158b8f7bf1b17bebbaafa0731abd71f2451facbc1552741bf7451899506df83cd459ded6df867715330331b8dde8237045dcc6d49be845fcae394a5c8369c1df484b6a437dbe22a7e718a265d333191dda34f5c51bcceef73ae37e68bb0dd371cae960b28ff646d9283e0990a05bf6d9d6be133e811b65ec74fb6f1188393ed66085996553d5d4c43b04e823b2767265e9e59527b7f9fad3aa08b089429f556cc67991b5aa426085d8122873c0ade33fdc1689bc285f0da55d2c06bda254b88d64454bffb500e77559ce309ff8770d8de7c5949b14623ee954eb5121562573daf4c54347d6cad46c746859ed527c64b42154de789099a7617a711aa55c7a3e4fb8dc48ad3980dd6632a2c7265e75842481fc6f70690161d401da2e0ad38b635aae650f25482f95d5bf656ec4ad95dcb56a8740b34a80bf16b222419063d5922333d16fe6ceea2a3f0693a0fbe4848ef485bf1577d72b20cff1455be27e5a380543611860cab6f62e4d1ea96ed58e6654ec11ae27ee52fae24214228f6e0372249532e773e1023502010fed5891c6d2e64adfae93988ded0f67399c4783eaf01b8a61b2a3eb23e8de74bb7f1d8f965a6a478e01c3a6cabfce4eb48458469715c6eb8df49566fa7747c2e4f81b173b72be982eecdde388854df12059bca9d8288f3622228f575d56c8b56e854dd1a9813c400763409c9e07befbf3878fe653d734a8582c819622580e17b87c93d78873b723bcf32cad8ab523f3271e103e25f21cacd3bc223d3f3f7e113d642daf643e1b36d2100591aab44db2547dae324c1920a959c56ba3090bf4f8bbccb55b0fc467143f839c15055deafe291eb947c63afae2418eb9328f717213db4a1165ecb223fead2908c3e898330be1be3576f7b5c4c70c7b755e759665e188aa306aca06b302ceae222d35ffed532e19289c488a339e2a361f8bcaf7e1d4c8f3ff9c5a8b2e257fb2a1a05326a6433505598b1f779d1a4b0c1b3b343147de1bee936dc43c20ac77c9a1d851fa230ce06c410bcb5d33eb3d47a8ef22f80fffed2b01499da1a1761fc2bc73bf239ffa0696a516d554b9947f4c53644b3fcf49698c6ff951852cd9cb20984501eecc8a81e22fdeade658bf60620b0abd74767d8fe8bd625e564b032a0cad8214000cdb516090efa651a4bcbd4414b68f7d9e627c50381bd4fc62ff34d08d91ddb3e1732ab056d3bc3b921c24bc3f01f515e6370a42cdb9131b674457f4f1b4b380fc2d577eab793cef69f7f6b8d78d413c70f82a7bcd79141bf4dda1b5cd2eb0ccdb32c4c9599cd586f0ca8455f85352f1eb847c542319cbfdefade4010542c5249bf5ee56a971aab85005664f71766435751b58e000d53bc7ed5126506e2835496d871dc1565ba95869fef2451cd4621de5e42a45eb280f8214272e22670954c08328b87677dc9c774e029a9e88a48c90e34d4a0bbe248c4dbeb645b4958c834409192426ae76d0016b48a53a2b7e0bc0ff28b5682db9ffea5d47220fe81a81eeb095c8533b63cbcdc822546c2f1810d0c7cfa728f0dfca74b927f05d7ab9d57faa04670632dc61af501743152a020e568f63171c90b8ed98e4c10bf6b26f5feef1a0a894dca1faf0ede653d78f2cef1dd40224c2045e98126ef3430e7739abf5a86b7b257bd45744945596f0c7bf5c42e99e27ef9ee25ee751f90db597217be3f44b2a802dc064b49bb8a8eca8eaf9716a7f2dd79ade86bb32702122bf7e09f5ddd4aa1a38b8027433d833c77954224569761fa6809aac3f600a60a650d3cca9e8c565ed6d0a07df39e27f93111f74947cfeba8a6cbdd876d28fc413e74aa6d1867c8405c817e63759210ea556d836e9f66d522c88f080c612631fbfa3d042f8e10f1aba78c87251d0874b7aa1f3268c3fccc736fc2ae1af0d4bf8aad31e3ca90e6fad211b0aaa2948313c36e4b9ac480730c711e38148bb034a55e20dc2fae92dfde45e6afe57ffaff0626f4b60bed7aee415feb0e304f2c64083b3ab5807ea7ab01d5de4542cbd2480d045b38e2ef291ad12646d23807f65de75b1482d28e497ae5d4e256352af4e7743830191f189d065f491c46ac492beec16a192a0ff63838500d81815df03c73f921079cc59e94d737640cb5c1bd7e536222653f38f26258f6c97f36687dc8f39a9203edd0df432c999d736fa6a279c99848878fb3d425650eebe87fe560b8639df67878e4a428bb989e3a5cb67fc112face41228c588546a9910f41495f4cae1c20d4c72a00e86c107cebbb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
