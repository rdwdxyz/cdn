<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9de0ae582e7244035637f6a6d9017c1c8d5bf20400ebdddcde12fa7cc66323753b29d179b0bbbea6aee3085bed43fd4de0a39e75f1fbe5cb762256226467e4736c3796596efd30f5d45f4771bd3dfa0c81d90cffc0e1a5668a5966456abb835cd36ae6cb8581d6620cd0e4b79182d9e20109eca12270ce8fa6f2949a0fa1cf1ede2ead36de3874c2a9893923fbe34e734bd14f5dc5a7d3f644c723c0f02ba6cfa3b409371f3fd5cb14709339dd83244237c3fd011eb17264046361502d697ba2b56a6adb1b774c357075e83f055dc8c5b24d022570bdf42350f6ae955eb0b8714e07ec447d5a11c2640ad56881318fef7f956e7eac052ff58983771ae7f6fb0cdb57d1c1fea97211a2165878fc021171fc63a30fa0d5d90da10f4328a3fa5a7d40c93fcd92f77cbc258b23b815def73b9b8a36217bdcc808668f451b2b59cab7b5621f85e3f5adad91858f2d7c2d0c528c84ce785764c5493e52406d2c7f1a69a12b952adb68f838a584ef09fbc7cb4a715fce7b27ecaa73c56de1fedf71f11c2ddf27d2532514d4d6b57363a868a6c7c6464371d811c6bfdb4b94d08debdae82d22e462cb322bb3ec0a410780084d55cad1c485b2b9a0db4ede85ec8cf3a31e86bda2dcdf945d78a433c2b2e380c0066ef5288a6a4884d317192f93832991004206aa9b436cef7c6847f1f7ffe0d974d1380c7063b7fdb3a77c2c3faa831bd8ae83bf6c72abfdf61a8769e3cf52ff6ca9c95e1e8467b0e656274711da0e54c28bd0ca282afb2a7a8224b664055a581a49321ea8ed566fdd974175e945f05c4c7c410bf7550cd8370755d148a136f027ec9fc3ef96a5282f2cb2be0e4c0ccb0d37c09b9ef28727b1e11377dbc042a39ac8b3d27b28f8c0c305290e4b0b959061f102d218ba4e3a57e22c68ed6464c75cae884e10ba9f6801204012232bd7958e92a3e8a7df5241f9a48cf877e3eccbe8e50195ba5042746ddbd0c05cd082c3ef79975531199b88119686ad218f375366ec85dff126719450eb87685285929e03f9fcc00e2e42f29e5721459151b163f7c76c67eafbd631552c5b8652b2b9943c8a030f253e12b3d433230f125917c81d6d1fb886002ad8c8a35f20bdc938958e065d8ff774cc5343eb82a4e3f751552a5c7aab3be5a4c86e38d6cde5b8970ab6b4f59ce2123a11f29e07d34edcf570390ed29ecf7a48d1cd1f937216506ee4466dc95cd8228b60d24bf04b6dc6a2ccfd6d1ea1a3ef2ae47942dd4ddff047cd5f6ec4c5b67383d37bb6aa510717ab777437e8514b9e31602ae2655022470fb0da62bf151209aff9537a1b0f42dcd621559e2dbcd4bd203a41251618525c32d8b4d23a6086b0e26f336837a7781bc8d1622bc74f702ea693e85db115e66a09911f15162a81efe94bf8c32e6043cacf67fdb60532e798b23bffb92572d33982255a87b44f959039298e1cef21cae1f8442ab2495e4e0f893a3493692b54bad4a16c3342e91643c188612db9f8b4d57c27a009f28465d1e18ac1200307ab25564ea73bee785f65f960ac77a2b1c2651fd106dc3582d5773484585931ca690b1210be0d66d745fcf255cddf227f372027aab7d32c238e3903f0b7924873bfb5d58cf85e717d2cec15fe0acf403a545fd23c215aea9bcdcbe1a2b5cb0b7ca62674596cd6f969b01ad3ccf887c435b4c33110d00dbdad6c216896a7edcc7249e51eceb0d96c2f53f048c89e470fb61bfce9a366ab31fe570d915d7f7474ef3c3b221b6f8769d12b4a264239ad2daba3a3acc667494d720a3fcd20dd435f8faf3445513569f428adf8597e733de674af12c8abdf03dc150e1ee5a0e060377eb846517eae16f6baccff90a041549befe1ca7cc2d7e089476fe0dc99fc6b970f7468d1e468f98f8d8fd6b1c1d615671a49461eb0e4b424b8489b5c738e45db5409d546e6677c8f75f9339195a92cf2a1997803b9612ab6ce1131cdf52ab9466259c3865a985e95673d903928e9cb460c43710aaa9e9bf02f54d9094c341162c2df55f7347c546bbb4e9c1ef18a625f2693eb1e6f305f30fe202e9e00798ad591084236b5988cbc52f78050223f79c0bd19e86d2f2a4c5829e51b439b5d2be3dc88eeadc10722e85aaf28f9c53980c687b0cf8dfc1141ac813f075a9844d5d2aae090928962e7ef9ee7a5e8d0ad397741186921ebae36482852dadc4ec12f73f9e62bb8d218a781e67f765da7f88d2c3e3ae811b824b99c2ee9360e0a49928c795be78314ecbedcaad3fb86b22a685eb43ddad6fe178fdfdd439c82f23363182c16dda1871fc4f0c0b33c9ed300f254963e247b9088e0bfb0543ffd5a847b6aea0c6d09275eae25316f98f74ad005092af900fd251713db1c6903fc1d3a5cfc33c424b46f90e723ebf0274a3c98a0bdb3962492879928341ad6c396d2d1be3fb4ccca468ac2c7fbb47b101eb74ef762dc96cb754fc885b1ec930fabc8564344499535d170035c777717352720ccfc1277c39a0c6d7ce5d67cf61bb46a6b848c731616ad86146382dc177102526614006ed2a4bbe4f5c4cd180b008c15214ff4181bbab31b48aae4e7d65b778c42946a6667395025673775e2153ff9e04b69c1f504b4b633957c4cd189990fe20bbba9cf75759e4d22d004beffab0720089d53ee202f41b46308851cac5dae8c223251a6a3360afce9357e8c37e9bda133eafe8f41e478c319c05fb9586b83bc1df3f43785106dfec814b79791de100c814f515dc078fe6583b4a5599da5a1711bbf831ea19b46052edb654b4ac7fb59d3ee1a9b19c1dfdfc0b47de7c677a077ab0a1542a113fb41e9aa7d66826d14e1274e20a10ee9ac53b7326b2e59da8f4185182b63c0798fa0f59e0fe3343b28aea36a38f2594d4ce44dff5a1964d18c2727d10b64adc53cba0629a712d763b3858ab6ba4692950e6593ed6c533713292fc828d134978b89d2861733fbafe993d954f7ca2357f287a4c1e8908215cd8dff3e2ba99f61f1607b3803980520999bd63f5e6c560faa43bc1d01101598c86f2d25d8b8e1daac5e64f0bfc1c7399ec2d1ca86adafd9063a179d326c2ce051705fdf891f7464709fd1843fb55621d8586f97fb29ad98e9fea065945304766ce49e458657546cebd74c9b138d03854d6762c3cfe35bd85042bd0687fdd8fc2ab14ce3c82239e1b15da1521edd180885ae64be394de5e13892e615da227ac89676490af82903d1f646b03f0ae288c096b15697908a924768a77cf0144a841ebd961e7fb3e66154d3601d37ec6ed58df3608e0d7bf69367b009cbf647c7c126a22d067c66cf59e8d672b538f35e25388f321adced0e8ae4caebda8291874ce01d9f46654fa0dbfa290cae708b99741ac416556600eb911dea584fa03f6be4fcd6af1ba51129325f5ad8724090446300abd22c8c5f455ff46a132b0d7fb49b8dc66162e0908033aac4dd0bd967191f4bdc017623f785175a2f049c13627af5b7cdd76ce9b0579b4cee34d1104294a5c57aeff872002f42514d11df3a74c2a6a70ea972b713956ce1a7d9c524f21293fb6fa423780e82971db79accf769e14fbab3854472fa9e9324967e37af8642089eedbcd0352b395e9f642f7993567887d3e3ae05e42e6fa21a089042cc2ff52de9f95d119ced6b8c73333f0b2e179e16c4ab5895fac053645ac5df915df13a84c4e7ccd17d33ba6534497c77c384e568bf43a6f7bbfc3d437cff1cc53aba84d6007936eaca621792bdebad63362b9de2c0814c7380f38c997a57362bfde02e38e36d661a26ccb65947c518532728571fd9fbb285fdd1c28df8c0aa9a4eeffb6263ade4784e83ab54188203d3e73abf44b1b7b7bebbe93156e2a4be1cc7fa2822e86d4202fd86f8e14f541127a55eebf42834a63d1e09bcbc9d86caa7808ef3869795de4dd10b02c7a6f7b653004a7f75e8f980ec51ac06dd728d78daf9e93b7048bbc3fd1e38b2f2fcc79a5465bbe82f061f634b9658f714649e890d2b34ff69fcd342e7eb86b451308fae9e3509120588ea238ece4cfbbac6ec49839b6d1dd85c2afa4c053a6cd77dd1a4f959460a13df76ccfbef3395a05063c5ad54149d392f733caf4bef63190d993e3121cea9a03a3fbf9b7b79528d786962fde458f4525a5231aecf0fa71ae434b0c3a63defa11838d26950413f00d0fe34aa2160f5388a5ec60e207ae6498cd6f19b9ea6978860b191b9809a0459cbe1bae119c64dea3dc5cc9dd9967dc3e2f6b99a15118cda2353b19684b00afdc53b73d27f830dd670f8e881a5acf98b97773f2f1e980686c96d2fef19cfc8affaa7f93bbbea2995d26b042250cc0d10ae136a50d368513edff00b934049bb726c34176b40fdf7b197e4e77836e607cc4109ea28702b342b32102785b0af71d9a5bae492a423c442c9531d8180b07db9fd10f51d80a9c9bbbf40f0fa71dd57625be02ecbca65bb5ab0f8005e5e989596709ebbdc91d1c10a4f080f94798be0ea624ca82e45d646d8919f118cef26b5d3a86a2fa26424b133c8d6b9fb8e4356cca563afec4b78edae843f2292d5d64f3b07f6dadc9205ab825fd5f4270abd9a1fde0e2b8b426d252bbd2abbf709b7c1e896aa3e0c37c0e71fb4d9958829c66d53cfd6adc07f0f0701d0d0cb5f8fa9336ef58882941fd6703d7235a219eef821ea105ff77824189270d0d254768bfeddef43944a13bc4a2c1a79cacdab15b8255d7f347bdd6a72cba1046c46c150b3bf92afbb1324be51c8837f8aec86f3130b5cb9f659891489cacee5982fd5ecefb39afb3f78d3b59d847e6465ce12009a14b202dbd86450ea033dc51c8207507ca8b48f4d42dc019cd32f48783f8db7b4eb738e2905cd7623cf99a201136f8efbcd2c3bc7da626dcb72466e7537bc564f3b647ce4ac81e80675a8a0498940da9e90cde6b1eb4a7f62b514f1eb89a6dde2581397e50b0b701d06ddeefce005d676571135050cbdc4b79707304f894ddf79be657d0786350cadd1ea778b479258c7462935d9123d1b42f44b6f7f9c25c24e30bd6a39826f5d3bc7906cba9f5d95624b068913f51ebb1b806ecc5413ea0ac5d47b6962eb1520fd57dda19937fc4bdb03b906aa6d1357483476dde768f77c44c81e529dbe1488eb96bba4bd6457e04e0c2271c55c645e298399686bf7c9d5828c491f8a16d434b77f8a4a81899d3b25b22206574ff3647f21951ff71c062e3b0e3f859a8ae554aa5356102497aa86b9836140cd7f209df3d9d2629ec269ff5de6bbf60b19399f22fa7198fe21a0971f16158beccaa269f50150ad4464f3067695b48c051dadda232b20537486af78fb590dfe8aeed5af0f9f3e4b73d905eca0ad86210bfc4112ecbd8a9c52c08f376d23b0d2e67756d6e654c00efdeb79ff8506951da5b17395f9ddd26a4d47025c6d63a1edfa2b53467af8fea957a015e572b638c0336e902a775a13c46864c0aeee0029ade59bbc0b097a701389ebed1f22bf6c0c0e29d2f6b0b3ececc278d5518949140f40a3583656ff90238ea8b06c9f77e3adebeae0adbacfe1a1483d17defc6f91dcaeae7ac187eee9535db9b05579f0c4fdca0f168413759c68869edac799ff89467ff1ff5eaddd4fca2499351aaf29f374d6349f7401c212fde4d95a1737eb1c8f6ea1fe3d7f700baa75daee55b52e9f023a42042fbf95670dea891e327d79405cafef9b48b235aaee79ada3907584eb77e7922835504fe09e1ab636197ac377a4029db60c8157b52a1f390fe098da5817fa0bfb74e182ee4eaac0782334e733e0acd23c1022c1907a64761b06f92b51b66ece353d5249686ade5a2b73bdc4b76a418ed498170b864c9b07d3c4addb671cb0728b2d31478bcbe3f404e57e488ade1e6fe9bfaa7148860c12f891180e487e8153c537d0b33b70b3003d6434beb8651df8ab22f2496032b0dd85b36b0819902bd929071d23f220ef2f96ff64b35af03004b6ded466c93cb892becfda69ffe05458528eb698752b4d6a63f3cd91de0e336a314fa66a5122c152fa1364c0ac9d0729e99f85c53593e4ea0ba325ebe1883c3945a08dda65dafed4ca576fcceb8de212054ede003127a3da0a029c7c106136faeb83566f2656535572cec7aee2e61a6cfa390d0eca8cbf42e28057be9677ca9805f4f7d3e945fb57ad28e9ef243ba1f6184769b3058ca23c0e48a8d42d35b0e879aaa277b293a37f6449875fda19f511fd23279bb24343400ed4dea880c74bec81c11215359075c1ce5029a3bc9328099e27631d1655b107ad7205ddb86c0e1cecdde2bff7ab01bd3d95fbdc7526bd5723fcb524d1f23e796766a457f56f72daf38b6e49cf052f2ff84542b03ce2ecce79c39ca74de4c8ca144b6cf6cbf60e1ec135bb2ec9c2d5639630cf81c4c78b0085a79c09fd6c6f2c669b21ba669bb7c7bea9f38f61a1a2f0f2557820e4e587673c6efb0f7ee4b9a3af0ac31ccb6a74f9ee4fb176466b270f5782c88fb1ace40899adfdb57885d3398e3551d062e1069dffaf6d981a7d53796e7ab6d4ae9830c174f97996be114b9af845fa7b40c26491ca152e04af8235e4fe4384764179a648e58fdb72140752bb6f088870b6ff29b155d15e8e70cc4e36e39ead8ab942f58ac6ad14ccacae4f61669f0850035a23cda957ec513d291968471b5d3133390c69165baab4a9e3406c2da273267162c631deaf9f5e5039d1b24bf8ab25e8e13386e29211d6b7c5ef3e8f6e1012e5114533b2fb87660a8de98fc715c9db73f126177eb1b0bd7198d0f232cc276f805b7b735d5623c65541763f3934c5ed3d84b6335c0df9d95f1826a9777f43948e32b4bc85c2dc78b8f59f1aacb0cda6ad08c89045f2ddc6ad7ef9c9ec9b2fe0fc647027e4fd32bdeebbc0fc613db0f2f1503ae040831359a5830628f4071e7ac73e02998f3147e0e9a7e7b55f89125c019744d6fa8774914713157a102ef176a0d2756b9e1e4c0d4d3d3ea51a94f468bca2dbf978c2f009901635d515386fa94636d51ae82c7d67bbe6ffa1f12cd33f05d3333b93cf89eda207732abdeecb4cbcf22bd183efbcd43b7d66fa12e1124e0bc72fc3c40407073c62953483bfb8ff97c47e40ef00294ba98f53e982e53c77414247f49400c45bdcf2635efd6995d594ff1cd28a2aa5627a6c68be69fd89637c337c1aa90cd9542757bf694c42ea46c7a654c32fe718957da2ef885c6c4ca73ec5c0dc150da31bcc52a71bf188a0536b9d5c859bb609f317e900181fca28a1c7938a4fc3550e7b8f3e42e85803789f2b1129ad7e9e3a545b3ddc9b0c6ca36371cf76f0c32a1a68c8c94dc246e0f57ac202007a77af5a97207046ea1a42d229410b5196766ee683e6e264af6148e3563f1a76b84b141300c5739f0e0f19e971756e9fd0f5804eba9d651736ac856ef003869e2f17d8adfb6b55a1c1e021d67e9de3b28cf9f1cd7875b956ea6c5644bdf73f82bdb8e77fa4715a8b4812ba857b9aa684ed9de2bdc7bb3596befb5de849a4fab84d7804724325e64e7b6a6e2cc1472b96fce0925e50d1f38a5cc86cb0d9ace5af8845532158c5f8cb1040e61f27d1fc86f007dc660c6892e67bd62f57b5b5d3b18aa8fad1a9a73c2be729a7117040e2e8629691aff5991719c29b143f447a8522714b8a23a62fe277912eb02aba9872427c4275073be04b2af93c5d472c67d3b6d0bc8a11059384e1c545ac482b3fc376f26c32ad12798e8cb9ffcca1371ae573b7dd2496b4239583303e5bb01f0c7aa6caf714e87306e12477c08eb9e3ec7b31b8721165c1ad41c4bf490dd732a8e6199fc1e48bba6538941ca2d5c210d6bc69201d88b8d248a0357a1cea6a3378c9bb50880ad09c617f7e5dcb4f014c50c69f9041761e7475d149f19a19968ff7eeab3154012635189427b45df287eabac6d1dc6d78de8279cace6c7bb1139fe60a1a54986b3e17cc1730e37e355d92b07417855b5bd4ba2a130743f1297bfa862aecb8a93b58610505dd6582f15a547aa51c81fc7cec9938e0bc61307ec98355560619078e2d0838978e1efb5c29d6a63906d39c372e67b38476caaaeb9d5a89f8804d1fd6e047d92c75036a8790b04f685fa8656123fda0ca391a4165ea7b46926256364da832989631c1d3dbe5a804aeb1a0df576ef1a1052bc4be8cdccbdbee99d489cf129efc1e1884bd0b3be793b8c642e7e350293af427374e895976779ed0fbe0778e1f44cb4165a0a33618db51b3d3b7b0c64da434228f4457d679511f4cb5c99c0dfd3e693bc8b17c16030948861cc37a5019045517fcca314bdd94448cccd9bb88e48be170f03a1fa3314f4f0f3866a514a6dd36f68932d1f64aefb6b866db004c5e9012d0152c24dccc940c110620443014ed71a1d89e1b00f7a2bf44be67d1be2459b40cd5361b55c48da0bc52d5eafbb45e5eeba9d0389a1b00732145568b0330c2d003d36435387fa204eb16f583808166438e0041fce8f162db95314e3597b89bafe9d20910ef9d1b8ded53bb3b39e2d20c9ac71097162572a6d07cfdbb4c53e43d16ed9f267ef5be1b5e7bfa9b3defe80d1fab6cf1ef5cc4b7a220c53c8b849c64740a0dd44edfd94bee1e40752de361eafc302f063df53461472220ff61db84231bba47c4025238525d58b70cab7e51b3a4fcc095b7b29fb784e902aa2cd29318e9abfb7d697f84bce70de62d7b14ae4870cf1f88d1bfe4f51f857ceb968e2fd4005492a94bda58ce009d8257559a9fecaca8b93596c761ad740c6f178a44b6916eb5019cd4282d9ba081c4b7690f4f5cbaa236fd06fd1617b6bd302beeaf43dba58e30ed43cd26b2c6c996f48d073d3ef7f9d5b768882f47b51f75b280445c5a1db10f8c8600eaf5da8c82fa121079cbb2437f6426af20950e65fbecc6d218428b4d038a8d4792c32ac858216c1db2f8839f507bc0d11b223438cd416940702ffbb4be80a916ed264bf680d04bbce8592f129480d4929d79662aa27b55b2ead903d7e08b4e67295dd2121d4d67e5a404debe14d9e41280249af7cb9b5fd76d18c76abc1dc9acfda45f41c9f6dbcb1b635acf07318bbca285455f9f6af574b4d2b3685cfd5a35634c40ac1f7293a3316cb93488ef3b76a7d92e194e179dd0b27f3ac5671ee413dea9c4cb7e8123327a8589046abb723ca0f08f87c4eba452649439d1770c7b3331a042da552b439b992fa9c05b06cc06468a6562ee017d5ce6109d9f41124fb281cbb14908255832826fca1020d1cbb4e9e930998aa0ad950f3815fa8cebb46701903080bf4ca0ca110764cad19ed7763d63ddf928d4febc9f124748464b43a32b0a9d40c188017cc6872794cc392fba8cca95a39eee474ce8d303fbd4016a9403901f660685fe081656f6e81b0c2942a5c197381176f2c47d5fb1791cb26b729aa72773fc71dc3f98a2b80bcd2e16c534e1c93e3a2179185e0101a754af389bc775648967df027d774c494375e11060be7e644d31fd87c08a66714144e8173eb8eb39b6f7bb43c85736f438f7966daa84c425a086f24677ccb42f1b9e15f6cc47c4d6e92d44bd45597c9c178f4aa65168abe2d7df8a5f37b6113c6cdc96a1af0cebc87ee99fafaef28d43609240a7425a4a92c2eee98e107a12a63e92a87f1f99dd8e71442edcab14b9ea4c36a2d652f7615a111351e076d771de6ff680c56e2eea5ce428343d156b08ea8460104257dfadb2eab8af17005847df42796782421b1de829e4eb59ba139678958d3a891697ea89fa6fd61d122839b0ed2ab9e4dc936970df5ec05e50f732367dbe087f6e4811ff0de28e3e2f524ec488d73c94f0528b41b29564aec872149a3bf450ad3509ca525e273136959ce1a7ccc3d4af357da78878f6cac74cdd0971e1ae239a8545a4f82f5c471c9a9b6685807e7ad2ecacf4761299ff0c1c9a2c9f0ee515e9b2ca0b05b71f619ba1ec546a86d4a422e3a03619dc2fa8204174db215a8ad892da963b47785ad77d602c81356734f55c7a4fec70b4a6c6394da3e27bbe32ad23af5869733a0ac9a86871f9118e568696a9b475cb76cef5c3c40786ea6f6551f3881644e3f65da50f1fb6319529c09afebf08c16b42feb038745c67edb983c2f18b2b0854502940e83c3b5d1a29dcbd521eec7de86bb333e82ff51c9336d839788f06794391d9cb3b4ae257790f4506a5d176553171387bd9a6d3fb03a4129f3d07ea6514828249d716de3df03928982188bb84703ca87cd3cea3b2e79ebd6104f92a61092de6135fdaa7ea5d9617e0a879c2548aec38e41792c6fd8cebcf18d2de0dd4f80bf36aa8e4b5489609d6e014f2b0a27e520524864144dbe7bc76adce704f8ee62fc68ede519e2717834f8d8ebd073aad64edcbeeee43fc7b3ef92940ea4b5d2c4f4d7c535fa2b182e5388d290beb6d05b5bdabf58edc117302371265466db7fefcc4e4283d364716bf0c209d6ca9000c08b79945d6be7a156bf98f6f53e67e46b7333ffd8f69a03261c7a00cfd0e0f311051763f5ff49da7d2aa76fc8c97a3b8c2f43bc6dd98c74a6d278575e0456d174fabc83d0cfbafb1b45082d839aabb75871fbd3eb17b454c45792488dd545fc84b415822c3ba416c99166786023bfc4ff8158c5afe0adc3d9556474d65b02404ecf53ac1ec963a7a9a36e4ee5a61121ecb2d56158f90e8a2304b6a5d062d09bf80b78f0695438faba7809c5129c89d30555399ca8f3dd0acaa66482ecdf73ef9768c56126db8365416e0b3ffac9e148c3627d1c7d985a6251a6ccaf2e5b9ef8afc18019cc70f4cc657033a637b81f47a9df23d170be996cbe677880ff207cabf0baf077ea5dadebb34e2dba0cb5b0403edf1fdd40557e2e80c19bd280b62d865703c12e473af6a642524d7d20cd69e1a9750474cf6d438467123242a6a1956cea6d9476db7eb815a8a3fbcf6bcd132920ec25db8cdf8846b524e33d36f0f9aaa82e1104734086af7cebf17286611bd3d9e124b9107b2dfc7cb10b8075c65bc3b621967de1ca7eeb1d02fed9bb90f39277d6a44d3b96d580b8bbccdf0ff4efaf7727d2c5e4dfabb66c88190f9bba3b76e400c7057c3882a40a15ec403083f6e96e049a9f321981c89f3fbdcbd5bc1582fecfedcf99570df1f175def38c5f8db93eae0341ca7208b307c2bf0f40e2369e3158774cee553a70c6c362e99f14e36b594cf2eddc79f955377dc8e2d0f65c8e42f0f52c9d88c54320ca7e24732af44751097cb79192381df914bda45355a878cee376b1c913121402193784282a9f83887bd3692d4fa9565b9ad696abd011e35a6b03a55f916e9e9fe911c55680a8244813f81a50aa9e8cc8f34ff0c45e3663d7717432582d956d19dfdebca87085f7699c3b8bafb4928bb65f9410d7cdb0dad87c594f6890689f076a959ecc8cd585074e426f3c38db8a5f3c0aeeecd3d623dd5b8d4e49c52cb7d658f2cc4eb56b76089f654ff176e4c52b53f4c98ffd6dd7cc3ed3bd47c1687700bc455023d7df48a2e58bfb792bb6e69d6724183af6c9812d9cd11a7e1f11f744d8ac7e5082801a19318b1bfc60d62a5115bb360aa3ea43c007c6da404836908e316dda2dce48d33bca4e70177276838f192ad03e167aa02b1f25b6d185a2f023852357e478c6c4b427ecbab06e47fd99760a03a66a463976876fecf0a22462f1c3e9c05e5264f49a78640c9d925ca0f52781156488e0700ee2cb5d92640b60aa7ba10c10e5be7ec60dc06a5ae2551dec62a81e18054d6cf08239223a9926ddb6b98ca10bb13b41acd5728279c42c3c5952af3586e4539b2bf518cee29e3554a410ef4615535b9fec90f02c60aa396109ac9fde1b59f2ba4732e8b1097eb71aab14a39de5cec306c81909ecdce486b65a60d58feff98bbbaa0b7f92bb3dd32033e86fd46a45eb2fc0b918da00945ab4a982508e71da683e423e1ff51856a2e3de656cdd134ecff19b3931097f3c6d20fc7c9fb66a11e8ee830e9100877626faa5359e41751ee8d270d59423d4c95e1afde444a1922e0421e68aaeaec78059a213e2f9884edc1e18cde578905497a81e0df36562890391714658a8375059d7907c9c6b13538e4895e91408b419034ab22ec4a902907a7081613c4afbacca14b04fc699c99d1c14dc8ae2623066265639da7b827c2e075ddf24a7dab0881f415ed9dac25e2008cb3b6a5355a3e516ab913be8a71f5a642ec54e92218917e121b482bf54a9a8172807d158e3648d8b150bef2a6094ab05ab342560516057cb017141646a1281715755e8cfec0e74c5c670c19798f1b0b760c6a10dcc419f2df8fedf1a807c1d7dc1d195381cc06e9080221348db0cab62fe2c79494d009b841059e6e221a29c0f7f6bc8f0c94698299af8d3bd3b5c3e74fb82f3fee3db1281fc954aad7167a377b6e2f1a3a11c26c85d7a738ac9c18aa856e9b562ff0a597c07ad621d777967b8c0769f98f1133a24d4bef2c238c8cf6614bb9fe92671d69e18bb3d04b7bad712220ff45cce251caa3581e8adf6aa4f1ad0b88f79a5c88a6d50c1fca74b193fe54b2630ef85ea28bd6d7063c3b3c95bb4062cd07f58392ff1d669c13ee6b2a73f4634cd8127e9ead6fe30205a0322ea492bfd760f3f6c05f1d1795001c73e7e292545a49da055f691c20e5e3ed074809f1a25f4eeda3dd537e9cf7a9d4b13d1ad0b56b16b60ebeee0d384c53c06dcfdecde7f7b5e1c337747ac1fd3ac1a1dd8112ab4362bfd6e83d5d9ce24e7e9603c504c0d1b8f4dd7422af17077251a22af82ce5423b7052e736418a2bd2aa6ab15ccc59c0b2f734fc65a6975c30ee9ca39634ac17b509d052c43e9a1609b2511f03bbce3e59a7b8e7a1d88b7a7848a0e3ce2ffbdb7d8a3396ce37dfc8f80edc1be9cd9531db8431f3e5699e809cb0b1a476671d37a5072adf826ae1fc7abb0319aa53a0ec6d4c0e6c13186226145c879fe89491a7036492bd70563cd2597265f3093c32ed9fcfcaa6aa4611471a1d427cd1beea70a36b4fcf6dd563a0cc102a85e78af53a308cdd4772759bce7c727011bd8d1f17b308031c452278cee961021068826fa432b1ba6612fad96d52768397a994b94f1329e64afe7e99f8a9f47cd7084d1a5dc211de3e41e402c8d72c372ef85502ab7959f7d23c79b680afc2273b1911c198498cd685f5b788597dd7c13906ad89c579889de17eae43bc428159acda69c22e74870a33908594ee7b686fff97260130b23ebf66ab351a288a2e75c66359e2ac3a3e7fd8588920343b48be14d6045e246823ee39eae0ee90cf78ac833a50e570caca70ac0efa0b73c05b73925e4bcc9d6379e6151f9bb271bf8501b56d60aa62b06fd689060de46f933a73fd7c274657633aeef3108c9e19095b2cdb978e18f1eb0cb075f54cddf047e8c4cd69ffd8733adbe37855038bdda9aa3eba0dc8f99880597219ff99306ab8312f2a583e0f41aa946c8df65aad72e6532e768fbaa641a11c1a923a3e28b231b9de6238f9e6a34cfc145de5c2a40945abcec3c28d9e8a19dae1103b40547f87fcdef5bc8c2ca321361d1c815126eb78e7817e587dcfd7a520cf0e51b14459563bec808a7cadae99b6ded1452cb32143467539f53ee30fa946b34357e8e156f02a4c875ed29df6330e2b9bd8cb373db5da1109371712e38515cb65ed2103e54f115128596d89a5149f4f632d571fc3f4976ef2e8620f8e66a3b03c5b487471409e914efe3022b5fcedaaee82931897bbedf631eb3e6d812de1ba34fa287c4663d5af41fa668ddea5a2631008c8e6f1346c801311fd3dd243fb5588b5ffc7287dbebebf121c8ea3b3f918fb94ce308ffb6836aa6c2394cbd71c8e23b6930a7d786cf6f3fc81d92c5ae32b26fba1f86018c25338132eccd72fdde241dd62c99537db4be4377d9a053ce910680cf04f2586872904958e234e19d149cf07a9154838a7049ce088a2e87feb45749b0be9e679fa10c1dfb5b2bd9d5e620ca3afb8e0ce68853811f558f28d05fb63f67b3bd0676ed9fcd30f3518174c3bb53a992ab40e11680f90a597c9c796f29f101ee54b7f8d634724779277464cb7c9196e18ddd87bb196274e6f272467b3a9af6053aec60507984b6f3e531ce1ef7cd7dbc53c545971a7c0767dfc22eca17f9796728f21cad2ab9d13895bbaa86cc8d748e43efb26069c57c1565479e5d227a59629d46633a98045a94e122e7ceaddf8dbc28e1db594fc406035ed0ea7b573ab0586e301ae20c0a9c6e19f879185465cb66f065da9e83a40be948807f7567bd3d6c8a559a5976ddf4098922415cefd0877ab45700d5f6ee7928a677aad4449451335323397762e93d39c097398a0726dbd858b9497d452a7d3ca2aed597834c3988cd0570f7b94325ffc29f7cef0e3b0aee1a62ecb24b69f6402c3ec345f953db2e877ae70b58a38bfbfac3363418a351bf2df19cf0b117ab1387ee1e9624998bc5d6ec2800a3c23475e6c65d5aa9f4876b6d907412df5cc2c03d305508f9abbe82ca5bb156e57bfe3955dbbc7ebd51dd7f85f36b7693f4b35b7466e2992f5e19eb266dbfcd4728b3ffbeb60d11b0525e8d8d021011c788f6b0d516079ca2683423fa4d482d2187241aa5ed67440a04dd9b415bd7fe0e2cf5c89e952572f017a410f52d32babcb30348d873e63d753803229c513aa2324a5b65752d51f06cfc27eec3c6df531525214aa137c289ea1d62a8217d505b07aff04824da4f9ee45b937cee4e4f93c82bdec2a76dc19ec9fc63e381a70fe7caceba68b8fbcad445835b6d0c3db24a044b22ba84e4a94d90e5527deec5afe0a09be53136b32cc3ce87cdc583fa83b1f369bc366fd23a579938e3ea996304e742d1308edd2dcec5c1aa43fe6ec560d4ac8987a9352cb1295b0058db5d049ca059fed8e111aeca76ee9dd38f01fe7883b941852deaa0a7f165272d1b9fe21e3e06650031897f40f1a3fd1c2b35fe7238758006538c513fb711029738e673c38f6600fb75c95b98ccc4da697a86f4709d6c6682bc4be44aca814bf7433791558d8aa7cbc56d0145d5ab1aac8c2e93d3dc022fb271790afac7b720eb2311289f567036b84a5efc1a71703f65710d867f1edae096d5ff5b7659","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
