<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"89a936f2bea76218cdec9a35846d632b889c25146a6390094479ea73b62b597be408672ebcbe0c4b2763d937a53ec8e762551851e54eb878edfd27bb26293d7fdf1dffa1017707d3551107a4e30c16e2e8c9a22bd98a6edf32011e38033abb7edd82d29563add87f4ee5676a32ee2bfc5b7d7c624342bbdf430cc1e4cfd4211f969f4938c04d4ffd1e840604e80b729f192c8b78066a8df610d45e9302ddc76b86ed00d78ab27cbd2e43f282b6946e1e7ac8ae20b3773ed89bae7c2dd2330c6c0852e8df8b6bc8e7d378e23e462a13481dbaa8230fb2bc0faeeb2e56ba312b6cc47cb347148024431a3e4ee641286e1600c0d0ede82ce141c3f1dd1c4bf46e6e2f0a0cdd897b60e936b8e4071aa065f8fcdf97de7df33c51509f7a415548e9acebf6f2dcc9c08ce6693f0a9182ab217e2585c9b6b8936275afb96281c7bf21ededba90202620515fa9af2e5c51eb1d6f17df1a066d68cc447cda6242c1e480d4016011273b12f8e52486211012bc735d78f0d69b86ed0a414c8025d75a528467f1a599bd2d5e17a121334438e0d44628173fac072f94033469ac25d657d263af0b8fda1aad1d0018541a9ba2461afd2fa3515215ca277bef14c63d59e972097ebb1dbf6c82b89602ff4ed61ffdaf3d17113652b325cf779d95fb44586ba1df0eb1d11a46cd07eec6500334728d655a1f19f1eaf643535d72bd629e42dc644d7b824204d6bceb4bff72b06acd9aac94f9e868aa02de642e228b7bf9c87b6be9d00f30534be8991b36e3d42e5bee7b7ce83739b7401065875ba76c9755e7a9d7ac7494a280c08370bfd3e0c0df1e79f988c7727e1a19d308026bdf355b478ae3627dc5bb226dd4b9f1949ad20658f66304358cc01f0fe70caf3a73ccf9e3f006870eef5b823d03b7b181ddcd7b6cb6f2d3c09e939aa906721a77fba44ebfbd7ad9340b27f7ccd37aa548fcf3cd9cb46441bd90b02b4edf076d1eabe2f79339d55013d93b6f4d790520bdb42cd8c40a36041c7c4bb93548327d1b416eefee04263401c9f4ca4dc5a509829ea59cda04e71a83ab8c0a23762f847a2f333d42f7670340209b0b35c9a90c52667cb57011949e9a6b296df5db60d75c10b2d0723b249895600bbe5aea83b93c40f2f5cfad6b6451bb81f87677421940196daec89081d996541b90f4423d5bdb10fe4d65a1efbe0965923aaad2f96b5922e727068cee27a77213f020d2ddc842c606f04e6585f0d26df662493d03a9225c08a0f43869f6a6c92daaf8c8c60c14567b14c284cb258feb6d0576e5720a9b7b22515dd1b9fa27c5f92dc96e0e3dfc5b412a41e91b0919eb1ad72128ed2724459920a9b1f5b204a8426db68e7197e8df033e0aa2f9aefe7d659a257d1df934292175c2b0458b6022ae1ee3aa41646c7042657a3ce2e392d76cae1d8ccf042d11cb17599df33dd5c8dad1a26b7f6862e5babe8bb86ee1e2a647e6c367ec9d1f9cfa0f9873120b32e86cdae9f0ab730e5e6aa29227d6f15e83692a24bc042786da4b9c3292bebf09f652e5116b860c77af6826fe9552fcad017f095bd6c0cf189397d17d65389ab23fe0b26f4295250491a0a05b288f1dfdc2e3e403abb4540420526c5d92fc2697d23347e569fa07ebcec166bedecae17115537592b99d7d58d2e39e76ddc6197f9c68ddba364217dbe3c217fd682fe498995ba94578658870fc91a307e6aca9a3cba38391d4621aa8ff93fa6b5b284badb820417d48abb6d71d3d8cd0741f04c6b39e41b33850f4f1fa06b316c690c1c5af28eed78f00440df2c583df72f9be0344bca1d835def20220c9d61112908ef888d83c92052efe22fe28bcd063f71a579141008bd879d57ac5faa680fa9f3a449adf5d1c94b1588c3b4dbfd7f7a312a5d76470e0f949a4c0c99390efb0b414fd0a15e3f3ce99c45aa27d0250d932b05936e1000142fd33cf04ebc3bf66690f847905fe3aa34eedba62fb08cf5b38132ef861d46b87de2030222bb8ae51079c0735cd090d235c92420184d5fbe714176875e42a111c3e028bffa0e9a2f829cc392dfd65719f6dec785accfb5d186cc3f05660a9792bbf594ba8a9bd697f95e942673663e4e88bc964f8f9de8f4caaf87468d8bd79f82063aab7ff297a314bf8334588d68370f4fbd22c3553743f40f9c71f458592a08d724fb2c4e5e2fd681c5ca680db74d624a83512c01507719bffa41b446f8fd59dfa531d75d88785b3964c27c4da2330e6559a80bd8cca6369e63ac6d2a0c349b0b676a16183256d9cdb2e4f4bb4477b9fae15b575db0b7a06b86d1beeb5059b14d1e1172564725d08f29b01cf003357c405c46b5c6623101c0ad3e73ba10acc23e04d08c906d69e1fc68150d8f1d590f5de82719a1464126c9fdec1ae6dcccf749405d524c37bbcb73829a42809b2537bbd4e2b5f231b8b08e9e5f1d746ec1169429f6c94bcee54d34190484a3ad251822338c67ef4e67bc731581aa506ad77f697cfbba50bb2dedc697e8f0602ec36b0f67708cc8ff17ac47a1402fbe3eb8c2be2a4c91ff0b1fb2bc97703acf33ac8107d2bbdf194b8c1ce35eab42ea3b3e38e0e40b6c5636cfd82aed17c27f6a8b63f3bf37efc6eaf2768d8809a91ed49c0f9297ac9e9b75446629bbac6e31fbc93e407cf34b441be954d60f6d57c685fd8891440e15052077ea5ab0d36c184e2052a94fa4178cdd1bb72262824bbd63f3014d3af54cc9953ace8b50b0b12ecc556bf6fa1c1028bf6476c81fbab6c860ea5bd8f9dbaa74aaa63679d1d52383072deb2de1645d41a17a5ac730d7755d34cee2d4a5bde948d9d3e236ce8ba8e1c207013d78c657d2b132e62acfce51361c541a59c3543fe56937cf280bc2f177a3ac08127c49a030cd8a6a435293a2bbdbc830bd5d6b2e94b6c90104b119347832a8fa5d292b882918175bb4af85e1548c422255bbc19fd28086ffc57c56ad2e86937ed7450b18fc161a5a5415a2935801695cd2f349ee4066f7930452d9c1b1fe911e0480008d9e06ac449d544fd42bd6c7bc80ebdd8f215b77629511a0aae2ed0dc371850060325ed93c2dfb2fbdd22c9f2aa902123095b51169ce529c92e574a93046f9d361aff242727b0c60776af22de15f0dc5026df22374005c20c655e82c31174b6ab06009126584bea154cd675b7df16564a51e55815a7f77e9efcf5c670b76d8c0857e461641dd2852e5593aae932a92267c9dcc28269329c7f6dc0b35f206771df6a2fb3e1108366c9a69439f757a6b2d191c6f0cd580eb466a022415f120617edf38248e1e7f57328f48b64a058b8b47d5a9ba5cd5ef07045b873753a770faee479a4e5ad7a8437faf7ca4d24381059eef93b4d3c9a0bcd72271a2b198a29c53e2076a4394fb896d6fee7c635bf83dbfd5d2120d4cfec4bbbe07b214ea3d191448c411f16ee580ac0d04783727212146e3b19783ae3ef6b07e595518d3e8824a33d4708bf6372ccfc40d39fc6bcfc6bacbc4007b8876c3821dda58d775f4dacb4df01c9389d1b2720c669664eb3a58b1fa69d428466b2533261ed2df68c6ab7d129221b525d36728df39abb60057b00db2b8a8ccea2904ace557bdd564fe10ccea04617cdc0f5c5cb99adedefd018f7dcab2c833bcffc76e6696fa93b0ae5cc19b7fc4f987a8113fbfee12bdada26e5e1c951b1f2f5d02b1e149e021c1c5652657eab87c635740be8c6eb0e2c6037981d28fa1a7f59202e6a0f113e7d7f30abef89bb7e1664cce22d36d4427491d56578dcff9508979588b07e3b70221a22ec3997e08f05fcc07f5864ec4bbb960903a6483cce7a86476b321edd8d64c4076f3d27c9e61635c9c41163b82dbbf24df8091eb25f171140960180a425e2f907560bb0924668493ac5e49e981786e0e3f8fa20890099abc47373ff2e89aceb5926e886a17a15b9638156ee202d9d6b1b89568cda815b5d7fc8b127b61b07b086a3b9293d56526130e8ba8040fb8fd0a8f09d26058350b2ca343f85ee4eab0a97ec514d0c3626766180d2fe1867a01e3f9234a235dcedf13720c8fa63f81358feb5547d0a2bab503bcf375ad45d69247d985e36321098f68e1128eed1cd531fcc2160c12275de925de30ed8b2db8307a78be1d0cfc363326521df62a8fe1a5e38d35c24a556dd7b0f60b8878fe1c1b6fe796f94730292eba78737f3543784a7a504585ede6b839a4522b82bb7674e0e4a8600a1c1d35b9fdd116997f372bc5431f4848cd4c9cc33086f15f26176287373a9a5ef17b10f1482f9da71e67265eda1a07230de052c928163b88a376e91132ef6b68e1e0eec0650e57424c6ba3266c7725f017d4fd780b063fcbef8f059bd0da66e073281c98a331aea820dce0a6a8f3c1809ecb0a9639650c48bde73acf46be95da5b61b5d8ff1f1b6041e0abeaa8238b3fdb5f51f7b861cf0e09ac3f77e1ae48cbf6a3ab4f13435a74ac1e84b401efcdd466f92fc948ce91a93fa85490c54187d0d34732ac4c516d2685ac6176c3d9cf955379d7aa71bc8ac7d0e03bc62837a3fa05d5a2037804f2df06332b373a5f4a38a0458ed6143d2c1b37417a2b42ce9092cab47a07f3ee1816ee03a7cd93127b32ff51be160b38bffba2af7e56ce08c64e7f6ca6aba458da990c18ad8ac578236872415279b800465c8754f6c79b92c3e6a98324b2b36a796b2be75f155e4a31535b094dac7334a9c4e87ae69033c4c1f80a36b1a19e7bf8ab949e185c09991f38b17b9277c60dcdc930324efe0bae73e45768776463bf1ae3620db6d698248234fc969c219fdd7bd64284b875497cce32480f6dd1326511103af0841083dcd2bd80d7d514500133518610b4f0c8b3f9c8220ae8ab9cdbe1687c74ca06f7e30290753adfd915ced6f5cede01260df81d2422e6e5e97b9c70437dcff0ef2b15ee906e24db2d7c9e4684271ab9e507ce0ff00619b299580ac16956e35980d36432805f42094b8302a84ecca35f8f2370cc1f1cc21dab9e70196c01eb191927286ae11ab5990bcda9da15b7b057a9347c9ded98f80bed126e2edb56399fbda27841a6b86e870a3fd7bb979aa61e2bb6a547b4f2a4d0e16fb6b71a6dcc7190042be58e74159a65bed48dcc872fbf30f7a10d69aec2185b9b59392050fb8355535d7e6b8fd5fb4f9e08f17fd25abecb70659d7753aa95820d326ad1b823fe7cd74baa3d3d2eeed1c2f032fa4bee9613e1242955cb53d9b5b5c5e32833db4a0ed26d307d3e8ca80f4c6a8ed6ecfddb3c1f172a6aa5cb5984d636f6b07d0f56b747866be1a0f86ac486f7ca3e2bd7ac3c82ab5489adb60846a36506cb52a3b67e2dd9cbda0e62965c74865582ee0ced19aa44c0463ebf1b8bfef924bab5acf4c81d98fe4bc5ffe725839f4839af4fa08d7535922a3bd34ad2f72c941eb27e5f9b755a98f6e667f04b58e9557464fdf0285f07f13d4f1cc8800e83b8726a43c5bca973e8737780e18941a2794429272cde8e9f1befdb5ad9f1ecf5e9ac4abb80eb1bf347a93531c420b9fd820a18631c6b683e30c7ad6632ab8761c028f849058b3a418446196fcda495cb7b6b891afe8b6f674285fa6da697995d7f86767f7d7571ea1fbaffca2d7723c03eab29ab6c5a00b67e608d033d54cb6c39eaa1e6c9e2f4cfa8e7036789148349a76d25afc50ab29045e359e2974ffc1f95f3204498f229fa573c9ac3deb47f4f832798008bb1dee57c7d55b6017e3ebecc93dbbec2cd513452a2dd5f0e21dadd214c6d895b3d6b428567d5003b7f93e11dc89a3b3a27f69dc0d29e39dbb5fb7662be6d9305a98addfb6602e1e616750f08a82879b63353a6bb455ed984efe8512e1f39d502509519ea3f630590d266f2f65cbdb70f386e86eab01bb2a4f217ad8517cb7063b7330b282cc551c5e6c188ef830b4eb01d132ad806192a9b447d11dcfba80996d03d2b94bec0261035e4cfc28de4ebcd5adf32b0d67a354fc01ffb3af5825b3e9de05a9fc6f50c2c0fa4edda9181525fdd5bb2e4bd130b3aa324867673eb6a0d275334aba2c1aeaec82f18e5129c0ec5c8ba6b764a03a8ce299a2afe1df48ba0790daf53a8a86f59ec6dd0ad94f24796cc01ef6b7f9ebf4b89097ff248318b7dfac140826661ac43c592b5370313801c2a967de6d3a7bd64958787e0b2256f8d894c07788491f2a38d5247f3babd9545a217daec785735195ccb2149ec5fb06452a73051879b7d52758a2ee080d0bf736e18b712abdbb4dfe206a4d23366689f0d40c94ce86d47aceb29a81e821c02766d326140680236334509be2955d0fd513c892572d9455256670d49278a35301ac581062d5c80fd5ffbbb16772145b5e57b69b0186f1afb527bfa34ec56b3ec0cf99cca206114ead435290c5da5f79c50d7bc140a925c995c915f5964eab44628781ceeb870866530ec8493cb2b97f58cb8654ff2bf55aba512a7bf6f3d4fb818f45589b720e28c9e91000b01c9ba3a1543d12c53d4284949c9b188df07f9f0a9f89882ebc5d6c209d46a9d1ccbdac2ef9e0781241d6eb457e6fb88388ac738fa65ed49d5c148da685175a152f367444fe46d6c75ca0a3cf1aec9a76a90d044ec1022b7e8ca51191fa16972092b26ca99c0c346e1fdb641f24ccf990e991e0bb5227c13eb57f5c161b1ae47f89907b6f31e94fa0ec6801ec1015f289be28ee04f2decf73c240a54a721896bb5d450bc1413c19166a4af76e77ee59fd6f0afe398009b3f4d6b3e3ec0e19c53a499d3fabbb52c1d5d79262b74e75f3bafd75d404d662c88546014063ee0fa0e591d26add7f8c534e62ac8d3c9076883dff50105ed33790a9913cea25d40331e6788ee963f978da61841515cce159b2b73f67d98d224a6da6c135005909317cf89d740f6143607d4c3f989d672c194f8b46418cda11ab1ead26f2122421ca7af41b55d84cf45a4502aa77023cb4eebb66728c9287bf3c61223a3b09c3d7b87fcb8ac5a94ab52589dd34e67a122743a7a6b654fd663e2e3c57669ddd841359da170d066391d18bca2635958245c48b817938c3e7475ffcf4e2776166c50e124240d25aa7e6afa86009737e9f0e0cd45d638a7ac20ce66106cd9277eef14f1f8a48db8345e299041bb4b8c407212b29b810ffe6ec2d111df3349304812bd714cfdaf55b962f24ebdc26a5ef78c9571ec15a0558644fab4dcb94271420e61cbd28581e876046ef2ee6d0462db175e65eead9fb6cf2d7c9296b5f153b64f62d392e29aa8b536896ff6f691ada22905b2be47428ad13e3d508c87401c7c96abbf4030f24f94bbffef77d7dd0fb18344084de891dd129485664f0b6e60e2a41306b92d71b656f145705b7133e12ddc691c51abc85ffc15abba16616d7ea32f9dbbb1cb6b50013bb444cb3ea2bade9dfdc3467698e180f5f0be4dccb2aacb2d1b87f0319cb9a4c7e80727a1b65d581c7435a4b9a4f76f1ac40feb9395d327ac4c4f4528b166819931e79d77951947022cf32fff45c72289fbd45e5746648107ea97c4d49e16ec4ab006e41eba7a8d081aab74b1e15ca6dcbf49b197336555d5651a816a11b0b172d06eadd9921474267544d054dddbfcbd895b0f1f421187ebb6ce78115bb19c97626130dc01de37bb6c0ff53dc3a1ee378d184945a265c218023d13cc5693c932a3d82b309896a5b17ee01b4375722272be2730172c1c981042ae3a0a43069c6df63dc3a06c52bda974c49fc0a24e4698af9c5992d4ee83b459a241b756c4edd4edaba1b96ce3bcabc32109a750c964a46e0cbe8288596adb480ff09066092d3d6883c3731a40c4020d1057f830cf004f32176f720d3dab71e813920563bd27a407a94ae2edc431f599cc253762e4d9bf11cd6cbc43a5d51d2b5abbfd0a207ca38ef17010900e32e3803874e9f803993e47acf6cfff19440bfd8279e6ae31e4466ad9a79aea1ce5e595cfdd37856b7fe8a3a00502820e253a2b2d94d0f8c03044ae6900e963d4b6e897b499b1a81415dde45a9f950a8d3e4134dbbfb2530edecff5919cf818a597a7c691d7a64f6964cfca6524842e9a06729c8daa2ef5cc29b6c0ee668d244a9cdf615a102aa3da2e6dffc2e25fee953463b13b528b91c75828128e16ddf538b23c60fefb8868125f4b13fc75808f58d9bc02195a04d244e54c48997a08b5281f0d7b9aa58533faa82448391682c88d69cc01c1cb821b2129f3582d2d447c41cf5ddc4148c6c3807b270c5bcaf923add55bcdcdc278ba50d0ae34752454982e88e6f7bc73d03af6ae7d9cf831d2d0121a3467d07af734ed5bfe251d4e6ddbd92582200429ff52b79d7fff3b6efcc9c9c9588cee8195b7510a141d0d01ba3740b857219d85a3492aed9b8b9d63285f010bd13dbc8b1d3c8c8f6b954f1b3de33ea29b1a2bc943bf122dd99d445d85f61376d622c5aa7163299fefb6839dda3b6c01694444e98a7692d882827877e373371a79d20ead43c68220cb71cd1c5d0f2210414bbf5c3991b54079e731c1faae8a51e2617b7300d9d70bf5a3c686d41c92319e7e4e33064a79e764194ee49e8bc59047d9b7ccab928c19b670b0ef09899fb2c66c44860dd3c5b5f70e96e7b439529f2896ca4c950c431bd567ac8494b27aeac3ff1b56252fa46f7f5720cef60c2b1b6e08385cab9725b22509f97888cc584770d73d18d53976f9f3f4e9993e1779e863a4c7151f15276ef97bbea756d00b79647b2aa2f78e1c7370eb08845b8b44498973ec9f9b13175abff8d95e412afd2031c2e2cc7e499c5b3937b5f3b9e244e1057b55c7b38a3fc8b984654dd1da143c06b9f22e7861b79c51e9fa02a32527ebaaa3f374ad908c7ded39ae205814b32f7f2f43b9c1f9a6372461dfab964653fd4e06f66b5390a17ff4816a138116004d721568a4b00828b6211ebe70cd0f844dfa0644ff017b38fac58c291405f760b251d7f497b1b79f75229f3d02a772fe5560b6e963cadd0726a6ef2fad7d8ba2caeae703800936ff16d97aae3960a28544913b3186f820519146cea76f391585812a1e56eff32018a287a6bbf3c21cdd0751d6251a490b88b948a4a0e791bfffd8d97eb86e86e2418c2261b09c32fa29a389cde62805ee2d06d47e33cff2eef557a8ff43190abe2f0c9f74ff8d3f5eb6ca326c3adffd79b119566167f6010da398cb43a7bd31f401945a663dfdb71ef2adf2603b6b764489885476394d0af4803b306c5423d4229a08e7eb21a1f346930456bd79f3a137fb7235b775e8fa2ea3122b7892103f5ae1f17c215db99ca318f21a1bee19db1e3b12fa98a8801383c194e33bae5cfcfa43892ab92af281122cbe5c52970166180f853c34407676c502fbc8edc084d53c99d5c062dfc42ceecee5813a77b1d5850a0938b86ed7c757e64c255158a7d59ce509f4b2bf2cd119db880444a265d732c808f845b4049791fef20c859baccb6150afa026a4ae791aa99f96aa68b63f3056733b98460de847e9b5e340c250cc06d35f5f651746af8820d575a30e9a599f541a836166238dfd8c8726c5fb2164ad12926c23ff41159dbaa22a61e93caf384b5cbfed35b7b0308a85b36f3cbcbe3f0305d8af8d7a86ebd24b222cddc7f39728c946b90f292d89f5dc3f4112f702804687d76c5e973e32f06efd47c7318843f9c66d9284e0049585da241cf872754c4993d41bb732aaa3bd1019696c86b3e36d80b33c080c9038495f11aa77273363527451bdb34b9fa9bf61aee7bb8573a0326f1d48a430127480d477587c851d5325b2b095385099f0ecc9f5aa2ddd22f681d9b0eb22d7f80b263b1d5910ba540d9ef1595c4bc508620e492773e8eeaaf2dd323549800e3c0d564c453b21914327e69d4ebdb41450d8ffc2bae4a283aa677fb2eed208bf84db7884c4d1820d3b47c4a54ae9f6aa52ba6f2128d3d6caac4553820ecfc5f2b6806ea94208249de2243fbd6aa9e02b40ccc6f88fb188420dd62fb91654a731d73464f5bf17ff4da4eee74008b7391b69cc3bb23c06d5211892e6fba18c50746814421ff360a838a59770645657103d6c907e44a970308fea70aca95d9b43a073444f44659cfd2ca3bc012a3ce694032913523538fa22e81faad0c21119cdea19347ea7538b6cb3f39df031c5c3a206307cb8a203be0fcb44d3a2cde83da86d932f5caeec3b79359c324c74c514cc6a8ec5d0f5da2ca9f5ab8c956f57ecf97edf13f588acee433c011c8d79e9e04bc6224634d1c7e745ae1cd8866d5e4e6d234dc1a0f15a979ceb3bb365a094ef5a6e9fe553383b3740df8ec0fbe25e3c8f799d5b7dabb60f6664f4f5ea1c1aa23f951ff235c1a422de5f91f8d7463e35b8c9ef592dea10ff7ae732542d8ef7e8e3b9768125e5e9b8638cae54f8454d448381a48b68d4dce207c01707f639797e1e167b45766e142e4f87c40439671f495594b965b86d4cdb55deca2099696b02d223e8a6c93bf95c772cafdbb217cd7718153d5f80364369ce240327ef2731004d87d5625fa00a5b4e560aab0322678991bbf2460b1101105f9a9065acb51cc0e777d00d3bb7f7f85fd0c1cd7ee4dfcbe291d809f90dddb696009d3857096b49b1c13674a05355e557bf2dbfaae90e77f3798e8941bf9bc00623de91fdc813e4b862653cab63b8559e58c135149e8104419075599725f7dd9fc6b36ee269c7b6aed709b53c80a930a158a043970d66e85fdee342ba8e2f6b01bf062eb539bfbe521b3f24c02aa3aad7a72a614fb02b3700ca1b7fc5bde2b06e3aaf08775b8ed5bca58d03ee2c0a44dafe51a835fb7a63408397a32561efba00bff44257b289fe5b5125f9602769d585a13d2927ff18cc6a1e61b7a3d1c0b5457dfb1c02cf8eb554639ef192c92055702dd679e8e3e3bdc711725d1d20084b51af744a073a4b3035cd3ec75a58f58ca1df6bb7176a52550c10730467a99125a8055232390c417a2e70395f3bc1cf78cd95b86da5f924219c75ab533e3a22d0350e93d14f8ef8019e5d40f5e8c422d0c79d1485ab33228db33ebc093534e69ae9ef6446f6941b31dd692a9447d3bd09c9ca665c53f0f1c0d0998e072703609c987deecf71f26a21c28236ddecd4be3edc118130b02b4b68a70337413a39be9fc610f8b09e9437ec22fe5aca7a05cc8e465fa8fa238cd2e16fb7f32a3623e01de9becdc04161c4267abe8b7aab8fdafbff3d84cc138e4b1fde7b18f105e2c9bff8727a7312c7b2a94f75cac628616f422eb4dbd73026e124e1e8c4f3c4a034807c0830cc6f570d0395cb9238ce9b66508a58c645a9899fcab4c81ada8648e036966bd7fb16224925cd759011a4e335dad203973b258dc7944a5ba4925406f6be4b465031e0c58ad2e9329b960263e7de616adb057318f927e85215a4d6688bb10c2303a5d3226e221920fb1f97b0a398dff9ac57c439f5c7a593d6570c61d30f6b0531b1def9dca521ecaadb78d24b3a6eaa9bb85eb9006e9e3934589ceee271a618d390b39b13b8a96053fbdc8ca3e264b841660374d9b8d484195bd3c6b0bf0a2996c11d6636cf5969466adfd82832355ef5398ef852b86cf9486a1c2d3c5cb73347003fc96832d7575943d785a5a4d144688ae53168e8e11e8958a4134980619781487a253a05e3d94f7947c4badcb4e73bf0a5625763fc17528254812940cccb967b120c7b98aa9092c2e0e27ec1041b1c7f31f08450bac67ab6e7858f448fdc7e7a4f23f87d77cf3cf4f5adf0195e2b4813bf532883694dc36ed6114c0948459766d4aa2e8f89472bbc90251d474decc408cac23bbb7f03bd0b5a7c66cb8c1cdd33a5c60d018485d38dca4a67ccb66ebc50b995f8ad8eb4cf0db3961320418d608ded203acf12ec41ba88fdf97c6e7bfb71208041259cbb6c34cd729cbb25fed574f009ed1f9ed2a85eb34339e059ece4890e4dca1cd6a228d41c8b5fede83a22f411d02bfa426e5cd076120143756667ad10b4350d7cf2dcdbd589cff2d0b679b5bf102dd42f34fddd891cffc017d973d43cc6e6f8f5e37ef5037f615d9a0acf378115e467f103cc8050ed8d9bd10091757f230c44f686df4f5ef83d332f751f874d7b2bfd5e03527c6ab52edd493b11c804d471736188cd2db82249d8ef17e8d8a0a15d2a8dac73ffa0d306405636ac82db563795104efd4a4b7884d8a3cfe25da4d52aeb2baaf978b3437743ead65cf1b8537eae4cf0b34805a2084a188ffc106fb7665429108a0426b0c8a3d1663f2df6fa427d6a6a80ffe0e653e97c6d30ebbde83e9d2649acf3261542ea23b5800b08708950bb8610c9bf09919d45719eda37846acea2a8a57d3cf2fb333b421b672228c38d119745b93cd068f2649e80693e9a4e776ff546048ef306cc0cb25af2486deec134f2ffd6775ffdb09a440c3d1ea7d4393298a33ddc621efd0575fac5c063ee67fe823977d2a570588388b8738d57115a5c9c77f902f43f7e96f9ac5b9bca0670a5115bd0a61e722ff577b8cbd3b7046600c35656a457ee95e094e78f206a9c0df1ad9fa7d06d6ca4fc0ee914b592c9c480577d952b5eeba948a5cd2cdb6f2b479704d26cae706e8ae1e4b21ec9cf94f079f8b8e130ba202c24e78658acf421cc96c86d6aea991e7e707883a776e9d09a5971e30cebff898dcb60ee6c525d403b25c91696ca600ab5032c9718f0280b40e99a3a71eedd3f98ee01ccc13d38003c437829404241179b632d8a1e572d192ac1805aafd025aec6d36387a7b2b1aa1b1198442f7b8d51cad1d39a43514af1b27e3207b5c7095bba7cc2694b9666338460c82367a2db5701a47c82e366cb2002fa38ceb9e2296b65a5ef4e9507d5bde8fff6e7f6a38bc4dea958945b22075ef2be85f7f3ffc257e4095bc2a6ced78ada0074a4cac73a9b9a64fb805170e29935f155973978803b659ee4331dafb84db4830324793042f2fb20e4c7443b9f7a0aefdaaea6da237aa66498d284367cc3bfd98202263728a13455257e45e2b37fe93cb253d576e11240525d10d47337c6e13ecbfaf9253cdeb7389f53332ae869b8ed0d472476d9daa84b5ab2e0d24d5e2df1a90a6af4dea9e61dc4b039d4d5cdb3ee26f65f05f55398e5284731bfba057cda11b8fe1da02344965bb0a8ca3cc9f7350c4083c54bde328cb108cfc9d995505fa932490e1af294265a8b541a784ffa64812d714b2ef4463f179a9b7c129bee2f612125300cc5daf2a0ad1f39c4f8e2744fa00a229ca19004210ea686c4b1e22dc32b2a8d14a8886e9ef3b3f3e7454dcd2c09af3ac6005f292357f3a4e4d52cf78f9026f4305c8dd7b6d5446beab5ff0f404ca664bbd69d33d466085c62968eaf685139c6d7c4c0c40e81925967f992fe9d5662eb1a3b53dffc1cb88aabdc16855492118db3840a5b96cb2d67a7a54100b1f366a6689ce86df893c78f1962fe7fb3ba56982774c43b7ee5d9eef0eedfb4aa469fb204d18a14f7135282af8d83288e9c74dc4481b1a4c92e592407176fa4745b0fc8111c9f682726a7fa3ded3b24e5873616f0e9941586bd216c78a839dc75f04b6843078a8f2e1b583663355d0ba376b1355808f5ac5b8142b5ae0273ec5bb24051a6b2b2f8ceca12c3a5cfc619b30f19b5e94195e42a5d40071fef9ec090b02a70abf244cdbe3d5db53f8da5cf0102416226fdfcbbfc61cbfc917ec03d40feb8fb312dc75acb8cca6f78e28e03bed475d52b958cce408e07b63b44c4bb8d9b823905478d56b8f62fc26d82ec3a8b3a5734ccede844abb66ebfaa115b738e8f893ce8be8e676d20871d7d979a9ce8386008cd42e3eb67138995a5a54775ea69913d531c2724e342e02c38bdff1c444016e261fb6ea465fd9a2bdc5855f44701165d26b801cb0fe3f53cd534480a771a9ff6c3358b64fc74c362cdb853ede65b997f4433278ff1b7986a65257f444c582767483b24094140036976adc6bf7c82633c65561d8e031deb926b045ea1d3a1f49185f12eb54edb54f73fffeafe21a970b92f14f1b53e36766549bd639a7f9c3bc0e22fe5432b7d6c96d921fd4c89692d1a0e5e5441971b0609b1e713c00817dc5966467ca514976de324fdef060457705b8ab8cfe17efab30d42b6eba24cffa5608f08dbca64e47a78a3c0824ae031294aef59a6811f0c4e441030f91eb172c73724c0c635e2144f0ff80b09f32f62d1cc877cda1111072b5fcf1f2315d2ae9fc40d3197a18a299f73ffba7fea53b76b111671b96fe3289627ecb4ec3ebf634b2de19bc9151b28e6f0f6fb4110cd9d23356009b8958f4b6a9858336dac17e27d9b87f6bf8b91b92a6ad2894b522e5773c86acd176ad62657f82f4cf318ad9f514077a07cecaaff68a0df8e5f690d7764e06879708d70aeccb6c2e70cabafa7c9b328fbac6d766057f92c62eaf19ea709d128ac9654437ec824dcbaad8268a224b06c1d49c449278688c13ba349a7037b9fcab6b64eb6038727b1c559e52971d32df7aa2dc6daeb32c70b9a3f373eb16b4845d98332d83e5a59e666401238af69eb7b104fa55151c0870c440f762d19ec957a821bb3f4e43704d91a5a1387c6a8e9de9699c3e2cbc98c2700145e5a07a9cef60c8ab06fbbc01ca207b6887551e5d45226adf6702f194186d24a1c09adf0ed8e3b700246117e137b8aa4fea448ae8f395bba4b10132286269faf9d8c0fb6929a0dbe4972879930907f626e2a5f18862bcd129afdd24e40e2b96baa16d4cef38da6fd6b2f597c4ebe213ad670c51f54de4f007f411d16e4eabaa5019e985234d4526dd5e633943fe8859702b0fc9cebdd76ae13577f8b17a95e3e8c639bcb13fd66fd659f6f37025e314b9d0635f12db94f5eb7e53b8976f24364f43b883af0d27363fd055da6c3aef5c8af5a04cf2794886b081ba52359f38d61502faa9135fa3960d6dd0b9a9d4075b36227623437fcf1427fcef2c5ca0ca6e6cad38ba64355424b355c586e26f8086b3b5ac95a98d0a016c7bcd5b8052bf1f159f397600a687d8d96ae33806c00e652fa862b6d6a16e848e8cef2b1133ee28f55dc2a2a01e4aa7bb26a94ce2103c6cb64564310dd5655aa265454095ac12eab9d678576586e9b305ddb0b9263a5f1d6ec41bf725eec69431decb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
