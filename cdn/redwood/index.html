<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc4c5c86bf556760b1e81f72364653c745277eec0c98e84959c13718f760717b87deab2610914f19b152429ada4d50b23c0962f6e11dbc2cceba01aea56c4bec8be722964108d10aede7c99c5f866ad33c14ab27ae6a1b63b088ad2431d44ab05a792b9b7aeefab6c85ccdc7a03feead693d8b3eef138f79d56142886ea590660d85dcb7e71ba5c83fc0a0a2483a1bfcfbdcb567a32bbf70c91112b76aab23b7d1774fb1eda956b155b4cf6a9866578e4c6181f553acab5ffb24046607459e314dd538c400e0752cf002b4fc46451865557e7cb9ca4cede2d2ad0a953d6c0621f163cff375ae5e00ba753f801303f1049cde08c01c2fab035282a79f57965d7375eb9a969a2c7797178861e07a13a8dc6ac5f28e667cbcc7b564c3ee8b71367e356fb792483d6abcc2910163d9d52a8ed306d0404b167cbc18ef24829188f30aee101847af469336da50ed928f5bc53afebe0c7950aeceb554a972348cfc297aaaae524081fef8b28d2575c33aef3b12937f21ba4340f68794e5f5df7112cd7fddcca7e889fb3a9f78559d028bef491e1b666027802572a7a15339ab07e4827a97a899e17cce6ea04d462c874bd43f6a965b63a56b1a7b574b2d07d09883f81cc70614a54a05cc3539c8763169c576b27f03f88c4a31f42f4103db4b542292b84fa75aa9c18bcb0c463afa261e1dd5f53611fff26bf02c1c1be73d3ccd0e51d519bf1462a99e8f42b934d11b9e02dc2dd0527383179551ce84741e3de66d48bb7044447489ed5f2be6134ca2f64d2940d8f858e3bc428bf8745f683b2abd3248f04c2c7555195e5a84f9599d8e181e21a11fae7c983122e35e230b936099affe769ad94b3e38214c41d3aa20e038b60f5b19852cec49e0e69ec7add9c3953d1814e612a3f5131030a979c3c7feadd6611999e8c1ecdf98cc6a7b5d95f766bc30264414e29a68fc9b856ff643b0527cf65d50d4da6e27380eb5862af0ca913a339d45952cd8891d0998a063a65fdc203abd57f742026af5944c841822a8d004cc2a9d5097996f48857f15a7bb58ad73b00798185be6a52ff158aa100ee18c14d436f714b1488b4455834e76d592b351faca6b124b2bce682a4bf77267f328a153c8fb09a229e78624ca189c657390823193474da0c129f8ea59f4e35b0c8829269c369661882184265cf175af9200628c69e52bfbe823e4533529915118adf1848112e3c82bae6abf355fb6c7d1fa4a0c114b57881edad903d593993cc01b2597c286f30e76be00cad6d3fa1b560903506e32ba6851dca56523455a080231ccffc58fd7b33e57ae1fa0fbb9a0eb1f86a46be663a91cab5ebc119776acee1609a6dcc6412999775aca50980497e95227819c8c21ceb83f951404f410f207832cbf2e5e5ca1c1d2ee08edef6fe8981814d8a3cf957372735504be95fce155a95da452db6602e6ef4e9161fa7d175f5dd04b7e49de4cb2f941bb7d1d474acc4d9663f9549c4df68883d158a223b4c3a6583762be4b4d0cbede7ca9fb3b81b28ceb8f36d14f2d6eb44e01a2bcf436517a994122cbedfcab7313f33c2cfea91ed403c50bf70ce1fe73f82cee4df5179df5f1a9f455656d731e953d752c056fbbe1d95dfc2401ac8e23b6b087ac394397e955681087598c5cc5da18e437e9142ef499b3a6bd97b4b25ad8d304dff8e0a52430ac85df461a20bd4b9550f1e2c98bd6ba8521433a17b5b57a7662fd63a8e75d02f06a15b0e5083871246ccfbed30c1c434dea297f52e06f7d7d213f832dd546f0490a6fb63ce074bf0efb248dc04701b59f87351397697e7d3d48af3fc49da02376c7f1a1fd02e9155cd9e4e76748d9adbf2eaadcba73b3b29c057b1a1f110bb278a3e782df04059bdaaeeb65fd98f44302375881631f78b7a8ff125e1940d11c9750b079662fb37db6cdb2c6a59864b8d6a001c0e500207ecb9989b073e669ddd64f0eb43cbe288b657c3147889d4e6a820dc41201ffee4df7bb7f0970dc3f790e93662d5c0ab8531e5803e9c2b89428ec39c4078bd3944e052db29167c24023d9e8e78ad97829bdcffcaef819d166bd635d7c041fda9e1ce990842fe156615bbc238820abddbe3e98cff8b99fba46d4230cf8508bf5385487a656d35e4d0f46d94dc688af2ff623ae1c9620267033ab12c455c11cf05c2ef192e6a722e3b5fb5dcc96034a8486e8f8bca34a2dbc140cb8cda357b338b1660d56cc8e0353db680db451d5591d6a92f70206cbfe327028b7bc38779e02a84624b4fc89fe6a801ca16df1ef7155ccf264a75bb192aa485aedb68cdd7d33b5850935ec2f6d2f8520a024dc2d6ce912c0cbec5620bebe82471954cf0644a9a09b056548fb21e8172e68da2442d9d19144a6f714074d6e8c5aab998047b454b42d1113223c19d6987133d3a01fda0736226b416df74315068a981f9466709993781b69773499d27458f3763a2537ba8058069a003a482f548f210cf714bb838aca8cfc9d21ce3ded1c6a4c911504db79df4e5bcc48bde7d650998040fc876763156422a0ad56cadea822d475f8638bd61aeb5eab2532be110f1de4abd169d4a94fe696aec701d8e31ade10527c7cf3a2d5fd2db100510dbf2f5d22f0dcefd764a4acd4fc1f4ce37fa83ea3c364de2347f01b72af0113c7ca4d621988e87bc5b449ebeb5ce646f2e746df4425a7e1b3ee3901ae2bf7f12e49a9af0631af7a4f7aecdda23707658f3aa3e418de7c8d148f28142b483fc79190f7bb35f585b3c33c527f0f2b9e37d953209919da14df3af27fb607d2d09ccdfe64658570b858c566467ea65ec9710ba15e1ab8f8eb18ffdb894d00893da680bb74d1bbed8f0d40312fd51a485b038a2ab93174c287e84cf1e15b6b0b651fe2a1517edfbbdedf09c0516465d8f7b173470e93593c26eea2108e3e9279ce0d5fec526ac97e803b507b58bc542be87b9c5e5d5817815dd9de25952c9ce48d7dcf9af407f061cfe25a9978aa96f3176fdc4666942b37504fe2e6ea7d108ac570657dd342078a457124e638148421eccda0c1c24592f3b39e24bf35439980671b3d1389458508b5f7654c19b2713f23654bb0eda5d3b047b93fc0ac393a33675990dfc9231d340e242c7bbf23a29cdd884a5ead5445d32fad491550962f05bcd213c55db2aaf47cba1e93ea68c5711608acbf3dd590d5ca22d2fbc2c928ab686772ee8aea5982795f7728f0124bf62bda3e6ec96078b06fea4082793a6baa3a1c744a1f8ea41b49fb9f42f180e2421e61a195151ff1728a76ad823962fb49fa016d9650395343c542c208da8e26f671243cf1cadec6767dc5c1bc577713d0eab05b821b3e1ff17b5ee78149a2054a5337fe5bc04a2ba967ef759e6b7766296a93d83788427ed4ee0048eefc511d5e6343438f239aaa60f40fb0691a55db168c138bbd07a406ef73473720b5fcf1b84f0bdb0785734e1fef419d40fa9eded47316ec40a9b91d175d659b2593b31e805b9e6e8718094554bb4caa4e55ddf343edea3e20aa8df0f18413e0f8bfd4400ce572563b361ea8978ed7d5504cd5ff2214678957561379d83beda641ffedbc2072f209f042424e50ec9499cd6cd2d6930d602985cbf0f0bf6d67a8cbd6c1b26514bb00ad3e924a50da65e9cc65ead34d2602c5ee1e4ab2ae7c75d4a0f362a96a9c2eaa2410b2d16c7d27cd94ffdbcc1d3d5318cb80deeb6b12e0cb4c7670c7b1d7e622bc58fa8ba339278325a716118e01c87855c8b401aa39fac1d62e72f2971792c3bd36efb77c4de6bceac6afd9fa76edbf379652c1918775407c08f1e3f19276f3576332655d5dbeadf381ceb47cf071575cf58542ef16eb1a5357b76adf7e4f122b808589f3dcc56f1f7ff2c6166faac7819c758ae16c8fc9bf1ef224506f024634a3cd28d6f335adb856d5cc187ad6406d15bd52ec2c35c83ea7a8b5bd6eb92096c09798cca85dfe918d748776088f73d329ebf55acd0aa181d90b7551006dfd31e141bbba17f8310c04213fec9d9b894aa8be5135f230b5dd5f398b014ff3592cbc0f0730fe370dd04da2d51788300f3d8870abee5041c42717c0de7a7ccdb31cd236acc97b682c28799e7c710aebb4305aff5c788167a9e349486d919ab658684d56ccf3dd449b765fdc71378e8ea64ae96b72d1d972902fdf168b316fc83807ad40b596ff643ac1114d59abaa6210526f860f98becbc4498b3af6781ab3056c5bf3b4e9722e8e8bfda0907ca883e035764da61b712e67b60560057c484f5af17e3d12824b413af2dce9b8c8b92df53303b16faae171713efd02a801f9fe3beecae0d53f6704b7f422b5821036a1a32df4c9452e837ebf40a8f88ed44336e5a286b72dcf5ce87a5efc61592d21ba4b195948d80651f91951d8b5e2c430e9fde63b6718c5f4a1ed8019e3b1a6cace0f9a5b2912bea84a5f73fab6c086be262fd09829336dfa96d76976cfbfa5f34e429848db8821def279c0917bcdb429df0415a33b5c6488fe3fe9df681c7f11768dfcdbcc5b94d7e0c0d2b9f9b3b69a0149501d1bee1ec265ac01a56b068a6d695713ad12705614a72e64572f990a25fc72df0d250193c75d6f9c87b7f2685b14474be7685386da42743babbc9d2d913a5dee6f83f17d6d5d64830aefca52b3f1f352bfbfe55aa19342f06957dac8f05937a86d6a8bae3a7abedbc9d68d60e89c2af73daa32d1e3774e5799abc0e6403a3fc3aba72f3cb4a7649b17e48846a45fac3439479ee9fe880f16ff506e29ef1310227b9f800f0571e56ffa51775e2e0002fe15ecb4b8df311b27bdd28db029e89872bf52c67d55e2927b5c950afe59a7db28aa9d594103aae3106f0bfb27b5c1d7a6fdddac981eaae4a96df0930883338ca9a7b8a52976187880d794f1a1bce14415f371760a41f4ce00f527665fbc5344cc69d57d8d6737a458d6c7fb3f69976f0322be50a1d35e26c0daaf2aed9700564a988f8ab8ea952ed90ac974e7dba77fffa5f9e3d7124cb79620d97201beafe11712f9546280da32e01d0284c29f427244a638828be0ec8577f935db0d2dc664ca5fc94fc04c2d4f2b02a74fc6d59aa19c7b93ad91ff44449d6b8b24d43609584121179a702d9c97adcb327a589021100466f0e3063e82de98b9ccc41d6325df31bcf45871877c4c092064df60fb9a9b2e38e1ca52e03bf408b6c7bef5f5b46563c79fad2aed461915a0dd085648239c2d1411110d1221e2334bd93605c6204442df3bcb69ad1b90aff115da379dda9fea34878bb870257a589934bcba60ddec4254ea689c926a567532f33ccb67db9b813749626926600c0e5a6dfe3b1c491bdb455b4d30221887ba4f99bfb5458acc73e03f132629d072a2b6b6bc18361b6a0deeb06cbae8b020478e858424456522be0bc6ae52d17c0b84a10d0241e8647189a4aeaf3ad5d882fa8e7ee0ec6445486404e6f15b95fbcbe5a708de085c8e6163f2d967bbfbb8ffb85ce14534900fdadabb70583064b8c1a012b91fc9537da08379361cd33848964955a50995b63773bb9d01e418f26f9da6fbb9c96920bd23934079f605e914d06dfe9b7b708f1b41c928c9c8f29a365dde1c057573d83d558fa980f74da01c09ebec5e0b00eb7f3a7c33477b08834b1f8b49d48c7240e33a0f06734d52ef9412e13e3a497095f27f7990f83efbd28863c3de27bc546e4d6afafd7b01eed064429b5479c1e7cc5ba07377c1f4bf833d082403b433563f4da02aebba32d7182ec26593677ffaf9400d32a50ce7ce49fdef18c04151c4f6c9e38755f815858bf9405d92246ee51243c3a9110712fd10bb730d5642e4215515293b5f79a39aff8986180b225aaf3437f176cc000edc781d4d69a703c6a5cb9ba576dcd3d634f4af888e5e317b3077d4561178dac303cc3cad16093ce938b926d1d543598465abd5816142bbc7583f141497d4883a40a0300e85bbce03657d401de62c7a05b16e56f03332f36adb8eb2e36bdc35c5e40093907056920f8e6b66e153bbe1de8da727df0424539a60f0dc07acc4d2f741be0096cc32e5e660f31f477cfd50b4b96854bd3624c65cf1c6575d0686a17e2d60bf7421cbb94c68040fa9a98c3afaddde91dc8e17452ae50e2d2c1b072b06701be45c070c03fc6c4153acc8713938111ccc6a92bccc4787a86aef1942c3fdf7d7c0075d666acba7391e4b0df535251cd9d25380c95ad209fcb94060d069a55bf0eac8666f2b01d0902b1e5c47f2c8692ac195366bb9a61151394ff8d115de5c32a34c241445951983a852166068c6cfabbbe0518270a475b25237f4e7b3eb87bb768dcdad0cfa72869986e1305c05b94d8877eda4f93419354f08cb174782d07a59946f726bfb596a6f08bb4948278ce066317ed861375fac376a2f576d972aa72b7f9bf5a72ad7e741fa78a4a1836eeb6f7eb64b1b991e74e03acb540c0931d0c8c715ca285ee47d1f32d767c080021972068e2533a0dde92a9aebf9e396ef034515513796ddeef8b0fa94a0014fcf63e640e52b90a07c84f65ba048db11d98e1622311dfd253e99674db300e5b4084ff3f1a1e22de7f3d4f5eaa7c8027806fc7a5378185e9849be4182cbb4e3ab8fe9f16b33fe759f72d152a3753da27dc22f2ecf421da04fdce75c0936eadbd61401a279b2d7dbec4fbabadd5cd1c3f0479f646702f4a85daaf9b1f723f32a77cb0ed350a5369a3bce34e8137416a12d4278cead71594fbf273f0640686acfd38b9faf78e3418b2e1f09c9c8ff68dcd57d28a2c19b459bb8bb834a862d09d9cb3ae7e5aeddd1d09f9c1900e0ba2651d5fbaae21da805cdfc478734e029605ed37bba3aa59221ed9aa6c026a66a61ea33aa0f1d12a21e0d5d506ff344c7fe2d87cdcc3fcc6f0f2c7012c7d48b9056d1d886cbd26a5d247109380f60d0184fdc6b0c0b45e19792cc76d7bd0f4bdfbc0fb733c46e2eb3e34651777366c4db09adc617db0771cb17240d4d063c139873b252ea96b0011013c7a6ed0c3d7f4ab2e4bd9f4e634eeae3f40c47519a8b48ad9403cac7586dd6578d49b52d844d903647367bd80246a8ac520da9a3a513ac48064e3f62561f74ed96124903401c8558e84d196ef5c971a478626194a3c0be98b26ba110c302022e8388f7919f7343a7ed510f4634fb33fa01c4cb3e824f3e2c8ab457468548a50425eb91b242e22dab91ec343866ff60b37bff88b8c8cc4cdddb9f925c03a5da7b9ed308200d6b2f7ddf6c26bf32b211aebd997c90a6459bd2663c42ba4f50ab548688fcb4e31939d04d40b385aca4602a451aa25ef60be179e372bfd8e9015384328daf1eaab161e3e3de5b11a5ba3d1709cb220a9c21dbae6047e0e072eeeb6ab9f16b16887032b62464f0c84180e58965e93ca1f528a95161b2af4a37678030002374350e75d638686f15a0cedcccb80885dabe664920e8f02b782499ce99ed8293983f7a9841fee29b8c5f94ad90b4bfaa3b4a343236fb14afa2734e10ba3f19fe427bd1401699f2966369b4a221fec10a3d1a0f67f76880b0d2661d2fe228a36d41eda91b814088c406576a0f36f2a1a4b80deec4d04bcca2a82608f59489fbabfca302865fd80a1440aeddd2b701f04011590009e9fb0146c61dc0229e25c12ec311b3a6ba3d0b44204a90345868f5d0d8ecb61773d11067a00a90ed80de93ea30cf18561727870c801d3aef3e076cbf542564e7c24b0b433e7b99294dbf779dd19572835a1f6720c7f2ebb248ed278fdac842f53d2799907c8f28ed930613b2849398652a729604dad3d640e49d757cc5ae723b2c4dfffce6a686ecfcd8e11928a7730c2aec1c65c94a01e1a6cd9c3761d95f8621db3b11d39bcc1428f735e0220c27738f82fa95b2a6675581052e6a0b67cca928bdcad69d7e60ed49fe8f028ef72f67495c215b8deca7174f5470da456754d788f2d4d2029b106788b97551b100b8adcd646b1b0dea71ac78b5e340f50445d53aa80be9a179988d5978fe3e034e2674090d6670bf6a38b33ed45f913c6c084c1cb12e17942b9e199d3685c6b3bb5ff013d8aea7c1ff2ba1bef85c1959c31ee6b07e1407cfe847ec7703d3ea2b1cd8ff5185b3cdb591f7138d42f4ff07e53ed5a68d8fa90fbf71a594ac497f4c497d599bd3e58146fe5cd4d54019f61f62736b156b6534cbd042d370b27e68ca6b1287f06914de0d68db277599c6ab0c7266a30a12ffafe419f37e75ef21d37282b7d60d26d699fc5424e6f70aee7265a77e3389567d787043a60ee438e05533b0e42b834fec80951e54ed73ad9b4525b4f06d4c351b1d6bddc06228724d1734b799ef056434337ff0328c6edb09cd6fbc52b2395c14157d07150e1d3feb79e23dc08ea49eeb8de948370e019091abdda55ad7e6c7c5baf24d4a6010abfa5b7f72332bfd0d0115900f0a7694d77f25b98d192886369ea0455967f2b582bf499f4f7bf701ead4af2eb5b85ec57dc6940ec262f11f87a3efbed16a1aebb4a3e508623b6facd94ae2b3d2f52747f9a3f5a848f4a478c92563a68cf71192cd2a80a4200be38e661cf33f96bda350192ea091dbecf8aa899c032db5d15bdf8f91142720b7193fb031bc7ad188a9c9b58f6f6a507ee67d60f7e4ffda6ecdafe96a30468934dd22dfd1311042a2d93b1b6308caa78b6ad5de65a9e17276d2e5fd45601cac4cc0d99419bc9c75e43e200e9772e3d068b3a2b279f2e7d63cb430b77e4062951a39df7f00420ce8724b56b35ad58935b4b846f20def0a4d65b8632a78b2a96c28ade129cef4150909c425b0f45e3367185a8b100a398fb237971a9e79e429096d4275fb044f859715c17c20a12b5ba49bc85ba8816dfb5f8843cede118cafe518f6ea4395389342e84c062c158f339ef594f2e9537165158bbd145ede106f899a0d7123fd98405f341960406da6c9ace1af7795e1ba578047555a52c1d92169c6debf7aae23a84a3861c9f278acf2eccf90053987a68a9472e67425dc77f6c08d5af30fc1aa54fdd91036becb5ac35020259e3e87b5efdc8ee933cf88d2671f7870fc63be4e094a3a77a50b17b5afc4958dabde5b6e1f79a5415581268e753991c46f4d0bc08ca6fd907ba493965f934a65b55eb1563dba61a6099815d86e36273fc9ba491147ecc4b395478d9b6c6750ba3adb047a24c879412633f4ca42d5380669a0c511ff21d81fdf39f74b31825452885891ac8cbe430a19f66f575cf8584b13473a4710894d066446b7b8e57b4c7d8b733609f8bf40cfa7f9fa9ead219b3bf3a87645c6917487aa54e3b173b47ec68a109b8243c0951a550c035a430a907e4837c3d38b931a19138bfca59a6cd6e391985488ced8929733474ad9efa85f0ba36e6882da51a9253979c3b02ea4b3072c728c4e3891f17ba4725a66c0c4288206b6f734b29b2ba9fab0c30d1a8e4ea3eede401bb50050775903b54d4a803fba64bf76b2f9e1615ca4e43ad0099ad8e1072a9d99a2264eac2856a6ffa43157d3e8afba032bedc53c0f7c58cf5b746fe4d148773f76c80ace478075a9f58474cd02710e2b7243f723ce2ff3af4933bd25b628d10acf7c97ff7cd05397dd132d63cc3bf741cb52885a0bdcbd627ad46185e231911c4150244e605bf73042ef3f1ea3f21c38be5c1e6e1f44bd8bca3c077d89949798bf5bd27663e6c4312fc2e12e962ea861b7d60aae9c29be9a4d3239f9501a2c3b478809a2518ddb8a627d1a382b0a7159266f2fc26f32cd149a7634d341f147b4a0cf1be2338af66e0144cd708cb74fd56046bef332a745c0a3713a07b2007c3dc24afaece2eeeed24672621b63a941a2217fcfd6ac7949afae9e40ea94a32304635e47856b504a1cbfecf90a007b94859273537f813477922b21a4f3cc4935de9596bb112c68234d7af5426e1e954292ceeddd293064bff737018661ef8c6b433cf629307b8044c76a2cb114b041b7a07246afd13a6b03757180b7f3823ca299d548fa8f933d32188415ff8274b5d8adeae80b44c0cb195623b76dada8c015e1d4707988cfe425f0cde87fd57914c06e1d4d279102cb99219c4e34b4e81f3064cb4ef76db8ffce4e6f8b998149833629811df5185aab32e8a546fc424a5e432954219106eaf9b9d7b0fd7b253f74ac83e671774fe1939cfd635dab7d10bfdda98721983fb3ef689820986ed5c648fb4ccd40b4c46ad0736b5e7cb223aae7a026ce233da1cd111d1807cca12cb9394136a626be8776a76c0243760c9d2ffab5cbaf39e86b81d91c6ecef582adffdf90752f0a6503173f77d043b64201156188c00fc44a66c6e9cf2e2691df46f90b17f574cd98886ed92a2a284db53a7e615bc43cbeb6761dcc48d0d354b502306bd8f79d8e1d3e5de64c134d4f3193244d9cb1aba9e5acddb7f78cbece5e6e15aa94217f3d5698253883d7221489afa90fbc88339fc6731a9bbd678e77cc572fb4b46b5e0e6ff4b5390eebb5bd36f830407214372b21a0c02924cec9ea9498d014e09da8bdb7a593efae2c3e7f3d67228ff75b008c52ef0d5145647eb007d313b41061353e4e9e81b9a856506bb6a2d5844675c81c4bd0a8dca227b99090a084a1297de79b5c52f3ebf12885dbd735eabc57957b189126f0894945fa56317164e35273355bc61fd5c9710db0ca706768e265954c1c86760ffe982dbe18d7f5ae1cb2ddf9309caee733d455d94c6954a866e04ae0f716b3beeec800db3efad9e4a7a6ee697363497aaab13e82b3d1e52527b3084fe184f411f5ed78099ff97b808fbddd32c4e0bc368ef81c61ddb2bb1e401c7e84a63a7983087ea32eec7960252bc7f75e7cfcd8d91e3bf7bf04aaf30acf19215d477f99e8ae298e89dce898660309d438b510ab88f5df468a90e355617b0af3d2cc9cd52b811111addd528aa48b0dad621fb0342c91df6e7f7df206a6f6bb9a962bb864b59e96946f1e3d6ddb86e6df2f5d53f72ed56a627b8258a1b732a9f2123a895002dba6c034a52f706f4be50e9a0a508eed7ea364a79d52629f438412a334680edd585558e6f033d775c63c2dc3fed296b880ce084c3f080eac06450db3ce3ea95ec8e724058a95520b0709baab846e956b8ec46279c7622ff6d94ba15b58a5b1405c9c8da808c857fb938853ad8ee374db7be254e48caff5be11dbf8fd06e9f7f6f3f26a91301107fc7d553ddd74cfbdff9ab06838f1b130092039dd44823e705511f0333ecee68b96709c0110b5a8a66083b6668b900f92aabc4ad0d4f2bd7422cd4f6583cfb90d6cb59cb79ea5c2f595ea917b19fa674257ed01943c0070f2095f3ffcebf526279ada4030469af82a8371080b9e524ad9354bbe9f2adea3dd650c1b2f1af022fbc4f7ec5e6b0fc76c284d92c900490a37a56e0a6186599e1cdda26852838041af91f38637c69a4271262fbc6d0bcb13c199540ab261141bf5f349b55c9dfb38c1e89447ce4f18b7fcdb3e7a9aba7a3bce6312ebd09c8ad00408a4ce43f958c45385faa445ac432f7816cc949fb62c43a174c4cf2d217a8b153a5e59c186002c506c488a294af1e4f4c9d650d29abfdb6bd80958b1c9bccc23c47b2259793597aa86525618e876236db1cd22c8eff72b67fc55aa9a8023d57a69af7efa9728a4a57f11a48e282a146e444febf589e863276095daf1fdf854bce445a7428f7cd5ad1418ea483942d83c56b47e7b90d99d8a6cb5c29f86902a748f09cb2d403e21d1a803e057bf3e98c881e7dfa9c22078470d68c0f9378967ef9dd0c475b8267ad1fc08acd8593b84c9f1de74e954ff6175fc2f79ea09422db35c036d58996af3794a31d31efbbc1bcb5da397541b888b60ffe07f35bac11f252b917a4b09dbfbb73dfd73e9132948168d2343deef07f0d60d64eb98b923faa8b23299b9e443a259ab1ad6a7180cf6d9a969c45e9f21d285cf0ce0dfd48f725d60540e842972c583af240193687ba0d6702f9cf9ab5068c44d164ece17cfb63f8a1b6e94d02766a7babd1d1cbf3cc39e3a557914eb13b9bdcb2e9c77ae92d31711610eca36e0e3f668cfdae1fb79ebd0a29b388a5b392cef336f57d1f102f828c371d7d629ecc1c58ad38b87b7ab898800d22ca0b8ab6d1de409daca541cf700396efb37df8a98cc9c06abed9c009cbb4caa980155a9b5bba12029254babe2aa5621a6fec1cc200d6e46f3336f873a762c102d465a2e418119833e4d29fbf5918dad6c8c39b7bd839324531882d1e1a0d4ba1c2a05a78078a37fb27604cb7230af3e454e546d7ce1484d39e66dbee9783206c42467da553e3174f4c5f3918bb147bfb9a3604cf7043d22dc3af5cb8c0576ff2d70d185277db393c7b5f0b23610c7692a7c3127b208d70b5914745acd1bf2bdb165f2c6aeb3a9b5e7e64e12ee54fb7743ecb94df73fb60162cf9220a2331eae6c5259aea3e1fd9059943faa81b6d0cb56084b8b3588c7ee95537cd6232148ecc33ec8d442da68cdfa1af803f9c11762d67499f1038e6420d7cb498a699ac980a0cde09a03f4d0ce34e35568a4989cdf2b155100f7d0e03044e1a5be248d1d46c6887768b0158832f37da36f7eb40cc97946d94a3885352387d27e7d423d6cc3ce4acbaa43e591c6604d2e3bfad4f77e693416d07abbad9878fd2208edfcaa4af1452aab9a7ee6a96bd20bd3bb739be6b0c126ad135efadd13efcd46ce82045321e5632e9b54ae05af799d94162e312890ebcb7b159b31e45381fe53f071352df8724d0760234b0897b0a63e2dc0e1c7d08b19e5fe96dce566f7867897aa6485152b1f87855d25783cb22b17422151dac56ddcc27ffba2731b1b101bbfcde6214099878843c5ee26b5321a1e6c28d5c125d2f1c66b1bd64d02a162efac254be44db4acfb4fbd601057c6f2ac8f019d3fe7b4f4299dbbf473312be7b0d1b2191cce5961926e1ac3ac2f671a01451c000e50277f90b522b59c11b059cdabca24941ba1d4998ef60c5e92f27f38b3cad5abed6aa31210e2e0f82495f6776a795cf7f6db15f4fef28023dcbfbf42406e7ff2eeb8cc97e0dde33950f07bd87f2e3961dd9d8d3cad96b2004d563fafd5613d0ebbe8cdb827f481951835ef1bd9dfad54c968e78d9c92ed987c99e184f7c8e9301330fe4fde4603f238c0e9a234b5cc3ef6dc10c5419ba397f4177542db4e2e27ebc9efba5c00cadb64e5b0afeed5c890eb0d491bb17a26b0957bbdfade4f7e649de969d0d5bd93f53c0859ebb98c4c35de6b95572bd4148d79f8f11ad8047efbc20d65583a20fb4232cf8f03ea22a73142ea19ddd1d19326611270da116d34035c6922f057e432469a36d016581110d3e39fed20bd607974ca6bc16ca2edbf2a0b7e533502d319dafa4532830bf9dc0f76b20154e6c877debedb0124402f3d8870d69f391e23f6c4c0f264b5eb0520406a5ddd64234e54aa5059fd158c991ff90b8f00f026b8f5d9cae066282162346307cd5c370a78ffee50e0665379fed66c7092eb3bfd5e704a34b67c24b0b25b5cdb6b656b4c362d4c3adee2705ad860af910bceccb78105eaebc23f260a848f5c18bfde7cf3dbe9f0a5ee1c5465091c86f277f96ce91fd50681d291415e3abeba626aa86f9bd9337415eec916982af5790e5c04f5959c27ab3f5cab8ccd0bfe83d376e5018037fb042c6b92352e8e10fb7bde3518b11c995a63b091398de5c5ba9b823dea816e121f06d2088622200eecc529d51a9de5e97b3b8aa5ba4f745474f7e3cbc72b1b2ec6363a9c48d94182597d92bfa49293f15dfb86775acf88a2381f877913f4af0ace631e3d6971094bd3f474988ef18d6f38ad92010240fe5015f81694a1a39bac936cc650e84492ef8a2a144e6a8885237788c4257c2e549331a6431d75dd6c45c8ab73c4e27e764ae56650d0ba53b6a07402e2889aefdd3bcecc911cdc70729566eebe75c26b026cc845efc5b3d9802e32afcdb9f16ad8682ccc4b2c5c4d54e1365b60082fc58c25b823cb26323378900c8a53fe9734da35386abc2e75d92b2ecc9e7e9663fadee76810e9f48db2872c59eb106503af95d035018cb1cbb0c444deb95400415402935793879d9280a651a622ae2b548e5c026e708247375dd965cce422c5876b8622eff59e9e712eff49e275d2fe6e01150948e995a590c60c0b7a55a86a5450d0d0593a0e4e87fc932edfafbe141272be1aae806854340e04b73d4cd4c3c4e91f31baff47d07f4a6e947405710115fd8a6660cb0ed39c568b48c857658b1e33b06c2007ed9661086cec52026721ce680c9733f13e9fad9359847f01987ce29b8aa720aefcfd251b8badd13561866e6c5017877959fd011abb355cefad609ce1729961727de29c129673461eed8ce9ae252eaf36fdd880cd13b89c44922095de308538615819218fab8529e5c90e3edf99e3dc3d37dcf1341bb91c0c44db44474b8d8cb5ed3b790497f09cf56878abd02a678c3b4616494470b3c7e52d048e7848ae84458359d93a7e06d4cd025988f4ae3327e3384445dd0e5d1f5546f42e48d7ca6efc5bc7b8e6dc396ad341460b6909f0b31284ba4ca46a995802f068d259f7ef8a20c6e8e92441dd58bceb3bcb482ac9d5acf2a9079de97beb8c5aef6f36d7163eab25f2922126c45c6e853128410a1b22d2059e4ba35f43eb7485dc948f8874ef402a5fe507d2e77c7969838bb94c2c42a7cbed25e935e03009ccdeee89c4218e742eb7cf34ffe5e877dd49fceda6d7fe1fdda49108d404c35d634c65121898565eb7b7db51d109143864433743047937ea93d0456216aa02dfa38f39028d38e2690f290d8ae6fe899fd443af626d206359f8fc15cca3c977b4c5ef860bbb66d66edfa00f30a6b1371697777cdd61dc63d823991073367bc155f211f806e23b6efabdf91ab00993710f820d2c0a217c62f7c1e21d59a693022b8eab767caeba2f2503ab42b2c2239c9f6a48466e027880cef60c0e5e73f38c217877bb6702b907e0687eca10e6b6e352d6ca1f10489694788bb3b00e0335cf050458e0b128756ef5a1045a604fed1d090a04c2f2eb09f9916ed24c17c43747dbb800c4b39748eba8a5ae6a0a6b21d702647b151749368121ebe86e523ea9369ce9b6659cd0943b163a35831227e96691f77d8cb240de46cbd463880f080230879c21cb3e3ea85a00d7fd65f2af0da32f721e86ece554f44e8469f19f220fa20eb9739721fc9e4c91d792122ee3f3b8fe62bef6a3bb42d2a0302c43d2f506da9effa50683691b5755eec96846b49c65853e407133f0ff8d4093118f043e3357b7b2ab13311d4aee94eadb40f350674d94f16d26a1edc3df8640b4394cd94d84f29cb36eb81a0065a074e32e3804ab665c6c104b6b9fd75527d5e96ba0b49c97e80680663deed505fcf8a27f1b52627a5416524c00e706029d247159f5f8b758aff87d18874f3088bc96b73ecdda4fd372a7131ddb4ca50456e2a986829eef8e6353c962967934593b1fdb85816c67a00b2215c1c2a6da52900eb235a45185e1317df6ce06476117a8f3717dd7e72715f7fea02d7826be2a790d509b49e2d2ad6383f78de2539b0bcbc83761c9f516c97c382d1396b9366ca112670d95ca0628127c116ead9f4c4cd8648f0391b2b4e7af3fd87e23b761c666d281505e73c8709fc8bbc20dbd39cda25535d3ecfe4fba1d27de3e2f71edd5531ac1008bd784cb3ce98e58a319e51e167bc5ae84ef94f4113fa88d5edc56d1b869d6e41f48691f75f070161bccca0cbabd7244cd7957066e530babb90b0254d72bed4872b86f88b067bba3f1d35f65e26c4d4b7096ceda9dff1a211ec0b88fddee89e825837a98405414ab6b800bd5009a2cf01a1e77c4ca85d60cf9da52d62096cf992c030e2d0adb458f88fb06741b18cf55b094beb9c421e95c79d873a7aa5b32ac772f1836f99b054e95b2637f1dd9756b922e56c5d276e684272738e9e5ca2cfc987240c7ff1996dcd090482aa532bf395978db8c3733016926eaaf5d213884c3104d5ad4ae978bd2eba25ade47d70c8165806073222d9a743ed7916f0c00ac4a159f0d0287bc1fdfaa962f4fc89b5547e99456026d66b00ee8f651d56cc7e1fadad01ab28d282775053985fbef1bf8622f5f2c2a0bbcef13c0c9b2d2a885fc844c38cb1ac1c93982094b486bd24d4129625fddbeb124c3f552b5a4c9b8e8d26151540c557c5490b661720b11249207d6de68332417c81f76551f8c1f808e4247fa49644eba0f86cbc34fb210dca2deeed331b771a1e74ced86bb0709a8b6b57acb5c869447dca756f98b21b5fc6b94f78192770da4b42ea2643999663f77e9c74e81a149ceb41802444cc1406958dec9041fb8ebca386ee746c63afa6b76f424133f06c233ab1d5fd76e0c44b95bdd817c557491016e198704ec12bd70d396a359036a368e8b44cdfb94bc5959b99cc155d4d9c64f12f26d64b3a468c790ae4d90b36350fd7684a9d1bed3bf2c45288e7e59db1360bddb03515dec94dc0c33eef72dbd538e2efcf3cb6d2ec451849e65f90d9ea84c3b0c744c08568435436780d57aa9afc90b23dc322286b3f1cc4e0b888f9b6912ccbe4450524777cbfa21322b535da1264a5af6878aaa3c90b4992dc83cb75f33184e555af49dbca1f36799e86f86b9c37a358f515a0eca0a9e63d16bb5dd174cc0e085b360c8e7d090e0d6c0edde1eb8975c38b6a7156d6fa4da990c1f1667aef6bb571e86fd614f8a4d89144cfd8c55653df304818e23a492da4b6b5c8b06e36a915a60eeca8c31cdfc70bb59f1829466ec2d21ddf28ba4ddc79745557f3964af43c0a182dbea4df9b05d1abdbf8ba04b8f56c4d03531bbdbc1dd44913cab167d5bba0d33ac424c21b195dd32bebe0cf082364b8e5f95289f0fb72d3f123bd5c0d1d2dd40f28709b8a121ab8f6ab528c423e799ccf4028d81ebef51a3e672c08f26ce3af3224edd504f4a5b8fd84a8a8209fb60f260fa98d9057eb7a5e85ba20bcf8e0a7f52a6c4794cd9ed6c679b699b0ca37192dccfdb60e3b1ab00618f06ae7a621fdff7844e18f6c8bc09ed704c776be3962debfef8c780402db8a4fc3e1c78d1d6a64001e6f17658c3da1ce68946bd57f99dff91cff007be76e43bd977574a15d1c4b8c516c3a98ec2c080f70d0e80a4a3a9f3a1a2605c5d2f48a3a402f54c4d8c775a9f4aad45907f011bdf45dab0977432133e19f43ad73cb58818d1a874e80ef268e2d7bf55cfc331453934a0b2cae876bd77685eb245ab1cf79ea5930a3f54b225fe86e710519176f6325fbb7ca22d66cec7c2d4281e5309b64f57543a3cbe7d2f7985d25eca575ef8a6abf21f50331c4e18cde2a3f0ae538b78e36821ab1b5661bf872acd48e52a6243abe4e0fb922d281e5a2b874049a33f62b42bbaa2917d45088a9949e34ac6efaf8e7b6378661f630c3678c7e99b4ab970d4b69c3578ac98ba9858b14a447ff76625a5f071c7bcc1ec0e64e7a51f7c7d2fc9b2025a1365d7c8b8578688ae10e491755885113a4cdb8f7b95dd61e887ad1da3fdfc2134437861835ad0a62c5bc4c6d9530982416a793595f1f1caaa94731358d58b21a81c0603b77a68f0645b487aebb8f540973ee1f4057e348d12f6573c586533d1706570a93a992da4122130b172b6999d301a4ed3aef7e472c30d4d05f3a30ddbd578dade3eaf1670eeba0ee48fb6740f37673e705b530fc587d83cfc52b225ff3904f8ba5f08f6265624d832b70a8780f155ab537b62eb9a8a52e784237aa1cd3a945236640f54bc688219a201831c5c7d6a96325d6ad902a42e3100ad6799111751a5b9b2c9fb5ecf71c4714fe344bfb3b2b2e0054602363acc8565d063907cfba6e9276451b8d39a8df56f44766d2ec384f92fb84487347113586be0e419deaada36ce29b2915ca1ae8af37e6580fb330d21dc7e25fc5efd990401e820d7c482a67fef973e8f348d726772f67b97cacd1e34b5c4b38c0058e41035a1ce5f0d5eeab58e25a2ba26db2b2de7636242e0d08ae55ba4acd61f78ed04e455","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
