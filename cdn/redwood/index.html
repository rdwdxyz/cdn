<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"765912b3f340b502831ae25424de50cb7e853940b427cef4eeec07bc6a1a18e35ba028aacdf8590bd5260057e7158db02f32d69ad2a3507a731223536e316bcbf510347e0fd4afe4153eeebfe11205e50f0921a3e0d6c28480166e3431cc719d6071963bd85e32ee3a745b2ba7fa23ec195537af6d7a2b91860fa7d1391a078c777bf63de8f56a17e22dc4ad0a54ed1232d72cd1fb196d61b1cab8d1030c36dc41b8bdcc2d6074ed68b25bbef2db668c0afd3d0f92ff14ee63dbe48d4ce8098b644605e64fda135ce065168601ec284a6ddb6bd4407f1d5cbe430c8646edc038250825073134b8c9b756dba36c1f1ee767d8934ecdc32d81c3c82625a4774ea31351d045883343d8d454973c8fbc658de159fe130990198abc9b4cbbdee4689a0b81f3358331231abeac2eb61374a82de84c544d98dc90565768ce3546e0119460483723d2eec55b1d6a6185f92a8b96b30d763e6f29d224a813fdb7d5826dd76d2c293631bfd9516aedcc4f6e78b3a83e28bc58cce323a6a24f1e35cc9e9fbd80ddf8bf14d826d1e318b752613be597a18e62b116ec7319a3ea2d8068a1c4d995c183272454f82c58055da4e4dbc26a70ad0dbb639551dc25462dfd01124b0865a2987d7170390fd6584789c38d0bb5963a466eb31bec756edcaa0273f9e25a80b0581979df140d0b58a61f15783ffcd613fdb8d3f14da4326abb9882140f228df5d1be37698381651ded56a7660e50eaacbf29a19ae5ae6c2ecf7788d388ecc2436b2785c150da0f0298ba8498700ab10e31aa4da627b0b8a57109fac1c33c87357b883b8cb26e0c2941238f0a5b27329898cd14ea47ce1f55b745a20bce443773e030020f0c9f7bda29f75fd64d60a9e78166e1815ae98338d86364146e61860b26ce276eb616883bf78f2e748b547144c3e965d08516afbd91bc46ff08511c701bdd3b1dc8a035b15fb25690ab5a2dd90cc8e8a34c4fb73eba0a09cc7b7347c0fc5783f20bb2e1cf0130a9ca294ab2d2b2214715feae1ef5fb8b0b7a1a6259123fad9d59294e21218034eadf77ff2ed2af6fcb012df6173b3db241832fb03016f8ccfc6bc4b9a5b27b19c635eddb85d4ca165970cd67dbe2b1c415c71f7caa0991cff27f99045a6aef14ccfdcbc3364cc5857f34dfa72efdd5e5f658405457426f6d260398df401bdf199e6df0220d0dd5e0bab14bf27c2324617ab35d97818419e506b6ca21dde09e9dcf9274c57d642dcfb7fbfb5fbfefc914b218b4da24e74363709f4c9ffccb3a6267729d834c1e72cd012c020ad28b7777d29f4752022c9202ee4de8afd8432400f755258af2de94d0f95bd03595fcbf25715807ca2ff81d03faa7f395366b07de793725db5a9352fc769eb9997d3f0575422ce3f9690c450149d7e97501e46f5b49f47fea1a4a7e9a2724389fa5b72a683671e2c569fc87790db3bf493fde62cd8874b386ca99459fb2572a19a2b45abd085f9f3e738c8f42cde4107e6f6027055f6df11da15ee420d50b5308faa1f9c64df9aaa3a1314bfdfeaa53cfbdc746fb2b1bd66b048238cc6eacca0f9e31723a89da4e6f8840839ed5bd4bbf5d83a80991c55d96b0d566bede86cf0585ee898a4bd290bd99f65b9b9f20a1cabf01e0bf84b35ecc1755ef3e2692c7e6d000619ff22632c16fcbcd6b5ed89f423aaf594d5a2412b20025378dae92ab08a83a440949590156247c000fe4f36bb60a1c80902b02aa5bfe3dad5bb77fa0e464f10b17c586716a2ec74936ee7c70297f83f19fbefdabcb42ab5ec55b38fb1579bf99301f96df8879b4ce3b56d82d4390005b5e2e15426ba69cd991bd461b23a1cd54c9efbfdec8df791b9eeb4f20a7270086a35bfa2100b286a1067cdbf0a21488fa59241ab8dc317d3a1cf7c0661dbc02f59cbf111c957207904c414b58cac4542e07254fa23b8fa35d4d5196ab39fb8fbf13103eeece8c78aa452dad5db45ada92489914230d011d247a6f9eab27ef31d6fd094fe8f9564b99c06acab7f54345c72e2ff0a7769b6b676f605f28476c16f4a79b58d599f1b3de917b389975b7a70e19aa7c151a8e165dcad7263a67a8d4b654ae4c0fe0a37bcc6eb81951cf18a8e058c479a40254002aa8f9cb64ec34ab528dbd60621ce091e840b4b72e7b63e35a49dfa9deed0af586e8caa49c1b61e5c699d0f212058ee4da27f764a509da48d236dc36a9474c759ad4d8669d9a537f05d7f0af428342a77db71d50081aff566f003355642d6ae326c77ef2577ae0e44611d6293b1b39bad20d1b372028bdc1a490fcfaee773f437c85516b67ff2d450c1965546e5d842ecfacbaa8f9abfeafc678e137e3a65740caa616c9304cff82e9176d86a1ad5cd8fb726dae3f8035fcc7a4d4d364f5f32f40daca9b69b0baa0452b08aacbeb0fec648e78711439d3bf273a99f077e2b9799fa6afba365c3b74dec6cbcd6c588b81556e772e198c9b78a3cac9e47d1a5777663bf8cc840c43a42bce6aefb747b5fae904f4954587d3ae0b47f01a990c9f50c0acaea8828e832dc0aa084d7836d9de60d5512bf18991d8f261f419fb1507237250aedc95653075345ead9e6ed043a574bcb91eae6e0bed3dcdeffe9bb3010ddd632913214edba2a35d76bd749dbd81ce3f19dd48771e30461c11c90b6f8b14ce0d0faf2f8f38af4202c0ee3450dd903fe6cae756a78b3b0251e4c31f73b224360bed376a461ecd64b695e1ed6dc1305a98259a92ce7c8a8fb48617115bca6edd90f23bcbc35c45ca7f5e283c369415b43b4833f050ffcabbcd6aee46074ce15c6df5e791baa06ce37ac032efa1ef90f9c78746964e8871d6678d10e5e10da2a721426b2fb52a8c9a6702a1ada13d8dc0cf0691f54b53842bd874b0251b2f990500f2b1f6dcdff2181ca5deb770f5976c53042181dc029941b66a0fa9433af17ad8b9112266a2eb5bb417985846ea2320bd775d443d7f02a1c6e62c8cd9ebd0030bde6fea3c8caddad42ca5eb6da4e56c3ad4ad3e278ff49da0f57575464ce5c7b02aaa04720387bc83c1a19cac92af62133f95f985d07b37a84c0afb3e79df6a9dd009a1502a9ccd029caf9af44be99f52b8d7ab5b79a605c657da13035f0952e6cbc540f98e1fc10d5565ec0e48b31916acd4e70834e5108d13865f3682bd69cb27d92ee531c32a8588a373cfe00fa4c6c5967fa8addbe9ddca955efc9da7bf05543b461b574fa96cc5c8e6dd2b60563891e0f7e6c34da1e2abd476781549cabefd90c4a0cd22141ff223bf21de9efb332337604aa6a42e19a4fba6d05666934ddba8e651ae3a3b11388697773fb78158eb8fe8298883d1de2f91f1f673eae35cf1469e19c874e7552fdad14d6faf1127c6d99248f78d09b03098ca03c224dad460e086e8635b9bad26d555f36a14a1d5b6125c66f573a67fe7b42cb0bafa8a412671430bd87c63d342c4bc402bb4479a1430c330b3bb58085b0320620a5127f2687fae200bf562d9aca23e16979f3ecdd9b97d983d1a3d6cc16c028f895c25e423448cf8b6386222d04288c70bd599f5ec7532745183e2c4b5896afe7251166a23be87df697487e2f15e14670c926170f597b680f5ce204fbf5cd5cae9f9430dcc6fa57c9d2328f7cb872c725ca5f926581bf32f84c7983d537ce292259946830b3c66d97fa054dce27bc62636c0b1f0056190db3391a8f67d10e28cc767c25877be3138e54385146ee6b5e6275c0d78cc9e918556c373ad73b23b9fed43d6fd9569189501f99d00184cd0bd5814d877b3c995f6eaf5c3a662ee7cf0b596cdf9c84521314f40ea6503b6c0c2dea777f849d2eaea62a39ff0df5deeab1780133f3c95e5a8217de57955ac424a6ed86a2257388ba393ffff6769fc8a7e19ed0ca1ea7cf30fe2b112d89a86327ad23aa87c781c0413db44286c695cfbab8de1685747c854747a4437ac756b666db9b343b5102e0c81d1381a108fdede36e6bce6f76e4a2a5aebc0b1b4f9238163af98c4d220b488068d7c546dfd7eadd7e77f6e24731ee3462e260cd8806ccb32d7dd80cad4f599b8d8720b64518dcf50c5f9b8df54d29200d98e8c1af668b09bc152ff3bedd2994aacf790daa30da397ecd76ca41c85fcfe1ad4d2a39d68077ad76d58bf82cb01b57696c4ceff1b94192a353df1ea36fa92ff1b21a126f9d5f1a39b4724f61cb929f00f536a212c61fcd1fc9902da243383051faaf8d85911e51596e8f925e849fbe39e4f55bfb82d15702af5911a342913bebeea709592993dce051092dbd353e1b00d720ce8f323ba641b2bae55f08b91fa6186768f760d1b6ee124be1851771275ea60e3bd3c314f1c2331bb16d1a8db61b22027ae7a0454142249ca117175480f496b28f085aed0fd36df84bed817d6570fece7d58f66501b6263c2abf7ae60e05959e671348169b58336b0409f5de08a23e451d37d2843e02ec1234f07f2fd9fad5862e14d666fdc979dc3eec729f70d249cec9843be54fe7980014358c5a04add7bc0c429c5965a45ec1662326c4c1f42f392b62d57ba40b239931e374d7f1d201a1d998577dc31925792c26ccc63980cf672861282030dda84044d6f3bc6bd156ed238d75bb69c07ba28c0b193e65706fc1fe3c62776d25e67631a5b3cec3164df6de6c7ff3fc7e4d2c3573329fdb19d75e12134ce3af667e5ff96119c0f6d0a11f3fd4a5f3b3138d9e6d42e7073f52fe2fc2a23edb5b47f9e00e702add7b495c6a712d701eac72d8f973000bdd0a242fb89b1cac800352ac4720ef7fb13d38ddc7f6816a479b716baf9c04f6e16675838bd4d5d45de5c8c0fa1cc40f6a9273cae92a95b94e6ff919049e19f6385867163fb115dcad18e813c1ceebbcd7cb6c4c1d6544dad81e4d8d7446497f305f212085be9e0c9d0741e13a830bc8a895cf1893d84fb214e67f3974aa7758cfc3c360706f41d7c4210dd80a83f67f5f901b79dfbe62b34a7c4a0e3d720eea9744244b84f6b44216ef6189ac8d4605a84fd8664bef7cbd6d9362208c00438a01c894ee3bf2edf080c790276c769dcea299fccf73e7039e263109db9225d04b6b27f734e33d6bab491e71cdba4d9d09807e0221343fb5afb6602c61e930978b87b502c37245660f9e7bd33dd4cd1f43ac9fd882b06dee0f4037cfe4a919e5e6f52de056c7ec17c651ede3ff3ad990626198346d5733e5ef75d64c7eae3f21ddcfb6276f93ed62880fcac379a5ecfc4a144f51527b6a472f1fb25ec68da776aae3aaff286587706d142535839d2f2fec2768eb920c2e3fb3b201c199cefa7fbcfcb3b44ca203e849935617bb4237459fb44f5a19b6a6747d32a59fa73938aaec71e1d08119f3665a859f07208ed984bfb4732071152592687792da14358654c2e9dfe003f1697b71171754e7102356e64f2f7a8c3b7f8596040b7b4629b2fe3705b5ab60d9991d3aeba5c2aaee4130300306517a12ba0eea514147bc247b7d987b5a6c3ed80cd6328af662b43adb829c04a9bd3de2cc7db59e7f5b09cd3e6d4c30ef52e39293f5aa814d9e0cbe297ecfdeed49011384b8a91eac703a7ac862e942fd3d0fd8d07d4dadc06de54233505848b5e39480f06ca516372d59f522837e5994942023b42e2002d671148639730b19a18de923f68607f396090c7c088e175ad2113a15d1d8f563208c8f52ee12322d78ca90c0c92525c1f8e40bbf73f007479ff2aa39544882e97b6c932b96d64b2b4a0856f81bf9ea7aa38993adf6b6233555346f769057ac92b1d5778c7c39c712b4619e967d86403359362c85f4bff95e95f81eeca50dcc5e021dc65073efe852664cfe9587b34c0840dc50ad1be598b038f051e315f0ae863aa0f6a0163edf86da53edcffa8ef9999eb668e3c06fa6797ebbfd1b7075c65097a2a77e557e74f4eed406ebd9ae9d09dd28382ec5a354836f8737cbc961ca60b6228f71a48f1ef883b3983f956042efe63a89dce11c58306b62052b3472bd420e7d05d7395d3fcdc2a1b309bc9c729256d380697b45fefe2343b2f0909526fcf35328b29bced3c6d60e88b69c5e9b67c6a1c4f34d9ea77de421ed9b8ece0a560089712c194b309bcb93fe164311fd76d529f9c37b6f214b95571714e901b9136deaf8da4c8872623ad5b589181adc79e5a2c1d72866140c61eb7f065bc291963d4482bcd2da4453926ac006c627ad9e82e60547f66f88c3ac7838d09536ba481c09cd16683ed6e552a69feae862399a83d5f0db97535ba8add3ec320d5d82307e9d7d3782dce155be6ac92a3700f8b81e61117baea066eeabefa11ee6c0608870c4ba5e113892614d3fdc4c78d02668aa78818ffb7e5f8b858529688e738459e281c5bad5d126077ea226dc81179f19dc3548f80e0949e000db04b013d8cd02d8bb193d83dc3009922a776f54923cf0a73045aa9099c5a7f151a8f33ccfffdf9e280c48080f2c47b05cfa6cddbd359d38eecd30e9047acf32d89f5c651b0526232723be638034a2975a9c577f8fb0753af258e8761c73bb5e7dadd72d6cacb097edd090677bb9c23c8f8da57058c6b8094a7292eaba2b3b808027de2c4512130116ec166fbe7bc571ce04815f99f6280a9b94bea9d86cfbfb73a937ef270e40d81f220df4408de411fbbc2787e90c61a67eadb45a068b3970011191f33c7aa1f0f2ef9f9981386101d5f9fd4fa692151385cebb8da7a1bdbeecb54eec7094fcc38df3fda63a6b9633bacf18d62bbb5fefbbebaa22f24f4e787ed83a181eab2ab3cc54808b12a8bf01eaa44b48636fc2577a4a669b12dd32f5965bebcc8b0f0e66ed2e82a28837bceb128ae486ba10191ba9f379d212fd45427e495dd753ccbcee2d6c9dd4885b7b180ef7d8ad48bd914e61763e119249ba0316de58714b51c0abb9cd74956ada0a502ec13893fca167df118df15f1601a28a33ec9cb8f4735eff46e8828fe0bc665043988ec84ec607b7e4b4f3f84d962fee47cf2fc9fe6fb527899e3486a8863a17484c9aa1197ed8b93c451e85989c0b22fae01360be25c5bea0cd615ab29dcb7a4b852ce2f4b3b9a678e27d1649eb8d29e7f1dbf09df9c3ba4baf3718b11f926822951f4e33b40e38c321b927d3091b48642936ee4dc5bbd09cf82dac369ce4b51818922945f9c242f5a5f74b51d48b051e9204c5183855d5d06cf2e194c30c25a5ee437c2dfba0af1037b2820a25136e66cc802034257cd0b99d31d020c9ca8e1659c2f448da4b52423e6345f237898744dc0438492b7012c62919559e61781a5c3a92ff5588b3139a663dc41a56b3bcc6c73926b4433282fdbd3a567673f0911c4a8d553b10b6a951f6a9410ee3f40197a1378161580268fcbc8377b9e7306340d0ba11a501b176841018ead02674c48d074084dd0ea086151284ceb5007db27b4964c92fe942bc008d33da12355fc7b083a29dd1b4d5817907522609829c2ba87805ec4c1fdb083b3c52582fcfdf7ccf83a6b1d6b0cc822c77864c13c2b8d00135101867662a9fea47a512c8717865fce92fa03f9e3cdd2098557381121ed9e1e03a89528e24c8b3019be5cfbe445f48473352716ebd6c6e2ca1dbd927475b7874e9243eed97d5e4c26310642644bc8c5c52a668da67ce3a470643adebb098ab978a358b4ed9ae22c2ae5e0cc75e35e19771bf232a7451b2f6d4d1b1dc0fcd87a468ee5f844ede094b333beb8ee77c26144d71c4f541c5aeedeb5e488635bfbe24bca0ed81d79db0e46f68918d28762a0f8eca0f5abb0c27ecf3832efbdc360fca94812eb93b5cbdb9f89b33768f1d6ca87e0cc7c8d1df6bd8e55834ae49f257205e394b9cb89395ce09e96242b390ce373f95b50dd479b5c5b2fd6fc36f4c2b0c0f7853d63aeb684afdd6e303d15acafe753abdce5652ca07462b79c12117dc29ff9a7c5e65883decd82bf77772f2791d2b87ecc03c5d853d2da84aacfa4342b5b05addbbc3eec310cf9d3e1baf603e700b4371d3545f192a38892202384f099a449f9e82d0c86973b7724ac2bc330bbf6e5ef4d0d73fd3dcf73acdda5f2e7c7105aff3843cf0c6a429f6d8d5ac4d3c666893f879cd5ee297dcbb65b88128d863faca6580d523252c955884c94fe939592a5b3e859f5c5d4b6f69a2acaa71f208fc76f39e03144c01c2b2b9d19f4ccc734e034f39bd7190c8a3c5358df781e068bdbfa71ae29992b665d7a5cde3301337f412344d5e11627341263a23b4ebc6819a7fdc7e13fe8b2f603e645c60e4038423bb563d5071b506b67bb0f6e70ac4f1635db3d6da8e9fc8adc5afe0bb8d0a1d89f8dc087c04d59609e3ab22121b8cd62d178aee58f34603fd140d61bb1bcfcf3b06080a930864ada37c561b3c0922f493644e5014c5c634bcc28b883a32ebc3bdd778c46f7bfb2939307a28b2522f690b6dd054920a0a6c0b14cf178b9b14d5482510258371f454234e3219254319266d9a467366029a6a66f845d503b022437db02d27e8ac547f8229b77d69ae8654e7d586098ac6b2b56136ba87506dd1b452eb7cb6cf63d65eca14e1f2aff0244d8f7bd5676fe6cedc9246a0ad84b72f0fdbe25133a2bf40d2f716bb12dd590e5743366af96ee22f01b3f83ab8e2bbdd427ef962d82b1dc5bc3b9edec7e3783f605035fc6ef057c7179f3f0b42848bddfdc4328d8bb383c99ecc472d474e48496358c93d6c62164074a1aedb19ad3d0768c589f04c313b14ef8c4422f5333ecf99e500cc7c51c5c34aa3a76d751188d169c38eff1cebdcb8a93d88da4e8c5213f7394709cc0aa23c53e7ecd31edbcf577c09103fe651007231561f7fb272ce400d19f77872a38d8fc3e6ad900f3904b45c74e984d02fd24dcd56cc83c05606335c8a47ad2e7009364d475e68e7a5eb3857547722c508028143208d219ae705bbe464a366eb1b820219740f332c4a2a12ec80451bcc5f2937ac84a5fed32efedbd62bd85759de9bef2f226b8ae21b53da59cf13eeda62c9940d838034ac1cb76cdad0d2332820dc8324f3b313485c185fc1d4e61d2eec309e2038df5abea3465a0bf7c356b5ca6eae3c884ffc2019a16c35f4ce02ce28ce53ca61fd14b0b14c143c51ab7236429cddbccfdd197c6e7de443797943cc9d8ba0f1668aa75e4b5f5397adf6839fe2d9e587df0e092e0c3456beb5607f0694b08998734812e610e31bbe8797d3e1a15cebe747df63b5359591736871896ac35020ff0d8cd56dfe85cab5aeba002e4d12d96a22726ea8f3fe7182193037deb07d4fd7395e0dee9d557c5914378cac88edbf0f5878dabc62da1c9dffda6c3f90c5400c25a2aeb1988015f10b8872a7d6a3b8f38fc33f3ff0b28ab606758c6df76b8def9bd1dab16f5f694523cbaf2abed5c730e55ca320e56952612efe2b62c3ba1e07d9d7c6822ed285286dfeb016e95ea2bfc3b43dddcd6a2afc9b54a90891e92c60291f00a63d3f914e4ebc78e621c45dfc3fb91acadfc3059a20df98bdf6fa4069c13698405311d015159fa5722c5f47765c6e5351947c3f29cb5351b1c8d712c55b8ded419bf15489a0181d5a405ce9103246f50b56138b8544f48402102421e216477271e25c2e8755ddfb9816a1e7b044b2ddfb1f614f812f76b5688dda8080b377dad4841caf14ce1c0e6c91374d0a610a9f4d3b8ea5e194af3501239ba879df34812130224153d1b9c356c40ffa5e44689fd6351671f637450a93fe641f3700abaef2076c392584f9ad4f148a12022c83d0806113a750c94cc0af456e726cffe67e4d40608cfeb4054b5779b9e8900e9fc02777b392b7de4bbdd73468e20d44b5e7e4648c8fe3555ccce56fe46a2450ffe6c86ff6f2e786c9da6124cf71486150ddc694cb5b24bd34c481428473bd2355247db5425b101072a405a6b0798e62a73539f4efed047d742d59ea5af42a1ba3dbffb96f54db07b52663143eca76f1e1a1ff3b4e8391f2891d8050913244bc6a7bc5794d7553919310dde6cd3a87b5575a92c7ce6e2b8332386fbcff9e97af34c9a44da02db7a7d892a9b6f83c48462295ebf28bd2ce5bd24b33418766e16a8b82ac1fe0f1bde1f14fd213b5ab601224649a89bccb1d203a59955c5d1851ecd59f28b174c793ac04ba2fe0c2b2fd0dc3345f71ccedf09afb2a0c5904b4b5a7e0cabdc428ea902745fcabce6a60b859ee317f759ff539aaf412b03743924ea5bea0eec55d7dc3761dd8c1389703f93babb904fe43cbd2151775d53b1091f275a61009895e81e30343acab9a1fd8ec221506eeda3e539213f03bcee1df3ed8b983947c86f69e2c21baa458d9eccf1ddb678ab5fc71b9b905b0a5b4149f975690d78a146376e1be903a386210f3fa8d3b26cdf233b6ede3d7ee3f88cceaae19de23ea6a79624c9e6799729ccd21b6985cba907f0ab114e14fd7a95addb96890de789e5ef5e9f2bc978911fed75560a68c46973d47250df42a73b1dd9075e1216f5f07f8b9ebae3fdb2488210d50c661c4afc4127a3cc6880c53cf04a7826f2f09493c633dd68d5fc86f5abf2d5f09491f70f36d3b665ad1e10aed6137fe96691467c7dd8ca291b3601ac8c6d47bd9ee16c569528da63ede3290dae5c263f75eb00030a01b0a723cf9e4da835860f1729db69245667f91fce6ea6533812b0b19eb7f69febef6614668d6577c2ea2612080ef118d8ffa555f7fbb61be06babbd27a2d120497234bbb5270ef83349ee1db7f64838b5769f9766e501257cddb1e2575936d5141709257da01ac435f4b97f34ab1163a5b56ff06bcbea8c8f3e83d86ef135b577fb8c7bb880b9a891c83649f218334c4ce05f38c91f40a2e4ef5c93036c7f62c070f906adce018c333d8eb091eab563ade612cd0579958c3689dcfbfcb5d34816599dd440977801c02b615b6156cd4fe102f1a2e7af21e6c7d9d5e439921c8ac6d4f04e3fd9b44a7821dfb9d80d113570df91cb663c843649b004969360f4f195052e740f7c5572201651d2256e82ff64009d220b718809d7d3375f5382482daf9cc02782f63a0e683f2f386347d36a468829e32ec79f4da6b602e50397e02b2ed1ace5b1cb51715a207e3b52e9efdea28ccb029cd53163b48e46e6dd7773856c9f60818ec6b1f69d0c82fd5a27a1c13076bd069cca110582fd3bc2bdffd512f0ab5f5d7a21b86a7a4556cc290030eb3398b5973f4cea903138cd8e5e3830d62b2703d6d8affd9f9070e5d080d55e14925658fb3cf2484808ee59c0d625c514180fb15188d7b08306dd8770b670d5c1bc291e0d1a2a9fc49772685db9fe25bb686724d65b5c6aeff7fe48d91f362c862c6bdc8fd6426f90623d86850a26a6d8b7db4f38a3ec9702a87a78741f666b1def80e05b3f302a54aac4371f7a82e9c1c6a09e5a2a9423d073dbe6579313cf814e3624540f4b998dfa63cd205a9c1094e0b13c7a6b10e32d89b48fa48e159dd1d98186788a4840ad0b494aea4aa4aa959687da5eb923ba697ba48094330017e60ae906297ebaa0d2b86f143cc715a5beddd0c3455a310ae2a490fde7f1d2f71c06cf44b33515f6f72c8d78a6e04ec1f8bc26ed631e325fd6e2e4ff4de879dc316dd770caba068633665ce5449c229f73485d3aa215566f49ca692ac625eb4f27eb583e8e4a813b0196fc7ca6cf0f302fff4c532f62b3d11fadf84814dd0f31867ab14ffdfc128508f31d7854dda99ddc96583076245e6b9c3ee2fd93ecbb78c53e9dad2f6629299d3a3c2614922ecaa2c4e51e8dcbeafa846d2dea61de6b92b0cd21d52d53d38df477290da4e3e01a8369e1fece0a958fcbc3dfbf57b65bad9c1f67a8fe84af316b889aa7aa198c47fc70a0bb3d5bd92fbb799cdd47d12f5e6a492acf3b5162c06318c067e2c8630472e6d52286ce1d3b5b182927829bc88121b0fef6d05736062fcf720e8cf2fe4a10472fb8070721798fdf1af1225123acd740ede74d1055e2f2756009165891caa130ce1d5378fb2fb0e00815773a4f423680daf54d0c9fb9a69ed77ed1c7664cb4822f9a826cfce9a861ade30fe00c4153e662b450ef05ca44bb4c14a77c45b49d3ce7154c37f7aa76e728506b235d636dd1c12c3a1384b64cfc444091843bb670b5abd81555a66073aaf7a852a82a463eac5a38cb68e738a6bd4a60d6bb0d6ffa3e9d20c356725726f91247e2678bf22e7c087165b2c98e19ad5d0547c6482870308f9c997cc26e46f3fda583bccc604781f88ab1bae83bd6509eb2451de7106017fa1e6d3f5914a2a8de6e4a7558bd3a449bfcfec3ef1ce9988084ec6639dc6a40d1b81fde19fd96182b4b5901cc1db5ce10cf0ba8618b3033720d458d69e5b43ed182209b0b2f3a59fb25b08fafbcd83f3866e0f012981d6ad814d76c579f5753e957f53aed47988447eb1d297f55c21598f6354729d5d086cadf7ed30efe20795447ce2c082fa49afd7fe5b9af01765690a2d344393b785653dc09a29b5202682df633393a000b856237173222ea0ba84b40f402460d6405c45a9a5ace4026db9c51167a4a00b4fab0541b726ba260c2c951481475c84b07951b50f779bb4b37fc141600034f5401fbdfd0a3d220f49f1166a694fb96198419ee2b1171f865cf255487d151c5c3dd5723580a21205258d39ca0ae3a3b0823c0a5b7936310999f1f9a0a3c4ba0d769bd8415b6c39c9e6d0b7b531590778e3ebe81b5dd0784092a82f359bfe5ada7ffdac3e98f1b461a3d60798145d5d94fecb17ed3c04bf5b98af0bbe9bf4321e648ed715d6b92c118e7b70b3880b546ac64467c3c2162694146e0ebf160466b010c91c3c8935e1246e4c0578fa871b435b7b4f5d2763c89be186c2aa8116117198135612f19799834ea147954053f94cbe3f149e48e9bfcd4a81dd8a16ce9bc4601c81e3ec3df7ea1958301edf8b2f1ca5bef3009069bb0493e75eac2cdaed1fc86456337ed64bc458ab892225de4984cfe5965e2eea2f92e31a39e19d3764a6b1f4a3a10dc6345f3203e87127f4b6fd3e22fb9af6545d5a6e253e8ea514583617b92e186b323001150d7fb5f0dd11ef0a069aedc854af17cbcaeea645d01c4fa0f09af8bffb770e44c8d398c6ca5f4b3e063e92354979ba0dcc1b3836174efa4b186011ce1a9eab46e3fd5d1a68d3b1a6404f69d1dd6344df2769e0caba58153d380a9c904c0ea78a360a231aaa52848cca4281b1be00d9eaa7c7d0a5fddf83d812c1c722f1c3c5b2fa4781cf4c87bb8fd68a9f075047483cbdfc74959d469645813b18435b8dfaabe8631fdda17f64cfd8c5f4aa1b0a91b756c219923df748fe966709bc1cd541551fc6b7884534f4676528c386c0a8a9d15e8abe20869fcb86151567b20e89006edf34b0627b92b4dbd015a1fad6f5d9a9358a3617a98f2a8b82a591143b4c8a715e61975c418e9d74cbdc0a451a745099e2948e220cdc9e26ef64001a94a409180a3a94d768c6792bdf6b6bed0e2a5654d3e942c817713ffa6ba3f8eb7bbac08f72326e2a2d2e78a094bcd965f2b7e4c18c3290f4a8139f1adbbd07a17c30153fee0063441b8abff8eaa4ddb1056a99db4f8c7dfed5e48629e062083f853bbbe08412800ab4b6f0aff6048082b8f62574e4c22f9caaa280744b6f6f2fcbb9bfcbde4a94d22b236eec45077149a624bbb4594e7b897c0c546904979cc974d5ec9a10d4ec2466720fd9b679a071bbab073ca9d6c17625e1de42b9f2a33844cf9bf62dc32f8fbb4f0111998af4a2df8fbe14d27edd21549ad4c86f791e06ff711a3d6a45e7875c2f32fea7765ca91a5c084165f81e693b2989d280cbcb770eb7e23f685abaf7c6f121f18e35d500326fad180f93e34af8d2945e3b1b36002422ff3881e30082b2c1431cdedfc6a495852e56705f102fd74abc42ccb2f989b8b35c17a5518eea6beb251ae29385e29575ba47f4288e6d1c1be49aa59ba5453d29cad2ab5e18bc73ba9848f7be307f9ff6819c8078e1c7343e4587b4750ef23de791883d826380ec788573f108d375f4643bb8cf646c0ebf468a15014097fcd447bce67f3fec7d77e62113857e1f7fffc794b6180bbe8f09a6e208addf11100e6a14a4bf95ea39f4bd4a598edf92d9a4e64241bf2d1b3eb4c15247546460a56bad41c26f385819dee3043d72342bda4326cdadaebe46933b14e81d60f0a583be4f7b0425b82ed9365d00a8daa6d6fde7812d7a6e8bf600d677a8569cfaa6f28b9aed9c3271e87478dd6ec3256f3d9f8aa8ae002f5d78e84f4cfa33acf1e1780e5d313868e8e0beef24d113b8d12be6fbff89f346318296a9be9fd59889adc74e85f3052a5daebeb93b12a9ac742d72c55f8742b3251756cdd783ca042f7cdb4f74fb3fdff0fb1295ae1347d971bb9374aa51b66cfacc7e17521e3d410c88774c5b6920ed2750aa48fcc13015c5cbcbff816ec028923221c7d3f1b1946b52baa88d150ecc93cede755f4f04fa85f60edf8d39aca988fce1f29798c95c695c7ff85e61700399a4e5fd7331865b9baa94ec3b1c86fc490e8d97669d1338e1e3c55fcb7e87ed79a51f82a5feb131089b7b8080fd725a364d99d2efc8983c512fd48c4b4a7fc795732402d8efcc26a52a8e0d777207d02b17ab60eea7ed6c44a83b1221b264c548d28c342886bd9764973618a749e947b425b1c444b5bb4f10ba29dc3830eedefbc7c29fff8e7f765d69872de6691b28283c75585fc2e892c8a325c1959672b4889f97f0a10577d5a50783dd37fd91e45ffd707dc07e0db2a04592438b68f26e770a265575261a8ef1ddf83f00cd96f73ac48b24e4129b1f8b0a00ce13dc266e56fc3fdd7ac8ee1f7ae2302fd1e07d60c6108ba8ea25119fd29b848a89a0e54a133787164ddd06b4eb77951de3ee912847e9b16dd1e228b2bc07f92f2ee6da479a7944a783e09ee54509d52a52f2dc73716933bfcd6c273ff91a031be7a5dba94c488ae2027d0172cf0afd9e5bd704f7af6224fed7d875e34f0fe3044d46da12fcb399c947e85d9c29733d0ac39b18bd75a78e665259be468c312813729d7a50dcccbdcf63148a3ab190b18204848645a72dd1230b5477da0fef2cbb4a996f891ac400de74894bbd8faaaa3ba41ec9090994c6ee8bec9e713385f86a1583b712e9c41f80f7b4ad7f04e2e9b083ec0d328d3caf76c5c089a24bf0bd3f1e14e34791eaf0ac71a2cccb9e3da9d0e503058621b6b2fa3a33d5c8438e0768ddfbb2006d46af00663ab4fd97a88c06854940fdeac61ab2549f2e430847a0f40555d38654a26c0e1016915ffd7460212c655d873c94e3c5bc3f20807c57d15f92d05164bd38bc6a16757246216ef60775e88262572c6103897cf78f470ff7a4887081c9ddf5ae8a2c938a9e1e34bd359fb91f081f0560cb313fe97b419a99859fe9f5b0ce3d8e0c9f42cd7853699f272b99abb285a8fb55c1bc67753dda733043cd07c76252f39e46e7ccb9d51e66d1b7a1e645c2908a6291cf749cfedf7650c819e045f17f87bba96331582edc858fb3b0d9d8a160a1378ed7ef29bd3ec9c9d66c8fdf492d06b8e84377e18f5b2a9b8bd5289aa2f9ad84bd061a5c42b0bf1830bc35762ed737de0e46908db2b9dd44d0b38462032fe4fc3bfea8c64e96ced7ca82aa6c70b7399e216ba34b801344a21058366c65d58c5a036259dd5bb6d0abe943637815faa0586710d9d941d0cb414e0aab970c8e893fe9b9878322eafe6dac6c7ac26f0cb670a348cc1142cf03924da241e86b1a5d9958a8dfbe9d736a5f8434cf2f028ebefabcf204156f4b928898657ff5dfb078026ac3e52ec0e0b121fd7cbaff0a20f73900349fa040d1336f29cf01572338784f75237ea30756f2dfdab43572646449f62766dd0ec36c1019d109397a3ce100618ed6f06724de17cbee42ae136edf5941d812e324de199c5215a071981a095fd94f16ca30cbbec5a46e6c86c0165072b3011e0889f38766af2725c7eac433c7d91b7670ac65336ac5055e69e7d9271bfeea13eb06af138cece5b8662d015009d6368f532e0375b4b478fe44fc2422012d4af3bd727f12d1ab97b08d0b89c8d64da26f4160e20995ca692d00130b8ac3453a8d3f322486e94ad4d4815fe967898ef495069ecc9f48a120e8dead1249eb6b0958c9d001d0d41808a849c0646b0c4bcdbb067e77a678aa4ce7eb01a2de3c916c0fee801b09e09bf959dd73c90a1f53663b8163045e2d6e34bca44ea352768acec52deca20077cf6185f76365e2abe49a803a2528daf286e8c283c06bfe5f1e905436d2d2fc9f76043edfe2c95cfbddc375674c8158272d00a50f5bd20895e5ba71db4e36bdfbfce96e669902ba0f972c9d5f9f756b8bb2ed043b0a0f380dcf164f90a71ef796c5bbdb175b56ed9d515482f1d787f12833ebddb0a0ccc8f8fa471178b1cdfbf9bb6882cf953d57970576135f28b21f18a401d1dcc6f2be0e36638f218c85a76b8510546b011dfac27c1c06ac5a6148ba54bd70b346f120c3f17e1bbae80d29d424ce2725f8e1b2a8d817a423a1525dce5178bb047cfdce0b52afe7930212fddd91593fe3493831034d7e911305d7a6327fea5a75aad5797e645e93ef29448420dd8bb4328415e9cee587aa19d4fc1fe742050481aa7f11e9e9d1a1c1c2f0be9814ed1432739c334abc032c8262b0fe7eea3389181aeb9b2ea381b9ce2f867ac2fe5c71fc37511ac24ef7f139e25a1dff92a04c8bf8f0f6694d53e3f44261e8347a0d44dd088f0cae66b8bd6734041fe70b4389e407526d87558d7c07594fd6b85da0e9b972853b966795e5e8dc1821f08d99befad92c2619cdd2a203107ff0d0cf5dc8a7b20c9985a8ab521680a198af1af62f77b18bc896810dc7f5140de2742539e81791fcf89ff6450b8103c348f6e3462e17e3cbbf766fc57974af8b4f52b06b91891bb2f01b9a81c17990ca6c37441f3f6284de83a64959752beb95a8f82f3fee11d923fc911d2b69729c049d7d8fc1c850183179739531e37e5a0590dc4768d4c2d583bbe4986de711c745a4fb81832e985d299ec017e253c29f4d03dd1634780b3959d742881dea2e3c49e48b637e7dc83c0fcfec3c4c295d0d7dee1615b3480dc12e7f517f2c2a4c3ebfd285ace47bf4b005bf969f2eeab1c716fc6bf4a6730ca9b2a8fe71b5bfb59c985df1efea66bc3772f157bd4c733222c2f98b3ba823f755ebf5ce27976e9575fb98dddd36f73d45a1a9f7ebdd366bc1fb6bf78bf3dd8ad491bf36847487171776f3d31a44cda66020bf944f5e3931071b9ef8dab7e160653ee600bd0dc66ee68a475925de3745c7c750ec893d6afeab85f79529e06303ad84a3abf536d219ac0a546c11b3bbad58739986d76bb28135811121b1a239ee9b2f58602a10b83b6ee8078ba1bd44ca45c852737f4ae2a8e049b09cfcbbe2a36de77ce3995e1ff26eb1f942ad54b4f93191ef411a93d3b0173d7d9ffe47c29784c0fe92d5bd823a75116cce745e0f785696dbcbf5b2eaf7b276510e1f3ebf99c4ff42098a91e4ac0f04c9a4d7f720950ad867d7d4496b7c47ac184bf6490c70abcc4837809848dee3d53b6c295acf987c2b9beb3968f211b1b5605d04c2f98907ddd00be58440c10a099b16739a4ed7856967dd0bfe48ec0ade00992fec9de728082fa9aff3feb301603862162f865e1469570d5b74f1fc9bc0e62f483c7444a72b99e21ac3587d914a942d8d77bc42455775fde7cd832334d65707a7b14563310840d04c6735aaed0d45188f8bbf0a4ebe654459d695418e360de2ca5f53f9cad3d6096aa995f12d3f5018ab2f4cc262b367634cee972be2003ddbad48877e57bdc460fe07b586895f479c8da7aabdfdec37cb71c3a29b388f363b2d1a1c69695b4bfad5523659950251a3759e359590740aca92a97b9f0292107ac8681830fd27ce108eb86adb3f92144436a9aaa0ab8c7b73b68ee68add5a0f4cf85125aafd591d09b8094857aacd4fb2b6d3acb2d59143c5dec043bd08920e177e2d1dfddcb715138258ac84bd7b546e5190f789940cdd61da22d361436","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
