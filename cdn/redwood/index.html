<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d75eb6c9daef0703f8b18fe89d29d049ca8eef01c84ae67a706fafe0d31fd04298544884129a81f33281ba7eb9cedb0fadde31a125704b1b174f318934859dbb954e115371971c5e95e5bc9005cb6aabf92dfbc532ce891a14e9999f965558472b498c640d9fbba1d85b0ae0ce14f77c71eb45459d6e62b44a03fa64852d6d68fa7fb58f83c6a0baa9df638e19b5eb0ea93b1ad79ebdc0cb31fb1178b05cc378b29e2c21e9a0bb189776fece21a66110ecc8ccb4a5713241ccce50afb128d6e7f01a65e925ac7819d1b2db55de1d714960ddb6da00d507648f61f1812e224bc7d3ef5eb217bd779c8cd3c62e71874649d7f7ba7cd2e18ce9ae423b11b95331389926409e38483d487d7d2eb704056850263e03588d2e4b9dac1d2e51811cf45353ec2aa640bacd344cb9094d63ee1cdf6a91f88f16eb9dec6949c23449bf963ba8f23d6eb90406ab3d6736ae629663ca3185ea356aafc5896cd1a1a9534f2fcea45cc9ecd6fc46905ffc8b32164af71ab185a8756bf9099990b9d725a74c161618c64c0b1a147aa2cd4a1c6860f504d9366ebcfbfdb1b8e1301934a5067573f004529d645be1b1e40da7255817681a1a906194b7be0634686a9f59e484f965e5b83b100010544f802798d0185422eb5f6eab37de9a48146777c7c1bd7e3caefc9d00941b7045a678e0513a0e137478c0e3e6f99e5b62a25d6a22ad2ee2007436fae1e33f46905a45aaac8f56d45ef609917661cc2b43bae7564ed540bf99ea4a248ea132c8ec7406541528cf1c4c71f0e7aa28f8e3d6a959cd4efefec7aff0e5275eaf7d79114b7c7e1e39559ddefe7ccb3e090590ca97b290f1930015696cfe956085ea6435ba02e27d57c0cf0f5909e4158102f1051f50a05fe36555a9f7242ab3eeb9bfda0983a6393294f28140e2e630d3cbc5c1c74009b4baecd5e69429a6bd8b6735c1a1714b59066e0ef541674b452cf415d286ee62d18eab05d28685dd178c4ca1d86f9b3313f77331042ce6261247e62825539f7c84ccc91a46bb9fd0c5c2127ccd9854c4f7a538a381f05ffbbe62c4e6c4508e2ce4316e388258c7c86b2a69261f2dcc2008887bfc4c2f0862788db81957f5530e940e46359c4ec9dd0fe71b45047f68a7ce5a12db1fa49445b9c44feab342cb099a5b97b821b082c8d05f9173793a1928fc7d38b605a1a27662f440f700d947548e6d06b70ac647fc24f138354b2cb4f72d457f0678edf513f739266c85df767a651e10a30d481186be7d3edfb76a98e6bcd0e857315dc2125986c3cb64a78579a6734a5ba9d539e5753bba635c8a18e61e492a7626e7c7496517352a09ac18396a9afa1d8710a1089023d6fdee9a1c63f03f0fb3ce21c27eb2d19038a060afac73e41a41cf7a36c096498c7d72b307163bc32330518f8f7d87e61aef1ae232a6cbdd8b6b8ca67bba8f0d9a1b0d8f93dbafb3f47b536307f26f1a80b89460eee38953f38765c855eafa2d9460705ffbeba74933a7ac71b74f3f07b9d53770a313054b9590422a9b6b19a39eab3951d33f000a5c5413020e28b08e8a26e9f5d3efbcf9c0a43119fd6242e4019f4d40331a5fca79b4b4696fa46f94c04d5ede1dba94290c93cb6f237078a5259b5da8025a66645ab16dd3a4297c21ec96a4053816c0a6098b4b84a3e0262615f7d52c865fea0d69efa56024b5001d109a8a758983722fb1b1420381773b86640d9b2b9e57eb70ac6f0357da4a8a25128b885d56ddc0c889eb68ab7ecfce46135285b061707ba67910db903355b448984d921fd19f0e05729305b966c6d3cd68c8856174e602f1a04e94d5d0e5d25d5777d2befd404406980ebfb81c4fe35e41523d2a7255048fcf5de4137d42eb8abcc1eb509b6f7de774bf910ccae15a034276acd203ca1bf1ada941e311abc36e072f9610ab4d5516a54b6e81078d9715c028d93abcfb28828450befb12209d08f6f932cc4445b018532fee4d4c121ab98dea02e09a25a88ba34a282a327a04469a696c96c7651bbeb129d0104d943c01bbf5875965b9883482d2d93cf7063168e68957fe997b66cb8729720831ae8682a53eeda8865b54b585de72b093512d784e497d0984778eea5a6ccf0f4d961b659748f43f2a6a4a9074ba69c6892fe0a93a0f8d074afa4c5fe80f0c845bb1bb16f27fcfce71f1560996e93d1c9a2b07c8a94a84ac91d74bb5e84423c1ccf4353554c08ec9d87921a5dd32e25c9beb10ada2c71fecb232e390d779cd2927a5e46be6a673e9e7121b9470a43c0712157da467bd3623d12e46f3581d32085dbaaa7d8144d2422e4c0f5f75db4647560194447018e9b0ca2f54521faba31df91c8ccdb119414e321c3420c8c8be3534b1d498bf139a0084374f6c178e60c04a7823ba38bc3b90a36e9d135dfe329a2bdea0b379378cf8eef3b83b1d2e70c2b2096d63cebe4711a44a637e327b088cbbf9bf844c3825773d299e95a4fb7ba42080f881e2350206d26098a115e1abe24a84431b4eb2fa6e1467e7e797d9e512a6196b01b442cc44e008be299749258dfb818a7fcc285d475a12e89ff4c687c0f1a5066f86d20995aac1896a158dd2751b32d312965f362743bd53ddcce4f56ae47a0cc7e7e6ec1c6f059f8c5b963ac8e1435cd756bceaf62f9b5972ad2eb7adc1d1a32662220f6846451c874541c03ebdcb081b94e396e101f3b62df6283b2f59bf91b4b9d103eecdfa741622a8fbf0b88788f3862add956eb067221c6a9bfb558a90266cad2ec745a5aa959e2ff6bd859bd92f8fd429d7bee1ecfdd47853b9686048bb00ffd7dc173e8c49696c40fd0abdb8ec25671363e0ff739961e1ae012afc4a326b74fcd2614b55b18e4a29e9d29cc1249fd09a27a6f6e2a51fc1a423e3c4b6971851daf77309f181ce89366237fc1f3bf3613a6b3b41cb9b7f087cd41dadbe4433775589f895d51870aad688bd1e8c237d3b65230d8389fc0d213c2b39f63551550dd3572ff3134f293c2a11180f3e2ee0bbfa39dbdce9d9843806b8bf03d0ea5bd9ce467cad014d0cf70fbf0b52cfe22c3246f69b97d04680818c8dfc44a052e4f4a7bdc4e4ef6d0c31e9fe7c02f3d5577c09acb469873a78bcd9aa51c111aa327cdf441cd3e90c3a2860ee8ebfa3894524b2251c01ac7eac41ebda95cf79cef220550bcf7d00edc2c75451ceaa01b85066d244ac3967aa0db61913c5185b2bab882ea5df3f1ad30e3a69905add37ab26ca39112780ff0de992873290beaf3402aad9edcf5bceddb8bd624fd533b4ac6559e82d721b287313be30f3e1600748d60043472b3a2abda3ffd5d50f1414ac0cf63c84a2952956c2c0ac3f213ad64e533c7e1abef2cb1d422e3e85c9a26e5e90abc1adec2f1e44437a68b3accd65048e014e6e0055abaadf715f4ebcaa28a09fd13fdb783ef19a0040b34684f7073644e5dca34c752547c95c561df65dc7303c26e276effd60f79ee2f76acbb91ef7764e861f96de5dc945e98fd6b0d85050159326ff4717951dc519006b33917e3850f4e666ccbf57659c80076de5e42637856d5f0eef6778856f8601e97d9e0bfab274efb1d2dbe545faa008e5902de39a9d57a9da3728449cfc151c2eb34bd294590433ed7694569f101285fe814f0e86959da1cf062cbc0d9dec3d1763ed96590762ff8d8ff236dd72a93915b7d4eb2ee42a42601f0129bd1d40a04293bc8d113f9ec8607dc5c1dd9b73d11aca06e48fdc4b7ae84e722e54ad70212e1992edb064c7412d259eb7774a7016266ccbe92040128a474f3c28c01884fd5796fe2e3d43ddc3167efe56c79851c1845fa62f9ca484cd8e7f6d425cc942a04d1e7e2449a6e7ad8a870c18322b8f2dabe8eb86bda918f353373aee2d6b429e8150ff751ddc5031d8b14d6ebb3254ba303cf67f16a5e43bf32f72bc653ff0b0fbe1f226f10db2de0b273598dd4c974fa3cea5face287ba3ef1e60c732b178af410a8903799c194668aa2fe23747b163d42f22a4e97ad8cee14d4d5987bb80f150fb25a17d093911f6c8e6c1f4e7d68ebdbd8142ddb5ee155110b7dcab7937d64283574ddfc95f44231700990f73b988e47ca50b321818766cfd903037406bc045fc8a4b674ad49873c8cfdd3f0c92c7109330cdeb43747e4fc556004d21c5eecc25a101b21cff8c5e2a3f9424753a91361469cc5dbb65c8d82600dda8b5916884b9ae4d5763b264a42f544b34fabaaceb7a290acdef65c963cb6c80b6ba19637ac77cdbdc6d39c5de564b41190daeebc59bef96020914cbbd1f84c27716b1f214e67b138312063ca3b72f5f4d1b839e8c4d86b28160c97cca14f4ccc54d5e0c2a425de7e2ee3e25d28b27c63fd075e5afb32d3684ac37cb3c098168302dcbcb724488c56b872fac4778d7338ba03c7214b8d54d0a974c5b29c9f61e050aaf678361b1ea1e5d5e6e977c5f774912a1be20dfe558c5ebca993475875bf8e2aa99d1638281b7003d91b7543071f6669472f8c7a182d122d753e5a5f030cf9c10f9dfa6fb65cebf4534ab08f924bdbdc95389b11ddd2662d4777f2b24e5715c65822578ed8967832934e461bd6e2a07392375d563e7867376e183e1885c72901a6731068012fd69b4f932308dbecc2e73094a079c711b4223b96a93274c0a339b29a976c729544710abecf5c89a75956ce908386b25773c81c1ecbef1faf1c5d0f1ee68a923880601d0dcdafcb04da12d4987323181253f08a064a3829fd9cd976aa6b83f0806bd9c9f71ad850ead75b14baaeb113b0d824858ed344c2f04f414cc6ea927694c9b972d447e94f74eccfc71a38cd6b9b7747b5aa2d1c83a2474494f25e220df78ae2dc4456d6855378fc86b17b44fd8d0d35d6de8ae1ca07126af635aca7c2ca901870ad0065f42354a4c0d32e52d0e17c650aa8bad7b536433a3073ba5ae0577c06ec1f97cee94755c5b92d86f5ac9fa425ff6dd16e9e565db1a2cde11037cb0fd9f649582b72997c7fc44037288ba11bfa1250cefcd6ce03ef3a1ea9e712a3087bd7a391b99fddeff13160eb83bd47becb799cca35e52e60c24c6015cff2f0168ccac86c2de47559d07814e64765e2035d1f29766bac079acfe120021ef1cf8ccf61736ebb7ccb36ba5f1d84f508ec2145e2c52ac475e5655f45daa9a890e8ac63c7bdd13e3bae8baad5662c07ec7a791b04c064396689f964460f94673b1b015806c65c833309f23efed3a0cdc561db3a52130e6febe14a9852b07cf455c2f8b81972215077e0e033dd2ae8b9494e54e12f830d7312de7032ac1c139dde7e9a076012978fc45c61f4c2913a8c9674f8ee6326e12fb5e78e6d9015569aec621578c18e4c90598c97fe5d44eca3e7ce9cb14319450396b129da6b8ebd45c3fb7f9f0bf8ca6aec07048688a286509ecc85359d574a3ae8a65b073164ed43f1fd634e772d7049c43de265cbcb5344e81b5b40476d5c87a11adab47de5e5236acc9b9344f20f58ad78170eac285f4a03c382f08128c698470c35c1d41c6d567538a5183d57e001d92b003c2f4786e5ba032279ec8233be108c13872f70a3788e0197c242adc84c24256a5bb3ed33994243a5024b54d4bfcd98c21ecf729bb9fe5f2dda3191ef3e6c81b81afe238bd13527c992a98d1ffc8167965fdf36372a51fdf10971806d16e3c2922da41110e00ee68b9e7cf6787fe6829ea84a2be4378c41c84f3f608fc096837d0d81a65d33ed56b53a8fe90750de252a831c4a648dfbde11902ae220777e62fe083f17d667864ad1f44d01544c6b49f284a554e8a71992e2f8a1b654481b36c098f5877db9e467739fd0f43171b78035c197924c0a9da67817707eac6039d1e68c253836d59a4932b23120c2702761af0188aba473ef43b837140d12ba062abd642639104836ef0c42cdc8a1389f1052aeb080c208ea24067f65a082c577a6fff24e68aa135b4fab4979bfa261e040ee298778308c28582af638bce3f48609ea66c5432c6a34c75709fbb0c7c98e576f2141379bd8a7b41cc74f5be2a5fb597824ffd8d8ffd982ae3693b2991f843771e6ccb577f3ff3de88df8fb332aec13c41ff45d593df24bdf3aad0ae4a07a3054aeda443ef9a2d1d5bc680c6a1b92a720d016942f9f18096bd4f9ff8c1802beb91362f306334cac666778b6bb96b1c16bf88b58bef8defabf4e45d32a0b2f4bb07d4fed75d616e3a8ed2e26770a43fc7f397967f3a0c87a2ebec759c6a7a41a56b2f32babff55c4971ec04fd9af120dd778eeb4a49c564b75f89475800657fb815428442a1fb43f859245d90c9b571a8cd060c7f186cd4cd7523b68d1b601efd2539d374b698408bea57d90c190cc55c7e7bd703e2cce376127fff5d6ef28b3d1d5d1eae91476bcb7fe4c80ebf6b9fd40199f23128c400027c11ce65567ae7f5ada87fb4a681b7e2f35afcd5dd1052bf788ce97aa7fe5f0514e9693bf822766492aa0cdea8945d5926f6818fdd2db35be08a6d80f3038cc54f7b3e89599f9a3256c4cf093d02eea240214bc51528aac41466702ef096f4cd14818947cadcae78221ba21da2788c1bff43da9a8bdc19b6b3fbc7aab67bc167bd5dc25088dde4ae0267bf6e71eafd0a87d485cc4736c7aa6b46211a6d0a2336a06bcd1b9159df6ef157e9fa89f84753c94a019b0750d6ec7d6e465dd22ffd95cae44feb7b739385a4e830beb61390c9c62b54bef3bfb74e253c84445699338594e9ec468cc4591b45fcf02de536a358329e23dde6a129ff8b91389a1f518fbe5d445482a58dd1e1a0b4c42e43c53da6920f391bd61f3c5bb752ea711674e0caf3e12dfc61519fc35598b09416d72eea6782b2ee4aadc562b89f633dfa317c5ce6659ee7d92c517f65c5ded9724a9a6bdafbaef29453f684a447ce79ba53b4a68dd0ad933e9e38cc41cd22ed9010fc24c5f534144b3e8e3baf504e50f4d258c0e3e9c7693d5f57abba0ee58ff1797855dc26b11b981b1ac6866fdb348a9a7ba093fab96fc7a9e0327fe39bbc5f8e41cb0c2036e6643f7cc63e35db96f140da784b5b70ec83fb23390f1df1f7bffecbe56d39460e17ac430e2065566432ef3659ccb7768a29b3380883555036466a78e28f9df35550fffb1a02ef328f209cfc7b61ffc7c4afafec510c24077b25c97a353296eb7c6f43c9646a6a84ddeb99728d012bb2c7bb688e7c90abf763933fd6e63ae2d96f54afcf8a7bb3ee5dfe60f5711f2c3cb7b6c7d79650ec5dceb17c7ce0c61fc4072fffade74ba80c90a193793d6fe5673098fd8fa22e824db0603050483ecf04ba467e3cfb1892e69279ee63747fa3604075c90db83b30dfb26387ce02f4e2fa20b79ca21a8438d116f685067f8272d813ceef1d1b0d32d4619168351d828c8e1a28af237b64695fb745eaded4d7f524ffd07ed397e81033d0229a44cc4d218cd454655b50656ed6ed7091e9d38e186a10c7acb9692a2e2d62e423a2c0ec6515d27b1022034a16dee71a676113395e2004fcdd41149fc86c990412912588a712d0e3d726a70670a2744f6b24ad1d94a1289e143e0ba9e6c4bdd46604fe0391e570c147b74c47fb315b52e23eb52b37acf0c9719627ecb7f0e8bb809b7128bacd8c114fec5bd99759127a24a96adc975d36102db1d1c6ed6b80cdccf27473ae6a18f1a228d18a1ff450e94d0acefa8115f5ca80d645de8da4f9bf5582371c892a57c8d474a2479387b21de843d6e4ecf587b24a8698b8ee3fc86fa68af76eca3352f7c8d2a43106dbd3807d1b7db9559ba30b7f399b505dae2a3850cf31050122394b35ee35cd520a0c506af90ecbacb56b8101c45de0ec7ddb41f628b0c0e34af4551162117adf4affc83eea81f9da3204e4f883f6a224a2952147a3d143414cde8c669e0621f6d5f0033a922dd156713927440cd2246df36f5bd743ace536e28494831b448a026892d7a5d2c10d0f3d8d543fd6589a6180d79640fbc3f3dab8ce09677effc31452c7321572b6584382b79d4dcdd326b6f94b7af5436a6886255baff05ea5605598cc9784fbbcc9821b966cf6108064cd47706729cb384e769e9561201932570377a6e7e2c0f37442b3b4e414589c82edd834097889c83b3c7cd08b3a88cff4dc1337d5043ff756908ad89042571618c984a350c18c750bd6761cf7959e8625d071436bb7e61dfb1009be278721ee605045640b8ba84e6df048d44cd0bb8668756d32d4da58b2f22b2eeef43d34f78ea6206b9ea475b7ed7ef258fdbc5e4f8f1a3ae86f25a5da425fb90fe58a05e652d6bf6a4d5eabb68cd77191fe18afdbcc003c308d101b8981b26ba1805a4dbde35a4da1aa7122ee58eba9b87c591e91f7ae5ed746eb0ee9bfd7a6c8cd3c195cf30781c264fe3b363e6c56cf61f4a5f1ba7168513150b346eaab65ba29c5ec8e552325c4d2be1cd930e150bf394b00516f7b5540fdee4b021868f0da4814011781852e0175942d582dbec32c166dd35ef7f27956e4019666abb1f00b306ff8ccf5b853861449e66edd1015d647807a6e7e61317fc54e0c5435a7cb2b8335c763c0e8df00d62485b4267c9b66c60df1df3b46f7a3d27ee32a341c45bf92e90e8a7da58750b28d22b8996184c9eb1f2972f5a68fb169ad92f91a173caa0064aa7a231f1d38f167dc8e01ad76f462d12bd7c0d9d9f5b220fb7f6711555b173dd245272092a1084eb80363911034faef9e876bd760c5c1c85348266123220fd319906716e82cf23eec7ab5be65e8315495afa9f6f3dc56e4fba16070165fe953b295830143719058c3dbb8da3a53ba6e16dfb2442307c357c24c606a033fb84a483390d9b96978b603e16f395678e3da1946b3518b25d1ddecb23963ec4f4a106c841ab28d71f2e6e8d96d4df97d0c9a2347b1a0ef9ed866df3ebcccabe592bd9a961bf042b79406a4239a661369fdc4fb67ac6ece8679e70492364de7a9c68f6e37d91aa8c040e4cd9d5ec2e65d5e5db88c915ae0ba2e1b461ff6e93094fc05fd47108da4db19747fc3c38bb89bfc7e33d3db6e88ab004cd50105be6c80777c167afed0ce27a51c91d013d5d1ae5cddef70cd0b5a2e8207c08bbab24ff17402002b79872e30922cf7bcd457736465d393a59a32d987bea097ea431cfff4ee65a9396816ee522767f6739da67d75e9b1f6629b577eeff7b901ff05929e9f49961dcf516551c6ba1d92552bdc0c7ba51194e7a2ea53830733dc29a7ab2f4429d01ab98e3b7bc1db996bbc31f5913b7777a17c4ddd1ede19123b5d8a32e85ee3476e5e06036d525f0879a37abeafef9d6d22770225831ba90d0dfc12ed07eee44103989f2f6948c2f226977492bf1dc40d16f9cd1dceaadfe645feb23237df95fcc53fd2a5c33e9d7318684cc9abeffba0a049e5fae619d37988df3cb232cb6d0a6fa22a506b12c335ac09b0b9536908de42cca809a9def56cb1ccd443fddfd7d9cd4ed1f8c3f3819090e813c8322f291e0b6007b89c6989600f7e8cc5d5d4b3e3fa7eb7e00cecd51b2d56adf3713911742117966659472ce678763853be834afca86f914d14b9b710408b4127066ea924df517e4d6c6b6b8135cfff02bdb27ba133d41b6e88acc9b967286905999d40f6d28320290300f253d8f912547478994a9bf2b830cde50eeda92ea8255fe70fc13cc5260863297bc7b0a5043179a182cf77ab8e74f5bbeb3cfeeb586226c41dbf73dfc81d4fc21b845720a22515a83f7b4a84410bdd5e2ed884d281a93f6e9222f770ebacbb890239f3b2a3e2cff53af2b51503484e6518ced9428b0f0b21ea0537ca8c3b5eadc84deec07ed9e9f1938788aa3620328fe183fccc7e6c7143bb418155765c1cbee4122a69e26baa79c640b594fd1fec4243d20a35b0c48ddb48a8e28aefeb17419ee62f2e9108baf891e8cf20c476b53595a4191de0bab099b235ff4842e2a80bf2e18426086843fd24cb871d0c568e2ef3087deafa0578633f13d2c770a8c3afc82a52963ad5a55d73d17e26bcadf36646c3fe1c7beb3207e646ed40b9fba6e4ba773ad47f43091c80a476182b643a73103f0335268daee84bb9049635865fff50f3dd4b7db30d21477bfc6225da8856726221a53bf80279a64a348803f5c7ea7639dfd63b32165eaaeb9c35cb0037671575c6e9e99f572cbf42de4eb2ae0f493e9f769152dab15aaba7aa49a5fee5152f34b004d7ee9080c5a3b1eb476cab2f1714b456f4edaa3f859216314392823cc3244541d7e699fdc91b913c11cc6068e72dd4d2c317abe27dd9082f0be8aa0e185b67b25ed927181db5a22e90504e496fe92691c17f05e62e87b959a86ff7522b82ee831873927d3021c33f6fab6e603ca82d520114ef5b29ebc5f136ef1af9f32ded66ad6e35bc0dc72720d950e934a63d8afe5c67796d3b040f23d553d00c443191bd7b67ea546c949eaafa8e1cc4b75d4f1c365d1e4f8096cf8a99100a001375a2eacb4b2a2dedb9dfb495478458c78ae0dbe3a715b7e1d18448259b57f30be25df619d4c268af48e356a60f51db5fa498904990c050249dace8385759b841a09b82a6e7442837d9ae5e14b536545a1e8527bba4a567feb6081cfdcd823c127a882a2a596bc82bfa00edd19a45c3e1aa522e3175daf6ec48dc43a7b5b53326f1ae01915b0e63d16cd685b67ff655e7da8dafe76a9e4b3afe1f521afe874d9d5826e949a7e7822d80adf90e2cdde78d5a6700fdf7952292fd9aebc0c20044d6c25ee7b9f6d0e4c195b3b300044fb2c2c68eb24faf0db422f6c8a2d9b5aa08d3fa2cedba618f6a86414eff583b15727ca24dd4794d53d2608bb40304b1463151821d7abbf7fdae34ae7a9d322f85b423824c82147f27cc1536af1494afbbe5a371447e79093667cbe8d1a1170d8958f0888c98863b402949849f500aca93938118e42497d3242590ed7f646bd40776870594dad6985bcbc03f1e2bcd8e3874c6737e69b098f24699b9abc2d7509c4fd3e81def28aeab885b176835fecfd21688cf29f6d885077fdcbef09a85f52494489867025ff294bbe00b5b5a064039b385cca414857f9791f50a34833049566f1e8d373517fd9abf85cce2f28936d62046240957326639c4b786bc30876cc55ad74cc887de7d3654b29e229b39ae91b30f7ce8e214cb792f28c9b2325c14ed1e5f3b0691962f89a9c516a8ecfd3849e9a2caf396794420118cb71c829c29705203c8285e146a6b4013edb4ee45eb0abde98ce9d2b1cf2b1358370a320f289cc5a47ca88e0e4003c73ac62362e5d4e426b0d967e6984ffbd7d500d11350dda34ef27d20330d02785799b7fef374bb706856ca4083242bcf33cb814200952f51c43f2d810e629a4cf9a2579f4a9c48e40d76f10baa2adafe978e4ada84e5f9e4fccd04d265f0d7465a892b7445d9878f035798c0e3eac8098bffdef623c97462ab1ce2d428645b7ed19e9c498eb576fb6fc2ca3a12f72579672d9b80ae6bb87ae1d33d3ef496cf51f9a19ab3e1400dbb461e932ec8d0ebdb1722e9f5711fe605a83a80bb781c169b0e032216ecddf89a4d157c75cfdd4174d227ca5ab0675e9acce71d11767b67dc1c7322715e1c9e044468f489d8b606d7d6c62a065ffde4eb277978168ed6338518c7e03d4d3291b72104a0be12e5380688a4d634a7fafde5aa2855d13bcddbcaba3068ac49022efb06ede3418e7958db12b8758a0ac33d7d211b4993817b1ff94898f73339245cb6e84987a542d48605366258b7251654f7d1600b28a9d75ad4d21521aa20a27e8949a16db6b58de122bd023fa656dd9649e62923bb12952d3b3d4e877b587f1dbf559b01527e3c0d80f756a2eb6b34e9986633bbaa7a81bdf60d43e3382bd00b2cca2c1c2b986f3acc4bc7b527b03e425512507566561a421f2fe418655d9d2b5c1f32da93370bb2d9bcca326738ea0bb8c7531444a61689a84de191df5115be191c104ad90949d561a44c76f84588fa17d11bbb41f994a053f66b217e60fde10354c9dea176899f002fc8ae302ed99dcf74a2fc89d1fd3f97b64b4a671a9829ed77d56f92df21aaa7fb36409632b22ce46bf667c9f23171067fa3991ff9751a339b61af030d3a52c8959ba6773b2517d460d9669550731ac6fdd887e07d23dc7e78ab31baec8fac4841d494826693858f2cd9777096ab24ab130e0451537d7519435778083fcb54adf745f083c4f7a9e8daec737067be443f2634eb956e0072ce77efc6d81387c9703afc725e810d1f1738e5ceb959b14abe3616eee6bf47e893088f85bcb5fa1a0e1c426f52f10de896d760e9f15f77fc548ca38c05d049cd7bfa6fa8e84d0a2792db5a49f973eb6301b2eb8708c7803ca3fe0cfd1527bc9d7864bee31af7b8608e2332b364bdc8c72c698db1fb0a3a4dd93b810ecf5016b3ae97e69810ded8088a936c557022b3d307ff777ac3101f192aa88ec93ddf9213b01893cf1ea66af4b475f73b877bb6abff5f6ab5de9d3514123552b2532dba74ca038b05e6578a3ba88d54ba5ca6148046db662d4b9554afa1608d51b1cb24b9b106240f1fa950fa6c2644816331223f65ab91a4b637a0ff7167da2bc13c1516667d4a774aa82a281de0da4654a8832d21a6baa17508f54ff055dbb8dcb4a3cbc3b55ead0cba246c2499f6a699bafee580af7afb8f1f670dea5d9934a1c4b1a36c49bf67dcf3c2c0c19d995a953c05ed6f769c82dfa55eb77b5b81a9e71c63e690da0a4d13b5f940f95c4032af8b1af224ac89deb23b307355ebdb5339ffd3c71a790310af2688181d33ff84a6fc3814f54c789a405e6fd13d29a21f3678055503b97b7b3f2781ed3c628d52e85fb16de7bbddf20853c6709c93aa05ee4c8269ce1267e284215c9c2b272bc39abca25294d4d0cf78aab2b0d52ac503b3904120dddfe9a28fe4d6a8cdebbca5d102870ea7ff9b9f6aca6e5c1159716083ad99f1f4ccd25829bcc7af626e856f85e0f3b116f75a7f5cc35b57346d66a9a48208c4a1566a02e264aca15f8907296437cd1dd5e773a6bf8121e62b356ed1830baae4fc5013b11f72d7a8a81a8594a45a0f2d57c1ccfeababcad7580dc17c3dfc8c77b1c5288d3135ebec258ef5074c0cfd6f9064ebd26d3605010144f7e817a8b89f9a5971792221160a87f42f28896184ecb698318ee04574622966d2e7e52a7f8db030419364dc675d116f73381b03776bfe5852e024c6b098475a5bf248121988871c0b8d38cc489ffd39a34f95ffc717057b1a9c11b75a8cf36aa9c627c1fbd1b4f10d7771dbdda3defe51726d6c27fdd7b04715d253a6f57ce90cefbb3e229d20b366c3d065b801d3b184582b819383760ae908ebcfad2feb3f733bcd57339f66110ea5926be0a11c9c753f5043e1aef008f22ecce59e5b0b6932778899179751e956b7865b5454671a54990dc49fb89da40fce9c98a32bfddaf61fb149e7e44e07f25e68423349ecdbbb13e7d6c281c40b8353d1e3b5f666e98b241a502e246e6590880fc2ddf3644c840d33984e80277d21ae95e46ab0e0c3535fa4477c4be15ab2c4040fed5666dcfa3e5875eb3ea9d474b823d34fae9194a9fe2c322b922e0705162ea0118ab9997ee6770878f03e7f9af041dfafab25c24760f64bbe82926b0fdf6d054ca93c1fd36654e19eeef267eea3638c0e66af615f08c40058a8156c60c40ddc6c6465eadcce97afd90ad8620eba6f590b227d12bba831488342be82482bf36f68cd47230512569d3eb3e7fdc7ecd416f78860e983bdeb631cf04b9befa25c666d26cd9dcf97ecaf40979266db8eb4d522d612b250d4ee15108787c5485e6af955ba2c14f31645e61c774b29b9c1e388b15c362de982ca29279e5629bf142c014eda9a1b4afbfd74e9530dc7dbfb219fe0e1c5260791ee9634a2f8b414a84fb4ab09f96d02456b5c6944a97b9383f7c55903649510f52633c09ac2ed8cf3ecbf422b4a238064f4b7ae0ff3b8c7ce647083f1a9d6033f457654acef4e2b4b54ac244b8d06134da58d5c7b189d4a7e38fed3a4f281af5b552f380af7827f00ac362b55c94fc08fa66689c33a96528689338ba224f13d16341126b99931906ba86fa33f32432972b3ab909f25db6dcc58a0ba96cf6e95c449273053a80feda52d405265e65c4909224518d1756d41f6c602d50352b0b0322d7373533dadeeb2c6bf182ae7d997d271f0fb4eda7a0d70414f8987681b185686df4e3cc1766f850cf6ef93a270087cf6e0e9d82d6ac86bc08c30bef22094890dea0e3ab63fa3d64076d1244790056fb95bbf379766abd07fbd792c6edb2f42b979ed7b19a37cdcaae1379cea43c2116affa72ef8c49e90d4cb2d32542b132050f027a5d713aa1d072012881b7305fdee0e0d17570c2ea743f3ea3e5d8b88d32b63adfb8f8c3c9a0cee2d05268e1145542b3c5843f7407ad27f6295964d67fe02e4da7a8e39735c7ff6c08677f49d95608ffde5f513a9809ead49931653312243859354eebbcc62803ac77ace3087cce8e856c9bf9059c490258dd613c01f3044383198648d7c56860cf97e2250807ef3f608ffec6b5093afe95f8a4cd8b4298ba7fd16e4cdb214ac3ee0c5e60cbb2dbf79079f399adf0f617535a541ba81836c6c750646cff15f348078b955ec024b29a3de8f8b34b7eae3498d1e06f591c43f2bbea1d6842a3dea1d8d83d891d00dcefdd9b0e40a8cb5a3261f38ec69b3e5adadde16bd3075aa438bd5bbf85f294d428213be1e1b645fbf3b6dca55fcea0bc95f50b30ef6c527ba6c7d4fa02feaf5813f38d9ddb931363b0d18f63ede8f1c92d2921fa4183b13334b96e80e10189c7686f5d238eb005d33890c10f23ea389d3834d296bdf41960f6252d4b0a4461e420fa0887bde2db07c67053f6e2806003c153c211e1bc15fa2c08fe66cfff7054d8b7a842d3be5aa2a12df4cce0106c949dc94c6d6975c32fb21dfbddc2dc6f7eb4f625f042130288bcc283818e8129e47600576d5f5659cc1fa321e1be285597d85f2e4a2eec66026e3eb2180329e6957addf2c737960ad9105307a70dc6b28ba73104b29bd0961610af4b4547dd2b5c63d068bcf85b27d3b12b33f76d5d4873bfd64e099b4104b647aae4a9928e398b8a443f25aceeb978c2966c282b36a4f8b1069c92906d1ed418dc16145cbf9f4eb3aea1a483a62142ad01cc360564dae95a4b308022909c872285a7f41ce9b3bc52981c2d6b6c39195777cd3c04db570dfa3d8468e23cf75fc756c48ff81d9a87969548f1f1dd0dcb4e18514d5d01a2e93ff0a8dea7e0a89eb768b7156e5c446e278ed5a924d11c322489d992f96bdab69a793477072ee992f1b513fcbb06b09efd4d4946e0a85f9b1499de78095bb2f49c1d3372b506101fccf849ffb7f5b05b8c4c331265951d92889500f4b76c8269a6887bb4cf8060868c16918dccde2d7e0a78ccf637bc7ae6a4b59a897e034a9c33d6992b5227ee741a3d71dafcc2acda11d5b76dce9d46d932d07c1962ab21d6bc99f2a4416002cc4dddedfe55bbdd61bed27a72307bb64c7c2a277a69358d243634920e57b4be17075b0be7bcc55ca100ea0fa1e5f1e860ec7179a943e7bb289d7d37e30862c6c86ba29cf7b600a44edec9e8747f75f5ea454acf90eb8ecd4ec112394f213d75d0424f7a14b6d3fd9b883d55b28f74a9e45c6d2ada798789f3eb154a5d7f5e344528c6aa3d2cfea27adc10dacca7bfd8c77f1c7d0195e56351dd9d2d1e8a18af2acc059f52485e52a6095786a4dba2700e76983a99cb17677c0179cbb011a6a8b7164792f3789f8c1173de2dab21176bcc3d68e4e66f18b8049f80754a02948e4a259b28d6cb1b58b6aabeafe9fa12fa1b2f5012a7d9d52bbdd02b1c12124daac474ae6d17a8885a71009a24ff20072ba806c8af4cee7bc6a35a5a671c1f9c09a9f3f9cd21f9f23408d24de84bf6e87b58c48743e123a2174854dd52e024ebe6ff81b4190e6f7b0ffdcdc14b0502d84e19d93664c4b3cb17c0c65f22b55064c1d90e9d6c01aa22d1b3ec6d885396d03c7af768a28208e5df8ef89c618738e5a57f4f1bbf6786d1497dcc33cf4453d2558b458aae4cafe5105e70e4609db17edb5d88e4cfb0fd2560cdf7cbcc8066762d3322bbe5269b4fbfb2d4a973674cf8d8afe88a83da1468f2deefb964dbae31d6c801a591e7efd8d5d6d0c798d1f05a436bfa0362371599c47ab3817a9a5df26c18f74dda6c41267dfa6531d0eba5c7057513b9a72883ea0d368f499a235d4be63a9d064df9113e2828cc2908efc932e097aa1a8f247c829fa3f1c0d48cf6ec9228ced4f079947f69896b0928472f97cd5d1640268a1c5adb9a5fd28886aabf75a8ba21a05776ba69a6e44051cff4ad31c44534680756b321857a3b127a632ccbd99acdeac0e70fbe760671f275dde9c664582ae1ec2d75e4e264102656245709f0e3a66b7b0fa45acea40f2baf9e359740776b04ea93f1ef901d7a202bf84c7f572054ff1b9db431acba918d21f8723860216dffde9eda80a445e95a57890d0ebe7b6e84ebceffed04427d684b188b63338bcb6ecea6bbdb6ad2231d9ae33904c5c8454291c3e5c58964091a8d8103edae7236c69be2d9b3295d010bde6ca0c14b9585c2668ead0dc257fc3fca7248357bf4d25d93f8be6457ed019cc2af951b22d090e6629735956f8504f5ae76769e1fb93d7894fddc6029b4e70422e3db906edf956376206c660d499020cbab57717ba70de8c57a5e52d2b8cf51ed2e395900d6f1e69e62756ecd625f5e31074c19e301af50cbf099303623fae7e9ad0a7dcfe0e7996c8d2c05d9fd207ac21f1d6bbb0d2991c2182ff7bb426323b53219592274ef9cc4db4b45827118512362e1ab8efa27d10431621b9f4ca21dc08b94e98c3c8c9deb0f8ec308b2123a8f7e02352de83281565fc1f32d8874c5377d704c80aea98d2ea483042c295433e413d7d3e13569e811ccf89f75c2cc2aa36d54919bebf705c92c53b8e2c77a9633fb23acdd977df50dcf4d4f7c8640b0e76a600dc6f907e34d63b6fb00fb47b65396fac570ed708ca9b52040f04effda6d9f84150bb6c1a6d22f5bd69bb851632887112cd131f49f503f2c0ff45fff8d9adb6a6ad28715ad34f50932cb08a8391a2ba79e674c3f77fd7c7388a5cf7195c4c2710c282863b5e0c5e590c5c01a97801a386b25fc481f3967ef4f91f648759e0c22a37e7f0679211493445dae2871cedc3d12d21d5b77f4fc35573c07eed69ed4c6a8c4f4aab18742f1400c476f4e7646dbffc2816657ddf416aaef17e007494ff7c375536bc69dd23fb0f9bc9e48715b6c98366e55f0ac13eaf2237c3ab0740bf586e7d97070c31379b780296b2105ca1d7dea0451fd2ea6c1aa0cb932bc518479354a2d7b2391722a8da4bb7fc6b2af390c26c238933628625526297258f0111ca47355a57c2e8b388409805ce02a8d19ab02efbe126e38745f2e0e407f3877bec3810103522d0bf7e5bbd23401ef2bc509af9208bee5418a8c302c2dc4b416b99f9579fc6724e2de40117ce4f4545cbae7eb9e32c0f2aa83e5b42e76cc1843f9bd0c042f3524fc08a49bb78bd837a1909af68c63aa1f722d4df51caeae501c8b63651ace2ad27aca358f3e26149bad02edc13f7b8d034ec44b9cdec0f601437bdba21b644296256b8faaffcbea306a9414840c111a67c57f19f36c193502cfb801d8cc1fc96c972f65cf5dc7a06d3a6578e23cd183755ece2822df5b90c26a144aa34df50e6ab773d4015b7436ad559b8b48af2926d11835788e34fa15588451342d1f77085bae907d4f279044de8dc8132040de34af2e1968af43b82bf6c587159a212615e9737e6197e4368b560f1d032fbda8268a18f4387f0a3f168552a121c538be6046bd20c1329946dee3239f6cd2ded8fcf24b2576cf661a960272d10f25f5f9af16fdf7808cbfb0e67713f63d640dad97eec97796425feaefe6d1190a449c9c303522b9464f8cb750b83a7d813e68218399b36b5b9347e9d2304124","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
