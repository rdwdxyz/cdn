<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b34cbe1dd1370593dd3a1b3d245d061efdbf60c22bd470b851fa49f62800fd7dabf8f0bb3c7e907b395026cb8e1647400b0eb05bf592971b38692d718a012ac33529d813c29c4e868d6cf4b881fcc113fb08a3e7e3302642257cbb7dbabc60df4799d324483d5919ea39f79199b11e62e7e9b93a687d752d15134e09b805016a4a1ab1c7c140cee79152bf4b257fc8ce234743c9ee0abb5dc9c9ebe53aaf73f3f5095c47fea0b0ff090a74d5f6d4f7939c4287aa548846fe3a698ff578e8a34a04d9dad5625c53ba28b3f3a9de55bd73d7a7df34d9a7298b25e9daa835a6a4a84119d3b6dff187c2da3137b3fb10e2196195fefaf0fbe8af4ffbf018b57d854eceeb5c76b2487eb652536eab922c11b5d1b5e5fb1f8248a89b2854c4ef9853daec3fae204240d243b894a491f1eeea579f9b10912fc11a19fac24d84872381be05704dc1375a8c60ed303192c0342c65c4e2bd1e58e5688fe30f13a20714e58f1ff1b6c6233975565817ff553319dedb3773770f4c3ddb5c38bc4ca32d1c23a209ce4ac882ade627c922d02d94a8ae6c77b621ae234d6ad415571ed6fff2da6f305086bfaea6fe96d3628a182bc3bd5332570359532b1dcbd752391a8f6fc5fd213205cd8ca2a3f310af756eca8de570833a9fd074ec3865d222e201d5c9b4ec009c38175c61ad897bc901a9142e2092f45161e6fb3ef32164b5ff3f2dcb1dcfb445855c1ae104c6cd12831b2a251cf0c1c9f9a5abc1b3142fbc6ac6dd9258506c7be8cc345dec257ab76527b9b98622982e81a031ae72f7c36a8123dfb47499738b2cff6c55ae0d60314d3375a11a6e6d1ba642ff06231f279be0ab4d00c6b44a19acd592e00a22bf932ba69265698f89d49f03b8ec0b836a2fe9a149fccfcfda5c6ddab6aa650027d2bd0f1ebec2f2d3512e6b11ec2976a972b5c1ccb324dc07eab92895868fd66a2d743003cb3535f0bad9aed984cc463d94e49a720a9d7e705237e0938d015677212991a36ea7adea45fd0a1ed65b7375ea84b6f6d75c108a863e3123f96e56a36b65d954cf57288db87557b9fcb5d4242b599d202adaeccd4b89b526b3e27bb997f9cae07bed006053ccc460e684ec30bbf3cfd032df24df6d46592a46ee1a9b37a8e5807c15573f3423d4de62b62412d974c44614b76fe071789b612b68e5bdb509b983054a9c82aa3ed2e99d719031eafdb3d5746efa7b0ae77dcb6a04c54ebf6a8c79f34638071d8897ca06be6b53804319470f75d0ccc2269d6735785fb2b54b753cc3af5c1246b29f111da36ff354d75bd0a3b1e018eb663ced5d1a214e13e112b3e972384efae1fd0e94e22c0589ab93bd68d229892e4ef8a603d0fe18e2d0fa5ce4a2a58d0e82ce5340e70dc0362f527eaf6be0e00988a6ea0905cc22bd969ae60c0849a1680b7843d7c8ce2081250952755afd7a28ca4d61e1c976fd51dd947b3715e4d30fc98ed6269c22ae808e9a0f0687867dc2632c4622927c8f8a906ce960a656ba9063d488d2cab2f46c0900dee6d4a2fb8fa7cfbfd051c3aa625d1d93a6cb2c853c9e0d7fe7c833043ed0012667a7021e193d6b1a57f87afc5a055365fa66b6d6c3aa864328e31b82bf0c62a372ec92a41062108b243ee3e412c70f1c060f7cdbf40c5a323550b86e1eed4f1b493ce672ad8967855af6685e9f944f6632ecbf86e0d05284cdbfc8df8342a1d4a3fbdd5f1d31be2b5b91c17769a3407beb694a71ce981c82aba3d6d92ca8edd17a949c311f973af8bd11d3dafcf48a880552666c14e61789e353ed84ca82343bb0948912e302199b3d6d0c7be55e301b922939295a95846cc02d1ec8e018edd74416d9c3cb7be0fbaff0826c5a3624a41e6e6eb4fdf827f44e3e4bcba2c3efea570798a8aa7522c4a524655d6ab2269749277d744fb879a53d6567e9a35f18345c8d15733f7abc295938e0e5b4c90b4f572549fe62d55157833f4d901085444dba81cfbdf192001ce415c975df6c31a5374e8227ed3145136caeb43c33e3ac6f418a15b3431b06024890e45d5979f3de111cabd6b19e7cb2c705291836e877a1d056cccfe524aa4a8d6d84272702c040fb506e4d01191ace6650806f0c041399f0e276e34a247603bc1f614875a4e825812339aa2942ce0a4c167e5ba6791e3f96ca5fe849b66d80cfdb2ced526e65229b289ec82486470ed4b5a4a9004b39f29eb6c55b3863a145f193e216b042c9ce8897ee4a671061153bf76de6e24d92560f19053d61e78cdeb163982140919e6e9e4ae2306d1d94f22b177dff46f9cc8cbcbc35f6bc13111f421d1762dc7f4d14e220c307d5b14532802cf53d1847fab94e4260fd757c2cb352a803a2a9788dee5d804f5bff84a443c67c727b14ed75def3b007ea914782d81ed11d8420c4e38b2553a05ccd453cfe1ff2f8c24f4fb742b5f2fba2b70f5fd5e439d264882ef90e6dd423e1350149cef796cb45249fec9e58bbb33c400c518692b7522ff40fb5d599cba545868cbc14a827ea483cfc4100699ac692a602b0ae5bea0a98f932aa5c400e83b2fda147e5953bce9ae0d888e7e02a8c703a02be969660348cf6771ce49524f84645adbe4524f96bd444e14b89f5c95fcecfb7a0a725e57f61478394fd51fe8292e05d64bc308908ccaa1e17eb40a6daa6b02c92929110cf71a65ecda300b5921b8dc4e20843631a57fdb519b3d0b912d5cb9a19333c471cb2d0d708c7144812fa1568a1d8e62ca34444fb7358020c2eb93d24ab296db1ea9811dd6d4a5629dba9e7b8ed09544e9d71ed743c7fbdee5dc9b7cc0518fda51ecd37ec9be0704d322026d51edf06d6ffb48a4e1acb70e7477237c93f02b6650761b86f4c30c502c6db264d62b5ffdc9e711f3b48fdbef6b871817f57f69d11d525a595d7fed3b8693268be84d986f51068f02bf05cd1ed137ebd966671c396a4a2993afabe600cf248e8e693675713be2c391e9e0ffbf7f5ecad9ffc0f70cde76440a83429ada75a7e153b8eb432415de4723b33b2f10b76ad19cb4fe000865c418620595a0b41285db6d44677dbdec3457df50d6b730b571d6d893197795f955468ac410fa3fe07bca53098a2204957e2ce68033c99f96f838b76b05b5f5edb395b4907035e0aeef020a0920a66384d26a4fda60c548b502727a9e1d0d72ab463052415759c8a7b60e961530fb2de3c63bb71bbaae3865b66766e7754fac29eaf21876f795c1e51fc13c2b8d7c0f7cdea597973c524b2a5c75894fb61b4ad20f77cf0d226cc9982221f4a8971580afe20ba58c29bb019550c2ea0f974ad68dc6e3b6b39a70080ae4f9d80874959624d9511e24848c63302365c450035d5fcfe0fef1baa95cc1c4cb37e8192cc38ad82a942e9f9824d754d6404724514b88d9a78793dec6c87868b226807d35fae43bf6c13256e55b129391d63b70d0c00cdaf8beaa1c1de61138abd3cf79d1a328e449ead198944e472ce336515cebdde58d128569cd935431e691d58a269e339f861a6c52795f1a595c3d327f8dfa3cbd67d89d3c748b2c59f3d26b59c7dcae377ff40327d5dd6eab93670dc9cbfee138db81da3a8732fafd21672efcd1854ec233e71fbb6eeb6c37aa8af219ebce7563e208654b6596b0b31f241ffb173a55449fa3344e064e2d39b3143e32027cccac0dd9251c8cd34b29a33bf6d8a7d5f823d781ee5b10f3f80e0c0689ffc0728348710b3ef97174b7a7daf2bdb00338c753f1f9d40146525f44a879c8816c0454108b3f7fecd3a24fa6bef0e4b50e6b86db3a614ad728201fbb34e7bbda4f28b9f3532fc9feb5d4245c053e542392cdf10bfee74528a6f02bab47af59d0ec8cf0e8ecc5d5206ea0f242ea34e1c03fbf702e1969fe2ec41ac1ef713750276ebc4ce98b2bfc50deec8cfbc30a2c70ab9402ed65c5fc6f7609a506309c41276194170a5f4df4854aafe4f3f7bf4bb7e75db101e078d69aa8a127e755585a863f0a42077bb59574bdcb17b4be0f58b155f36dc4e1e4338ed44b4322f866413f1e35ae2b0bcea19dd51d813de517f21e186c3b1d9e5865b2925b92972cc7cd68f92c85cb82cd0e3a70b5d32d04d6276ca974bbbea8772669d9dd807fff9d2f1302f7134381a5fbef33cd09feaec06674a5b74b75dcf1a41515cb6228385bce72014420b28a1b669ebfe378e3f3c33a4828e734a243f57b42a8f33927eb2ddfde9d5a33cc9e9f86e23ea7f4e208cda17bb466a3c5a1b0224c00bf287e139fb54cfc2c23255cbcd8afbe6a0151fd272f6b9e4a784363a18dcc731bec3c8f89a547bd7b20e9d9c68e46c05b20c28b7a5ead645c98e1231733be1f0a772b15a61c1f99a91d1c6c468956409cf3ee882cabc0e54acb4639744a946cdc431998ac5b7084f550b01a7abb658c6075d58cf0874b280ea6b377e3c6755c77a8033326f13ff01d59ade4448cdfcd3c31a0cc5fe1aca3c4122bc16eb0b12ac02d685adfeccf47264abe20301146b64f82b85ae7a2f9c96b99f7da4972f81ec9dc19a6d1522e0a600b9413a812d73cd4d28da4d3eeda0a1f3dd96ccaae65ecf608f89d423a9f5d2275eacd4d13f1fe7a801977d6d0ba63c43abd0b38468f12bc1f59caba744ce4f0e9f115cd71a198f2b7c77b5d0ae438bde696a97e40bc166527229e9247c2e18b0cd2520fb46ca234c1e0078bc5ddd050e9a4a468c4fa653226565de7a273c1cf8abfe9e45a5a99a550970d1771f9eac21106e9d18edce48e43b21b0ba8d30e845020e71811679d8cb7a388b142404bf0581e8c4bfea966a59107ba408249b0f1e3f778ec33e168f4fa6a37560087fcc9991b2442835ef193c43e005bf88bd04c4cd5ab704f1b86bff914802b3279300817ac510eebe74b74ec4bef3b4bebb55a0a97f19d546d5b9c84c25f96e239735acfbcb6dc57f1f91787108a1429c1b22c79edb0e43f8b20d76d4b51118686b451a7624fdcbb1a2bb8d54859461fc37e838c06a9b572f1f2011f5fbe235a66fbd1fa8c235584aa1f87639a36aa5aad7308cde0d9696b63a3b49bd837ee7a596c553d7540d6ae1623945e39ea7807418c17468c8e8be16b93547591681fb6ee115d6dbe694664f2a739d9b8f69f633b84ca207395073d723edf4fe8b89c5d9c625dc3e18d0a50c88fef0a93f541eee17d5c7acb008660c6679d8a117f6bb0bd1d08a88d46c6c0cd2db3c336f5a46546f3502bcad8b3cd710ec32f7356478981dcf1f29940972ba4af12f9e273470744fe8ea683dac3a960a9d7c66106a0fda80ca8c737eda57f6ddf306d4db930b02a3d15a23c7087b24763269d50d169fd8a56c53b810c78b58e1836bb3baac942a5099f10679608c015e3c0c1a8b17d316a4603b93a5ecf137a4d84b0c1f8c4d47ef013366fd9303c15a4727d10a6e050a5e75c72c6b64fbf67881bf8772cbe3f2b3c479817abb1e661bd46a468e3666f2b51ffca099fc9661620e6f248d5f091e0c5d05ef27aac2d1e3e858eb950e1c4ffec5d5b93af343718a87e43a6539521e6959dede073dc3e45bc75c8e7e2ccc92a2fe68a4f8ca0a99ab0afb87dade769af76e604d2b82ea26b30012b474fdaa1e7cefac3143eb7eb9bc0c8958f64c55ed94c8e0f10f76e46f8bbb788af3963ee718beab948c3136c7357a115460a4b2336ae2bf3f820293970c66b0b2c58b910b296b84655928e985fbbfd9dc322df8432f45dc4830203a481201a6582822d45eef6570a6303d8f3d130c89e0ce1ecc071bdbe357bbdd18d7830288e3562e862447509ad2b3eefa6dd49f57402fdc90a097f1f1e2b946bd31b900c7b77ac368476fb88bdb8c3f170303d55e877002a134ff1cce4dd28e02ed9b18b55ed95330bfa923d85d652b78b92f7319c9bbe2818cca7df650e1396971f4f467482a05dee40c80b0818b39593918c63ce4229d4f2bdf9ff880c80480703b5673a398bcd8a3a73e0cb23f3d416fd336f601866e451b5a35860eef758c3521d40d4e04b9a95289438bf6bc885e6f8473b4ae129919b494b5f166027c93751b7f11dfa40fabfef7fbc33effb0ba6542770765dbb019fceb629fa70c0cbb9a8d55b21cc3e743d68f2385543580ac43e71cda25d5a2cc5c061373943dc3d2564dddb1cde047e255213c48a948010d0f2f332b746263aa5158c172f511e79c47449870a313c426d266c3664794b06dada0daa2077d95dd4b79c6dd1b1a9065fb998a6f04472f26b26feb4df457eb33a0cc38737719560b61e4ca17dcec13a0e566000f8ef6f632c5ca71537cb9e2669b00d760a605e34743429055c85b52d8e2aa5a969203b7894a5fd447f10cf0c595d7a3a8eb8b5f4b5a4462fc59797d1b9de3db5c35f84e115bdde8f7b2ee30c74057203d5a68bd1624451f7e38647bfab21694cabd28739adb8a7ee19beca286994d6c4ce638437c383d8ca70862d19400810067cdb32e0952f558a33dee049913ad18157cebda75d678f100c2fe19c890289a6087f62da2bfb19d72c88c9e552f7a447c9adf7e340cd911c12a89a5e08a6d2e1f6f6ce27a4d6bf8b11758c7fa7a5b34e1d7d84c1eb3da7c8e84bdae2e0b9c21cd713c3b7832d343ec2b1ea4ff2675d76771aa86080070c9b1b25533f2ef2d6d3fda9f41d99fa2fc83c96d307f328d17b5c9d0df6b3c9aead22c7d24bc5315983d429f483babe9b0ee3da4978c17d0dbd3c8ee76b35efdb14f9ba2a46f25510f26002e770aa221a9e590e13298ea926553b1629fe87c68906c9a68d03a1c25128b322c68ecd5a7ba61af26a324388aa1757a3d4211273ff69868b9b534d1e833f1ed84991137c91a2795f04612e9e12372a92fd2ec5bb8ddcc5482e6b6ab1d74875dde9c284e2847e944e9dc9350a2ea01ae4bfcd22d367eea062bb63fe708b48eaac2495840d66f8ea923d2cd1b75b63a56e75ccbd4338c6396bc1b896ab1909529c85787047bb1e22f8c8c6476498e936182ba3672610a0b65830de4910c93ed5bd7dc14beb3f1d838ad95c8a71b350fd3d998dd53d36f13f839f9d3ddb4f01ada77578c3e98d660b42a493898e9d77f1551d5c658c0e21688da43c771669cb1f7ae1489f2830447ac87484f0374e974e51ef9ddca27bd6d4f24e4e1b9c242b79d944fd25fc3df81eab243d842684c47b9ffcab0cfcc3534bd5813208fc84e472a7bb6bd756cb36cd6962e97629ac3cbaa4d1559996c069fb67242b9e2a3c10fc47fa9efa05a3b8822a28556e11066eb76d7eab51cef6ad7303ba9341176545155564b499f0fde6cb3a240b2ffbcf78349c8920f0b75c907ee4a4f87136051298e02b41ae64a0f706f5bbd99306dae1f7027005796524eb804c9af2842a75d57f0a55635e6c100f33c7ad0735530495b2888c2f0656d50554010e0b45fd792776194e06d935f92bb3bd8f502aaf65c98e1e26504fb6fee457525951a7248d5f95f1e7ab63c1dd1253926df2e5eba38a759660d90b16bde3549b9564c52514957824abf72c154be9498e3f582786dd766b3cb378ff33b98b05f520991ac9c419ae6162e34fe74cc68bdff1c324936344f2487055e41ba849162dab29689a956127903922d935ed274305bf0882816e3cd17fbed08ca4eb4fa50a562d74df0702862afe04f5dd448e4941834b87dda3c899e5b86229db068445ddc0567905a5d2d6dcaf9912b909f5bc54a5c8cb1f0223dfd8570765ced80e40f70b23c22df61a1f47538ae8405a4e86218cad6e11ba859e67af28c74bc3b2ca79f663930ce9475484f1cbedc12ed44b14a4d5eaa317cd368046e119bdb0a2337008f2162ea56b5a6d7981219533a30e2331b621d5d5b5060dcd5c4ebb13697c55648f8ffb942c25a5a87cf8bf49db21c8cfa3d3ceb59fa2be1e921f871d2d38556ef70b2cb60c38b449d5085db889eeef1bbda1b72b3f09b0ed87c76af22b44fe4adcdc877f8dcfcd6315668a4c33e5480eee1a32753829a63cc773666d6c3de377511d1e534329509b884e1c92d6b39028fd77efe8856e891119c639e3aa0f18a97dc37e4b83cf1bb5414fbe54725de088a27c7574776a0019d840980c93d9094017deaad8e8dd2a95e04e7bfa92d296fc72721b64d6bb122b3785b917c485f84140bd6255795ffc3ca1aade9d0e922be59ae8c845a11c79f962bda01d825eb952581ae9bd0a6158463b340ec4f70a4a40213a567f501583e238cb612100576cc3d279af12e266256674930fa2b5cc1da52e31b44fd94cacd941227d7aae87231eb01633ab65a6deb52f8e17d3faacaf4cef35b98124500bfefaab08911056276435be692a0b6039d982f30c2d1ea10fc67ef139bc075eeb53b98326bcc8fc1a7a796c970110cdb4ed4ac9bd5dfc0fe071f16cd585c822d17259993c25016721da1b7bb201b70db6a25e585f74300b409884490f932a5c131347439a37818ed4cb82a3075f05a1bf8b52784dfcb14e410b8362ede15bcfb4a65e3705d6c6a59e6ba7dd841e2d2dc3d0cbf22d7fc638063e8e706aca53742d00eab93d7df2d7cf1d9fc65e8e5004148cf26009687639620d2a6b4d1d96335c74e9aaf6e3e923a5a411c19dd061898b289d5f66cc2701e4da5e20a1d0ebdb0c25aff828f34c9f73fe98e6f65ad4fd7d03263441aef134536bd384162b989cbdba3cf24f7c9090128df5699545a70154713f5f7f41a7c0059d8b54719e6345eef9fda7ca625abda9d40ceb7f025b32d35139116224dd66e9f094d5a020f288736eb0c408c85b431c0f981013396204e6b51a30d05a4d32f5ae1ec81760be2a517512cf9f4ef493a99976e603070e3376155e3b1efcc46faaf846705694832c6c87f329a02cb109a17ec01fff2b2f2931c7801a95a982be1c2d58a290f6003c976ea74eac91ef1fd9fbb384810fcca953b858d102e6c7c829a4bdb794ea733000449522d3ff1cb3fba5ca72f31ce4b6a9f874834575134878bf453781b6b0ab38f406c37f0e8e2f278dd1fc01c68921f7ab9fc58c06007a799562b89e901ce90c573d8574a1c1a99f1329b4cc3ab38876d753f35ae175b1f8d2b4395bfa6522df1e3f0bfaa6da97414d665c7de1a35ba61fb2042a5fe3f33a2398cec34dcc813f1f9c5f115880295ac059072ff5d8423cfa4d46583dd306c2ba4d32dba17f3941c1d54c49a42700a231b110b2372626743b114c28702e933eb21fbc2430b5e6a52c6ce902048d0204e0dce312c84a04899f7d04685bdacbc1eb88496141aacbf810b4626898c11e24981418e2c454c7e27c8d445c92a6a234aa04b17ab1eb4c9975af2bc6264d9b4740877b76e3e44e5240aa203087e20133ae748b13f13e837cdd8c5b22b7629049016d010c75789e3037822ff849730fdf8f2a77ddc3a50d838363103fbfbf273ca4b7324a166435af73d05357cb7418923438dbb03aecd96cee99c858ee8972ddd491fd9947e635000935b171d0920892d96c6d8dab9e7d5a1c26b55a3f4cb1c0cab8dd416527723cb8587b06d64427206009a9a3a29a3e533931c7c316b6811d70c1c6163b13f21ea947198cf3866b36f33df32bcb11df044227370cab8f5824621974452a15dbd146300a7655dc6858316de7736a277173e74c7c7003f88ff5a4cb68235a3733d7e22ed2e2c8e8882af468c3a2e8832c948b93578b7b0adab5065a612c79679ea2a7a96823f801a8d2eee07ac24522e0c6eec44266b70adad28dc718ebcc26400373b2baf705de737363ad0e5bdba84f4d7bcb2985db2c22ce32f8dce03ddc0cc3a20fe6d25925c627aa8d358849a47cb94160b34fa485a972f1c83bbbd243b9fb8ff3c071d88509b06248c3e7beec41c1ed1edbc50054315580a7864a78bdcad2921368a426169dee547c8cc98f10959c27f3ef4182d39429b6745a3d6f4b565ab4ad3755d7dbb4c63c90117c449472b667a4313dcf51b5118a003890b0a7f0d89c983344326cefe14836021b8fe7f7ce67fa1fc622d10658c5926e2299de6902be5d71b498cff6f340298f2f6bd520f3f19368bead3c4806e5fe39f5174ff42a402a003d52a42d0b6ab47ca07e5ad331f0f2157c4a87e8ce18f2a619a506b6f35b5852c1988c0890a768e29b5efba8153989dcd3083e96a8f747a7e931ae0c8c333009e8fd523b3b6c2f42692e2f8defe2f782e465d2c9ca689a67a8c97b6f54a3ff8b59839d3562013dc1da9f42506197a0929ab0cd35bc741146f330fcd72ce9f6d95895a7c1fd75749819c51b35b1d2f7aee29e9bf089147149c25aa666175437eadb1df71dca7ec2b9a920eae54d52228bba62da8a3d6dd723ddd7b02176c2ce0bf35e19dc288bc38241d8409668b84f40cd5b62dd3b261db70f8b5c9521992dcac6a6e511c6f7d4712b8188c51635160c587fdb80ca8e945251c0a9a05fc1ea30e518fe97b6927152f7fbfbb6ab811632d998cc65c9213799b02b714cedfcbe7d9aff6418056c6475204a3172ce90c00bd5832206c1b00b5a210bebb019d42bbdc76cc72e7fc90a45ae9b54b5457e2c983f756b9e897b401ca2f23fccc099adb3d51bbc2fa04960f3ede64a689d17d6987f8708e5ea56379e3f57d5d22ad50e8c98e45a1ace40a45704aad7853ea143ebac3ac53f57ad2937fb1daaa2bb5cfa113c3e22f1586febf4f04597a2d7e59bfef51a6a2624ec7c36831de861a24e9515bb5e9f0e8983e8be1ba6f4e64a61aed82a1bdf2c348c3f4850f6704cea4fed5e9a5e47a82874a1285d7b481a5b25f7b6c0d081ea9e5764cedad91185978fa8b0029c77b8819db829b4cb237e8a4a72da49af0e1ca894df97aa44876a787ef9ce5737fafcaece309f29d3d20eeaf70ae829eccb559a009eb0e4e8d510d819fb1bc796064bceaeb3da81691d4b9ced3b782157d0863cbf67a341ab724a25f022f832a8bd02e4a6671074c7dfa9c3b47d34e4e9cb5d5cee6a450538afdae7c749081056a260e2c1eafe8361ab5bf896cff127cf0bb5692d550bfea9b66dd11a563672deed3d0b9e85c44a5e557ff6dbf25d6dfdf264501ea2acbd74709bd6c7b3b7ddbaf4e59381702a4a5681b5b2c0ce05b5fe31e0b562ac3cddcdf41d58689c57ef6725fd72bbac6d3c4f2d092910b9c834481e0efe000eba01b2a600777301b12aea0122408f3951e3a64b0a026d0b50c7d5a16ecdb3f5114e9016b1bae28851b4ec675908589e23a714e02281b8d8601854bb5332d043bf5b8e197ce3f738aca1c1e88f6f5a01f52ae5e7670acf3fdcf07851344d9beda78a89677ab039c25d124adf0208fbb5d96fd4af657e3f18c6eff48d6f2b8c59ec7c5dc4363ceb414aa5b2478574712f4b66773ef0ace3e481daf147f90f0c68a9629f754ceaa1e8030f8e75d956a312ce70d6b58abcf4c9a16d6a1bcb145747e505cfed4dc64b5224273c2fd090dbfbbb7d7a27a934f9edeb4dc0781ef60d412a277e161af539e14de0c75a9fcd89be82330fa8566701c41def275e000c3e508f327597268afe9b24feb5e1d2c302ede57a024a18e7f032e5c6959ef8a88d5807afff1354b3c8b82e0a8ffc3b22910d552b368afec74e7696e4cc62e5ea3815f3d1c7ae2192de693c00aea6dc7c6a5cfdeb8c597e4570a8611d8071d01b89706218478174cc312df1e2edddab9aa0b3fae265edb2f6b7c1d621f4d12fa7de83a17ab61974dd2ab161ce6e0a8015efe94bfc24d05ff04d8ea80ecb0f97c67a6ffe3c79fd4f29ab67da03e519d5b35458ff742078b8ae4fe39771b1866b3a10632f86c5e7042edf947e1786443de762d5a48bf46436dbba0b81c82a9d2adb15e01a0008fa21418c3e1c560c83e48b4c134a70a3aa60195753984e4437616b3128aeb45fdc73cc2476f925589e50c6acb58f43b6c9f332331e89cfb8147bde523de45d7d96ce50de65a1063167a69841a28c39afef9484ff87f14b2516caf1aeaf21ad653895c4f4cb862c44cc378ec16abf99c12cd75776bed5db2fa52496a9ea53e149cc3425a6b5925d5a4cb81ff6ba2de29ef072c65d65ef980a5ffb6a035f5aa79f4490951fefb4cf2bd08ca32bbe57caa4bcbc338930fe2bf4ced380fb28456e004a8edee4bd38bdbd0d1c3dc994aa0855d2918c15096ec60a9cf618c41e49d598992adb87504f5716ca5037c8338a01526f7584dcf985108d6b9f437afbb2b60fdcbe98bbf0db4f9039ee0c6ca6e4741f2dad250a85c8b4ed675e64f69c759584e684255949339c340cd766d4bb59a225a492879c926a18282f45876c5fb5e082c99b7079d5d44c44c2ba6ec183c6c3b41f868b4b31d461d98e4477dd67c619a5674c84d9f8639016e1c3d01771979b76d5dc7ea90ccf2d7e34a48e2e374e3191bccdb4fb81e0475caf1979d8181b86aa584fceae8375508e6954ea05aa9798cbc8bc2b146ca877ada4e2701791e70d023d754d9d2342c01e294ddbb55d2b285b40f412b76dc013616c28cc8ba94a5f4cf6f32ce91c32ecce51ef5b2c2c15695886c2202c467a65594360aecd790c021202e58c02bb43e1b35c0c14791c0d8a68064e4ea165d3771cee46891ffc47cf5c5443214ccb455d59691f24618e33c9130fa2b6bd62328b4506b20bbcacbba3944b2388cf2ac79a01dfa8e10d638c6c74c4e2f515e004ebdbccc1f0a24b49bd8d9a7b2b2c41625974cb87b03ab84d36af71f5e6c6b58aa9bdb9da6372c41470bc63b8113c75866156b5e4eac8f296f798650d195e6b6e7b0e622ebf233b90c0762aed81486ca64ff7e2ef841c9e87187efdf6f4b7f0c9bd8852dc67bf2097addcafde30f6d8aa6ae00a7b6be297de1ff658f949c206d235e3ccd9cbc769f3523cf6e5480bb2d5fe10a4bb47485092b4eae96f93e161e43e5b491e23f46d98eb3dd2ee4d5dcae347b97842926fe6e992a8139a9636445d439d9f9f550e365e83ba81418187facaa006d2a8ab3c327ef6ceded52088d5809f773efdf5ea3e6962906e067e0d09b251a9fb877d5f492e592cd8fbe27786bdf70b4a5feab97f49672a41a572a6f34ff61f1a89a749e45de73b0660fba66b395053503c880213b141c5eb473a6c34d22770efa7711919882fc14ef9e8dd0f73e351511ecced82866c6a0c11208b1514ede1c62c1f8298f96752812d81ab5157bc746c667ba497365757446a3da6e4128d7706718b8113aa1dbb9f8b44b1b3bf99880f741075de11bc7cb487280bc7b8365f562854acf08f99917436347ee6ece89e77dc8438574b756945f8deb5db3d355836c543ae098f18650b0ea8844947b34e7607ec065bd907b607aea886e5f0eb045e6ca1874b8b4d57d3f74e6b92a8d5cbbd5858c9b70b8a7b7a568d33a14e4eb2613169c6495489bd3d87a16ac8fd46c82983fa67a01b10a191f54365ebc3741d60b08f9b637feb64527430fabcb1ff70eca15d38e94ec0a9c4568d539a69d29b91d2aa6f0db9d37eea6651663b389f8dc0cf307aac1a517eb65271c1c4f51481e8d7c1d1e717b1d5664690e8b1890fe735886841db8c12e4e36bc1f4da33cadfdd9795700e3634e4948697bec6c7a4febd104494a24607e1b578f32a5e463d374b696e1765020d72e96fb33d50169eb49f57c164ba334708a4716bf74f301ff95d9748df3f064d3ad6afcbdc0c73ad9071c83b582beb990be228320c440f2b0f87217d692755e389cf567e1bf8766756464b836d1bb987f0ef2204dfe3b94debd4a2fa16f74ea5eb505a204e5a89118a7bb7a63bf188eb3bce334f37f903189cb53a903893baa5b399d255923f51d73e24c4153e27a61cd16a81f063bd3886ebbbb7e85daed5c46fc55ffa21354fb7ea92c88bbd18979f0efe5118564956e4c63426d46cea232a1a95e9afc1f5eddc05fc88896c5f8d08fe1a7ee57989c9999baeef101a01f2c03909471ceb48b04f1847946d901e24e70abfccf6806f7b9e3ad2d750016937c094a29c34a9023035c4ee60af3f914815bff71ecba3be180e86cd405db7017221652c552dc45c7c4f70f72a9a48d87a414f45d3c3a27b55023ac65ea33e0943f4072de06c8dfedf7a187181625bfcbc10aa494d73a8921883f20fdca5e3ba15e3e35716a488d64297a9add06b9b5c17e2daed9af87bc6807ab2597d78c82e3411374ea7d54187d40c704529894b67911c563f59ad6f983fc6bed8a6187f958722f00d03c8cc1a8feccf3cf2706d028f3c4f2927a32dcf1e91c7598bc831994206f9e15e39b3961269f943a46d0bce7d77915306d0b7ef6df9357ae691b28e491e46b8fb46a7facf391f5e99c51ad61f2d8d46d572b8c5fc5c960a3ab0e3c6a5ecb038f7b60459e50fc7b133332ec4fbe2f2dda4afc8d0e16d25e9066f944463c59ec245078c7e3f1a95976f01b8d33423812f8494a2a850b2235daa3ff7fc30d845d40e3fec6981ecc6e03ac39f178e5bba92ba5050359f0b1a6c7bc31978a385513051a93f3633f35953601a5b9d2203119c96dbc9563e5a31f674a9c4d905560473f986427482a9759de806cec6bde24a9d57975147f5fa30eb7e4c394e27c171e67b45bb3065a2774c6dc212e18b4058a2dd6343dc670714c3392724e2d48bb0168f3aebdcb301cbd931b4eccaeaa0f4d329223a368cfb0772c1149bcdb7de856f1cd6a6c5edb43aedc88c82fe32f9a35f425e17bede3b65e1ac5a76504a7290e4fabd0695161156054c0df5fe50b4d2dcc45df6e62b8b5cc198d3e950a867411c3f932896f8a2d6405923f1423511f5e6cf1d8b10ae226181eeb2667896f3023fa7060c84ef970833ac50504ec018ac1826db094a247190e42f7a7d5d770443de7b7559eb081d20ad4fea2773731cf429cbfbc0b758aee8046ff5f172e1d091e2f254ab1bad1d468c197fc54969e4c01c3d4462560643891a3090383c4c5ee74bfd90cfe647ada0983d925c3ed965cb839aec930a1ed26f4b0f8ea049b7126b9458edd7de76d8a517521271040014f765f07500edc23b29b1f5f2268ebf0297bf0fab52c2443451552f49679b2dd8aa196331b78db1f05ab893b78120522d7f3232569481a83804dd7db7030376a5ceb7f9bab091ccba1d92c4685cf81dc584f63f275f48c7ef0d9035c6af62dd5e7e2b1f83bbc9280456f06d381b827cc66fe8ac1e8b2e71ceba8c665320f8b1a2ae176373eac8a0d9dbeef91655a716a9f7c1c544f805d5df9308b43dcb7bb0637712f1e853c9824f856b007391463e06975c1de93a2cc8cd97fdcff8dd1a936913ee3225aba2dc6eaeb20a9a9c49d10455bd1e1586a6a1fe625f0328ef65a8cd3c6770f6e4c90bccd6c265482ce1805c20d9210a011a199f9643969f52d747b1befde7397bc0f734d3698f1f4834e8eb1e32538d8be79702b484336c7d062b1d8715f99098822c09367fba231466e36b92aff131f6c8dbb9476dd87a58d250ae79b5ee1e8a9b7b54fa9c47d059bf7a223a3e2b648b933d597a9d898e43a38baab122a2a811f054754c71870ba042935e967a004fd964e95e4e5c1ce206eea78d374337e4a8511158bb769d51143942f8c6998b3503010451e6983329c6a59e8930fc5c165caa5a48ec838e269fc4d5ad3470cf3706dfff9fcfdf6d7e547fa3a889664a6474fdd8de1378643f5a404a0afc3acd1673a575c774530294e46da6a68c881dc8bf8d6299a34887d36209adc4ea7b55ac776d3d902b1b6afeb8266a0bf49dc7a79837e3738abefd311abae8db43d9a84e1a5f66bedf433818808b113d0bcf07592e58be08461828f677d6189684d018b6145f205b26ceae845458d853b36ad9900f27e03cc19959bb0578682e896e7ce7c1e9de5dc912b832b0db415946170f783c01168dffc652ed7ac8bf17c1091f1a524226578e5f1f5636d075a0b15733e2ec3e5251ae0805e82547f76e01e484a6adf52807de30c84aaa7b451f0f10e20124bb2cd0d62734703396ceb625aecbaddea4093bb35fce5f4e730247a1774779e7742dcf1a06d106b63c79a76a7c6aa125b3f71a5262ca93880fdc9cef3465e4df35cac7b71b0464ab11e0792d60038dcd923bc1ff7d36be030cbeca9adeaf5a077d32c25900e76fdc5a31ecec5bd9b3a34e89f1239b4af21f8eb7f48c1fd5038f414d56fc5c4c9589b6d184d2336e86e8b1efe8b9452845448f67a62eb362547a180b2263a1206642ff8715e753c9340369103aa58a80f87957840fb5ec83c72c2cdce02f251fe3301d1beda2cb9b289dd349e744bb61b171684d8ea00556ba4d2c1a42b886ea315f4526fc6e0397d9dcacdd5261caa95916c08adb553ffbaa375eb5e8433b0250c01ce92afe59f986ec5ad7cd0d4a8cc2f06493bcfbed3041a86748a22ce46c67a4b933974f9ec4c91af8283da41188de9976c82cdc630f0494ad7f51d747f1e72919f3bc3679766a36b4279c89b0a9f12e275a6bc6a634be701f8f9265ae4a237c145b64264f10f9a85fd4f913c4b68b734606fd9c61a4eae86d2e79433c5f319bfbc84dcd7d6f0219c037bf2b61bf9e4ba17c1a492de1451d69298c4fb87747133900c59005b319581413e3cc209d0c84d2620b0473455a0f2f86c7ad62b152d30dae6d5de93f5fb4ba20586ef7f42d6d7973390eeaabc70891b9692f646409dd976452726bcb8f7ef72768184fbdfc6df181e013ce507efffecb340d8c025601ec9a8255f57b062ee3f48216d74f63cd987c5658e3e125045ffe83d958f65717048df3a04a8677a4a4a870c9bdb17c2e80561bea6f06e701f5ab48d3fe9bc84b3f8baaf855d45297623889c6e92acd6c921590de6e5fc9d75252490d7e4518a54094ab0e5173922baf7119c00b7d24e68b6b32ab87e0841202521cd4f46082829f5485b01933ce0a9ce8b09325e917f9ec353a18c0874f5bf03e619e0a4d320c9e405448d54d2d9c2737da78f18ac78c09998e745a48eb00af4989cb941e601ab593bf1cf02da25986980cc010c57846063302f1b00a037aeb756a2a583bebf62b76c0931723301a5d7ce22867a6ffb6d16287b1e6d6249f56a9f15b38358fd6adaa4f84192a6e5dac81c3919085f0e2deb8fded28a40b6870ba683602426395c18c32517bfb12e51cada6d247428ad3dbd6f571418a37d2707a0cae0de137d1af2b69235caaee56847f6b266f9ae8d13ce9a456acf0c4c965f62bc894dc8b54f02dda3cf51222a03e1b6b9cc2755ed4b9c1694a834cb6c734403745de02cb0bee9bdaf151b3ddb714ba877cb0df975faeeebab6739e7cae50dac560e72ee0be58916d8b092c8b90bb25d946fcf1cfe9ebddf46145aa654fab607f7b62be92c58dad600a5ff1d36f9b6c8d1b466e97dfdd616cc9150c2afb679a3c8daa7c2a3ad8ca952afa8febaf59ec9e87f93e757e4f5119cda30534f3f617a11b235c5d0be73434fee2cf2cb3ac620a3401ce9650694a2b907830a03434e810e2ea3dab48948a0e7a0696cd3dd546271b450c0a2f048714f1e8495be67747d038a6291c4304c7be99151c840472ba5f30ba2fe2df5065d30ce4518a456d79237debf60362ae20298d2a61890fbb3fa1744ba53d58dfbcbf1b9951d2dc4b30da410d98e101ecd824a35a8aa62ec64ef1ba987a255d54005fc139cd6a16af29b0004d29dab681087092ecc74bd7c79d058c831d9325f7c2828c9e8e77e76a0498e6f6a3067432806d10a5aa2346e3057dc6f8358da7e7ee2ba55eb24f423a9d43a79306609c7120c5a10766e116c496641cc93349639adb255284f70147ca7a74681ae6b0df6e337039212b43e3a714f31e352af6397c8a5a5e6bb48e746206ef0e1760cfae18b1e26620dcddf61420eeaa3e6a8df3582d99350f56f292395d1aa04215f882ddfb2c1f5d5303b387f9d209eee8d0624aaa495046c806598777f9bd26b457f0ecc96092869e917b14a855e15031afb32092a9a5d9569e0b54a56fef83e7f8b592f28358d337af5e8656aa370b3adfa8470c81f73f3836caa481503cb12c61e268c17f524b5a31fc4e56c149ea75b02b97bc25ee04287b9099cc4dafb9f6a59682a6cff02d49d4a13ee6a98db3cd053ff755e603f8e43605d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
