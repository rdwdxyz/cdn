<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8715fe6de030dcf3d91d3c8e67d303a7372f82f732ac1edb33f017f01314308d1244da08f0324a869f4215b8eeecc7e0a1772ee140864953eb4f7806d3b71db3b5a8eb5093f53bf573cb465e408b51d501ce069563828c6b5a0acbaf7bc7d04690808bbab8483b138e61d474e2b36971424e1a0b636373f4c63b1b3d434755b60561e4657bd3df2cf85224e483d7cc0864fbff96072733da5b6fc9d58357b0455ae466c0986a0268c2fdec00b48746dfc7934700b77ead38ae90930c6f49e284592c970b4aec6eba5e67b6212f546c55a6c7875d8bd60a7f688b3df4f8094462ca4226abe7f80619567b034560c6b0d06d0d5338bbd624db977dd729d1d8fa20b08357c4aa769c74d8a4f22a583bcb8cf9ef3ea6f6ed77c7a62a943df693e6adfb9494f7ad87fd1f2c0fcde7dab0b13aa2424e2a7953d1eef6e97e633b25fdbc586d8fa3f495eaa653a336c040ed20fc655347af9ebe425235c5de15cd5671b0a8e0e9d5998feac26c8b4d731d730aedbac4820c6d3107bab9ecdc96dbbf074a77b6255e3b97a250da58ce7c834af8a6c04e7451b3e9fb2674d686322b8c04c61b08f5c705c257e21f41f10edba2b9d1348f0b4aa5cd23b6f4726bdf35fcf9d00c4d97d43c37fd15c2be303e3e023c1a90843bf844dc1e72447636a2db39fa73f8243cddb7d9d7e0b979598e53c881cb911b336ac1b78b0ccc54e05f7c6b20bab77ea64455b549644c5b5f6f465444cc0beed38b55d171ce809fed8cbb116ad51e5f0013df96bb2fc0f3958c44bca3aff074a2991afc8282bd16e9f933be664fd8604b8ca85e6f1f28450e079493614fb13e2e76b94609dcd17a2aab9e9050b255dbac6a064f63588cfc1654fb3a86b727fa6c2ac218efa630308c8d3ad7e2ac307599357e005812edd6c4c365122f2909cd34c535f43e6c91c58f5c9715d76eb8af56ae0df275809db3443442eac352b28087a8aae58b0e491879f8789e009069bfd9356d040b8fb8c60490337168461bcb975ffa798d8fe43504e808c1d71c5c1657e941e053ea5eae3cbf90c9141ca1d4c4430ae4eb1f11b12be2fa2a4b7679ffda8f60342d0f3f8ba9632bcee63f7135d9ce6f1ce1a04e24b7150a5a1bbe1c3b41358bac84cc2f7bb4f971ff36ca992ff1ae3334627866af0d48631557442138b4da48f221c5368635fa722d364c0c87e551bc74b9e03596215d2093f9b835274fa9857647c2ce069750957aae32ec46e40e40947db2fd196f0784cf6f12296424f7db7e8b45dbd3900827e9959b6823318363a574824e8a50a9ea9f23385dd0a96ef33fc135a7207b6120ba2a1eb9193b4a36e59f3d5593db05aedf7f3af996d646b06bc6700035cb491ce1dc98e4cd45aa4cf83842121b60b93d6d56b03d309e99cbab0e3acaf1364e8336f7767c5b0984683c0b3d4e0dd3f8a21f759986b45e2a88306fc17a20a86b13e10591498565ca4493e5ecd1a3f2ceb64a67f00edb4e09cca08477c97227f7f609151b434334f42504448b173ef30a05ff0b4f668b56ea59e4ebaca607d224a9f359a51c30b474f11516e7d19308de7fc2dbcca694d955fec0403583736737a37de7f0a3ebcce327a4d163e8cce8a7d290ce6d44e0d3aee05b1aabc49ed6f5da2cd61079806fa71263700bba208a9413041d7334860259a538258a0c813c67deb2841f247647b9a428a3e36984f474afcc72ad03e98b9503f8621e8292a0cdb9c926e6900143ba33fdfbc3c1ef36599fe77a1f09976e6ce306bde3a0d979df8b693197b39a2fb2efb075e9050897577d363b5a731e5984d621c7d1033e7c83a6c9921567a1491505cce7f3c26e66e4c183e55a2a0a43c5e9517b350c174a5ecc6f11ac59b97e7862fc074bd2d447e0a2097733aef0a70df886eedb6c32440254f0de84a7b854b1e203dd5589a0ea69e3da93a9ed6a735177edd867d04d11fdfc6c55361aab9c4a515e6d3af7e3306ece0d76d6449e5c1c8e8df10755121fec3c7472bada5d5a00de0e9b86cbb26dbca093a6563e79600254e193504c43bdaa33c635d7cf5a21ccef065de1dd56e8aba9d32f2cb3a9c2600043572778cde50194e0b1ff316f6565ca2b70122dd65e0287f8b50cc4758d002756b62dfe81b9f821732cfbfad5b313aaa27118133768dddbd295d38016ade0f582c80f8fbd67a47e75613a7a8b2837d7c304f97c84b2738da4a5a6745b4f758b99b86f755f721c5c66272e1e35d13ac43a9c7b1b38b9843e1a9d799aab66fb1504d535e88bca9219b0f13c93e53f7e679e11326ac4b7f1fa2ed82bfb6cb5ce782ff6c2627839aef9751d606c2a99953d70eafa5dbd40d5bbfd61f1b4f54fa3033d3ff7d401bfdf81d61c0a1ea82bddb7c4329ffff3940e9165900e33a5da2476ff585e5ec10bf1f2e22534c7eea076407be4e10392ec00006faf0b7724bac8f821c37a108f61dcc46d253d73c6b45362773018c7b38e06900e21b4f048e3279f7673f36aad5b971196a257186e742438855658dd8ae7f230672408e682ffff67b982806271df61950a5922eaadca35146f1f6595a3a999b6ef07b10f01855135ee4f349548606f97b27fa676d085c62fa4aaf5af4f967d157b23b4736e8f3b6632ea560b8c1a48ee0d7c2b7aff186e8c0d9e1daf40021f30e3735b18f57d354c91dbac702d18fe91678cf22d6af75f48bb9249429b2fe646c53bc7c9a48705694c57927f11e23c2c883905dc1b9298effc06cf11767e2034b33fd6ebe96a807fe194d4a4eab3060f7af86a4917e122cd83b3e7b3a41379b87834f9de10533c3fa320f89fea2e75d2da41f045cb24a413b805f9eb998e751eee490a1da2af9b9e3f367d3283ee79e3f9d6daba2a5e8d723e177cb57161155a62490fd9f6ffda78cf1b7b5be45c94ad05b1806f10b17892f1bd080eb9f4b0833d7ac3d0e38074f46375b28eb50735fcc1ed0ba352e4963ea932001e2ed2bf38dc5522802933f3373f7913b01731832b4cd1404ce8a05a88be653ba92d4f35cfe3e5a5f38d9bbf97c31c42872fad55825f4bdb725a6f452652fc5688536469de1b2242eaaea12299a8d12631640363f21046e5128ef01d9d791f26cc1b08ef872ee46d1fa33769c4d665d35b8c6104d77fc3685df1737aea7baeb489d59936a884367ffd2b071204d5be15acfad16473041371978c39c97ccf1618d1564a3b2e43cdd6d13787dfdd253f91e7bb05927bb61cf339128ded7154a0b4b3e543a70c03d64f8ab66ce0622b2fd2ce6caa04ad1ccb521c066dd53ef6371099b7d1abf3420f5a25550e5c92011996838e2e9d4deff9be888215b1c9ab969e0c9ed42d95219a6295af83b582ca364f0520baa3536c80c603c1bb060dcbcc3323286d7d45a3bd146f62ddace1c4a4ea5b0b50b63dd11c645480bfa4566fdf0df7e3cc8cff2cf9b6c7a39564539940f04d4869aa8e4cb02518baf71ffdb616ee64dab5e25f634d0325ee61cf79d5086361c928ef46d3f90be925d78b76f799cc0512568ebc97f9dfd77c554bd037adb59f907905ccff5d2b93326316ba8d6609ff8699fd571aa282d8ba3d7d706b76339fc5b3a191f08c41e5a757cb1c28a07acd2b949acda17199b8146a48a1fba1bcda2f34b4503b42cc6c5aa1ba08820bd8377cde2c3453e8cdbea1b96b77afb901bca255dfa4326e8e6928280d62c0d51b3412d510a9b28dd88d8c588bfbff0b6cd2a8681264ed21bbf5438b01e2bfed8411d7d2b7c59e16a35f7d64940c8ff8e21f085c9bf58778ef63a44ee8aa1699121f6c2cf8d481d5d624bc5ee7e84069dec47d14513cff433fa6ac360f389da295d05cb8df72af5029c73ae7f46aa89cbf38f36781ae71e609def0609da5d212448a99ee45a2b1777db250711fff9764821ec0986684565c6b38e96076ceef835af20ea661a8b0dc6afefbd558c25217efaea284ad81bb162859c60fcf335e1a7d3e496354fdc67a81e7fd2c5cbec4cfb8e18ec51f4879b70e9b2094b5095546ca816a1bc11f39225846b90834cf48f9a0fb39f6b82e8baa97266266107df34e5a97027f66fff7e6b4c40ca8ad1748c57b3cd91a4bcf62475e8146bf4e56485ca9ccdff73c1596a70b65c73f63931395b0660a636c127c70b6c0b5153066ec25606b55a490563e97c701426f7e38a5f2103d09d81859b9403d7f84b3a02a8d56df40966ee080f6ce5cee16af156cfb242f296ccd9b65a0fe451912a8d4cc412b32162490ba7a87cc3ced67245c10767201c2ada788b04e140f3523a8c108cc4005cbf33bc118a622855ed8727534112abd3afe3ed1885c6bbbbb20d83223b22c6a2651f0992bea4dd1df6b8944c2c3fcb70ef6c24df258c7effbe5409f5b713440a4927dfbdb16d090ce5858be75aa09a0acece18bf6f6969d21a4a75f99a7abc3a79f3046d10b806ea999a1ea7af9c218bf2169aec825ab2819eef1936a272b0a12a014140297c96f96cf1ad998585a69410df03610c45b8eb621b7950906181e3716e0418bed727429a64272998e5f1b42ac9d8ac6895dd3e893029a8dd2aae91ee9fa113bcee9ef42274fea88b1c796c2d5edc18cc46f9bbc9f76e3564f0a83dc46836f18a3c556258885e20aa8313ed19497b66d70e9f9b42d3135eab9cbe7a6443eb1b58129931c7816fc7f0dd40c5a282633f29127520caa13f1ed321d5f9e6c800a48c4abee966d5e8cb83c9e25ab67baa4902f309323990fc5f720c8394ae0066789d0515a32e373dca5620d32f3858409d1c24c3ed2136baf23ffeb4439229188b0b56d74b7e2376cff80a21ec017c8807d32b7c296e273dd99739c56e7f69390516d0b70d3b0a02c13c8a8e332ec45dc1108c8f7ffe17fd10c93d6336dfc18da4ab8f9f06896b5e0da00c350e0774ccd6fd56a5e362f21d47cf6b40fb8130a38c2815320551986ba073c8221968ef5a85e721bc174c9015fa28131ee4419a532ca41f2ee226b8e3657c94b2b48a2c683bbe8b78f94264b8d0b5df35c933ade6da7e1cf800e60074a8c71f59bd9fe6178fe674724f4b9e4c929435939878a55a62ca64d7404581b1b51f6157c4597e6f8bd53b71b407916da835545e6bf0f40a8dfa063ac53c522655ed7b9cbac55ede017c1e8b2ef4b4f908f7cd8a346a95cda164980c510abc2a8cbd37f84a95969da9955becde4efcee73c6b2066ee741288dbdc2aabf394c57c7406ddb548596b3b583c9ee5375f22964af02605fca9afcfdf42e27bb19ba2344244e30cb7cd1e531177ed6cf09c0f69c1a83aa452b1812b05b3ad955373f4310e617682a64215a1d783228a1ae45cc5503a4d5bb930a9c88538ac8fabf6df6a3cfe7ab8aca7ad339ecb84a4d8e259179b30bfe69e216c8030f6cf1bdfc15dd5944c7fa26f901ea3386f6bb11013392c5516fbab5cca0320a6ed714351071143b988e0c8c0302579f41639843d633890b2d85f67da77e3f03820b4ec839ebf5ce85d6c80dfbb30b8c445a9ad65c0a17aa8d08237a8130867604870397b6031e7b8fd848bd05c5bfaf41ce8f4136f698ee5999e07a319afce6de2297fb46bcb3cc10cb6e37198040fa4f2e25cc7aa7341e34073afea9040e0e38280fb5916885155f5557086f6ae1747b0beb68fa1bc9916196a7aa443008bd6aeaa74aecfe8e7d9b760c2befe1fdf8ad5e73fae875ad1f67188a090aa7b7dc709e4ee8c19cb7e2ba71b6e32d8996c000e3d67883f937d67488c721636eaeb2f577d00ae20f4b30b143adc00d59aa04902fa7c92a23ff05e8e91772a4294e353d5daeb3b2d1e3078732267a06753b248f860ebf2c2eff7c7af32a9f8f5f1b15c7848e79090b59aa2d75a4793a78452824872a7c46870f34c29755480a70814e6bb7ff903b21afa2076c2e6de920251951f309432cc34f6340118b4f0ccadb270f0a1163a398a40836981fe7396843f7b8cceeb41fc8a12ff9d1316c4bcd16230ae5380290754e5cce7668c12c328e4a7a095c93c840a6ebd30c5ed2a2d755e75d1e46352896967ead4ca35eff10922b00a625297ce5b9347e2fda02eadef5ef9432be9d8f31ffae0b37eb45a6baa922e31031360db82e1e8614612d93ab38c7102f8d54c9a30636637ad6ecfd9d6929ca9b9ab42b0db64f89ef1dbea7b31434169b37786c31b42c49e6dfb7cfd459476a0f5721d687d8864a027a9d6361da5457a9f762a7ccea43f5dbcb6c7c8f11bee6467a4e81aa3780d021dc54eabababc0538c2dce51abab42dc049f734909b3560f82fbfc25e218d5bdddfc23489a5727a13860ac1d3328a9ca93a4cd2c78954e49271809f46d456b7b308f3d7bc6725eba419bd62b44b4f1df34314f5b5ffbb6078fd4a21eb7935ced3c296e21cbb2441a33b9c2f6ace5f24d1522f5683ad6f9865c822831e7ae781d606fe921f5c574922804e1c5d4d76d120f330dbf6477d8fd5d2003b9c0c2ec1cf2295f6796b54e0243368e726dcece577dbce6cd1d94478b60e2c569a0d873878271dc8feebdb22abbf589b19e162b987f396e5d0bbe31a1120df9c22d6c27445e7e91bc076b579efe3d93b62648153a8f05ad519f55759d62e0fd773dc749a66d41acd8e18c479146de648c5115263749c5fd4259d8e1aa467ba88da9e28f520d54802fe0682a6605d270c32b5ea6c7a57fd0d40d2136267f56fc3df2bcc1176c4ff06520cd4e803431334d323c0bd6f5610de6c982a40904353209e7c58abaac55af8b50f9691667e975ceacecc93e5b0a73b7316caee53a36a11683ad2bf582a012023f6f962c99d68ff68cfaeb2dd72efe613658ca65b9b502a241656c72900efc1f8abfa40d386fb0d3f113a43e6d3336f4dd2f46ec6041b9827196ade7e1b84700fe333622a4ce54e7a05e8273ce460dd83327e80d62afc24a52141f16e1432f7b163a677ccb749da8c7cb4bc475655835cd3b0867acaf5edffeddf4b7d7384c3a5d6d7e2792e732cad7046d370c4b5762ec2181a5b5961fa62d5274307c7d18f01c0dcc7ad95898487359e083fdd3b1315b1818e6744793871fb5ac1a65eea850f0878c33dc891e2e62f66c0dd6eda182063360f3345fe6b812251e0790745f4a50ad115ad738fc7e417a00690714c0c04ee7f2fe2fb1f9e598e54d2eaa4301d3ee6d5255706e376bc6ceabc99583c68f36d57edbaded6a669d6be8c13480e4b5975ef90bde35eb6f1bfa1389650aa1833a3e3eb9de186db754797d961677f823c717af589fc5d2122b1c2f24529358d9d8e4f86e8739f1ba77a33d9a7a41a3a098528c064b46d149a69338234ed5dc1a9eacafc7222849f166df17b2a8bdba99b7dc0fd0bed379aa5092a94ead7a86bdd095e7bb7b3e5c6ecf35199276e2c6397b91f43fb380325d26ee38aafa83a2207027fe39014c3c57fb328edc64946014265db414e8d80b38ff2271921a128cc052a317beabad6d680e60cf10e1dae30a1e7ae1de3b41ad87690d5f8b9510ec3e19eddeae83b70456f0a7f868ad9555d0a6cd88358ff1d36a5c3aec0634a4a9b9658e95d8be16d0c126605512afb11bf3898c96c3c643dcb1f6cc9c46f14fb96ce1e11440d2d6e09f0e88a213ea7acccdc6cf073f35df47ce71359fb55ceb7ef9864c9fba2c62a2fecd5d1ad3c6db4ee61f3adbf4fd7539f4f73ebdbdcf94fa6e51bf044c496b76fe7de048b1bca68289a708fcadabb82367116c62f219399204f37ec84c0d477065a7461e4f9629e5f9606d0c4f59ddfa9a8db4aa0df6da41ab6d570fd9fc18a06b8880750aee8e53dea83e4d36ece30ef94c62d97a327207f15077c192904f2029c430488d79318632952e9979877e32acb46447369e24d1008b450e6979af46d1d8f7c664172dcd4e6c80fdf031d31ea343e53d469abc7a0d7c969ae7a73b221a2a5fd75718ee8924804faa8c11471654a8f12c03a0ed2ee9f25c2ac7425a6dbd3b67c074667572f11e7e37087ac2ffb95ce446a074bed5521e8713f7dd2f57cfe47a1d98b4a10c1fbd5f448f0868e71abf37d94bf18a3a4ea6bee1f767086fb79e00e4099b636eefb03158821e8670f3cf9dde9c5f53d16042f00275d9f3ab3a80b98b3616c413baea69e7d7f5a61685143c87fce7c7f6b3fdde2dfacdd8c8e66ab43a0da8172b5a2998d91ced5785b28a99d31214ee64974aef22b1831838741de4506eb1895b3a6493eeecb00f3180d9f51b9f7dd41f0f2c76106986024f74cc692ecc47d101fff7f66dca6b08dc2475cd58a29880c4b76474d178f68fc473602ee326bb1e28a6da651255e4e72cbc85a170bb0406679e591c096427134095c799951ebe6ed7726b7f5a942087b9836b0030ff4073dd883cc39d6b2dc4f5df43b2fb8aebd0fcdd4152d88ec99540381c9bb972b080fbb1d9c03db7c8c79d142fe95528c8a2f4c184442aa538e2ce1c16ab047ad7aa1f8e39d1f2ec7b6fd1f4d76f4cb3facad18943e5d614439b27638ecfbeb9b672190e9dc6b5c15733144589449fd04f2468bd44e03e1884c248103325df984c4c3d0e5f7d1592f6bb5222d2bec43832dd2f54732918723163ea9b09f939b54e51cec1514217c83f063bad97ab17bdaa2f58ede9a5b67d01589b10b23572cf7ad56213537ce90fadfd756a3c499af371c777d83a100a1f7ece2f9b4193056f76a9d4dba5ad75c526d8d7181b15fc6933f4ca6cb907984aae3424306ecaaa4222652e8caa63882d5fca0daa25db8be34c455e3f0b32d5dbe481bf6545a545c7760717c16e20c1b635c9f5d1e7cc0194c0d31c03f9a4a77b13f2e3d94338e03ab39e4587b2fcf4504e9fb5bffefca91d8bc82c1f96b091803c4c518b97c67b695cb78910bf9c7e7dbd5ca80d456e02ddc57421a3467485be1df3440997873af91fea5771c0ade567d1d47ac817669d7a4051c8cd795c016b99ca5c2548a597e4b8fe304a57424aae8a6d9a011d75d8220af30607c8d0c82edb3bc5449fa50048e19fc199b063048f19ab0ffc7681ffb000ef123bcda7dc208292d954529852deb754b4432d6d0f14bb953a9bbd245b33ce0dda32bee1de87a05eb1c3bf8e6b9fc18ed5ae60582f59b041f398cb55c54766b993a34cfa5a94e381c62a572c8080214f7b4a65a0f3943ebdde8111d2016df0368e878df60f506c047e5efe1cfa19c9e55ff98d0a4a062e30eb4ac52243c6558688ffbce48f4a8a13620cb6d210516af191d79cf433174fd1a381be09bb353a49591b8f9d09bf714ab7bbcc0e09fdc1898960e3e43add69f022cae624a3e514bab3eb085fe1944efb208607ce6ff8cda9b13692aa07dc0a669e4215255c920ee4d4a8e30d5de07f861e8f4d1e91f16197e67dcf12cb4bc666815973d6335c7c4e6c6f2e3f527181abf8b9c43b3bbf2ff40b7c887c9e6caf0ab094b4dc0fe169e4abdbfa47c0693acbfecef2fa458dde2f70513176c91e8c2a2574e49b9dec11424ba892c62572f91070dcfe940967a2a81ee735037b38c6ac4808598381cd5ac72a8dc33f7a85eee09b25d4384d569ac54ccfd455a9a745367c72f74473375dcd69b68a5ae296c0d06fd3fa12edd1187e700dda0857fd335045866f27b264ac5b2dd04807f5e032d0cb4953e276098dc7303f083052ae0e277e1af3a2b7b98af0fad77a60a4be3b682c7b77d05659ce85c45474caf11ca5f702d1a630311f4fb8ee9bbdc0e4f74025a5534678262553f9eff3a01e5d0bf5e5355f695a62e9769297ba04d272527e5ee8d76ea1a83550588346e150aa2be44fbb3ad8e0b38a11e421d2958ded635596e4514202e46c30c8c54a19a2963ca0dabe68caee52051cf65c97f656652f838012a477959e9c74b5927f97d908db7de0774edbab8fa4bf1d187e30eae21bb9f15f4ff2933b8a917d2fb918649edcfd45f6b0d900f1d93de1554aa295fe2d2d7ea752acf2c02bbbfaef33aa10aa3aedd949faa926a066632b335a92cbe1e8892eaa899b708df93f9713d3317dc4d1fd538e9389113c89625c722c39b48398a255733520ac859d9287616ed4bfac6c886cb51cd5443965b0aaf535935b5310841f58234f7cdf7bf25ffe71373c23298e1b3afdf010b40bcebb29a1b9d77a102cc22c93ea08827532d7fb378126bf90912e2941ca7eb9a16e9893abe1dce1149c1a25ecb07a20ebb6b77690c78a29f15220401105869925e76e5e7b6af742b1ed1e0b2abb172a6bf489f26144582d1cd2d83fa9fafc826240c4d7096683dae0f26a1cecb962a4d25f2c33ae901076a5afdb279992852d8e35858a421bbff8543c0313c1b9b5c09be2dc1a3c196f30ac7b07b11b05412e9f8f16165caef3b7b2a34f7c2a553a990998b7a0630293aaa9edd5033a0dc4e53a8b8682bc2676ca7c48da1f680d193f67426b6d479dbf10f1938dd0c75b4517686e87847c07b22e6cb3bbcc133ee6e312980f38cf107290649bd4517e965e09b1732d59924b15d7c69e206c57794f17f8a727b8e345da98e544bc0d63a48d5bde0d16e8b1c45751ce11f4e826cd588cf3826999d837ccdb4f8a222582ca4d3ae2dbda7ea6aacbdd2ddb9e2b9bce6da4154bfbe25d7194655930edb76aa9cb327bba904fe20b3b8389470588c9a479b177c202282862a3694c14635c2ef38fe53d0e1efbf3d613af76d6b80672c5f5efc2614840d7b94787a00e1ae0c6fcbaf728cbd8f7f3eb4be6222892ad761f0b03efae0b687f74e795d5769c1dcae59d040aa55c453e80eca2d7ff8b89e6138fa350f4fed575de2d5ecd7ba7f41e921f1782a233533c6283ddd59c4ee52a1d15b1bfd7e13243d21b8004b3a95232c15971831d5e5681c194a9502b27bfd3c12b8ed8c435478675c1ec7b03d7a16b8c34e104f6ca5d9925576bc691e4ed4243d3f079dd428b49522c43910481a76736c0150cea03ddbbea63f9e721dbc0923106e1cbe5aeb3d655ceebd75ce9624f41d62d9b4ea9494b9b5ea486b7265ebfe272a11eb37ee9c7b84f105cef397b13d713da4b88f15638d441091bb421cf4a09596440d6116e484d70be129e0cab80975438f93999c53fef23b89bbfb8f219b762487c27250df136ba4a8133b955611521f40785ab0ebf29f7e824a1e9fecd3661995bb7ff36d6b42650354e43837251be593006da920ad483034d6167b9c73847f653a27b48966476a5ff81adf24efb76b330c0725aec5a59c485f4c446683c647129ad3522a3c034c025fc9877f87fcc29b24114a155f9a2b31d372e7f68313a3964d8731b6e32e70ea327a18ad905dd802c1a7f16ae65f6a9ea42243b0e052bd2eb07650dd719f8d1488334045f540c5bc4820e342597150b449bdd85f7e7abb8cb5b1045729e3149bf598a77f67ef41fe61b8019ebe685a8e7102548f0091e9a3aed9e3c76d57917306fb010d5ad21254ddb22d1f361d77851ef3d0a71de9a713073d0eeef69ce90e4297c51dd2433d6d3d18561f18f77c13f6def83492a9f85e9e16f30e4e9b2a193a135282f8be9525d76455ca1628042fb0d138a85fc49318536dab5397806fa0df4993d142e796c806207c592e9b89793155d96d9fc76ac3e3996ce8913cbd5c0ff7696d4c874ef0625923a844e64280589c637f19e7560eebada80234f5ef3248ebb2c4aff0b53aec327fa97640007570defbc486f54984ef6c24e4dab08e1fa7dba3bf851f2f63d6dff7d2166b4ad73440c7768bb37d65f1be97acb7f569e1a77af4d08a95a01ec1f585be876046d20f1d8fc7ae6cb4b630fb758183f13410debc0492dd07daca297ea113264d65147f6297b74bee71e3fe52bf079db6cf8876797b35b0e6c1443ae9a50df8be44eec814bd35ddc80fe3737336a2ace0e969b8b87c4c2bdd204150f2a31556bc7dfdbfd68877769321a9a66997a85a14ac8030c7d93ac29f7d59683721b4d960f28e53b90a89c7c6f70ac335393027db852fd4b2ae22ce184bed1baa6436af15f156703496a721640e44ed1106acefa893847bb06ad1c8d044bac29aa3a0bae47be94bd7b4cf48836ac47de46f68e1152466559455de0165e820671b475b12988fedeb204d7c9841f1c96fba75d74d779d423e0d8cdefbef3fcca7e64b310ed261b5947bc636bd614794cd44e40466e442aed9255697f3e0c35b09f609b4c81bf4c627b8f02189b829fbaa4c26e47caab2645102832c3ceea571bb36e5672cef2c062c3c53b9b166f7872e137da9c33bc784b24bc37f317a39b3803b679239be7ed8ec378dc2fb349fd2974c548e341495362c9b09328b0b7869bc7b9896e8f6f0ccd9baecb3cd79a618cde248c24786ee10110dddcd840d154ea80831891753bbb40a3aab24f3841b26e917f54765bc870efb582bfb31930b8c9a685ef2fc3919f78acbeb0e7b605fec27c4ff63e69bcad905505134799c10e806bcd3d9a732f7b170813c30597d3e7f7ed8a85cf104280ba2f9653c61455c01f639a9afafc5bcab5e9b5235d724b31b327a8ed28027f814e322b23426f55c9fde90f5b127c191346f866b988569782d8edce8e4bdfc68286e4f1bb04aa529e06fa1a47fd5f8cc69de7d6fd6c99bae833ad9d629d7b847ae7050f4fb43539477b6c99afbd5bb001b876ba3b5e322fb589acc47a305633f20faeafee21db1d7027603cef82bb82bae6b848296d2818856a8c65d649c096071e7cae8c965db0a00adb0f4375ed65826f4511d160dc8274ac5b392c2180bda0f2a19b597df7fb86743c8ad4c45fa0a4fa64f2815e92a83af77379483d0e52a0215cd237e9da0598b7b472f0125d8224f3b04c5227e88bc48455a311b4c3406f278dca790d56fd816dadf403f2755970b99e0d2b8cdc13310bf523f19fb2b1a906846d5b7a6bc8c0817e2b0d6dcf5f1bc1f4cd56f319c2fff80e251f232342f9ca3029cf91167dd6e3aec0a0449d7d0ba0571b1f6f6547c65820906a68686488f9ccf0eafbdb8e5fc81b4a8c30221d483810df165d368af7fdae9ced6881f7ba3ace0edca233c54acd1eb98b3babfed63717ddad2c56e0e186d723888e8cf0327ccdc3275be60b628de7d3a1e65c4856d795b7df0587e3b86343b9995db7c685861241d4209648e0a9435010da5383ac16c99144c4c0351a9834551177beeee45d4a2d219c94c6591fe96aaa54957853bccdee1f255321c60c9c23b5d62cb3dd75b5f865bd513e9a7e6283d097bfa19917c3a392018e7fa105ae54097e070c5a0bff1e07a06ba3e843f7eb1019ea9b511545177fe729e5564c66dbda1435b09c12e49246efcd54c73df99965df5ecc7ecfee55d798290ceab5319644cdb175ecc756c892dba9c66dca700ba8ee80e843ff4eeaa831d12ecd694aa96e1f25dacbacc5c7c433b5741ce58a0f165012a9086a96bee40dde9878ba7d62404b8cf4f227be1e3359405a7564e5a7a05a36af52e86d6327034a716ca4bb1bc4e3abf7e931fdcdba1e1a43a01dfa088a349c971fda910f0d2b78d53d0de464f29a8185fc043e0832bfb6e3c55c9b012385b01b32767e6cf1845e57663bd232d6675acba03fb2c2c014ab0aaaa755303635dc68b7dd9a3d1798658e78629a9ba4ed569ac1584a7f208948382a89f57f59fbaa556867d6131bbfb2104c0b860dfb963900b3348ae0085f175956089e867a22820162707772c834468d585478491e179d4bebdb9fcc681848dc68cb24bb399c745ae079e4dd74b40167c5c47b890bb2b77d4f1b43620ecce3909128a5a1a9b417902dcb89f80492630843bcbe9b649a18f999859c27a6c265eb7dc4b650e2829b0bc1a03d662ed016881f62adb96d18bc530c88ef8a1438ed761e9e4753a86cff402ad6f1239ff9e884251da67b5ad6daf73b2b1fb320426bdbc175de3d3490081bc059fb5d3a9a3df97822c9443f2b5408f52fbb1aa36127154cb7cd358aa583b9ad4123c954dd576bb36d890ec491070384d39abe01510a23dc06159a7fb09ee5802ded7e4bb8f61a3029dc6d38086cd45f09a258e623fdbf7d6c75076508ef967e467ca0a1afb3f23312fd7bf47cf9a370ea2a828575137402a58696babf622f8559035cb1d96a3e017d5023e243d2a301409745fe68b30f94a3c8a3de9bc4c8ebdd63dd11a92e359ab4ea1ea289f0f297aa1ee188335357b00efb6b0153ae526340332cd3297a9e751e59503e59ab0e081855da72186cca7f6bc19a3df6d557a872093c11c5cc12b899e8bb18bc5af0128ab1b99a8895641d05a58a5e4c98702c16321a1f5699a8d6d11439583f47f081042b75fda4f808ea14bc62ef37a0fb1159e4fecf32007bfedf106d8e30be7ddfc90d63c9bb9334b4ac33f7458748706b522e78a2228ef552ceba05b5e20b7698409e41cd0ba908c4637aa61652dbfaacbc8bd55503a9125d0d0b0394f1e1bf91d090b804c2afd3ecd46365937b81eb3f13147981cb7bd063f8a23ccf404211ad4158f43f411837ffdf59ca1bb0577133737ccfcaf7aa2f3f8d22391e09308a5e72f2186a6ec5287f4b3c84d276407db22eba907ac391f8704722897efef12d40fa0c6a721ceeb5fe4ca8013672fb01b9a3f63896300629e03ec2eb1391b9d426f2d88be5a2941274e9c4838691a3ff51d9ebf8db64f67ae8c0d8c72fb12c8ea63ee075cacaf337bf7fb3e990b262e87312f4bf1f3745885862feb3b56620324984f2e65a214bbedbf493bcf53f15c9f86d666a03d8d076fd17f39c621cb4fc71c435f0f5761e811fb0f626e8a86fd1139639638692360d1517c94abed707aa87d5c7aba269cc77fc744a75835bde93497a4263eb25d622a43de85e62ad5e34a7a3d2d7b9a832c3f32c872bfa9c14b022cbbd5ed06c8b025475bfb22a5746257f6938576104d00ef547b2ba8fc525e6477dab285a47d043af1442374a83f858498937cc2154f16b4b23da7a7ab8c27b172f9e0e8bd64eba763592038211d0a6ee663b38581561e812c9735feee664b74df4d2128b420e296211d142c32448ef0cf9fb441d835729e579161ba6d925d705b212bdf86599faae8d56e0c28a197679f5aa39dcbab1cff7ec2e0ca422014db8b875e4595f834b3cbf9dc7b65eae2c62d438d4a459f3dc54fe61b0cd7158400016610053ca01c96e944f3d1aeb5024e49a3894","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
