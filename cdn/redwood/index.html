<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99306e1b15b7865f2769268d8b725bb4374415e4fc3c275514242f1a0980bf12243eb574ae23114adc5bf4ead7690e626deaab3e5b35b1c8863933c793118ff0a05ca9142005f676786b5e23386d04d8b484b35eb19d1ab063804e4238984cb170189f71828c6681c9af65786bbd61af17af653f6db4a90ae198196b63fb28778bdbef74601f5808d870a8c198d6140006f77d3324ff8f9f0b7d2537f0b7260addb6d29dca26aee0ef8eef410524870e734e012d0e1a7faa58763ce1cf795de0aa3fa47bca802ed17f7c188278b58762036cda873397bab5fdfdf419812dadb059c9532102110b2d6275b166c76e0ba468268df121a0f940b837617f19038429c46ba5c61dda6c591c7ebaaa8d5227011ad0cc557c5c56b153b380a7b01c6996f9c0bce5706677bc6398ee660c05bf1d8cc63dfe6818b9bca56cdd5b32d2ad3d73a6de7483c0c98d19b2bb3e50a56ecd2e5d437432ad8d559fb9d61c5d37221630b4b993a47543c36ac538d14f4ab1d007deb981c5b893dbd4f82724fb74769f72dfae71aae57604faec49d78019cb652e21e20fca3e980f6a1610259e12dd3f499f214dcb4835e48a590f26c055fd6776dd06dabdc12c176eeda0066e88abdbb71e23b49469f1fdb3c1acf3348007285c1aad0adc40c57fa64c36d63b1085f262867a01f28265b0818f2a69d6dc9c0dfd516f9f56fe293f21dde4fa4087471b89c6832f58aa6596fb09ca8e98d4a9ca75ca28d3a7af6fdd2c76cfefc4d912486a1dfa528be4f6fb0ffdd6648d412d6ceaad5bb27b5b2b4f6f7e960b0d40e35cf450e4fd508250f4ce1995f49465cfe2defc90b4fcce9e675058bcd6cb317fde0d4461d11502e8b747fb1b761f2f643f382e8f73261a744f8107544607d4fff80792c8bf34dc2371ce31a1646f228abf85f3b7e96e687fd367feda2bfbcbe1770f18af187c1add0a90db4d6f0318e6e27458edbd8058278153d9f75511bef6fe7c4f3f94c20b48bbef5a36652849d47fef239efa71aea379e431d47d7a3620c68909377bec3f1b672df0b15fef2725d656587b750b4a38413c78ab20aee3c828d70e714a6b264eca48e5a9c53d1e64f5853a8bf65ea35031d92a83f542a888a1752e494b95e0d22617f826fdca3f05615f7a9b693383f73a72c7f1530e8407cc4b0057b3102e182d02e84ee1400a0853b0b26d026d1829b64b524340cc83fdc6660b06c2f906475688b0acfa38599137fe04568c85f32573c993afd4f5a193fdd94a241bfe96344163da12da6d0dba80f5b475e8e1300c165b8e13541745bea7fdadc3d5c1163387e04e20a1abfbc8090ab303da2222e49b95b49721b5001560c4f8dc31471547d253f2a626d88cc60a2283ef5539a03cbcaaf38008533720a78bb637a28440249187dc0b87eecfdf1d4b77b44a826154a8720bc070056e6ea7985ef72512e6fd4c71b54f544022067e1e93477691adc8400bdee9de91a20d398d933569b38c2d8401dd6c31d29ed5a107e43377ba298af3e5fdcd70509c55ff77f2f22579756473b5e6886f658d2b9fcd56249d03fd8d47c1b34bf4093dfc03d45aa386c534b2d4195d2fb05b49e601d6652d800c39ac562e903f1601c51b417ed70dbeee6a57751b22750af4f10e41d6c9eb1cbc0fa4e17fe5e8176aec754f77cf44512dbe39ec479b7db1a5c653657e27b820393e3326713149d85610c4527bf6fd89fee028a2974b744ed7430761c441bd7aa80ba58e1492d6ce2a7062ca20b9e403596167ea4a0002730450fed895a00327caff8dd374a432df97ecd2dac3383ce6645e31a637cafb54bb099e95a44fb2fc79a90ee44bdb9bc36ed39c2e4d7196c535f183f79991f0c4d4e7e3d2b23cb79846fd736a7359d41b65294ac9c9bb5fab11787c09af62b57e6cec9a1220ee4ee7b28a8a3aff5cc323be570ea0d6481fee307d32141c98dde459b792b436660d4b0222cf011445175128d81ffe421dca03afb562596addd372fa272035662697ab4d04fa881346e776d1b42a2f4267633e71e047a891668e018ec615398e380f4a3e6cab416fde5c2c9c4b905c3ff7ee18b487af8c413e545fea6cc85094f2304f239ed98d51f1bb394f43e1ddcd0bc55e2f8dea15ac547c7917e087efa4fbd2a641b96608b043b857ecbd39ec8b281250659c719eb6422a76714471ada8bf2fb02b361259075fbf587f10ad439e0dcf95375c31842dc2f67fe046951e1eaee822ee0d9038feaa41d20f3aed379b146754d036271d3fd0ceaafc580f8790546aed22dec521472379af8896c2b7aee76b5d7d63f73965c5cde5b27c12d929424fc8a79e82f1947b4e6093ef7d6a5bcbe04db350e7820c87d6f1f92f2f1029ae37407d2434e5b5177bfa4131664d3700cf682023134521737b4fa7d3671006a775fdb91622d46c0380afeefb56cfda6d43e5a2ad8cddfec5354ec2b1cecc15a5f041242fcf0750e83d8bb196ec912a8023a7079b1fc86c225286e2a443fcc40ad5bcf35b19551cb0f38c2e71d0daeaef88105f5466ae3750daae9443714bc1fb4fbe38da5e1f789fc4aa2b5e448da35f35613a078d4cf36fbc2b53be073dcf7ce364f32dca1db882fbe3d628274b19a4169157921283316b9060246cf215ad19b7c7788e09d1d13caf69be1704e9656fa38e32b4177e5f8830424f44a07d2d0628406a40867bd9f92526e6afc0ca8ae4edfdee23b303f471284366422c3b51e2e31364cf753b6136f3f752fe1579fe1970928cabff27c83a134c19eec06832889c6a526dc80db9be97c864e6509d876100618068912695586cb4d680d2a430390d671bf591dabb30ee0f80eaafdb194da3e36cf5e4270ebfee77c5710fcf41b39cf04917832d8a08a8cda6835ca7301a2cec754f2233172f3dd6df05c25280f2cf9bb6a1364fcb3a672ffe3a446533585a99f70a9d36c6e08e5de2abb788b1db8c0c8a0b92d8bccfef4975f4d972cc2af0252904e1c5678295f296eab7c6e6f255d1e6704abe78b7ae5053c5433d4ec827157382925db9db6b3d40e970d00f56619e2ea43399d50ad0a60fba91fb3b581673c11b2245357c8d84b0148ace459ce3ec60af7809e62469c0eba2fc25cae2767a3888c967c751f53cf07fd8605704352323645f915a7d11da84efdb5380a4d061e3781ad76d824d3934be6926b144b222d1f40ccf6cd4b587a4175f35e94c70435298d625c91dc3c822f828105cdc76e280561418130d4739750c3c6ec819fdf7e8a4ed7812dc9f375e48fc1b119ff3db037b2462fc16114ef52e2cba2d3047d778be2c109a07ac6fe1bfeb601aeaf454ca67b3e262c75b126db95fa30eff0100625c69038977e338512f4933e4ade6d1b980ea4c673f539574195c20e981e109b0ce10c34e3e2c5cce46df81fcd5ddc21f957bf12e21c31ff7e9696904d3e1dd96cd7b30a1b774c267d1d562e65fda247a19abc480203fd528f6633aa65bf681c64642da49f9607285cd9edbd58680e24a77959fa674d418e7fa99e0627fb5a45e7fd48e8fdc96c7d86b7bf16bb07c57698517ef108b3f6a5874cd61ce33f67d73cf7e8bf8fe8f4b10e412a783419518bb0a08d0d91fad064be2150e866ca12dc9da2fa7b677c223c9e039e418f3dc7603bf3d309367e8c6c3de9f5459d73f43c52a59a7ba5f8e52e0bf0db984dcea1d0f41bb556b7c0f55d6426057fe3b434361b9000f3845504645abe374ef736c6ef9ad3d9a49a989197eb60e72149caee8e555fd1450cbb932a362604cef6cd6fb42540b43d93be7008d0ded77ddf2e3da80230a39aed9e0cad3d70c925c63e6e4adef5b8c552000922a65db45ae748aa52feae06d771b647bddfbfbac684ffb0d2445237eee63f53e130a04e346efd4ab5f6568d510812a4b2218b31ae57dea8ab8795f95cc68eea55cdd5d81f23daeb0a6d0df78888231c99eb9760d646bb7949fc2b96c804af624f370c28c34aea157e34ecf02cb4e6ee87221c8a3b71b8c0b57a6e7a63c0989eb8c7f7954fcc07a391ff30fd1b5421cf0eaddd885572b5394369e0751f3427f3198d8765bd906d47331a598e7b06880c24ca38310c4f59eed684d89cc097a5500a064b711eb6d36bc3c49965433088a3bb61dd24d82a6bce12114e019b8cb02dc057e9b0865b77b0fb4a4049f3cb1b38b99b0837870e03033df8b402b0a40cccc06dca1a9433e671f9c031affa4d132207ef1cdfa23175780344c0e241a226905ff260723f27ed808be631167b5e4c26ced039381616f2d5a2b5d08ec8adc4427b4a146d6d317d21365c6a7843e8a23027204d76a4ccac46f77c452db5f0535b44d628c104971e160382f4dacc8e7923f1760912caa9326225e415aebb49fee2a61cb12accdde010b616449c67d46d30e1e9b1abaf40a37ea0022b2aa0d557a686d55bc06b453ba63e3a153554864a64871a7da1c3da24dc2b82ff0d150c36d30078a895ccc919454be468c4ea95335aaf2e98660083e3d74017bfae06d693ccefd7690df4de17fbfcecc5afc83e2ea52fd42e4c1a27c1e71958f2673d3c29b164c8105eb91c52397c44e70966432eafbebd941e345d934f7bb29929fb4f8b3bfe71482900afae0a55a475eab7639cc3aeb4480aec95dbc0158dfd0f497d79b0bd848d078ab11002d3521b42c7b40f63d5a4fe97a456a1596d5536839065348ff01333733f5ece8c7e8e0bc62a4c1fac18de5894e645511aba274f95c33be377ad6b0f75cba1f59b125a632cd01a9a82b313a9f878df5dbdec9d1365321ed91ce4685950e30ecf81e7e0b4c9796332cfb75f0f6542044613835edce81d40313f17f76834543d9375364604d1bb5f292b7a6718b1e933af40cbf68ab795cfc80555b43b39a0e5a0379eb010d0bb3fcdbebe0fdcb4c577bd54df45f1eef686809e96efbc8078fb02f30523dcc6f77dccc47b6f423c0eb30e6b5a559b460e5eb9890fe58f64bdbbdc539667347bbfe2b18aec65f2da3b9d61bac136a525fcc1713b351837d34ae593a6abf56018b2984c0bf9f8eae1879747e4537b45e801998c92c13809396ff690b58591b02dd16531c2dea3c61d35952d0b58d8009b7bbe7ce2dbd178540c55396c57bd2f8ae2ca29d3ce530da3aef4686ae36e18c4a97f4d9f3fb419790a639c1ccf94b63194abb893527dfb4ad932ff2067d217159ece3e17f4d023f2713be88fd4393c5d0842d38ca5536b8753d99b84cf50a90b8886bee692e54163807d3dccd4953632fb3e92f1e26009d3d09c129394cc7a84dccb07f51870947a6b58716db469d0ba567defdd688abafc7266a5bfd3ac4a92712e61f843422dc11c4e65b66d18163ffc3fb5e23b06b51c2075cf02a4948996109bd51d53e52d0124a8e5340e03765e2555cf7d5f8b73fb26b39aa2430f37514dafcd5eac1fd8eb33cf4fec43ce1ff312a00963304deb6fb38020721ee8289b8fd7f030ee3de5a724b18776dcb66e5193904e9dffe9e988dc4a795fd4fde1616d9a6190ea3d040d8eeb7fb627f8049569c672a069f2415fc3a20461750e294a018b4413281b3430e873a97abe1cd6fa5952cb54d7f7f8b2acfc0cd713f794e15aab8455817b4075ceee2d42fa30ffe623023e4d6cfe49437181dcad8c0efc96b706b26700ffc52839b8343408048e294404eb38f12cab961ca719e6d61de9bb49b34ae8740458635c7eed1dc0408bc8663106753d32c92d1ee85a15d9aa5c0a5d12a9c4c08c77d7cd9865581f03fe0ee222e5bfad5d456dfe0172d77f3004e4bed8631e66db72275ed728ca66305e52f02d10571ee84ac2c4efbd880d547bc84a9ad96e2e2310b941ae7503c76b50f1cc1a5c10de9e9174c80bd5f5c6df97bdee805a983a00338dfcfed5efaaac3d65861c472d4e2e5ec3be0adba868d7e0a9e20829ef69702b4cf43029ad4879ee5edc71da0345120ed91fdc4cc475eb837635a17240a1d38fcd77e009cb96e108e362fd1fbe32feb8483ea1f025f6324e470c445e20734279c21ec9eac50a8b4aeb707569723d1c269450bb28ea26e5e3f9aab08c1bb9a80847979542f012a0e753eb4ba2bcf74a3160ef2dd5877d8a44414fbb61af20314476c4f4d20e41e6a16b439140ebcbe2cfe9e3ab324b8a64eee681c1f20d380fd4439bff71e49466e206679acd8ebeaf68afa6785f75111e5bc13371ac302d8785b6cc82f976b9d535a8e2228367f6202a5db260364bcc4eb088e8735a5da61a9a2c3cc0cb10e672ec3292ab70231ba55597b09ac4e57a8e70aaf2c7ec8c0706e159a8f890675f83ef41ee2e11e1c3299535847206a3c2d045733de1d3e69c27bb39d4309f9fa8dc3a79f78300156758185c597a494a55650ae89457b314f846a75ee85253bb61e2c6a51903ba9d6717cf6a0db834720f8c2d3309794c01b311687831b6082bdcc7cf00e4a3169e9bce974d343071862d561d976727d7f4ec172c17514abf2d53e39d9fb5dd47bd900a394d81c251c01b78ba6cff1c1eb05c25938c2f9d684ea5a8b9940be8eb6d97dca5d69824a56945dba3f1a19ca822e923e6b665a1503fb781943874db4565a2e4f6db541a4d2167368916f3def047e61ca29abde4dbde2189ea5a5d24a0e88a405e433355e5b7b8ae4e76b7371bafe82c943bb9b588fa7aa7099e2eaf64f29a0d5e98d2db9cdab5679f22c5d8fc9b930006b2d3c24cd1f3de84e52b354264b6d2f4fca8b61bd9846c18ad5c695e14078be70aa3473f260536681fd1f196493e5e4381dce467d560988084f605031d5535fb8287d36ec2b96c490d2fccd9f2e527917a263c445d6e4af742715250ca17a31790eece6b6d727da24692326a4c391e8b6c7c8e7373965f96a2bdda1c0154779cdefb6cf3d4c1b657dc9cbfec696b387a3e50f996e3a288fdb67a4ef6aafd520545e8052f26abf2e5f1fb4328879783a39416a5c4f82a143bb7d86882007208b980b973b758ef8660394e50b2a58fdcabf5999499e4a0883696609151251af5560162604fe1e934e42000aa2366118f18d447c05d02308e2a45c2442cb21df38199e3305526ddef103f98a141f63e3d96f7694f626a84202715dd152b8fd846d55e5b27c55467e7fd7176cf9fa7c53bdbba9fdf2307fd0a98ca1281d950a8caa97cf5c246e6361e1107e632fc5e7376741db7240284ce528f9a436a03c095b53b685d5f0639311a42504ce0f21d482df5e0c29261bb72b66dea370be6546344aada974dc0793c3a2a876b8700187659c5831801e286d04b2e0e3edaa15bb9a7daedcff6d082efec3c66926b27b8ef237fc19f50ed396b2520ebde6198689d3e16cf7d74c676284820b997a5d1d51d257f8bfc035497378336d3dbe0d070bf20b95f24f52fcd061a80a2073267621e7c8394edcce84596a30a1c943f6cd63963e81daf6c633160736518a0b87d37736db2e50772775de6d38fbfc7108ffeaeff476816c53dd925fd255feebea0bf257afc12fd091fba2ff8eae9ee15e001cfeeb50b4081aef5258a758cfe2097a1a25fc3209d9b2628e5dddaacd11b4d5eac541565d5773401a46484716b41bd999215b04b78eb4d614f1889518a08b4ab974b07c6a47519d4260c8f9c48fe2359a34e77393c521a36ac006d304eab727ad809678a3125930a21179913d3c1f7b1e20f8da79df1c559d9836ad47b58fe196b7e7d696c1afa40d9bbe8808ea54a21ec40d89b42a94dbaf8151e61fb102dfdf795569e185b2a5e2a9de070a0fdbfcfc080ea75a2433d1828c688bc198f9ec5f6a5e314018fa5f9760a6fecd64f2c291721fc8ab2bc3c695c2a6d6823cd6c9187de03c8e6650f55c5d55bb59708b27ec889fd4d905c384401e02ce937fca71370daffeb5fca1098991bdcf3068a0d1f6ef11e6d4aa34f2e7e52565c5cee826eca985898032eeadc16982826ed8c33512aae29c9e482ce9f1962e3279a2b71eaea5bc93d1a886eedaf15f5010368c54658b51eee94ec5d7c646e08f43ed73cb9c2092705a2b1acc2558bcbf84d9d93097d40774356b5ec6f48f12d8ad2e9909dcc167fe8ee1ee5d30e04c5df3b4dff8931943d72121b3986006d342790131d867f71bdc4917f355ebf07883f628b1737a134e713a004c95213bdfe6297bdd1e4461b59bd0113ecb5ce41beb012d362521d0300c5e8a6cef1e56c39854f552d51c3980ed6bc695aacb5323edd7f3d18b7a9abe96037e448b80b8a280114dc2484e516eb992a6701b4b6452ed83c014f3e8a7aa150fcdb4a5776168c41192e8df7091d936cdb278aa0a5f1add36009d9152cbeebb8883932dc37548cd43f4ad3fcf61aa3f703b347f18136770d39b3f9d0c658f6db6960f945050af2a11f07a453d8286a43dc0fb554b5715fe10db34f9111b2f19e1330df9419cc97a63f42239df1285395c37a60a5f61be3c6875ab71027cada3b701cce0917353504b1a8eaa78ba4f2faa73a5d262acbf57c5a41c42ad0fb84ccd19b54c83170d501bc45e22ce87a050670aaba24eee0694e261a20fde68707e5f437af33e949da1ca0cf31be8e9eb12741c21eb82a02e0c9380b0abb7360570de7c72de572c6931817cdcb6f2b1ee26d7ed02810ab1d2a59f3c6c08770f87fb5872f86438079d49e17a3d0bae317c99823bae043e31ecf2434b75bd65b855bb76d0a30c77cac2c2e37fe4aa3d907a3efcaeffb745842f17d59d80b26d28edaaa54e7fdc2aac154f9146385e781505e1823f0f1fd74ddc1fe7091d4858e27bd7cbeb3c83f99fd23af2419612497a1a5a2d64b9f902017c91d48dbd356757b02d9770d13fd6a9b4eafd49bf58815e68562e3840843761825c8d04a2a96e62e37ffe5aa021857c04adb7401a6f974effc78aec3ad0730ac2dfb591f6362e10a7651994eb46cd976fe81b03b03affc91410d00ef8c532b3a3a9b6c9198623a9c81a8d5c15fb73f2edb8cfa32c9ac1a7787e4489d62f30de8490bc02a0a7d564c535da14626a1f7f228429235bb807a84a77a5102c14a32cb7f3e0a1b05a97ce536b5f864733c5ba06866e529f291b7c09ebb14da20c1659b20f90a568026a9d2f5569d58ee1e5e2505e93fb3af2f1c8a08eab8c3699e776cabf346a5771ce8612c8a97659a2b1dc5e3441341fd8c5b011e66fe8c39afd41174d8842f16e5b6069d4cd43828f7ae8e6e9396f224920635cdbdaef43be7ae14b41646ae49e02dded69707f0b14edc59a9c0a8f376f15374e5259b1bcc799f5438bbb698b1313467c2136c6dc6facde7e1000e8d3e9c61e72041fa12b0aab88b40f3676422c17afa15fa969b054807d04ecdb5182573a247d027a9b7655a8fe40afee434c82647fb6acbfecafe0f889b37787bfbb5cdcb738a29ace49a2a8fb30377442b9f27777cd8febcf032aad9cf78fd214f7999ad04ab6ba932f4f722ded69c8c3003091e3588c84bd2ea1717b12304c167ca0b6ad4982e78879743418ed794efd1576390e07d7fabe24a065719aef1ce771bd23e5d33a84198ede732079dbb165f98a8ee1ab29ba100963d85eb117a57b8a7bded526262ad618f93dbca2bd9844cc38c4243fe67b9c8d6bff2d0c53764184d719e7f5c170b81c2cfd3d54acd2b4fab42ceabb77e869d9f7ed82dcc015162f7db11d9a5c48e3cded3303f864f37cf5835823219b9b71ab1c35dbf9e63faec0ec04ed5f8507ddc706cea14a78dde962fc56dfe48d3e3fd2c0db1f1a1ec4a0cf660bb004ee8649d942fc94e48348e87227d8a3719d4f0a32ef297769f539e2f6bb2cf23ed3793a3f7a86f835357385fb928613581477a3a01006f4e1bc93424cc117e254569e1915196eeb03b0acc32db33c291ee8fbbfe991d601b2b98940785026d2c226683ffe6eed92cee6be6ee40ffb052412522318b10b8bad195420ceeeacd7033399f77877e3badebb3fe2ac7babd445db8136f163e04ecf51c5acc9ddcf7fb43064789157913266e414b84fc53b6ed7febfbd4b9b0aa6cf2b17026daa63c5ee74570668651f3d01676a945f49a38b8ff5e4395bf160cbbf7e161fc1ac5211980d3f831f53a32d008cbbf2f53dbd897abee76abf3f821f9b5e711b6a6eb89a1a1e58a67546b888446d6f834f23a38eccbb208d55b97901327c6c8b33961a09daf0a2d21eaea2423175707153709ee53c3f72b08559ca4d475c642acf97ac53cae5626588c16a7af8c0662bfa23a7be2f1493f306601a9884d8c8f6586d554860a5cc7fb1606a8637226e8e83f1049f939baf23462e8d845a1ad3885a48da00e4d5eccbccb0536d8ed89c3b6dc979b7c25f97b33e0b84e8321cd0ce69f827e7cd380ffc1bdd8dc67b1203b521bbff73e8f2b4682749db6c249518c3cdc8b9084a0b12a40f12a243b7254c2e2865eae551285d4d97e0a37885b362c1017e0bb34341a3c54345fd377d9976cc743af1d77d7db9108c8028d3a78dea314713f0e85421df210e99c26cce48910ac53ac40119a44301a0f5b656f4b54699585a9eb1ccdb58b71073ab73cf9ef565c106d9ecca4907681dfa42b93a491252859a46489f936569c373d23f316b9f52632fdaffa013a46143a56a361043f81067477ec71e1560b8672188ed648279449df70f4f7d2c6f74bb005bb95037a8166e6d3955ea0492b23b1d8545d876d3ed14f95e6a3df0ab521ab06779a2fb102aa96bf4d10bdc2c7783e47cde09479b04ea8be64b6ec38c4248d81ce3603105f1ab8abbac1a04136368b1dc74ac6962927d373a5bb72b6a1099939ae52c33188a014a49b1e3699d1c0a5a0806c1ab3536932b6dff716eeec71cc81430ac4337cfad86c569d0b11f7859b75f222be5ac7a8d94fc041e5ebbaee2afd73c55f22af44b6e4bdf184e28da06564a91e2a6a3c4d2cc02ddb43cf1391dda49a1fa9162fef827296b96f8c7c8da46802e9b955a72f1e1c3a123c3d3d8361788aabe00ca21c36202c0cd40a22a0e5b0b05eaef73ca1ac090f297767a524d3b37db7f54f724f4ae90c2954dae414761cef37f26b1979b1f3fb0b7883eb26e336070e83189e1c29ae36cc478af84c76f0dc2d0cfe508840ab18e14d897321bc8cae1f182ff35cff316cf2188cb615fb3ef2147e4282be547c943dfbecfa9f5df727fff070646e03a2ab9a25c1f195fa38d6e737b4a0ed3c114a6ed69edf975608d2171dd513a86c106b49a0c7ba4bfb72569a21bcf072db849fc6199bee561e77991f11bb93964e28e9ea061f6203efbab59d422d1929fcd334be907df40bb0399badd64e7d930b48e624e7f6d28309a84bdb1cd6ab7885b917d2bb2562407cd585b105daee0e8d18aae7b054f8c33bc5e0a8695324cb8085b1a7eaa15d42d65fba2b3f85d8be8ce45046981bb55fcc5ca4f0363b45de259c2071a0d86415823fbb0033c5e3973a97c57055bf716cb313935cd7000de21961fd3fc58abd39cff43c366787cd5e2b7d339c0e29b8f244788afbf7bf8cdf5a5af17306d6949f8d95ce6130dccc3934f02d83fac4a1d496273ceed9645b2212c9a0dae80e367857e28d1735bc27d9e68a02db376ff40ea9a0dc13d7b744ec6297e410694482b36113da2aa943db57b220febdb063aa27b750645663ec85f71bb9916ab1d76c48bcd493f2136b59a99610ab7aa6466887943c4753edda54dabfc933d3048dd2ebe8564f40c219ab30011e8dd64c56f0d80a9f79d611ef9d92af8f158e4d0b3b625813245f03cf9d83e084726e84ffde31c2278e71e186559959c7a2d25c9dd387111b381fab352b53c616ad55c24bdee5a253acc66f021c39380073b92f4be450906c81ee45b6277f0cfee01dd39174331cc360d43779810deb1e614ee70fed863b453dcccf12b95ceea965fad512c8db92e539c1af74a5acd45f4654644b86d1dcdbc58074fba8cb5720acc82ec643fa769865cf8a0d554d14a710f4ce75b116727dfc6123ca211873e95da3fd05111e94d84ad5a661a56a9dc4e85d5028069954c1b6d95e99b77c6e7513424df848280828453030fbc02157d76cbf2b96371349b31efcb880be32de6b8f9e42b3012ec7ea74e678784419d17d88fcbe5b898dea21bb7df77b9eb54d66e974a897149b252510e53fd42378bfa287452a53af0388f951113de5d1f439dc0ba492ccd261675fee87c71a7980688862bcaeff38ac20fdc0e8545379784fe170faa8a7c33b59ecd78533dc1ed7557e4a2a6dc39856bba9a5e5c7c227dd03db66eb3697625b48348e8ee4a56932d453dab0b5b2b42f971d7bba4b6af476c2dbb2390d36a8e1daa9e3135bcc77779e99672437c39aa12d5505e38189ab6dc9b6cba67b10df165452ace8d6b0612734b3257197fb8ec86e223fefe535b9a674cdda8275539c4312e9eda2c2de3a61163d52b26d5cf55968d2ff102d2a932ee6f74661b13c0fbdc23346c93b83a6997674b39d4e6043f3b8e1e2c917ef0cd7de80e7bd8f2c90196a4e1e28553abf775cd5b49776727fe455ee4c7efd0fd46dcffb835a8b870b0f6cbeb1302150314d3d2787896b20cde1d4cd4ddf6c118475d5250c1444d902c84bbd4703659f62ad278b9a261487367b3257a1312375538e65ec01b4271dfb5ef077215dd0eef8020b9962bbb9a6a9adba3624111d16be98826dded779bf8d329bc041047c768afcddaf0ee6baa5f69fbe1d880080982cc6675d6955053d0a794ee6357784d2ff029942fa8062c3855f916d0ce2d50e52c5f62d2f8af342cab714f817409430de49273a5eedf0e209b7068293686cf2d205326e96f0cddbf22b483f14cb11e9f9a9bc7255d4fbe65e196f68d0e80e388f74278b87abb36b55022632a0ce94feb8cbef417a53e18d030a7293d787fc30a73cadb5909ea02ae11cffc568305d138e940f2950953521787bcc385b39cc9b66b930f470aae246ff3a4c5b812bb4ddabd6e38111ddb016cbce44b0358cf9c19efb1db4ea4d9f0d336c7b999e38f331adbf676d747d7feadb6ec66e22c795f8a1a68cf9f9b4ed3d45a89d9cfbf6b45f6cfad9eedde3a6f16e26dea29b81cc18b15e9b971e99a6086a5f7f1fc94d8688912c0541a5c092b90314fe5fd188ab744f99030e68b1f02217f9e9ef3a4db613c22b7fd42073490cad9257738e6a1a514c173d10b1aedafdc8da6f0b26fe23459ea45a948142a6c730032f50e5d48d5c594d6972be0891de5568a8ba9e8dae78d335155ed3bb131fb40ae8a5af3fb54284f6cfc03b7dc10f51af96707ae13a05633b9eb6404e4f75ab2cf6f314552e14ecaad11f07d4e1835c0ec468d52bc0601bf69393079a68621afca28a38be017d7d0fd902e676e0988c50814e73269f2857e5f9a2e13c48f71f5dca54c9033aa7c6a90711d5c6f392fcd3b35aaf9d121b920861f16928fda428ca7720062b64f312a3253983e9021679150a6cbe63600701c23ca3a08094c1864a5a98bfbe407afb825304d366a7a791009bdeb467ed2b34f7b3a5934619f0b70563c9ad5117de4a67e0d174353553eceafdc053d5b22c3c2bcb4f4d5d17088d90302b2f67ac129fec69980eb7b0bcf453a7094dcfa7f4f83ef064fa9283ac606ad983f108c20f79826df7e797d897b2141d74b7a2005dddcc834e76f127648329165bcdbed3e61202779fcd94c535b0d0263db0dd6ea1a0f3d3eb03dcb30cff34eb6590575d1965e291259d892a58d10791355b6a4238f31c2e2b105dc5ca97e23806a22d400c21561beaac56f50b2b9b73125fa699b33634cc9634b0653de1fde9c419aa492d017be48f449925005028017efb40c47148a730b089464e8cfc09df920af5f7f9b99165eaf1e8f420acd3883a23929686804cee521d09df76bec762224cb28f94358f0f5d30a8dcbd14e2c15db65df752f36ce903c6f5879ac62c3471bd819620c6c81a0d39efb8caf3e4641f64179ec3512896c9463c1d64cb095ffcfdd281cc6866f109691908da4fc7e1c07e2fb41fc30581091d9ebf56fba30d5481b23431ce8a5a8ff4bb9c7bee637677ed4fdbdf6fe3f01560a942b6e4c112e2ece529fc538ee2b053cbe36aa815c13f5526353c5ab00f344824b178a9c9b607fc17c15aba7c56653c310fd7b4db6712c6b3f3b1b7a25a2dae2d9517401b46050722c0fab6f983b392a0f9bbbd05e267836dafa500a186b22079a00e2f869077e0f09e7e66134f8ff83c8d9bee26324ca7f5f5dbca7a0a9b909596b879239fd71a6ec115527b5a683ed988171b671e59dfbc62b8660a722541c1f635b3248de6d02dd91bcddf35766d0246b8b9fc317018117eb6d97eccefade7304ee8348f9dae22b039fbf420c4a5aef111914b575a1fbb2601e75e20087b997ab95ce388dbe31516ea0abcf116f0910858d5c18c37c797f187dde105be74ee99f9d869dec7469153e0a00f52ac4131e109ec2f9c0df0237166ff37ea5d5f73834f0e15b4f8fbbbcbc8d856832c42a0a8a4157379ad4b4c40bac14feb96e7a6379d7d55e7b70f34f9c339a06134e453d858f6de312dfe222592d8cb8bf801cc4e553ecb07270b567936f245bb7e13931b8280ba628c77ab234bbd6189cf09c32f047107f3a9015f8cc2c20a3aaf9f66b497ac4a7e22444373d2ecede2de1689f7e448d0a05e3fe3ee5086ed44c1718f071b1661fc5fe455fd160aa4de7257c43ab9ee48402739655da8b4cdbcd330bc53f12a9b19ccb46ef9bc996400a3f4a9a44bdf21331da5eb7d3f1cc6701094dddbc3ffdcfd9e8e90de1baf0b6b0079068100b4686882e719d335e3ec50f02a313a929482dff42e1f08dac3efa55ae0f3a98f2a01f04626e45e4d0ff0d29baded6e733f2136e8bb8e1286f248ef63b9c02f2c78d76deec7fc1b99c510a46aa17ffa47aadba9d45e98132bf5538cce668a24030ebddaddc503d065d7d215a50dc5ba17304f642a02426ff8e925f8ae78d0862fa8022888b0fe1106583e28e7984dd8749e1b383a3dbd19be8d904a4cd3a0e53b82f16bca5dfdbd1b32f7911ff6f5229975de6e312bd8d851d729617de8e527d8ba7ba0a5d781703e531ab8b2f2b447d8b5c1515e3f8ab39aa8917d62cd492d1b06c7cd8f8567b1ab90588fca03ed6070d709bdd65f451393f1fd80a46a7d64c7e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
