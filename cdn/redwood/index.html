<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4db4402724c3c599306ffdc964d26cd805bfb9020f8ec142fadf0b3c0cf9cd1e9d3cca69abdba32574d2b6e88664348dfab17448187f7c5f218a8bb445ec63964e6d2ff37467ab86587a5c4969b414fa6169ce4bc8c59e21ab9ed4ac2f95ea8fe5fc8fcbc7872ea1f5a28ea892aa3e37a34664c01c72ff9c176bd5060d031ed2fb024f3040b3fe8e5f01cd58703bbdbeae00ca6e9d7fb56cac9f5419432cc9859df18a6eb7fca64dc8869cd08df51bbc9346c99b3eb6cfb467330f09514c15656e9cd65634fb6430b8c115ab359b88b0f9157dbba81a05f29aade95e9ff3aa68a2ee0546decc83b8c76cae71b5f18672dedd61346426389cdf2c4dfa92187aa760c4702db1cf6788968b202ae16101746ddd8b96ea1ff2926a16e2066f4934668ae2a5a24c1b4722f586881d959681a53f9ec7231bcf5009e96c74a65835843ac54052aabab4022dfc87b363ef8eb6d13c82383aa0e08bd09ed078ba7237997895b933021cb5c113fa04ac0cc4909135f7db396c9af0863a0de680cad0d951537f117e49848aec804c165ac632390c72f41970d17f4b30abd14503b5a5592738a263fa315d325cd6810880975678fdaa48fc62ec9536d021fccf77b3c6e57eaedff1cfc6a51dd459f31c74b508cb86f928ac9be636d38ef311baf40b7a9b53485e1787fc035826ed4b247f245790263364b3e6f2b4ca0760069bc4640ba0b3002feb9b1586eaff015de0c1d07cd438d78c952187c384240fdf689baf5143f249c08ed45922ee34a50de285245a0181e4e0d03d972223d51a7f3ffb0756ec01daa8026c72e2a60a08e6a815b617e6b83787fc80e1dfaff0eec27f6a74f8b910fab2f8965eef23ff13f6231ce59b5b277073f65d8cf44a47768a21933c09f696ffc2b99ea7b4b888451ed0a328849a184f86f8a584d833d1107804c0d9b9133ee130969d52133463908b0013a49f968f7a797dddf48627462127e866dfa8ee9df90a22dbd20b7feb9a41dd68a62edb632f9383d46abcabba5a995a5c9a0fc500ec8be9465febd5a8313a33c4adf9edb642cc34b7ff1cbe6d4a99d380f762447919c219878999863425ea0cea36a6290b1be14402136985edebea223a1847821e91fa261400edb9faed9c815324029d6b8457384ff1468c945d0fe1f3913aa9a7b62115812d3aa1ff3ce4d6bf68b6014924c85d28be327089c125a53953a3ddae549e22f0c97c8629f0bb46e8c147edfe9bf835664a599c92522984b2a58d95c060fd5920e45111df3e71bcd014a7b9dae511bb820e6e0137015a6ce5cbb791a16d9e1f578115cb25a2ffb5801687613d18b32ba592b33cd78ca3ee1c85abbaea7fc75a4dcd1a21ebe6d6bafed40742d1bb34d4fe5af9b72f10914d9c0015b8501730ceab350ed0c95e40e07a1e3784a6ca4d7f5178ca585e57a46761fa750757f929c751410c919938d24ad6ba46e23a21c2731dae1292f16a29d85963885fc7222906302442501442c1574fb510ecc996207b4daf2849ff383873fdd8923249a0c35f3ff89b58a83e749dd976df54fca4b06d2ce2d1bb28b0a7658733121aeb3331b784db33e17f132db83d6ad055b9f5652bdfbd3f9760facb7dc77cab409e16e8bff7fe811e8692c27bcdff471b104148bc764bc38ec248d1e5300024f0a12ac0c3ba3787e2d7af09f23c8fb0c85794e1ca0378dd9a9da8b92ebab05e7890701a1c9c9d2ef765d8406f9eb437f75b563ebc6b83bcb69ed6941f64887dd00fb851f82cacf9bf00a4c74b8e98ba4cf2c04319fbfd7939b5c9bac8e66e254675df71163c6df2e979cfd22188be50f8fefda017195f9fc80f3c0470c5ab828cdcf3542ac18297a6544c0cb2666d8eb769eea6ab7cd3e829651e90ea4350e818759aa2e2b95e424095e2e52bc87de52de2e4649d606cbdcace7eb3c33e826e8a382b17c97ddd4948a3934d4541311ea2735aae98d353e7a3d01b4d361edff4c43ecaaf0e3adac984db835d4ce247ec52a61fee706c89a6dd372129c546822eb2c507a950ad0265eb0d34d9ecbdc00d1f535869370ef71b36cc4a608cb4ae25b0d49a78819532e5861e9893ebe4179e9640071db519f594ba4d0cfdaefd985d44fdc54bee832396d03ffacca150eb4898a57e829983b9038a2e16b194576ddc985fdf3b808954f1399f15ffd81a8715a29594037956b37e3f95d4b51d91e957c3765b0dfc1035b8032bc95b4048fcdff55cb6eeed8d3a2d3d1f5f703af9fea4475d7b78b928a0c6783cafd4fc0a5392b6a4b2169c0728dc322dd5f1e65ccb332918b772b1b713d3b543b397987fbb13cc939d5c16a8fdadb0d5c2a3ce6a934d720833dad55a347f9dfc5497068d09d82b90f15604d6cbebc5c2fdb0d8f65efb1b36a103172d25d31bc5c2c1db80c8214eec62f176b7de872fc40c4fbc87ddfa0e699e92ca0924a6c46f132ff3e6e31c1bcb42078919718a7fb7ef640aadff5771ee2f17b6fc25f135d579856e36c87178e614c30662ab8f4105800c4ec39de9e7ae239d6e7d919d2ccf03e232c17d6446392926d8816bf1976d9a9d288100e9741eba4ff846e32309342c53db3cecd5a2c807bd4780d3c9bc88360d623d3a375252d1ea56fc643041c3a1c025a540c47a2e9f8673808dcf349df5cc54372c5b6ece6b7c6aeedcb932b5b50171d2021c9b25e010e67ede326695c32ef07ff1cd2a67714e9a3dadc7096c9883556584c4a111022619e434ff877a03283d75be07623582724c5668667962c3150095fd6fb4056e6dd7af833962af5fbc60bf24795348e30d2f508881239c8fd40cbdbcbaf300ae8e6652d7d93fdc838bab08f343f771e1b4dfddb906ed2e4f39323391f0966622d8751ad823eb2bfc67076e088243f1d928042b36681b7bbb1c273c25bcc87dd659aa36a058b8b94d7fa410dbe69f74811281b538ee0752b64817e4ae6188d818ec8298bec5b5339871ed649aedfedd4ce6f6d17bc38e9411690616caeef3e3c1f6047c1d348054ee8dc091f4912b0a90139e6eb18feea9f073be8191ec9bf2486e89614b707727d04d8081ec90ec3f9fe32921047306233ac38b4397fc3ceabc34d4dde413c27b3fa294aab6c764b3589635b07165882ceb5718a178ccc91c89c1482d2332b596107a68ca8c23bf8da927f7ac9bfe4ff759f0ad920707189302820c59aabe3ca96e1b0414d9509a9a5b9f40bf83254a53a23e52c3629631696737ff4dee1155c7da596235f947e15ac0934e7b543416a7c3b86dfd466ea181610d0c2f653df03eaf5bee4ac56d7bdafdff3224ee9b487af12fdac75de76a25e376d95e67edf2e4bf4e93131953155f7e165827de080be7086b4f45104d66f41c92419c8dc64d10a2418f00cd0943d8f84e50ad9fc3c01aacf3f7e59d19bbba9b6ce87add4bf20a4ec0c3fe930772aacbe8bdb8241daea0ea6294e5cf5f768e10e14df3fc3cdd474e177db0bc2803d08cfcb1db3e83decb1a3de3632063b112675879a58f5484dfa574982d456f7e8779e019b352d901767517baf0ee9552dbfe575751ff123326be415de2c4d56912d47216167458b751243981199e6bb817f2f40eb6a4234d7c7dd8d4d8645a47526685e188e165137367f26282b832a6df8cd26ac871f13b1a293b0fa5d28faaf415cb3976a941b5557825e1d85b42a11e5f27193e68d2206ddd80ec293105a046d280fcadd423d235bd84703a512bc2665d26e3b69f728cc0315681283d95311281d20aec86ce12c85f6d8d173c53a1af7fea7c7b4adbbdd1248a471bf0c2ce18375580c290a9377048578dc276d87f3595688d415acc1bf68a29d0bc8c80ed98ec92aeba209a22bdd535fb19468e88de5a5337eaf40f95f3ad1222a4f5cf37293e122c70ca52fb9be8d19394e1f31a0e126605833151b080029717d7f14c750c2a1be027ff8b640f95e8935be1ff74dddcf70e95e949312d443802364f588d267ef8384da1fe5362eccc2cb063d1533a118408fb1d7aa80bb3c89bf44e1d5af58cd7efbf09de839624b81848540c6a867b2d411be5bbeb3e7c51e3d287901064500d401c813d1f27ab7bd0ffc2fe7fb0a7c7a38fb0ba40f0a2bd54034388e55d3a59f4b6b5dce1bd50d64b34f131b1b1378e589fafe0e3453446ecbdbe985be89c4fbb6d53ae3bba7794aae665934e81dc52634a2f29a6d48a2816a013eefbc546376f454d2359ae5d20d95811236660f7752f0d151cf2d352deb8ba939a0b721534093b9bdd2f4a20d6fcd84d66faa762d8105f2be66c3e9843dc6abf0d49d337bb08baccd472be34f92574ba4f93c9e78d8b57b98e5311ff0c891407c5048a070746c99ef1254995128f83c72dd31eac6e95c842e0a614ed2ddc74e283396468bc54acf100f9296e2552bb8ef8dd93011e6e76d302a5773cc28bfa15ba691bd51789fb353965f809b3a4181e88d373a3d9e2223ad479f628fd063372b76a01f36bb61148f7b3dd8537c264957bdb7f816ed5cab7ed432f3fd2be5b3491db5cb8204281ad1dd9421d4ef8400813869868ca5ed619bb2e286fdd55194b0d9b0533a49c8e3688fcfc21502bc37ed0c14b8bc6c525e5d830219d077647c2cd39eac5b1b17d82bb33aeb72d03ca6dc727779daf4d9826d27786b2f3f8c0a9f578e8c07f8ac97dc8f4a3030ded9d2ccd5793c055f33cc0badcce3ee3700a9d8ee1478fb90b03d405ea6761a702ce76024c38c636dd3eacbd5f9a6a4553f22ea0f55e8abc719821e7e2bb88886b610dae0a4ecc90a45b2e8bdcce1b62d67f19befaaf8a9da152e0956519454aabf5e3de65b8494de7f99eabdb248e8fe4a2c98304858c06fa5519ecb387d8c9948c57c3367459f95978d61bccd9d224454f8397c026ed8ca0f487f612e9a50c4f747c026fd7cab9e8adcb95a145fbcff87829e89c18323768ed71e3f01ddf40e893f0980a7efd2177995064a0e8b07ecc5f5dcb15d1640cfd5059590e320bb08f800230abe037a600177d03757c61ce68abeb7bd457018ceefee116c19cdac89b5f6fa3b741603f524501127e259dd4a7ad764b7a73b2289ce1a7052f44551e029eb52ce9c1725b647e2bf5a8e3a424329ca5708ff0d63e42d28abc2ab06b1a7930b07c2816eab18069ad33584ca546d8fb4912056c0d38031d8c8c35d55fab34c0b27b0879deb32b9f928130f27932c062b5e61c29c4748901a96ee9be00d7d16a393c95af2b3c62f46861240afe52b6409e309e861c7513e3ba03fe3fc1ab7ad43d7ee28c9f4d1495f5a60145fac99ab68b10f7d933353376b6db13ec205798b4dcce6dfa68094b368c4b8f210f6fd765537104d6889d0bb18f09bee15c00b824cdc43f6fef1f87941e67b50e9760c4c01dda8b055d56af7712084722ccfa841cf5844b868864a6e14d91c7beee36c684e44cc9d7d730544c235b31fe719bcabc4080f272b9174b50bc718925c7fa60dd73fe27c46a2d83259c6f644ac32f3ce05c4dc2d46efd572df979467e94b3f6434100660edc4f32c0a82880439306e4d389c9fce1fb08e05e8ce83bccc143ec97fa57d5b46b58e9f3e429db8e2bbbd2d76f41d1c03e2254279a42f06ae2f032e9daf6fc3b7198035af5bd4cadef83b8938a70637466e293f018b98c059a29f13afbbd67ff1485035c704af5ba0cc5b08dcda41d73589a511cfd4ebb354b267e0ba92d8c07a62ce4d92343044760f4ab71ef0634f15aa45ae71f0529568e7dcc0386ebbfce11c8981d99f1228b58d0a75638a256176448a836868448ee5c9218c8483dd17e46683943ae09c57b494a1102952cba424df48e44a563e2f721b7e3e12e2fd147a6691f31804e6d3ba0768b7e8fe01be6889b80a3fcab5d8d2edf8eed3e38ca6441da02d31dfd7ab67e90a87c58e867d20f5713a69e3b22666fd40540a7ce69d17b87226d2ad1e97534bda2065ed68cd0ce82598207168f7a7c074f9f4a078eda784aa8f72e56ad8136c59bc4339860e2fb46b5f53d5ecad8c27b49c31d8385164ff92adee068e36bf7b080a4c9622519f40e8e07f13fe8321cf1946201533182cb34329c6e98454d8f067e152ec1ddc3b0177eadefdcd5da6abc0a2005739fe39cdfd3a45fda98093d4da915f614a538d7c648cd7cf3600594e01c136f4bb1da6fe8a5a93d9e7152ca096b9baa1750e86f0a15edaabf68b54452439773230063d7b92555d2f5b77c57d5fefcc39aa9b113f0ba5c43e6600fbc36506c43acb5a7386e1b73bba86a124c7a93df286f82a73c19cf34dd892fa358d26655271fcaea1375fc13bea25ca0114f4bab495cd2bde1be97ef201e2d9b1ca379088a636ca6ad8b57eac7df3b7801a9d90eb7f96f3bbf262217b62d1075042ae5b31a156a8728fe9078c17aa31be6ebf855958cfe20f679fbcccf34ee02b1bcd6a21f0dbefc17fa835b0ba7d52102782106f1ca886ae41752cc6e47e42685a3a487bdaaf5dfb5fd25911d9147b8559718c216f779b8a5e4f84856241c44322338eece3d8c927106e98a15c657ae9afe97cfea81ddb525b21da88f1693bebad6b190e75e702637c2acd13378269867011f849b49f35b55fde42c8b8a95e1d24713aef9b352e1ea1985c85a6c3ee08dd3420e14522b847917bf21da4c9d12ca3d673dd2e5167dff301591f15d295ddc8dd93f5a8691bd88034b2911e8f83b25123e69f3b36a7744ec5d3e1fc6c71e3699cc2e64ca2539a9fe79d1329b1e15928754517d8a709f895fb534502147b2b0672515b9305856bfd8d1a6e0fbdcb88604090bb24500bdfb02e1c03537c842df3613435331317ce9fbec1ea70d3d156ad36e597c91f5e08176c6b5c2ea0abe5183da205f322a289f8a9072581ffe58e2aa27a85007ef4ea2a4a8c5bc3634bf91397c5288e8c1d619d51820c6beae4af874cec9cedcb46503a6a33d64bc3ec095914b8565cfee6d6d7f95247bd0db9ea24eecd30010364c90e176118e8b79441fe742fb4e8974a71b3a132e1123b09d455ffdfdbaed452d2ed490ed39e238bf1cb20c9272316f72d92b7c0e4f3ae35e7539c96b271ef1d3140c338b9ce6c4250a44a63a6ea28a4720d89a2a2753facab58134dc87d98c37d49085e3da3df01172fdd7c951528e7e16745dd667b601a27b55b8664481bd969e168c884dfad12477d7bc29ae27753d0ae654f1052bee5443cac9af1772a6c6b6c08cf6d20172ebf3d2bef921e4a91c56fd03a1f28df9912246ee94bd84f02aac7472fd34387dc2cac2b69aa14491c778dc51bfed11a440833702b66f28aa59578f4e647a85de82dca82a295bed914d4b58aee463b793e2bfde5cf1df30c0493530c9834bbf5843d72f1805a64c6ba3794b6d4786d3a7a6c69bce91593bbaf187fb88df137a50bb6c8c8f23184243db3320d93fde6615007260706d4c2d13e43a490d8a1aca10d1aae196d62da42443de33ccd2a37af30a74b3fbe44726eefc8bacc3ed1f8624cd8b3f8ecf6efc3994e741e45a3ddd6f4518c89f77c7b42748314c04b799ea41589a06e89251b5b2545d4961f564ae71db3f9a3d36111708df7dcc377ae06c276d63246c83904bb1564cae3e36254109fef786fbbe66b42dad66487be4226624cab873b906c203a0bc33d4a492846a6c11c5551e8f6303ec2de639783bc4b669de09a5c42b285cde4b4b494b1419ed83ce89d05ce4431f406fee41f55a30905c29f90b4c5b0ea65e6b20cbab6fd83edbc76e32b7d171d300e0a895e5e8f5ae2ed606a1838cecea992bc3d071047883ad71fb3188c45da876c4b5a64ba993452940c7dc182dc01c6e6a80dc5791d0e8939f48e1ac7a67d50d66ffeade208ccb1127918f88cfda1d26921457cffb6bc62ccde9d381c666c6d79acdbbdba8da9c061f926751cc2b74ec5abd7acf679a522cab55fe43d05e860ceef6f09df6aafee550db7f654d8bb28073369a9c6f47bc3d7cd5276c6f6c8cd0b9b6146ea656a7b2767f49af7cc607737232c5fa8806996ef4d3fc977f8b3c117bacb0cc6877cc9fce6be8b0203f00bcd401aed64e5746023e6008c66565bec5375b81f2d044e4819471e88ad39cf41a520440e03e728b74a8cb9a79bed527484ed2636c35d40cc87006fefeffa215b9fb01adba3eae94eb56a690ea5b8ee66e6b049412e455fd07e209c8e171e0372d0042a2de078267f1abae7b6f2fac159e579799de98dac1880fe6ea4bc0e09b49be596b2392513ea3e6a5a0d4472d3a6822c75dcaf57f9dba0e0db94eca2bc3be723f85e79889a5082834fab406c0206624e6c537740f1fc679acd2486b6a9d9c540739219b6d3d2032a1aa6205e9e6b1790c8a2a7281db5aab4949309dc112b5a3949be8763564d2252ea809d1e82dfc8c09565bcae20b16ecdbc6e3c8348d7f5f7528fd6988131791751350b97a3bda065b42412ea4675357eafb16d7615f6e3b5f96836b476c18a2df342c886ca1d316713c2498c254542a0eef6928474fb2989c18f0632a31692e78589f3d79c474aa630d0f2b823400d5e8f7e1fb1450bcb8ffa101c2e42d72e8fed08556a8e5399d474b3eaaa74cab2f873a2a4adc6c130d23f0f59185d4e243b95c7a6b36bcb12611d4578ef58ccdcfc09434dbead23db66a202401055618f08bb574e2b2573227c2871b8d7e07f8eb1f9d64f93d400c11114d8b5ec417051b38c0d7c7887d074e445a1cfd164ba55045e5cc83bd142c98115c60b4da0cafadced71225dbc5b1d3959d16f0c86e69f24f9d4e7340b3d6418d2437383a6fe61821a0b006c5297b98f5c6293265fc7aca8fa8373d5cc280fb22868392f947f63dd483b6adcd6ef17df4e3d6f18a1c0de20e838a11400b7cf1c20a6069b067edfe681b7472ec06ffbee00157ee16aebf83d7954ff073f97edbb190db7ae90ed75d4db6ee81549c6c6e20f35c883975983d178ca7a4e107714d2b12ad44d41c216488dfae24c9050f906859a65a33d75219c309718d951e574bbd81995f99574fff85c19970c74f3d989f5a65a991d0445d82c82f11f83b9f6b91f87612100bb733e66f42ef4dc6ff0c626b4713833f53dc789a7afd6094ec4bd30b7722baf2cd9e6d9cebc6e904ed334c0e3efb0be6437303ff4267d185b630b4b233e51fda0fe8ef3ffc57d803c9b642fc751274d2a5d500a7669e4bf698a1237aa8532202e133a89d6e1ee07605fd5d93f9a1a0ea015c3cda89ea643983984425568098329fcd78a60f140771d668d5dd9569ea0cab79df43c58bb021168578d656d692e1dec05661915b120e5ca11b495418c4e91d50e517253db5c3bc3b39b49fd17d01de8dc253de4ec7a23e84313e5f0914ca44b26dbec91334e01d2dfd8efebde1a4336b5b99972a920510c834e7c3edd2ff7dd93731ef06d5b4b8e9120ac4efb21d0d5f09b3df7d145b1074b252fca9baa8ad3094e76ca7d291e5f548c49b7aa9c57cdf3cd283973c511e03ccd780661e9f12bb1bb7abd97fb2f81d1d235daaed81300f92207eadb4ac3b4ea970f132db5666bad3452f14d5c4a062a6c01b6db62d2105e5a133dcdd1012fdbcc460bd6f082d53c5e44c62935a07ee0554368bd24ef33e54f39d1535ef57f76c4616b2b10bff7aaea5aae55f0504f051682b010d5ca643d50b68108a8b97ffe1dc47bc7c7f57f27eee3b7dcc43fe68e932ff6f071ce3ceaaf76f297667e597eda31352e20ea22d87a18f9456c0541a6c421baeb0a210c98acbd9be39cc19919dd542ec6bda543e735567c99eaeb15009f68cde1c8105cf5ff9c745b88f7c21657887c1311e27071ed020e62032ce258727c4cf6ec684d678efd65bd9cadefffc01d16411a6da7f495a55fb6b6ad5a85c5b2b0759fc2604ebaa890dbd1f6292efc3facfd1c3afe7882d41fdda7153689f99f5101036d92290c2f9c1196d30b8676eda66efbbebf506df2a55b684f88fecfdc032c2a0b582fdf5ca31c959ef89a051c26db0af33532f464fcb2179c44a78020901d12fc66f099e31ac02a6498cb455cc6d9b5442a7a6c4cfa33aeeddf8871db3373a294039bafedf7f69b07b43026bfbdf591e74946600af2bc7c19b850e688bf005876ec0b8b4ff5c5c8b00466f4a1ccc792df23378e2e8aaf01c51bf908ac15d7d608eee2adce845f7120e62c15a9ced693258d54d53e49e386c8dd2e89bae2da74b2e77687afde0b141f5269b6e55d4fda8dbcb007d50a01262ff41613e687e2fb97b056d10aa139dbf7e36566022923d2c69f417fc946409d3b36908adfe606cf3eac3c3fe1269bbfe82f7cd0d19ee52a982a57c55b5118e1aa6d08e3905926966aed1a0ed8e4599c0263c15a5a0f28b874612251ec793be290afd2cea9c277a12192435f707886364d04a97576147b6a76136f72439fda58af15683877aa1d9e191940e471961284b8ef3f51679240920adfd2c018660f72f14748ae6d89b93bb4551298e8c0d044320df3a805ff24d6632d888715a33d4f13f2ea9736d6b1e9da3ff9ae56092fa2996ac8de5e3f29b6a464321e1a5800819d4f5ca9dadf72a0f4dccab146a08c101bd673d643a21293e7741b38c6b97370c9010cfa22e9a3aec9a9c349de5476e32baa3fb184bada660cd2caa7b8f4f3f858a956e546a1704bed1ef14027b8b06da47865ca50d5e83259ee3693f5d4130cd35489afcb26049cacb843b39a044c226bd514b02041dee630ab05207b766404f4818c2b272543277d7bd2edc25fda01ba875ef6dcb6f3e4e7bf89302939bce33282e6c03bcda8cfcfd1d3993989d88ae0122161daceec3e1db952085c90f193e35e68b1c11f217d5b5578b5a7c310d92f9818122f47ed2d53e64ad326b57d5fc68b678a58897ff6131c7f5eda4156729ddc0df45ac56163612fd4d47d3e4f5c6cd6056143334e087d7ca54c4b3c7dc252f9b32ea918b16ec7bbf130df71b7b9f7b4f049aabe52c646a4dbedbc7e762e949ae588675e860c8335038964ff0ad913fbc531b04641f20a8b25edb3c6228959d300bec653cedf6be35d031e3ab9920532576e55054daff84401188bb8576727d884caf68f2d8158078697f2b41204643f4d93fe0c7e9e60b5ac0adb015a4e3facda813972da456d8a46daa596628b80a2ccc8d0e0e5636b1736d52c8c9604b3392fcd88f6a75c583597b9344c898b84c273fdf151b822ec9e159bfd603b07c754c4cca35457b6595d742c7bca2b12b38fd68ce45e8a3adebd42d3b8105c0b4da3d76746a402bbb01d848bcdbe46cc7d90e7fbdfbdda18b8888a097f572b1079454e3b9f93ed8e99a9fb450e1a86c1f93aa74b60536d13be4a0eb3cccb3416a8399f00de067721accb274f16465cfb6562c9c1fb189246a7485243b17520c52a188b1b3360137b2d44f6dcd0947579ea9d078db0d7a2c29393bf29dcac7738fd54203564fce26eba6db6432df07478f479ae774066e4292a93dd0b2ecfbf0bf10dc30d9472a9ec1ab401c15e42245964983f0b97071f576444c6a7e554d7440d276e0b372b222978f1ed28cf85e93fa9141b6c21b4d4ef573fe676e61f24179df5358e36d4f5d55140d3211f81a3dbc2cd8e4e1b78b326d10b71e99da8492d6d3f58aae95857a45c75b42c6c84d8aded78bc396413052a8a76286bc82e41e544bff1cec0fc6dff85ae37ea85b77a962246c6a9b7d1d343d9dc54a5b377624d471f56c4a95f3c99b7526a669bd96854f748c9f37de8dce8edf9c60b995e757f7bf9fd10f772e6d43b7b5c4d52c3e05f1038bbcdb8b743d757bb430b5ecf7bab7cec42bc43ed8ac32e930f490527b388342cd4de0c6f6edc7cb7174e2dbf7e669093cd6e9a80edd85e172fc8671cfb639f415c548c559fd70040c945b61458de174005f25cc9f119995b76c15936024362441b2e3fab8d56a8a8e624f8a71fffe33ae7e31f455902bf1632918f1a8971afd05e77bedc5ce953ed3901cf785f6d16ee26f408e29bf0a8a02b26ec918cbf82021740dc7fb8f08de8298a00d122f5d7d62a90cf27ec4c955e8d02b965e0403e8a3575ae9ad93a9bec58df7cd40f5571b14cccfec88c7ae3ee8a4c9e36f40d7f705abe2d206d94e3838391569e53ae25793afc76268514357dbc074b6abcf0660fe522aca1edb6f543b35e217658e7b4d95f1c41767a5bf1ed0aee65b0cfbdc43e77e84727d0b2b36465f7e4c561e95eaa71a81dc4af89ad88c1ad7f4f4d934fd3194af69f23a25dcef3d5d6c201fe73a7f4336c89e1f5c7cbe15dc3204bff7f01339d59fe0cd714e3997fb914d763fad20b8bd210f6d3b1b3bf61d817800375854107931f2f4d1ec9b738628fc4f5cfd5065983205df511b94c681a2369b21f1f12cebb827d2d128587d797b8a54e2d4024bec9cf42a8a627260d3260291c56dc77f8de398e950296335ec2b09c761776d69f9a43776cecaa7a1552781ceb18ea8dd73e413d44b547bee7c8f52cee1e6919413082ec3649000fbc9bf7e3b19a5732bc006a8906edea09b6567f8b1f39c5a1efbfd7f3e3a34e71c2eefaf0c4bafeddf6176f320b31fb8d74a20cfd92f91b94702b24edd296866df3e33f5b761eb8a28965ee27781b175c6c0bf8d0b354f53e9f3e4e17735bb2929ce6e687c234068923f8ec9bcca4df0124648b40f113792e3814686a639e8f934830990221fa62e15d00f91092d0b7205370909068362880e3ec9f179519e2b17e6cff59703b88fbdecedfb3a2fae06b03396e61cb6baf094a9a86a4593c01a07f740d0cbabec51097dbb4de187766d82aeb741c7699bd88a2f329ec1bd4a3c840749d0f0e8ce5ad6386fb8f6c062ab5b51d83799cc8d0b0ed7f9a54ac27b5c497954a007705b9c4536539857b467c7b99c3c702dd3a96107d56fdb78101ee3d2394c38021e803d9bdec016260b92835285548bfe4eb0b332c9e5946344e3f92ddb3df04dd2463b706ab221df98ec208d3b8b856b31e1f0125521c44efb77def6ac50802d35760f6bf12cf20f642697a1a1c00e70f2b542d5d62d501637e46e26622230c58057cd5591bf45603e68cfac8537aa4050bf5baaf9d3cff47a1d2c699e9da07ef93f1201934449f322e8e75b9f7dfa76509c1eca368c48cafc5aceb2ca627cab107b099803e7317c85dade066614dc2655fb317bcac026e6f49849bf0153ca2f104364888205518765ec47b49b054d39b012801eae5f3902a6867651d49256dde8e55f6d66be662c9f13f5ad0958e3b28a8c5ab945e3a3c3b2c0a89c395638cb0ac17da1ee9a150471b78d9e23887287b522ccf39aafe822e2267b6b625e1a585b93b817dc218c3623ff9e74f5e63dc2b9395046d28a4d1bea7dea2814bd36feaffd52ecbb13e09c579344d1d1314a2ecd49844743949f2955c990502d9cf5fff7ab403c6a3f6a7b632f7159d9085022a7370b8152f58bac7d3e25be212969cf30e1d83182048b961ab23c6555377a2d134cd137ebfc54ffdb227021c505f3fc5d2cadf32cf9e6fc34450ff7b5a33b39b7815724f5b64ca436de219fbeb4277bf5487ed11cc91a9817245c7201a3342366d8dbfab6a2716d7241d7be29616fa7fef75e9fbaa9fbff7896cb3b35769b04295dcd008ea1154fba56851c337eb822bcb866e95eb5a08acf9b963c3787eec80753e3adf26543a712467a572c045fa36e69579576792b79c09b458d8632d1363051da5472b70f21eb89ca44413db935c993bf4fd9c17a21e1db681213e1d2f0c85811ab129f2acc8029014872d1be258cfc030f7e29924a47190453d8902597a371cf6144116092afa22724e1c49f89e2f7acdc99dba9087d08154ef7be2fddf60bde54b39629e850d26ab2de539a4cc69a85db8eb3c6e511c51b71ff0167d2de4d4ede70efc1e104906bd5dbfba0cd50c311f7373b06027cf9a11bab147cc889012ecb99bdceb6c47aea91a34f6fa1078bec483275946556a5bc4e7658711bf1d285caf0cbf0264ecd6a6ea5f09494926da78ccd8406a29f1fe2fa5ff66cc370267d4350e1ac27da0b37e99686630c76dad9b6181fc7e05af522041840ee9863e41b097a6307134f451c4317453440cfc9970a181102e9c54dfbe9f7d1cfb55a85b7c6a89aaf49d269c528789c497a70a7a758986ba1ba366c854f4b7cb20a502003e8268fd8eb4d961067f6de59e322e3408709430ae160b8a07ea1355c6b7f6eb226337cbbe1eb1495fa7b7c047c8c5ee243faacacb107b9011df888fd4284ed84ccf795f71342388822bab8d40cda043206950098708730d605d422d8bb8f779de826e4764946b2c46d9c82fdb84aed44bb61fed3385586a1ce5d10d011350fbe08ae3809ba04ff8ec9561d981d4eeb7e70efdc76bbc1624b41ae54b7bba22d4278ff8170cf8926197008a5ddcebb0f92be8bb62b8ec7ef04a56588948fc606cd113cbfc78336b131c1388e3d4bc2ce3766faffbd253c059cc1331c0cb53179de907b1d8f593b9899fcb50306f40ebb83d790c572290ba784102c36d0363a266fd64bdfc81e5047fe4c2b815df5b903acdb6c81e77ba52d6125d90316a9b79335f0f926b4c6ca243e732d9e96b7960667b37838a903469a6c04e16e147af6a1b6ac80854ae3b4e0bc3434ed298506d96eff452d2b2e0ba0e0e2b0a9366a7a087ae6408ec818d5d6f8c01e25e93a4353242f785d767ed0bd4c206d0c1928c22fd4413b2ac44994f3e584d952c8bd0dc25fb9ac0c9fa0957df862553aeb6c1e9ba68a0b2423ec5546328d0ab9a7bb58c245d01b91fc0efc9e260aef3f7a641c120477746c1a9b8871413c313b1b2399ddd65595919533d8c9f0bd40f20ffadc4c7b9d073bf1897152bc57d169bf37b22cd2aa6d9c6aa24097783199d075abce1641cebebe34438fe3826f7ae2485de663b595944b1b6041f451ab786b2c4f7d49387379c6529a5f51d5dc12f818b4f52738c7388f2feb2ed9fc17dd56a98efb0369e4859660db6612a44200bbe924996b43864c3922a377d5a699e69ef397bb827984b4258490e1a24e8bd653560b8a18dced5fb0c7ff89135fc0f0bac23ed7f47be2ca3fea9c74819e7a85adcea0c768e69adf63a96c4861484822330b306eee02a11bd89515842a0f8719697bda069219e19550504796f894f04d5a71ff36d3af4a8f232d77a9e027297dc76ae8572e84fa1d1f06d74ffdb29faabe6847dd49b8c2c57b5fab4b5eb6b6eec3da821a1eba604f80a10b7939bf26ca720b423b6d68139ddd7b73ed3710e031c13b0b0ce4a1aa59bded6c1ea79a36f6450e417c78e771cf7a2518d1f04c798ebc0ed78eb8273b17a51612004e0eb46c6835f7b97d0426c545dd80d278a42c8a5658925b4e05409c306819eca49b6368d2af750faedd5607ffe3a95ec5ac54a9a79c0b65e587f19d803e6862e6278a7744524b56a6e5e04b5658b4262756ce04f248d4663c711e3f6e76b58d3fd424f5b12262dac0d83ba965a21fadf84b13dd017a487c8b3e043cf4a5c58d18b320cc7cc1d704392a90b6ea5039947839ecec838ea796330048dc36ef7f701fa93edab13ac460c5f12715943cda8dff8a520efa72919259dab3f68254a5678c413a90c0072892813f8bb064887e80e1e4e3dd62bdb5415c011c75b9a89568671440e669d3edf3d3dd5251c586459928c8105280d6ba7ea54edd3c6fccaf2fe641b8b593c9d17540b47a3bc126e5fb2c7c2017d477296b9bc7511084447c6b619596e33f00b5b4f1063d705417b9bc6f532bdc6c9c3279cb7784e1584d71dce42ccc862f56956594e815b36c84102ddfb7c2c81eb022f5ac5c537356fb2e06228d2399f2c2903ae6745af035a8428a969b6cfb59a9e660f39c534d9ca8af21ed62219cdaf65045c7da3903aad0244de6e0d889ea0e24b2082ed4917ebefee321ca44ad04e2b57e90b785bf69233c3476c882b551fac96141797ed5a534226c6637d03074519540cad10c0ce54a2b615c3f47801f07d744db1348b40386e1d4de9708cdb57c983e3e7f5f0a833d4e4fccd961fdc971a63f87407e0680db3201b44839679afa3fef260967ee0ac7e62e7d63dde37d27cb3bc7931d521917b54f8f459177ce7a17e33c29fbc04a81d1756da1322665b3eecb7b4e0030f885bcb7f25dfa071241583dde54b9ff24b3ffb2923bb37fa2d4d811dd28562dd99ef52f7ddd0b9d122b121802af15db2d150c81945f4cf48dc6ada1f0709ca217e993faca59b6a90e2d3b81fe67a3d5999d6bc16a1b159f7a18079d0f0da67ab6d24df2f93fe0be93f6cb1ea0f012c82e074d62370084c301b1438eb1b2da74c07757cea1c556202c8a6b2bd21edeeca82dba835c8633df2ca12e0652e5b8558c253e2a93cd5b23a0e07aef7dad47b286f3326e477fafae3387f5a04083c713093cd10cfa61ad374b9afb51057d521ac4ce43aac20a3c8c15285b8526226b473dfaaebdec7d6bc4884d182e417c3bffb0d8a91471d609d2e316ba60b807477897ebd32df5f0ba4a86108fc223de1d8b6cefb95fe1794d858f8fbad167f374714056e7caea4988cb4b662bc087e76ff6c7c98fca298305fa8a39bd4a2647f4cbbaec7d33a2d1f1024524c88b32455a18df1daf39f38562bfa8976293b536707b107492896295a8652c5b332e1e02fc053a40826f5c66a94d31477b95fe3ed6f08481c0a68335c330e8fc30ca89e5df1863df881dde5e8d7889368a3d67c8175e5959e946bce5c9e4c40c4472464140ad019e3fb133bc77b6cd4d6965d8d26afb537f3632b132bc3e946c46a0a0faf5d6a74ab79cce89a01919aa5474051996ac67777f6d079759eb7dc2e1e050877ef4fd739dce0a3299fef0070f91eb5cb797b6dad006e050539c4fbd0a7a56194f80df3ef43e25a2fc18e30add9a351266b8f287124be25a5be80fb471c71529c26c86180f51fd4df64a69d8dace0e7ddf6b67ce481e30ed27989c89457cbde93668b58e96df41b305403828c88f9b5c1970e392b7f9c5f6a0e68bf5923ef63448bf998cfd3ace5254c35adb98180782f32f20dfa429ffdf982da8f648a0b65280db50375e68bbf224cb1722f0a2151d52c8dee58a76b9cd7d1ac7917dfd045d92183e2e759f404f44dd3e5fea66caa1984e099c82a51475d8cb9ad80a761beecf2a513d22e7715cb9765a2e52b059615df484d92ded923dc8da38d2431fc69364b0d7465e2bdc98528782cae87380cdf95f92e83b355358e31329b740a43d027d2bb658f96eccac5689765c3289ba0d86dd7cb891122831fec765744ceb5c7fb0411fb714b34c24da7e510ba7e254a5d4cb77f61c2df69081837f00b9220e458278961a4346033b572f0a5acde765b001e013cb6f6a66e554af32dd89586f17f02311d2e992a779592dc136dc03464e56db83369cf67257c6bd87e86d342fc11158ed740f05200e6959de5f428b70f9eb550a8b320991f4cccfd2d6a8d9b6b765d157d34abe7e58aa4cbab4382b784bf0a287299b1d05610308deb15811012c2a483bd1a1bb6bd28d58f796f6d67b19892321b6c36ed0d512abb562b911b7458c5083cab66f6f9604db6cca047a76d12d507a882934ca54e76c0e28775c52ebf5affb205913d7a099f802419af5afbcea6b897e26367034e726eaa1221d599397aae53767abf5ab515d897572e4175cb75abd36645ae32f1eaa5f595aaed24a4f95d1bff40f2f45b1ebf86585e206f1bdb3f12399ab98b3a537d045ac4d315094c5e1b3d1f8262366bca721da99c04bd56b6f924ecf2f0cc80dbc91d1e3d061aef8f970ea58c0f60e70b170f7b6150e0fc4ed47a4b596204ecf46c4309f88dcfa8e130368479b90b7ff340466a86603c8a24ad153c39f26597f5e7bf4e7c20a93c315f691d6cfd35563d716b18768393e3ab436022f8cca4c954d71ee9f5ea8b30428e808e03228142cd0238ad44d8a2660829513c113430c2676505ef03eada3fc1df4ddd48e5beeeba7c7f27664eb31d728a6aa0995ec6fba4bfc90d66e5e64898c1d51ea8bb1fbb2555be197c54600b16632dac2daff0bd0aec6c46af8fe7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
