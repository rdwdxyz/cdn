<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"163b753cc876f6d460bbe3fc783a49bcf702498986a80965025924afea892457f133dfe78070add02f85ef620881c422e6ff29db68e498621473967458242e55831b80233bbd60f0fbf6247eaba4eb70268e8fe8b6f5346ce36d56e649fae1afaaf1011f86a9d952939943d6eb920fd44c13b389eb0150c3f2224c448ea2c5fa7ae18a3af9d5a29906eefeace72b55c77772ec7c45b0c97b78aeaf1d4fb65e61708031d1ea76ed96f106cd302c7de01426d0feba03058e69fd93714a3871e02b76bb4439d57998730147c5bdd628e742eda5024c50126f7608a12ea8c2564f9a6f57b326c3fd5ef2128e9e05cb426426a4dbdbda7c610101502acb01dc266bb78dace952bd507e9ab315b105a82c564fada3812ff6cf3b98094701c9fe58d0ba8524a51fa69e8d397c44d413c485cbf2b58456a6ca3c48a81a0e5aa057957bcce16b1107d6b1384fdc5b33d76685580465f5bc882f801af4ae48add7b4be14c79d265777a14dde33fbd65b8673f32847e4f65db4553b30e9682fa5bd3a3e0b78f794b0a00fb1ac12f9ec99142904271c6bb51b292827e86e58315295503acdcfd74ebcad36cfa8d81a978c3d46f319a4c8cb24ff77d0643043b64030944a5a6910b857f1fddc8235fc45be9810a2fd76d612fd60b5cd08bc28375a3c07bcb5947e7e34aeef413256cf7b5be8c721f3503647f81b3ffa790ae7d0abb328711517bee65f676941840536bbe96f5ded70cac56f597edef2f428d7f3440f9ab9c20f468bc25ea368dcb195cc8382a517e3bfee460c8bbfd755e16625e0cf69862ac07cbe748aaaef4ed4b04b55d25407598e16cfd6be7c71a1c955b7dfd3f5b475d6cf4c3d4c3687096de9329784f264384ff4a32b26be23709d88a69077e720b3656776489b3849a21496e67fb419d1f54259e1040b07b2ce6038820bcefc558b895f1ffd6d20b1226b685bb3b5fc88b70b2511a30619a222c656a092c1c45286fb356eaa85994a2aa07629027b1b663b3a294787074ca11ff7ee8ee94c0296d195d4267e7755cdd731c2e13282214961ff3336774ddd49ec5b71d9b15ac0bf1e3ef92bb04f960fffbbad5565687ac047b93854b9133454602ddfbaae32091208a5b177eabc0354b1a8279b7d05a3ef81ee1dd18fb9e5ce27baf6207f57dcef6b7146dae4156eca6fb43f3eee1d0da30b5270d0ea08f0bb14d281c6dc32dde60db6e8915a397d6ef163a57340ebedb6f9aba108962b1dadc408fdb7642c0eafccdcb27510db2d2f8672101ecfef4bf9f99c03d5cf6baa4857acbfe158376969a373ce0bdda533b560dee646cd1338abb2e70c431be2e49ce8cbc45af127adde1c3a66187ded0d871082b445cc276d332a2de95924d21311b06ee6f9c315a9ee99ac2becd61aae151de42cf4ef336b3a07d7b705b2a345990899b9dfe80f13c32037a5eb0936fe73a4bd65260a08b03e9bb22d9bed6847a564d90457c718afbc5b587e931a2a8958ec499813c68fcb8cb3bd129a487463f7af36d8bfd0d24d0b1886a9740729e6eeef3fe628b8ad4645cb1b092676d0a0e0c4af9b368f43ca63551f1bf11b47dc1038ab56d39c9a1a06926b90735bf41a2909213faa435d8cfc80df2a46da21a18128d9fe1ae35c9ce1658a0f6232cf9d0c5a7221e68ae2c71bbdd7fe4f07d2dd6050339b82afeec9b4a3977d162f4874ccc52adb6cad4b06d09deb9a466249b8ee6b56240482bfe4fe9702bfc026a2fec5e08704719e5cb7defdbd1e1edda5f0929e4c73e563fed0d3d800e569f2074d5632652b2df9324639de2dd0d72c1a5b16acb7cbbfe01eb7e0648518531ec5eff4105280db20483db1303d2168aeb2927c808077a4488cecde57958b5d38632a574690b27dbae258f7409619884734f9d2ad2a7143d1285463f6c50f5e16be316b7410d51f1d19c0634fe4e1b140cdc4589ee7b2ec6d6d90f6605a95fed9094b78b8eb0c1b9e9e4297036056dec35aa9a29bbde7c989b0512387f200d1f8d37ac2c485582358694b9b0c60e03318d5b324a7ff8e1c8d87e390d2344e42ac56bb0a9ff2666f540122b8ebf3b7284f28e6ddfec4202f3d733bd2550bd1cf81be5810687e114d2ef58d1b9b77e417c2bfa533c112fcc9c52cb433a3fdf2466781cc69bab93e922bda5005a6229d6ed3fb72f1d79f4d547b90592e6f0a49958b240b041e8cd7361c66c464eb1f83711e309dfa7200f96be498228c25bfbfcd305cae12d21c239ebf2b69157afb2f86a4bc7ab37329bd26eb5526ac3711e8cb5575e853f223c99930155433e879522f4347d89817c6bc9ca1773cf4fa2fbf8f75c29b4fdd4927f0da3d8dd98886748645011b904d19cb000f5678ed4352e58c879ce69de2098dedd827838f4dda2eb88d77be791b5b5beb990c9de89982d8bfe54bc2c21601e444b8f2508d398f2ea8cfe831afaacaea363b51fd7dbac17f7a36a14418cc9dc56de573ecf06b85edf3174c1933f1f95df9259a77d9d14029e21b3b60aaa56df0e1577ddbac51e937ce47bbab732813fbcc667efc3246a7775b23e1826551ea8d6542513dff3248312b6165d0f8aa878e1a6987a37c843f1f64a07abd50a3c2dac088f291899bdb59144cfdcc4b7e117849c2b50a549716e8ed8e2c21881d6eb94ab1b1992fe998246f831ca5315890e82d9adc0bad70ef1a1f86fefefeb460e639f48c58e9e77762ec13cffd8ac0197cc2d2324e0e398403801fa27695918d81768d8ff9d8a7f45641511565cca66fb89a3f68d3e28dbd93df2241dd9ef8e7e4f2e142c6aaaef19e46171b3cc9d47a0b2e82f880f93ddfa4712320ccf3a8a72b7ca1d73daff1a965da43d9d95e88d141cc302f5d9a951041fadc99f17d629353a31001c1ee5f3c3cbf9747203dde935c1da1e00409ed078e806f1c5a0bb4644df429f20a242a9292614c4d8a0cb5e5b55c3eea57e428b74067bc5bda9f5a7e4c3e07a5383837780303d5d77d8d4aa965b95555acd3c5ccd6a43a40be5e74891d31698095add5f77aefafc919e86cd6f1d67898902731bc82d2508205dbb92044d906329128981dbd9009225fc76dead2aab0ac791c23dade51356a229d477783f2946525c2229014b1d01c6dbcfd134a1950fe92dc55fcdec1dbc5a582d585a0748203f85e82c16b8ea0577de596c6431af2561e3f006784d752af7478893981fd7798a6f7b550b498462bdfcea5debc7a0992ef8316e0b228f9b1537c3ea5ace18f2a9f2bb2180501a459688d39a335afbd28b874528c274fcdc3c3ee8f5ee77fad97f3d1846298b0c31558058e0a8dee4b1abb4a03b9dc87b559add14a6c2fb396bd5d867a94998793ad2225aafd98343542301ec7f2692bb80f83e89c35eea33ebc0072277be23dcb642ca68deb79922d5388c8754a3f99fdb649b2dbd9bb83f3e90447a3d5582636e27817d7328875ef7faf4ae3b2685c5e8ba58b1f50c301adce7d808cfc81fe8ad0a6cad9843bc24948cd3f2174af358f6b2a1d14def14e88d1496e41a3227a36fe0c8bfe5b76e549553398660ef2c1cb91f78e1baf79f5b6d768e3947a39c36fb4537634e52992d68c3c4e61a63348c0c68cac8dc1c5d0da322b9561a0bd7edd4a15a2bf4722efb6d0692907858e862631d3ead956897c86334f66c2d370edd1e5683107e8814c1e171a9bda022f4703a978bfa3ad81d39fef68c5bc06702ad09febba4fda5c5da6991a6a9ab9a995eede115bef4ba91a85d1828d623136424b6c7e2f84ac054ec98375d0e2d6e9639a2e85e27efe00f8f0d646ccf18bd574a11049884ee786c3679802aaf513bbd7faed41cbfc05010dfa83b54d4b9cd0b3b79ac4cf93dc9b4f0993ac4bf8e0648adc01bdd2bb6581053aae28769b8cf91291150e8b5976e9df2f33e26ac5c4df0fc2832f161db483b40a6b6137dad88c5bd8ba10ab01a3c94d4482d6ede076b938c29ecc34f4d60ccfbe4fe33eb5dcdefff948fae0143b912cadef5c0ea54f6c43573f2ee1e553f045152178db045e771cb78efdd541c4800bbe38767657246ec19a0f38180fa162bd23914104c5ce27a599d6d0441a4ae36fde8d1fa1b6df864eaa218e5e4a197f700c36ec7fdb76f50514ef9342fa168217c7efcb66737db5536877f15b8da5990bdba427deec76580d0f687476dcf6bbb7a69bfb3a9e934e047806692e26316384500eb22ebdb171e437533643c35d57b45dd1f0d3b6c802ac849eb2716c4216aa40ecad583d91716d701fb27d796f8dc60d66ba57ba820534fa962b781f89bbda16a5e79864fa4cb29b54dc4c37026e5a8aa67dfc519a8192a4ca8c9a2b3fb4574cc6e09ded089fe92608dcde0f8ebcb33bdf9d85ec88dfcee055878922a865f47baec2f92eeeb1961d755c0d063630220bfa80900addc0cd1c892edd6edfb150de28c0b353224d817ddc7df570983e69ef2f4439af87b478f8fda2f7aef1e59a53fe019a6c37e6318b4dcceb89acc103356b0d12ef5989ae82707f2b9b3e8e86f4f4b6c817b74659b165260ade67ace962ed57814a70feb2e9906152e08ed3ca1232ad0ecf214bef7a792b1b362982396ce0772ed953ddc00fddb3c3d8e18d7dad0ed157ceae70e3647ae6e514658d2cc93acd40e057712399c827d2e59af419464a78b7e2335051a229a80f65e9683c7677101466e6fd18a3477c370c0e11b7dcfc2b78694f845e2b27b9749ca20a0999f9105267e9be60d44d66e877e7aa791952ccf9a748efb59704cbadddc3b6a8256df78ce517873170cdb5cdd6d0771f1468185d2a40f2da7f2552d63122da4edb2d24319c4cf6ac5e65faf08d46f744e57ac56da9b418a936ff5dd63bccc27d064c2cd268bf859e9278789b7025897372108ebaefd579c3c2f9819e1af7425999234224be410498725fea67fd43c6edd1ea85339fb96dfe9ba843b605add865c372bd4ef4dd92e0058a09c31977285cfa4ce415c5b157e50dd10fbdbae2628bd0fbdf614a6043db270a14edf4b6106835ec0300bd31bc6b3f1aaea35f57b482fb01b89049390446302512fa63770bf4f448b46e4db319965c1636e3176de74ad773e0220810a50dd2d155d7847da60dfb02615770b3948be5e95ce7da62c5734fba16c0099e2474f7460e64ed49e3583b8223da8a94915ca62d4ab41289c48dc604957d246768ab90ead41e1283ee2da706f19385db45ef8ff2e5545c0fa53b1928cb5d9300321543ed645fe69f681980697bac2d3af0ad2d7a8b5641f30da3ebbf480f5bafb32edeba866e0f7f4c1f8c69fba33a390d44816b508a760eb90085ef2354c138d2e8ccae6695c0529123c33bcf8da368faa0d632dc9ec0d71a9d786501d388ed2ac8ffddf51ee4bc2520f20ae4c85a01e19d57e960ccfe61b791ebcbcb7c1b5c011d74f49112fb4dcd851c0e0f37e9538f5f8e0df0dc5238a390ba16b81442861a421e9dc84b73266a090b3cf89650bece8a6c9caaddeff4782db48a79c5a5a421dae3ccc8f7f747370a63f2552ff8c40e8a7f5b77ebcdb1d22d9ed31b9e24e97c9df0cb58be24223d3146b8c1cce35c20a0f09cba2921042dedbf8bb6e3b374eb8cde4318d5a8cc87aebb6b29a76f6154d5efc8c96c488b3ffb4af650d2674cf6ceecb5d41585d80667a8ab6671fe8abd3fdba25118ac23b114aa5b8f246b84df50a72dea0d744c4580feac68e938346b7813d138e90352299456defbb2ae369bb8d5264ff155bf3bbea5057eb88bac179818317808f70cfd0e771cf270974e121b3cc6160e4a0f47ed2112f44c7b6302d5d42bc0d04816db7d152de08ffde7d3c32db247d320834f7239badce4a0ecad45c2db5a206dede7fc09ead0a8af04486bea92f6bc64d60e5d8fc4f81230329361f0d366e103284a8fcf36d4349c5fe85fa34a22b6bed38b9acb5c60a19a95ceab4f675e4569062a42cd1ac2a001bed26bf3bf53e8a903577b751a18051a89a072382935daae45252323c9ea63d3c969bd7e925451506a487b7e1d4a47353ceeee6348432ce059ce03cba3c025462e31373e631978c18aec736c1621fb7eb108fa41dc7c4b814548766b1a4edfebadd49cbd2f0357d3e5c6fe5b54e971acb76613e8f7d282467380e95c768fb4d81322ed7d43f69024dd034046839e9542695bfba856ee6f783c633f532df5a5907ad17c4cf279617243debe4149e86ab8285d3d3d3f5932f94813d6fae5b6c8e04c53d3f113dc476c8d25faedaa84f8e030312330b87a08f47aaef67a69491ac00c16f1ac419b4d3e8ae0903bf3fe0f15cf447100a3467ca65e00992892290bef6831a92df3ce3bd7b4c08e5d42ad889d73af38a3a7051de7518c6b49021e6b0ea726a1c4b7ee8807923247924b474b6df1173329fae041a609d3d1fb2e7d4a371751571275896cacf6ba7c455c02644c440c59dc54b382941df60421ed88184653ced3709deb9a7cdf42171cfb073c0cf792a5ac757125a2b4031d429deaa8c80a0c27d3dff3321804398f3fb1858d3ef84511bd95648f29c8ee544ee079038725eb68c2a6712160a409daa4a1f7ea23c07bef2004322af15538ada59d8a35352974ec560f74d6cd9162918ee985785b6da874693e49c67fb38bbca48870ac004fd8fdcfa5a1883fb44c096c323394af60e8624803fa0df24b1986d09a8845a755f471834bc806f6144141acc273ce1409c47b9c3563985e6d58c5dad2712d06338e1423396af54dfc066732989fad2b72e7cf2dc45a7e5a79dfc22aa34ce3eef793d92b8de88483eff071007dc75c05b6ec0bee662ad4eeaeb7f1d62c75d57df717cf12d6221c861827b631a100256f78e96fd6d173f6e598cccf41fec0cab31be55714526258cecb69f9bf494037a3ffa15b479d49850a68cbcaafd861eee285006c504ca4069449c2546aacee8c299645e8baa7294aa25bc923696c1f68996e5d2decd39caf56782803089016f5ecaf952e550901b04ebfb459b9d8eeebc4c67a95b17157d44c8211f831824145e02f3eedfbccc86445d37d25ea8ea322d1d34301f8346de33f6585beffc9f59597bb18c655759170badb2843f7ece84fa28f3951e7ae66a7c8b6c670497097d9e24ba8f79ef42980451063f3ad3617e4d31da12ceebf0c38b973957ecbf194f79ea0516ec9487ebb8da4f2b61087e095bb1da4b96f7bf3762fbc42bc167ce1da7f69e2ccd29ab20d569309ff4c5029b04204ec525fcf2500e73f2dbe2613e93f70f5566cd9f1850aa8b65b100b904eb289c33e3f35eb835b4d953d00f611794af0309cc6d7cf646501cea9bdad6691336dd9ef593910f61539fff9216ed59b98423210eea8eba1b653b26da25045daa735e750e74c8f765b1a2b3648eb57befacb032a2c2f636d25bf366350d5a125f02f0f2f3f445af22caf62c5e43699143ffaf98edb882b8ea055f95498c0a399f03d536aeaa5bea83c8ea0fc787c6e2c6ec10a18a2723a8add47f97d25784c7e252067b333b6d95acd3c47047bcb17c19622d2afa328eadfd32e61b4bdef663198a58e9a7fe42ee2e1454dd414748b32c10748f3504b01322ffeeccafc4adf655957e13b0bc906d463824af8857b2c10069693ce162135b37b7e6b747ded27be75c344896348bb2798beba9418fad4e1ab2e9ebeb3c21bc464f7bbf5a1dd6d9194c5cd4f00ca7eaec4ed92c8e1fa41c0f6361b24deb1e682cf9e93d750af218204e0fa97ba8629b3857dde62b0eb1ff9a52e858512a7cdbe1823ab60d1983e97e2acaaa7677c627c359e850d70564619fe755caff17a0f26b5c7c545807d3b60c8b18ca78cdcec92b0f1dc185d172ab92467d3183a9cdaaa5ed2277c37d8af15fa76289cd5421d11bdb3cbc6d1079a8c42e1c46631776974ef147497c3644e8f2d0d2f0595e393a38b6b3a4c5636be94422c8a352377773f081a29d4096f82f449d221f3c0b67bb18aaf74c41d2de89ce3a452187dab537105437c434b36b409ea6332f21c7edd2d511ae5f1e66d433ba3a6105aa1da6454c9b69141cec0f3a1c60fa04f0b3a7b1c0cd950270fa336a4a6badbc2668591622f888965b13eeae2d3967bb340d5f5b6cb5cab5b009ffdb98892c804474276b4c2b7eb99a3bd31517d931c38ab4249189fc356a76c564ff8d41230210e2c29be9af75f96906632d95a85bd1e1e9bd814f27083826c3ce5046198425782ddbaf6b1204557bbe7fd781e79e6a31c731ce82c88558d1aca18ba1821282f79d6422fd48f521182dc6e6b7b79b34ebe6526877aa75948f5ef9ac85e6cc5f8e7160f575e21af61fc3dbb8e9e0765fd540c92a0582f35a6d1f2123122f6c2984a3ad11808c7f23ba4c47cf72502ae31ee82f339a0eb49419291fedb9e36022920c98a4af00934374d2cbb8e9486e8e263e10b63b81d67289b70314f5eda01e042cddd773db524775d294a61be6620c64ca8fbc8285cbf47791978999d576cbd037a665df137b8850e7461c354a6ab2efd9453f858eec1808a1b02166bb0930fb79c66a73620f7fe29234e772be7391e6a33259c5010ba3c05eecc7ddc7203f949ad78f22c0f73db64c4b1937f40200335acab22d7a9326902abc2bbd659e0e465d4d251f247b2b84419781457dcfc2fd4febeada5dcd8b2fab9aeb0f3aec76ae081a6ae09a0d28a0e33529b6c6a81bc1cf3e691ead31ff2d35b0ba8d39cc5b7301ca1568424b8c838c51a6287fe2c2640cada4c6827b9936d8b2f021dd7ba5f00ff016d71dd52c0342159b1dc947271c238a3e69d895e4761c44ab2c31ccd62bf75faed234bdbb3a502b4087276f1214e3bb73212997b0a03ce83a01c3cf2529eeae76fea2d3b62341a3f169bf695ea00de7b97e8ffc9d698111088aad2e4edf7abbd156cea9ca7c8f997e2117961472b9160590d256edd26e99dcb32745db0f2a46e072f23a05f1497f666d1c65921b7b0e384c9f7b74cc171ce1be7597d8a38f3e85aac0c1cfa33481651cb87f6edfad7505b64a772305bc6fdfc5b3fa08c6e2329df80b3a491acf3bd033ae9c77199966fe0db129bb343a2766827c4f84389e198a482ff2ce0a53a9335bc24333184eadbf10abd359dbe7b9eec4857a62b2b231978ef5446d67157ed430633da49d559678b30eebdc9f4a7a169df5889436500cd4ee994818c0fbc052284a22ef71904f6be0a1c91bcedc2b9529495f6d65d577fe9393a68e1c015e85c0823d576e0382855828a672459ed4c6566ab04b61330868a5a44bbda14212091aff55e21d53251e932bb3b6ec54d7f99593e67f93c6e1512eaac209c032e4c32e1369429b6ac488535c93e8bdc40e2089689b8920a3894ca2a7f4e82732055d3fdcbedab47fdc96ee3f28d370aa41ae89013ba0da9e885fac3858e1a9be153228fdaa95f36b5451e50b01068d7f195dd027628c4fde8001015c59a43ba84910dab9b96d401a2f4d2a287d35bf8439494f41e4f1c7a9d7c920bc80933bd703ccc867340b59becac1c5531485f186dfb6942e3eb95d4415e7bd18480105fbe3b64f8223f07551b1202ec6e60386df314fcf18ec45fb773028c6f6d4f20a5bcd7e16b16100da65b51d722ce9f0922c8a1908a206b6bb03a18e6387bac14b071fb45ee8202ad2e38de41be90623e214a3c38b8401837c23461ed3d2286a25f662647178010694aa4a2ace7a817e0f2efca3e7c63cc59590cf77223101e846bc798017a4a37ffb6cbf364bf7d2bac480b45168b5ac9db2c12b8368ef7d2ce32983c73ea594681794d00e6c914d83f985d4056a8126be3e5371eb92d94db38afd17107e1d63b10321859d87b0d3ace82b4448abd81200e0cc682ce46c15137c618ca3b3e96725b21c943a148706fc1aa49ae5b12d4ff5bd72a8fc7e0a6100c1523bff9caba43a261a0eb397afbe895f4adf6a34531521a64691bfc65c0c329606959c20158e9d03e1428ee476168791aceebe68ee8553c76d425858901d886f820b8a5c73790dc5e5127ee78850b8c99e3d39b12204a122ce6d420c5c8b45e7559063937331b08cd298f4bd7a2501fa47c93a2f10418ee6a62f21fb9f300678c52011923b24dce5be755aee55a2a89452fb522ce363fd6d150e63b9ff1ab30f531633cd2c1bec7dc2894c4ad70d8f8696ac115bad1c6199fa650721b053b88bdf9d25f890d407cbd30f69d210350f9cdf678dc63ba3e46fb87e0e6667f6a9b963095ea50e8bd5b070a58d695160207987bed35830e5552157d6363a8980373f84b47b2e51791b2576ffc7a9798bdfc1ca711c73fe19c226ce0ee6fcbd3eb25af9b9f23c9ab5194562db9002fcd5c6e2a0e8e81efffe6d188d12ac5f371903d6892b1a610574251851e2972c1018514cebd340bf9b1c2f64d01383a2fab2105300d50607c25b0314a3dd452828cf95d89dff73e9262346e03655fd30ee3b54edb2f1492cb54974de9490a745f4fe0a7fe0814337f78eef5afa1ca90a7e03dd4eaeee97a2c927ad32a0e8e4e65b835bda817f8f8ae51f7d380329413fffb9c54f86f5dd023822f66a5bd74af658812c450a6127a00bb87e4de5c0350e6b34e51902248f1fec22cc0a64e08498fb31f65d5e759600b9f506e1a165b62739b75ff7734ad4eddcee823f3df38b7f3ecb1619798ab36f0596ad8f198f5931b26949d1531fc7376953f9a76f4887b924cd8b5baeaa580b45e413e8e5f3c8c55f734ace43fe6e93281e1282b6b7c2857f04dda6a88111bdf4ee3386a1ae2c0c4b5ed3d40d2c040b383343e16d1a655fa0bca407cb975008fafc54d480d70bdfcb7269b76024504a6afbe9d92d41d8b8a498de3a7d5b3a974465acde9b7d95e0edb42ca303202bf15436e46aa7a4769dc079305b3bdc84836f9e53b6320b5cd7549d603d14325efe577673fd78caf70489ff99d0a3ff6cee2b7190f061a3ea525c2751129fc6b4e21d6a5d6f18591ce765219079b7919f6a35d8a511dad359c7cd27ca875409380010ffcfbf840b2e7fc1595924b7f95ce07023abd2e687aa1feb642a9f790d12c3196260a814c989a0e500909b667e7ff7d1f139ce1527f755a68fa9000040ad60e766cf3472a323311de439d3c749034c96d49b4cefc3c7d875518bebbf55e914a790ae9289816553aa2d7846176d69721304fad12c61becc87a2ff70c21f22463f2ac71683d9422532a7a778b09890fd62aeb5e1822f804c032ac3522e6e78b0475471790e830b2ed1deda8bad4b61a9ef7704a58c8477d78f7571250c76ab8323a53f1d71876990e3bf0efdf48eb72ef250d525c9470155a660aae40e1287af563f2bd638b1e96f9884c1d77ef58d6c89bd8f5b1592f3d333b35c485b634c61190e3f21b05a7149a57007d4e679cbfc6be102bd9e3d468d3e7b0ffda55d27577a7b20c43b5934f3185d2f563fe58dd966a8ca24dbdc067c6518310c593c20719fd4fd38c3ce0717b873afd52245e0a7baefb91e1802dfffb0eed369da76dbe7f028b6d384e9bf271d1f1b8ba1725f26a1ff1f6265314ae1256c28b8ed63ffed957ac2ea7bfe07bed8bb29aef61d2cd0edf9657d03c22195054b17bdd2a288b8441711fe8cb7589e8871aa510a6726b1422466cf896254bfbbd139db04c1dfa7b1f47175532268eaa258b904a6e5fc5b1e9b41913c8f86ffe31687c0b4db98c3ca039348b9669717ab85968fdba2a360d23d762d9093e40544e1daf57db5f7726cad0a8d5415aaa7d3432148514d99aa6a93abb04219b731708a7413c8828f036ea66690f7e13799e87659aa4180310dae983236a5af9a79702f0fc7c3becb0ad63e31292191fb61a222042b852120b01137d6f2670da919ec27e446b33334cb2d51896934dd40da375365a239cb52cc1543dd9e5025f8375e42307514cdaf07f3278f2dd11810ce5c20d4e80d8e7daab00769d2593af94289b47caf266392bbdb4b385f953dad0a130c9ca9cc3d7ed8da93326f4f3b7ef1ff7b6b73b38c4e9a6b50e2621ac5a530b50edab0ea74e7c39e256af35071c6aee3f416a7ba06bda7b5132d5a4c5973e7b2e2e3d53e21254a24fbef3368d847b2915ade324eb24d1d4f593beb38432ba1586dc16f715c729052ec6a62b2be91b564bb6e1f72617bbfe36e647ff371a67e78ad1df42c0ac7aa9329ab48e07749a581aaf85253d3dc4a73a15deaebd6fe0d11b16b9b70e73c5378834abd12d83900d9813b3d965fee413819af6efe0bfde8502ddc98780bdf6448279441c0ecddd04e11c145850649cf01d4bb9ad8423410f894f2403883ba33356bbbe0bf11b73b64cc2fffbd67dcaf9dd7332e2c68b368d09939edb2a937ee0f583e0d97fa7b64209efeb9eabbccbad14c9adfbf52627c0f70ba4351185be960f2d4950ea5084eb8a0e32665e3d966ff578291e699ec56db8909e315525fb3a5817b797f91547e33dfbd02a8dadcea2d9803d18c5023b18885a8f5b3c707b53eb99e630d105a3f3ffff489bddbc1dccd480a3c40e2392ee522ba039918de81d43d3fffb2e78798d39ab91a30d922035faf6b1c89fd545925ffd31b0684635cffa6297143801a415ed458e45c0943af497895a763965ea6ce7086023ad23dd1c47723d23c7a1a21e167a985b2ff83433f7cddcf6ae6c330fabf142f3d75b6f6ef98f9223853da4f4b660d4dc205fb08822421441c01702e3adf1036d403e150a7b9cf790e0a78a2a157952f41c73d6eb2078c26338873ae794d78d91f9cd8d01394b647264bc35dc298ce66eb78214d3878dc45a05c9c97d4736edcd0c6c60af32269c5219def8f92d28b7c5868f0dde6e5d52207b6309ef11e19668d160cc078c0156cb2df78382a37e95c994f725769cfe09615eae28d16ed8246aaed47f56a9a199b84056cb3de629ae614a17d52c190ff0cc51a002e3811a4af30c1a8b0da85ff41b10956ed9acf5fc5a5e24c49ffe24603e57931c7269d9ccca935d891444231b6499f17410cc8a7959ffc919f3b4f9269e71f30587182665d16873f395cbc52fa1353d3ec9b82f66652594e7959e54e6801e80daa218d52d7afc7297f124306c4cda841bb4264ed7da61f9291fb6065bcf89c30b42a21895fcc7562a1b8cfd18b4c7be167519313f4a0ffedc4ff825242f1c3db0116351758e17547c444d6790e85cda69b07ba340230e45777948ef52df86f69011266acdce3351cf49c1ffdb66527ac9d669c6907c904e9bab39b678abd54ec516629567336296a583fb0fe7f579aa3f062ae55d791e261c3db93ac9aae16bf1ada76dea226b7abf326f52fc8ca4b5b6deb4225b3ac4b258a111ee44ab1cf18baa03388c78181d076137339061f91d84339133b0ea30eb40fc3f1f96388bdd4ec4ac506f71e28e0047c968cf41e6a16c71abad6bf41c6c49b4489bb74460aea5a5496dbf7288128296529e372ebab6c934e1df98ce55416b523449b7975c5a264ea1318bb51b627c6a283f28be8210c8dc0c342eb016e2ccd2d54544b062a008654011e0d7f5f671e94f363d14dcda61e4c7d7324a3dbf6ef6ad6d4eed9554e245ec7fee24745ad21ca55fe0eef9f78e554dc70ba34e2a734a0a5b20e5291b9ff766a4869be7830fd8092220504a262ce90aea371879d1c504f7408ad00f95a1a13102d1892ea858cf93ac36a09f8e1e04bce603e16789c54c36999860da504beec0cc4a1e96ebec0f848b8d8f01bc258f57974c128ab7599296ca2cf9ba79b355b16907c7b3c40983953e5942b3acc3ab82997c84f59df86bfb5377afe683f85a466d968aeaf19285ecd94d1441cfcafafcc42c382b100db31f3f462101e1841b63803b53c29bf8d6f48aead6f2fd2bf70304f3e22e37a4c1103ead171bb245d41f91b2eb6f1eef48dec88ce9d77eac166ccadf337921fba26b6004d81f0c78737b25e49512b661c53595341bc3e05c728f05921366ebdeeace33b4d7b550fa7eac7622272a0ecc07e855492071af2d477441974dde3279de2441ba0450645e65c6e48c88a556b47d9971e8382eaed6b571d9f5a7b2dc640a50b73b5249baa99cb50a70e4f35bed48b38e463ac576a07e6be0f94751c19282a4f056cdb2a5045e3f8e033fb6884fe59582ee7ff9a881221c82b195a30d80dc74bd766c69fab4bad096dda6279df270dc638cd477569c06c988a3c928df353d1a4abae7ba3386bd77f58fb8e3b076a6b81325d898cb5b51c30022c10d3f8011fe96da3dd0a4086d6f05f9f6c91754ff8d314c56a6fbdae6deda745de3957009e5355bf3ce9730659ec75cd5b245cac929d805bd27201b2bc2338784459837742c6e108b46f37aef03d31574512e219c2a6cdef1240cf563a1854c660a2b23fdcff6760d6e0bbbcea199a18373bd272342f97486f868b0a30425124e9077f374e274964985bad70a4387a0855d629bbc3bc7eba879a3b7258dd62d4acfbf2a5e4a0ad2e96bc9b87b726748389f4a9f88b75116752444b42f65701e216d06ae2b53881090df82db97d8855585d941031bb4a8863376931dfd6ac1f424bfec24d70a66dab2a04b456b3110ac5e3e77bc35d194335b44549083137dcc36270fc4624599c2fb8b71552fd19b23921b4bc32b8a6f7a0eb50b788659dd4ad89dce3874a8ab00e6f1fe20baa8576c1d0e8f0663c2e8b0180151ba686e1336006a9176fd7e27aad0cbdf7e73357168a09d1444d12ab630c7537ef83216ee05643a8013aad0c0d971effad82650de0fcd0f1ecd3fda5836573f60ed542e7df88caa1f29219b666fde4b6256de6ea70c005a8e2c5293e5a9dc364b6fe31a65e9064066a860ada03dacfef617aedbfc9efacb1952720b53124f1f3430bf41ed2ab50b3d6c6fefbe50094a76b37eb2efc8fb1193658f5e0fd74247262d727f10cbcd0aba0a53ddd56de8076e440049d8300a882e2e0e3dfb64e7eda11b9a75ddc291177cf76e3e7b9380d7bc12b4dff637199bef9564723b66fd3206ef5e39439c13264186a5169631b59aec545be0a40c06de29f2772cb764aa0cc0e31bf230992d5c284947917c85dcfe99fe657df4dea23828e245a693e247d7ab58601d5964e76a4c87062c07d6507cf1359e66a961c807151bd4e745a25c44a97dfd8ff2b7ea752f61044fbad21f358d4c842a740be5d9d651b2abbfc122d9721794c9bc012999eaf662e45a63a4111dcd80c9be48511e79b8009f146058f0a34a120e0ff016859d3d7fdf621bb25dc53ca0c139758dd2748a99125488d098f168763ce1ac2f8b13b80de78f6c39c98fd9094e2a293e1216f2a6f0ba1e69c30dc21b5057b8ca0402a4591d67e031405f88a37511f476c56f4e68c8ed0bdd638ef66de2cee248ef38c580d7dabf6e88dff09c0e0dd8ce4a575a8c0e054ebd7aa30766d1c7f7c6b31a64b5f25baf6e0088806127aab9e6c478df5fdc9a4a2b8a4a3d7c7a875d59070b920aad396ecf998d237738da9a471b370ec9d91eb406f15be3d4f2339219bb8621d99453dcb871fd740aeec4c3eea00b7fa2d071ea593f691f35473fc52c5ace13693a0236552141d1d12c86dd6259c32ce58612ec6cb9b603ed41ac1f2a860ecd7ebeba7549aed098bb03d249c7e7c8e5df39a2183f7262b674e5263ac53d9b6398f8af497fd914bdd1ee81ba0e685d6c97cc3cd82699e660c4bba4d4edb5b1829d9f5c1c8d8df2c565a2584896fc0f255cde21eddab5adb88f975c444460065b9ce6346c263ff42e0f29f1c65122d5f4a9421fa38e03b9cabf01d2d1e70ee759d760afcfe371a1cd0d75d0fc217dbda400509a565eb5f4c3d6495858be93c5f4577eb74164814ce547b1a65a79cb3a3d77b1c5a08a438c9ddeecd70a34dcf3d98561c642812b6c29fceebc618feb9c6300dd849d97468921efa68e51774fa95f061f6aa0feae898f4a78c607aaa366c2781719fe2bd36d1e35a3dc1efa2e3d671589de6309160895d79eaa947972d9789c89e8cfcdfc52f8a0162cca91e4db7f717df848f500e494709a7aa0396d324bc4c2d4129c155f175cf6b50fffcf6f41f79df9ff3504d04619e939cbb33741c0d65cb9f471ba53ee0fcda7568a336e02d36e7ff6c8a6893da329ec78736260e983eec9bcd7f9517df96b2046db47aa9cd0c809ccc514f9ee0c53f5fe0e2478429fdd612e1fdcc3908744061aea46e4af017b8de08dfe98e459b16a8370a384084c288856c5796ec3ca5e20d99acfb5692b64f34f8d62a4a1a1694e704908040df89bb31616d628e1cd5e318947d808c14bf212ac7599b9cb6a297f5190d944827e72d40ec6279ccba139b1bd7bf59ee40feb620141813b4f383973b33cb6ce6f9df99b590210f8240fb2825eaf97504e366411a7f27bd34adfb3c6118dca40033152fe2f8627afc315e82aad086d5ca2f481148c2c36685a0a6cdd0e869533909736875bc110aa1bb1213eb9b5775ef9240726a711d65c28fcbba2e43a43044fb7b906b1d30fc2bacac6a1296b29514d2c66d4f7b4a7a3767f79dabf694d7e3f5616aeb4eba6d879267b3b57543a546af5527a27f7d33feece34e537039d9431ec5efb92519df8df52c283646ad2a01d6b05a228f9fcaea37301d9b6449f90848652c23393306c3ac09d2230a24c1e27d21b45ffd36eca5d41671ff2189558085f0c2af4af810c35190321d9ff95e108a5e11cd9d9b9be8d86c0a323e7253872a9397261b434c0362f83d23b509de45f33c58f7dfd7dbc4f8896562219fc46566bc114b906573873e37e44d881158b27fa6ddc026e5ac936564ede681795cecfb2311ef4ac8baae46c1f884cd464621a8267a8d6218af1f50a5ba3e13d222a3e5ca7232835cf4e77a809baeab5a11f25df9091950bba0e6e19ae42b9f5566c5ed116d73217d1ffbb50f8886a2e7a8e97f3710809eb81db90d51a6d1577b8c6bf43579030763a8b505a790fdb20c774ee9843d1421b5a62d2f03f3ab218ff2269b200c0c49f8ebaf7396e9ce88a42eecb7c5de9168f18d8cabdfd17d6832c3d30a8175ded5c2d4fbfbf4150b127c84fb9a87d3c5320b3bb389c527a548949975dc29730e3ae73b569d637e2000ac26b31a5347d470afedce819aa30bcc886d7b608fc8202b93301080db55f2357045ab3d9511464f1a4b8b6f281ffb1d030bfc202030e25792e0391f3049fa3f47723b7e293487d84c723b4fe424f1a974b30798b139e900474b3a3720d4e846a0788e836f101abda6b24288e38d60c2dc5ea792b147bb44c22830948c0b23fe031d4ac3f4230c231b6fca30f35792dbb9dda8cb2cc0d5c9e5a90df7c799293b04e740224d099050b539cfd5785b6568d19bde33e8f41cf325cad15521d3d3f101d5b94d8ad3e072064336870f691b4c131bea4040241654bc893bb1751547fea7aaa15b7f6dea294bbb50cc415dce07391b63bc10e8b25555abd18dbaea67cbc35d8823f2ebd855190c146edb41779bcca87497fdc16beff44494a2f57b389aca8bb1f5a4f0ea3f02ec6f6ea01b2af084e1afa169696773249c5961309011e01e0461987aaee204a359c54631566fe28a330f5581c91e4315784c29b7d980ee36d21536d9c0b3df857ec081039a9a755edf3d1014357d3ecb906db4627693dea41316777a97ac17ecc5f7cfd07c0dc03afeb1ef8e0fdfa94ebf9ad5111a5883b4703e724ad82cb6ee138cb092851235460456417012e14e4eb24d36c845682d5dd03d9e616747d6bb4ff84760e0e23a5d51ceb54ed4c9a91a57fdf3a00af886595ffb0d2ea5c8caba59427e9df81e33a3ca3f5f8045581b1e9eb8926cc56a786e40a824a251ffad97acdac7b4d10b69ea4dffe8bf57f1a377322b4e148021b242d86935e35cbddcd01143099a803948b40d27a2728840c72a9e559a216d5caeb7d318276293aacdb5823b28bc125227c14abca1028b736cc9d6366c70a7dcc340563288f310c44af70452ae146c4c10a16407202f59f4a0789cea5cd1f1a7452a6aa45c5f4f9a457f76dc1fd3c52e90a913384446d8de9729d2407146b774f3d6ae65954d1402ea33200f2ffeb61eeeeb08ee937aa72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
