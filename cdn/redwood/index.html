<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b8218ae44ffdc6d07d1f985513e73fb2c692605bb880b030e1da899366b96bfdc0a5fba6bb7de47e30bdc473c5da9c19dec847dcdf948d19f0a05ea72d38f3c3ca88318cc03a8163c7f892ef23593375d08e786e7adaeb58ee8d1c8c43fbf7f49c3c9f7ffd818e1189af0e7b5e4aa6b9253911bd0a93d4b43ce32476e6fd24db0d510f5715d123f8570f16037c782e0544fb88e1bb0301952995defbe2c954ee98c63c5024fa69c7b14e8ad9cfe27842f67f2db7d34bf74b3a1751171044de933866fce7f9c6beda65e93777eff5305db98e19d667df90d6eb85a6e6c46f8bf6d73a6cb2e6aa0e95cbd46d1d4a67bb44cab7b34291c14103e937b7b3597f6e26834a44defdd6616ef4ca2744e04256bc33e6e7a20fb6dcaeb4b83afc712f91331266ee21bb4a0e35364e1c4b4c6bbf52f541ef0068edfd57c63f70d99d22b9f6d48760c04a42be2b27ffdd6f2f3a566fa6937317a0d496c5ede769e52e6c86181d6aafe44b3a33d8b79f853814ca4992dd86ba974b097c66021c9f8003ade73a19ebdee327ae742610aae9e7cfb50b6ce75475ce1606d9f6345a33ce7377acfa55c01a202c5cda0bc6ab25170afd749df0a946d70d9a1234773b4f9725aeacfcef6cea992c768d077eb2e401b82d79eb6a2f032793c105d6484d7b328f8dbd746859ea4b434cf5d8aa220eded854de7ffcca628e5195457f32ada851b010e58dfd3e79d03cedde77228408125844793e80ec4f521508aad1e6d99b8f3b1e916c1aaef2f39bee1cf48a3396ee52f501386d6cad5c7b8b75d8b83508632835ca151cdc5cc169ee9ce35ecfaa589c6f76abc2803a667e678f5d059e581bb28d162674a7a2821cad34e8f22c757b46834e43ffc68c9b8474bf2bcdfbe1b6d86c26380df9483116e0db3cc6f700ad54f35a9be2dd6b593986e4df4529bdc423c74109c3feb3d26fae432dafab604e6b9f39c707e798e0b15e3a7f451adc864bb0bdc60dfeebbbd2a37c6147ee8b745941391ad7800b9acbeb3c45ac329160ab3156aa44bfcd6516ad9b7ed8c1e775053cdcd6adb82f979dbb9aa1a3ee340b53191c2eda55c240383e8612cd475180c6469b0a0e31d9d23a0353be5201fa562e0621368b2b07dd330bfe24fe53dff418da8bd792a6d7fdc9f91ec85182a0d372cefbdf3207b321d7a548e01c37f8b588c1e6ab9dff15e1dca9aeba5b589f1d8dacda0212fc24611e96b6715e275caa003185b2c24fd5c0d3a63bc41ef75820335ecab61e71ff999c33e37c9360e08b96b9eb8fef84490bed7bf29e0c114180dbd3bc7014c1d11fb0f10c2cd210246648271646b830bf74dd981aefc7d9c2b86fd256333e1b058b3f4c944aad1eea0b8f6d2a16c583163e3880ae4d00701b78b91f6cad87eb650e3c2a18bcb2c6bb5f2e7ffd451bde1aecdc621e86ee180c4a30172a2c5b555391da543eda1b6ac397735bbe292e79856fb407bbd33970903daa374a1fc158f117f8884c7e571a509a967b087f9bb9cd860f564eebb2782e2e72489f0c1c2b704536970ad88ff436d87e977ae1dcf5180fd1cb9e6f2a28e90e5ce61202558f3bf42c438759d5dfea1cb2aca3122ff23bc2988d10cafc40c0303be9d4072e76531d2b82dfa134be18007226a2acb1f10eafbd7a3ba0179b44dbc7176cb99262a1efce25009f0abde5798f404fdb2467b5dd5b6e9933861375b8ce21dc3211812e1cf266fc6436dd4fe12d12c9a305dc500ae8453b9fb3cb14b56cb546a8dc8935c5ecd04d815e79632178f4addd6b3dd1e6d563fc81ad83162f284fb1f99a4f321958de579f6742307e64325613b61548c9a065051199eba93f7b20c6c312008816897004f70f91ef8cf046af44693a1feff468bbad2676562d5dea37dac50bbd734a74fe4e711b81a0af1874de191fe97977cacdedd67451faebeaab6c5218386bb81cf0ed161e585385d068271fb0de10b59520e23db8602877700909601b070cc0e75bd8779fbd9ee960c6f16016ebaf266787826994803f318d39936c070ade7fbe35221451150ab5399a966bcaa7a9453dfdce11516d820ef7239d35d938437df6e9e5d3d2e360fd5b8a521b0cfe82b2c20ad06168ddc325bf4b62b62c74478cea05f59c902146a3fc473cd12efd6da0f97e8de919a5a8513827b6150d94429135c86c34cf5b685605a2b556c406fc12035db0a5b9094006d8b9177545c2f1a92126d255b3fbdd23e737c76e11860237d6b5352bf17c31b494888eb7f9dfde7edddcc1ecde573421f769bfac5bd74d76c1c1826d5184a2447b1d77f30d0d24515c9a4358c07640ed05c5cd371fc2686adfa8d26977ad04b36b024c552d22dd9437a228866a085287798e90a6c3dc05bd510b0f683f3cab6ccca9e4cdae073fe1c4f8baf7b5a9375d179f16ee7dd415b43bed776728fa7575577a099ee6057158c3ef93b67350edde3cf53b26989e9fe16229b67fe194789b803465578dff09eadba2273852abe4885fa877add419253dd780239304d851f66b0164c3de1ff9bfede65be15a178339958025c8faf6714003abeb3db231e5918e1c643961c21729e8fa0467fd23615f1b357bb09b1ccd9e92cae51766f770a9c2766932186964e73f1ca7537ee9fa59f47407f49f3714488af40844fe00e799715e86ff73d97c66d107e53dec42c100d13000525403152ca97611ce2d09de78dc8a9baaceed8e4e70e4eee2ec5ec1acbf8faa25bdc507ff9339903ad6ba6117f28d2206ba82501192621c58d4b7d21c4df3097cbc66528bc29a55fd9d8bfe966f92088d06cc132ebfd2c5a9d1afdc5bb5a6a622a53caa207132a5428a10ea1c9f6a211ca68f2e61d466b62f3bffdf31fb6ddc7996ad29006709063f7fc5ba9e056a125732016ea80ce03573fcd9f8fe01ee50e1135cf7669fb6ed7177fa773e05bbc8c0203f9cc55664fa3221fd3429ae954a7ae664233a825d5636af015e90dde95b7f59aa113bb72b2bec4a8f5af2937b71c16021cf81027f92067225b68b6b69a8d230bc3fd3a29aba110292d4a5092a9c5835bcdf005805d1a1a941df78462d2e83f826b301daefe9eee087db27c7f382e733d183afce96a04f7ac2d51f03077522f80b5a10a0f568352d4463e1a0afd78b7fb8d0d41264be611a855235bacd588c90639ecb01142389accc1698af6462db302ef75a0ceee509ababe557ea633f51dd6d5cc27e3af8256c8dc90d14789cd86a9f67db81cb215b83096988f4af152c83c8e3a87d5cfda004cacbbf02eec284ee9f2f9f74a3b0ed1cdbb8c4827a7eb8e43abd2da1cb349469dd84b33242d5e21033359210e3d30af0bef71a8df79c5c8098c4563f068ab98d0430ae13b6d1eb63d672240c245f773141297dc49b0bfebdee47b863c6cf2a433667c8b77dd6dade5f2c68c0bfdde007f0dc98d93e9ebba615e843b3d9a36525ff1a6c321d76029e56025272bab907c04285b6d430d52f57d2dae306788caaa3ee492df2cca91626bc544a7685e091eb953631839aa7d9e4d5eebde9aaaa589dfa46efac9c1978f60cb2aa065a5f431f9c3636da50c09de7ea9b1dfbc0a29eef384116f374e5405b0ff12205776b648bf6933cc9d09b115db56a30d6930ed399af5f9539d067707d30ebadab0546e3154893f23d71216d7225800c2810c8ab03ae0b52b15cc1f8f962298a49f72baaed7285a917c0a103da9e9a169641a30e52cb39e747de9dc9e36132bcae78404733aaf801f1db45711d89b1196511a5affbae3bc0fb335f9bd3de891c17d89f025592f714f3aba4d4e44987112a81abed696634eccdc8213e8ce822241411db93dc4ee4f2fd50319d481a8f8a1135705ecaeb093adbf4ebe1a4d109c1ed60c9b0955a0340758bc9d3861aa7f6e96375813b5ab03949d5eb283cfc097931182ea7eb890552f572ab59bd7ec2a16a10a00118be0ba61665142041ea75cf640cc4df91ea6836630dfca039296cfad45f16243e735377d9796591a05d34a5a8bbaa3c647261ee435c7bfccfa1bee80f3d30e313bf09aea443092a8212a13bb0d502082619298b27651f74812a1167e8debbced6772ba706b98eeed3c8fd7cf7feac349d3cad94cd42a0fed99e28a2cd9d51e141d1263fbd3848385b996a236d513baeff4c4d0127617e2229932a0ca7d24bf5e8a23cabf9b69829fa980d9509c972cc8f07947e2e1616c7824b4c516b2505ed0ad614801729a2a3048da7be4a7269bc3aa32f3fbbc0f1d6a46513109ee880da00a5ff6192003bac32d907dcb8029bd6653061e8df54809b4c3dc7243bab0c66fcfdb28829ae6c719f15dfe87c291a2470818d6fc111021027d1b420bb2bf5f51b0f20e80e870015ca8889d8fb831746d3b9dea386ac5e10c2f75db15594b0233698473105de8f68b9b75d417da6c4838b9eb5f5bb7ae9d5d2d22f2303048e570f4e85cd3785d1ff35633d2976f4eb84a1bfb946656634aae05347f2808d1d94298c565abcc6c6753a7001107561558899434d2fc8c85fad993cfc93f7a729bffaec3da84464ba19aeba32b557a049ecb76adf554168afe47cd2e5c54bf7ecba022bddb3a109fca92f554ea4c98f5af9195c1b8460f1f593bfdb83d035a71af426a0c7f039ae863e63ebe04f11de097b564322669c1cab019dd61787f53113bd69311300157c6e38be4d5efc109e556509b870b58eec4d27564ae831ee733e2e7187c2e21fd7fa0def3a00c2e13c28b2223722838cc91c4a748a6ae035b176a12fb536598db7b2d6f6a6e0fdcc94515a65465e9568d0746c75c4056b8f3b28db1466e3e45307aa8a23bfb7880aaeed4f218d6950598c5ed371b15b0af7a3cbf18320749c70990c034739609b038dada0dae364e8543eef2e7ade64efecee4ee0d37d29683c5cc387246f709d21268a2640f45dd4a4ea10860492a9e7ec2e1af45a21b50670e76c01546961f573af0239b8152281290a9170be0730eeb325e00140085d323f3a5736990f6050df5cc12e524a51deeab112c84be1e92be758fb6d7a7cb7ded47d64a322eb0f821ab76008211fb8fa5819b162e21708312826e8c151df9ac189431276969ef0d84d520219dd9834dfc9b9d24cec002532a7df24cb5475cb9facbe96f02892d8b967435245eb4bf47890b0a48ea7fe5daa557fe0de32758e2878204a36b5209fe29dfbdf9f1347384c2775b7991565061cbcf18be42e7772a2610686a106790dba78ffdd57aba9df8b9e875342ddf85a57e09a7d679ffb48d877f887191e027737a62f9bbd9b71d434b27b9f41bb84b878879e3b656632f64927e766ba0df40e8e52923634f0c7288b92cc46cf9c7332ce7fe7aad9769944abd42edb036764531850a2dd31d62bcde3370a88b51645088be40a897eb322367625dc9e2c4ded39e7c2e9a7fefb72018237ccd363f2bb85d2b075cd1eb2cea3d17ed516cc2eaccd70f2273d2d90b9fc3ca4fd8705f65d98680721e4623f5eec20f0ac7a6f27d6d760967914890ec0c2342fc08e861eb2d3e4ed3ba92d1c6ec4f984c9d1577cc330fa017c447a064fb051adb57fd0d7dccc5801305c41f4a11fc11f55332e881ceb4ccc6423b3fd611d782aed12208e37272101a346ab1832fe19e4dedf6f3b4e6755e471f1013ff14f7ca4e83c96193c90dc954c64e37eebe55d4bd8c0bc82dd487c3343b4045cca0d8f6b06102b565509dc13ae601f32aed0ff54c7ffe747248fb512cd9e5469ce648c5d8acd610c0c16d3d8094599e80dadb59c39ad9abd68699c02fff539960cc36a261ddd61490cf9e399be6767acaa8e793952e48b748302c79efc46053be6de5329f7f31dc919bf844ce6a21db6a7fe188bcefaf658cc53dbfac62ad03f5f6917d05ae41f5bb420ee9ed84ecee7651e738f114ac3bba45fb85804e559acffbcef9929a5584a258f56f6b3c251982ffb8a34b0e59dfd7098fca4721d4918e1f5c56161665d81687508fb65a81aff30842e9e32daef7952847027bd85276190a7ba5f945add75a07540080f6eebef6ac020261c4f4d74909c9ad9906be331fe8f43071f62a8efa32a5f2e8fedfab3d50d03c0fb2c1774c0501592a90261dc5118db42f6729ad1bb7f99239976aee37d921c333d6630c65a65b7e58ed42461e2f45f2e23f067d274a8722df4aec574e55b3a19cb5ca7a068b9e19389c457b4fd2632e3d029c98d74b4b2b4df53d621afab5b53d795cef56296fb1cfa315c32d12d71b13a6ff4277b2e3337262145d248ab13f979acbd77159a692fd3c424762ee42fe4ca124eda920657e3c54b42e386707d5f76b67a7a0ab54519479355d58e1c70d6c8d2f7c8aff50d66af4ddfc9de609a42ecc1a18974a3233d4e4750a684823df02840ee3dff29436c70234d13826e5458d91c9021dd429f5468caf57dada04c920f9045aec5a171d07bb981c57f80afa4a23e36c9621e11d0030f31fd7613b031226b79ee556ae8520f86a6b43760f1a7d98b40c4fff25d2619a0241156a364df11b151c5e8f38e963b920bbc7cc1a4fa69113e68aace7f2527d55f330b7b92f5d620312c42d8ca087d9245fd386de4ddf160b493082ab5e02f5808f2786e333bd696651fa62a907119aa9a2b6a097065ab32e591b7d17b8eddffd4ae6f7ecb82ae4855611e590e64881c1d0d08bfff9c40fc8f3681ddbbdebbe319e485f62b456de02a17011168b4c5168986c2a2fc96ba9f9a06eb1b0cc0172e6d38d616a8b210f786a253cc6df3541a669ba9bab93e714880482e6c76908a9121a973830f060d6d4530fedc66ffe887e11686ac3f898d341bea364494228d10b7a4f715444a4f4ec682def3bf6cb533c48109b6e9a544e83505450a924acb2c5b80059657c72affa9c6bb80c29e893006a9140a7d95094ec33d29ad2e31f9eb4fd44bed0c87d24afe846c3ef045e0318b2b0f855a05cce9463a68ff1757c41bc512090a1f8b80a2aadc5744e774d541cab80ecb85f5f4b7d06cd96681a2038a8085e3514d90399f016368e8e8b61c25a7f3ce129a7ff1db301c5f296af3c973cd21b4e9c955c2e69af553e5b58288f11bf71b1f92e2cc73c536f4924b312ce40055f20774e415331391c3f449b7b7d0e7388f4c7f9a815c3bad742c4a234db8794fcf141fe598d25a72e9821925b6d83c9d49c22cbe91e18da86da0c1abac02bf21d54ef825db0b45c62fd7879e9be7e26faf3ff068016fa82220ccc8b00b24912667dfd20d9a4ed74fd7ce77226801f05c9ff6df94df44abb9ef373de04178095f5e020244999e9893d220f9425b3f0ffbd10998f8116d1703d96acfb8c959e8766d7fa55c97b7fe82f19b6472b912ab2624badc4a3213d152f1f9751c17524e7f21fd08630648b635fffaff7bf9d59a0b27f28727ec5efa5edaa129044fa65fa65a199aff2ca51a2fc4cb77f6ab594990197ae1f90172f85c4846da5f4e770c1cdc7733f46ea1107323721b16e03c7ed568a08047c54bdd0cde4603d622930a6f6b0e306eed8fa7768fd61fd55de76175b6422cd883850d686a3208a1b0f9a7c66b8d64da24a2549250ae7735b4e6b61d81a5d36afac389f35af107dc5cdcc464b083e6a317b308d87e45aae9d4c62573c02407bd70f829038aa99f45315c06e613990f4c18d3b618c5ed73e9740f2c56d386ca52377fcdf844c79bd2f654e054da2b4e90f418b774a0db47d6010aea7da183f58d9bf2a4ede478979be19efddc3f8ea74280d0c85d3bf903b24aa372f45a95977213374b29ace7b3f37f63d9e3472e53178d6e5bf5993d10a443bbdcd15097b48283d97b7bb8d3d6b2bfd186f0bc514f03029457b7058e7baec6ae9f7e9bfe7a04e5c69f943040a312199429e92a29b543a080a3745f71fd13e00042d92cde63112fc71e718b7914b1de2fa3f649c2c4af5b8a1da7f481326e86a8d100382f677072aaa2434b1b156fad609e8c345333bc802df97881ec3f3b8870ae3676f1bd5b88e2bc5f371be16076820bf00319dddf381f2791482ec5cb376044fd0c91cf3934e4f8a4f17b60cd67f7ce49b4f4c928a5431eedf3101a30dfd871260cafab63432a7b807858b7618f04d45b2071a84746c03e46da035d756a6332b68cab95c475fa489af3f9629e367392e6245a4f32019ca7286a422236374a52f9f120545c65a3f40421bc83ffd8b7266e06a0da013799aa24db04a581e3338174c600384f34f8b5ca3c6f3dad37fa95e836d4c2b00d47f7c983f92e63e9aab1c9e376cbe7313d8a1b448e1a46c480d649c0d3b5ee8d8e34ae6b81d4f366b41a662c66f43b37c36471212c3a2bb40f9e93ff71b09775d9aa90601828865476b5050aafe8ad97d5248787545d30c02c27602f50b7880ce3ca65b7b063ea7ae6852720fb8cb3d89e808dada938080101c2916cce0475d154d58d6f989755d2684046cca756026abfbb7f2e19f8ce95182243082f11bddc52b43e472244914d92e4f1f54442416a4f6753ef65a739258e52191bf5cc32942113a2c815b85bc2e8bb282485bf6abdc20ef4d510db1f91145f89d96e4b9ae25309d0768e321dae13865f87c0cc74666411a9ef870e06e81597aede8f6e452be60836fec193ffdffa460fb216321b7eae326cacbc2ee5cf2f6ce5a6f4e20eef1edac52df25bd2f0bd9ebe169ded219619dff6a37c508033818e7d0f475c087c09c49a14951b3106a2234d5b7cc82c71dcc9c7366571db7f8a7ed825b70cbea2c8ae28c1ccb3628aac17f962049a0e7d46a285f2cb05c5a8e14339d75643dfbcde4b0016eeb4ac899d3917613cc989201967b3e1b9ea7d7d8154b6bdf360d719e04d30be7986ec4075d4936addfc48c6a701460d56efad9e3c52c55dc2025e8cfb8038905d380d6a8f07f44d4e168391e20f44e9780ac13b468cdf212850b652b58c1e900fbe19e5c4b55d2d67690d76cbafe3538a10a0e981e20046765751808332b23b8350c64409d134b6d8222e24b151f5971fb6c8b47694ebd8b44f8ce5ba7fd9e7b46cde767fd18a71498552bb7e7e1d0fbe6f2389f3c7f4a69a0879f5127bff9117e2e3e37d17dac43a253f61647c540b4b5cba75411ff552e7f66cd453ab33cb6548178c9814af58ef86cabb74c130f03910f3a8891e82f01af4a2ef89449950ce473c8db0a30f68026c133b787b6c36cec28fc9cee8b65ef662735bc5494448ec6387a6a5fa469ab7808403616b3b5ee1648de66c7b1a805b133221d2b1ac0ff1b4e9e748666d3b19f917f1f9bc52f5bd6efac10dab6a53530f9d26de79d433ce179864db7ff69a9293a8e1d1aa764db7e9d02c5cf23525947bdc2247da58d1cc926fe2ddaf6f6f0457802737f9a0640d5ab667f2d99e4e7b9b2993d44b1bd9c18d054856d3d3c5a61140e5cc6bbd3fc6f6c4bee2ba43d8b3ab45db36130b56ab7bfda29bce64a9d1bdb2084d407ae6e2fee1436b966cc477bd4afc6efa43f2c33314965ad4119c6b354b564e9586fdb348ad90a9e569816afd60274b0002bca1b0c32ea8b17e0ee1f74bf6d5c773e45bbe810e2a7e4aeac1e44f71352720f74bf6f5ba2e9ef29c6de2cf1ecca1f397bc7ce2351ce61d9c4b3192b90fdc26ea77929d5beb9d5728db0b4a5afc33ecfaa1685ccd0520bf4b3052e24888a316a9120d173f69431509caf4c47c800374578d8f2ac268044973d306abb80b2674cbed2240e04f38e9f83827ab576b342b7d77244d444b0666a6e60316286f9d6e46a2e24797c47aee928b47a116a4ac1b41d8874116240056a5922164e00ff1c46d2e7563379a3a6c649daf4a0da20381c6954bafb1a3ff5dafb88b1e01779b90fcecc94adc776933eb113f8e81b3c894361125c2cfed146965cc7ed4e26ab5eb5dff0fcbeaa7003ffc6b55f5efd9f93d36753933e7f9e8709a611a85b4f83f30ea67cf52be3e1fef570a2153bfaa15ae9c165b280bcd941ec5b153d1b3a5a9623b4d07bcf5ce90cb4a6211485e29e99d4a879a3abce848c437c865347f412153c474ca068a50d7d3b72ada17479dcade1af10f79f2015d2f70882acb4c9a0c6ce75e65709dabcdc6ddc5f0f6c1f2815d9c4cf428e56603a8b39892597333ef85b3e873640d8cd7854e884e72146bf4c7d2c4e3530ee02ce147871d93ad86355ded1054b704574d16366c3e34951f97400f70ab189b5a9f32d98f037eba3a04fb0b0c5e8323235d0552f7d78aa16fb1a6cd3f7ddda44f499ed0f48c6076431c2d65b665d72e920f9f5ea6e569e8a54c8475176664d38521d2a177d1fd60bed697456e2dc82a5528d5b75466e302dc83026bf7ae6068b87bc3999ce968dc5a323078ac6086190986bb25fdd5b4a8653a136d09044a18e4443da047cd953b8ecd55db43461b9edc01c7a425c98337dbeb93eae43ce5bb17778481853e32348dd732c8793cc4592b796231ad79d305c108e342ff75c7885eb7a327d485a6658720e7321f3714669bbdceeb89bce197fca0b69ef0c987f37816adca458ef474758017e1963f30fea699fb169456697e3342209c7c803756d2264a9221da579c392608dc99cf4c8eeedb5fb80c0df8ca6014340d5cd7b48e1b49e57e76ac6f05da6d526cb50445dac98eecc093afb50b5cde022467877f03c5e0eaa88736c263878593b6c07ceb1e7ca07bdfa85c93a0fffaa6937c1dc8fc3bb0c358c816dfe434d571a0f400f22607ec8810af1b7b32fb01868e9651e7df767063aa27a9390f048df0d01cf0eadfb7204efa93194a0829ea74958dfecccb2b01929047d9a3ddba69193725e6f553d997f94cf130483ef5ae5024a12efc4da6c9fc08c27f1c81d661fcd897de92e94ac66b2ac2c75ba6996801550f32638f6889b9f14dd9b26b39411ad7e32d5ad59bb745480e97778c2c821eaa64e57e1a1e635a4e56f92d70bae615cbbee0bfe61d9611eb6aeea04bee2b6d1ff9274bc987461c81aa6ffb51adaeaf424f890653339e0689643c5193fc391f50df803889d3ece42cff930deace6daebf5c655357569cdcd0a5e5ba2caaba2bdcd5b27abf414d5fd839ed16d7dcb7992de1cbf4a5bfb4b1acccdf64aa50e8203cbc8a0592fb656eb443679e680dccf7e4a31073f1a82d3dffcafea384c626c8ca27377a92f91885a513781bdbda4b4eeecdf3d9a2f3d2d6a8d6fc3bc42d771becb4b83fe8861e7fb08749906feb8d07196383da6f5992da36c7612899fc1facb038be4653d0d880c1ff5d86d2ef55f3c06e2314a49023fcefd72c2b2dff4da6875027d02378e75d8d1528a22f724b57da3e2e9088c153f8f93c71455263d0441f7e6567fa8573cc491f29a1594f2cb17514477f05a7fa1c40cd70b76eed0d1c6ac251f0f7ab252f2622d5d742c320c85fd0aeafa083557cc7b2a80ceec7df6ebc7f72c163348dcc1fcb27d39412e754f672eef6f545aac30bfb5829c5a94be2fd077a33ae1d0d5937667e84295fcd4b4b6590834376a50a372baa685708f088a4e96455fcb66580301aa21985f3723d7ecb040e89a58ad7874b7643ba001b10ab0879d49d661062c64a3af41256a587b664abf877ada8aaaf38e9b99aef22ca795f55af0e3de5b9f76a0201be3c9ad3a5832a378ff498f0283da7f2e52f3b4abe1bd208dcea60a38344c74a87dc831ef9e13e34531fb08bc63c9b70c7b9b274568246920438be936859abbe4ce559e3cb414a57b5809949e269afd216f01ac63f28f229209d75cde0e61ba53f3ccc905f7089f59caa8f6cf6227002a0c75751457e43e470d017705952e7b82152fde165e12f232a35ecadfcfa5b45bc88f971a22544a78f71b676b8940e581f9f195d55a9e93e3d6688b0b6de512deed453a53e3e5e7e2cbd3f583df80de8be6fc36b018aaf1c2adf2d2286f9be1db554e6c2846ee87e6c7f7a5ac5677c0f1509eb696c52752ca60ed1db0733200b794001b5502a36cd523bdb991e2a61396113087d3b4d4914dc29a7188d6cc84a42c2faa22476dc84ee4fdc295aa39da5f9cf2fee2be39e3c10c94b5a83b80c50df25c6a1edb3092519385149066b4a4433446c32b96572f0ed933214141a4facd47282791c6d3e69684d548ef7b97e47704420916339fd484f7b3303d14a718d4f1033fbcaed66d6ce614ac6b94e129f77e92c77b22167937f562b46588da38ed66a624d35ec07cb5aab2f77ffd630f9b33764421d80b02ac4dfbb0892d5b0a48f3e7b5789c17f08446d3c2c90a324cebe33687bef77b863b07d5f201dc36f2e29ce6125f01261a3789089f467b45028560db0a02cc501a31b02522b2e2662182d5610539d2fa43bcd1188df0345c41bbc0e21a5b16a5aad308cf7197a4afe411a0f6529169fb31620c86af5ab2f5ecb948fd6352a925ff4e10ffea539670245beffc8cbfdf62f3440d5b6da5ee34c57a3cca5bcd9aad2ac8ebff92d287d87c338f47c91113000b44c7104f256301f52923b3ae74448bc26c92e9d93ef3d8d2764c8bf4e746ea2390d469869b47f63746698b1bd6291099e272550877b48e0f9a36e44d70ce699dd593c285215cc6642617b89af7da5963dad5b4c1626d30f6f2a0fc046d7251208ebb1176ac9077292f92a03859877af4bc571ceb7fc832547cee74f5c0798f56387604d07fde608b673885e8f7df8f711e878ebe8463191719394763b2f3b01d85944ebbcd7e04918e2bf9e6835adb2177a42a5f7908fb483fff34f68ee9adc0c2e8042871a09c7c399f30f2575b3278e9f3b389c81ee4d89441416e48f5b0d6b21d13a364a702f8f627663a22b3531b0cdef83bb97b97e9cd16b7ba4ae1ac3131e018e61702f2c182f45ae5c16a27cc8ad61de2d09f66747491aa3687117659c3281352eb1db3facf7d748e2bb99b6ede2f345c3fd82a69e841173e0c81e518d9ba4937731c3cc53246695d0f749897597848b9f78126b748c4b97a9c5b898a2169d5abf4cd3519e3b31814a7fd8e03d57ee01f20ea58d07ff4b15da71a88f67ec590ef7ace2d14fa4ddb31918cb41f01d405824ef0bc6eeba2e55fd7c79e1ada58cec17b2463fae7f78443346ff35f1e21ac9c662ea0ed10ea3645f81077c525b464585d25f5c61c2f58dfdc6a39660fdf78a15a678ccd845a9f4b5a08fe8bd213eb5245bab5c0941542a68afd697bf3c9e810e3b9156faba2e67876ade5b64cb1910c023198aaee7b5b6266aaa3dbc90991a6d727d7d3ad7ca547d9e2c3e34661aaef4bb3408af471085111c66f1324504e4f323704da125aa1282b515debfca414f5132b10fa1c5ca6cad7e6a5a4ce94832470a4f326abfb0dcf13cf5a2a5cc2cf42867562a54f31a7934dbcfc9cc031a6ce92c7055a41d807e5a2292d53a36c37cb8814fca547c5ffffd530d90723b883669f534c573be62714e522ca2d9ea22ecd6be2170a272ac18b62592c4982637402fa516b96604c9149820798141600c248706bb769c5091d6319cdb0ff124c27a52501bc38f602f0f5d10c8dfaa574c0888de1bec4d9d4d513690193c3e8e5fdf3dff783df23e5974125d7532042776571a02b431f043978770ddfec1628adf24c69366e691a77b420554615892763c6f12ff5d050de88217de112206a1aa3ac74f28053170490c9b349c650ac6c44b1a5aa3aef02f226c6fbbe7fbe0e0074f1281e77b310e3362eba2a5b6bd8ea8e99e693389697032c6a13063a8e5a1e1ed8c7c01e822c006db6b8b588b7c8681f2141a94a347b094e20901ec0243c91a9db2f64311e53ff91cffdb94c8f94502f97412dad876633a9072f6368e0feb1503eafe26fa179f1c48687ae2d903a36938d5d3c628c39462c6e076bf6a3b40c62ebea94abf9ae4e13393cd1fbadc13b2304ebf6efb147973f2f3c24179e024ef7697dc91f2d2c796b16825cd4de285c3b5d302cc5dad64bc044f13212fd102a054c992410858da5472327b5dd036819e31b9f58ec1bec957dfdc568a5efa4369cc445f745c060290e924a2ba97f4439e098f7f7c1229e95169edea521fa925494fbd00c16a07e9cf8c6fe35aac4e6e8c75ff5a03b90ed4aab1b4861c977a3ba06de5bde5b07dd26af9ba07873afdd7cc2039eb0bf75c489d3c5d579664d512a61a02b1f6d881f04e0e274798c2db2e6a476adddca6fbcf86600b5ed0c9f4a697504a8a4f3168281819878b5833c6d1824b4fc83c1cd9ed7f12950d0779759935ba41f21f2b02bf8aba55fbce457aa7856a0fccce8910169a58464b5973866055600ae3b36171612e916171d9d0e1374bbf88a7164e74b0f9b3a5385798e3c0b591668af1a9c147b6f80268d121bfcc70a3ef899cffa625731ab47a24d75afaace24742325ef8922d652e6f09bee6f065a31c4c7ba86d1c127fa3070205c4966424c30d80038c65505da98ff713f86eba35e65c02b415696d3766ab009fa2a375f0a4219a11760ed0d13c64144ccb6c487bf621bda89313680d8539e340aac38d166658713ea028e7a0e747d9a09bcc3c5fdd7987f74a7f460ace98141c2dd8d5ee0dc8bc2e65fa631d3e6f073aaf4693660daaf8891dcfcb5489887d99e3c2ca0cf27b8e09539aeb9c31c4f70b630b34c474e1f7a06015ea98928b9527b1889d115a7316574c183369baa0211ddb64c376f8117643649c4759ea07895e7ce275be70daf3b8e92024160dd73af2c95f6b014dfd720b49f9f2055a906a2369012dce7bbe372de3f5786815a63509933c2ac9e015c8bf601e6eca9d0e1946d48c299f708e46827d83a515f6549cb4291fda49dba5dd627a0c8ec7e509d7ae8cf53c1aca89d5c330440085d6ef580115a9fe98591c9e4b6415d54fefdec8f497a798e18973fa147df487e72c0638c5cdd41b7ea2b52eca9bfdbba4d5ac54393c808723ce88dc51399b0884463977357e03ba08617091584c899553021bca2d19914a656ec8febfdb1eab1ce8ef6d76354b0f40f7b97d77e804fdb735bb4f9b00394f6d2031a21c3a816737343625f86219d44eed37b93782e6fffecd98e2c36571f78590e70509d84e6695970cf1d30746f49c69d376a18a04ca03ff6ce158bf3cc0b3e85a81bb65203e2d3157ab2e4599998bade357077f9fb484608091367bcb257908233f834453ce74fecf9203e8e47c28bf323bb4fd6f5fa4bee3b2966bd3b7dffc3bebddf658435ee1188e96ca93d5a106970062d901bfad19edb4fca26d30c0e82b3e0ed0f10576e9c33e33b68cd0383eb8f83bbbdc1ecbc6507d92018a6bef46b2c1a3949c946748971047de386671219fe017f6e9651127bf56717992b319f78166200be882998d73a102e8988c6c7c6e777b09d8c3bd2ab3242d7e6262ad46f67511711126989357e362863a4f5e3265b3d2ca3b77362b1c83ebb57622c1946d346d241ddc4403a7a2d826d69e4a2471e9dcd8cf0fea76c97b7205e82c54565025faa0629f4ab2b22a4028334d29a02439db918cde489c5088c2b9167fd99621561658cd3617eff128c727e539b4e9b909ddc97d9da62a66d540547397e2cbf32b65b4f5b31469ebab94374b0b4a5deb51cd68d70f1c362a88c2be89fc3e35c7f39979573642d26602133d6eb1ec3c90f156b04ad8de8b9e8c27cd60920af22528ae098afc65e66660dfed00024264a165062afe24a616ca42bb37c4a9674eb82db5915c0f7c0cef06df351f1f47d0962ccab0c1e40cc77771a00b44e1e739dc5a33660651af1e43fc84a10a16f7bca0fb5f78386d468b722e2b18609b9ca91ee273408da2da9c8f8d1e649d2eab493a8f946f9bec6b4a1de22637e472fd8d2e2f5a4d23c5e29aacbffda44bc88f12979bf8e723aba3ec04f44c0b10a06fd169526d9b59e150791983cc3bf0279a3fa6b775cb2ac52c91bce114e4a5fa0c23b2e48267a1f32f610081811d93ded6327abb9d77dbe44586be48e3518768a9929f25d75b18aa42a4886957d39db9e6156f1233ae92c585d431ce257adda98d6425b8f77081172fead7f7cc5dfb74ecb34f69c794f747ced3f2e81b744d5a7825f5a175bd16b1cb2743f4ed3b69b5b8dfa1a8eda0f72ecc3acc3c84db9a35cccba0dc3cf8d07eb6bc09cdf4cd3be89b0d321df32256d41eb8bce49487250b88a55f22b6faeded1f1bdfac577167966c39d45ded6a1f4a574c5ba8032f0c3ee0110c1b8d9a2cf98fb5e2e2c2f458cc897b9e59204e0bff39bb39ee0ff799688fe10b9b45a235e17cb85dfaa03c6f1b5fddfac555b7364753ad9f573680de8562cec50bf70898eb7306e0eafbe8890db93d082cb8579482218d2bfc53f7f95cc41cf20eaea20710151d4d35088ccdd281dcd64d9c7c2d169f66e18a994a5e6510212882b4cb159123bd6dabff2e3d405914a2c9143c91ced50a85370afae6bbdf0b5f60290c8959a955eeb8c76f180a5e5c4ea1e6d5a6442d8ec29c52632f56258e67034f61aea72fc5a509a4ac85906192ac935d4bfa9e08c2ee1445282ca1fbe21eac5fe72b30f8514c16f23974c91b26202c78c8f43e76a2c24d0b9637aa4daf5691f3cccab56b13ba97fa86e819b25a055f38b449dd96457bcc819a9fe9c3289267c8d041d3564fffc4ca2503e8d473c0216f702e821aa8e7d7b753f1277122b63967c869a58fce5b96d7a6b71a912452eadef52703088cbe2f78f463dd061b934b665a1ba21e712d87c01498f09de1eef455adbf6fe1c88001eb724a46a51bdcadd2b061e16462a4aa7e8cc3ea9bf1bd3a593b4329946181aad4794dca38ac5a7e19f773996fa3ac48a8dacd6a89cf8dbb85b250eea1961958014dec148198dd07a1b373934258ec6a6a26b523660d8b402415e1709402f1876d9ad2f915f77b325e6787e797edaa86182df8ff2dab7e08da5dec6d0ecaab90097549f36639d278c33f7b0107916dcc3a61e20a7ae512f1ed51e55942ed59743237efa7cf1d40c4596d68ff1722ebaab518ac5b2d1818f5592f3d0ae537a42002f3ccd2ead7c3b6ddec1be711c8c6e99ba578f44df9b28b543de6029d454f588c855ca091122e3b1f1707a2d9f32e80857360626ec162a3fabeafcf5316b855b4ef75d82831e50be9c54f59b337a169fd1f2257ce593967258cfb9870069945fefde9e49d5f619681c539e5fa8129ec3d20c602e05afa7a8e79a59e44f6828b93341be59f980593633acb05321651befeff133125fb814ae072eca22d57acde37ddc42a131e6e23e7878f8815d9115aaafb79b100013c09846aae293a0e52378c159ba745cb1313fca53807bd80186e3169cc1877a121816bb46fef77ef41db3006144a0a5ed0228f80d5be396eb384f53359c504425fc848ca7844c947986f2fe973b90607a0c6efded04e5260398834e25ac84790f2ffc0705639d6d351af8a2c14af7468e258a6e10f8f36f52311a9386a92f21fc3dcd8d6880f15d3327827501dd76a10a9ee6937be48168f40211702a268f50dd5aa9ddb743652b347f3c94c9b42c9aa660980ef65db1f67b011f3c58b097aa929362f51473870caae0691089e2fa9bb685a764cda47f59bb52fdce39ef4252cf45c6c10df458d971dd96cf8c4cabb5eb35c401ba457ea23dc0ba3f252e46d50e5cbff6e6126477a69c475df83e3c198458625dfd4ad134c3ff9a5f5380deb8aca23b1c888a82d2b7b6dbc76663381d25a3974fc54d36d1541154ac1e087eb4b89fb119021a34a8ce86d020650766a7bdb4888a996ecf36af760f2f39c5a9d8dfd70838fc436a2629af7fbd002dfbf798191d0ae77189771d1346924c8acd8d9fd123b61e531ec6369101a91fa535fe0250bb1197e80d61583055f1bd83b27339326d7b22d08139dea6ea929d7485b04668a5ba045cbe1483a778285f363e124501db16f137ef16718c8806ba98076d14575b5806da8f43c47df413873efbed42dc59d0e78b25c256b3f08f597351a4385dbef03fd0113d080fbe0e9e41515524c1b6612eecdc3d404f6c6a307aa5c2ac48211461ee595c725b8617213e20c47fd2c703654ff617604de41a96b3c87c0201ead2061b332551ca9c1563330826faa91930ff2394","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
