<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ec1e25be653fd3bfb06409d7c2350787a93c56e05f6ba0866beca41492e1ba5d0a5a1862fc3c26dac3df00531732e4bcc9a9d3f742042dfbd0c3489f1b1aecc18486a5c96c1ce48fc07d54fec932d3dbb662c4b2f95962f82aa2fc7a3bf82820cf9e12e4af64f24f30825b2a69ef41d0bd30d5ccdd2de9651b83169fadd6041483c10c1e71db7834625849375a9215fe20169c94cff3d6bf824545de42dd007ea090723f3d288650f9d8b1f0facab3346959f3abcba80240dcc3432dbad126c2c4f1a69e54e3db4ad97b9130aa0aa26323f342efa649a8a202bea1e4b698746b9a9ae685d14195b94db0e070b495acf5fe1c84c4268232ec5da3fde1cf9628a40e29bb6afc3a0420f9963a1edc7028d72c53f652304993e87eaa1120ec548490930949321597d375020c80cd1ece15b094ae5608c577e4e51bdabc601ab3c66191a035c0e02e95f94e7c0951848791085b605ba1b97ec75c76a4aa49afb0e3da0042c73e366c9ff09b9cd8e3d601c4eebcadb15dcb1349a50f09a92441c07264d1e33b66841c2a024a0e054c2f0f7c00b58a229756ddd43ee2e40b0307d0c2827320dcdcb927cedeb786ff8a37ec831a142670599b2f3496260b4e8baf2b8e3c57ee87147e327001cf90179a5a46169b526fe009562f9b71e5f0fdd5f58aac4020f814617f8336623c9e55abea9f8f1119fb0ce1ce20fd459aec6f6220c411786e2e90c55f6d3da8db229cfb32797711aafada74c1e4eb5770da116e7e5bafd846365972a800a560f462e43c003cbcd115946d6e185968a5704e262293216ad102f89e14687b6b5410234d0499ec54780d606a7e5710bd861e05826e6fc59650bfffa32c7053a53288edad51c329e8bc314a116705b98302623d3a61cb73164cd0859768f52d2492474ac9f542836db89d38447e733e495bf9d9a393785c264ad49059c31c046bf06013c8db746a8a44e53258c7c6e98b4e18e75a46cc3be03c066abde0b76ba109083607b71ea81414312a6f3299de7597759c443f054b31bad62e9458c6a1679f1c4b975fb343bad9b684e64e37701f2be940a437d8b9c3c7d48b0e81bdb44ad3c354141b6dd1b5151ebba35ca00d558f78494405901dff91ff210ffcf6cc5e9006ba6bd215ea4d042e1016131dbcb7438e701ccfc7017a85ec0d5abe30f45be42628b6ed0a05f3dc0b0c3e9bd95af1c1942f21ccef06fb80f27ff21f5ef415d98f7993117434a597ff380b1a5eb51d7f225728912db2774a14cbd8a85711596e74b1ac12aea3e5ffbfc16e2bd695d0c5eda36d1f8a25a252cc4843d1692faeaebd72cafed074ec54a6d6cb502e2d2d6de73acc63f9b9c718de0e1ef468a77b3aaf7e4395d61355e26cafb62a3688f831214eb4f25d2998fb2e742258370b0c5212251b910d2919ab07a3f5158df62261f102e7b59752f1661243b61ab8c6b881ca5e813ad0b99854b89501ecc46499968e6433f4474a7d21cb4631ba637f048b02ebd4c4fd875246abfaa406bde85eb6a2b7d566fbd10a008b07e91d02242aebb8128153c212bade269a7c02c5234a342c50b697e7865be87b515948d5f9efc824457e98ed791c671df1749a7205becd7bf8982e048c0dede4f6b5e54da7142a151c81db2e7f970dfbccecab1a80814042d8377dc3b6dc830b1f07096da6b65d6891a26bc433d87a7bf3ce62f0ff0c8a36012e093813cbbfabb1abeae492403c95ae444ce89738bc701ae25f267ed88ce6e3215a159c15c9b3945b09bb98df1691ddf49eca05713f036058aaabe00f644e01e561806a9897622132dded52436d86636c6f265175f79a20299585d311a50a74dbeb22cb017ea97e779a4064d411963d864692745a3dc40dde5d4a0001f1ffc27db5159c03d8d524c5cf80f77f53b8182a3c6c5b23cdeac88fc88047d4e90bb3030ae0af64c288988073df64a23b0ea3ca237ae83db09bfea99bc77ea4fa18840d3d83ff011c6d881da7ef1b0c7eec1e453f338609f56dd90ee6e58513f13ba0ec77c134d7d7b7cbf0c354a4c6459fe4f322048307f4a2166ace558fe7850319b6e1aa096963ca7ed7ad056d600d1ef322b6ee0b3fe000d161c116c0f83966c519af0e23286f3e8925eedee02b5eb3bf13643f869fdc27d39c032af43ef8d25674f04e13859f61092edee27c2517e3a145e4ed5c02bd8b57156122185e68a882296d841f2b815a273a4a9bef0281fc3bb594b28b56c88ab5e4c66affecab993158f3d8bbc958469457fd317421e4509a5705c15e35da7213d33547d5b5a6592e85196d6cd6808b2fa4c27e505a262c668f018a1ab47744bde432ab7733c6f96ddcad30ae7dddcee6ff3721e67330c4073bedccb5027caab5f8e9840b7fdaea28f55f336e0c0db6b37fd445c55ff88039b81ccdd0488985335e5af476c1563b01588744ac68706a61fb1a4233380cafa1aabdcba4db3f2a3cfdfbaff19b12da38d58a41fefa43cee038badabc4c2541702870229c9d3d40d04ba2d6c6feb13235267620d5581363076afa07bfdbd54806b06123af293049f63f1224d6612999cced7ecb07aba0350d160259fc929d15b7660b4435aa21392be85193149d9c2b19e193a64ca074856e0f6b9d95a06542a5a5fbf3d807aed26b30aec16fc8d335085711328d27b8611c0af854f0cb81b1b7218b1b2fd90b73a44b8d2fa5c8ad7f2bf301910188f7ad1af6c57cba1e5ecfae13317829d7947603431c97e9b94176ea9ccdcda6f7b8ab5c219dce8bf6b688cde70adc3ba7a6a8a92f6a8d65a39be7aad8b2f76459c71b1bf28d9a6ef524257b033e55da38eb3a578d1335eb155100fdd2ffc7abd71b80b1c14cc3aafb92300b2be249a301f1dfba6c1e5418ecbeda72541e9375d6870546d8140b6e860e7cca7b80ffe8c731c1b8722ac74bdec5d1803ea1c67296252ba94a327068600264669c807ba1f591e23fefdae864faeef29e0b6373b6a53a5a4eb634f47f45c0e830b80caa560e645aa5f0c72e806d1cfbb74f808b8e655c373d8085a4ac30913b62d29e974a8e95924fc9b117c2e2701971d0ee44714b3e1dcc3a24e9b251e6f767ceccd3bc352dc999cc88978a21360f6ad956ec585979ef247b0acb99d887263e3f2ac8713019d81038217b6e7a0c340da239a806f9462439b9c579ff3f9eea7f223ec12b9ac9b81016ecc8bbb473739a59c9c8e0106f691ecebd0dec95fd1f11dfd9a60a0a2972c8b784f0447667f2f0025914619491d9b203871ecbf9002c739b26477b7c174e0f48f0b0abe463b020bba1b0122ab60ba25606795c39f92c6248c05ab8029b5e6a16e3892736fa4a765d933f8ac0ceb5bae0f76a7e25e660a039e9030212c4d3a407dbf8e4c2ec2ce8f7f0f66506e6d58158f362e1d3f01fd4f289294f112a8fbcd09dce3c01d53bac7d03106751f723b09234f27f12edec760e3e474dcfbbb6b78d19f0f0c589be8de5ad79b98014b6fb683125d5d2ede998ffc3032e0fa823004deaeea9d581a38ee85773f1bb6ecae86adbd640cffe917ea37c84db6b5fbfa63d5ee070b4db6b1620e3fc193ef70954f338c548f48f5722b9bb618309a172f13f189df2d9a124a2c79966970d548f0360e811f0cd910ebbf2bc7645b9995a29fcaeafa6da7af834b87d228d365a29724ef4c73e076ce03a98d9677fe92417460f5b9236728e4c09b2af9b18385726f78e466439c95fcf77e9c1cd04073e44c9d85dd8f916595da635e4c61408192785678bbecc7f4314f2e3abe45fe619417545e99e164db0dc491cce3c6489f0793c9291d8ef333fa1eb7f98aa117c757c9b58c44d3182974a3b057d137643687dab3af264a332be0cf985ccb88680ebceee71f6ae75cb7a5e714db2a42d49a6522e19c2ccea7e7af71fd92b7825468760123d20b41b89e61fea178ce0504c8e5f0b8cc8ffff2f6ca480146073639db77e330c6804fafac06d8a98ed8551f49f4b34ebcd4b1e199407a66cc2f19f54d53ae5d1bef1c9193dd936a3ede2a0411dbb6363851ff0b36b958f0866f0d1e82dd25a921028fcfcc5da92f23a01cde425e036bb75f0db4092d5744905fabf7507363d047a22cedf5581c30669a0d47d0511d6f4a3766c27fcdaa69a73b78c993b8498ed227ee3d0b66a9f205a13cd3e6cd9c6cb0d51eee5e2ce2c8f4f5ecf18b60c4bfaa5519ce894284162fe81c86b3e596d5440ac48cb251d8b66e3d91f206552f2c2507307ccfdf350d761c00928571a7580700e0c2a89feeb0ffb24a508c7e2578a1d4130db99d520b40fa8d04ed1b92d7d18ea7516288fe4e3f84f0219dea083d575f7f7a50587ba451b28d595b9b0dd4c9f28d90a79ac6712f72c804ffae45a151435808fd9737a7e2c5f9d3edf45eb170ca3800928ab373b2119069bed08e2c0f146b9de64613ca851cf0d205204d4e80d2ceb5d3f727f14682d31eefcd0c719e3a355af0994a06c1a42973d6ee5fb7a3e6d80a525633d55490febac0dfc902afb76acb03a6b56ba376206d3e410d5b795d6e0f7cf96a6933fbdad9543ce37ea8545cf3043548ad701b6ee464d03ea5fb94f4b362d8f859afaac56f0cfead0825f62f1d2e25a4e8ac9f50b10068fd1826f5ecc2380dc6e11cdf1ddd3db017cfa80b844c11e5a0739e71e5887b2742a7c21e4e8c700332ee761f4eb5bc242bc24e5906104a9aaa940d4e659b644b16fcf066dbf9dd353998eeb60b2c2b459f13a0e8ac2e52ffa4c966a938ded8d4d6dd5c6f7238e8692ca18419531e798ec0672c1d5c164f6853ade8871687725f2cd037074fbdb3352f40fa96768417ec00b31e5fb38ef23dfb5f4d9f852db713290c0aa9ba444e5015de643c5c93c49e15de4521edca756fc23e677c675cba644858f8d155820736456fe599d121a5a0e83ad8282ac488097f5b3c88e7ef7dc54c14b29793fe6362ae78d490ab716e79b9290ed5d0f5ee2425ba0c7d0157b383bca8aa7985baaa392c08615530efbb9453bd22fd4bb9f034793482e4251dc997da9c677e3dcd7ae6c269834a96b1791a451e45932709cba18e74195fefaa572cf8acbdeac9c4f4d03c3ef7b9159555a017c91d61e386330ecb6092db3692d73b25b8ac35fa135d06235650b0aa50ff0ea8ac99e07c9b172b5b4ed452eefc1bb2aa20e8c72e05cf746cc53437b15ea0e86538bca01124fa3c0501a0b8c63529a10ffa7cc557c7dea80c94b3dde5e572ab0af60df15e1197c9266107a7f516d4d1bf0812d021daeb2cbe5a4e19b955828c9e6d58b001572afd98493489e6002b7df189fcc629740712c623f505fd2e7dfe736c9dd3bb2f5a65650ecbc6e52267579cbbb309946b6b88e42f36e7ae0727c27506983ff9bc07b97f17acbb68b33d5a4ba19925948895981517397d1ee6a64c3fe67d58edb2929f86a11bd7fe47df99685c5448e7f36cbc482b40045e32e156a8ccdbd2e0ac036eaf4b97a29c74413ca64e4f4508850e73e02af37eeb927279a5afe6ed8f09f016f5212b7e764beeda34db306e3e83450976a9eaf349edcc5bf576bf579af16bc016609faa8dc6737a518ea11437934ee3361d47eac10f6a633354f6a9a084f9a3ebda2f5fe42e806cd6554aedf5627a4004c1b9fa5a7ad42eb2e4ad07262be18240e62c889ecb4d905d158ee3413b2b2d9416cd3a2301148d87632371384886d56947542d0b2990335605804db8838eabc4cefaebbe965f9ad7952c879128b657ea166d42cd55f350bfda70b2c495fb092afd322528d0a437f37d1e32435d5ab4e0132ad1445c59ec39eb985b23d8264ab350d2687fdff09554e86f025e2db93153217be5ae06df04f89e8242fe3bb047480167c191a00f7c14786215964b0c511bc13399558fab3c669d97d0ebf44de181b884e70e7322ead0cd561076a429b3e57863b56cdc0445485190e3e9d7c57de6b77ea29de45ad1f8e5e9c06c5ab245e7381c36b79ec8e9dcd669cb0c000aae9e99baf3b2f9d4699a9013d9ac06fd9242323dcc5654efaa68d3bf1f4a999d31be776cdcfe512b260e2b4f676eeea20689b29f4e80f49ed3718275b775c4fdc520854bf98d017b326c809b4acf76227cd28f55b8364831482ec9378e0e7b28b5c3561ad7b8db2e6cffee7bf7bbc0f67e8a8bf35bb341ecdd098fa7af05d4b2ba6e13fd3a2a2dc9a4fefdb1fb70023faaa33ebdf4a70ef58709e1d11c86c11d66185052e58dfbe88ae80336c2ef332db079632bf40bba920411bc791275200c6dccca5c9e21bbe9a09111a28d48268fa203f57c3278e87c9ac924108a6de295b0316f0579213fbcbd64abb051544aa2ead56e6c5f6d99fe3ca1762cbc07e1dfe02d6cd2ac888ce01ce0f81795955a65a840420def85b2806c292298b00bd1bedcdbf28e197aeaf0eecfc9c8bcb7ba7eb09d4a8da3325a850f9d6db8ed59b196dee68df029f28273632beb4a24cb1312ff498406c49fda771e939ce9d1867b5afa3ec77da43efafecbe1515d14b0c03c522a580ab1da3c7c5f7b30d1fded88683f33fa41c39ba6fe8a129c409931695f8cf1b9d980bad751002eb14b7dd60892d75e6ec76862c5af28fac35a1505e0cfe0f2ded2a093ac61e1e843ce576e02cd3e65f4e98267044139adb9f7298dfb2c2844df863fe4d90a01f5d04b1c1b36f85389814ae9920a52ef892419124698af36936e60a7baf42e8f68fb67a5d2ae9f0edb24470e669908bbf21d78095df7a6926c33a1f519b51c6bd26aec5e6bcbe912d774e6a329ea715b6877f60492758d06e95761f78416e9a94f5ec181f8f2543fcf2fca5868ec66cb4b1ce56dc51122955e8175066b18025d67b6fb58e8995195087a09b4ed8ae18e737758f6f45b92028b3dc2db2f6b5c61ece35d6c885fbdbcfadf1acdc65e9a6bdaff6825faa9c56a5a54564e4c5a0f31989c0519934c203a82391c511ca7d3e49ebcc2b55c0fdbd91fe4617e3eb061a89ef8e7514512a5bd132795ab42401807361f27c50e5688533438a15da02c26eba14e8f451816aa96019748dc1c64f8fd06ec64525d0b5d1d82bffd80e02b0903a6c287f56746530ee91298cb2a4c0b7871ea4ab95999381def5998266effd650cba5836e841310272094df7af649521d4e52731eb6b86866852091b0dc02e4ec68fc236c5a9a5d464b251a9da017e8cfb7a652cc7c89e255277ec4bc6cee2dac952f6e2d01462e0e401e3ab10314e064f976bbb93cde99f9e043749c9fa52f17afbc67e8f35a2d43fb11806ba52e34c8b02f35eded9e1dae5479a0e82e4bb66f57c7c210865f4540a365b586dde5b5d95e8b67ed0a1b8f321854777c3ed37663b6887515cfaa8fd6f8b4f699b068d1916a6ee23627fc9869d794fc89643d6ccd64b08f84a9d04ea37b0c8becc3de117e33e46a7ac9dabc8bb4017efaaaa3477c935e6bb931e3c919136ddb45012e96f1046eb2f38570a09d10e8e66a0ce2f3a334456366889ec2f73b0ba037d2ff4fb865e5c2fdc22e02a1b5258154f1d323a26e431015dc5196799311fd4354ef2f2906170e547f3758702ba28e6a82d2d05710096c9bbd62729710488f8724dd3a84e5ebfc50f187b1ae6ee00ef660a6261c5ca6b736579999d57cdcc104baa9d1c3ad9ecb80b2c505aab12fb246c36159d0938716e46239b5908a680a1cf70c6f0844ba5c91d527c5d2246a8b7a57c7f39d7738ea550857db49e4ac35a42638b9d991b600b78bc4de0fb8e993a72c9c5dc9363e344a9f0d2b343d2321c12371d82f0f6333d5fc9d58bed0771ead94ee02e74f955aba7019c8fb5f079a68c5cebaf72c15a67282e780fea812f1f2bce4bedd0053fc018cb4dc2859afc13ae37cccf2e3e1e480d675713abd476802bcc4092efb13b1bb5610c17669538789980da6b387acbf39712d5d2e6ff0810f4418c4c54f6e7fd4280f47ec12f41ea414d77ca433138aa369a6cfc49876033a2916c049b8b21545df62fec8dfdcbf5c1cd9ec9020a815be9f16fe8fa7646de53448cf790c6719197a3f4fe02a21f98271ce60b76f36f05acbbafba68b24701f252079e9585ad08965aa7180aae5e33751a80c21f3379ec1a86b6fe195207e8b7fd8e229be17a0212d1e0ef8675e6a5d7466c5688a8e31aa48890a7b9b068e4968a566e27ee90b7fb4fb206275c799789afdf975362eea71967e4cd3ffa485028c9a4c2e66e3690f734fab26d835c7bfcb0999fcd2d011f30644871e2fc26e3fff5ffe704da5e593c7e93fbd346ab372f58660b4d784f2249294bfecea18f4d8fe8d8aba6710fb547ba521a77d997dcfc7b76829dc6c5fedacd7bbf15471aee4449161d5a03567232d7c29afc8ab52b27e0cb52c32f1699d28ced70f9023dd2b705b1d6238d2cd3f1fd667ff30c1ba5e565292fb21f6f578e484bdb8610b361da73e6da32c2fb01ec098b9c30d22bb1ce016074c1eaceafe8a9932814fb6324f9b0fadd1ea2e7a7b741f4cc12215b3686b922f672f2742f7f01b65fdb40d36a6aa65a9663216891de6af59725c2f8e2f32db4a99f8ea39bfaba493538d084152a10e8f898f5149be76254d7bce61d064a0524c177b51784e72c0712feea2f028e4ee26a3801aaad0965943ca3da9516112ff28fb360038c0af8c7f5677dea0746107cd441ba9eafc1a9e4118b496f59c680fee9d5b62a71408cdcf24e72acead7410a1dde74c30bdc285d124b3dc06e44a9bc7232b13e58fa892d78a447a135131d97ced0bbeae35839a322266c10fa33dd1ccbb2c727bd59f0dee302b6d856d704dc3d926c6ba035390d64bc63ba1608aa66303cff32a614d937b89c338533e18948081658b3ec801b137aeadeec3c0a5f88fbf5a8b4d284d79a930339d7b1a0fb8617e83ab1fc8e4e679c159c08f0a61941af8370488f6232152e6a5c94fa73c6f181361cc702811f4dba82d738ea7dd53c4baa42a76d05b53456503c14faa08b6258a65391669e1b3bcbfa472e2e55d9d967efca885be9591c4a9ebf73d3feb3b28a90afbe851a789a7578d9f79da69aa00ae9d8a20de7b5d6f148a7678a6e54f463b8df72ed113c561698298bc911357d70c8e2f1cd23b2db199abddf60c96392b2d05204831a2668aec987bd52f6cc520130b3e8bddc3f65633006a34050ea848a19c8169360d81628f79d358b8edab8551196486d0fcb1b7e25b55227ca36a2c7548c5c2b59955b9d2d2fc9588131cdf33a196e380c6675cc58481cf917a5d0b213c0666cd1a22bb41d4c649516bcc4cef36b98fe751363ecb6126d123b48c0f5cf0a8190ed172d2acfb85684247429bc06a330e50921f21dd13eb2a7f8c63e76ebe2a69a167d5556c2b40f177d9987fccde5357d18bd8dda391853819586912c6c6ee44d4a1914ffd268c326fe7b7ed1a67114bfc1982fee3d1f7831f76f135762a89179ba80d707174bc3cdf91b31f62d46212cc8ff083a6936b6a0d9d52c8c87555c8cee077c71f8368fea97e2a71d8ea5ec08fdbc46519534349d7faeeaccf93053a560484d70a6137c3662738c517467f9b466534e5b121526a3e44cb66d0909f46c48a9e86c338755415ac1ac75acbcb4427768632d4e532519b218392c94551c2ccd852348fe1b7fcad0624942b03945cdd08142f8db0c2bc4003032b00026360140e76dd5bd971a9701f4da3b73ab85c0b17231a6dd12cdc1c0581c241786ac43541ad219a815f7973bacbc22b6e0028f0ddbc3adf4f8f03ff6a3857c7f7f2d0061e45e6023e6f1787c5b9f5f6aa7ed82cf4e2125579c2b512d3e26652f011e40aaddcf3b0179548c7b9fc3594edef407efdc42fa5a8e048e6310fca02358d8ab47cf7bbd5d01ee456dee72328941d46b068cbcb163c60963e3769a25652a93c91eef6fff1307b2bfa26687bbf09fc6b297f8b54291085b61265cab911b70cc0e64250dc4e657d6336e626fa8b117c2608b5a8730ba47479cec04512b68ff3cae1f2f097ec486bae8140b3ac88e3d9abe3072c0a1bc529e5c08e78b3d2890e42061d32464f83bba80140d76c46320c24d1c455e224b709adbde74bb93da987cf7b90e6cc895abe3b58eec31eb92bb825b5b4cccc4af5ef5c8fca4094b96cd2d5b72dd5d14220e530a4f9f8709809ec2244e7295eef062c7bc36c171302d994b09ac4c102957845242f8257617653a4cf65e87408597c78f6fb3e419e917b27c8e511b78f3eac6b5956c7261b46d7cc622a88f7dd8f385a24d3497186be27228058004083b999b418632d7a4bef37cc25d422903b10c80aa37103ed39536b12576f81f5defc47e4eab7854411169e7b29755a58c75a4597a257fff1f646b09cda7d38d680463e944a1eee551b4b382516565b195c160f2f135c88aaf09fd97997f2e6514c6bedb3dc04448d3b6e8475cb118d625062b021134ced1c7443733b15e31fcc0ea42ac85a7fba5a4153af703c0176337ffede03c5c7c5f268c40b4a6e0102e24fcbfc7463eb2182b64b636fcd36d2915de30463889fced5d46b972f091023cfbdee6f168d3c47140520eff5647b34dae4d56dc95782becc98b5df3807af1f077d5a876b0f125c2a0953217a7377f75d74404e44960c39ac0b48a019681144e440b55f4e23bc578487ddc5621dc9c01edac26bcbf03c57241625b5bdbb01145798aa0da11fb19070fea84c3bb56f8e303b54f72e26cd5870d45d2aa7f38c23aab575402058fd9060d22e370da670c8f904896c2c518f65267af71f89db802f3bc3979322caeb68d95997e77a8fbdfa65e8ac2ad7ceb6cfdd0792c726ef345e938f398a3cbe3ee0f618a4da6794251f413b32a213bc40157271163cdce48b116c353b27824bf80e84a595ed58332d57f07076056a5e7181be274159c9814f314f5d35edc6db040704ad33f7ff30296464618833a25d238abdd9fef55d1d6f3af2b7519687d5bd468604cc9f95c9f07ac1601bbedf957a9d4152b1ea262c07349d74cdd9cc13ce563b4944b9de43d29d0221f85dda5beda96248013b0842fb47dd0c2bdf1035b04cc7ff03fe0b6e1962756ec159c34efbce12701877a639544db9b0430ef0498ee327f7292dd5fe6ba8784a4c41c15b68c3277facf0443bf0275e2db5501cabc16e0fdf26909d3f952a55ed052fb1f0c0e22044aa03b00fa8bf3ebd103ce87ac009bc66531a230d495229d7979f7f83cca78f91e7f3eaab4b69c6aae7e78072a8afe0ce2c0a365e3be4ce362cb2c78ca272dc7b5462e7e6ae5b30f3a516db75b409351b1d8b7c0efb78b55aa1a8a58d0c01ce07624c3973f7b816eeff6dafdc46a7031dfd6c30ad42f4044aefa22f195c75a3a68daa8012c64c91bc213f77b188217f3f4a5f36dd45d3c4ff7f03f8e9608c1070f66bb51520d59374400028a4e3ef405d8b377dc11a45b6dae6f09b237835afff69bc3e88f2f617798bd7e076888008730c30f88cb671ae42c4ea8411b4d71712833cc2a5eb4f07f0a0b03970c53ce373a692aad3a4add9933d3bca109beb3300381d3d448dd1aded374a639a98418027557d23ec41a5677d6b172bc1a336e35c7bf97956cb544b209d4ba5e92a6e9a41114e5d21bd3a2de9152ebc91c2a1085491cf8c6b12adf7299aae4ae25911a00a3319c878198bdac0f16f480f6946a896983b89d88425e75b7cb01b50fe06dfe1d17d3e45f78d431651e23379e180797af92a6a6f7c10a3f906c6c5405483b15028d9f13ab5ad3ca9fcec021017cc2a8c7f5ff5d7cafb560cc41e6df45e6579300726067f776f8b662fe87f088fab86ef08508eeb3d46c069e6c1832c8108dcd156e4e39edf64d71c75bc7b9fc2d24902ffa2e903742d8b8ebc0d73fdc69767e4e83a6f711293b16e7406e33ae6dc2c76fe46bebef3530b70b01697b8da374c4a7ee06ce9af63e2670141266017a53e9b844e6fe7cea6c31dacb4479b8af80b5ad32757898d70d0f1b7985389b1fa5d6f192c866dcc277756f09dc7d398769642a954b67fd476c56ad54c41082d78a745a35e7108d021a767c8b73ac342f8be696b3ec984c655d1c1d0868893993dcd36d99abdc8bf2d0913c7ba80b8320d188461e99e9231881d784a4937a5f04d19d3b78f4259a0bfce8a3fc1ba0a1d7a6ea8429c6487e1c378179a2d0508ea43c2de29b19ef578169aab0309c337a418d7671188fbf0fbad2909ee3be33074922fb66fa16b0580f872d738c9c8525a1076fac8d5a4e41eac017036b7b9ae9ee8e1dd0223b36f95719ef9f4a217e25dd392520e72850f9236703a78e2a1c888503b77847330ccac2bf3dfa0c922b76125d6c39f3022839b67c55a0f274b603ed648673b2c3445ff67584d9251297810acdaf69c7a79e4b3e219546264c43bec8935d85efee944c9091f65aab639dd432a9e7868c120f7b5a2d9a1dbe4bae0a7195e951a273ed8daab4d675985559b0e8c2abb1a7c7746745a97f282ff79b2ede89098229800d954d5cfcb84c27cf793b94b0e0e86911b2ee4806e018b10e9c3bdd7d121fe01a60604ba775f33a477a0cc7bf35505cb612691d2349b27a66b6daf670b9b6d8075148e3a00601f3f6c6877228dec505a42768f7d4f4ae490db1887c2d8fa91aa288e03b2443ad57303f89a4cf1638815a459ef17d0a67835b0d1c7685386a86599b67cadb12b133c64fbde4a9195543cff8db5ee9972f0261ffe568b1277818d6314705e663b08b5613df4809942840aa4ca63bdf2b7296b58271161de3003ec66eea8ff63c2d3200db611c284d590508f3a5b9a2739ca2975e39a2b88103b398644cb5f1ac5275a02a8c7372d013a3f6cde382788cdd9c4ecd415fc0a6ce39163d877a461afb6aaaf40b0f4b4777be8d0822b4d203158e24afeea7e050862a5082a1ed1cfa1aad3629637febee9993896d92cf90c65315b86575c9320d9df188bcdebe0827d26252396bf9e41e499d69ad862b500cad4edc2c571f28f39d72408368c78574b084a793cf14170bec44569ba34d0aedec4f2ec738e96491d80e1529848dd5d4344fbf687154a5aa6a4274a902eedf054ce2a3124bdd1d8e59a0c4ae91d1df922bfa1cd55b9cc6695494967e97810d9be7de3b771f16e71cda3ece8c497f35796a0fba2f9d389bd3a7317e1fb874834ef760b8f9a3dc10d9841e1820b4375ac2e44e2a3dc6ec2e7f3f18335fc5586eee346f509ba2c2de54365163fa868e3f9de423dbc57a9a844059a5fcc3be867c92aaac4f6f78f4aa3b5285db989e256bbb0e1a7d87a9d09d6acd1ac51ea49d9d5db425dfde298759feb081b3c22d4adacf84cba70ca5a3600cfc5735b1861649dc3dd960d181a1978af92454073a327a6eac9559ae8f7c6a9886a6f05d0310eb028a58ad558f00983f7bb9dda8580dd2e31f9eb178fdd43dffe2864a799dd6f13245a5ed5207bd425d93d98833d352a314f6373b2ecd5c963968144f1d3a83cad4c4279a24c5fa74163b0e62e4e051688cf684dabdcab78440ea715d2fa3ee05e8f46c07bc9d6cb29b0a6c019f988baefbf7150f5d533bada0448d708573fa00c0806c5a3f9400d77f8c3b9492e557c005fbaef1d7febc9d0f45aa7fd5802be194c404b5fdac1bb0956b57f5c620a15841470080c0d7ec4ef0febbcbd293de1eb50a6a3057a156de93b9b02856cc5d45f696283b5976bc0350f6b87b60e21df4a0ad6445f63c2ff7055305b3d7e25339b18c11b5e059063d9cab41b8e9c448e84858d6fd8580b14cb2039d6e3f900ff4ae0bbe43c0ab5c5ae63332d4782a949ea0815b7b22cf85a1ec07be90c27e88dc710a0498d50848d9c4edd222860aafef4573636c994fc4ea736ce58eea4b5162d791d6b8dd001d833929e0a0eb9d576b146e285a9f5b1c93f26edc4d4ae99fbf5a43e7a3eed2c71dde81683c0e694187b6781b04baf12767f24adcf7fb7133c198ded49b86d26863ce3efc302a9a563b6d61e19a937398d77b954ef144167f82dd33ed8e30284e5824f01c8410d8aff344a50ccff2ffa43f4ecdf21b1f09e8855c14499239b4f94697a44bbe73a96368c939a26c5d8bb1d94d7712574233923c0534704e3de4e2b3512783b8cfeb2bf8d57c9cbc9a461112f6c486e847d3350ab7d5aef93aabbdf296e2b6511fb3e1270cfbdc255d543c8693c8f8be9647127be310901156c8e780eb888bc5bf3cb4f55968bf04ea700c397fb5729636bcd367f8fa2968c377c6914f52df116dcd848df9ca0e473332023885594302cf27aac493ea68f9b8ef2639b0cac1dca92c5920f54aedb41bb00d9b0ffe04286bf23f99caf25ab98ea5697369a834c04879f5504e57e199522c3d4eba12e007ae4c685966584a7706a7c0937a7a03e309dedb5802da2e9b858f6bbb5f45cac99c85a86b92001447383da695e6f62fc971e8aa9e17a5bf726fc34cbb17dc387b69b6959a2af9a3c4fe50ffe51ed729cb4ecc867b292798c5f0cf475c04df595f21811848b15a6530917199cc40b062142f0a88f80e1fb89cc69a7a40a47c1ee80dbe9bb543bc811834fe4bdff012cced2ad91bdad7012ce52e86e162ff40693178e0d3aaa69abce012f86c6bc745a8d7598ef8592986fddf4dab46f5a87566eb4e7a6c39b7cf4c6eecd3d21d0126f16e396848c0a31f05a100404f19b63abc0a08a64781559de559b59e0b50573047abc148053e537e4ec03e76938400f12f15297fcd2d7f1fb583e0ceafd6f9724750fe464f8ccd978aec82cc1ffe1c4017db431a5dd8f6ca82444de381f633cfa0a1b5afd0cde760db6cfc849c94ab39ccf3de972c87df3c64d36a98b6d64fe23ee7b0ec84be8ae7c635f0fded72c1c93077b50fc63598190ddc612488d9f3917124fd21e36255fee9a51302e35a75139ade992fc6aea5ea1a3c397d6fd9f37c09804f9ef6e88fce1aa3e969db6cccea7fdf91aaff7429fbce07bcae1035878dd229ba1b5b5addd9313cb5cc6f4b7bf0705a1a2025900712dc082848c6568e4984ad15bbd883eaf269e445bb0c131d12ac77be20fcf3a8870bc137ae4c9cc68e56a115161bb7b129c81259bd7a665c05bed82f976d80ae722fe377e9a4b9e6a5321e57131a8fc95c627e7902a1299d5f64c96aea668c82f9eb5ac65cfd9914e0246e4c674bc04b3815f947d10f97f79574773d0bb378608162360e3db06c2bd33700a53e575745b0c2118fc3a367417a9af7d497a9508eed72ee56064e48d16ce55f44608f0193767c920a5b3499347a9dcbae2c450bf0b33cfad7d8a42aea55d7b64e6732117d5ff5154fd6bc67ac234c5e79e5a65b09b1afbe0d7d96a2edde020bae8148db8529025f1191c6364d745e1b148ac04fa624001c5b3e81a2bad1395bb68c35d376187968f24eb05f2469c5f1246c3d72253a2420f7c8fe254e14232651e1a5443c84315d6b6410380629e6d77893b79632dd095f96969208313bc822108a4f589b3b887d78609b857c91da7e08a9485a9efc536bba73b9af6013c96cfa8d20380f96fd7f0aa48f21515816736134eea93e828901f2c9a2ee94b24d4891d2d19ec408ce73c4bdd0e2d056ce492875ca3e5ec6b6f19a680e471685a29f61b8389b1c86ee9e234d3536e726a6da0b8ce8e35bf6ee1148669b1c2e85b44c19a77793dfcf99c64f4996f6143dc663fa090319d39ddd0ab4ad18f71040b7cdceec7d7d96768c39bb4db20b5f407024384eac61b1752850ad3e5e76ba2523c3f1356ee2ca2411aaa88e5f93771a7de50db8ff96c4f15e810088426d0d953c4adec6abaed9173b89ea2782dc7d3993ac280d8670ddbb5f0d98fc35c842977f5a317324983a8cd722e55a5c30d5fa5708acac18441425a4c21de60445c0ad3c5ef1c62c9b60701485927f8acfed72c983bbaeebaa80087f13c538836005e2747669adc753f4e22e7c0662e081f21a07c5c5a96e24f847023b33175d82513fe2a2b4142dd3c252ce887a49df0692edea3c0f51f8bd8ae515de53a05f339fb6614cf92e2e441e9117ef76a8b706a014c660106772c380c66ed488a89704b73d022d027ff939ef640df479c30befc7663156d802c57a554c45fd25886362ffd1f97e2e4960bc77679923bd64aa67f162aa0f1dd6140ad2ef4d8d0a1f7e77f51d02f383c903a566e52472fc116fd15915f0b60568b879ab66d38e3b0e09918b4ed163e8c9f16c6ef5298c88620dfb6fe911b1361c7641ac38e7336c024d64c3899e5b24424d0cdceac0678c4ec2712afa40184f76a4d9708a73e9004426a349a5cae7a014fd96e8d9a3ee1d5c232221f1429933823371f84f4b809981a616a3c23ad10c8385cebdfa633eb56e1274c1960fb371d7ad4f8cd84a20bbcafd4d5943c9d9001afb9100428c5cd07717593132a1ca37596fe497bd9a7babd8fc6f8bee412da582693ed0ab4887ec242ebaaec73e25f49315e556c2f9310efa29ab727f3d438fd01ad4e53e360f123616b55e5e1ed031b36d8c1193a2dec9896eeb29f2a91f536e5bf214052c93c8e7c48c0f3ef14af2c4e222b1d60ab364f09fc5f2923e2240e23ef2bf974f4d001cb529b0a597ab6545278695b1211ac78d91ff5b84c6cc86a9d0964939e9ddcfa9c25c0dd9aa17287e2a3b8d71a1178f3c934ed4803ca487c419f7609e5313a3cfb76b809d1689dcfe076ef4e6f8ac0a7cb4a8ce9d3a3aa4d358ad725ab5e8f8bce291a188f2fe572fd20e3c19e2aeeda56aaca19ff6e02ca520d6c85f90f568c4bcf274178f59550505956cfd0a260179ab1f468ec85301d2b2f8bd342a4121fe8016f237462d97425b32ead560d03eceb0b3f09957e82cdfe76c356c85338654361c28a659af73f00c239d4412e506e7d8ab01a0d2619cbb2946d21794a6f60a5325e94f94f5c8590edb6fc4b4c47092f9a4cf53d4eb8f5767714dc38e1e9bb41c271e39147da88e183dc51b3091ce6d858bd4b10dcd39acf38d1a50e3b472b53b175de9e61918bdbafb8de711d2da5be79f4324c44c1d214d436aa739c122f2fdb0355ebdac4ddec2338fa47740448388ec3316d9f3ade0c1d506df92656b24cd6d56b432c5c786f9052e23a83fb418826947eee1b8caa3314bbcdd17841c3270944df92da4be97c01b59227b26a722f421c883da82b10b7af6c1c3679dd441a8a42885b958d769909d452d095d9fe067bff3d1b93efca04345c71d3b76c5862aba26529aa580f489433e28ddef3e76ef8b987efed997ac947cf1c9666983f8c445583cdefbf874f2642603b06816e59444065deab7f641ef4867358891539722eb33464dd486abb81fd0f034ac3439449e84e63f4898b8a54da4913bb6917010889b44756f5d9eaa63b312e48ca89495deaf84016246ba45ef6ec2b028b4c730f2163327f9a6d286a554f2bc6c34ef06fe829681254d2d441d93fe1c2843fbe16ffe2527ff0ae4e04f4b1cde86ab32d58354efc55fe62d6b2bb5d213ccd9bb93fae868b1e5abdb1d5ea185e10619ee6190f8459bb6302990dfccba61e8f2c547004b6004997448bf61a1bedb995a033fddfbc666728f185ddc0dfbca8e7b45836f72d71a5834e15eab32f937681fee0f01a17d27d3c6473e9de4c10945f3a587e8be08ea3990c4d2afffa2e7c0e67ecd16e858a3e501c266a8ff1342e2ded73356ac3b754cbbe7477f32aea23113e407d6101491090bf4a8d6a9b2ab0afadb2622b9583bfdac41539e29a2d72eb734f93fe4d1165bcde7d54cbae6a54d1df655b597d58f46f3ab299b928ecbf00974ecc61be738db17a6db378096803eb0c70fa786672cd9edb51dac4b05b0e24e27d1b93ea7bf2c40b31247eb39a459b917aadd84dc49c195416ab41bcb53d05aaacbb32968e5805f92946649f4a26966bce491a82b120658ac64c0aa8b3ee25d8796843d1d3faa2dfe85f6622c6c208df26fd2ec1db929e0d343020899cafc110e5f4d2d9a6264b1e351b65f594f85c7fc8993f928bdba4e0e99daf7b40c1c7dd76f14ab894a8d11ea681371d05f0959ab2625cab7c2d01919bbfe0d481148162cecae7b9a496d674d5ca19fb5ae5d2c176f8bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
