<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0526b0013159a30cd86c78cd1599b28a579f2efc0ecf821bcc10736627abf091a4bd72774673b402225ac28fec62cb37d79fed7ab127a39f4e79d1fa69cd8be7aadc20d9af85fc49387c5b112d6e0c14b32b2b0950448b1ac0b80a338beaff8830198d070bf223dfe32f22daac7dbc9c7b612dc8d499a391e3a997ae3931e5a39e273b126bcf380f31909a7de8bf831a78265bc5d87792b6ad4e078a61c9a251b2acca2f8c82cd413b18dc40698354a7470a278b84657a5780d55d956102c29f619af68c52fa83fc120b1b9dfab953ee3cc5d87178c994003e44d700bcc47e375356ab4256f0f5aaf3dd2461ca30d393ca4bf242491f1fdefef00405e0fa65eb389789d2f7427b47ff41ce36fac0b296b43c74bbed4d3e3bf16870240083315d73d1e430d3fb80db4087c73787e7be3e3610914475bfabc41a679a59562f2fa2ff3bf0c96de7be7fcf95e4ea5915dd7b8e91dffe5c991956b6a07c495d21153c448f082b30ce65be0117f7606021523c48496fedd68a556581c4651168f969761974626520942d28a4977af82cb886239c85e472205409cd852bfe674c116f862204d5292c33dc82bcf2eeaf536229a5c92e98a80e7d1375a069530251fe3889eebf5aaff9128807400cdb2f56ca36930cc1a09f3a5d999d26e953c34533c07f6ded8b52e6691ae74f66f0c0918e5f24f481ebe31bf7d0548c51b3b982e182916efbf68e6c0a1e8d606bf540bc4fa403112ec5928a855010e1c221e61d30d01342187feb6d833a1384bda468b2f332dd5811ae841714c751103464020db2c6e7f196dc8285953a132307b46b965225c65d280cd273f3c75f36c44fad6ee6d40eba0a18baf64d18e41c094d404516225190a397f08cd695317c1d1ec071fece24a3dd2ada9f91b1dfbec58fbb94dcac9dc25fd1e38eedb669f66bd5b4abc2e01870da54b319b2eec53ed6d0ee9c1fc6c8b3349903ac06f4349e7eaa1a85e2b7345391c5335c3499cd6103ddb6acedf0bf1a4bbaee4f508c4a58452dfd2ca8f036a467c9c943e66eab252ad84f83e8ff018f36d45e894d47295cecfd8e58a263384030f514be7680659f7ce94b0bccddf1dfaeb2aa07e60777d982936ee0bdd63516462a4f860af9bf5c552bb8e77612e7c90931c2b7258547e1596ea219a5782e0da107675a9cc43c419cf2c69ce8b9e7d558a7575a20caa284f296aca49365249f7a43b83dc748bd37be1077762e9d30645b8572ad74a441989b1b6556b55e9cc94c0a137d22e7444667efd98ae48a7480afe150057721e897e9bd6ae1cd1533f3a507c0369680c12554ff3ce836db2aab99c4e094f70587487117babdfb75f5b1561144adc571548814de1487cd701338cf8eb281ab6001dfa1b28b165190243343c27faffe3658c9cf9041fd106b85fcc7bc7b0ab35573223b051f3a83db4c0627e31f1732e0eb114dc31b76f3b147b1f3e4f2e21c554b0f6d99e6510960fe3624ab8a27b20f798693e494fb141733c955ac0a2a57d449e93e5c3bb07d37cdf8ad53db355071601ac8ee2bdd0b30a575add946b3353858f4788f595e0b21187e7f4ea911cea62a9d083db5d440dc32c7fab23e98dd19dd9298ac4c0724566527aeaa45eb68b64cba27447c6438bb349892f90ab97036f54918d42a48e138831ad0b0d96fe0226552b35d349912dca88ec2c40fc88e360fd270d0f63210e745f740f0e8eb4c7f380b041502cd7674d8ff5a008436ce8c92a030cbaef3f08aa748783d2a5b4ed8c34ecd5b26b3194b88bf3b8652c35eba52b22c44e96ba809a2d94dd87b98e58306e659d450eeaab5220026907cf58002195d9fa455db178838e0b76c73cf871a57f68b5ad56128fe33892c180ced25cf2dcca8c7c9d321ece067aaf4fdda12901b07d8a0facad2f3b3c8e0b6e61f126186663f34afb74b18ab27b7d6b9d025d311b7a589b6f4f1c08a08370d6e9ac6dd45f5709fd19c092faa3565172112ddc9263a8685f3540f5f20f31144f1d57c5f736f412c7885bb510f71117c066f2a0fbd7aab7ae6ed271c85aa0cc0259842202d6e193d000f9f7aa1d4cda25c2889fe0cb9dcdbc15df5046cc47a95a16786ece342847eac557ba9e8208da06384683aba1bda56db0fe8388ec5c52fea7002c83082f15af92d74e639e0b1c3f6cebf98efcc1ea1114a360971e4723bfccc7946e9305621861c7313d8dee6ad133f0e255e7a4a7a542fd256794c8053ccdf80f3bf9cd06f2579640a6f6c3d79f60484871dbea3d4ffeb911e73c8fb7548372c1e4db3e1bdcac0100a84f82a6d422c08bdfd587b84974ec360ebedbda52a91402aba1d681927bf2ee860beba7b5b13ca5ad9a53db33466a1b1fac5e773f06817e5c908c52c57da09f48750c653ac5cee30b1e17ee74ef8efa2360eba3bb46e8382944f1ce90a81f6f6b03b3691d039ff87151086683c1cb0ada3ef284313253609a063bc8cd31d5703b3913e3de7731ba946b8561926609961164ad4d2aa12cd42a3004ec40a898e943024f2c9d4f9101b38a2aa9b51a3447781af52b3268f391ab8d7d2a81f7e560520d8d115384fb75c2b7454ad8911de18463384dd273288a83ef80f0bb92d74dea228ff5756d5413f63a4ce10fa504a85fcd2bf3bedde26b785f13e86e3aac8696b53fbfb1f73dfe87a131bee30324cf9fc5c8cc76c1451adb874eef14e0ca9b443a978094d312ce6614572fd92b72c2c702a1a3b4016e79004ae64525fa3a883a1f79a245ba5ce1e8f085327d384767f4ae8c5d1524ffd42696f44face394c723deabd8da9836ef7670f16537cd18d07ee7a0254208b1ad14ba85bbe9fe88ee81dd0d1841238392e79c23078c604b80cbe07f5050f28d71f5848dc729ff0459dab05db81c891f277efe2dac46fb6a9fc12e0384c0cf2080a8de1db12a1e6cd037af6f3e89e0510d84ff5d0c0cc2ec10446e4c1b8e0416ec6390dcdba8331ac9d738f6caa77d0e3546a42ec2c86e13eb4f51d3729642bb86b61706582b846a3b979d33ae8374fedff30e4d08c3924c1f423913ef9dc901b112c6a032bf769fd6e2722f07ece58ea925183225b68a2bdd07b1a9cd906e2f53ca73aee2eb7547066e2343ae99677535e8e28fa03d8830d4cc4afe539a1490bf596b882695723842724def5138121cddd198b0aaa752ffa874d37d5560648ede8fa56f3c0b12ccc415e1c40d45f19d306be36f5a60ebed4e1cb875f700dfcefa9fe0191e181ea5a6c34e5e7ea8f57a82ef3ffa3cef7da34d6a009f5ca4da135b63c59c78804cff19cef07385163631ee190945e63c3238ba609e59de4dcba30b703d7a4c98acc2b1b3fa43b1a94b97032bff38f21fd6a129e5f341a682dc707b826f62597d1759b81d2252601b9f65b3e48b083455a872b85b2c8eea5f76874b80a04ace910874e6b76910b345d92842f667e361f730efe8f7de309d09b0f2cb3ce61e9c87017f7eed77295c18aa40ff2da189b6f9e96729b1c3e8cd81082bf217c26295acba42df3db13234cf3371aed1a618a6b536af6f9618e2eafe1ce098ec94f11563b327c67229bd5cb5c26fca7e4e925dcf23f3d8b3033f2583f053f1822f953a5c78513fd51aeea1ea53c2bd46cc52b8a4837f1c00f603f5a76be58fdb0cf42b03dba1c7cb89efdf0697e6f0a96910a83f3e82c26448ba7dc3784563e0bd70950f3bbaba3fdadd8878f65322b694205ce6e5d89adef16fb20ea8c5e5e261aea39e0c23ff8146872e1939124c343bf733d29c244dff57deae23fdf67a4c33c44977b88d0be6c39e734d9ff5f02fc7449544165959ff3a7aa5926ec6609ffe151bf2baa62667e8e82ef4ce2472dd9d0d9308367e25b54fe3d32521cfeaf2126690a5744d50e92897e006cd77f4f3b04e9f6ef07499350bb3357b2985e25467c60ed16dfbbaf47dcd7b16abbc10507dd5d5bb23f51cc911ceca5e0413dfc2c59d7a10cd5cc50762feea879dede9cb6f866130eb6764310352aa2d14aac357c1b804d02c7933e68fbd2eb37cfbf71f88f10c1cd79bc57531c715a4c782f15019064f8ef25ad5a8a8b444d2b3238d6d359d89e96af37891d5b7371c9b0ac6596367898480b4b663da0c1404ed47ee9ff0a4d380bb2d9a1428a65dc1cb4014067911d5ac56e8c03125ae3e7b742d1652f6655a7f1123d9e9ce9e64522793553c3588d14e59f528dfa99864989fec7ab2d9d2e15915295e8ee7072709e2fcffd0ccdbeeb566386716b330a87809b2e0ad3f5123843844e073c5a25a0f8fe7edf0d803dad58b6c05cd7b9a6109a00c2e135760ba81e47c89887501c8719bdedb5cf39c35d651c8704053b8d5ff13f9adaaba3af51b9ad598a141aa6d78587f51f715ad15e915a9170ecec3508a3d2050799636988858398528277d78261fc8c334dc2ce32004469364e2e02ffcaae3ca2bb8382b6c75e649a86f52b472708ef803c1737cafb8fd0aeb6f15ad16ccf4bf30a5c5ebbc361dea674f4e0730b476f0d275da07b7ede02f7936251a50246dc35d08d5d17baa0334225e45245885e70bb6881ed925afbac760c07f956a19e114683aa260da96d202d096898795705b686e4cec406a6e60adf19ce9348fba2efc0a155e54bb7e2c08b33435feedaf1ead2cd04456bda390307f3e1f25bba6fd83ec445184a115c3a7f5ed4ec4b86c6df8656f03e9c82366a82bb57474229ab00ef32a0dd894714feefa6744c7f4382aaf14df60d8e58a5863344898769b783a2a3d054d49e7d22a119f3d38161998920b8aec088520efd586151feb6e63de4326a45bfc7296731bc6feb955ad992f4d7815f4c9686e309d1c88548e6746181af13da5eece4b817640146ffc3853807e2c8ab630b8ed34d56067c723a84c5a9eb113e19d74cbd89bf37066f20bd535fa3a8120c2de4ffc9e476fde81b15206d5e1e89c13d3f03d0f582ec36d0adf6f88ebf5c8035922f86f7bfc6d80e9dbece7dad2a9ef6c62cbca2cacb7957230cead202e8b1ad75b4be70e81d94a26a57091bc4f3b4c73fabc3e9fcb113ab5b7644af1c2be841afedb511e0934c3214732c029e91dbdd54b5c783203bea32894365f347e434f52b5be336a313a46fbc1b20ab5c3de62b5c873bcc38fbe296f5f7e46f9eea22b9c3d9d7cf9d32194b8c521f5465f8997be53d0088420cb0174916b00d064a011ae7ac235c443e3f6dc21edbf54a61cc0446952a54e334975f298e36c35f50d6132c7d8c9166722f806861ef38c93314b7327a30834ed3832130e3e17567fefb0772c48a7806b559761f0f017ff35f1a535e794b9b8ecb629d1ed0dc376f6beb88095a26ca0e6ed0302791c02987246749665778a7f5c4623f0579324e454043b5e26409b044dde0a3723d6c26f59b18367e67a52b667a6f1a85cdeb157a56f0a844f3e8580ab73b66547ada4c14c5c1a6933eae78737636a5d5893751dedbdb84d5b0a1b387321db7068a048753619ead3045d5cd287f6555689cdc02b2bd4c8e84217fe9162cfa8148cb9d1fa6945fe7b7991bfbe8f1a5ee8be337b4fe4f73169b4a44121292a3f8145ef2fcea0badd5a6262703b33dd995511430f348848ad523f60416389d354cbd37c7f07fd4528c72e71f29e1d549ed28ef79f057265e2ab1c7bdc11b78f32429612e4d2f75c556f9545d1123dc4146b725ce5e5743c3da4bb0d21c0c9c63673e761e2d356aaf6036454a48cf0e795bc97b23f540d86d2108cf12ab4ff578b867133f33bf3276eaf1873fe3c4ec91959b3f03bda7d822a1a46b7f21bd54e654bf2968260073bec1c28e52085c19c8def6f52c0b2ad0175b9b7fc08b4e022c22373ddaae17a23915db2627030264f261721f75a4a0fc7bfc3dd62d949dbabda4238bdb32bf78250ca86bd130b2bd262f02019dc3adfa0de46ae833cf0afccecf47e6080a36bc7f75c8ef52583ba6750c8e949a37f772d487f37a70ac3119aec9a18e51a4971a3f1621d702250c9bdd85bbc82840f2436eb1e2c94b1dcd73ff395d4e9494b7c22c0f479898c3e860b23a8ceace5d4998534779848ea953f9f74b7f4a4b493a1efc0b0b1237bd5be963819f96c8eca5bdbf3a371207e3cd09d5d4f28b9aaab8c2abe038fa4b860f841da02b3982a8144fba15f967d42308e9f52556c5b0df2649f6e375b3e789d8c274504fcefac4382e546c6480434bfa02cfc6bffc2cc7ba3f1c95c5f9cd9da29e2aec397393859b2df1cf885890cfb489b0a409c24fa8feaf864d6fba298cc523e40bd5211790546431109945335f2fadb95e30ff8665f09175d2ac8bc5d805d0e5b0c3bdbaeb3b3638f31641a688f392162050601a62c71f214f74979fb01275f30f8d4ab4b50c405e3f5fc47d68160fe943329fa7ae7f9e203c0df939b6851af0cb2945844f5ddb7a6a9a17e9bf27b5882ac155e2e0de3baadc5b157f480b6b1a65ba6a14d305e480f48c7a8393f488a5f78d3de8b97eacc4df9baedaacee80156533c1729a4a0792b84b58427d89a871cc9b15bda8e65f1b31b35861d8c9e2187b5d534396e7ed63e87ac989dbf7d142cbf7009e4a057460ce2fc3266f4b10dd11fa56c29515124c7d92f9dc51fe39f42d6cf20a3c5db4648580fc752680b30e1b50299313ae82956357777fb94e17b1a8e8cc488b0a3632db4e5b484de0660ab2f53b0b056f10eafc923e3426ba7b662ecb93dfe056693ed703d9f86d258f16022fefa9b520bcf790321aec4585adbc921a3c6b6e95d7aa397fc6d453817650d750c32eac91c09f4ea78f3b79a9add436aa1ccbae6494f6c1724da7397915ca8d30d7b9cf476e07a0fa9fd5b666004135428b1074d8dadc70e712292293fd7d5fb8dddc445de2bd513f85914a5f752228c9e4208f38a6fe6261bd7981e220af5093ee0fe67fd03d7cf8a2dbff4e7e93e64b001dcf042c21ca15712b58d54173c345b5dffada62fdc9487fb4b6cf251dc3bea5b8353a9268e37b30b5c22bdb405367a9a990b2dc2832cd47dc500b48263ca591e1ae3a601f8f3ab19e627683b5dcf7230a1f4c5af65034f5d702d5351a991a59caae57480c879c152c422826f84531e3ccdfc13a181b00b97c1d9122a9c35444127bf9723f14b1b34641727c6e8eb72d2b4c04ad11efade8b1cd9edb9a99f48b13ee301e07bd8393ad1b4360ff691ed5d4eb5f49872ebd523a298852fc20cb5ed5e3d7394e26d53b3bf99a7b99bf720dbcbb8c7d04526c939bc54b5c346aa4300c1284b1e7a4036ab6885994097bebe204d83cccaec16f04f6c5be702ee3d7c5a44a0f6c26404f9419ef1dfb2fd2754bd8373504d21cdf91e820c20758107407f5fc075db8643e37eb24ee38e017e6e237f3f24b3c922425902e95405495dd6de5b7724b9a705787ee20ccc50bac36a66158ae8efcdc9fe11b6d5d2d71f3d7c78ca69994ec2974939c513e700ac1807d9fd88d023c3b1e41ff1f8a3687afc98e95a5f71920c6098d159dca26de64f601e99e0ee9b5181da29c01602c0079505a8dda18addcb82ae1d6526eb4e10be54dced13aac53fe81da71c7e52b88a5960b8c6b7820aab699d1dfe75132607161d544ad016c682f024a918e6859c462ac8e9551e5b9774a4bdf00038000bae95d59b042337c3436cbb1999148b02cc9dca6e3fbf4430285a18a03fdd84669c2474f701a2051750e7bddd5a4a10c8258e4c9156cc4134a4a5a73907ec9ede0937893af7f4d8948b479a21c755454c1794a3022669babefa5434a303760f9c69af9f9e9d7450cc8c283120902290e5c4528ac03ca6385ef1ce9fe78c4a96a539b949753456dba34f31b236a940769c65de436f25db1847cfe88dd5c352de8e1527bc3fe286048ad75e7bac1755058d13d6d75a517c9e0ddf6b51bf9a4ca8915c7c680e3bcb076652abaefaca3bf465fead695f7241b33ef059cf497f9397ab0a029dbb3fd62e5eae456673172159a50e5886b55b8e232660297e2e74de2f9e061a3fa4ce3b3fa42b9d1afec453b1ea78bde4795f75097535ef9897266db9a8b2752bf31186ad09aa372f3365db2f0e155110bfc10c52d774311e8a8ad43eb7aae84c31277b8a373127ee9624dfe7bc754a4559613526a98f17c3ce0872ba153e1f0fd937cac6e65fbe6b82df4b45e3360e76a8a3249ef1dcec42f5e73f50b48b9e2749da717972363d96bb98df7539d2034c738e67e07febaa714575dbe9363cde8c91f69557e78de8aa52f5bbc4bd886a0a4c5c2c644b6250eab61bd0f27574506941a2756d2060e0ba344bcefe3131ac463021a8f6d0034f412d24eff2f19e6720dcec2e996fdf7c5be95b2ae516593025313ae998a74e10eb12216971a88017e42b444e01be6417fba9fc907bbb2726d562a39a91d80e56a7e6e0fb5f51fb6869105b5c6d1741d1a4d918e1a553b0b32b3fb1045f9ed4155817042f9bb261effe7dba2d17248df99e2d082a8f5de941e234451eb50bdbc3e4469df3c9c719712d04af0674caf1013fae483c519b8299893963c9133a5cb85a84a7fbe1edcc7e44969014b32dd33f792ecd27f5388859e821506e603f7a160133871de9ed0e7248d0211a516e30bda8f6f0adfc7b764e6a751c3d911d8da80ccb2ec54b3f1494bdd33c6f526649afa88a88e5560903734a2b9563b51529611a501c2cc051324ebf95b9cba9d0ac72c585ec80521b516d252aabc2ae64a99323bd1ba420e19aba78dd52d3c1a21bf592c184149db1808abd3775978403ca33460409d79c0caa43364d17b7cba9bb16f9def72ba49bfe1765c93f113e80171262c82c66f6b5db27a9bf1aa3470589728f8a42c666673b7a175fd397b7302c067f4c37a5464a065a0d2f748615b42206d13431ecc7b6b74dd03dfa8d093b90c5f387bca370c9144b6edd11b1a402e273f8c4f5b38363dd860f9d6b99df2c691a423d68d446f39db065ecb746084d3109a8b6a6806cc7506dfc4a75db17f16b46b71dd717a439af98f46925ebffc82463384df3784dee09690666d17965b1e0c8a7c412ee9a8e44d5362a615e700be93af8f8966c129d8de62c4d02df10b0add3bdde5de392f794323f70a569670ba03c91a221c006eb8ec5583e86d1a9c2c09108d420cf47c286e5ba31801c6e3d065904da7aec17caf1414e8cba6f35f8b788e3f909cf6042dd06f24cb25a17acecbfc1b3fb330cde2d5d86101d8742ee095140ceaed4a012f58562b6a5d39f8754038a887f6780d87ac9c4981e68e0cbbca018372fe3e5269a4411fef2c26eff9c1b1bd8db524bf5bbaf2b56fd94e9ea615a6085a0444340b143acb3b08ab699bffe33869f9dda7fd9ada26ee369b04a1458479488f5373e8c6fd185bc2c10afd0e458dea49de586899040f94faa0707211c2dd1931cfe6f3a7a458bfbca2d9eba7b2921125aafb3220a3cdd02b08aa9184de843ca3a8a0fb7b864680c952d3fe10f477e6405e9aa17f1babd3eca246a1e869d5d8ff86984c3c0bdbb8765b20d89ed5667f221290d913b4915dc23eff711abf88f8aaed77d2340948d9c5db1fc65a143c870adaa5bc109c84a5f8bcf79721b6f58ad3797fecdf09f11e5c0d406dcab7a19590ff025556c25fc36d52e7cc9d09e7207f1dd874f3bd460bd4f67e58aa2242e3fc6a4b90dca4a7eda002567cd15130e979fa0de65919be47fe431e89be3b096a884343c32de5aec4f22d4949bbc313e92c06bd10c1cd86935cac629e345f60e43dddb130a02052b5a0a8055f5a4f21b29d5768099e4c53b5315a32c0240d574864c16f121e355391a0ffbe5a739e5e00139eacfd59f4989279c029bd5c2457f900bdce0c8d0a09957d9003e052f148c1c664b10c56344141f407830dc7f6315409cdf6663fa67b1e967d2cd96823448153612d29cda8477ea64d83998affa7c275adbe6d6bf1e6f13c5e8e90a66f9fd217872505ce31e1745028efaf46a83a0c9a54597fb8fa040fbf3c08584e31d86c9d3e06368a12c1ad9f7bdcf20d4bb48d902d14992a4dc1d60ca24603d5752a3590c829123724af21bbe514a7011c184e33b7b7f9f638e9dc8f78fcf43341cf612587a35d46fbbe52c29601e72784db39d7d43c01d45ce14806528307c21cfbd4d78fed429ddfdc2893d32ebad4ead738b1b1406eeb6c93bc0d756091e76868bc03672669625863f9f4d1ce16dcf4d5e5c4a192630deaa01d4714aceace0a0100db83471b54aae61ea664b4d48d0f382ad1e7e448a566e55890886f3161fa65244409d18d9be131d2b8219dae2a72d18ce586d89d5a966124f6e12ec4de51dbb90c934e4bf7b1ca0ac47e9eee9e25bd7f750f0bcc12e9cc36872141a43ab01343e69db6f4a703ed3a15d383eaf54bf3b3d313f308683227f9a83e8521e2fac78cd3ae5c5bf463adb57b5d5922c36c5bc6dd7ae9b7e90cfb02d8e5c42c4aac11a4d3b6afe3b9eed4c5d657d0867f263d0f5051d60398abee2b382b42db24a7cedf3ef939c8b81098d7e96d08a17c56219b0cee5e3de1fe422c26e4269784ec57e58d9ec58d5d7bab25f26ea9898b8570cc03910f4467e47653e78dd31e9858cd464204fb1487e150c3a9f7165a7cf95b30e22a6d3d8fedcc0198ec70f3678afd3bbe6acac567b97a8ee1acd3bf482e377c04dc98e06717aea91a98d5adb15190ea5c52f29b9d363d06139f69f8cade31c7a4b1f5d7fe2da0dd8f346b2cbd435ddb56507176f9ec784bda26275b275991a316c1cb35afbee0e7b466a68a72c3a0d2c98279897fc3950430292fc4df96669bae86f6007bcd2d0d31611aee6d68f479b558af2ef45b67f6cc47b11e6706de7e04bf994d5b5d5caa277f3480b57cc6350993800f474947ce55d40344f9eb948ff4d492f1518e4c92bd7864f04a4c21f398e704d92d55511ccfb726be59ba2a1f3762a4b3a682064c8ed7a053d4642eaba00bf5103d642cb780af73a1a82ac1872a6e31ad87698e975c45f5b2c75bc5c527b0bfa064754f151e938f52480a0198eb7c947e8bcbbee0627c93b8acd8548108a4c8cab099423fb7de31bc5180578f880d8cf5ade643fd5a62d651fdb28c63083ccb2f2997b6481e53c751f26c8fb824fb8cba0dc8e9734ac380117abd8d6cc3b45d9eedcb542e141abe0f8718d29e741dfe96de18e0298afb0ee3729889079e435efef24adee938d4a2fb9a758a5a8cbdc11dd6f224f9766fd710f19bf21ff1ba18e74f9178fb0d45f388f065cb2319e5e5a4647074a9420dbd526787df152337edf07d2c779fc2e3a5e336a28aff64a6d74b919b70c2198b3e10ff1cf049b7c013858566bd8f28cd84de7c269c6d46e3be0d85290f06dd28df4326364bb74b96887ec82602b4eb5222e55e6ccdfd63d84783512cf40aebba96461a001ee482b27065e0fc1f058b862eb045d1e7d60ba8feafa7c911c84b6956ed2ae1e9afcc0fbfa5b6ade7eaa1b7e0f4c39884ca397fa150f91206043a3ebc14596cbce2d9a0a6c36c720152beb48c03afd304414526d5d90caafc986aac2e31ba0aa02d26e01a923d1db49b369c4e456e507cd6eb40373b9e561d3aa1086d16815676d53e94287ef2c63b489036f4c95d9bcbc712ae9c4ce11b6d8626ba97b131a1147a7073685c659a4a8835ce1dd242e1b04f4cac6fd9c27362e7e6dd2f640fd5d4be6855e18b61abd40b676ab7f3048ce66d79b21762329c1a231a1f2540a8142eb0c53035e08c6961be0c2773245ec197f622e7fe22173784e63f7948fc02afdb4a1a15fcd7c2c3cf0fec2510476286f583b4a9349a29ce238ade56d072e307d00a7348cdea739b5f67f91995368c5593ae88ff076f316902fa49c53e117f23f0dd8ff710e856682620cef8f749ea18c31d23e72f97f95bbdae7e81dd51cc1e62fbd54d5a0fc982272fd4aba290affc8d885c7c9527e04a5adcf041a93259ba082392b9d9b8477e5698b4328a1c126da01f4a7c7c7689d677328d864472b147532298b604db756d5ddb5706bfa63dcab766f81bb478b894f4602a162c614925dadb060b5434f022b26d4b689f1b5b14d2f9bf59a1cb202eb4b252b926a5cfd2e0eacb448bd66f9e6a5e0db2c709a80ee14558be1d18318e3dd9fd3f290e8732d2b67a9a70d51c749cab7053195bb6759f4f4d0b63b141f95b5c99be4efa535eead9ab2ac86ede719f401e5a7ccdb7c81e44266284a4f61a56f69494f2dfa326688c3cc94bee28391757ee19a5b937a2f0a7141fb578ae27e2d1b857caa2178b273a0f1df21afd3fec60986bd0f6bc9cf43a10dbf41818108bf265df9c65cfc88a2d463f4932ab0e05339762b83717185937ede778c4c61f3a2c16d4f8c5a4673bf1115294eb2bb7dbb095661754b537e3060eaf042b4766297a6a9221957fd954637014b6926881619ce2bfca12ec26d2ac50912f7433ff3482b8d9dd68eb8948add4437988fb07613723a858490803855e57436822d06c83b03815b280360f092daa06248d0f3033c76feec3dd78cf3e129ed675772a6a91ee44317277fef8b6e4c68e973cd15793b61836be69b9c4af3dc2417f0766149fcd1b2acd0a91d16e25356804042a7633c75418108b33d7daa143857477428c2069d2411b5f415d425e083c6b00c66c0ef3c38d3d3993a8004486b6aea9dc6dbb5fa48c4a880153b255adf5ab79282bbc4c36941c8cc224ff5e5eb667548362577b9c3e9d248a43b229a9b7b0a848a3a63f98318b9b1440ddf58fea41e8c29d0fbe3a1d7a62e5af4cc80aec4b2b0951bc7f962dc889dcf43cdd33de37df263a43473166126aa405545dfec1c3f2cfc7bf2436af79c8cea0738f645f6db5d005ed8bed2f6d421b4fe5d9a88b737ed2d231b1e2bc3b99679624027db42523450cd0609206ad23b3700759b17f39d814708b53cdc10609cef13549d08c04167584ea2d008afcc6590dc064c4a9fff4749df5691775bf552c8135cacd598f7068a1adfd2ce47c28e5bc275eece4a420ac3e9879c61c6007b789874c1f7fa645904b2640ce59bf60225a2eafca11a04ac51a7076dc747c5f3f59e45516dfc17f6181fa15d49eaaf77f92c547eea492a3cbf0797fd11c96497c055b10e4eb1efdc75777bb425dbb10ac480fd2deec69c159f377d6a550476e75b7e26d6997749a1fa681341ab1fe483d6e4c8b08a7fbf1537f480050953c3b8b057faeb3ff12cceb1d14426a2cf7572928b5a78e43220a26c7b312c495b04eda376f9ac41a413df63a2a6e5ad7e9dff834bcd43b9fc02c6a1b6707164cb1efe0d0d7bc1787cee4c4f2aa13a119cc3e9c07d1d5f693b7fbfaf6abbd37443d1396664584f3bf0537da06601a1a15e1dbb363ec2c65adcc0e81a29d15c4e58b3c66116e944b912f6e855eeca246ac601fff661cc00b805ee93c4a2c000f63c0b3f2ccee8fcd2f251ba6f4a84024af641aab53f73c064d9765819cb2ad45a1cc7e1db82b1d018010cb21bb6f78a27877109fa8b9d01b5e937f0c15830bba9cd2e61e1ca96752392aec990b5710827611da80d926c0f98a9b75a9559617dfd11e184f1ad2f4121071f98c027fdae9f0be1cbdfe3ac70b337a2cf9046706bc3d7b6ace1a04cd782f5c5cbc4b5092c90a5a4f9385e8fad72dec028ead874efc872067f154edb04a39c2a1bdcb2c61bc23015a3054043d5b47b41a118d3763cd092a72fd65f2c063ca8c08795708f438ec4e1ba8ba56458ed74fc7491de30f1b4132a56c550dcb2646d6a5bc5d332095c13f0730939be172cd719fe990c624200cacabd6d477c0f094279292b69f9e610b5670f85e7a45c259a361aed699994c693b736bb972a1ff4c9702f7fa6b0b2c9cff3d2cc076f7fe3d7664f004c8f3e67af05baec178d7c057a6344fde1086354c3b1e582e368318e1ccf424a50b490f52273e4a5cdf1711fd7a964c60cebbb60f0bc00acce1983ff04885697bf56e61063905dbfef4fae64dc3e0d1e82e77527b19fa9dcbd04f3a87f7007a4111471e5e205dc8b90e03b5330fed48965397f8172b0f05ec5410396fa2946e76d08375d9f00025a56b68f95b9d88997f518f606d1c3bcddd4316826358c2f88ec386cfbd1afd1b10dcb14c9b657fb59e555a7bbf552db6bf0b62c39072ef4daf835ee66ee2f2c8c67dcc55e7362356ffd5983dbe1abc581a2ac54c7a41405971d850bd636457a9c144a6e69a7fcd4dc06b4a1ed7e193670d630b55113708cf39657dd5c3682ce29243f55cc2c52601236df257b3dae20292d88a7f244e07c0410ea62b86d930d6e0c951100684a8cabe17e8cda1e6eabbdcfcd7c6e93688542fca836a434534849b73e920e11b12efabd29d4ac76dd5630887b10be76d81380c7290ea3a922fc1986e7d7847e33fdfe80df793ac4fc73843605ee07752ba217b70b3d0c24cdee9fdb634bc9c9b00dedac53d909f635c31702264310c93dcd11972a6afd2ef29c12273e152f60990e333a2761ca76133d3113cd67ea7795ec38e6c262ca7f91c4aa39142727c1c3f9c77a47cbe9a86864096eb898595c103d83667ab9240c6d461c0e7f3fcdf659dc06674215f4b4d21781e2e04a2fab0ec2cd7fc51c73fb5229de715a1a54c7d7d36378b2bb20266348eba11e3b236936614ca841f84975b97295675ed5fe60bd9eda6b7e354ae03cac14f98ed08bed513d4e6e23971197802b781b51b2866ee0ce464d26d4bc9fd74dca8937272d483712142abcc954e1615de1b379bd5ab25516120837bb4276db8df326bb7749dbd241e88b72420884916003ba75a7326cbb01ac3b4802e4a75426fff76370fc2352ed9b7ef87788c3221a4a704f25abd2bfc8c42be60438ad1a35edaaab60174469c1ecf6eef1d597d0a7e3872a10473d94c46a461a1c4d79c1a6690067645540ed96c50e40ff1190b68417f030a4bd1991c9d214c4340e7cbf409f0fea8ebe741828ff960138d103505dc0d24478cd8410ff4ee644e544e75972fc0637a2ecf7e908e1067a03946082e8b71b3023b9660c4269dbc16a268c0b8d4da100d5bc71dd597639e0f99b196262c0216be7426c7e05578a7ddb948422155ff05524be28281a3867e8f92570dcde08a1136040d9ef8af4909eafa78137300c30892182385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
