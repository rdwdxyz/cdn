<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbd80b644e4a7368501b12a4677d7dc40d5ab51d323f2cc8915e7e39e38dbac83be90db1dea12051bf279cc2899f93aeac40f9f972318cbd65509945001d0969d34eb245019ddb5f41432a62a1f1d8b63464b523d7a32f02d8f116e37ea26417fb4b98340a3b420947c3c0f4989df45b1e368e6308619d855958422fb9a5789f1bfdeb24d02ee52f52fc5b1ab22d2c0f87d6f28d1de19aca3d1b398ec2b32a1ab4b7ba84bad1ca50afc68794d9869bc6bd4a286b585783e8e64c543f8fd8e468b3de73288ad93cc548671a60ef041a17e15ee3e908c2ceb3bd38d24f0b89ee2b5359c1ad915963df9b68194727bf6847db445cdeee6188ac900ea1c4d9f30abfd4908d111ba3c3c0332d4af2d16537b1a3acec6343b5424412ab4ddb77dc853b8c7eec529a1243dcd33a691cce1c5448b042f61bc0db8d09547a6b53cf28519691cb40cb6844c707c7ba21adb65c97ca27ee76cd3f41681c8d8214a28e461105dab74931e2ebc946027c2995147f3cdcb42d0af576f1686d64a2b82b7738e9c50a222b6acb0c55dde620b8e6b4a9701eb199747001948c81bcd66a37a1b6277e5f999814599a2741465363df41b3b06128e4624842fcaae06ceed1a49e2de5808e6a8781a9221997de512d43bb5aec240c59eddbd643f9cfaa72cc88e7206a78ef2fbfcdc916fe11b68475eeb9be3e3f509bd57c8928fe6fc6689e80ea683691aa475b19a01394e1eeccd11c1c8d16a4810b3db34a79e3c2a23e29815d5023368c60df899cc51de51d37d23fa73d22df6aa45f4635643f9ee09408a234c984564d22591c199e107920a1403f7c493f563282da1234812489e42324b4a05ebbee1efa1d7765f502bbecd2f54d8b3d9ff2e6853f1737ae7bdfd3bc05a24bc215cab34827b752edeaaf93d6be1e85090d9d71da553a88c6912d68437efbcf1d248b76c89eb9e388e48ef145bbc7e9817f6e74fd623be41ebddb3ee21b8b73c37cf0d703a535e1edd156163250c30c0b9b3097ecd491ec7b18d12b33f1d1d88f405cb8ad503915b37fd0b97d827e0a4ce643505febfac89b982c1dc63dadabcc421b5e28faf132763fc0f9d164eed4f05078d9cb1d392e2fe3c799dcc21bb48d198eadfc334c0ac6c6e96fedf971507f0edc513361d99132f9a42c79473dd0f3c430bee5e86f905dcd7d2a44e3123de137c1dbd36f19ac6a28ee83513094ee93f8449f2526a42a44fda022210a068021ef6108125106c1a9d4bcd39c3a907fa0eb8c52857ce6a628bc4c7a9960e4e59ec335898ebc2531c60cfb4b14e654c4123c7b014e7dd2c86e76f208a284cf1d6ac468a8ab9d2f4cb579692e1eabb16014afffc4211e90562995a7d084940eb864dbd7a454e29a9041d78326c10bf1722275b9838d2abc3e2a62e7844309357d17f74bcec6e04977fc428525401ba2da77c6406b748a4d299750d93099b430ee7930f86c2cc6b7ca627942f8f3e1b550a4796359454d1de30158c2234eaea37f7ed6553477243e6f92241afc2252ba6c7c3f7eb9e78308113fbaf919e7c707c05904722785779caf66bdc66badcbe41bf534527c6056fc6bd8cc5039b9ab2b0917b80f66e48b6836d63ff2e47c562f23bb769f39cc3c347718fc7c8755e46a355c337940c019148c7380659aa6239860cc8cdec2e3709df582bbe3d9a6ac3906b5562b5c547253e1f531fb718e2f5fba4a1b68f00291f6cfedafe8630e1da5ac2cca536dceaa3f7d20a3db8e6d49514909e09ef364e89bc7f66b6ccb0cf70a2d5941661fc0ea2cdda6d353f0fce55b31f97609bc7ea6f3882a668a4dbc45f3d93e125945cc0265a19e867900b2f0421d3832db680afc0654e51d99cd462573429342e4cf0f70fa47aed85200ea721d0c269895990015657a9ee03500bec401765338c1ed4cbe700244f335d317ed5cb00d5c919543063d68b7a8da417c1af5ac2a285d4350c86894909dbe54e93badb7ce53c9db764a482cf44ee54016b6a1a49828c09a5168877fd6db20e3add3c0249065e969acc9a5f10d054ce540d6e507238f1466d0bee434c6a344efff5d27435005aeb53d40053b912d3eaf448f8acf784909c66f7f486aa4e224eeff9ea232090db72fcea6e9b91d7175eb861be2b09a199278e136fc76b1f3756a7e36d390f79d667bec10878e65a768aa681b5883a313a220e8067883379b6b11b39f57af00658c84e153eec0e4770a0c362954740b12386daba1f7310188693db107dafa4e5f0222cbb22df98666a68760b2c9f6e17aea886183fdfac0911f8ace04502bdca5250ed70cb458be01faa538455782aa159802e62865a0971dd9a499587a705a815f0f0a182f478f853e7392d4d85cc6c68e62e162b21bd35790dfabf3e77363d787b308c9f8d3672c6c9176427c9e61aae7d6d0b226178fc4c76ef8a27b02cb3c321fae898276d447053125eec3be3d6af2770645eb577e6aa818e8e7ac69f0fab02f584c993a966d702d842efab6f8a67d3e79e7e5a71191edda3b8937e34419a0f43cf7599861739ec06ddd28bd529e958104e0c622220fb2cd5361d251a84b6e766cdaab279171dba5712c1717fefc0522e1365a2841671a44416d206acad1718a994573e1fff480735f91fa4c1978ef5aede6397e039acc15c9851dd3a4f504c1bf465226c378e97a1b407468f8dc3a7ffea2d7dcf2e743a484003cec747b8f386fdf25aca99aaaf37fe9bb0db0792ac96c518c277445c8329f4daeb980897e557942bd16f5e8f7b3d3aa3220a21f0004a85d18ad7987e5103814dc6bf18f3934005767a211677badde7df7a163d85d27d12d3dd691616407fb8e82f9b8af85854ab4cd92e5f31e9ff1558d22274292a9b2c21b0fdd1d280919d79cee9ce664c94986ff9f658920b1f9c30248901357be8fa0f085ae0718097700b7360477694b63ffcb5a38a31b914ce1e01d6b5708a6d10fc6e9b0cb172b206c1a8b03c3bca6e5b3de981aef0e5048c2e18e0e971400fee2fc868a4bff4ff346e95c96847b8151030de90c69517b961f5d04b77ecff0b1c3c860b2429f730555a1e3af89d2450e72402feab122a69ab68f9386ce73f9b3e9570a379eb17272ca6c981415575042031dd41635cb296b49200e844255c5f4b2973d0ec1a9f50acc99335b440d23dd0f38189ac39c997f0364a0ffe901372c4eb1c7a1253012f78e6b040b3acba9870f6e62b0746c0b40c599906e4d9ae42bc0980439074c229a6fe7083312a863decf617acf54af2959d2bf43686a60931265527b23d23520326605387631cb5fcdf55ef6af8235ffb14ccdfb79d6b5841ed7bdb562a3fc84573bb2639c0575300ab74caa82e53d53631b88eae697095616cfa240ac57d5213604c4be1e6decc9f4c90d0316a534ab82f3f9cd3d91e382e656fc9ebbeafd5c0d29383981700f4ada19205ccc077e2387652f7bd4c5e99ff6dfb58e88a0d48040c55c2fd19e8669f55256ebc7b6f434900510651a6ce5aee7613258a09a48961db6048e93cbb16edf71c4dd0a699da2756a3db93ef6c0575465150ce5a789b39d518ebde4814a274d8d1b38c9d1975d6e0852f02ab6ac9ce19255c60bf8a12291513f9dae6641e4ddd742bd0017ddbe9d4055bbd0342355bc3e7af629cead2b7d4b7da8ca5a6a08899ea93c661fb81e05a66b4459ab1cf688e621e03f647ed63564d978b2a85ac479c3520fd39eaa1228ef6af39afd464786001c760ae6033345ad7de1cc3793b149c91d70507101c53543cda7cafc9fb1042612bd33c8163b00d521972b01f17dbc16d02a3eb9a711e7d4ce59c2195d13bf713857ca0f9e5c2a406ceab4db80f099d21c8a1a1fbf6f3de80d689741258c0ed40042712ba0f60d1fbbe1e16a04c11660c608b026e2b0c97fb920f1fc26eb47db5c044550c6ffb540aad8756cf1ba09ee566d696328c6a7ceb024d735bb7143ef83041e4666b0f62d0f0381998470d19360c51a492a58f4194be94a8aaeb293075795d85c8349506953d8015bfe685339a4cb34a5335cc88de9b963e0f1b98291af436197e3a6a96d1db626748c5a543c61a56b7be01cb8877e7a075b4bee0bf873d47a969a5beed01471e2fece61e9ca4e0c168c738fadde0e0a6b17c3f16928575fe62e69fd4bb5ab0cc143794877bf86ce241b3e866c3a0490e32d2fbc8f8c96c04830d4c0dbb5890753634a3d0bbc6fed332df3476523bbb9db7347b214668da0afc173129544473b5f3be2968a2448cc0d18f6e75ce9cab583e355926e905154e387ceca9d67139b1882ca7c71faf2ee9fac01f7126d26baba5cc3e9a059167bd3b1e01fb54d71fcbfa862a8673311919f4c0d63fe358e567d0c8ecfa23bc9041279c07f997a165ce97c14613deca1a96d5f3305e257e8394f54c3e459ee55cfe3c08c815a754dc340aa60e5225571597d29ae73f8e7fcafe18bd71ed79b1775ef4410b97a530662d2e0b3d52af1541fa74480678099bc66ec21f02538f61cf3ff9c4971d25bff83c71fc276c9edc1b08339244b3a085f2d3a1a43e3ce2d82399ccccc58258af7d1c11bfe0a837e93b8a23e39676f62a82ef5d95963fd06c0de6a98cc30fe5d61fdab33cc513b865233c9fbf917bdb48c96d7218578ed132deec719226b90ea54b7eddf355ecd2e6334dc356b818f72057eab3ebe671252f0d3f4e9cc88ab98ed1e4921904cc098c12cc20cfc0d6120c96bc07f8458a8c828a30ac5036c534185655dc82ec8039a45f590f723a163d3d7e706a35646506a5543fb5bbe5cf05fffdd1226e9d0239d81cef27c60c942b2860f3f403113a728c1305b64bb8b3b88c79c4caf0981d443afb3a7243c69b884e95b5884c59ac57f9590d6da1198516504be1cedf942a1f360efbb140f2eff372a3995fc4a8d33d3d3934e3cfd6bb82f70321a31df06a1d1d14498d39c54b7e4c89717e1f5e493ae807b2ef2a829f1812e5aaeaddff013bf7804c7d9144c57d5a1186bab53d30daf4ca43984425b7d46b4b14044f5cd23a68eca146ad5124058e4c810034af54f7353408c6b811a414a324bc878b03144f9179255586a41c3c383b181f6bc05d864cd300f704306a6637c3dc6079cf0215568d4f8eb786c3d90d37967a335772344a301f46d97c60ad6941ed744d644d6e00be7f0d786679eb9c9c6627a061fd6f791ac5c392115f245fb1d7567b08e7b23bb0b548d86003e79b2323a09aa796b67f871ec3282925a30b7a1955d8593e2b0787b9fdaf58fbbe16f6af30bde1e8f7ec995ea07e2f51ea01990db10c5ba8944c196854081835eeb858c39b40f9011b9a13a026ef295a53045f245ba34719dd74cf7f56769f1c4184212ee548eed1a97b33b8de87fd5c3f6fbcb3b36c38f2bbcc9fec4585ce73796fc4b97445d9aa36c8892ac033a40b65fcce106342b4d46380ccd4a3cfd6d85075d5a56b4580dc0ae736ffb94b732a311884a56434240e5836590534df0bc3dacfea9d5fbbf9b40f5283f59fb5a993bfd4d908e2e9c808629a8f79fb8a463612964986dfd796d78712a0c9ef70df78e252ab2a3f8da4e4108318241505ff7915a2f92631423d90cf3aa496abe14eff923167c59c7c7900476d0a0686df1104e7dec69a1ebb571f1e2736393b441e5f48c3377a7d2d680179211900bb2855bdf55a11c8eeb6fbe72c9c42c369e3537c50da3eaab6d41a3da1da903ee5be6f3730538e5938ec7447fdfad59e39a3347cfb2ad68f95939659a4bbc012185f30190fdd1ced214b7b704c8b67e4e19ff2c5da6bf6d8b4d06a631a7ffc7b29bd4bb837cd11806de6083db4e28c0dd7c45c693db466588722c9408deaddfc443fc9fb1de217a944c4a1b42e3032112084a4c1c5c5e442eb7e42df77f393c4a47b667279abecae34ff893cb2c5333f570c55af45ccf881b2fd86a0416774b8f13df8d72e0bd343996af8147c0efff8a0e0b2c535425342c94e431e024f6b0473308e28d3a867e895086d1419695f28b9439bf7cc5b5ec8f883936c736b44c570f3f6bdee975e0baee751e0313e312c73fe05d2aca421e342109c127f7a61696058bf2b457433d888577b4ea480c701141762cd7bf0e3fdae8300b90ad309cda1788df4e62edac9647b0af5991e457abaacb8d19ecb6d26936de1103722c78f9711c5b8d0d0f77528b9270c9b9e68625d9439e456a275ad88cd743aefec2b9684d2d8c4c6eb1968015428d7385a4c70b89912e714e22f3a4e122555f884db67e556e22e2a050b7c6b47dd757a79f8196b14a066ad4258b3eaca0e16ed24a07423d5042fa9032a0149b9b016147134d8ac2d1cefda0b80f75e1a9d004a2485fd2c4a0dba51ae48101159ae2b16966a4a925279f50c842d2eba1ad5f34ac635a70ef686eca93b4821fc6a55f5ad2912e9f0404fb4a70844934a4c83e7ea85d90c9e84952aa0f499eda318402926ba5c7f41004e3fa3da54e18381405a9edba9ece7e420acb34bc3f22a155e50c3939f992e48b4b1d6f1f3b6dbe1a41aa4ec2e24539c908aa5932e6a91d2c9de30037e7f8a361fdaf8010de8bc902bef0a6e1ef70db1955729d50df2f1fdda155007b6bb455f83de8abe3ed0fd2617246ac002cc7f2119be710179a1af5c41495da25909075fa0ad701d9fd350a0f8e70e53971142a9d8cb6867c9ebc1ea62245721933290098dbee9bf567ddaf7f84e33178537a885ee986fefaf9272d407989b2e5bdc1ca0a872847de9dc8a8b0de8c7e0e30a2bfe00168bbefd3e02e94ebe43ff09fa4e30a2e6e28555271da520cf9b2ba7ebfa9b8a9289450bf5c1363678c06dab72a8ccee332e1b080c0dd33432af2c07170348eed90a25fec98a62a59107f9a39809fa3d1cfc8997ed52355e2a52cacc35dd7cc72837bedbb8f0ecd5e79a729d570c6127150b1917be57a465ce1fdf594b2b34e90fc7977110922399b7409b03d517047367af331dd3b4e09a4f09b4d1d18191887d2d550cedd4cbe522147fd914ae62c063a7d170be82ac9e2164fa198a88afebc32b42ae2b27b8b490a7906fe90d5f41417efdaca9613e97075077f077b8aa7b08f30d47dcd42e8aa80b93082cadc601400fc5cd910d152bfb5e2d8bae081e520cdb191ea7920b5cd9dabba3336a245f66e8ca6964f5b35f29a16cc7114aa699db8b8f633314fb234c877a2212ffa28352c627a7f591635c090fe8428899d03018a87e47bf42d29e67b2cff36c3d4e300899c851c267a4c8076967a368143b64581c4023ab73c5d18cd57b637d7cdbaebc1ba50bec810ad5c1099ff73eceb2930312d73b5152fe8261ded15a170695a8580b25a6e2fc96915f0983574694a4c407056541e2a8fa7d819f65eaaedf646513591ab1262161b08800002884d2e412a42e99bd2872c647cb3de957013717394ec69cb09917d615d81e14ffe9c421807414fe61571263035d958c142266c3e938811ab1ac86444c5c801a14351838d308548497ff2b5354ac3add6d8f93106442c2c0ea92722e025254d370e7016434a6d3c43d0de20083cdf562308689f950060f4cae394df561b857a7d4c48cc9e4f236965e50a6ba5a211da9adaf43538914af6a2cb9301c9595e440098b7976b7602516e752e0862837318a58c6aa8f795bb9b4569dd89ea5928b0de28753fa3c8ca8277b80c073196c2f981c2839e537b424c88f505c39780a76b1260c324011f9ae85d38bc007e49cba85773d8a2aaafdfb5471577d47873d73f8661cc667775c5c1d81f7ddc857ff914ee00a66110f1a94dbabc83fcd3b525ce9342311834c2341e8b043661aeaa946de3d289a476f6df9cbbcde9cb879922a1abcd9f4c59eab1927f3b8cd98291205a8f069c62ae296738f978ae1486093ea7b55e061828fa0591ab5b946191388d2bcd9b787a1c80aec021bb0d815731331d4879389d133e4b0c2564deb1786e886cd31b7773c6aa642aa6c259f131c6f5792b4ec557aca3173e55c52595f9f6ad32c738150893c1220a752cc02bcbd49a2bb5db1977efb55330157e5cffcd16d19a5d1e8ecb65cd30acae7ea5e940c5a3edbeb4330149087f5014fb6f19a87c0272edb18cf64e3c81f5a034c2858884bb3fef4c3ad3ea000d35410d9a665dc56801c010f441046ed543cff23ad630946c913c3d6142e99c89c5ff6dd251afa7dc11473ab0bb4c41e5430429fad7051a842a4a7a4d841258c21548f6ffd29a898c3a8a80afe2283e2d3ce07c029d01049e9b6d0369a617173722af1c1698a5c2b4e10b96e5291d1bcc305f1f239a71e78fccba261fbca50b35690c84de91ec2c102bc56c969b4bb5acaa9fb0efa760298fd816a16c74fad22c80f2c93a573a0a5fd382f2358cd2b598328177e99b951931ff7b1ad8cedadb5f9667775806c01a68dcd52150a360acb679fbf67ef78a366d63094be4af7192fe0bb962f3532fa39ef5a5caf7b410a21fa92a78e8f2e1040dc378823142aa7006a936dd3cb337d7a7aefc00c37f93ee46023465c14b69ef65a85fcb10d528b3970aed77b72ff2683ef08ddd1051dec6ca8659304f6e2cc72e451d4437bef6347bbeb0ab58972d8f845946490951b64523252d5658fb686a80690800cca147e9cd6f034d61b89ba7e8848664e8a6a5020c30699690066c39c1be917167b917bdb5a5b7304b06e51689eae307c42e7a7773d7accc806970f638dc9a3895db5de5d2df2950a59555c05422b2b8799b14d9f6e0c7f558cc2d70b17a6124e9a8f2f2cd57a69c5456814e82f2cebdc4dc5504ec407e0ca40d47e409b349cf30716df41aa8531045a9cf636b82680476e9098846c1bb7b30dc88f22717dfd30ce77612b49035003f2d6aae9617c05f8c1c39d9f53992cfaf9cd70997a75877d6fe69600202431568bdf3e01382f4092562e9460729260fef75e12b91bbcf27ddcaded63268a4309881764460e4bce5723135b4750bd2cef8aeabda9543659dcca25e380b23e0462d64c9d22d26cce4903023719c01785c6a57554e521c2c2196be6ebf3f6e2d45c5ab9e85df420a3e6e51a6cd13323955544e995845761a91f1606a9766b0bb04872980996ab5c511581d4f933c07c42f310aac6952e69464f98f3f158638d17299a0a75eb3d6b88413531ad8313a9da8025c14bf4a0a144d2fa5320d5f48106716e6498a7279a234ebf2e7d146cdb4f5949e8e2dcf39e99557c5e23b14f8fd44af404420d65ef3d31cddbdd51366d7fac8c9c2f621c70fdaa560da6349da9e623e6380656b3261f700a4b034d6581bb1058993c859e81fb41ebad349db9a598710ce827aa99815f60f019eaf25f7f7e9d57a723bc362b37b9044ca65bd15dc189b9f97796c60844cbd33b0106e11525ce0b9cd7101d1191c7b4a7c8df733935beebdacab14d017b2773d212a9999a5c8718df9a8deb38beee073423fc962b315ba199ddd5efeb94820e9fef176aa3dca16642bbadbad8473104a8a70a28b12f2a41f07c17b9d84d220b70e0fbb7567507999676cb132609af9539d073bd8a82232b152d30cf61edc95eb9762b71c459afe74f38497018ae43f43e5f0cb25e9945bc6bd413f3ee344cdd811186e8ba1f6c775636285266beb017759154130ac334686057e80c54e4feac4741393797a290ee8539eb2f33efd9d26248e3d5017a65a3a004ea0f93719838fa67a1a55213e1daad1403685518c9701e9a065460bf9c918e2af7ba0832315ab47abf1713ec804813dad7aeb99d5d3f016b65ca881490515e52d4ce9b62bb2177f0ab53e223ee4736af6f6c48a9f0234656da464188cc8decb2ac2cefe4e91c328ed465a8b3e1f91649f0e3fa3a7d326bbfb3248a7aa44ca30617fa5f32e1c1110b0678796ae9cb5a078a5232a710a050865e1ef93421d84bd920fd964c927ca9dcab439a75ce119e397994b4257e0ad85574a1c4f12d1f758d796626050000d49e1e9d739c1e70b0004471ce07f77dbe2d734637ce424244d77f15cfe84957bb260aa68f49ce77c7898d39b165f91d89b2842fad81a917692745cd53894def93633a4aeae3219b3d6853822cc1cd8f03fdecceab5dc46956a053700820c41b9f5a34f5a90f3f4b4fad835808b2978ded624b85e61f985825e5179a09037f34f8d6638bfb1776412718bf7f168ba2a2380b01701e88710a0678a13dadd92df47ba294d10406be0677fd3f1e0b468886449aa7869421f7cf3286c2a46da5303e52ef90922c996edc1c56f6dd4403681eed90f23283006efd12cc2dbe173e530d059e93db41b2bcdf1b00052d8c550a9b6f97abf2aabb95e92df7d706de31cae91b2236efdc4efd0da9177095862ccff427383fd9c7a028895991ef549d4c6310cf7fa0706d82183f2e93dee5f1185a72eee7b32219df3ba26695206ac034f8570508c352136a368a3ffba2c8bdda028d94d3c57f828f8aa07d88b45441a060afe4fe19261bec9297208fc5a3988dbecfb96073ad208ac5a0f6f405f8a74738f0bb26ee404d2e0b4635be3926559f20a8322978f812151cce847aa84de1dedd3459f5404247feebdb0ec5617ff32dce4cf016a70f17b426067cd80f6533b309ff136110a3a0166cc198085d1f258ac1e19878de16d5a11a714a5313ab9ef23ee6bfe9480158cf0da68f9a0ff29c03c1aedf3202a7962a3d6712194c78dfb39556b3f45ae8e57dedbcc218588d15bf32d8d338f6be370f71f0733d763efb6ce6e8504eef68d07c74e40c3eac2a59fb2efa3b33b62a39628004c7022dc3e52773ecd3bc7d5228e2b5446d5e693e335ebc1183d53e1f92e18f19477fbc9753b1cf6841a495757f509ed89d4e826234973f8a74313822ec368a8601b54a98cf79e26714b00bdb2b63c80b58c163024de4391231ad2dc7cd540badd1fc3f70f3aa15d9e98e2cbe6bb3b42d89423b8af22c4b4a52386985a1fbc8dec57c457b2db7b8a852d7162372d391f86657c2560d252bfcfd42daefa182d550769e5cb5f1705bc094dad3443d5604e46ee9378809f6d7e974bf5917f963618405b48eae7b8b84bd99a9d11f9dd09bc0481e819b3983ed68d8d6b53a75e45dfc784687c6041afd9a046394bdd270bf2b2b9ed3fc58c303de0d2867cbe591b1a9c041f3ef0ffbd5750ee41569d46af1ba566cef50a545143288ee858eec7018790edcf8a8401d6ba65586b03ed963c033a0774682494a23dbcd7a6a040816a53b88676e57adbaee7ae43069fdad83e14197a1738fa9f15211cf61890ffbbbdbbdf37b8e7fbd47786c038c5d08084f8700f5d07e7afb258695479b8950f1232243c0511fd21b6abc37d4a65cd36d691677e6f085258d884b99fff18ea5eeda198ca820aaad4c4a29e044e8c38c3d98d676ad0aecf42cf1f5d0bebde557c826b57e7f12be879ea4753c1f39ec32efea47c79a44fbdf288959f3ef8739a35a5adaae7e15ae447672d76939bd5f7d18efb7283e0cd43b6ddc0376238ccfe09e1787c69a3995c5bf8ed579f098292c4b77f7678b865a0fc994303933e49a8b1e92216b77f5c02a53cc275b605d76ef8b84bd393a3eaa2ac7a590cc487265da25c4da9ec3cfa024ac73a2f4d66ddc01cc0f96b25a86aeee752359089a680815a1926ef852b5a54cdcded59e3c005af3270aae7354b34211f55bccfcdef24488b692b93c8e78388c24b4d13d8d5f21622826e5b8d2d9f4721724a5e05dff393695e2ba3366699671e56509f738897f49791502b9ec63a2b0c5e210196e85f56abc292738968f7bfb8595c1377a5ae0f0522d3cab6658db1c6603edf9c975829a826f14a2f8d29788a071fc97222cb3eb02b1ab2bf16e35b1d438635a348ede89d21df1a85259476e7fe85b5edf8c92b25fd21ea74a04dcb6dc8a312669ca0b0aed84034a70ef90591a01cd02bcc0fb9d618eb0afc2788e719293d85078fbdc907455450e1a53b72b98d14d4fd1696300325e24eaad1cb4b3cac1032d4a376de7c8c0a52434f6fa1e779485eec5225c45d0e59e4e80d18edc13c1c61e6fbe65cc0674ed1357300991db4faf1ace5d352448454afb90f529d92aa6f5d59613f32fd8fe19a2de964b9f7bfee60903d9d582af629050fb23d959c3627281d83047384dbcaad2860b055f64ab73ddb43741039aa11565774169287e04f919dfc4a90bbd8c755aad0b2ea57420674700952951e415be5338a483f1be14ec477bb54965010b5525d79f45cb03a17eb6f25d3cd15f7f4ae2fa8e73bee69322565970ba9783dafa91d3eca6a5965fc27d84667260becc050182ad009c70507f86b2bdba27c6e6cc455912e2984403f6213e50946f454aa4655c6e8b26b80ca6bdda90e1cd30e61543f5cd9c23f536af45af56d8efbd61ac7534d3a6cf78e6acd056c182d9d8b964980dc83a006317d0e2e72044ea4cc9de417269fdd3f563ab58afe8c1ad3843a5b98fb385aa7ca86220f788e58baecda783cf42e184b9f4c3b99d86ce063b069b9939d14dd26ba584b74ac2817f3b39deb70242bc1016f667701a451c4448ddbe6a27466f2d96d195993aecfc1c2a9ef06ce2bfa6197ea48ca2ab87f06035ce7a5eaff34af77b6764c7aae85602162df356dcb56f810dc21aeac42c3cf101554665e0c9d54376fcd1e036d01e1e6f7efc38d546b5c1c21c7ccf96c5d1ce6e8c990e61f06b23be7dafd58770b99d9657d7daadb226a1df2d41058537ad008b9d7ff8ee2aa999c882d993cabc0d3a4851566d65a7ad27e9b4fff34b4d0b1eab131e200e7f493e1b74f3840d54988f0692130ce1ec56919d933072b22182c15ae1c4906f022eb6cd3108cadbb0ef005942ef1a206a5da990a84a22593907148339081d7f45dd8ea726cb9c4d74b59faf804db66bcb18a70caeb6df4495dc06cb2fc89c1a679d1af8d8aef22ca743384b51ae57368000d462712945ceb7e7ea15e12f5147eb1aa52127b1242080b79c4769f1be092eb65c95edfc2fbea8d0abbeb561881c54ed9f81c2adc40b7723650e506ac055e4bba9abd16e7ed489070b9b0df1ad9199022544704ddf3e9a50c671555533f6b75d38e3fc61a7231cae8982bfa2ef7aad5fd1d9398434a6f3c8f47262738260408b881058773cf23440437940a7784f4d2263d0ac8347bb2a8717f95f77b4faea0f914e5afc95dff9c46b680ae743c0cf0cc3b14e34cd8004233e365a3c5ecce32c09d6bc0699811b4bf3bcc498952b21323f5d216d2c255f7830ad18e05d71b3e757742d8bb8e83f426b25fce57744fecba1c236252b6008c8798ca5dcd324dc21e8e9d023449cab582d57dbedf4b3468a170dbad5f805b7528bed54b349eb70f700ade9df57cb1fbb3f91d4a0990d7d5f1c7893f12ba72dcc7db00171f5689a8fbde519d127202c6c41c2d3160a08879ec4693ea910a964bd3e95d10f68989414b8adff07790b024e91be52eb34f7c962143c0a234d2a7f561636932df2702f4d7118f3224e64e7fee761f40e15ccd0b1c7e979fc233ad0d9919fdcbfcb775694014d4ef7825f35db22e17cdcaab403ad4666e1cf6cfa6100fadfed93776f0bd0da3cff1effdb51f6c1bb409a2e699f22b3917205660eb7d0ed3f7902f40a6e402b0d2828de6b3fc537bdd2b05e6d3c732d55cfb495e996d25e400029d8a1e4c5017744edd613625d16c47f075de527daf68fafa4386a1961a9ff5e85736ba570ad4481b5adce0f99fb523862237959ff92bf548e81b8564eb726cf0d428df8deb410b5d22d8ba75e2919a4e504622212f9b4a44874d3b5fff3fc94cecbb84d19822537e1e8df3bed18beb9c469ced00a4b70796e2c312e34227353bdb4f2845477d461a1d2cd2a654beb297992a04021dc0582660588ecfc6c0e6ea15757c3145ba518a89d02ff1761ea280673c84a020f5d863d8439d8910ebd61a3db047bdfec12cc32939d617a935815a2f25c59b06cff393db0a29a7fdec34374921c7a9c8458c20ddbff5e4c0da99ec9cc62d00f9ad5c3749473cba0afbdd0cb636ce1acc549d5c056639b27319f83faf6703b0c41cecec62a28008d70f839282ca82a822b5af1be357c46cacc0c808fb2e8d26f7aedaa9ce25602ffeeb5f9cbbf4efd8e6418aa2e147036519aab7d6e9303d407ba9dbc002cf5c96b8f44594fc16f46066f240396b7c455ef070fcc92c81b9abf560d366297af65b5ca54b607ae84096339ebfd8c0ca53149aa4e56df8bdc3cafc06cf3dbd75a95c58fed6ef14527cb4759e0a7a4f86edaa0b0ca6fa9d72ce1ff6179ac0b5ac1f99e9502c7fcc4048e86134f70135645dc72780ab89cdc4eccd8a0fdc5f8996cd6dcdc4b85f94cabaf68f662ee212fabb7da7dfda5924530593093e6d8fdf6912f93942a275592c2018502d3cd81c140af07247af6c3825b1a881216d2bccb8f457d99504c207a1dda5a3b4292686eddfc461148bb8b80dfa404368c81de81d316796ad307930ecb559e09c58164b2584cf19cca42a4c8004ff72bf4922f8272d55c0e01d739580cd26adb53382fe8394b11f2e5f25c690cd5fb6cf2489b1ed6be38edd617e93358107d5e540d24a87b5604d770e16a6ad581e9f5b64ed6aeb20cf97da41ed351f0816efbfcc62cc33b38d0249b8df6e0bcdf3c77dfd477ea8a58ae48e7a239c457d8564284663943cb3eddecd3b26c459374ca07f795ba2a33a64c5278ef5ee14410197b59921d1f7fe3150eb54f31406702e216fc2e93c2be1658035b147ebd477137dd67b19dd2581f9d765f8c963ded3efff73ff73104b2aa43623b630d25d3683f00266f28d6800033fbe658f96bc466c82a7cc243397ee6ea08f19c128e6792726d1c97f15a0953458d60c827d2a6575bd99799550527274f4f758dd5c692382b2726ffb1e156875ad56406fc09eb1ed184b27d1383d94860d4de752ccbfaae4e06af0bb87b8878f4b69034503252ed5f59ec5ce4c27ad6c4685cbd2899998452541f0200a11bd5fab838f64856908723f59da42fa7b808896ff8234a8b3e6a56f4445dccdc2b4a8e91ac5972dfe00426e464d69da8a25475f110305afd39a6aaa6bfec5b044e041441bc30a023aa77b8847483242aa6fe5319e41e5810c45afbfcf47fe769d7770ccd0904c531b108c02a42036fe73a64e3ee02caaab8a005d2a8da0eb065f6629d4bb24aaa234a6f1848b779f8cb538e96b5fa3792dfcdd26f1859f0f6ef012dc7b22dabcf8a85bbfa4b04d0f408cde893c7f57a82ed91d3c24fd61a442cbec62888fe93d6458415cbea3d2bb0ba5deb0ba3fff3708194fba1689638a02788f97cde57876fb92943a020fb1b826717b51cdbd91255af94953c93fd2a98ebcaba4474cde46522f59529723ce18f5ad14e9847d246ed0f943150e6c09d5778c0d26528facbff61a26214e670ece827230532203a1c9424c90c90d4c9446b3dd4f0bbb3d6850a817c0e61f515034e727fdcd516fe2a3272fd6563eb6a1ed09730359a2eb53054dcf40d7580da531104fd2ab268005641d7d4c2c014570b3210700515ab8f5e51194d791dd9e13fc6deb6a14dd0da4b702a33270982b278f2644ea6c8938895e01e578ac663e5b1cabb0a74ee297dbd223c144047bb3d3ab151371b7253722d8cfaae95cefc707be8812a7a80b3ac1ebfbbb0b90f0daab8a5d53f352a4776ab96042fe221d5257bf86148a07f6a159da1709e1750bb5cbca4aae34bcdf10a1ac90c9c9a08606d08b6ace9df133d9efdfbbcd2d8ca09ed667c36c83710c234b70a2e71828f7ed2b703f08221ee83a5693f048f0a79bb3bc2582be183d09b52e0d999079be02e832ba5f3144b59732065651101781028f6e74d6c41fa07bded1aeca19ea8945e92fce40df9fedfbe1e2258ac64dc3cbbc5e5bad7c029bc9f88ba52d3a740ccbf40767a5b5151d56a76d077939c98865735965e6dda83854484b9260fb8cf10e37a44930263cc3825367c3af86841f7acfad4facaa6a4f2cf287bfc71301c122ad8a98764701d139b1e76787c3fc64b894fd91d5797b01bb73eed12d9e2feb25fbe431fd7acfbc26909958c5cb5097de06f885edb30d91f48d733101697ce502fb94373135be7125713763ff428b43560556bd33232f48f1dbd0e8a73ddc074e9dede2f2614ec105dd04f5ed716e72ef096e94bbbc2b28e36316a96664b73abea35aa2a0d2af60c009d4c10c1059463b5ecfe73f6bd4ae361cda78fe4955de61eabd8ecf22ab55f4aaa0bcfd989197539c5856cb0c94061a99cdb2a6c0bcd7420f8778971d5c15bd4912bcb03b741d2ed25a797709642e791138537dadc824297586a7fad452c94c41453fbf3f4d859616eb08923b3c8be809b605a3d9b9420c27137de341af78eca2a2cdf7d63f2a777aaf649ff0f21ed76ac4d40849c5aba8569b572d95a34c9af0141c3e3903a9a2de18f8eb78fa8ec692a2f606d4c4786dcf9b66d6d1c84f03dad07ee2b375d0993043240e9c30d90523515b84f150172091fb42ec7eef3c2f69d784ac917eab738509e9697053fd25758ade78769fb991e4f9ccd74b1168cacd3ebda523638e2cf5308dfc66f9b5fd8a7750985c50c8ab6b9d881cf507976f590802b2e4a82a08d25ea2be31ac1e38fd31aebac1f0474d0f0b20bad72f9c70bf9652caa9ccdcd09d6aea715678c27dc7804cc1a3e9ab134c506a768d8173f99cf7104b04962d3087c0297b4c7af790cdb7fbb94e28db4b37cb9cf66a6504073f2703f79b33ba7f41c4fbe31d7e62eaf708d62eb9cc876699a86aea71d956e13618d840b9dc3888e017c1fbd8420b10f4e55f078068b36bd8ae6369b890a20836ae71ea3d0bc1704966974abae237a31180527ac5989b5f0c60bbcbd2afcbf00c3abcfbaf5ba20861d2901759d403ad3095e055e9efdf832ba6e6aa43bc44cca86cafb03b2c80923d3e6867da130f9b827edb1984cca69d36592cdc05a854ae80ea29995e704ab1d4c417393b6ce27d65a9c65972643613be5e9f380bdc8bd547c798b51ab2d49832e41cb64663a7461d78e27c7949cd7d43c82b1d4a55e5d1ad1443dfd9a53561733b9605231daab8e4c38de973a37eb02687a09450a6c2154b31251a7933b9fa38aaa1853303ead81a9b94c6e03e548d8f32974bb118595dcee5cb8b3d4b93be460e6a46e5020f7756d48757f81b0fc23d5d285285f6cab271980a174e988aad5007ed1900f6924815d3cb74b0d933adb3f914ece39120d06e4b0cec6aaed1624d89e6a0c60352e24b61f80907d7a64563a2b6c56377c19c439b2864e295d658f0931a75a0df3330c39c1cfe11f64dd340f4278cc74b52d2d0b40fcb0364256219d1bc65028c496a0f753180ee1498499eb5c13dd5f5d350bc4ba6b540b37c0f874b06a058d626fded6abc68752183b95fbc2509473c806b8e45890f90fd41d02a4a509083334c39a7ee409342f46e627e59832f03f1ccf631886f377d4a904afcc5779dc569af40ce5943e307630014727d7d0b686e67e79b24896e68b95f931aeafba680f0bf103a45a2c9c0a7ae9d6ea8fd7eeffa1c94bd4966574427c8a9fb037543178aac759ac1a5e21b19ca7329c606c66dd0210cd7f86a7f6475855bda9d48e725e7b6176e061234866aa6fb23e8bdb7b7f3fb9a7d09aa04e27779782c2c460522c42f7ce21e11e6cc13ca046e13e0da95873b4cbffb9278a165c82b652b77384d7fbc7bfbd49b935cc905594cd2b61adb81b9c30d4fcd4a21350bd121e1761d642ee3ec85629b1e73b04a4bccdde583a5ee15386bdd9e3aaa7b8a1904aaf3a2c7e295c64b4b4a75683639867d3a8f6f02af7b1df85803dd6a85cecd8680d5d14b016cae4ab58d909dcf30d007ec4d19cd050f675f41b5c78f8cff98be0b39f4fd2c746abde2cfd3a99bec4db535b773c91cfc634beedba4d9316bbfc38788e5ae1646093ceb1e33e0924a04d1247a484ad25741dae1dafbf8c904d5fc2d5351535c986bc1b90608d281249cb138c49a72310ee1aab7b218c442fbd80ca0f17bbcc585a2f751e69176009823c9c9909726797c99e0fff242789a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
