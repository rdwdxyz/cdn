<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb8ff3539496a1f4e36535ee398f0136e2e986e4a5b387cf5a775fd98504d62dc046ce7b753b0c36cd689999e256aa531085665358d1924b9980072092be0a614ac9bafe650cbc0d407aef29b42c7c106028546dbdfe4e50d7927d24ca6e4cb0771f514ef3332e50169814aa40aa4653eaef861a1b09860dbb0e32318a935f0e925bf05cd0778e1e356fc3b225031f620b88f7f75d8bffa6337c9b3cc15f654ac6d520ca14ff8b71d41bc2ee738b5ad2437af0b94fdaaa7413de97da5daad08c8cdc78ae97393df95f932775e8a0dd6b808fe0676b50d078082b2599c228f6182c47c21c6c26d4c5c12c092709dbbcee0c51f148e66a4549834c21459786f8420e5c185016adb974df1218cdc5b07b90907b4b6a1167a1cd813882c482ae112315ef91c264fab5bd3e0c48d6eedbcdfe56c158444449a61d195d75ab128a4eeacf9cedfe8a1bde911bc1bdbdcada52ba5e76a5d489327b8f311bfafcfe4679614d83cbedf950fdaeeaebbb8e2a7bed4b96e2439557e286c63c41a53f42a3c236461f8768e3bc860bc9fb2ef59db496c48a3d3a829f5847497e771509d4b7551c212a560e69de564a8c3a67d06f1a749480d02bb60b27167c8c269523d911a937f2787eb9721c161d950b22c77bb36fd4afaad6b94012c510f8e3c8c0f2fc4f8a3ae75882ea22614166531838c94582a748020a83f6f5c5b14421a710cf88635c97f8a1f0b2b398604a56c40857b6e1b04557a4e6b2e126e251fb2d6bfbc61ae0f2031a81cb7ad84a822803a7f336f512dc0fb3060e7645a343b0217d2775c23b8e2387c200338c36fea901ff60c993b93a849be4bc19bd2e1e04fd2d6e43ad0f117f135f906737e1a6d19d1df8022844d42c00f22ae9abd5ad730c20c22186b0e840f5d27b0b75052feee85eca3aff489c1e7ee92c3571b668eae61a46e9e998f5c78cc4461ceb1f4ea1ddced1d6f2559aafa4c7d1bd1df3c82e4e9aba1708f7cacb3b05bf7b291846ad7472d2505540eda1d925a6e530e99bc15e4f037a61888bcf01006c75ad4cf6280ab60638e47b5f2c38d39d11fafcae886087f4830691e28f9d2a992d1b3d3cbc5d8dc0ae21441c034ddbb66cb74400ebab7fd23c55added8ea9d05548f11cec5d0f817a0cdedff56e84cbe9c72e46298a8bccc828693aeccb464c1f615818a6bac9da42dabc4947b37eb4b2e947ccc1970c606b042621a908c4ad8222aef63b3f802d8d169c125598fa1d1b5b458e51d33c73a7c25d4250dbc50f4ca6da54378e8bc34e6a2e2c55b2b667be0615e79bfbae9c558d119798f67dd7704ef86fe6533b3258ef1b4f5bc02e17237670b5df46c348b8a3f52fe6efdbd359eeec09381dbdd3bcb0625735e34f6fba6ee80b2b01db1dd19e55839e5c9274e575bcdda130e013f4b136ceb3489dd45c6ae821787633da563c29d54602e040f14fd54e4df5438c4e88711e78758f4b6cea211192256152eaafe25b00e65e4cd8a1b8c235adaecf5f14aac6cd11ef679e4e6ac336fc619412cd74cdc772584c738efe97e640a9dfed53640f2c8a7165ad46261b1efa384adc96444d7f72c13a44dc582c0e6aa48874de2a952f25863caada0f049ab5902b2419c9175d8807ea935034064832ec3afd8d072b632161a9848d21dee31d6adf27959b8f503f9fea0f62b157dfb626fe738b772bcbd268883d7871cb9072fd592e6aef5512c4cb47fb4ef34f78cea7c09488cb00c3e15b607c527c7c632cf23ae13a755ef5696321ffe94e6ee1373f08a014eccc1486ff8a53dd01b8d637d54e7fb3653872b9527826bc5980db5eb92ff11a8038d09c6fe58e05fd2b0db47e8b932a00ec335e0259b44feaa74dd660ab0cd45cf3d9f1a89db1dcc957c54b98e26d124b6cc835ae0a25d230d8a4dde337ec4e00e0dae99dbf4e7400881d29b91a9bb19095b5c5600e59597254afdd2f18ebee53dc27a0c9f87320b74ca6ee306eb01daf4ac1abf756c3d871def46653c38d789cf87b7d868c7c071106c04aa4dc9f9a79f5b9c980d7a6f6bfa97083969739f0a2cb524f3bcab187d9ed2984089f7f2a9bc9efef5bb851d55e7056276ba2299f73fac0d5055e11b17ca7590279327772f831dd3d38eeef11fcea1a579366c1242ddc6d9bf2faf3cc7e8387236e9a44deb30d20263e4aa65fc6095e6b0e201cb6cd5d93b15cac5d2b5ea06937bbf476f3306f3fc33b5a85002512ba35aed41f8972aa003c3c954ad8a1b6209a5981ab42e83bf1256eb0d9d9d21921f3021a5064650211f1ef6cbc94f729b141ab1003f6a42513b57167c350dad062dcfe6b49d1034320bd191ebe1b48ecd5b234b4e7e14bf43221616f9ca4e8d3ae26e2b2bf52d2a082a25df52aed208ccd9accac19301aada54b75f816b0f20160cf0fb866775b4e3f5067f0676a42033a5ffa2ac6abd9cf4f407749eb7fe88993024d19fb4c271ad413c8cd86c20b5a2cd1d5dc8c2096641083463eebd6cdaa594b39fc25c2164a0e54c54c1c75a75584dc68a1f20e8e3a4e903275b52c39355f4bd5c91f63c409f3777c8112da364b9db8c622152b2a4e499b3d779edfb69061e503a155786f160457788c3bd00f6146ff33e5d726ddcac574e5deb7295544565b7b4b588be54a759926c9b0a06211987dfdb59f61182faff8b82230f8f5a3834f9c59f9ff85b9f1f7d095c501794ab98b7f84bf4fd1343f1dc2391440c39127a02bd35b0e3b0027f44e35c663727c9181ef53b027b5f6a1071687cb78fa1b7f902832829efe300c85426e8ae54ab1297d9df17c0017ef76581bf53889fb1dff89aa23176942ff97c32292540670267a9fed6f91715ee68d5752a020be5e15e4519d0c580281a2a87332c4281039d0301cc47f8201b14a96fa56a2c6affb201ef9e2058250ca7fce829f81b14d252bad821ebb48f0cafe78c92354d5239160d49668376fbf67ad53abdea129d4fcbf6e5e5dce175cb096fe62d3d616c4684c326a712e237440bfc1be031f8a4f4f8489ac65f50d457d067f568e1c88d8a665542b660ab0c79a6b887f5426dab880c2895e6c27ceb5c529cd150db5f39d35989bd862c16c94a8a733a77748d5a4937467f00bf984a73ba3d464370745df1875d5f5fd77bfd5ff7c45a5e7e41f3adf9c1d53a77481d40a1b89440967b91276a0c64d672ffe27c0738adb7684e82ca2ceb21850119a3e246ab31c514bb86e93268fccd4ccbb3700be34ba926ec7af90b373ba1451cfc3e0b5435811e8952eca9de2d002888718acf0c72e94e69a1c30df599c19572ea161ffee80769fc53002ce54c46f0c42b6a54cc9c652450e544b5c083d445fcbf098ffa0681c6ed844109f9e0af2038135318f2d4ef2444df9605c8000bdf499d889f1209860ee0bc3ad8c0fa27709ae6d256b208c25b1e3e1b320ceeddca4caf2e7c1b6378b1f7a5bbe7dd91402818eb782c0d52bb3c9001cc0984c812c057e404b2bb99885c33ce310aae0166eb2674157aa97b4268456239c24dfee3e15738003cac5e9a80ddfecf663d21e33253c465feaf03cad1b4c87a266d7adcd5e4379175f4230a7f67cd0e25ba24637db0409cfd9ae986c1ba1fdd50e4623be431cec43ece79449e735f8fd34b23875c0ed4daa3a106e92fe8dae9fc25603ef5975a1162ed73bb300e70c3267d69b94a2ab9d6b5726bc5d44173026834675fe48925f1001268fc58b86b30556b291e75d53e8b5e525bd4116ba09f17276f8871873617bd149935b2e205c2930e00b5512eb9af341c1e16c3b1f181c87cfd94333423089194d2642eb69509d51fddab3262221a56e6ed94a1eed8c91d81dd184b1fe9123628ab3cd7272dbda2be274196555cad0aa6c7ba361586bdd7a9dfb8fc6fa240458c068754719ebd0e7a3d6304d9b836007669e3968c391e85254306148255c1392324ef071d556f0d4760fddef8a42a784890b18280e37cd545f4b8dbfbbda003ce2cc17e30cdb45b6a33684d78d549e96113a53d75c10f2c5b1660cd400b86015023e1d0daeb85404f0482c2fcb828be13a559865cab1339f3cc728a2d9d94e9f448c7914b922105570f16ddd94d271783f1c51cf263f58a02cb8b2676fea6660676ad885eaa13fe4058b3a6f6d3274fb29ce48b6a5c77e585015811028eb0ef8972c81c5b46d0a792a910c89c61e07558ee86a4d2f016d11b7fa5ff1d511500c64a0e630070a439c0eec77aa4880ad526ddf46ad406e344f5a8fd72fadb32b21065dc46f6fc37139c4858c5796e52307a768de2e9b200892f21f177ec3af89e94a896ed060631d604192b40932060924047c10ddeb5e82e5e778f7b77eac70c448ccd35d9233d6356ba5ce2eeeef55821161814ad8f69c76113f9e4ceaa05d5a97024197cdf6e34a2beb3434ae09c3d87f095dde3a98f667ef608a3ba8bca063354befc99b71ca53dc73577de1857d27bf548bc61b244ea48aaf6d982c8c9dbd5a41c3cc0a530bee766fca59f028002fa86ca3610b04fa110954bfc31439a807e88cfdf8a1469398bfa5a97cbbb34599beef500e9ba8bd7b717213c3cf72e954d485909fdbfab1a406201f048044ebd8114729c42b87472a34a90dbb7135209c06d648865eed78b4394ca6304dd574f09f0f1a8189d56efe072385f7104d4b15b2a1e9add8ddc175e6fbd431d5eff84dc5357e8f65438720bbac701588d49f8aac5961ec2df733ec92391a3e36f92e7d2569f97027fde65cf64662a92e8584d69c3fd488994fccd8ca1ff9dd91abe9abc75b042ee945f775ad7141e14bc9ee30383744108530f716d958ffcd4b9d5080126e69d6eae497efdbda0c46f972c523b40969320db85ab1f2cd1fc010946c184f179f40bc9b81e5effdbc34acc51011f80fd1fd2835fc2e0ca9b2a15d9e3a186abe6a5bc9aa4c681cbd97d6c0b769c88f2939dbaa078b018512b901ba8e5c4cb11048d9bd235c896e0e7a5755fe90d5d0a2cd0148d42c0dc638ec983aba42eb0abfe70df664d8e87ae6a84ec89b236ac5fa4e158aa7cb8b0ee1101ba76fd2b3ff3aa5dee37c304ed8e59f6394a9651d68a8d41b9bfa892dd1fa98e0c14c1c9a3c2b082caf89b8bf0d7d1320a9cedc4eaf74d881f5a072fda6c7b5d2d0fcf80866f52177feefad5f0960b06dadd72cf85b2e84b292024ea4093d6d41fedc31408d9f02e15ba55e55f446825bf357898fb85270ab15d4114fceb9287be9637ed06c5bce92cbf6b25db93ec384b6f3324719ee27e4432496f06d6ab426c9c8052b290eada218d585331c5f1a5a170d5ce9375e67be148ba02b3044561b9dc16919a5dd487a73100c632eb97e7734c551a65d88db757edcbd7d80a8df5ec63a4a57b21fa824cf228b558e1f8e44cf3b3a82abc8855bbeeee1befbdf2b931d19c03233b4f30427c2e16bedf47f97526f15e000fe780ad440cc379b3e05742763c3854c83d2eaa3f157cc9142b9c060cd5b0f1fa215f828710bad7b0abae5e42cc2f90402b24a86d316d6b018186e312e5d301690520f969a8a7ba3b27f9a738bf878258cfd7977d77d1ece7ccc4053dd4947e12209cf6bf97c67ec213c116a351f93ea883aa6fb44d03f08a0b79b0fe0f0eab458ff8097b47b4a8647dc6e25b6e45d9a80f3a143a2905abcb6a808e4f5968f57a4e266c5413db9f648aa237c82b8faa10dfdd28291be4fa37c2aaae07cfce4f764bfebc5795b2b0dce3c076cc011b321bb1b6f892e149b8442f8b00967e2b9f26019d787c097b72958005a340c19daa1a025a9f6208aa6631b6d31e90aad64dfd78575c41f73010dce724a2b7a29f8438bf3dfa3a2c468d99e85fece7c761cc10cdd5fa1c93020625a858e8da12143620a9b6cd5e474d0add1a5800bf7586997081b8476dd5c36c2fa7d131473df1df536d665f600afa9eec9b4ca9498028e3dddabf4f0feb9be58d658cdf7b7fbf155e03e93b71cb35f24df328676a0d0f5a6920ba6c276130294748777e9282a246bf017a16746c3d24e9c6e3a6f20c7a2fd2c300184f6d207268588827c0a449649db311076671a0bbc411c84f5e55e03830c06424038b3b2c6adf873d4362764be779c417f768bb8177ecc61dab466d789baeee1d53e49f41ad9cdd60e190facea7b7de42b63784ca1e5be8e79335a1755eaed69d534b15e940126a98fda1c5b025534ed2813fe106e1b44fb44e09fd2f44eccfa9f411703b6702fa35331b82593f0f64552ddfed4dbaf067ea03c3c756b391a67fabc88cf415ff5995da33d3d5bacdb823838824318cf1f9a4c75cb18492e69e33684c1c583dec1b4c3852e7a90f6edc5d48d8f38cec4608fbc662ae34fa9bb64ea193930229cabb5c148ec2c301e47e2712db681fbd0c517881be92dfe8161e22e40a35173fc3be93651fa23ab619d46ceab2709d2aee71f15399984515691a727f745ea65fcce913043fe522c8d6026061aab94a13aa0614343a22efdf77f7cdc4c8cc408ec570988fe01f2265dfd560f7cfe306e3ae6df229a9873173e8321ecca87650c8c09d8ed90ebc67d9d12b29156e5008545eee9802e8875b1dd3659bb3618c9447c234bd0737e9329c8132f73de500fa7f80e64fd21157ba78f81b897f55ef8569a5854f2da672eb480996c090b315060829df2f3aa27d0c871ee3b08abf2e3ae3676a84368a27ce68a67daa8d66c31446d07ea3cb3fc3fb979dfc174ac84debab994e25079dbf315113b760b82f21c1745e430b75869be0a39e08e9de754754afc5a1dad75b528036c8fce16ce946d313b94ef0f98bf698aa67989b0b1849dce77839c7c0d4c1f8bd568da11055c109848738b302534d602bb5ebbc4784c5cdde4a114d968907e7bc785da402e8a05f64225e9faa825ed081ff091435e29be151b2d152e88560763ffce0814dad914ad11c79057d642cd64315c16531bb17650c6082e3251ba682a1730555f9ab036b9f80fa54a5b2e182d4409adc37928d87c413122330880d837c1caac4022377fbdacab78105d9576a541023619f7d3e2b0d9fb9e2c8cfea17128f3f4698002b3cbbbcdfb9984fef1ce38c1ec21260f63266a0e3463705dde85d50a78af803f01fa1676a81abb9891ff462761a042c7f4f88f5e787b023935184745f51c355387453a1a81744b0753c2e5a27f7102f0ae7486f3b30c052d13842d9be6539802746eaefbcb65b6708cb7c9f194cd3be215297f4de9255ad2d56a04f8d31afa351a08de4953bed435f16ea6b036b4b9d18dd1f219fb9f2717574b343f00a86fdd3988018e78a056729369be9fd92c92bbd60a43fab51002472e64a8b34c86a47ccb7cf66f3fa5b205b6ec0cccb134a2279a9fba1cebc514a59cecabf2fc14ced8797758be13107bf84a4597fa4e7225f9f96fc20079074b2ec7c8d218a867417a0ee37f7c9951e0e73a35b5ddc6aa0fd92b668161dda2e06a5415756eb7ec4dd780fefe8dc4a3b85f68d23e40af7c82ddcf61553982fe9d0ce96e48dd2e7696027929c382ee0fc737fe34b978f52bc3f9af86b4327f584474746a653094289f1c8fb1c543888af6f049a390835d7f5baaa0e7bb2a0dcdfb23fd08142a7f565ee3ec17d7a34380e36a586cdf93e1884175395f16bb4d8e5fc39f2cae86306e14e3b68660f838bc61c76c9e69acd4313362153a78650a73bc9303ac09d1c84f5b7f53f4c8d3862c3ba55210db9fdeda1731ff4165b918cde27a1d1d8556764a134bb4f18a9aac0813edc87ac16944615aa06b893e80b112e49c9c42fb07ba36f5825d71f74ed7111de411d02ebfdb007b62f11fbd1b4a47fbc5f92a0abfe5a4f8d2fd58ee0c63a4d037adb496b605e2a5da4c9c275263a0ec6e8c669af0d1ff5f7714d78f52bc309e0a29565a866fb12deb6b2a658e07ad19d75d18bda7db433c27447a693a7c16262c0e25f025fe7b07da744704629dcfef675e4247fd883f14f6a99eeefade803b9ecfc1a6471738691ea0ce1fdbc3e3e9c10fbcb2296478ad3e5a20df0d02ee272c88ed1c5f628bea9390ca1cb8ec7fa9a4eb92d19d136867737d0e130942846f92806216526fedef0072ab280de858e19e7c7e8d7e261f7afa3294b86e7590954f6448a2da661fbf02e024fac8b7adf33280a37023f41f8a3196e871c98931e8dfd94f088bd74c8ca0564df2795839c1d35266b6db0b1b52c530a8dd3403eec2b79028a40281b54f7110f04f2056344fd26d9475195e77ef6aaab3762b39785afe0b5831992602696d184e776afa7b743e58b60b18e46c23fe7e0e7f14b217dada29f79a4c5a40e583cf5ff12c412881ea42d568429b6cd9d07844b2d39382ecefea1d2a4a8b47c91db1f6a5911b4dc646799f2a87f257e355f9ce4ca3b54f35fcc71646bf7b2efc0b5ccc17db1b7e168c467d9a89a0a4e662820884ef9d3c7f30cb72f199aae712bc1bdbc7346bd37b59cb3fb9c9399b518c286452c4276b31effe238de45b11dc487e38b627b411441e7c518f19c927c4c6f17a99fbd9f7dd3420d67aeca669cbad8d6d8e1399b032764e377e30952ec31bf8021ec8ebaab8b6e92991fbcafd85e63e76a0fb7898cc43016a64fa9be65da96ce0ae13ac0a72dfbe5b413072b4ba67df8c5f21c8678e55b42d14250a03ce6ded57eb8712b835aee509ea2b8c26e9525a2a16e8dbec6ebf0fc917cc766a683bb28d9af5d7ed2568115083601e004ba71dd4dbc21abef9a6f132a4afdc1e1f0911c44d9150192d3108bc23a2b71f9934ca75cf7b6990f112076367b2f528f7fc11a6ae298d62096a53be0e651e8d9eaa2b819ba2ed972231c622e4fbc4dc59ead8d808725c137a3dd5fddc8a195c2b808b6ad39952ea0f47c82c2c06425360900372bf4a2daac45bca4914fc3bc91b9aa9a6b3071d70749c349917ec66ac44ebe9517e72ecd91789579d17cce6e851eccf4a9d771bed6c77f4d841add79520e961891873d5bfb59f20d0114c5ffb6c25874d9851741c0368d4ad663bba9fe47c0b26d6dde3d3bf43065b2997d5967ba7b0121b756adc2afd35e06d9aee15384865250e6517095bfef5b25d591ea14f5c42be8afc3073e5b3fd84cdb74d699666c15a8c73e904d8f2efa05ea7f760aa22d2a46a833c161e90bc611ce780bb47c8a7a055b59c5a515da921335cb2d5cbfad6f6564660680501ceb1ca05a792e1e3541fbeec965dfd6fb219d903aaaf5a27c9765e4e594656a2df9f09097aeac92dd38821061a315eca44bba1b319baf3e38c4bd0abb513d37c0745669f0d0508036ffec7ecb15453102bb4eaa8598a5c371c2e776e28193fb04ddd784d7cf6dfc3ac82187aac1bbbe9acfd2c3a1b3cc118bef2742f9d126b407fb3b60017b64260013853ab6dd24d0477a7926938a7905113ad3fbbff13eb42ce90acbf6946475a20bf08e5052d2ed72bae2f98ea3ac291f17054f44e33a15e99e4b4bd5e444bb3bf03ec7591bed4859dd87e9722f79ac9cea4dd3a5567dc8f0164459ed376c89a2cb5f7ba69366373102a45a54a384533a2d7fcad0ac408285fbc66bb503c442424f93d822c68945ac7eee1f7b2be340437351b12b72befea498b2aeec35d501d9e3917643cf0c69163f4701d1d46554130fe838394d62ae99c9506b0b66d6b8725f49963b8804cbc433ceef00c386649635cc111c4c6a91a33e391e8dd1cf81a5c955bcddcbacb6ca81c056b5ccad379544dec3a6522a3cf580dc9d06d7d8f64f0e3b6bcf2adeba972ea7324866f228fe19c6c8a04058bf9a3a430f36b6c6a7387abb23895cfee1234267d7c1a5a55f2378291f646aa3a604f3aca34829ab549cb398f2cefe02a05c1acfc91b63e8c00c8b2db3b69bf2b65df88f76ab1dab64065276ecc0886f50c450e36f4e9fa9d5743e5ee48f9bc0569cf0850901ff0207040482970d6e1e8234de5327c9dde4867da04c14f7a2e5b390cce8bc16885796e9f8a44ba2537fee25427c2712cb0411bd7fca31b2b4aabc89551d98cb9149547f38bba5fd3d47afc9822bae77dc478da32575b6f26ede07f4fc10698f4c8cab7a28efe82a8efaca9a8b4c1d9fe4c058115ee29d358b26641dc836bf551db88d40c6bee86bb27e2e41d10110dfb4532667c54f72167023250cb50ed153ca349616abd9414d7d42de119562d0286bb064ed98e933a48c15a0b0d02b34dfdaf50d7f1dec99c619cea4d0f24eea15e4015b835cf815460cceccccc79619ba9831eed96c2e91780c3c0c7661975bfc2ca47e1d9e8213f48228c503b687652be64a831678a63bbe21c85c454fc04c17e400bd3ea33a339a4e41177296ab67ea9d1c97d8c8eccd9d7d833864b662f4005b4cdccda05bbe88c831d26e715f3d0d34f0a14eda8fcc2289ccc917e7e74508f00c1799131d8526cfaa08fffdec4c4a9961826e5660f5e42148fec34e577ba275f5bba0910c0ce4ddfdf5545d5637d71e18b7735a9b89221f64586cf61402aead3cfc15e055b1307b34a2e5e8801c4e6b3fd208da62ddc9e5f0d9bbdd9ac631f6fc596bb33e2300f52312bdb43322e0763b99c2230bcf0336c8eae705bd8a85ef26413b6af1f1ed9f4d3d364a0fb0f2742acf9b8e958808ee68aeb5654d7a30d50837492376d683a14038e6e3398970df2e63bdbd0f19003dc6ed0618f203e0d6f58dfdc12f74f047d4eb7d04e41357c7de1ad7fd6cb7660b3300fefbfcd0b9447a2783bf105aad5c96ed3616352d04fb886b230658cdbb3f1dc6d56ceb66758389c8313c3c816e226cf271a457db26ede62a48909c9f49a4f6cf04ef7b7295c31162c92143f62321be3554adf6880691dc45a8d1d05463cb11035ea2eedfead7c0cb7fa2f0d50e0a011e949f0e0b88f1ce1ecf567d421222ea7ecb9e29a78d0d2f19bdfeec34aafc6bfb921d17b900473e13611cf69f9ffd9cf9b499ffce0884b164bb56820c252185622a74f3090b7b413b807e31ff8f49dba0344f97374752b49aeaa946ecd90689a8daa9b7cb996627fa7aec825e7f0775d6ab2945a93f9d99f12fff989d32b9df019cde6af658147a7e43f427e7c84a22e62864310cf41b461cb75cb719e744ccfb022283f3c5a68d1a6fa5170dd8c7669bed5372926c4290b566a2437b041c9731fd288a46702ee78fe71a637036d4afc20624b2535ddc4e87f305cae10d7e6230d9dc5dc44fc0db95800b59c9f4511b40994a3dfa3c4f4f561004fc4e8b16451d61b68cf607c721504b8bef067b6136a5c930932eca5c2699be4ad054fcd718f082609af9458360d5b29235f0fa07c3fcac3e0265db6d6d3364fb1f100f10ff55854c95bac256086ce221035e1ca949af5b76c73e6f7bcd74b6e7e39311837bf83bf6a47ba90657b217a79b196feea8754685341926c260eefb0e24c8f85ff892c430bd4f374e3ea1acd726dfdc51fd723a6943cc55546d5bd50916be34e02ef35f6788c158e572d3fbc728e265a127234137aece22ac2d0cbbedf3198570782b4afda7f56ba16f4f16f3a231bb03691f6947f808f1993ac230125c1fed7872f5ff3982190ac6bf3b9ae8c0779fec9d2c38831af3bd578ef582462a4531fd05bac8278bd82b6b57b3c207da2378326c9650734cecd9bb6b7999fbba17d8d43d3bf30a8a2c4dc3a99c39ef1d6ae654930e97d8c5980451db915abf0dd4eeafc30ecb0ff861f1163ed7a5002517b8c72274168c2200a864f847e85811e4296791a64d94a3e446235bc9b4bd67ef71a25a2d968d3fbbbeaa538b5bd5ef8df448949393638289548ac6a25c19a2862fdccaaba3fe36f984927f2cb1f05dc778b9e883c4c1ce9e74b4e98543ca30f2f7aa6971fd1e39ce785a1eb6beab87ba2932ede1ccb678e66f0e18edd57dc1511975bb77d474a4b8a9af485ffb6b2e83a8ef9a5c443bc72742290390074cb9d406e7014ae9607467bd2f178741ddb99718795e129425bd1c2a041896b00b35d8359f1bc20b91598c51a40d504398054174537b2702d3bdc52bdac83e4eff232261c101a8f8d05f86ea1483679c7e73ea83c2ac4b8696803519a25dfa2b50a3c3128a63d93bf43529d4b40fb5849ea4baf011bd2b79e9d586f888d16bb518b0e6f80811a5d0e80d1b1d6ab77528655a319c1af3150f03e9d76f0e595d55c2f93993196d35049f1a8b2e76219ea4bad57d3060d650b481b6f3b8cbfb54a92c4f8a98e1d3d233fccfd61abb5cf7580758a10c187785a972ffd994ed9275e2b4133f5f11e817c6d617ab331d5c1d8e3bc1eaab9169824d8d1a31a5cf38e24bac2352b6ff7501e1a5de561a0dffa34ea78ba94086fb6036b3bc478b22f632e84bd042b46079fdff3580de6b8a4bd492a946b06755106ccda45b2b9d05bcaaebe9e237af965984536306a49e72da0861c458432967b5501125f7c5b59d032258d26b979d6e2b57a93c224b7629ba8d35ae49ddac73004d589e41cdf322e4da8d7f2234f66881af9e51b9ecb0fea31bbd97570234ba24540070491f45cf058a72655fe0048c46c6a94a36d38a2340ca93c5013fd72f9c75da387cfbe57912f9cee156b1be21184dd3971ffe270abc648aae9325123b552e7c08c68f5a30c764a51d6684d12b7b095f191d894d1291c03cff5aa29d845b4ccfdcdeccf91c2ddcd09dcda5cf05b49e7a86e49af73ef8e537cbd6ad837b2d2b3d9e6bf4490c05e78057152407e1d5772d7b8f8265f1cd8cbc00b023d363c87ea8955c26d2d717e8550ff0e72a5135597104be44d1ced94c9aff189b43894efd383ba4e5cb1901959185fa13d0365af0c8532e55af4f334cee9d76888021fa7db1004982bc7ff110da0f871a8a165d8c7e452f65f2d5bf8b5b330d180d9ca783a81caa47741c1ab208f3aa8ad209a3a3393d0928ad8e6c41cd0f7f7477ff65474909eb11c80f8e163081a62bbb34676c609cf15e42fe5478b738b4bab88165ea90cab4c48d0b79653a1ca7c6cf4d69db948d405797d360dfe026bc2bd88ddc1a87d3da2d765bc23bff0d0aaabd18d995066fd530681ef7ee30f1f6f31902e645f024364f88b6d18b4adddb4089cebe5421b77a33227c2745ff860e61b90538f29d4400ec9d20b6e26f23272b25f60b384d8a41dd888ff3aee97bc529d63edc97113b9fb7df2d5644d4cd9910c6c2e719f9cafc5310c31940683ad98bd2c5114950ac473d514ae290b59dc0391e4854663a253abbe1bc4ee7c4ad344bfdcc33d3a44ed94559d50dc95edf9eff4303eb58c9609bc529fb9a341ed119ee72b77f41b479c4afbf82eacab81b6e89e92447c6a84f4c724dc1470663ba780061b9df7ae81df51420184a04a131f9f30ef9fc51967d35b5ce92ecff3b7b36ff7da204b356f3497c3831858996db424bbfc68abea9dca64c77df02b11d6536aef925224652e9a99a9d184b13a7570717a9557a4aa23bbf606e708ea58e88c0b3cd4d7a60bbcf1b30ce9eaf84f4b524d1e956bb5f856989a76709a9dc4c295dc632a0c1f542ae6072042ed057016df4f544100194f77532369a80a805de9486f9f3ec8f6646226b98bf4d928e2e1ba4e87fbd2495ac1de7c8ad50992eac2c48e3a05fe046cfeccd81c449add95e534f372e2a1aeb8f22efd0425408ab8f542e7f3130094786915d044a2ea3e6c7014325d441057040b36e235d027c361337053393ed2e9d98f389ab14fdc381192aba20b3542bce652fc6df684904a4d582376fdf30a9e18a82330de49ec137b536cef428b389e4709e29d7f200beccd039fa9fd0da9732f0908f8b8722d724287b61b30392aad8d8741cdafe23984699b0cb444205a0b173c53af172f63970bb3ead07b96d7853459ee7de1af3921c29c63b7daa848a0aefe91b038e8515bcf19ce9cfab56ee619c5a121dfc3e04bafeb147e386c5f309ebefd361a2719c5ba9bbcbe3d0a7cfab00a28583abfa2c96667eb85cd95b1b675b45c350e4f1b315511681b5072ad3c1fed014fee9553a99f53bf7f547cef2ff8e95d449ebb92127b6e7f5a533cd76dc0e1d4442a02dc77a8b1656b69346d9ceaab2b4d2d547e9e0d6e50fa6388ef686ee2de2901074921bad73fba3ea7a487af403ba87c458703aa67206319e1c524bf5a58c744fee6a41b2c94340063b81f227a15aeefac2143379ac23bea45af93a66a59646a05582b33f7f6672bb91fcb199a187a80b55e8be2c7963bb3b998ded83d61641bc5256fce8d2ba6c54853a862f97c70e437963377319b16cd6fc9f382746762b03b044543e8adf386bfce08da2089fcc88d077edb5b8926967388cfd5f35f897bbae8710892b54307837d45d6beefe86d15f174685865a1bea08fc3949be8e7f5583438c8684dbfbe3773281f6f74c85edf75e1a5930647745e9bbf94f66541d8f35709a3779a372adf9e82dc83c12c8a70261caa8e9fb046d91eb9d56741696a71c72c78429aeef6fc26ec705720bea8832ada7af774d9d8f1fdf8a72bbab613612263a285402f85605158f5f4d8c54ab54ac2ba16a02ed034201e6a757d4ec88f404532f177b49966e2d89896f752c0c965931df1a62220fee39141247040a1efdc1f6e0319851bc4311eeea91acf7467ba680eaec090fd13409429448faa9d9829287291d9095dc0a1fdf9105d6e699eb4510c2ccbba68afe76dc22b15f5e7e615fd31edd299ec57efebfabda425f86d946a3506939c36ef0bd43cab0c8bf82d7ce044490535fdb78aabb9b3d2d38c627b8504ebe646231be8f41629a62919e2d2d4148ca349065b9b7d1436e9c329cb8f7eecf91062ea4371941fc4c3c438e385f42ed263deae4d418eada72f87cbcb9f371b60b31ddbc5ac65c86063591149e399ee8ce2e6bf148ab758b7465b63dbef07f4ab75d15acc2e174df1baacd844f254b6c9d9d1203f7aea90c5dc47aae401ea0b77a7ef0864abf3f7fb24b3627cc412c8b9be03a896c061efc20d79810e5b605da31d73dcb06d3a0aa87f744458b025cf855cf27398f922555b9c22b89ef19fd12228388476df97db58a13bf96e50a3e4e3f7a85edb3f127418bd947f2e6da8a50b9b59be87056c121f37810e9c956b4c0ccf603be35095efd2c44a125b56db77853c0f4e1d6d640ebd212523254416c3b9077bf19a67f235341e2609d0975204cb07eac1eef15fc7b0ff6952c3a07fc4788cc65fc9f5df9394805b61c9682300447be6b038447fb6d65f8556047a050b54b4e74af35a93829675622828b870a575d179f308c5b0a4c0ef7098a0296a2bf6c90ad12814c1631a8c1df7e00c6264e5741aa6755093378ae4f4df931873082d315575b8d2c4584a7376b78f8c6b20f41aee22aba17a5683482111698b40162e3741542576d77c2d347392e1918f525034da989674bdd2c16f1f75ceb15eaf8d2b4709262b0b630b453f1c1fa2d2b3cabaa206ea3c6257de873f9b07a76ea7faf64ca37fef9e105610671850057940c16f9b6394d95241042fe8bb145e119faac6752320eebdcb9a823dd9fc166a0bad58b69bd732d744c10a17870cac7d817ca6ddcdc481bd4dbb00a4c7dceb22f97797512cbcfea54eb376fbb58398bae631235e69c018b3945f2c87c15001b93e7cfe809c49c23ca83e58a2683cbdaea2ad316fc4705efc41eca5bad26e5e820a94ec83886b8c3ddae3263e17b549ad15985ddd8380c837644dcf35649ce84ea728d56bb75272412dc455d05ff7591aa69669ba94dfcf4377805f9bcd3bf9212574328358a3649d0883238c7ab5c6087c1006be971f6ae8dd1c60a528a17c0c604d63f4dec0d046da3891f1f70355d829b95cf416762239fcbc02d3cb97cf258cc1ebe6156940b5eb452bc7e1d59e98b6004e6116c9e83ae8921488cd91ab8b0900db6940a48d85c3730ced41b84f5c847c22f8714b018d2cf52922cd22adf978da539435bdb0939f97dd64092c89578dcda0ce47f62ade266145a00aae8b6cf74c600705e346b175354038970c22076230838c90b388a3ebc9c4444a628367391fd829d7050764f1807b17f8ca249bea971ab06d8ebe006130282092542bab2c55d319991f476d536f85793ff9ba5bac65d648540b618b30758ea9352949a9561395a455283dab8d51ab1d1b8aaa9c054fc6f7cc4b166637f1aca924a393a025c8b9d6e8f8ea9137d10a836a9ab78eff42155d92b9b3a446c28fb0d47378a397b3040957244caab844d2defbfa23f4cdc29dff6ac2ed7dd2f63623c85eb45bc3f858841483441d7c7305390c33660ad87c98787ad8c9500620ba5ea66dd7a50dde685e3d82caa177061f1e5a7b91b0da43af7877cd0f8c6218c622b8d3a760251556fc730962b3d7cd482439fdd320a7dedd74bb12b186c9b37cebb9d26b13172520c618d81ee591d96cd52d0b3c8dbda7df36aeddafc97d0342817a51c4be6057e37c4984166834f5f071f00bd223e21e4c841280d2d825d249e7b95156c08420c7c39cba26fac77bb42b400abb65b5d25b1ea90532306cdb46df0400649e2eaf26cb9309a7fb95e5e868d7df431c3f8f280ff3037ba89d3c2f027fa5bbf33faaefbd7b4200d25a8cdf266ea45769df9848352926d8c4f27ad368c8f3b072e4ad98c2aa1e7613b9efae2e8eb049d2bbefeebf12b5a8070d47ee64307a8b94fc05e2a5c82ef1ba2b00a2a225e04037e691ea72c19ba3f6e329647f5afbf0dc21ad962127828f463f395b87004ed2e317e63e58f06aacca534aea8ff6b4cff3ef115fdb8a2e08be6c827a88d2d2721616ff828efe7896157c5a269daa9b567a47d82509879bc25e2b01ab6f3532bbf6de14935e733f417ac4f66d063540a026d6b60933f5980fe028475c143c539d8bedc29bcdafe703aa4e053b75651c11db58aad48f2ec53f58213df239c6aa866fa3a33dd7a795a3c43ba343edc3270fb88ef485037339388d0906c68043859f05580a2a3ca30bba66ddcd63f1906b24d46faebb1f6de38a1ddca6b67a7bd8e95192a226451a4f47598d46dd2ad1fa3aa171bdcff5ebb0069896ccaae3e11899da194c0e7591757c036b0c8252aac8f9ac4cdd95c61d7a43f3469f483e85d63d1493b195e696078bd185a4c4d89e676e030f41d7574ec58d4f4d400b0983071ae3948afc1f8ead275c439f15f4116b03ca936bb59489b0fec4603a3561d5a6ad7d4158f443fc3b764ee0989bfafe1dac778f4e9623d677316fecf649933629886d3f343bc6211c1114b9a73e9ccae4898c25200b546d22e581f5b26ac8f5b67a06e2476e749b9c7a4a1bba820f601d4a014abea6aefd14af3b7be39ceb2af4c4616b725c23b6b0de43c760b592615eec0f23f0b850b47eea4b02a09c113454707edfc5dfaa950d380aaeafb8fa094e47b9dd002e93e04aa12ffdebdb088e3df1b6dac18711c57850511fba3ba408a5ecfed84626d5a92876c3c4820ad72a604714f1453eace0894a4443a9a693ce5dc81d5699896d5290c3ee8f474bdab3cfeedc0bb74e57a727084bdddd3b922a9e541850a347fb59f42f2e7ef5139eecdbf064ab07f87912d47d3da62a18285f5be56a4f1803854093e85234555a6437c77e0fe87a69c4c0e77945a85c1a6d744a1e7492e307c6184df22dc166f3494ad1f4bc1e7998e1c11594a40dfc87d4b0f9caafa8563af01a54dba3d660aca64f60b90e9997fb0a9cd80f8d114f146323ea2547d910b5e6a49f4e6305eac1733782c03ddbb3cef03fa2c874cf597430e3f83ced34216803ce74a8b05de92fb8badba6a3a58058e47d6152b56a73ed140f7c8bc89db803e6f6713341729196b6dc478fc289854453d16bbddf9ee27c9031f6f34f4adf7259c0d0ac53f8858e84589d28901788fdb9e009d785a2f42f69420c6676f53565e10077a37bf797d4b18cd2c2ed5d8cd249e77016181824b387725629f1eae007e9a330f40af394ad8dc472a5a9854820cd22e4349683c7101747eea759f95d6db676a93adb9ca625c6329acb023d960306733dd821f11426b7d3f0c183ff14ef27b973ffb03a0cdc7c008cfa124bf26d2aba77a74d12877fecfcccf7f4301938ae4f308235711","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
