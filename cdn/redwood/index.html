<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc0db168abccd3965b3640c6aae68091b60459f2a8e61da8f0eb8fc3dab584b0ec41548bc85c0a86d644d3ae9e5805dccc8930508599f168235e271e7f609b29248897973ad257c9fe9d50a2db5a80062b5c149682f114c287229429e3c6561a250b7a49a98db502fed219c7b18a2ef6daa7104d72a3d3bf87c1a8055cec00b6202863b43e50f577dff5ae0b3123519bc810c8b3ffea952c2b588b4dd1ccdddd20d13226eb426b855ac4be72d6f7122becd92806cf20d2a5f2425414b0c364e82546e661f0ffa2d40c08ce22798f13bd11338dcba76f95248780d689d2ee47eeb5e7504d647504fff61729ac7252dee8602e14bd9ed6ff229b5bda231a8d76f5b97f38099e085f51eab143a39345e65bd389441d1d913ae2545fc5c6ecb5225c4109294d74a6c71c475cfe8125c6e9309c3e1970cc707e24f30be9c2dc65c9733dd97240e6cc07c441fbcdf816919a92ea2d5b7c6a3ead422a193be5dff771469937cbce658048260702fdb8ad9a8eb5a89b2f5f36e40c847e646ec469fd0af72b619d3d76da60791bcc7d362f3bf6cdfb437b826ce5b824cfc770fac756a1e5c43512b382c66d5d4a2137d4319f6ec2e914b110fb703af49be89aef1885eea5b972dcb4c97b345be439712c3cfbaa0d512097643b05aef5127cee4aad6f58d8352fa9ac8ebcdaf4e92661d493a91fbdb7bad1c6a67bbcc5572ee82558a80bed4d3107b0a22859f0e543b53fa5655cb0d955fbe9e939782a8b6142e80c3518427e21d3bd4839ef024c05dc62eb3a776bf2e7ac21d651ba2ccabd03573f065575c6d8fb4c1b1aa8762b9cafb52e2505fb904136935665745134dc31a3134f9b986ce5fab883b5e0d3f22e994ea4df94e1c7ae2f7c63760cb4aac17bdebec34d3a297f41804944bd6c6b1bc0c32da49ff3615031e9e9a081556ff2ce6be9934aef892b2e8321f5b312875e025734cc65e395580ff8c020d9b86ba4a20d9ac48bf88794e9f6e35be60cda4ab4cc188d364e4f7b87caa0c05b18d4c39106b09b868bfaebe6b2a871027f3ccd374d8a5c71d36aa6386fc41ed36e26ee976c8b1919545e4ee41b0981158a0cd9366f59fc057d4c5fa983b9aa1612956f59f6144b31911ea13b7342c428e148dee1adab7e083e6d4e63b530e24cc207f65a0c59b2c859b6998b5917e95d4ba196dff5af299b96814fe39d11f2db4f4236508aeaa8b21393818c3f69a64daefa9b9ed121383b9b6d502421e35fbc1fc73de396d869f42bb8f2699f2b6d29461c4ad235a0d7ffcfac43246b1cfdd6d5293d8752ac0a8685693f7dedbfd168e4096a79bed966617376c8c20a73025a5c675653efef4be331be9ded6c607a087b8c25e471b53c7c7c42c7090baa045e1eea06ef01d1539fdc0912e67bbb5f601e033cc6bd368631758b99beedccb4ae0d7434dd4e190123b416e69bca3e69fe6dcd34c6c7dd116984e255e8956da8d1d15604a2c4d330ad151f6605ae26314629870a104967f46fe91ab2cb4201305178643b02293a4c53469467d6e9f2011f63edf886436dffc5f859a3b900d6121b382055fa677bb03f11719f8fbd7565b576c0462593924783c9e4a3d2f8d8262db841673ea7bf396d5609b155746b2dd89b491f87f6852ff60ff7e268cf04c9073c1134da272fafc4943447d64e0280a52eeff79b3cdf6334367bd006d02ac26f26462090d9ba744e5a1512d2f592f5850141472d98e7433f8dde1f2a1aca98234d1deda62bf727bd9522ac2a684c1ba5aa2fddc12cd72cbe40180eab2201c738c036fd7ba33723e59a9d94ab601fad56f2b7cf600559747ce279e7beb00245b5d0443a0eeb545434ae7075e84a590c76ee89109210e028ae5266559c91a2248209d0ff97f722015e133a8385e78b8cf8ce28719d87d785d52a403049a40da4a0aea1e281b08fc63219909ca19ef184301abcca4d7582a01c2074d030b5b1c1ba56d594cdd4bd315347cb9b9c903a65c9eef6acdc8455b61f2f34448024faa83050edbe24d3b3d261017c53777795381d645e0868885b2d46c591a61aaafbf9d625c20050c6c53aaba9c62e0939e02bcb6de9e7a3daf322762bc76737a9d8a9c57c8cc98ffd2b89269c73987efabf5ca88cb460b163bb6012ee6659c545ff4f2da64d61d8b105f1bd4da8bb982f2478e386793b8dbdd4b7ffdff9d2362a1f5fc73bc9d36eed90bab017428a7f126dc70a9abff3bf5d393ce8c7aa23807f9630e3befe869d5f0b2733feded6168db5317b2478c33b2a2e04855449d06b1670148370f4c96e8398ec6f9ed8d008a37bf70f239818dd2df1746c6a17c6deeae47fa65fe040e4bf5d7651919c90b7af922aa3cdb89182a61850dc122b14fb7b8a713ce9a0852ed579ebd155bc1f98f4794595a6f65533de677406064b6c802575e764dc77d8a8dba04fd5644aa2ae43a76936e99b2f1c0b89f8e545d36f42b69fb91efe57b3fd2c6bba5f5d6bc1251d2f8bc8a56ced79319c5439f4d8a9ef53b8f22e15b2179bd8e009721503b557da8c7359aec2c60ae12ea616268401d615fb5f5265cb639c4a15fd29a166c60bb4385384b53a3def91766404dc64635920dc958f626870abdc36d3240cc9d5d9c52fe8aa6dccc88f13179bdcc05cc22bc6273a8e68e617c7f308def3c3327528188f17cb79e70799c7935f9d56155ac94b8b418b478973df36e147d7490885d1316a0ba209972fe4772fa2e4062d8e80cb7d0b48126a8763467931ffd24332a3250620aeb1b72058b54944306ee71816f17589dbcfe77bace3f6117a2d8f415aad4406e538a329afd1c0a7186e8c597887b0a1555d76ab6cd4106874082014fa7d251e6a3baec9cbdf286bd1e9b395125ee45ceb256a37c413bc9aefdd32eafe212f2b22376b64111fa80560a8cc0249580b18c9943698c136e81217936e503d42aee49d9819a2c55307150891bff8bd5db052968e3d52e2bcf9e943ee6a2f57830f15c79546aa2c1b23cc77db199892828c0319a079eee2dc1e57b6b1b72e02470daef3d3f3897b733633d853d55dec3717e5f2d6c8c25e018aac35c22ec92652d6e97491dc6e5593104b8ede670513fdd4d531b8d1be56b5134a17ed2e75ff5b9d21906a2cdcf1248c86c3f9d08ab3fbafd7b19b7380bc4bfad698dfed14a3e94e0eecd93eb4537fc7cd3858b534a06571e9893feabfe366ec86131b122f4e48068b6939fd095d43c650398f9e6ecd1589c1725350bac6fe2c049fbd0a97af5573daa5933dbcbfa4ee41883d60456d509a4fe35da32758fb7a6ea7b8d69af958e94676e565cfdb776cd8c59a657fb9c1d58dc16837e4701db556fed6ddf5e03beaea06b33c2765be686d9e9690ea2d4819330610302e1b526734e0afe93227f39ddfc0e7521faa1e46490a0c69351c1c8c9c4158f94ef9c49d021d8a539a89eaf8b5be21622749d3e45421632d07ec8d3270d24303a94d73e0872b90109bc45b69f2ff2c6203869c15366871d414f16aa99e375a820e16fbe5f395e26a76fef9dedc98e01518a4286f27b6f5af8db245eabff1ef917d83f94c0fa384e5581a12ab8a5ec434aab228db137cf7df22591fef79fea69e2c6e8d8d07e90cdaee7af973ea85130fc6630d4f001d19c32d8e09d3d6e810b05a302d2f6e7b9a46f7f95abbac1682380995d13d2a226697e7b9a63602b1dbf7da55bb7b82cc8e333e155920aa46e2294cd430b526a37e56ba0caf018b68e00a957203f643800a85312ed42222eed978ad77499e9949c5fa12352760fe35624c317031ac4e4e65dcadeaa0ffddf6a90f6b8187ca3a2e97b42fd27bcd57730287434c119f58563f6adafe1f4de056a8b3d36268dd2eb7e8c47daa2db7d0c42cfac241e2382ffaebb443f1273e6db31e35ad5b4f1d9c747eea480717bb8eafc38158c6da1ca7d78d81406fe2bcd462f22b2cd3f8e5bba95e1422ba1c38a17d6f2cac1c7de0439cd38e4ea83776649e0bedcb074588f52d6637b4f87b0a94e8f0da28084aea7f0640f678672a7a1cbdfe518763bcb5edb5156ff3f93c1757823707e6fe3934d03829efe68ec3eefbccb90c856c73e0c8b29858f3b78001f353965eeba58903de9267bce3a55d853733f981859f66eaf0cc443f60c80614732c21f8e803cf9db482e9a9a6d604989959fa549eb083b63ea5a8e20e6a4adbdc33873fcf422de3c3a34670f5b61bd1c00788e3a82ad35e20357a610d069f3dbfb8bbb5328de9181bf82a517e791516c728d382fb9cdf26ca29c2bdcdbc92d03a5f8eb134765a2d4611d34b2417468cb3b5781beab31d1e13e42dccfabc6ca7923ddc7616bf489d5f14309f0abebf892f7acd48c381c6d867bc482e0bb69e1d7b308c2b5063203d9373bc9d7eb54e4f61af72ebdb5a758ba515a097e251eb93112274ed6296c5e8fddfd211ad109851413b43b224fc6168a8a260f732ed3379d44428b84cbedd5fb939b33f34b3152c1acdd0da166ae65cebd40069c512ed44d7d8699080659b9f1fb00e1ba99324edc6c67593de4a2c7fe15682267b26fdf970cfbe2c89dff5e15d41c301c48b9b9f9a0851b02b53b564b2f8e002b16f4ae07e441f45b522446f86113e3c27875c1a56beae6f60e4022ab374610a9d15aa08d9903f660a1054ae1fe9b3a5638760aa823aae8662c5dff270fee8b8f6f7023108717ba97ebac92a3b2d837f5a60ca3f1e661f67c15dc9a1502dbc7cd1f484e273ba67767bc8ac3f3dc8caeb42b6b4dd3dd236bfa44fcdf9fca99d6542eee4a1d44dc18afcaafcc6f6e9f350df14c35cdfbaf0f988ace35971546006c821328e366bcedbe28bafccfbd01dc107c6b3f4fb78f569c2ff2f0da3498530d56acfb7a8b21f087ce0c86411a78fec00fc6689f8de4996be14591980215dcff020148461e7c1538aa3a18ccbc3591cbf3edb7e8d0ea2db19098347b1a90f8415261795c48ccdb3b78cddedf9007cc14080edc8106e30e0d2221a559c5a5a1d4f8e05674e27581dbcc087d74ced7be80a25de947a5959626f6cc40d660457aa1638c72af7d0d3d5b7ae166a40b7ae8d2d0a37e5299926e06346d42dc543456eeea868ab68454450345e9bd7b3247e594663c9702de424107ed0a2eaa2f7b3e232a6345c71a0344d9dc59514a261b93563f841523d26afa5b676c4a7088154ec1927991e758732e95669439d50124fe38c3fc2496a5ad0a434f1ae40da1ea1da67c68cbc5768bb7fb1c4294b219a902bc87b27ad4a9f3f2cbf2a42fb044b3da7505f9053ea06d29df26bbaae02aa0191b6b0299187c6e9f490f98786063e9062eba93b082f586349c83f4c519520ce9364c0a0bf8390128782a17c21d2d428aac8b6a5e68db7247603354ff3ac73e460d9c155239c0c456f42e957d5c5ffec15f920f529b9179d6fc950c9db2cca8d2abf324ffad4ff1cea650a5dbe4090197ac0d0de89776af4f6a5437ce63474bbb5494d47ec87567c344c031bdf9a578eeecb02376ad054205af34d72af9f2bc18e5bd1656a89ba3ae55b65fdc2bed0c746ae6af84ab5983b6f1443768c58c35f283c632bcf03b69967d44810e540b22746cce446fcab1b6733ccafabaf78b48eedd217e52a775c3f34958cac0a4b420b3aeaf7b92f8ad39eca8139e64a02b4b10d2a23df5ded30526cc37e0e2ce71685b5ff5e5fad1248f38b63e3f59b40a2fa0499d2e0e672921cf46eb9a5e983642089d89dc33ffd4b2bbe28c7f84d8a9d38b7e8f0dbf85501e6d139367800ab2f175ea7afa0b1f9a4a38d3ab3cce150ea0f1265f342d9b3526f2dda53363f6bacbbfc171f4938a83d547860b86989636354577009ee0520ebcd1d1965e8648b15ac42200e1c3684ecb62f8b3e9a2c33c0ac71cd7dc2c2651e1890c8dd3f564e10b54ff51e7f73418fde00aa803584ec5631631e72bc51ce57e2e931f6338261d643eef8745095fcfdd5a9db2dd8643a5564dc1056b95d1aa3f72b7f2dc793d957d8b9d351b0c3e4916ed9789a421f831e81f02ae96ce925cd9c23d5aa2cf4721cb6e3b82daafc4f8b4543750ba53e3684b7a3a4f7041aa79c881a55009c3c105e08fd57f220a744279996a228dc38c51e45d24fb85902eb2d765be5d9be13c0c094d2d0f2801b17485d93e8809537b36624517990c2d9f68bd51c0ed98095738e90839ed7fe1bb1a88cb30bf5a26afa8d6b8f3e737cf664a17317de1b0ebf795eb2ecffa90e89d0bb3c455f38430d81e8b079c3bfaee72ef1c1c06b2ee56913c3fed1fd4dfb14fea64d28e50c2c51ee9d31f3d4c7abc7d0e629dfd26285b40c63d9c8e1ca356714ef12fb6fd5518243ff2720bd0683c129496ae61051570794098e81197604be58466bc803cd513b6cd6f274ffa25373ef7b80b8a90eec0eb1b37a02f1b5938188bdd61d894fd7055c624bea3e720049bf808e59d437bcbcbe9aefcb3cd6f2228ddcc2c66d6886aa5cf0563d5bc7f412a28c07248eb35b16ee597b44829e80552a4666469eb31eac0fa3508ea87c32d6bcb9da80361a436fe9f482bb7860e3944ed1c9ce850aa64fda290d87f9b664c6dcfa362899ee3cd1baea1a6c86d6537a0593fb12343790107ed9f31b5f1439bc8e9b087547b7073c83cd64325eb1b295e89a4ea481659d51a871ed889a8e16f386ce9b2d98bac82f3e39e8261fd73933b1ab3c9a020bb37d5eb0488d7ffe1d7383c717f356f4eb845f7c6c3d606bc2a881c072c8ffa7b294bbc9728de6aa130c2b97568ac77cc88aa2de0be9fe7f2c166d9c7c0eea9cf4715ec3b32d0d5e47f1b302348fef3977aa672483fe5767e4ce33ef40c46e3e3301bb24a065c205ebe229808006bfe92b0c976e6b49536e75c97a1cf3530177654c23b2c745fde7ad540a782026cfa972f8a81502421fc962c9bdd15478df9ea62187320efa382d3553a895c1542b0844ca188f92924aaa1cb153a58c1f8f7a440072dc9ecb037c4b27a201c1609b126dc97b1aa1910c2a53841a936a0c097d348d8a01a7b5bf683fd4dc1d7b8b6169b66c80a278acb0130256f823a41637d25217bdba7e1edd6fa7c694110c481d245ff62a82dbb88e3e0811af5dbfa00fe7d3805e6961bee85b01098eed96f88f6db7a48c6a41415c9d5bada940b57e828010c5ba7b8bebd3b64799925fd3f7f77578cea9356fdd206915a05968c01435c6818838bd42ce6fb5d51e0acc23360e04dac351bb0ab36e963cdb08e5681bae080f423db48249d73dd7f6e1875e12b24e7440abf2f7fa15503b70f5a70b0fe726868e2c75e60631b7580bf4b4bdf97e7c67d018e258cf7e5bdd82555665e2dd2ff8e03c03125868a9ba7d1e25a72d46ea56a7f533b33cd65a0da7f63b3645ac1b8724a6d59aeacd892f963081d9fee13be798e66fe7ec3dd5ad1daefc43e50cbbdac46918fec7265ceca63ebddb039f4aa841d041f45ffaccc658fd3f44e18a62f151dde930126d5773fd8570f92ce66d2a0b3fce6919671320e0f7d97a0c1539caa16bf51d85da9ac93d7e97cb3749c600426adf48350821175d056872ef7df5435e4df774bec22bb3b9b422f0bd503769f48899f3f06ee8ff3eab88137f77d860df12212b9caca1ea37675885de8764643807a863783892527d195e7da4f395cb84c5094269e8c71f0ccf90f05b436cceaf491e740ef2d8a68fcd0b41207d61a32e78fa31832e01b6867fcc44597edfcbe517ea8b1444630a43de8d1b12deae8cc27174070b95c443fd019d869b8c3e15481228b93d98a2ad9a29776d1af49c16bb25428a28bc085654928d9571e64a7d7d268e0d2edd1b153cf5e7375e1a9af7f0dc3b33cfe842a0b374c0bbb4f841f2bbc3ce9b4a9143872508645fb6fc8215a52daa7bd5c45d16bbf40f7c6d75165d4d49090706d2c815cac5d81f097802f24953b71a8a62bd137ffae3973025848a18446349b9715d3b3951fadbaced49e363346d8b4efebe2c26beac9d87f7181aa82078a7d452391a4399854a7d7dce801aac7aca6371abe1a27fe3c5365abd1d67d1633f44486c2fdeaec103408f4a17212254f880736d16eaefae0001a8471810374aab839c758bc36aaeaebc444c2b97a6bea96dbb64bc792b3185f3337631c63cf18255a0462be782d553293c3bb70feb8112d6cea97216d8570fb1780b9b86dd9dda6b72d329d235a8d6aadee87e9e62a6d336cd56dfa4cf32067983a7ca43a0df044f13d11d5776e37fd646ea82284a6fce911b6f833012a68d3b5a14e3121a63bba4ebb08e73f71f4203e256050cc9b792aa17eb6c136210c5116e6ff042629f320d51a3c0dec88c79aea316fde083caa9844ee541478f72d7ff58968f5e99e2815e14f76513d25cfdc56f38ccd6f94410d1b5bb85b1d9c21890d1ea7feb9fa95644200d70e6ebc5c1104ff3dcdbddd0dc1684f42533210a87605ca678e8404388b4d1bf9a2939293b8ab4b5c4b5b3ecd0b454bd1060de8fe785bfe5af94d0db3ef77f39f4307a63df2f62a012b306f23c291c6db1589f18e1ef6b8391de27e58fb2285f69a9fa84af645f730bbf49c8190cf63dc8b4eca81e1f74104fbe3a6c9c9383f06af7fe9aaf7a7924f5891275d508ed654d55af794d6c858b13f989f013ed6a243c462dc3d598c5eeab5e41036b4ca94749ff6c7e8f0b8ccb450573a8b2b36537dba421a1dbf38571f075bd2245def241387f50c9ad8ac56c6c4a7583fb7f077f4f6588488ecfb319f076af232625a43ab9dd301657e01ace1ce08150906d1d78bd2e49855b3db8f97cbdec625fbb0a7f28732986c28a260529401aa19dd6958b376001651482ba208e69a0655605941988f2ee4effee462e1f798289d951d24a560a2ddaeb6f0ea178ac4736dfe417ce9b0753eab7ef079225dc1f0abce7221a496b22418bf16e780ccfae2e48aee51880a78a8906aa57f5f4095e20dacbd86a28061b2613ae503dae88c43b61f2983718cfa56fabb7429dcd81fc2b9f2cb92be9fbad477bc5c1160e711c4a67e9b9fdef578dd5a92afefc69f8bfbce4d1054ed0111f2b50fbf11e9fc135e39d17364a11d1d604f801bd9483d4e5188372f99dff88cb0867344c0c63e612015c5657789ca2aad52b97adf3577ac118a75e9a49ba97a37a233ff4fa11856967a4e5b4e7044ed4f0a41bc00d26b50d02a8d907ebc94d59547d937d674d846ec75835252bc06656602a894b7881148fe330c8212a890d21edae9ca89387a0ad86ebe0a066baa514da6e6059b5389f6ac2067ec0f22753aa3659a7a6f42449bf66eb17d894d4d8117cf45295c0e418eb0d596c2e5b1f4af7df9845c3f7ecf4a260a4f2906cc9dadca82c9a1b14bf29bdf34f4fcca074f776409fa69e5c5d31a6187681f1cfb7f4d2708b33692c3796d6bf24a6f72f15d294d610c13cb3fa05765b5c84e6f37dbb97eb3689a12420a4b0fdf596ec2f66e197d34d3b0284ada12019dd40d4d55b25904ee4ba3e0b9810fe20619954b3989c713bf591b38d0edbb97689eb2be092174b82606fa24fb758889221d0f0b430b3ca923c356dc081098cddb9a2fe439ec5b90de6975ff310ffa777508b4e0c2794a92b40befc24517e5c00337f3781fae885dc32e156f5edb80fdc2be5708ebbc8a357b2dc9b9abe2e984c02c6e11dfc3800f89aab383a843da47a5fed64cad761190e855482e8b0bf9170d111b22d7d80d6ce176edd02dd398f83fd8c468cdd135e901e83fad7a9a6f72cb0dbccf193dec98467b1cdf2fecd72bffed91eaa0e1816d39814b5b7a51bb572d5ec8c2cb466c1b3628d9be200ccaae0a71b95909801baed97812fc8662f1cb93dc243e541dad59be720c1d6ab99d59c2527580d3fdcc657a528cfaa8b49083a010da1149a790610e1f51947ae4e8ebbdad02afacba264ed84cc1e39459aff80f8b7df99543c7619518abe4a615066261237da4cb96de25841746d5ebf4026ed4aaa5ddaa5eac22685063eb7af4404f2a0e8800166f86662683c0be0e8023777c067b47efb2e3eee0572840c61721563ce6269654d573ac3ec30390bd3c79cc8c720d9f05e81a1f05cbfcbc703dac9cf05b1cfb793eb3df48348c16319cb8d5a0c34c4e868ffe52639ced50812f89773249967a497fcd8c39a54b5f1448bcc12ab7953c747af3bc9dcc2acf753063fc798aeb5ccf51d79d84b2d12b3a52dbb115f25009d04d9330712b8f90915a41bea37284d3483d0a2df46e741d00fe7341c090f33cb8540ed86442259d0d03eb6218689ef1266f075ffb547ff4940fd83663db12dd6c90c59d26be08a70c4796da22d6fef7d438cfe5f634fbffcd9e9b52ab96aa276455005090f77b07deb171fa4ff79cd699c556f1d2a38ec463bb833398a5d3098317fb7a8dd9e2895a6d6183f8debf0eff73279289b7475142c0f14f697a4917578812cf89f9f5331accaa9d48fb6aba0709d49fb4e95096a75e63bfd50e594a108afd85bb3065db1910456cfa9bcdaa063492f9e8d49fcb39b734225b655dc75f0c554ecec4ba9c81f4ab538f1c4078043f1f252a3aa5100ed25c1f9f02e67801a7b0b713ca5a767270790bfc2c2f96ab68ded0650096c4708df06f6e3b7ec3fbeb0404e9517ec4986c1ed755714df1972442c58840740d1fde7e70a463b425d4ca612614bd07eaaa8845794f5fee8bc53843416fad2abe66c3ff8a3570e55a6e20bef614aee15ed092f2f6d9e212244da23c317a274cf3b1bbf3e53d7d02634f3a75298a93bf875471b0b430eb51c705ea1f1492d34de9421d440b60bb3d28b0b82ee4ba145efaae793d3303e6ee694199cef1283c8fcb4b3baf038d3639598d6b37aa099e01bcd9dd5b5a4f0c55136be78ab0e59b04bd918edf918b03e263668de7d77a1d807c821d139c56b5699e8637547c49cec9f97481ba0bd28b269fbe4027df0c6d5ebc09d0eb3637716b78f8177eb4403b99e096653f8ee275a6c5846ca2bd05c25ad9c2cac5a6d162ac06d9ed1a9d7ee064b4eab41b15785eebf1f30bf2a9ca7890142329a2521c45e9233c172d2e6d8382aaa744012797f19505e502835aa9787bd086351aa3bb070a8d79f715d25a983b691e92384270f951b1b133bc44faf7256df38928a82a3ad74ab717e9f9b117641844f984d66b9e2d1e3692ff9927741e55987b46929472767af38333c1ba248f64f0ecaf8ea5f069a41d1da7a8add15261c54b9d8fd8e67a04932f31c3ca4c825f3ca53aeced9703acece43bc27c198382e1b53b77281d867bfa1ab1669b314560ccf03c0f8a5a211acf11e2ec8402f3542a6d02e9338e070e01c851c9c47dc10638ccf0fe8ed5a81bee14ecfc1fda304ceef482461d971c09dec14513d5a784bc8b4dcb5508c62b05c26505c061f6bbe836790a919eac9f3b82aa8a561acfe2cf44739ecc2bf57e90c8f2b669b43080304dbf1acd70742906a64cc25ff533cb7184498f45fc84e567f44074eb6ad6f60c2d3688945140dc9a62662f6f7861163faae72c873c96fe9e5753733a6d3cad1f56878393c59b05bb5fa719f6679f414d83c5ac2127467aaaa5c5e34ee8f4dc768a06be5d5f1145934ca9b0f755c75f39285549b57e583764934c888f29234896037624420fee35712cd778934d603af58b4d7e095d9f0e4b6042685eb0cb8775a094d9d75369fe84412eb56d481a676a0fdf8775ad9b46560f4034b1a6bf878d1e47bf195a5c9e8910021652c80f01a471297c8bb9f36de892623acfb7d08b081b8e7dcd61b89c3792cce1aeb573991d0416e47ba76408b2af422b91414eacd6d16aa9e609056a97db03fc987510ef5a45084f83260e5c690fe228049f0663cc65e095fbcb02d10e869538a12f03180ba2ce845429b1711428394374469de0ecfdf8ca697832fdbbc5f9095371d75df61f8f131b5a241387388d07e771ab2a1de09e28a97800dec65f6fc656a0b38cbd7845ecdb4d199e9ff557b4d91a2f7fc11f5f39d82ec1c6b45e41051d2218cf7311bf9f09b45181652a750a0ca2e55a0507782c3dd45ca045de47ccaac5cbf71fcc84c0b979fe059108ea468c2806d999820c0f4f3f805626a4774444adaffb2fa0f1800379fab0b474bc860f60a5e28005a806a3e0e495b815e163694957418c42fe8f65f4204161aa92cb65832a2f06d91b8df33351244774a59ec8532c8ad35c8c1f15052d36bcedecc467254ee1a83a156fe1278b18921c1cad47080f77bee2a4aec9bcf385fe53d4446520f2d1dafa26773523e873ba0c6cdbef145d7267e5e47d4e28ad455a450408d1844cf699f135c15c5f208ba4dfc269a60fc92e7b9b83ae6a4b441ece4c65cb2b68f32166ed646f4f627369dbd74af96e94c61cf854e37b8a7fb4b848080506150deffdc8055d2267e8e4eeadf1d08d190b4be9e9f8e4078e178a2d56b7945085f87a755e59d9b9aef644e7dd0a9b5afb67185c1c9b2fab808712441e01cc225baf0f3ec37cc6179d409bef4bedbeea8bec290c29f6399631e2cd1472e0f04d8ca115379632f75f62e4f74924478f1c0df0f282999c057b999eca9353ce699a1b7663d3d82090210e0ea3f1cc0f1dc4c7d167ce4008de02bd3e229c210d271ee904f34c9eed2c572c486098dd8e26a976ae5e9e30d34aec9a0567e68846ed27f2b01a3622a9224a41f3d32a148139ce9fe740468f5cab037e95ce6e9dbdb83c1eb518121c20548d6f41d773ac40446f428f0553154d86d075b45d3ed32325e2fa03cd23a674dfc3efabb114f8384e5144bd7a4b5b4934b6fdfe74f626c797bfdd649481967b85fad0fc4305a604bbc607b3b52bffd657b736a86e236da467fb00dd45c4a2068fc17d3fa0ab0b9772e86a886876c019d8c77411ac0c9c933db7ab78544e8e9f1f35530dd0d66669feea2f6168695c25e90f79eda9bdfd3c6a775b2417e8e0e8dad41001e7a7909468ab802731d34e06bc537ae395dfe4faeef289df57e1ba79aab336a072dff9ce888a93fce054962f666a3bbd994915ce613d1ed7b5b93bab9d30f9513cdf8848f819fc0e2d8dbfbf081442e0197a9df459e1becd0115af7e9989e40829b75165ba147f7e22aa98b52dc34938ce57acc93873cbf9e7bb273d8ca4d128dbce82e6d575d4cee9a56de960b676652e5ca9c7a3c4bb5e31f08bd5c5b1a88ab7f0cdea6d8a921226cacbfc2cb132d8deaf0a5f6d3942eeed8642bdddcfeeddb1f3d2c2d3f31f9e13a0a82fc52413129bd5633b1aefa1aea813dc4a9eda8de3f02de72179528a7a7008fc5575d6cf3c87d3d1d7fd760287c95cc776cb57eb13f833ef2288ab2bd652162551c4dd44a537f67135a339f9fa4898e422f94a907f20660bfb05748c77f9135ca3b6acfde5504e56f766af17d4dbfd02af7b87d8d743bfee9485b447cc596eef0d862aa54a1160e4c002c25fcd024c5da0bc877cab4c928fabbe939222928c7fe57da1227e8f6865de84a1b7925950585a8614cde3eb96ec77b49ee9cafd85a568992e1da8b0295ea04a3be6af228aaed7c7f53987457b5970458afb0205d5369c09e575e7e7bc1b3fe316105c516f50f82f7b0b9568800af585dbb6f499441984e2043f7389f5e1d6759c37d6553178da89a459db602cb68b17eafa684e2fe9ae95b0bed93fe97e1fa915397126be489b0efc2123b48ace44e0d5d7a41df1532624e2fa1ebf076a038f50aee596f1943e52c5e44b4d62d56f27b00ecc5e4b311e59c638876881b43350e7ed5fabfd6ab10df83431d2aff9b37190c9cb603854eb5dc92adbb797f18176bf4b315fdff4a769344d4db553f821f6576cc5b838e6b4b6d81199631954c88767773e7a0ad34d4d3e2404b14f9e9ce606c5383f41813bb13dd195216d862195f9d8c562a65971aa6a9597892961a401aeebfa74305d92b4950657e1ac8c8174cbee590e1333fb2093a35c9b829b70e0c21ece14f069e89f2498c4ea0167f4a892c9bcfad7cba2489ded79f86f5e91a759848566fea93474c27e89232aa918f4de3bf60d7265721ee1e16721b49102f91875059bbe9990382e406c5e307490c91112b0cb8b18e6c71d0a6948903c8a35c86c7582d857081fb5821d8ea72122fced2dfff41a1ff74b7b42b4f2a1925beda87808a994662fe9a5f109afae6a19cbb35e8f11460a391605a6f6876ec9df1b97788e50d0b85bd5aa10a83645df35dd9ca979d766aa00db3731318afb4f3f3b58cfff19207efd512976dfa8c428df246cc4b0f4a9574d296c16fec38b7c1d3aee33f22245e17f397417fdf6856a24b3c74ef67c5ceb98fb037728a76ef8fa2ffe563fbbabc919e9bcf7d76cd6bae5b8addb59a1cb146a439f72eafbb3ce92114fe52f2ee9a679658afe233817c72ba0bbe3a29441150bd75e89e42e32a1da13fa6f7470a57bcc7c7004dad3a12b1421ec6c89f25c8cbe13b94c6933f5f19394d96e51d34ecf7f7a19a653718e06815b68ad6789cd4171fb19378d53a376bfbbe1bec74fc6e1c3c6158defdff1153e27eb340ba1fe8ab53699cc6ead28e9fc21579608bab1d8037154783c40b62868f1b1c25ceede0e4babf9dbf00fefe426ba2966e5716110cd865862e1926b45a615e698b55cd237bf58af5ba23dce16d7aa4e9fcaf855583d47410f2b38448c13af1d896bd767f0139f7f767bd3b0f945f271314f39cd18c2baf5a2b51938efa934c80ad8898748434b4b5b3e9d0787062eb8dfeba385074a7c4530f55a270f48561ada05c26e59be4d77538138ccf927b55af2a1a0e18cd023bc0ed280b9ea4856e52bf22d93e9e25d2ab95805fcd3c7041997870f2e2454f6c9dcaefe966b1607fc427ab554867b4c90f7d9bfa6d49d07ec6ae8391ca78883bb2edd70fefdcc4b38863ceff0853b6f47a4eca8f8bc62da7c0561a1a1721300cc2276c5c246f3cb16dd180662b6e2632a3af214589246919c24d3f1533bb332cdab3498adfb0b54575b0fa83f047450e7d3bcabccd1fbd33f47d48398ec41a7a68e1ef4b20bbbb4febf7cddd3b2047995d07489769ad85a80522ffc40af10e590fd5e453231b9a18e0dd8d66b095838b4af9c4d7f85090e6e0bd23cd041d1ee6fd0e6ec1b090deb663eaf35c97bc38373d0e97694c3fe923aadd37c58b1e10bd7bd032e66b84ad4f4ddcf6b860ce6ac22c7d28804f3987401c01ff58c24c58ff051f0b6da9dc6b674bd573a3be72a3405651d9008260970072ebdf96985c4c841b16bb5feadb976f187a1c3761cb4b803ada15cc1e60451b90f83a4ca02617bfcb06c4706b55cbdcd5dd991585d7cc202d87f005bfc5ab9654e8cc2183b85c4a5bf18aaa9d3068f0cac4dc3e39743fbfedd9a6c68429aed88b55a6b1464fc3573f1efd829421d105edd6a89a166874a98ff293408775644f829b123e89bd171af291f50c6ffb9a01c57ac8f67eec797a20c6547ca8df7c339278bc86e8109718cc2294b07f1c6f38a3e4acb57b529e39d77293adef1d61863cb4db3ef094ae1ebd08fa4e8bd9d2a5e7518c1c6ef72e829201c9ba00852c9e23c063b95407297853c3d99b205e02bc84155e5d60d075d12250c5d6957b6c732f344f320bd80e1971fd1b439ffb9dd34faaf376d745f04ab237d7910c4be318efd6a4941f0fdab74f8e92b17547af63006fa9e1ffcbdcdb411c2ba61f566eabfaa5411bb812d340c2024764b5ae6d22a38a81ad259f65b5aa838143e7b8fb72567a76f64b0662220dae4f1d1d27417d4b9305f4576ff77da3f6fd7f2ca1971e2d116058ca1b4d16f7a9139d07723697aeee23e32a990dc6fa20bb68c41b5ec8d21d134389932ecb4441f64c7a7911dddb51b7c119b11546b819a1109753bfbcc986f1b9e69835e3a9ebebbdb2e9f172bc4e126c5ade9ce6f30c785159d003f1d533b79da8ecb009175b5e2c2d16f922931196bda1e8a198f3119e7808086cf54dc1f48e75ef7390874071f5c557bd4a519edfb2540b0cb31fc61d428a45e7981f95d0f80b00005943bbe02449cd014e10aef6ff35cf582dd34a68d7229c1900f2cc09c8ddea86b4d681d697c2361966d52ea822865188ab6ecb98ff6280bb9a0a816e7555de55f8c0205e7e3cd53e75ff9abe9045f92a04960feb235e90f0a7fa52134128aa22b9006775840d0329a542262506c6284741bbf64e7954694bfc7797ec2cedad2877185d67a463918b7c75d010e03cc01e24050c5dcb01f5ac14e34e7f2af247d1a9161369c50c557df86d0785e2c0bc99fa9a1fd6032f19f8e2966c4519837ef21ec3887f7bdc909957b4f7ddc7b0ce17b1aa56fabb0a844e5a9fe785f67e39afcf474c34c76d95ed8a9cb22508c0a7b50749e90c3eda13a6742d81be25ccc5bb7cb58ec28bb0d90c8c594124c9e754f3970a1763728eafb3ec727142c000913e574c66344d2ed16145ab64f4f7b708fe0f79c097c8650f1317775c1ab48d588bac9f97fe0aeacf43536a18fe7dfc2dd5a23167a53ce200a63467521eb90d69b1680d3cf1a12e38495f79092f465ffcf745d01c133955c09d0739ff28d992961613b1a7f899ff9dfc81f80d314d32e886363d134881566c6d8b245e042851366a054f09525011855a119f15c2e38c90b8806a4eb8152461096aa18bddecd95507dad12892de89d63ad7a034d2805e1d9085dd87b8bc51d0596cf4ac4ba92b0d3fea77a3c80e8aba336d7823688d38d220e4438a375fd667b1eb6c01d0097a726d249b2e6b351f4737dca6f75a38d102e0f951c4f068bb046dc4d4c3b087151addb46708b55ea6fa7052f27d80d3ac43a20a05e7cc6d44659391c40de0d0db441d04e834a3ea6390ad918a8c1d7c62928c0b7ee72d609a314590fc138c5cbb287a1536ae909d45b2714ad7b46f1f44d36605800b1cfa72c680c194ebca08693b32a963a98491c9ba286187ab371bd8c00ee459baabd44ae2f2808d6cbbb5ebc4af91c7462c090865fb55f442c9c926f54f517eaff455f9d267f4e902a01a1b64e8f257e6392d99a58f57ce3f89cb66f9eda04724afa6c3bc7e555e10a4370d0eb61321faefeb90bbad7673ec251078df9191207233455f75563286b84ae14c5637d58176d546ae7cc7aeb3e56de27a31a5983b7ac54896dd5c0713087127e8c6557775af0acecab3aa394cac258346efa0063eebd678bb2831ce7a05b7a9d67096aab7615f9f75b22fc548aa70b37f1e621e055a1bbcb047f115fc093aeab9d5caeee42199866ff8de34a1530f5502c6ca94f12859fcadbdda213734143b4a88b8735d604a0d911e99cd7293341d35aa24c5f369f0b96d393f85e059965aba5833a2d72e29a0d4504523017aeed4a5e2d7102c70c4ac950e2de515a4d08ffe12849381c04699a606fa757f399bd094e293c1eff7c98294eb3ca950e8670ab7abd359a1ccb5272fdb472abe4b008a7d8812497d4893945c6dfe3d68233f2f15ca10a05d22b7083273e1cf7f54295f7928bf63a477a3ec4987b17f1b386effcd37ddfc830ee67c2d6689beaed6fc1bb7ea90faa8ae5762d871279c0bf4d8c5af45a5e0f92e15c99066486d4b16e8fed98fcd3fefa834547df975d25065aff656dbc605f5ecdbecc0bf5f807b7e48575a32af4ca86fae0e162d96bf29e78d75520b0c1aea6af525bf5561d741046ea7851de45c712aaa9be5a344dd40d4bca417a9bfda1d2fa36b433760568f7f813801178c99b08aba6ded71b51d315e07c8c1a9689f61480afa46375d699f0165fe2c53d104b9bf205dcde12679b5bc4db8fc1e238b728280679803ee57fccfff6b2fab3196e05c7e192ffd48fd2b83abe3ecc61ad18b2b5a29cb9182a059ef3d9b7d3f78d3fbd096dd32d67b908a140d0cf65c212c46dda9b72a26547f2ea5386482534f4c1cdd5604b7e12c3ba45566f8d7970eee0b78a7d5ec45f32c0a7eac9a940d18764319a326e1408047fccfb2cc3d7dc4dbde7df5390cd0c2100c1b91f00ff5a0d9d73a71e09a9c7e0a9994ee6e8afbfa34908da377410b1181e18a49e87c8d5262403dc9d6f20646f1ac9e2e42719b6957f35b77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
