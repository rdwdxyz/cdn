<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"300bdfcf893a0fc81674d38912be17d6f2ed65e5338b9664b74c7ea89cb8d8ca3d71f835ae5b2b5e44c71063cd8a363ca18cb5304649735a479772fabf808efd598f4f390f63f3121a394e7728fc281202dff13f4991c901269ad6bb443d11bbd6bfada9537bb48e76c1676ddee1652d41f5c76fad6b18552497c28d4e79e7cb7f7b8b50a328c4936785c1eeb17160b3f545f3300d2b2cfb80c9ad9966d5964962a110342f65bdbb251bd38629d2a2587e7b0f07df3c232934d1700f1b4a02363bb39d3ab2e2b089f9918a24d22fb75c8dfcb850b555230e10d3fd8ff85ee8847a5fe7d56690302cc718c5dce5735670f8dea35dc7afa697c66c7db7282f49c8f5856378408ed7373b48aa29ba19ff2cf7a1a61b518e6402d4b50c96243b6bc3acd1fea51dd052f0ad76d9baf9f8de6f36b5bd8956558c7e307bd5777ef3856ea5db49a254acba29d2b9b97b3a44bac8d35de61db47efae9840c3f4b41b7513dc7ed5ddcc538f5198b6f2674c003d15fee1f1f4bef2e83d4f61c7dfc5413e29890fb4e519de72f2ed55ef21719284be02744060ec32cf1513990000dcad574b88bee803b5051350046b338c798e1e4df7f985d94b8a16d1f478994515a329e08026d6ee41b1c2004d6149f5f7c14b13bccb1d5bfa2d2e1d59c3c55dab5f9419ab2da155f15acfe209ad09c3f5b9489ddd06a2cac4b3636f1632339fb9f1fbf94e753615cf3e4c8721d9d7448318af10c87aa4c8dcfbd3cd5e97531eb57488b2f3410c4ee3749c13970f30e7947c79baff25b126c9fb968fbff8e67b0c1a0c0842784629f87cf0a90425ea3caa465d47a85be05c4c205d3b2560b0a9b94fab1b01a5252a8e4ba9c7eae4c7cd3a73d46896045fc93736c761733c06998dcbe6e69f9fbdd5b2704a4ec2c809305d143e61479693b2d7e10a7c74d093975778cb7e53ff64229fc401901146a1e817bee4ac33d52d39da4b88b1a80ce061fd6c7c341671f3cdf1275895fca8d971234ceb8e3de1e90d21f7ffdf6463ac371bcb90d8ad2d94fb78f02346143bb16fcedf5daeb9c4042c464b184b573e035b6d61e54c0e6f27e43aaf6ba474d5b0797190bacbb4e114c059bd720e961e52649deee1f3dd30e23a0caf6db28edde8c4cc7dfd0a4464188e27cd5bf7cba8912a29e9292710c2fae0241e92367bd0384f3e25fc125a1d6e8aa7f0170cc427d9917276f5c9bf0aa169a81fc26887740b4da25b45aa2f9dc6b51d09ea19e577f633cad2d2f9909ceb4d48fce0d2cab284ca70f273f7db74bed3e37fc68634c52366b28cd833b1a8c889e41c34a19d6dee83365e46db14612dd6d0fec590ed75f4b9ea53515a9d37675f286f5c45ee933da0afa610cc4b98827caacbba476b7d434c997bc7607c51d5c2b1bbcce8e6b10d376afb285444bcf000d71b95ddb3ec45eb205d7b7fcd00ccba67f8668392a4872551705393703f6ac433174647b2b85c4a7d57408d929238fc8ae87d0b53a5c316e499c98d362abd9791a12a517496465abd72906ef3e7020f3a40028deb0306b341090942b86a77535ab4668cdc441066736aa5f05eeb5175c720e5ad5d03c37e5ae1961a4b6f55791c93e3929187aa4e2c96c79406e086dc77041be4df19fbcfcee082944575ac19aba71ebcad8534e4cdf9c0957b9eeafd848814b7c5c4a1dc33f21d678c237d9e31b2be512e50e0cb8d0aa0429efddbca266ef786fba0caa333cfade1c5eb373f544671f04355a696c2efecce2f47579c3f03a99d28193cea789e12a58ccc94a34a6c265684f211b89e96385962b600ea8193cd23b67aa1c8c6bf4ff65ef4b50a6a74fe3ffad950cbf476d58a2a6f40f8defb7c7e5ac1cfc6c236afb176a53cb13d488750b59e575a1ca0d66470ca78a33a8a4ae6400770fafe867539caa092efbfd65b201e9788e5455630100f9a20cf142b76b0a91d8821ef1e67f24c9d12067ad194636ad048aaef984f6aa74428e1549d2f6405329289dbb73f220a14b24b4d521b18acc42129b63ee382485a05da27753a8044fe598c0d5de36ff009101c7d6f84b2dd622a02583fe56cd762a270cb3a0c2f6e95ab37943caea200af19f71baa142f8108e1d46e5206ffd5202a4874ebcaf31859845a1055b3fdcb1cd280a3d6fa13733c79d98421790badd2dfd557d6626cc9995efecc6307d19729ce76560f98788a9dc1e46ad256756c9fde82a3ad12530cc9ea4951f7147c409324aecf4a9d896d190f980f8c76b014ecb7458664733ef8fb8139031e3ff239c8d77b9cfecf5daf2be5edeb1f1895e9cb3ef5af3230c7cb340cd0a65acc6f4290d87c17676c9e2cdd393ff8b7ddbcb5642772d217547903790bc99f9c66cd72812a82072c85f9820d211fe68d5783418cc440bfd2e95b4364c305e2e7b2c9255db50d5a5f70073aa56d9d609f1034b2df63c6c8e977e500b41074671c8d69a5a3e5e4b698cdaa134e5149851e5d9afff017aebec9fddf9857aab86e4cb8ee13b4ed1e526938e1ff7338ef77eda31bfc049f114bfde64be86d011e38bade79a0a836e854d0cf8312f9f6cb9aaa9cd9963d4bafd6980aa378d77e07a4497ecf2a7364f9abc1b3b81613330b0ea50eae5675ca88993c9262825901dfcc4c89873d338fbeca4420526295d075b5d87b81a15e1782b9f090628e5682e6b3ea3bf9bee05653244677168cff892d25f5ea6ff63eae665db6e35ff4360ee7f0e6a803e40c1ef2160cf5151d4bfca26f919822a0f555e68333dd31816c9e5b205528a1bab93d7625ffd43bc5f0338bdd1b46a96e1414f93d2592467439760e884930a65213fb3f79bf7a5a16c421a29dc85c70606fe344f662d35c817cbaea88cfec1c556a2cfe021993cf99308980de971b1db1dc2ee656d12ffbcf8a765a790ec69eeb450f2e6f87cc7bb97137f8f8ae2df71d0ed5cddc4a350be138b50f994daa608a3fa586b9a853d0e2ba5bd82450ceb4acd2c673c93e8e600459a129dd87af9de30a8648212d5443972f5edd0e7f688bba57217e9b61e56a16ddd58f9f67e9b8f9fe3908ab2c176d9304f7320336634f81708b860478970da23ebf851ffa54f8a72d244eb3ea8a7d66ca7d4aa4db53d9b955f7bb743ede4f4d77753bd9050d1907973f3780700095f59ccac770396606b904243416af94fc14ee5eaaf6cb28d5074337288da92d1f8ee8314f1920ca3ce4aa190434c3278a4171cb19a6238aec9ba9ed46b369a74346ecf2cd1c389c1b2551775eb389fe131fc546ce46f0fc2aabc8b413e60e035ce1ac8cc940451850af4416b7642b766dd2da742d032461b473e1585259bc04277042c7530f5dc2f8269e0702871c32094b41a079dacd13f8e17c5dcca5dfb7e01950e502acbe663fbce3b0c1a5ec04f49a48ebec028e6dc08f40d9e9f2e91bee664552c7a1f4bc83b496d27342931e3571837804c37bed81a3de8d152377e29c90bdf4c3895cee6ea9e2efc1f3fcbd9df0ac13eb5c37a30cad03b912cc04c11bc48f739b431a066572e373709a2332e803bfd1f15f8b3960ddd2786637a7fd3f194ad9a20e43ae5dee222a6b1a28d19d4d362cfa8bf8912f57bec304a28f283ccf464247dfe045d93d339b04ede8fcc092ede7c2b16aecc437a44b1237dd08a532661249773749745d8932fba95623a29a2d16590fe6df17a9d350fe3bfbf443d838c74e38b64da04bb59007b77af5d62d185fb49fd0842988a833c037c97a2b89d3b202a5948541b0b850e890c594f049c50388657a7054f1b6608e3c21b998ac561c6b4b245e9524a9d85f23a93071903cd3d62e12d4ace4800657e7157347281229c9bc0e3a5324db682351784ce01cb152052e268b9ec9e5884d6b21e3738153b8a4f5766ba5858d182e82e78e65fea3d57769d96117bfef1bdfde2572b5ef3f0e1f9d23767b18683ee203ca208cb05246e5ca4cb06409f67969ed41f5757b8f543dddbdb7f70a5166e707c154556f8013fd7e7745cdd084fe8429f265e5c23c76fad2060d97e885a94fdee878d8f8866803d8195568ecc6081020638a4f4fe1028fa560df2692dbf923e61f0b48ef643a1995b845856c9e65b587c6d9c6afda12a257ac4cae3281e3e494035a690af33045314737349336bd4717a3f518a08f87b1b9bcdfd25e04a3906ce99e71a86718e258b8c81093af92681c0a745843945994cc7db286753c1e3046930fed0523972a4f40205cb7a7ac4cf8effbe78744f024e097cb0a9c864a983034073c12071de5080c44e2c6f67b6b552d4d841017983d9f753dcc6bd02e738e3ae6c764be02d4a9332fb9b7595c1fbbff9bbf62b220ed59bb45bb224b1b9f58cf887d78fbe591d65205447c2e40f683c4bf4aebd8bed31f8169f896e491aa470a2ae14e64527bcc4ef651bfcc55dc8f66b018f0bd97f1604c8db5295d73eab573a839c296413ce9fc96652b2fbf3a3a6a5c7e711b1fd48937dd61bc611861668ec96315f561e269ee8e1999e0639ab526bf65a2877aff6529830f63b97286bcf73c62dbb1cc4edc971902323b8fd4dd7e0976644afc7ee44774a5badad105349f258659e02320bca0068c16b9a180b70bc5eb8b54337ac76bd332c7dd5f326427868a0a0b3c0ca174c21040194f530ddfe85842e5045075a8b18f21208bf9d2d6d7482bf87488cf384740a47a95a4c8983ba01a3b4e3d9143f7d348337238116ef199d776087f11d4bb89a96bc6ec182db8d2ae067806ff49f3fc2dc303d13eab03f414e9959786a421779d82c6e601b5020b4fc1713a43c864707c1b7580437063a4a6e5db5d05f06f89ea088c0baf0b1d8465d1b6fc5c6e7dff66e5ebfe32498599f0dcdbb086ce0bb262be2825de3180bdd99c18d5c2907a69359accbb463764674f01000b26ca9c859c35962ee76237ab705ff33b83f1a6b4e24cf7d425026889da9d9fe6d846e73b7f15336900d7038a344cc8a205fe7fb6470d8b25c98dd5594c0909aeb166a527c92d566f543b13d43f8032baa5c88a51d200c2b9206e76439aea5452db63279d2f80d0f2b927f7201b004472bba4313e413cfe44d39d6c7a83ed9c8de91d723e591d554f19a5ba6771bf4ca6739f64bbbb4743e7560802671e2507c6749e42a8c0a3e0ffde2a440d032df30a28198cc90572542bc81ec70eca5131cd71d0f6b96f52ab782eb12d019968b2ad980cdec97df9d511b83e67163d726647e5af215bddaa51cd2df325645c2a44155d1abd390b8566f3cc24eebeeafd119252db9c8925d3f341cc884bbc812d33c1ba3c7b370aa9966f82ef4af76965f40062c89409965620110a1081c18485aa3a4bac8e09599801cbc75cc216cb9dca3578da0efb574500082c2782cceea098ca2451d09bc34677a5ba743c25d75a7686f633110f4e2e9877333cf29c6013469374fdbd5830b1138979bb9a11552db9a4ae6daa4e82d0c9bf6f8a3358f31285aa8389ba7e07b1e4b0d29f594b94967f577be6bde1b97701ceb7f01e4266589a3a9db65cd2118271f78fc702ac959acdd14d218d27736b2b1bd90f3a54c50248982d72d0f837a5a41f2f2bfa03badc7169b5f950a87b7b03838f66afa69fabb3314097bb5eab9e90c9a8fba5842a266d861999f5ee718be5ac359619fc9f8b3aa82a65cc0a13ef1e9c6ced1bcdff1310d7f875ab324366cb802a44a09ddb266ee3b6f15b5625e8a285b57f64eb5ff6003a47af02a586211eab01cd9725b53bc2c3d3282c89c845567db4305bbabdf29966c0a28c7411f5c00405d71b5e0606fb1b16119bf8ebd9e0fc6fd9cf2556462a0d372a9a10e1226738bdfc6a5eee1bb0dad22dc7f73751bd4338e52be2c92e70ea35c7fccd03a7610080f52fd39421c0d305885e75dd1c299f7ac2873f8c382d4d7cc4f8d53b65d43db4409a85210f456e79eea7e10c524b9f4fa15e4d201de913fc5062313f36c4f9b77a6a218eba62e575a643f400a31b44a053e3e60ed136c934e40754b27e69133d4243e5e55007044fcff8f39bc32e71c32d74638b5274346d61b301025750fa4ef13adc5dbc5a9573295d8b3772e9e302b02f802e3c9c859db6dfbe144cffbaa86d0dcdcbd573a7ef0b0af5134b941927bcdbf5d8fff1dda64037705a18c27e20d3d5cb4de8f0bb808047544a0fcb7630a5c7e4f255b04e6bf6e223fad97b6f608a43115c5b98771027f4e9f77e89057a7586afcb62587a151c27f61facb15018223fca60e4d5a7f4f3db6d229bac7b310137d21cb5c3e09dc1a7cc981cea23bb890fa1f0619d44f9b98f6bd6fab2bed0f935beafd0ea6a6b27ec2735d6f66706aa9ca3d2813f19f44628066e7318bc2fdc951a9c5c031d754a4fd199e1b23c50c0cfec8eed483f1e5ac398b2967c28a97983c32574bac30fded6a44e7f7363a26713ab53b160d81454e92a2625af06199e21e083040acbd92c56fc5e0dc8c596014a612d38ad333f92ce2bd01816ed3519c2854df86b6a6c498dfabc3c8a69e124361f3b221c81a3e35b8e710ddf94fb31249a704be5a57f2eeddf80aedf5ab0beb5dfa7c93627e5fe63561bd87ab6d3e434768eb1be18ff10b8622fb0ceff7ad0e21da2c77d1cb01fd171141c3be14b0a58d1cce4e7abbcea5c4085316f2666a45176513c8949e8982b576b5af8789b9220b1b4ec66e225f9db13463584d0cc535204fd34ae7d5b0ddb13d9b306533685cc50f36913f6ddfa7ef71c937c208d416e335a29245ac5f2f009352067f99ac8ce5cfcc120dce14939331bfd3c14418017c087f2bfd7ea4fd287d1ea22570cc47d165b7e6b9e1cdc1e234afa7611e62ed46c66ab4e3904714ffee7769641b7510b31a3c13acc22f22e33063a2fc91a05b74dd6d5b3fe13aac6ab8def92aa1d68a1caf44ab5430f21a6c11f643e730721bf4e20e73e837af04177ee173bda644746bcf67ef51e7ca191fdf5d03f2eb5ec14b1db83d47cf3c2604385cd8bbad25326e818246493d6d4a713b592320df535674f3daee9c9a86016658b0dca2d0fd3e5533ae2c0518219e11a54337321e5c23619988546cb69d5c4f09751202b183343bd88a761fc872a4086324e05b3f0b490f0e0d21f8377969bb6df25980518ee3f57017cf7fa0110681fd402bc9e6c862343342c7872114c64b9b35036478d4c2b6d33640610c8db08a2e9b34f3123c0ad915b5ae46da346fc22e27a2c952eb672acacd00c0a39d982cfe92ce71c0f6cc34911ac8228189fba2f7abb797b63f72bb4a82cdbc0aa11e7cb3172e5bc8e225e713556b2221d5d283dcb73ffe7d52ed82ffb94ed8af3174919ba1392ce34b860cf9010334c65d4b45d3b117b8905b42783da562d0d563628b5814103e45ae2d5e9c60f0af24682b9fd2892aa1d1975c739c516c1809b58d4738bb5d8b17c027eb9d9d2851788c7a2ddf07141ba9293a71bfb31aa6485945c884512c57b26a7caff88b5c671c963d4960dc323cd9f067ceb763a85841946c9093df8ce849294426f2cb18e1fbf818d358f1d41702033bc68f674a3fe5c58f382468aee459bf48277e7dc4300df44b6e5c03c01082dc9d25c545f9071224e86f036acfbd45b60316e2f29ec81c54e06956090af2f91d9f3761dfed92fe87d9f5f290fbdb80fd667e84b55bee5545cd94e483be8e9aeaa8fff385567d60903237979d176ad6811265373e0d2169369476a13f2fbabf9b630c6327bb05acc00b4fd253f9236d78c72c83223e20ecabc2573047ce7221565ff00a7ce4cf4b7aff118f0866ff50db18eaa9cc21417c039a8bfaa2aa3db64cd439ad6d5e9d1700299865784c32e094600f795da4104ad1e5566d46975a2ae6ae2a4fb03c777b7095d0760abba61aea4b3394f76466a171571b46e68295d046dfe958d86ff3c96f36caa0feafa2b24c9d008a14cefc11335e2a43ae138d6ccaf750accc6cf6eb2cd7b60e0262fc84cb8351355983544c85bfd556867f87afa54a8571251de1073a5e97ef61031f7d5dc95e45b4684fa74ca40ffcbd643cefc652c44c81602967bafa7909701b66fcd2b35596e0a3676791766c49a94f5b49865013d15a899b800d8aeae56e39b9d1967c3d541140800dcb0fb35f3537806b0ddc919bb412f684a95ddf5c5848c063fe3fa739cc313cefeaab9f780bd905bda2c4492b0a16fb471394c89ee95f02120823d94ce442deed97bff5bbf010121f2dbef51e13793085206b1d16e62c5f2d777a87ffd59efa2934375f7a8c1828b1bcb4f8074acc2933e3b26cf1fc12a99ff0daf5127d9e63b085a614687adba0c2542fe854c362aeaef9b2609b26abd2bc2e201908750f7d5389168221af2be0e425e706fed7589e25bf54a3eab8888d268d82ca716c2b103e57b4dac0f82c9b5ebeed16365f5df6ac8364d83835a494dfd6180e0d2c68a92ea1ece158bad9897674f324383a1c76197a1da8dc87b1c0c239579f63534bef90182569f8bc552206cbde6feef52c524ee8de190b08e5c1246ffe6ec00de06c7930e8f2f4424c9910125b1b483f9e354474a151ca45a1f4ca7d11f2b3bb7f432f315961f3f972ff9bac34aef9e24b37883b56efcfce408b417c2eb9ef0d308a8b09eb5d274f6e533fcc9bc5c49495badc5a305cbfefdebb756196ce0f45724503ad2520cd22e7ca07dbf131c9318f18f3c35f2d363ad0a60629f79e26babfd88e6b8c5720fb69742008edeacf1998d1d8200fd6ba1f96161106b329bf16f8dd0c55fe406287eb23425d9d27ded11d2072ad6dfa257081c2cfaa9f3de2fa6ccdca3a8ccb0a26216c40b10399435ec5e3fc7e177a11ddd0a2368dc22fc75bf73fd4f8dee4c015b9c632f925b09f711d4b64e3f211e98405a8fc4887912070fa44e32b788f3c474880bcaf67fed4a919a48fc45dfad08e236715856d8c79b83a24927c0af2c5acd880b7ca29f744401b1eec0d534dc858f718237aac4ea98dca2e8aedb2ff30e922f458dbf95dc550d52538a90927e13f54ef77e5e0177386a7482e84c2774580ef72e62bb0da8f4d073f24de2530a3b125c6eb2c3d64ea4fd933790207bdd277e77a9dc4db749d4ce80827ec79424002f6c61a61069ee967cae7105e92189c9a8054b7a9d3788cfd4eb371ad1d3f6acc0d60c81b703f9b08f25e0157002e4ea516b51107404fe5f32019db0fae3444ecf5d3b2722e7cc79e2a54c7bfcaa53d733bf98f4c9f9448059db19d0eedbb6b3e245e2b439d2a1812309a0a45dcb99f1bbdb56841e4750de5cfce41b1889c150fcb817c316e34c52904f864be33ee1f54cdb60ad0360d2eb76e737c7793737eb3478ae302e22bc756fb98602a8c7fb12e02bf37a84d9a8f27c13c652953ff3be207bf0892e82da42d6f02eaa92e3183648a8fa4ae190dfc75718274b93e76691d657352d70bc43210e483657b13239d462afc654f5d53d7cc2ad1fa9de1ca191f452ae5805ed3bac582de93607e8db24e61374ccacbdb64e390c7583ec62c4547b099d569daf11b35544d9f2a6a7ad711b55ba3c39a25d78b69eefb4cbc00a577e3a7b01aca0e33175b0cb6c735091c429e738f15ab59b7af64b9cdb476096df3b56e37bf6955e1cb0edd6e826a46ab3336392637692c2582de7fd8e16c6950bf022c49354b634d70bc8bd8cbc3cd69821f7aac54a8978ad592b05b965385d26f5f65b1c37601736ff728cd6d2679a8bb2a3748f45c85ec97744e13d2f1a5d33be126e1a0e6e9fc78e80d8531fcecd65393c929f7daa179795f9185890d5283b902c1e4e599da7a1b68d596e56df2138b03f4b364f5959af3ae11bf677e0c5e116bd88a626d58364a55ad7b62e1ce94a7cd138cde9ccec676b32d18df5c6c83f47558274004eddd16d2076579aa78e8e1ac1eabef782d5917ad0780d8b2f516773ecedc70369eaa3df2c3a89b95e9329fd86dfacf742b3c66c753de8be8bb38da07b18831bba6065e7fdb24ff52ec8e0c66121111e534c00b81af5f9c659e0aadb6d39aa94f4f46a1638ddaae9a9a6e3873ce6488d44d6fad283a2fbb727c196677f146e38b8e0cac31a9bfa3bd029b51c764be631bf6cc65a7487ced99b43d585e020fa4067f77c581deb97580b4c5377dfcaa30f5616e1e4bae28b4c03303ad4b86b3d71f81922ca3efacea0fd29caed5eec1f43902001e576d5ae10b828be3e7d7b122f0faed759a6091d550c0125e19a1d0c73dd711ee38718747631159beb5bcacc6e62b15417671f94c413b938df3a50a68ceb91990f4467395960ddb65c4f6e5ee8072ecc501900e16bffc3e1870a2d787392d59134537af1fb31bdc7c2d99b94376c014e9d43f8dc9ede303d0648cd9bfc906577cd2e361f127d276e11453ee9366d7fa25c24f8c97263b523fee9fae4d725cbb2d6b5901cc43a5bfa44f52ecede6d7292a48e91a66bf241727975eddd2db5f2ac430ffbeac35942452799fdaa0a4dcddf5ad008c4101f82d3519526a4e8d80ab6499e301fd5c720246ab57c02fe64b743c8130bb8b522ee7eb2e591048705d6cafb20d3aed44c2c575768c43437233cedb65f9a240124a02a6b4189c9f780fe3f97dd2913bbc1c77835626f07dd02bc6f33e573cb13205720587b3a3cd4f2dfe34fc9bf0627521f944d61e6275315b3cdadd6fd5a9f820c728804651061abce1c7d656d3c5cbd5aa67ab1ff6bd6d69f3adacbe18ed174c60e173ab7a235fee0cb6e2c76f223f59f601331fd4135a826a33986d23753a3f0747f5ae4deb715bd217418293edf51e9037ebbd2662ef2fb9735205559269966caae4d36f377542dfc8105f597e4b66bed0890587096e02f430183bb3e17d138e32ac828b83fc5b526d54fd0375607d19fcf4c12e43dcee05201a6e305f1bc4b9e5a6576d23a5ac7cc321451dafc1a095d59e584f22e1929c04a0a1198785f7f3d17af580a4967d77eb8d021498a41956bdb84e14f0a0391a327e549f671312772c7d52f9def7f6a06ab8b1d018b807dce6c5902cca8479abc6aed2392fc7c56aec8b69d4c81038dca08f756dc28c70f60ebe52b412e5b9f140052f13cb6405f6702992063cd3d1644acc96db5fb23cdc1fddf410f1c7db43fdaa17534ddaf5520a145c8abaeefbab8f7993dcf0d390a9002041b76e450cdf1957e4b1b098d62ce55b7eb88923758aba93fb993055f7afb64c4ddabc9c5c06cdd8daf28915a7c7b3ebba5615a37a72ece60910f2a253fd680607b0df30fffc5e6f06b2048b1332cccc5c3af4c0008bc12487393f5a3e6978c03799b7ac2283f504c54b8a97f046e16e39c700d7636a0e686fd0b94f288b789ab8fae31b19755a6eaa16f41a82e8c32e717d12f0cc97326a2e7b091c86726491ec0fe3c349901d92e726025d5711bfcdda46212bbd0360de16ea195b5b94e15e34e73eb546ad9a6faf91d9fbba87fcc72df98c97bff2cb219838c6b27d04d6aa401f6cc4c22b7b534c782dcc52f00503fe901a51672fdb9b4c29043f62275dd1d75ed741052bcae93dd4446a16b6d70761d5ce37da31fdbd430fef37d0b6313073f685d23b50e087c1c597275d95e404e455da658fc6028502c6c54f36d3fd22cb752e5865d5439fa7f50423e0858df4b13af3612e1cc890a1a96c9fa8efdd554178d6cf7bff57e89deb7f173f868cf637d6d1990f2cee22b5ffff0dbbd3df086c7ccc76f43274980c6ce0f6a94fbfe9bbabf8170f7567d963f3e014279b0a7644778aa7f433d03adff481a292749a326855d8cc280a6ac502f368033aecee253ee1c5d56a3b3d886a8e62deed58777a2c4590d6e4ff35f227d170f912024aeb87fe513baea66d94844c870458b9d8ca48c4c5f7dc948f3a38383c49164fa9f07defacf77efb4121387639db253f770f3ef25f07339729f7bf0902c73bb9b2cf59f934e852ca58ebade1fb6f842a85828a6fd1b1a12b7a9c148c4ad849251362e2467006fb73dedf4d6a09a4afff99153ed1d2cd0a2b7fcae52f9b2b436b014b16461caa390609a27e6f2bc2039296d0936f8cc90558a5c0a2c68419eb725800924938d40e8a1ab28d1db34ad8eabdc5bae6b774de10f423f1402ebf07a73188e3934fd20592ddbf2c64133912a1e44f6aea624d8a25b7d58d049a5a8f377b55f3eee86be5d7ea9f2063a1e34f86667ac59cef807ed2be81f8e56624c09cb24933dfc66ace5d4ae2c76bdc354bb532ab58beefa60dcbd32bacdd8d9071f29f4b3b759ee8ee2de63eb90e235544e0c6c25325ca0d96e76a609a23de7beec0f0e939fab947379aa06b62daf2f8760c1f07ba4dc693144cace8ff7f49238cff37b5d2b1df6bd171c93d349b568359a715e0f23da5caea9babb4e6cc6aa34c5517ff2c815231ad8654b06ef038600a08f04f3b9281aec6d6ad1848a82e880353cd89aafe509e40ba78284a403c46f2769e8def0c618a64425a4baafb474c8241aa88731514bbe7b0c9861c4d58ac9fe35fe44700f6c0a17345e00049168c0f0f04b6c52ec28d8e388b0a4700a6b665167ac7054c0bcfdfcc93b3cb2563a601e6b10ff8ee40efbbd891f3640b7ea1ff64a805a5e9291d219b80587be079206d6af099967e8f9289667fe87fe8559d4729c6a04e5e3bf7a80bf60fbc3e7ebaccc7b2212691f94c0cbcc95d5437f9c21363f0a2f7cef3fc03111301458d023c0c39866db7903dded4f5ce28937756c930b5374aef1a609d438a1c119a6434f6ab9f8a8b98dd69e75a9cf11481077989436f17294c2e4cf4f15113d8951f2bc9e905f1d11de92a252321e96e0e57d1cbf0d1b0f4ce6658736134e61018edab0768f5502ffd92f78ece9090205c2dab76f04aeaf0a5f52284d8855a30b0446f208a426459adf422de393901092f5472c2587762755470d476c33e3517c952861e40844b24296cf678f778a6392199526f12af2c3c26c57921b2f7f517dfd9bbb3e0350bb08ca0232f79a7878f61398c23db9c8968a9eb51eaacfc802f9cbb486d56dde3c27d8792ee1573fc8bc1a20c82cf73d640d28443ae180bb70abec3a0d1a731c52568067fa3520ad5a827bebcd11df9a9c0c5b40e7a1f80d6f43c62c14e2184f597d6ba69540b9c301a67af2908c4e071ac85fc8c80875f61dadfeafbe48cff4c66d91609ec282681d84d9d1631f47c1909dd3a5720617a55697671c50fa7640429c2d0d04c052caa6153551b31e09b27b9668b09f1cdb18deb4845493e57131c79f070fa7ed8f74e4107aa81d8f25c68bc67e79a5fdc18374d355553f89529fa3b51bc2ea977014ffeec2f74209c6b2ca2bffaebd1442272c4c16cd99a02396cf1d53180d95b6141e614cfb3986a95230373a98d1fa66b51895c7fea150f4d11ed35e509c7141938860b40f49c4d03f38fdf95c08dfce257e04d7d88e7105024303fa63d32edd268582c8eda48338ff4613237b8efbee6f9896f0d21b4e98ecae03a7ff52d50e92a349e752babb610afd1fefe6f6f6ceed45220df0428f966bf02b90abf544c6c10319ac31331cfc41913c0f90a1e6f3d304140d52367cde4c5102f29f021b70e62b0b79721c9a2b0d022276e0a17f8f64b88467133ade1f4e5e9b65446ba229dff0cedb0ba5773f7236727c5e7e682398987da04d1e8535139a88a3d09f7741e0ee0ced0159496daa6e2f7429693e5c4ec8089224b341772fc9a9763b344888f9cb0c0bf79e11c9191e2cc8cc9391a6fc717029c590ffdff58e84a5224f8255810588e34cd3d3ce634da3df83eadeb56134bc68f69caafee109f95d84059a524bfdad2a56329b9cec8aa510fdaea5847fa9944b30d375f6b853c68c6fe9dbae05209a21e9ee6f16c2c6cd6d939b0363d5c7f3791354423862a3d81585bdd1ca20ee021afd491643a2407dffb1fe9c2f3f14e7af71dab0130a3c09c53d10009cdbc4cd2f43b83d5368dc9bb67ecf494e854035f76f0304650a77b7cd929a217ba6b43e9bcb0d656c37067c954cf0d37df4a84ee7181a3cd088da712f542ffdfc27d2973dc6e85dfcac3e7b472537133c833c329461e711b15035063458f89b048755fb58c8a1a94f5b7a68fd98d6f479e0c2c41b0e3b2186202f830798a0d6f31379ee532859fda3e0d45650e15df736a067973f14dd43e7d34ce215b0a6db98c398f1dbdbcc9cd90ec3d437b1b950a1c6defe8703653b94533989ab9ffd51b7937d73051f9283a7d60a239cff804c5af1d01816a371b2de7fbb5417d97c455985d1a078aaf7ffc945619b58a1f31bb667680068c3e803baaf5063d5af4661d3650acc8c49faf26eb9f138224d3082c694e6608633aba5469d0c5149d0bd4f2bcfcc40c8cf5ef72ddc4d76e8f67a556cb05763390680afd5a2d5362393cad9beedcd11227b0ae326ddbe7223f869d0ceb8465ee5bb60f2cdabdc6041b906572cc72c02f352f45119a0590d3d266bca62c5b3705fe60f80a6a53ed27df08f49903e83568260574c6642cb6be7d51960be7ce13acf9f01c6ffc05af5bb76b3973af01dee79fc527a25ddbe1a7d36f7b5e84822f573dc361e7da41e0d2533c3f31090ccb9a268d0dfbc370b0efd55b0c4d162ad50ae5ba6460eefca60aefeb7dc0a61b38aecca6372612c546b03c123e6c63e20a3e9a0342c91b1dafa85b821dd1ebce12d0bb574fea68629d3ee0e4fee0a9294d9ffa58b35168dd6e0b94b933073fb98e7991d55f6b5d63aca989399cb6d104d0f30e47be86bd05d2f865a36d0acef6074921e08beb571f3dba26247112bababd086256f23beb332ff959263d8acbba2997ac8249e8e265c00ffc5b12670e8a27251daed675f732c54d156183b5a8abd0d9d25b050c44444038e97b396f3a7968de92b81e67020cace45437d40b22f8e4732b6a2e1599171e0bd7f7bcb97ba35892da5582f2802ecca439021bbb220e0dd3855902387f8abe60094a4465f0bee40a9f1314ab20e71f0bc6a7ad7be472cb28ba3af3718e422e6c4cb475cd26a28a075ec4452929658d98d12e8889b6b9064446cfd2e081e8130b1c7742c0d06e26e469ff379276dd182bc358f522dd76d74f9fd45806f12fcb1e6718f5183e4eacebd2a702e871189ae5445b84b4c8b157c381ead1ee05f800c43f1ab6eb65529f91f2a21a24bccd9d1cdd288a1c3ee5fdc69aa37290a83f455e96d6b741fc42da427cd1a1e4a53698cbaae7eea4e2da9e4301a7667b4171faad91e10e4ae7edc41d5af1b8be17eb5be86c145f30ba85a40ac60ccfd46cb2d5341da2c0617c30fae801725f2404323c586080776a5c82d8e514011696613aeb268ac2cf4279dc124944cb59ab0c404a4026ea717a6cc158f9e4cef88b6021f23b818f46e0733a6ccbfd87de46402d6b1f7db27b41168fd9266d84c80cf84ee6c0baa30763e6f6ee6bb4858b0f569846ca4841d6105a6740e425c587869354adbe86951c6ee2c7b2fb44240637c7625ad745ebd6f14af2aa36e8bc6a213aa6529cc6b181ae37e2dc6c6f68ca9cd4aa55290e4fb51babd076528c596637d88f8b435b86b4c28ce2086b87b79866e58a241e49d7dbfdce25ae168390c5566fe2a30d9c40958617eef86b73d67471cc7dfe27317312af73f62a6bf427c5213c6dc73038f4916a87addaed735f17a9007a9ad9c97044c26bdaa30a24bd4b1f73dba3495f5f4674a2dc90b73f4c200126ee8418c3a3451e6fb949036ccb0776ae5c82dde75e649d2b33e02af20ad4fe8ddb3c77b3586bb648ebaa0943daa971307ad98ef3c6edf3ce0a365bcd62b6ec682c76e5fbcf9e609bfe261f522f48c866378deaea2039f2fd0f09ffca7e935bffe225b44df998b96c81de2ff1f8d0993ef482a0463a639190fc02f7b5aad34f14e1d9c93b873b6d98cb2eb7dd026af15b94c85ff7334d0a7b5a68a6bcd7e62ba90d0b0239399f386e544838aefe3e255eea62859d10f5a5204b8b066b8df83aef249f94ae5da8cc5d2643ecb6ff6b2268a0082ddfdbc2c6f90e00a168af23a45fd91697a3ec179c0da14ca488811f245be2cb0d0723c556364cbf38830d941017619fec5fdb9276cca831a9878a772269ec82622e107d58376c8ad8237fbccffcf727f5103d8f0b2202bbc0747299d259a85d27c13f925773c3967ccd465f583c90914276e9f0dc7d16e2d089a07fd1aba41e0fcec045b0a5653bdc55b03506a939b697bb2f8fb391b329e43340c7e0eceb069fc815f3344f07354cfb3588115e74e476aa04c4285e83e4d3983b3e3da238c19fcf1aac2db065e5476484d1c90af3a15b62c966a8c4eb68c79076217704c982763fdceadf2eea6bc6ebe77aba7c7d84bb67cec58890586a4c0455e42272cdeecc80a177ca73ab713d7f4b18af0dfed5cca1935097ed65b221652acbb30950ce48c0a9941c608299c3de5ba5dbcd65d87cc48f04b1ca50e36ca91c9faf27742e942af63c6d75ca7564724087ccbd659547baaede6901f04c96bb32fc4e0025fa93a4571e3ccacabcc5941f37607647d2d2b8f53a3c3b57f6e815c4165738213fa491f047340c1b6b5402c03d0bbdad157d51907fbd1ca44b007109fcfcab064ce2bf5dae73a281ea5294809fe26d89ce04f89138a540a6cf5197f7ef3f2cfbe0a2cd2554a7a8145514c0f3c2128ef5b1927c231a33cc7104a8086035f036d3d3e03561ba576aebfab1512a3b09721c200519236e02681834aa8ffea7a930a10a061cdef606116550e60ae92dec1c92dde0ead94c8f70b288b58587a681a31a3963034aea87930933e8bdf41b663345d046541171db013624671143820695f809c12bb468b42e0d6fb31f9f4c69e7e204b3946e0cdd1da8fcb4904c50d41d4bbcfcd1dee6cd9ee3a1ca33ff678456a7fdd7e00e172c5ba653e75cb112ddb4e4113ef8726517263188ce2ad46be1baba46327050ac81580e4b307929abcb09649e37d1cd44ade93ce805037f587db6e0243bb0ba01ccb0e9e09b3883e0138fa83b806db7a1fa1cdcc303bfdad8130b876564a99ed4c1429b5fa547c07f7b26ea530ea17d79ef5f00ee3f274ca4c431653054cd65bfdbd7ab5466d91fbb4d07077a9ee9bfb30d52e765d015d57075c37b5ef34c08c7e593849072419599869ce4e11a53a5d1f68d2ca9f30aaea3f863aa8a9e51ed05d1c18cd1f5cac17b23b26c684ae78e7c570893fe805544347ef84f84c80d3e86156fd2f516dd05ac56568a5e472a44eb0c7eb1f0a60a39b0a8553c2377de3111ca2b4278c56b0f23ddfd375c90fbe4d983e4f185b7e9d518267e2c35c271df3a3c06b414ea41195a8610fd0271e9a199ede6e6c3a845535d6f58cf7b7ecf39c1179a0f4658c66775a4d22e7ae03fb2f3acc0ba4c2779d102d95577b850eeec6d78b39795e96a79b2756445c69d8db181ff6861667040eff9737d118751ac0a9b1615f102162142a496043ac13221bfde10574ca2e2da9246dfd2acc441aaf2eb66477d44ad877c4ecf811d29d08ce855f0b63311f894e9d740f6d7485c791c88659fc4c6fed5094f04d5ba40b3b83be3faf17aaec0c9ec41f2c15ffcfd179dceca6f25ef5c1bff4f80fda635d579ece2b666080e5a14fa81dee0a1dff01caa24ff35c6f93af0fdb1ff6563e558a43abac44a9edca40249ba9589fb08b8c5d1bb9aee0e966bade598b4d2a296f8ac61d32d79340c6832bab208418dd68812aee88d8ee513823b1ec7abdf694418d8745e3cb282016aaf2204bd84e5655420cedaf33c2c73c3e8ede32e1abecc5542fed5e9d9acca3a5e7a7ecfb43e3e869db6b0846b449de10f42acfdaa2179a78f513216cb7a5567e6d4c4ed739700897926c697654804eeb1d2c252021a4b882c72c8c32d319749ac736675d655b73d7b9195b661a65846ceda5dc79d4e84a20a011a98f2c37adf9c8ead3a6d8f9c4d4f0dd1eb8c570e707bd0b5ee97ae57d3755a1b9f4c756166b81d47e72572e28b3e0b280ff03ef35758c987164b052e7c4e53987b252ab757ac9206020559a945991bbb8bb8b392a5401b85cf8b3c356d6801b5966d142b3b93859a03b70a6ae4c1a227c687b49f4651676f0ef6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
