<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2506ea0ba903e89ae3ea4cb4dc01b849d3152c0c7e5f3f49961d266dda6d965a2ab5916e10a2849ec2c8491b793722d621586db83098d05257aa3a413e9ee34880b92484e8bc868ea32da0741c85b54455beb6a38d865de1f446aea36f3fc6b8d6e6169520880889fdd0d5260d369d306519584941423cbe65db10332b4802b8b7eb8b556a614a73feedf6b1d6f0bd90efcd3dc79ebe53faa5338f35623fd2e2f2c1a3a755ae953933f4ed063612d6ae63bdf3d42f59f22edc88de1df6598aa0b82b63c754b73ff9a36c1f74b3fd3f5d94c23e0a91f2d3d6df3032011c857369cb96f1f2affd3afd61167018e8306751f0a07a1a76b90bb6b8975d80cc37bc21ebe67dbc0059c7ddb1fbfb16d7deb52054625e2b4df368677b0afe5dee2434ed32db303b986888738048361ea2bff5a7f96d8dfec2903b1e65750afca75d4842aa6fa51c447d7ea6b6e15eb7f825eda90c074335c9a4292112cd7e94442ed88567b24807015a3cb0c7b0d846670f97e3bf6a62a5c9401e0ef0887823c40ac21975b33c63e7da5523ecf07f1a849ae4409c644bbfc0802391a90ba665a4843d67ae003337d15c94db89c3fc33ead26cf447ddcc6d5dd1886f7d302b874596a76f3967aac8dd16fb1575418483927ecb9fa79a43c3b59732c2a9f9a66b6c8050947779c54e1278843fe6c8c8b305b718513929d18012a0f70ac1ffaa4007929082b26055a981087b1249a030a4cbd18cbe00b71894a6459d31cabe99bbf76ff8bb62506b422b43ed6cd20b5f716014fc564531eaafa7bef214b10cd346c7b03a9dabbbe476e78a26b43ac99b6230cacb8d00aac249c91a2bc4bb320fe381f033fae62419df4c0b850dd5c9e3bb0213cdbb2a651e166e8c72655ce5a02ffa7a02b764be6d35f36e55186a2c47a5574cadf4886e06f9b77170841f591c7d5cc5d58257ad3c7f18a2412c272df5eba62592915c36818ca118d3aeb649a461aaf61e200e37219de9b365b33dab4fcb428d0464f41fc5e9fd156d1bdadccf3b86f3ee2a3748f81d380fab5b8aec11fa1f6727a745173c5f742d81bdbdbc1bbf9b90bfa6585167108a56a5470d7e8528946f7b6ee044872bd07360a3122e1f6dc03c2eedd5a21f62f29d54ceda6a7c86ea48b2559e677645616282c3669b41b690837366cadaf2bece510afb50dd3e9432640e3eb550250a3e4e81afacae3f4e264d1f5313e67565a4786e7eea42df2bb3205042b78f35928da174e033fceb81f9d7c882b6d44f34fc52b79a958b6ea83e0ad7f8f4d9ed3f4d79ff796bf86950cb967739937ed69f145bf456d06c42b5dc46d799f5514ae268007e606243096c87bc5d50d61b52c0a85ebc4c145d41e8e85ec96a6e53bbbb7650da4938679b3881b444f1730b355ab0383e89d87709e6b40452201bf847b83cd7cbaac96d83f70c9ed7028e50b8137f4a663d38eec7603e48f365fe1f11887817ebdddf82f7c2ebbb7a9bb560cabc864cfad5dae69b9bea3693ff2ce69d61c5e62641268be4401a125ce60af03c894785d601c8eeac22cbf9e6479d90e790f5042536827c8dc3ae2dd60bcf6a2a83f60e565228e94b93b6fb2a87755b146bccf65642cb952edc0358fa1306d050d343cbdd15090ab5bf1165e38a39a489dcf99e61efb1d6a642f6e6d4336cb392775d12941c04f6d4811e02bd0b643d4ac151ff39ed0be354d45dc62e8610b432e71c2c0099a30ab794a1cf6278b94ea68bd07089b478a69a54ad6152d6b22c02a745cb6576927b58b034fd335bcdd3abfc440cb818454ad78c64f0c97ca024e5402007e5cd3e345d291b262709e8950adc0d5923b508af1c6cd63cae55eabe18d288112708188e61ba131fa2c7bfb46225a998b68ca3831b4fa74446df4ba96c2880e3b2b19ff0137f82636d11779e45f9f0e3e9dc00e7f50142a30e3bdb6512a59d002a287d45c000b640410f53e69f4a176de07e652d70f9c6c6d87fd061b95c550c5eba514d55969c61156ae5134094dab457c465482666800c01368fcb05afdd1a4bf5905d127a5f928e4a06a8c98f5b00ac668cc4f47cb7506f05eb7f11cea98b661dd0a1384d09d9c6ae2416c64b739b6e0ee64a107dd1b0a7115e040b92fe04e88a27734ca8dd3660cfb04fd92dbaa227865cdbcff601e428cd8aa056ee55b6c168a98f7c41b33bc8c9042256d50048217f3395c0e9b0cff19695d2f2ab184f93aea00c5ffeb13a4f168f868be7322e6ce128377a3b66f2a97b58662f951ba15a0c01e18f80db38dc574575942f10f79d1aa1b96d07d4a6164c9a3615c33fea873f503a70d34ef1b2143e643125c63ec9034ea766abc11332aa44ed2b45401ee215d97d41cb159d7e00ad918e7d5406ccf5335c358290cfe6c7fbb00bdf22c27181a83ea2df2840ccebc187686746b721466a1bec470f2d0a086bf3d8a01595be8a45297a45e0fdaa8829998f4195a4d5e15634da39adcf0eefed3dbbf8e0506629e1510b2371215f377ae924cd4858be4fd30b4bb584a2e3e8ff98c8203ef89efa0df3c4acdeb64ed2991fefd24fcee6d4d664125de1943f383f636d2da7842e995e18f46f54b157f291d2c45ceffc63ed4aacdb7547f3886421db7554e907c1391eea2c6f1764909a6d99c63e91a19286d5df95db4753bc180bdc6cd1c4f33f8524e9fb34f4ac899106b6ea0c2ee7a5c187359720bd8f94340b80ee05af54a88b0ed1acdf34e320bee7f358c2124b2ec54f153bb9082fa5608d779466d72fc2b0ff123aec64794a860185ce0cc852d39e8a1c88634b73cca321bc38ec0dfc83ca74f2c0e056c167f7260e0ce1532920afc115786bde1d0bd36c9b3608d32a38016d27867780ad7f7d6e7ce009a621ccbc33f301be14d527cca96a3950933f32dff1691afffc403954593b3f4ea6c9ec6d16a90bb0b2146c878e04fbd6a073a428cdf19486ea96e2e38a7d28ac81cc415aae423055e004169a074ab65e6b11247294059d22a07d611ad20f97ac3dab164f74d6668378a82dd14ac0c247779df2064a2cc4182e42c3adb904400ebde9589c6a6452cf248b0f5b52b4853a0e8566001bf0cf8a0ebe082baf9269e2644d71976a114aacecb70a688264850c1cadd6a62c7c566da02bc424965a70cf2d1a71fa644dcd2b124072d6c839fbbc9117adff8191c67774ae37d26fec99aefeb09dffd2a04f6303ff4a1a808bf1a9d09bf4491ce324b7bd0d8af11e9f54fab89d123a0b14eb40cdb83e722da8e7129344ac206a52e81de83eb1872e780de35b5af4af1fc9fc81728d1b395a2ec7adf0e42be6909689523c2e55f649aa13992d11cdad86dc5642be28c1bd13075104cf6ad5bee13c8662ddaee20c73f323e026071f1fd761a0b522b449049c1b52ba0cc3a66180f9024a8bea063068e8e0444386feeaceb7ce0722f893295984a288dcd6df0cf1c069f4c78561e9f2a079880059c5351fbc7b901478482fada8f0cce58f1e12854dd094de7919c36ea672a082677e39a7faf93dce0932fa895c864577087e617d208ee24b5d0725975731172b6a637875c20c97cc3f5fcbac70a8c8830bf28f5cb5d8282777180bdabf5a0368700864b0af1effaa515f9388b2f0d8922af79ea7a291c0d4de8c69f02fb300e33eec5b4a9bebd5ba431c70ead1a264cd7146b6ffab2aa2b07cd024ed40ffae572f737889da5410652a6ddc247d191d3cb4484bdd69721b6ad94d91402d66ad6406272907d8f045af12dbde020e08cedd7fc4d96c45d4c57fcb998c056f95b32dcb3cf46642f44596063fbb0f83b34a6000110e950d40f7f60ee9ec55a618af4bfd03b55045b29668a0f9ed1a164e4717438ab9eb6f80541e046310e1b7e7f6d507f8914babfea6088c7e7829e0ac2853c2f21581242f6a5ee30f457f1e01910ca0d24f64594ba7e8f6d11244e944f56a1bf670a09b5bfdb1d803b5f423921f392649548caa55daabfcf5b9f03206a2b4f698b38de2b4f80fa80d9da205adbf14e81a627b6004acc7c4e99f34507e877b7389ffcc5a8bac7a57a64c8a5505db2a0342b1ad3d039f903a40051c94a5060a64cd21224fab3783930e52b230f0876c39fd9a5865dab15082ed34575ad98109c5af0933ccfa5811f6c47532fc5a1f8a45acfbaab80e0601e9135cff46c39a61b7b28c3fbbd8d4c8c9ea9a8acfe5a115db9b860609274b558ab18c0c9d3b32ae9c82757846ca2dd5c972ccb2df2eb4e5a5773dcd8b270f37325982488612b1542b0be11343e9402d228bdcadcbefaf4ffb246039ad58931952ab8a82ed3702cbae2f1bb44f01889f28ed2886192134191ba37c7a4f8d4923cfba318f0af49d0534a439592048e3ab7723829d53c9413473f0740dfd860aee70229258ec346dcc7dcb715ab6242d1f4438e114d60fad697796169bea5a31140bd790444d5515fb764160f231269a2f3dfedefca6751dcb515b3498c4f89366f660f9d344e916d5d1213c5164d18444d30e82535332400682ac0d3cc99f0d4f11fca1c6f0b24358543251b36c44c1cec4f174fac2478d6ff90ad6f34bea2876984cb79f687077637e3ca9809b658f7f4785b3df665187378062481343b32a502adde37fc493b158d0977cdd627855a5b114327146c1a0bee29c37608b0f35d4d777ba6d759323def3b9a6a2905f365c3e0877232dadecd0f0993aa88fb3ac7380e4bc815791831343192d0a5aa90714493eb11e623b7cb681e4852d7e50c9d69e0319f86c091bc4d53260dc26c4bfd31798b9546cb7ee16c7cea4def9fbcea1118d5357d80cd1248db220b14680491fc082943252b9b09b5da3cb9582de2962f2aa340a869cddbc2b6fd337cbfe4b44e85c5095dca08b21df16609901848d5a159f10e88999bd5bfbfd1ce914a40364f4413e04dc6ba82dab54e55fb9268ffa4c5d4767ddeaf7e7734463508006b9552a48d8605d5467d465261ec83bff83b38a735e3700c3ed37845c5692a25a87d44c1979fabcf3614b1d69129adf552c2b5d9a4970fab3d89f24e3658fdf82c7b65f8aa86f883c2fb5976aa8f11a888c30c570f3dd4953c873c01817eb1c7810f9af9fd59c4e74835310109fefef48cf4d4148d95220c083dfa17f738455ce694551b4b865c289935948dba0f714b560573ff17f9335198432664ba3697470fe330318196350ec09971c316c03b000acb2b5b1e354f5adc22b1a80a9976e3c296961d5b3bf436b94ed23a207ba1d25b91042de24b8ca326a20ea1556653f8b08625993ab1e3ff374efee561a5451ec08b730162fe7201a40b0a9b9a8fd96ff758dae6cf974725b30662788c4a23932fd8159992a33b0658cf4a3924391b2be43ed643fa1e270acf9fd6580ee30ecb32acb4ddd0628d13691db91132b08ac8fc02bb9e303be147548c20b4378dfd6aefbc54a1962b9daa5400f7343732ed3861981d9ef9aa07b12a7f520653f3bbcf56a15b081c9e6e31fa887ecd60a2e3a9dd7874c0abee5057340a33fced90e2825a8ea71353d853b28a217879e36889f572fb343d8bc01cd33d2209cee41db28ae70324f9bc774e3f4eb094a5a2156d84b13215a76e28dc92bcc2e03709175b56631f0ec658015cdb24ce967113ec2faf4d4dd747895e00fd8a7cec4b2c49f0f14208a10e3e1916ed712b842608aa64bb26c0c09580f5c1c3365bf0d5c12720cfd40c16888864fe12c38b4a4c7380dd28f7f7e06868a2e59f4d253824f00ac7a057a6a62a5683dc548fed2115184c087a5623254ed402b6e197dd06872f9c3a620d58fe9d1e93e7c2d3209c559b1c4b6f356f6917599abd965c45dc85c4a450d6ab20869e83699decc7fb91761347324bd2e2b437ddefa8dd1a0aaf899c0340408f8641d83fea18cc39881221c6b2401be9fa41db1568229716bab62538bd5ef2124074548b176a87057cb6a8e9eaba08ee35b63c2215a9a94e6fb8013ba645a44fd84d9c29581a1560b1963b2b13ffef144379b502b733f1f1f58f22b7a2c8b81c1ca6a3a3b1a13f09a63d7e587ab2443525b2c934365960a3068f8da77d7ff6e447e56963dd9ecfb9012d1deeafd37d199f1e2158a29bc523b5d1bbc41904d9c1bc2c160172761ef2f69a92b444c2e46734d4a94960344dec0ce7a8b670ff667ccac73c700398b12b64fe4c5be09213a2a6f199cdca39453a8ee82f7e0418d403ee94d5b4eb08c9a383013b5ff1f2007186e95e6fd9a6a75f76133736fef00a25140dd78b2dc304db02d7d76f6f90025e5708b88b98b7bacb6d6f62e7608cef55d8fe6c5364ce93614221e054894a692e830685aed6cd8a066a608980ed7c1975f15639f30d1b2570fb40e156ffd8a3c7dbcee6c2c45162629547c781e1e7e7a6e58294ced58eebc8a1ae1ed7d37ad85b3653f9fd9db92bdbc116873790d0239db2b1534c9593cebbf839c021bc3c605a0d8ac31a9423a3cc62915467aa3aa5b09a6910a00807c960ac3ff0325e6273ee985c45f276941a6ba234bb59e6cd62ef2a583d1df4b5fa71b28c4f5d684cca7a31472f77dcfbc909489cbb384e98ed090b74a7c6c3b5f14a9537b6a4a6fbbc66bf2db853ac5498f6f951618fd9f08f41c77bbccedbaa8c3cb31e458d0a3c83fe8c404dbb81e90c367833349506881831b617fdc3e93fe3a8401bd864f3207e5d8987093faba192cd960479a195da33f4241b916e9359a7b7fae6cad3ca70629ae795edb8835a76fee0f4b7d9fab55bc3d0d70eb7c3dc2393a411d3135aed01cbc55787f1551d022ecaccd9d4520dddd73bc67159c87470fbb6396815acd431f93c510a60e02743347d09fb8b8818e638ac1260acd36943398308a3ad820c1c007b059ada70d3bc7fce2d21ad37cb788e964d19b980b0d79ae9e97a8e30fb021ddfcd35cc3ac6170fe5fe0f3bdcb2ca608220552ce6f1df867d9f0059bdf0beb82af6c17cad90033d34efece9a2eb3a012da9f4c14e22fc548cd9115fea5fb27a41c91b62c6b550ec0e2a15513b4e1f3662a6f14b3e23f79cad2225ec82bd60ac0613d58c13d09530ca0346a9341a2b79fb461e841fbeb90b6bfdefeabb2de5c2afb4b8830b32c54e50f415a57022ab20bba40e9adfe10134de4e6ed4cf59846c7878be99e1796fa1e0c699812fe9226f004c81edd8a4b28b4c59ed52d1ea1c72fbe30c052fb05e89d10395f264e866c6c1227392109fd78b058681e9d1399036f6d2c6e7ddf87ea79b2a11cf103bda686d088469dc73b00fe4faaf8a7fd73e25364ed3ca20229fedeeffe743dd479df26d29cd9cd996d4a6972cdc15a82e7688c751eaabdfda5dc48e9126a6e55e7556fe0d14ff52dfcdb2826bacc35c06394fa833a28d3fb72e831f369ab8d7c0f33648261c7d50974703675531921e65501df8b2a2bff180dd2bbb76ea600a85e0a4700bdf0993cc6bb76e3e9d27cea5e034b22256302989eb8619187ea55c0ce4ee85957c02fd9ad2840f7c2a4c9ae11725bd29c80d5f0a706a1136281506ec5e321c9e01090f83780f09a32e80bbd686a2375a73a0549c7a049d0881870b94669ba1def2dd89cf5e707c7d53d4ddfd2f0de771dc7ac5156cd09fe2f018c15ed193df9480dc1b89680a8cfb4f4371b8711517b4356ddcff90353e5f68b3963b9d8c85c670d638c26bbd13ac38d017c2e80b43be9921e24026b2b2e6ea67fe3b6efad57b7c246d4faa20c76b3a79e623ba846204fcdb1148a4e684f155c78f85965656b66597905eac5b68ccb1c16b5497f30080d6bf5f24a4a684aa7c0907334a245965cc1231001db99015461f65c558f218ee3c4d846588c03d0de434d1da231fe6f5473f9af0581034369428a240f6e2aedb09c9e6216f05f1b3286b3d6a4b9511164583c4df77fa9def18ab7d5a7289d03fa6f45b0f8dab2104a4da7e81951c9eb11d12a5af98c18c41ba7b512f6c27ce88ccb741f7f0b123d8a5924f3e26c9b964cf7f0af8c288a4d32f6e70af8a54e43a3230578d24396889459e838a11289171401f2c2140395e3c567194a056d5750c046debd66db0be3c52185ae7c16928d407439070f3f4809cef710d81ab3c033daddb2170efeb60b1bedb25e4d2691f34f5ec5e3f9298c737ef6179f6d94b02425c950532e7bd102d2078dfaff9939d39695e4827da3c381542b15f96038954c76bb77a66cabbafd7c7dd8276830e65aaf903ad6652d95af14ef1948d06fd35f3644ed11327de46a1023cc1d261495469ec4a01f384316e11a702716f15f6267a8b4e9d9a2a373b624c8dd72e38e376e581811c2cd50768810a3e587e65431924193aeda8168c251355365bbf29c2e0576168cca05624b737cd142c06142bd33903c966cf2ba88daca434c957abeb2016f2fdc490db9b5cbc32eb0d6b3847ea88b4e6297b2fd9b1f3b57eac54e7f407f2a7a2a7eb37b728dad3609db45f756429881836ca3bf07e83038771d88beab0d4ef664194d949834ff32e7e414b23ea31064401826d201b7b26ad0aac0a908f0311008e445d6c37e2160834575d4f83027e9c660f586acf0ff78b7fac98526f89d274b870fcf9ff3a9bcc1e950753e9cd2aea4072dfcea7af69ce3f07583800a0065e7ebcf4f15928b189332ec0cd76b65f2efb1fe4fed089d570ec5806475882996d1c9b352d9b3c233adae71dabfaf6f63983153918a8e9c83b064d6dd01fb5c04b61d5326ca57cbf04e6e76facd5543286c3d9c052d503e501b21072c882bfa227357f5281fdb8f6fc03f4c4fecfdc367ba8c3e3a82f59d408825661e7cbd8a46db690a722e2e9df1200a545952c9e9ef7508387d53810da8d31849fd4490908ab1d7457a5f2d26edf34f38c7974cb953ba622c687803dd8e0f41382bab43fb521bd1a3443b4316f29a439a1ea3d76d1dd2e1b091f51597ad008c3964f1d4c61873b6fcebb05b76178cd03c758ab2a7aff5fe60bf13e0a51591e6250eb8e9752a6fb10afb8b0c63d6bb5cc1e6e8a54509dcf15efa1080a27ccdefa959e67282bad5b8373eb7ab72932045dc433a370be0cba5e5c92a2bab330408ccc93d1188260f23154f7a649acacf4f03976de4d88f0ec2576dccd67db41ea73eb141b732b04b37a050c580da41fe0492b33b8ab540b54ba4e87092368ff435431461a50f412c5fd188f439314ebccdf74959b20c9be8eecbb57de0f10682e483c14bcb92282c8a9275707b1ed1611407997ac322f90556d41aa7ea3d0835db04ada4a88e021f2442c54b78adc1a492fda50575086b31a510ba2de0864d8211f3bce98fa76efdb31101108f461a1b019b527c82027389a817571f44e9a8337d3149be44827a6195d0a7297733f17db8903c7b72039def9947ab77eb49031bb7c3eb26afc876778c3abfafd1d712af105efdcde6acfc3ea0dfa70ce17a8eff915918bc63ddb627ae7b5d06c67d57719c81079f5baf532927e9a09a8ec2318a3748116767f525bb50ab2b75d28e7c93da4cf490cfefebd0e1146caf0effe94f6fe93056181964b7792d84fb9e32fd94af8cf61186112d283efe9dd9a2297b73329db5509aeff1a355f6682a23e916540e18e071c677236257d4b04ac1af9224b8859c35187e66833a9ee113ba8de89da6d38f023a7627666616e359a4d4e05a6a1aaa190ef62e3c3fe0f6a881ef824b6e98a59244acd25e2efa10601771b745ef4775a1d92fb90e36ed3a4ea416790e9457b1af6964715bc7c67bf7c474dc593bcfbc5f02c4c848386cad94fe098d74e99e374d15456bf3f47bf1b463a8f145a7e2acd81627e13242a3365c53fb8d6bd23265c10597a6518d23db932e5a22b3a2a1834849df8d8114f7756ba3e5ae4e24f269037a92abfe813ac515dca43abc613fce8017b9cfd089bcebde5bd2093a3d547e111d0a5f3ee0523c1bcbaddb4a30ce64e77964a89a77964e1cd53c1df4f66788003061b6772f879454f1d50f477a9304610beb00f9ed3aff362d2b97604184279d5ef94c775ff6d53e996da521273fb758b5aef8d2141817383a8c7921d6e6702c61120a0a450fe9fb87883011e87e4c86b3b964125858b384d17c7d883149bc5c1af5d44580b9f250e6baf1c0a0c68ec0fd19410a89405dfa3cfa0207fd3eebef40f6221b88f02e17a36893ac1f5ad71b324d251d7bfb65232ca1933bf485450a415e29c71c287d2b5f19d2d7ddcb145d624d9bfe06abffa767e1a260beb19b07fad03c46630382e045269f75439e55b3b32691e1b70cd9b97c4916aad156481354d5f1ec7d527d29286d223330063d31b1d0adb76a4583fc01a78cec61b86e35f5fde398fb983c00ecc3d1dbd8f835f277bf69feccc6bb7367fca13e2d119099b8a7fef1dfb2f667954ac57d30618a65f241e7658aaae8a985811f1409bd16d1ec89daafb542dc0d64f276fc5deb2ccbc4f366657310580e7d28d273c8f22c8badca2ae976de2ca154b545c8e750edab4a96fc93f1af66cc029abd66e764f1338e167a85382cd70731201b33d963ae300a7962ebc0f83a3a01cc5c3a94836feecdf77fc99362c84bc590b251ed23f65bfcbb0880d8945a915fd4dc7d5cc0019f7b318d69dbbe95dda5590f03ff00a860f70e97e36dbbf5f5d5ac3c25f1b1f9141fc65f6dfd7b60244c548d467a24d80064d69d0a3406d0cf21744469428a7ba54eee1dcb5a39eb12c828d14769b53c899aceb770438bae5a12e31c84df6891f0b270791fcf65f06ed2851e2284dbcad170e477ce65c0fba0f3c251cc157ed66b4bf39e30211cbcb6ffabbfcbaa095a8d67ca7797ec355e69fac51aa5bd67b8cca8c620b41fdf072354a027113c4131b8d4f9c01466e92dc859e35278870d824d21aada8a18bfc4c7042d75690a21a3b69098948677da8ff3e59ccbfba120cbdd50bd3450da031e53d9eb573637cc37dba1aaad71e37483f12cfec1ccfc286b766303cfabab6984cd807386fed90782a2209c4c0282389a1b1a184e4a3a5f2630ccf61f5ae4140b62769312bd694ee2d61ec0f1b14adf712eacb2e559a1bac630f540a5c4aac76e535c5e67a02c0f80fc05a5b9a087d39ccb7473bea68346e868e9a378bc896eadddb2c40c3489aaaf2b116781f0029495f9b6cca0dd9bd33d24c837e7b3101783318f3d84fe3cde4b55f1708255e3146397702443ec03ceb9f20e61cc500fcd74127c3d434717e825d7f4dcd6d585cdc61cd38d73639e06d02d4001ff79b22babc1aeaecb699e5ae166d2b953ea5d30f8e72a9944f9858a8e370e493c9e66add2d6d96ca77f7e568c39b13751d1e41a514d9bbcb24502ba0c16b1cd104fec659470c8c06148e3ccbb5607d1fec948858ef1c1402ae69142d2a2c6f03bb431e79a8989e8db7ee40f551ba461b0385b800ac9acd87ceb53f3670ee19fce97409c05c0f1cf2d0d8529d348b0a0d1108f53ddfa4e642ed31ee153358d4cdd2f7209a882d3736d65a8616bdd5e386e410cb18bebdbc257883db8a8d2fcedb99e6153e02edeb2c3af066cf295cf2afc377e86b9c378cc970e5dd5cb13b99389f2f3523f2faa9920dd797eeb84c1cf54466f3f9be3bde94d783dd08e0d6de7200942df60dbcf600fdf562eaa2b899f10be73b4aea9ded5e49eb8ea9e057ec0a6f22f10fc7d0683e260ea604cd686906cb14aece6453ba45312dec76b554cf9422bc7f03a15739bd9dae2588173fbe647a8b1b6b9f7f1c1d5cecc8fe3cb94f90d7a649c88e784c4b69d13532532e610521553bc6a90798e33083074ed1575046d6ed9e8ee4ce620706ce845cdd1f9f44decd1d72bbaad5e5501f1010388396c3f9836ef5fab985b93f31b196090897e6093e3ace6c32181f07e75a905abfacdc7ddc9ff909cf4278cea46493024a65a35bd49cd5b129db4b8722484d1fa3afd466ed7e58969c0060465ffaebab7754c95c1b16c699f7f13a42b3e73e59c5b27c0627ff067e1cfc409650df5adcb98183a499a2f9a9969cd781f593daf93aba2f4a093620e33c3554fad54a091ba167afbb31b3aaa22ce6fc53aae6a5bcef2609d4ccc4387507fc4fce8284f9dbf24ac0b8627c8de7c55226a2eb365020c2704204b523c450080c5177ed89be8a55174b86dff53dcd63f0a1b7419b9081236d16196cb5a90da62b2ea1cb6ec5787f6acaadc95269e9e2ebf51907946c4b1d068dedec2588d32244c498a3b500c4e34c06173d4c24ef1456ef5eb7f760af23a068b01766163a043c45dee662edc1f0f7025d2ff3751d0319cfb959ea264c44d4f9bdce3e7d1403751e753c55741d20fc71dbafb70cfa0b638a783aea069a79d8a7361d50ea4851df1a6ac9c15016414449c589094459d51a0f4861a57017238ea0956f9c6447a89c6ffac6ec15fb881ad033e1c50bc89fbd62dc679d2d38d71d5910edbabc07741a30546305dd128ef6e24ece9c62de55ea83c127a43653af6a8bbac9afde5d96b0c77f90b1fe3055c8a83675c8ceb808a6071cfd5331d19d8d2120ef455c5d2465256360d01be309780400a00fb155c6a56d41cefad19369362239fe80df88178e32876187bb75d0835eec3d26265070fe780e752b89063f45893bad7da23730501f0fe3f23abe63f1626cdac1519b490b212bf39db956ee1b255db325e24e9c3871986608fe38b49753966a85cca616fe7534b418500c674d9265797c79c7697b41d633a0d2ec3d532a9a3b5b57dd62f51cd69810aebaa92412e07f2f7150143f8fa84861ea550da9c2372610100b7e339152052bfcfa76a12fa80b1c5a786f821b23ccf47d30d542510e5a8ba61caa180ecfb8fd4cd5701fa93acb2ed61555b73d27e3781cf7bc7f7956046a4d87de39f823b624d8ea0c7b157bf2c0f387fbed0143f57798b444950ca97183651abfa278849834c378b6195758af4935f766df6c97299b8eba42868976893a4b3b6f69f5d39604dc5de79056a00715654849983e8b3137a733a2fd21c2785e0832212fddeedf34a368b476f09a7bbb86b8ee020ee52321bc24ed585432a97ed09301b2a3869d033dc5998e9fd032c9135435da927270f92bf0664f3577066465a19685846b726495cf9e43d4b0a89e7a10f30a76993886ce769ec32fc9215ef4b26b3c3835ec7c72dae81b3444f16e5e80e11088fa41aa8291db4721c659345a14a68571a95412c4287f135716570ddd7052ec94c629e9232995fde67ceb16ee504920839d3cde9d63bf2709eaa0593cb0e19878849a9b11e26d816ab95cfe6d9ec82eb11c631fd5659f4b8f5a2ca46c477b4c03a15c65cf1cca58b1358ddc81d593fddaa332de608a48da86cba3bb7436c1f671c596b5ecad10a8d0c257d64adc14b91fbc928dffc57ad298dee30609015756af31a2815a660fde28149a440af0121c62c647447477ef79b890441082a78f54ac8d2ddb2f22b46c49bb8fe381059d7b9c177d7825f01dc8fa6f0f2e15525fdf1b0e2bbd68c743f28f46f7e66d0968196d4b2ea292bb3983f7a0e523484d4c504b7ce67f52cee05c4dd4ce8cd42abd86419860aecfaa1371410b2c0e36d43f062e9ce19c5d6745f18c0492f4bc6cf137baa29913a52e73d92bd5e3e653cacfac70daa164c8c9ef2be4b508b24a5a94cf0fae29ab5021f62d4070b24f3b26fe3596bcaa79d6900657d8836a8c41e75d951368f06cb9ab6e4ced4c821952bc94ced527d8aab75fb6767bedf3d7102983cb3a2fad5da9fa6c43151b5d6309f6eeb0014f7387b1eb40c3aaf3bfd8839ce76a98010137e39572a31b39f81bd77441c0f019404a05aa412d27d879216c5681fff2eb1c68a7e23fb4840c35a243614492dc08035cd94c25e0fbbdfbd0f8e0c138e906858449a68e119462ec6b240536574c6b0c6679a7e195f4f0dfbbcda933d0cef2c0634c2e20b7b92871afc6864277ee2dcf1632e18a860ebc3d884a24fecd6da5346789f0eb8f7ef30a10ba8ad83484f0c98eaed91be2a483c31be312df03a0580d9da0d26a21f8bcad68c40db3902c42a7aa47a2cc9617b765c00783a1f98beed0fcdb8ec91d1fb7da3d5004280a68047fabf028d929164b84ccdc3a725cbfb7f316f9d0aa0cb73bf9a5ade433f8e0586ea7b7d3f2d50a91005618c589f6e5282ba3ce3ef4390b20b852a742341e3e7c8c29aee7bc7f804c76e3ad4014729e8ad8df316d9950eddd7dcb1664b467ee2b61f5bf6b27edf55c06ab6e0b875ce3d99a98f3b59726d81cd2f658013b2593ffb60edab37fdcf31750f83cdc7a43ee1c868592ee9633ed41f95d1c68173fd330c2ceb3acdc1a476d4da778e1f4ea0c2e47c633e23d2ec1d3716ac3f30a82ff40b528b4f1c9eb385b4e81bebadd200eab5c357411fde72b605f97e55114d9c197c6c748ff2697078298c5563c8bb884b226dc4a26a837172cc75a276906f7fd52cf2e0034ffc1372a0696a8b1a55e14cb6c5c3b26808701c0ad4f2d82bb3696dd92e616bbd479e56eeaaba6e060556e70e93f3cd0fecd1bf76da6cbc7d2c6e8990a0a9910fe04f6826d3fdffbd52e7b25952928ae0a50496712276707defad71beda792edf243f418bd5490a28eba63eaf909c7c705fad5b234ce6c7997e2c246e1c28eeb235c76499f570d899f5a10659610b3fcca686f15be37fc6d6e6a29f15d67b82e0d99453bfc28fb6a3b0d69051660d3d979386bdebdefb172311fcaf5653d8ad4b014c6408cee5cef7d294ec45574b5d1c894456660264c5fad00f1b30508960f91c3430125c238dc4fa358f20e7de317c96215692fb3ab4ddfeabb451537d360de13e46200d434cf48107dec6b080f3fbca10490a1dad3e7f0aaf01be17023678ced18bb2208d43cc6ded22f781ac0e7b6f4e6963c357ab1b4c6d1f18246fbb7d4ff5533d537973b2992d790161268ab574d6cd0c7f214e404273742b9035cb5942ab14e359b690884d16f3cc4003de8647ba878b077107cabb12d97acad90772f2e4780414f0592e97c09dbafd71fe71d1f6482e934b89bc610e027a36dd3082dfa65ba18dafc5dd36a9a5934eb1465759e81d83402b10b7392fdb2ac789ef44ff9e3a2b96ed8133b5fc41f51b58fa2f8623b0f7e36c02da1b3f0d0e40d72de82af3db8877d4a6b8523f3d5b9231861befaf0bb8b5ab6dc3a1e80e9c55af3e39c799d740ada9d3290906e9f36b02eb0ff4ee3689da2dc88c788c7efc5739725c795728cc8424dbd66992e39069020f8705742aad591593106ddaee849e69612525b7d9a9d613874b9eeea2265203270286565126399d6b85e22bb251b381cfd92a33bb44051e69be9b40645c60851a7dcbdc35dd6a17fdf5ba202eedb1c1d8e30a814f73a48d40f59b71a2a950e000366c3e63c843d6c1504a0f90fc9005ca9b7361ba0b71d063d99187aa3fb052dc5c1c40e3327da6b5f6d62d080a3636dee67f4bbe0e7e1818706fd140e6549f94187569cece75aa94b4aee02027b5184c0f55bf97e783f431988bea9e5b41203a35b75cb0ac23718b9ed8bece87e8b34a8d0082ab8d5350feee9a9cdc727fee0ac9409d8f0f5bfb05346b19e7289bfb6ebf1fdea5e3eca36a659b5dbce255964888b47adf3af4d6a4dc1239bf648dd4aa84eebe468c507b9654814949746603fd20e0953d3c0065b2ec2dca595f831a5c00a78fd35048d1cb9ca26b2257f68fba16842b5dffaca4b232c346c571c074984625d0bf1e78f2e29d0246739448a62b3b2f24575dfeb69d04194afd2cc2cfdae0a6e5367f61266b420129b871f34cc56209083afaf19af80408092162ec1e0efc8430e639279b72c1944c8f06aee00e0fdc406b1bd946cbdc191d92a4c6cf93e4322701e3816001256af9417d5a40f958c1b3e23f460091120bf3bb99a6adcd6646698f67a8e3c01c951704f98bdef39de127ab4906d953859a13d012d60e0ae258cdc96cfff5701c6a1dcdcc92b2389f7c5e7b23f65027fdfef68ed378bda38ccab67f951740ea6ff488fbc2c40b051ca5c8a3f44202c21599cc1a160d33f28f421b1bb5e4688fe660e98e4af94c41e0070c73d4be9cc48c7908b5cb88ea2d3da3e0ee706e23a26fad5b1536274d075ad77787cf02d0ba182215f9aaa1f92513175b334d75ecd3c32729c1b1b7104ff1cb62c0d58b20554be4f9b0935ea192be375b3b4665a28f891e201727dee76082f0efc5d8be2b4477419ea060eeb0b27528c373a314b6e3c19577a618aa54ddc9aa061935739f104759c538f422972454927317635ee694275fa96b0851973babb0c739b7d5f689a401b9f0255fa32ca1fe5e47b56aae289bb0bc3f6dff5c92922dcf14fedeca9e0b0c027160a0201ca4239c2bd7ca077b5ef118b09cf56bbb7a4fc833f561d398b8bb1db67c7c9f8bda7d1c74ac2cb198027518cd0b8ef1249fafcd3dcc125b9842b2dec9db0d5b1b1ed87ddce55c83d75bcd9f35322c15bec7d0b8579258b0e215d19be0938f8b77c2d3c4ea0c0219b6b52a0aeaa604981d2c06e206aaf64c72ab7373b9863a6a37c1264aa443a2f030397ab09a0589f7ac41a4e7d7861ace8bdcdf547b1b3fff262831e82ecd640ffbeb4d1894c380a2b9f4af1e6f4e95cc2771a394f5270b81218fccbead6b0c052d743e042c48d548cbc0ce0677cb634c3408dd2ccb0d1925f3d8bea4f526c9c59acb58ee7c869c3f751b26477ec2b73aae0343abd95499cac41331802fa99f19bc17b16d8757881c87edbb1b56e4bdb21654a854ce35b3b1d03eefb435af91f9ec716213994f9c6515c7117c4c81873c0e4a40398119a481880b0f544b1aeb7a656c6f7f74a729c55debb690bf575a2212ec2c8d773a4082e55b1eeca3baf784d0f5a650ba333af5eb5db77775f31c508ab24190f66be29bdff6bf7ea9973249d1d0a8684a0cfabafae18a92fad881d3b8a6f331e85a53450b2bc76331ec05d6a36af8a2cbbadf673627b7631e482325a034fe43bfa05d7ea18c97f432ca848d8e9e71a189e51bd659232aa7dc49a123fad94dd12f374eeabb875a7c1033f5e4ee7374791cf8a8c6cebdfc0571d84fbe77126a0961a1a136d76fa27f6a7f665ad22f109ae62f69d9aa3526d8a2eba49c8c062e4a6d8e9c6f845e50a5ade1d386001fc5d8810423e4fe439d64b195552b8d56dd1bbc24ea3d3c8df821b9a965cf1eb5f697394576d0e0527c6e0d9f92164a4e307b166837e0c68b2fe19879013b00141543c71c73a20bb81b5553c61a07f1614b1ec525c349aab788a5a08bdcc9604a5266dc4d7b244a7c1137f22776ac800f18efaddacf147311cdef6f670ace6a728e559d8f17998ad341a0c528e89168756141fd85c21ddb3c32fd07f442c223c79eb173b84c76d23d369fca68df28dc492f0e3a067ec7ba74c58c3c07ce2e35b6227e7ac964d59e5f6aee72a52ebc7f220b616ea821f5191249f33beb67b748b13c8580351f3edc3ea3e38a8a5642094d138b708113519439c93b8cb312c01fd2f7fff8aa227076648dd828391b8b7925733c05b9c4ac249a950dc8ff677e8b6a9a56947c400a19dd726426e82c62a9ecaf5b0656767e51469b826a5eb2d87c5e9fc29a4e2296f763ac6d36da8fc67adab214495100552a4b00b7953c21de7837c4c8707814f642f81e01352a90564c934e4e54d9afccbfe5bc8bf3439c201379fb4a1efd6f1620b4fbd918f0bf084abeb299bc6349664e2109db98405461d931eb542ff9a382700b0cf8cd85bbc890765edb83ef3fabecce6ecfb002946b5ffeafe0f1cb2297eae8fbaef3e3c917573aef4f3cf931b8c1edc830ee30fa342ecac1bc2eed87f40e9600f93c52b12d5ca3afddec9849c7a696d2b153a096ea7fe396e1c5f9bddfcca220175de71f3858185f003161da505f0f4f5f9e87384160d3c1ca065e9e27218846dfeb28b0d1a430b500f3f1a2c63f30a1218527fcaaccd3fd664e0767287778c67cadd1e84a4237976c97db088e0784de15c6a4108e094b110ddb7b599b6265267217e792b9763d34aca745d38acddc86aedecc2751564c670b608ee1a6b86bf3d25ef5f1f5b16486806383839232103e69e30f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
