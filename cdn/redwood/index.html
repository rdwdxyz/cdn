<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ba0838f84c5e8844e83bd42fb2c5f92e46187821f66510c9863ef2b4099aabfd20ebffcb4c0af8a7c4ae08b5aa041aa610b4efef456efcf7b3c05f7dba6927be7c3e0489d4ce9a0f78016018adad002fffb025dcd9fdd6519e8a1a2604f2b7a785233cbf6070950db69f64d826be36c6aa8e983d92cdf0f6ab100bd86c89a328c40e29318b36ca6a5c59fe7d1e660ef440a403ed2de0c2aa05b44aea8103767b73d9805757967743319e0202006724046c7c63132036d9dd39a1ca8eebd09297b3cfa815a7b82d0edaac67bbacb4c7dfe507cb6049c0bd14f0617677b21ab590d516189b2be53dbf6ac66f04f3b6cf290ef068257ee2a3c5d7a869f01d23fb78817250100f3e61104b46b4fef9aa2794e0584738984d138cfa4a9200a6ec1890dbf9c02397dc6de9eb52989cd7670f00e83e5a33ab624ee28aca356ce67ac7822e6b964aa8f49241f3f2c2ddba8ce33a1ce4c42bcd007ca8ce618f97e32c2ca4b1e7d31aba9102e267e23f3bfd918058f45db739a04d59ec3e50288c8838dc91c64a0f14e8732c8317992ede76fd3adcc9bcc1464e36b33efe930ca279d0c1ccf1d43568238bbb06bf758f856bfeabaf015de34d9dea120a871bf1424ba46d7cba5c4f19329f2a5fecf9e0c6c804084b307ec261945d23620aecdac539090c29514d7e20d5654ddec15cebeb984d1d5c6e5095361d6a010ace1e647cf0dfc70e04a368f6ad6131976318a1653f6e1bcbe04e123c2fed881db47a459c06c76d49a1ab282716a4ca67f83aa4774f31398c25105bdda8fcbbc78db0744b61242b314e4e07e273ebb78a05c7695c69440c4d402f9321900184aeec36ec942f54ef6e34144078b6323766ff48129aabb926921001172f3bec49f3ea151e088dc7fa2b7853144c64110b33d2a2de4707c7dfe1c6b31177d40ec92f628104b7387460d204b07fadff29b64b5a62e3e829edfccaf1fa1a99c6cb9b5a69130cd17f1f171058844658103b4809fe33df20b84dc78b08e332fa45117cdb4be5b4ee5d2f9686d2f4b871d414cd186b4c50d744e78e6423005119911046aac8f65d3541aca67ce7e34beb51501490d6df6d69ecbc1c6e4940a63f633977544d73b55f304e0df262dccd1cb291ca47b895851e6bccb99000d04046b378795807d5a56e1d809d50d414791f0abe5c0188d236267cf3727925f379db079ac9a99671a93ff8394fd0bf0287a5949cb9bc6699dd2543a09783c3da352fa597dcd2af2d75d68c5e8600a98dbdc4cb02ae4b0a3fdb4d7bbc1dbac427b7a8b0fffd28269f3b76dc07b434434264667f248dcdf3182478d248aa4238a3d61314cb38de3dde45fc8274169f491e16a74820dd82b8002d1a7f7dcc6656ab64dcdb816b1647c15652d3b577e0b3a59c5dce11350e47ef376229b41aa5ddc217d89278b7edc8b92e2e75472181ab74edcca53d7c041a9f0ea620a6f9825c94308317dea035c7a0ac40cbdfb4d3adaeac7cf11e5795f7aa8593e90074cabf058ae24bf47d2f132b08f8b3392ff938ba7e0f824839ebf5b623a2e1ca1f6771f47eb55baf3eeae5fd2e96a27af6d21d7c3eb8820f8180696d3851ad5b51dfe1835b540dc1937a55628c7f7dd9cc84ee0690b1682d63be1ce28bc2896479ca194421a27005bb473d86780aca6d74d508bb9b27652437c9a74183affe30ba3823e65f31434ea793fea826059fe1a2577cd946b915bbdd5b973cf7d20ed63d18453692ede4a19de9d4fc75a5ab7ef9c080d62f65331aae755551649207347004e6a04a5aa625dd523c554a376f3303e0f749387559b36f6d6a32e13d6523273ae9730aeda403c78394d18e24fdc07d4be5e84359cb5f1cf40583c86ae77c85d4518a4617da96859ef03ab1dce8343a37bd7b7d07c8ba2e0c2fb3f4e7308d54ed837ec834bd604aa2da1d8e119721feb792ef256df25a0c7c175ad3beacfcfbff14719e4f406e204d0722993f7e59f5d32178b5db329c0be7f83125d519f01ce024e22c14a9a9b1e32957f272df830cecf8557db3072ad3ec5e75f2e01e04d4f453cd565085df218eabd73f42637057bd330f9b8e77a956c02077c8e7e3f6ecd35cf343c0357604d709ba3cc2e7fd8683a3620fe3731e8cc4e83f14e5df73b94b589c4c0a6b2e114ab055370a3427ced175afb3584d9c814e6d0fc838ab6e79d3178c4af3933926fdedcd8424db412110c03cb8e3f37ee08b7c9bd34ca25d7e9a8cc14cffb3a79b2699697be7e46fad36db78126f672977f3bd5b25810b8665851fdf0380e20bbaefcf077d7b622fbbf25f6dda3796afb92d99b526635a03ca1217a6c8d73c8c22cf2a2dbdb403f62218839fb5c187b746e46c8f2220c799dd172d5810d325a638a9aa417bafda16f8973be1c1b0d3e953399a5fde1dc20ccedaf82e059f85868183678073c2bc03ba7051fa8a2d0f36087bdece5cb13f2ae89350cf2f4d2a130311cf367f37c1fec00f4de229d2f0def983825e86d41c5b8013dab55b52536fe203f1a682e27b62a798417e9c7370c79d43fa06105a87634c766cdcf464b01ef38f99766953647e8767f29fd6f2f8cae475bf3157b00094a4485f65b207eac4a28b555cfb3bdf9a3dcca1a11fa3cac1e1230ab2df14da2fb8cb9f9055d10f0060344fb3e99f648754f32ee9e7459aef5ad650ae26eb573407dfb7392ee1c625a84b53d528c6210161127890796130fca8a3595d74d8fc2e1acb4cadf63949b90661855c4104a9accf4fd30aaa3d3a604b51621c436bad579d2c57c0daa022a2586806f4bb84302df4ed3028f6e7a8f9132f2ee6a8776c7601ce00b0f010840f977518cd86115b02efb21a9e87b5be275d568ac4deb7589cc97050ded951b9bb306c06481a386163c9ba086c56551601ec4cdd5b61289604d25dbd413c20b6ae8e0c6d6fe84f230cb0726cd8f34f4a6bc18bce112a91197e639db32ed39007c40a9085f149cee1e11ce551a5f8d367f877ec7003abdaa4c2ea298bba409d62d32f487be6cc89c09ad0330e5e2b3b806d072e938ce532e25a3a96e2f9b953b2b28eedf998c5fff828eb8d3f7e8e68abcabf40c8e4acda4cda25a33fef0024438f2fa2a9dad11436a21e74164f28933234e921746810395e975776abcdb3d17dcd0cb502dd0af05dd0f805e9da7bf86d4e7b2ec1cfbaa4f8b5ef14914b31b97d8798fae8467d1c6f82c1e0f41cfcc6c54c52c0fa7530a25a46ad6688cbfbf9b681902270f052c40f23c96a67ace931c7844280b0a3f9148655257f05f365f1b5df3c809343d131e29343c9fccdd1d78b5f4ae68db9a13209b7f96cf05145b35337be6d57bbc5d295a266d894e68d693453538a7a87334515e298eda4480b08c6f78d4804ecec00eb31f54064ccb43958ac2cfa30b162bec550ae698ee44aea54fcad75d98451b75cee7e334232a06cf75060e38d96afa18f22cad0671a97472e8affa9e2e437cda3aa5e8c35c2c5b8a3c91d88ed6267c0db94a06f3d9b9d1fce87f780a89c7a648104401b1b1ad1d6f2f87d9f825a586b3de37b281b4cb32eb60e446823f0202b81fc2392a5259a9520a9c113f89627ba5525ca21f65c6052e40cae7adc58a8ef88f3b36829747c1bc80103942d0485c197554054c243af6fd13d4187f13e84e4793a3ac6c2a0318eacaa8799b6d2ffe2378bf831f815d0a0463857d03f0657279351c14a97dfdf3621cbe465a4a18436a5a96af130461f93c2307a2681160ef081d4852aa14879344725a1723dff13a04bf9df7819d97c58107aaafa89beca0c8ed93efe108820b5d495504293d377e5e939cf3e4933ff45bf9b65cb5e8450acb775c9cc0c9a5f8ef94222ce67adedeea34a6f279ebcd778a2d6420eec598fd8db609a5e6e60584d66e3d4316660f021f2ded105a9df14e2844c325f760cba83a840c061d0683cb7b2f415c321f8eb919e37cc0273f1c4c4f7cad48c1bfebe1d45e8bf7363f32734f3af4d03f0e4a73948fc9711bad9f40be09395696e9b38938f1f6d5a04680eb35e7de54a19a6823cdd145a95967245dc0f8aefa079f9811562fbeb1aaaa7a8aed45bcfa571664ef1fb6502f5e9092b0370a1febb6275302d8c902765e21325006c870644d71ea3402a9d6c33206f35cf4cbdff097e5701f4f1a3e93f6dcaeba55a970c208521d2b0e693cb8359ad07878f372063aa94e02450f61d129b0eda415a0fe27564366f2ef522c157ffe59112edf8a14c48b8f32074e04e717d01c18ad78a71cf4f417476e6eb60c2ef79ed4eed62a92602877049201affdf338e273ee3ea0d9ffac1e9818c54b352763a6200b8205106da64c7c054fc3da2da33ce785b7b24c876639e614a85889b5ddb4081cbf44b3c4d1b79040d805e46b2e18c51ca3cdbbc7f5afa4e250026b8c308e04606f59e091e989ee84f914b92a681e45ca1c43aee4792dac10028f3ed276bc7c44ffd6b891ff86066b0721677df4a5d0f08b2fa2bdd91674d90bcea66fc2683ed0688a61981f87542db24cee8518c33574acfdff6a4fb37109e8e9f737e42600f782f508635ea337a016b970affac894f7b4350d82357aa381a6f25cdf31e389012e5f0f690ad454d35d9d9e2280295bf7a1a27a8c31aa8ec0b87252fdbd1ff71fec79489f05e8c0a91442559c405e24b981c6ed12ff4ed24971875b016a6505f3eedee8ea5b475b54dc007b72cac7dd2858c1df5d7e83fa8e4fbafa1ab6bd68b3c66089158956ead997ec0400088eaae26dc786b9dd9759b06d8824539a0a66a63e60982411374ce36fb1503e983aa71db5fc277151718f771c87d182db9b4e394a430fc6d6cbb3f3cd65c8b1556a935b2a635d7ec7807580107d270c46d90e5412055d75ff7a8d696462502639752e53721ff88bd14a051e7ba19e61e7972b1037c60ed7a2cec5edeef5149b35e456118aa038bd39debf2b604b0469708fe3087073ca8e5131a827bfef91437ce9c76ab741f1767169b0e3776e6e7d9692399e1540c821faeeabfcc0ae380b4c28d4fdd939dd4d8fd589dff0a302ddd824bc60351d4e0eb578cabc641a257e28403ac4e3adff0e5b03ec2b8913bd51b49e0f66356f1a7dff0af7ed1da051d931f2aa3cc9f7c29a9e4bc80884021ba402179c1dcedf6d79fd358cde4d78ef7b45597517c815ad6868e56f0e02a4a9a4f3d32b958f3363273685f52f131927119b698e9163177be3107b5cc4661fc77456f9fd712680c280bd3850a3740302c1b2e820f6219dd8429b39384f22575279a6fde9e953f6ba22af46cce3ce837136f6a54f5ddfa74c2c232795e47087e3403bc56cd7c7c8e5225ee00094c4d0fb6c638ce61b38216a1e8da3b3404fb1861dc3b304c519a0539eff7bc30273c721091cf94ac45fab3bedcd8aa71a46ac8156810ae151e95d9b831efe059867c1c71797e81bd1874bd62d8b4dc227dad691a6d97f856b4fdcc93bf0e873a8b4a1e90dcfb99f574c4191cc5370a062c122472d28a70b75d1e37212d8798c587e38b28af6f3f41d30d84392f92024224f8a3f4ac7c924c65d4d0af703915fe7d1e91f72f2bcdb5ef49dfa5540e6ef3316daf398423913fd8a872f68421ddebb855c387c1ebf7fe686721ee8d8259ec1e78a1c012685f5130e277014ce8b91d7f39c8fa83f3317b430615c8a423350a729d71bf4904a81625d94a7ff4fb98b89f3e2a20e12d4c9d367b4e7a07e60b3743560efe2aeaff958456b6d5cbbb4062b6a2edaf4b4f02e08f65dd03dbf840fb8dfa3260cc4913cff34a3c8a9497e86be104a9a13e2c6ef6f554d6275f9841198c828bfd25a3b9dbb5ac70eb4982ce3166039537e1f83d5ceacc3069942cb43a6a1b2f3a3bfc71b1d865931fc56feec5c85e4790908711ef55ced23b18f00759ba2288af3250f8df35e041eb3f0bc328bde339fa16702ea464a1b89df5ee1c9c981ac4eef4952ccac970f0d8e7d8d08fac568efbba56f34042cf036709362e3e1f974682666d9458f9c9f0b33a22cd1605572a875b46dd25e984eae7c12cfd1ea15f1c0469dadd31e9713ec87d245e86b2c62eb2e38ca0c504340e7df7c5fb800c3d2456c73ee5d3a0b4d7b53c608eea86eed73e17f8b4c3e9522bdd34063a765a1c13ffa1c454aec3daa887fe12f4470981ebbd87f28b7490598601de3be688d730d0bf0e4c34b2c9f12e03ea43b54d5fefbee5bf62c26359902d55d82b71b8e30cb0565e0ea2cf7f45596d576f6381ddc411156c964105839984d6e3d93f12651354b7b339607a4abad5825d7c84055658a9f532c2bf1d6120110a40510d10e7a1134233d86ca8bedc16d40714ca7267e5d216a12b19e4561f602c07e74b129a2ec52a75428559523153d6a38df68375cfe00d5432074b684141fc209a0a599860d52b17208719e9a669f5e2da9ed882e529415faabaaa4760157f57723d306c9ea3a8d4761c6805b8c06c00711b6b6e7df68fdd8c8ef0a75b7d2ad20228ec8ffe116e1e00acec31f240e3e02b5fb4fe188311de4cfc5d3e9c56bd04883d00be18bac7021dd901122b06d3c77b443c968757f1894b2b6b6be4e805961a12ab8ba1cd969df375ae664abcb430d305ea83a5cf169cb233ca0516ee054d17cb3531765182ca7d06ac0d6d18502472b5d7bdfcad00cf265913cff5ff3a9dd16316fdcfd7ddb9a27731feccea64046e548f254dde9433fe3da9c6af17f5acfb8caa712f06692c6a71eebe6588cdbe422680bbec22e5241891de95578aaada5abe1c6cee767186a0e35c03bbe4f9e3e4a2d8df0af2feb9545e412f21dba5fc20560c20223a8cc4a22cfd7594e1e35c685bcdf968de43d422a5c09dd47c4fd83986ba59ec41f26eace774492a07d71e66d54a80ea5654e597d1aa2b8535b555fcd04d71a839688e4dad993cd79e70c7d87d6fd69ce4608fa2dbffd2ba8f70065981a06720355c1f8b17c7a46d03cb2453686c2d0d51e1bb89e896071efa1b0ca5d61239763a801d4263185c0ecab4664d4aad145f5d32c76e0dac8e513d9c596109f2a9f785c45d6f0314a689586572195c8e4666554e7d3294ad8ca8a6887d71fb278a25bfc33671b804a3a28d4ad80797ea104a48f1e7d1c278b4bef166d3f4cf0edc8573b62f755dc6edc94ea3a44619bf5fc8027eb21f2b28eb88567115ce03247812fdbe31d5e82287c6da645c058e3d89a1547216b737f805d462779f696997e41a46712e5e17214511f757ee2cd30f374b6175a5701f5a245b200431d6fb43a11730b75d481ba615bcef2dd16b81d775f907e1ec68dd21db10f6563689d80cbefa2f158607ab53d6c1836a1316dfb955efada302d63dd65fa1e023bd2b264dbfd18d3b17d9a22e54831dfcc772ba283ea804c17da239f1155efeecdc481acce59a505404bc7b35661b4ed2908ed3b4ff2a2f55755d83092d11ef595cf75745f89bca26f411779cd52fca243a53079862de3ca438cf3907689600e939aa4e0760903ef85ccefce80ae662e8f5ab5055b81889c98564b1fc181818b727f7a338222759c20d2ba021b80f4a17560c2bee8c3b00082ed5c5c887516b31cfd6756ad7215d3560faee9e446bcc039370f8585c68261bb5d0ecc31d30b50459efd90760f47c8f1b13e98f3dc00a0bde45126b61fa72608d73dc4b995c8b8bda4a866506f1a26dc522ca9320b632aea9caa3b45e57686c7688e5a9ab44c77995c0d7e5d74c0078f88537aec8ecea46d6c7282737223291d13346da800f687f5b0e612c070d2770771a9ca3831ef649fdecca91b85fae7988dd6534575124d3cce356cd6701a6b8068fa2cda61c0c3fb24520f1ed534991fb56128d23b5767ed7336be85454c9833955f2ffab523594db065648207d4039a7fc7b86fa27186d160a35bd06e7a4949b7372894da6155cd91ebf0ee4c499b0046d8409ab9afa554ace8486bed3c45c326f60d91670bcf96c32fc52f6b6de271d990e262d548ed7488ab982cfd9a238ddd5615d40f84c6d44416e17c626f25d18b17abbce33c23f70ece9dc21fe61ff0d220e3589ac97ea101537299794a076725b88974d8b3f9a7202d715e582c88cd0aba475543e46407b68decbb0c30afc147dcfe042c22acf21c6b1a3a3ce807be305f03dbb8fded7c9a53382db0f9816738ad36420c992a33c1e4c0685764683b1daeeedbd158b4f3b23c7ba2f89b4986d92e69e36f9d771f097eb47a58f2fe1b00c8027e008538be6c21521dde9151a7895c71331279b53ce8319fd49879146a07618589ee24393d4efc3a0f75bb0279c3b1f83887037246f4a7f6081d56b048f0928c2de9e250b0eed2f65b0097b3c765779436cfff1360abd0f901ae99394a74e0cc88a56f820ab8e93409e4e04fea1714e48163d1054ae5aa0bcfebea7d08638249f79a799e62252b550490b0c960fc322552c284f6f8725da0f0ccec902785114a9fa4c6a84cf96b2d7df9702dee2066fba7b47d07b3a4c5e65af289e1f835120f2db30d8107f3c04326749efdc7357d88b70a669302d1b400a13ada5ca861048952de17ed6708cd292e63eea3d38490e04a21195ae4c0051ff02604b6af3b2a17a7d03ecc15825bbcde870b4ad0efb4bd675ac19b7f54d05c7d0a8c816c7275ab253421ee558c563a39fdb604d55a6b91247f89870b29cd9fc9fd1a8481e23f42ac666cd04af8a2304b818e622b86ef630ebe62ef66a6f1a6409d0883c1f78e472727d5934a73221f78d677c642572e7c8228c0fc77ae8a93c13e3b5230c48dd2fa4d54ca58c4dd2d3c113e5f958e0fad7359a801d024d13f8fe0880ea418fb955d30640ceca4aef91e4a6399264298de4fdc7544791d23bb1de99682be9e8f983d9e8c464cdb9019dbdad222f63513ea00331663ddbd3d51548e23202f188211e94a10186f7dda86e1400b6ea0591c1c132cedd13c9f027e1a281d5bc7c33909c19ee78d2ba56489bd7222203a0912b2d32aff2d7dbc3f301d664e21a0b1fdd5d67eddf769c9ed77446a8380f78fcd9d95b02295145ccf311c2e6c9c02cdaa35bb9ee9586eb086c4c9f15d3fe5badb135184a508811aacdd3ae15f245b554ce6dd23d458e017263c27e93753d4deaa7d08a04b31a0f3c674c791a0c27fbea4cadc1e7d0c7f906d0d9f4b888bbc91745b2968b8bb7a8548cde94e4476f22203ab4eb7f6ce740d37415084e5ccecba53fc4a23d87ecce8bacd562eb03fcd3bdeac2184f8e90247a441c33a4b9676fbb39dff9413ea14f7d7c5665ee4afe97b251ea2dd8ab386e1de815445c27f05fcf139090f01ac8ec12513c65a60abb0b6a304c1fa5cf8667d7875d2dade323fad028d533a1c8aa61b984a45050763b58ec9c0c977410312d6d2cf1f07a7e80d76e64e475159fee4565078af9a72046962c76b7e07309c919fc07988c5ba3f821f2d22c1dcf67188def0fdafe6d98c8a5b1e4364b87cb0710e1955e3a2b3d0b970f10684b76a8ee6e58fc35eda725a03c7be6d7d528ee6137e057b0bb60c91c602b7903d7e8d7dabb11b269aa99b5d380eb1458fd9e9dc320d326ecaa81cbb096b48025bf3a10f4e0fe89b3d229e38bcf2b8ed1008777b231b97a3025b4b43a3edfe3858180932fc7e64c3aa4e64f3514508a495703946629206cddb8d71a302872947695b80ea2bcee6708e7b230e78ec083939a05b513bb698bdf619af28791dc0aa4a77ef55f9d4447099d0115fc9e21d961fd2710bdd9b454286810f04cdb26de4bf9b08a876b952bffec9037a3a86c03ae439d6c6ea030516bd15371ba496ea2a286acf0911485a17ae2a84433377bedd684e724a7b7c4befcdcd4688ad2afa99089d5be78ed76a15dabcffac4f688b1df2ece44ba7afebe4274cebde12462bb72b3bfec030b49f16c85838bad98d1d95983c7f90a179d4bc1452db8a16bb7acff9886219ed87a3d8b7837c0a2b3b72ab17d3383ceb787d03edd8d0a906f36b7433987b8891b7244d2c3a5934410fd2072ff69fffe6dc51c9a4c1d32600fa38eb88ae6fdc7e5e471b6059f1be7e3f57397752e758bfca6ba66d08e8e64f4f30593217699e20da8aed30fe9bcec98955035c7fc1a3e0b667eed0ef4cbdf06189e55aee62ed4f848abaa10cc82ee1a7b43dab6d8905f800abafa695b1bcd599b0c3c482c26b62d249db4c3e22d36827eafa3787503b0bed77b8190feeea4fb44a37a5364bff4cafd9a5299b59544d60e1691b9eb93b0c64134942404b105608c5e6894808288069da50d02a26475fb0f04ac96dc483c810e85aecb8edd3978dbfc55be1fb3c72a3bbca36dc4a4481916572d233fe65b0abdfef03f9b9deddf39286ebb9b96055f107d890fcf041212b1355dff2eebaad536f7411fbcd8a759ca537f49d2e5fac4f53646b85675299362065f93586d7540605cf80944b2b63fb3f962efb547d1530e3d984f60f5ae309178f7da44097d0118f38bd9f52cd45120453711bc11f1602cdac44338f822330eaf8953c191355c46922b405acde0db4f317722b8bb6a04493ebc2cb4e4c050e386a6bbee6bad0cdd2b1769060c522bd54ff8d7efc43a56617e9e9a37ef55a4a34c5dfe35714960a8f5e7a66d2c1618966f64161eaabcd9e3704dc3737a9e24701078fccfb57d87882482dfc90e3ef14c11ffde627bac79587b2453feb847c44d553008eb26d43b27cf80da5669fbde3e15346627bdd100f6a5d8085f14267c2a10ce0b395a710226d399059e9bc3388786d506b9bce96022c8df6b4c368899f165da48173345bb887c3f254f95974cd61355b2e45d249871ed86ac2cdecd502fbc895113ea3e0e8defda31b8016523cc6b2cc4b6b980d3e834cb57250d8698de634ed9626b5cebd5ba6b2b4bc2d310d2d5d8dbff0ba7e17c07e196313fc8b8111748812f1d8d8ee365283240eca9df50bb4f1f01f46fe2ee56e849fe62fd2b544985e587dc02fc38cc0db4ebfc1f0fff6708293c815af2b82916a1d87f45e433c57f75d804ab7d4a755c0f99ca02885e11cf65a6909e7cd21774c1b2e02612da357744c02ab7f90bc16e7176e1a51b86a344bfadcbbdda7518165be9ad654172e352d8fe4c7231c208a24060830c07236222ed686faee94c91982c90240e958235f724fdb03885d478c6fcdf8fa7616af79223ce6d87cb6b8292a106271ac37f2a506b6cd122e2e302c3272819c333cd8989d49ae94c870fa40dd6bd8e981bd33538d7d131aa71facdda3cff1ce520fc5c61e628325725e92406b55da52c84575c154cf6f856358b9208c7c957fe634eb69ee62025b97fc99550d7563f8e99a5bc5a30282930b0f351527781f61ed8210c7139d6e94188bd5455b7ccbc8bbec54228124289a1d766d33e6edc930f539c921d001da359e0d131a943f9c4c9f32b0f0843ce3e53061ff65c4f84bf56bf03ef35b94dcebf83c26c04d68e9f78adeb543218466484ff390671b46e95d772a9e63cf9043913a05ba0d58b08a8fa0fc3018ee0a3d56f45772200ee301ecc339c497a88c52603cd28dc6f7f01d983eb20d028585ae08a761469c1af1cd26cce88557c30bd0c5fdc0f23882bd848e16a398841cd913f08710b6c25b983e5efec553314378e2634bbc36263a8b38028e3b716b403e5ab5109d192affc1e7f38b59141704744b3b6def64d00215732ab4242e69f130f8ba504f63d443463ff72cbfaea01a08f16b82680316b2b014972c42e1ffdb03d8b7ba8c6c92ff569990683306ce3c5322fbc70fb5297b876484615e87b71801a5e01280bdcf8c6c6cc98d299b384f5d166bbb335744047b8e418df1ea09d74dd9924f5aa6c3b7e6c5320b8f06d1e1b35108a1b42e6eeb0e117ae8fa0275d27557a337081468761a8cef339992642f90e38ba085c8e26354b1e113482f4dfc5c13c042324be25f330f3401e3d914638bfd1f9afe1fc3600ddab41ea20649212592e5298d8358326117b7cf3939034fef38f0d6a3817930dc1d141c1fe70d1698af1f9041536a3877e62d41f2456e5cd5bce40440096476601cbdbb57ce4a4966992724e1769992211df6644edd458d8775e1479e18f746d966f6c07593b3d39e9f9b8d474b7beaa3288349598c5b745dd8b0e1a9e8343a3ad73e57a93eae297469f2d41f9af7d8875d8ba27cf530707df7c8566b01dec0f68ee405b603c9c4cd65de0235fc25c5acacee70b3fd1300c2d4ff138c41f71043c20c844c27ad86d72898a7890520360de772ded0c4c93832b3dc4f56d88179c17c9057ff368a6b8a72d48e966d37f50a516fcd12af7d6a963b975f30a7c302bad2b218af6b8f59de1b2521640b48bc93a3448ba7f69126ac01c8b0d56df9a61eb671c2ff86e9befc02c7ae24fa01403fdc282bdadad6c2b749af9bfc4ced8b76e24776e11a2d9f6aea8900274a7c4f9e19450062141d1cf3ea37f661cf5c85ed0d158a99c3dbefd7a038b6bdb55f0b9a567e389c0559db189bdeda7d0f90096df3c717cab8e9db582e7e7266cabd8756369c5033eff91108bbfcbb13b5bbd5a67e79719f0813f35bc35352450cfabd9edf54e538632a49baa568428926134bab4a228728f0d8a8d7177736d493297c748fb2f0b1c2b1bec9b82c943e61793fcd75f95a0d9b0682805ba7faa729f2a77f47df80dfd12e49a8e03d56b1dc6bf846a36e55ce1a89e522cb9bfce8617365135702c049ce7c1c75630a08883ca2e89bc2c61d2bf3dd8cc18f40268b78e903be0ccd46ed6dba80008195c5665ce8e9e122cdbc55403289f36912bae9c7def3b843426a0f37af12fafa2fee8cc6c29499b7f2228d32ea7c5d18644949878147178c62d06b4f4f4ee0450e04ed7d9329e6db77fafc2862d82d22364cfd4467917d95887b4bfd1099a6615416e0e66f3b86d39445618819725f27c3c12c31135cb16f230d81a79cb70ed00cd54509c869153918bfa62b0ffc429af057694f0c5336770800045bb29516949bea86739352c0909d9de700919f47205d68a2eaf4819835a63b14933069e2039a104970da5537ae0a1f32326f9e77f837f27f37e963383b896e3fee6d56525224ed7b3846f51020147ef1a78e9a5730edeb8bff4fc8d763ea7c6d55a8b08ee3b79666d6f156eb43f69fac563a0877ec822a4b6959cd7b25ec848ab63a6fee0794c112c316caeb38956d2e58893859363e11b726caaef9957a3664ad4a0aa108f12412c9542b7fb23fd0a079e86f0ed34f63d6aabb2064336bde8ab68d630417c01af1467adebd5bf91a01fda46f667a339b790c626fd39570d4228f33bd321db5911e464ee5a3ec9e000403754a06eb5ad280b70accbf6e0b7c73a0cf68cb0b5b3e142cdd0db91ac6cda33fdb3b2d17359c1c24676c26603540d65db8412fb446179a15f65a5b86718ad2a080af8b5aed450e94ffb49c0da0d3a60616aaa48728fae7a818b5d5ba3454d32d83e6785ad4a5cf83241dbcf1bd9d779646afc16c3ac607fa882e1c95d69adb9c026572216308880460945e72cfe280a58ae4ee3dc7bb33fe24928ee1705126e31b67f884c6bbfe3cbae088530fcad731f4ebd37184852a8f65f153a03eaee3f20b21e122ff011086e86335bc31e2c4c4ce64635c3ac8e7d75c689c6405b4865af143f8d223d2f19e65561a41e613175ed66c3650dfaf0f9a3174a8015fff4f23a9b9e617f04f02de0446be5150f2aac9d1e36d44a60bdbee6c4bf4b630b0bbb705ed73dbb99de392c5ad1fed826ada670b96043135c53500569e45a37512cc49bd2b80bf276dc2e7dd8cd9bca4c9cac8201d5d1702274b4dd34bd3ebbdc615756fc6be338f6540c405eff19dada1a1460b4d1ee5386b3d4910aee4ff157cce8c2f1ada54a02700940200d060b52014e95278fa35a874aeaeb6480a34aebdd1c24717551bb3bbf8210d1829527019e2ccbacf77780aee5e7a83588e33662af1f738a17864de84696e77a0bc03fb925fbdb58d224210c52d63761e43904acc1f461706166f5b9290af2263d44f568437e77ea90f3dbb5fc1aedcf0f0686a00dae5a0f7ee1e9a2d241d347730b303c523061303ba37f0b4ec4c24eeb7e77859850055cc9250fe2c7b068bfa3219d4570a9ba19a05906f83839ed16251343979216e98ea493887091f76b41639cb514f10be7f2ee360cd31d33a383a4e251c86344e88d205d52987a2c56dfc0c4a3b3cd0601a6cfa88bc0b382612c273c076ac4f1b9753275d9a8b9efa5a65ba1e683ab3b16cc7ddffcbe31f14ffd3d50ee05cb1d836246f77845d755f4b8a0457e247115c62f7ee03e85117bed33db27c5dd0612bfb5700f7af1ec8c9854d46dadb5436d07367e34660515314e58c72532d74fa88661dae5832720d2ef27d81a35fbb1b715530e9b88f271c72046217be52f2e5613d165fe779b326cac309d7f163d933bbfa535b39486a0fb21f5a2456e77ed8978dfeb852e194c0a66680a7e3385e5a984eb0e8bbaf2829577d4054a91879b404494639bd94690f1136feac936d7677b1b742932a3e6df05422002afa6dd2d6f1cce07bef1d04738b11223709e2d54763f9012659f36487f0e4f78e57db63cf57a3a03989e5b16538d47051c3057f4f7a4f8e011e8ecbebe0e89a33140d7e7a3ce1f77c85d66daba8a35b3a86562f0db75a5436b6d62226177f7beade63e1f212a80c494de53b8f0383713251fd4296a8020cedbc5219ba74383036a54648ee0ff86099b769edeeb1676585a49b97151d60b7145c56d0725ababa4ceeac29254131b060c2c7db43890beade01a63976a83514f481e06fcb771486f355c9cb69c5332490c0d40e326ae9e217f2aafab5b68b76c83b6dcf58b585be731df0a44fd2a999eb28e60d52ab22a6694cf7f9f405811accf4b0747ce0a0ea9ef95893b1ba4fb00870fed616d47d989e41da805d60e8f59a5a9fea7fa36393acc40ee9c7f7a3c0edf7d6d3d6490e324b5795b2e10989549cc942e9b900e354adb11eb2f6f9dbbbfda9ac491df73bd87246250f0336340d6203fcd9267a53b055da5056107b93b19c9c74d9fd1489b49838c7d01ed5ea406d7d6e484b15663371c603c46f0a721ce08559b1b7f5f0a4e4dc0080deca23eb084313efb6aa906d0cf3b30717d9e0d7f4ebf3b5a4cc96ffdfd7ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
