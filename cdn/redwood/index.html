<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25dd9d035efebc59de014d3e8d375d6075fbd34804377f00cad7cd1c016577532373cf3a42ae87ff41f352d2bbb000dc2e24f66da9274bb717a678a61659533a5bf09c404300bdc87a148c71259c63304116cebfb12491014519db90d481055128aa2ebf19c6a20f992ed22eb2d8a646f6da0e28ced8f82dc016f27c491cf5537598bd8982075e7cffa4b75c0ea3c42166ee8c97e7aed0995f9b1e38e1891c6d59d5a6225f8fe1afa9c06d5f48311b96c7ea325f27a0de947ac050b68a2e829dcae299400ea9e2600b67ee249d3f38bdf4f83edb3c2707f1b8d11ef78d3be6ab7b8358d29a525a08b8345c747adb48971f6705c21e6d817303fc0ca4daa903fa325d7603b8d4f80087fcfdb9c20b2dd88b5abe4dd2f179bf2ea1755d07b788289850c49272a9630fcfaa438ce85bdd46ad27a2a4a4a4a8f2429c7274886b7ba6497c6888818a9a11ca3daad7ec63975f03a3459d46c337c9b001398186ff1040fa16b15a54c13d2c58fd1f5337ae0e78de8881e86d744080f05971e5849702ba73377c93b81ba4b09049dd3711261063b837145ad9473f3a120586b26b04de89fb418dd96c24372dbb8562aadbfff30b1f4c8ba9c55aaf88c9e4e6e664660f2c75ce49fb1ef1845a4252bb6ee698d4475e4b617bf43e3c481bf1bc89849ebf3f69d18b5c140d0d7649f25244b680455f4f433c469fd38439e742d0f3225c457109da845dec0c91503c3e20c57f941443890a2132eb8f272d5d94837295663d2764381031b0ca0623ac9838f7c4cf9a30c34b43ec570a2d6a2d5605da5d31a20eb95683e50aa21a16d1ace897ae605a442af279fff210bdfe48debe69ac7f09bcd097d13f036c2a77c9641263e3b65a53356bc60082f3cd99f0a4d1ad5a27a0f954fef118ff383e948968b436237793e841e2dcbe4ef9c50613130e66e301c10ef87f9f69f95d539d3be4773e69f72fc42af0ddfe1b30a755aa741a6d98126c9040fcb80ce765269d7fba7828a8b0696b62477c6b965df211c4fd9b3d924b835709d4a43e43f446c7c3ae941c3d0734446ebc43a181e0118fc0eb521d73c2c6e52c63c98dec6f2cb099aad08c3306cb03138cc8673b8a0d6c844ea8b11210e76ecf513c96630995369a161dbc727dd14baf501f1336c45266e77bbf5a005234f2e0c2fadd94da477c9cad8233afa8b9b590468e1e79cba829548a9f74c91f3512d912fcb03e3b2e3c08b176f7f83f5b286247ce2d123dc023807075a92320f7e927875c2d80b8f195c0c9da34aba11ad018540e5c19d55be036c1ebd01f004dbe811795b7937861a13aa7eb22a33bed39f803f21762ad055131b200088176ea762b6c308d932dd5d7bc91d9264cc61d1ca6e1fd500a24f9e31501056b3e8769190c67ac5cecbe5e5cfde694e11abd604b00b25e30391bceb7bfa6ff2ad8ba2a50c5b92b33508b2a9a02f23425134e59385a3999579e97880b30fb0066b027ede5e6eb23a8f90e61005fd3e366223e3e81526308151c90d73281804a15a95e24c80c23fadc478a76f8b4840119d5cd1f7e156aeb90fce8cff7816b98ba616641705a821f469519265eec1ead31b202f91102dea9e883bd80c83253612e9b1d149483051b2795906cef949b56bba003a3c2f7e44e457780e857a427dc0aa1aa47648533fbd8c252f5ca286581012bb36cb4f7fe8b1c2dd33c28ddafe30bc7bb52f7e5be52bc06d5d5406185cdcb04a1d02f2797e870fbbb71d88c212ff8df6d471dbe7e9edacd4e45469807ddf8181f11af7d636cbacc3e5e84af035a212fa8eb40964e7551fbb61333c9dc1513957d7bf2ffe8f3b853f6092e2a58151b23f5f4ecf0fae7a05fb2fb95dfce9faedc369c03e1ed0caee80978cf2cd5d70a65fab60d3247978f32fae7f7fa3ed024062989aed79bbab8c817ab4cacbb3ef50878beca2447985c073a5ea13720adc4063a93cf8e9383ffbfd963aa06302eade4b2e6c1dc24149e178f37f8edadba818fcd2da43e8dc3fda7873e691f87a741088d0c0c6ae8d875ed5275cc94a4832ff4754256adffbd1c2651d9644e92fa057bafd5eded4e44bbf9e9fe2e75fdd792b7ee9c0edc39161ed1f19ee0e6954cb82a35cf1c2381e2023a18b3d3a1e579e4ea6d33033762bda0873d98f3750e7ced5a2e62894abd6e67c143d75552d6454ae8ec9093bbd4e8003abb3f0cd5283aed1be201c190a28e502f85fc45e298f4da09ce0e31ce9333b893396ac91ed3b190907cc946cb5771c6a1d8bfeb21bafc184c54d1d84ca0c019710a16e69911b064e3c80d439851ccd3bb76b3023960614a9d773279a17f66c1284f8662f2febdd29906e5e51395d68942f4fc9abbb53376a50e66d5f53c93adb62a1d2875b690b9c11b97f051ec29a9e3ee615043992a5d7e31082839935365f6fcdf5cbc3ebd593cef49d577b9bd53502f7bbfa26c9d28669f7bf20a1674bdcdd2e451f5ba4c3b27e6089de3f2147dd41ffb5d4f61fe92f675e8da8c44325bb2f6a8ce22e134d8448cb8f854fc65f753d85257243083b01aa15380e61ccb86be64cf594e83d3310831589124fd93d4020e24b8389e08019f0c98b9f42fac592946c0cf970083571eb08fb63dd19166e5eff5e813d2937524f3e2be8b88b321f00c96d5a22e829c9b48fee3968f75ec17df173163ca63438590f8e5bcd808fa5380c93a3e9a5033e94982ccfb64669c87fe8ae4cea8a49ffaf6060ee6fdaad006318e0e1262b886b063273659eb5e913f3cf900af7b6395847ae99d6a36c15bedc74a38008a6e2ef2675eaf8b619541143024cc60afe86d181e258d2925acb78398263f8bbfa9c1b1fbc251121105ec9fae4013f4028161e40b681e9d94bb132c331a0036b8e005eeae318fd179b7d67c220f133c03672bb9a43a0bbb0f89cab88e801548a6266e926e11f10a06e1cbf86f56b6338a2b3695d794fd5554a311d4f568c7b40d5e36d544a75a29f0294f7c458cc13e9f7d758fb3609be1a1ca85f2ca075eb1acb77a3ac22541c55ce925a70d2dab5f6efded71f93c12e551085e9121f96aa293f3d74160d60ff23ebf285e09750cdcbb84a7ca3ead4fa0201ef71aa684ea3b7943c23ebcb0d55d0050128366ad2907e61473338ca78a64f80e832457f9d1a037ea049494cf65a12d4c309f7c3e15e51a827b938c18fe7f22ccc06b41d7b4f758d681acb79e09a2fde2d6066da197c8f5df809521037bae2b28efb74883fd731402737cc6bb2668a543c14fb2cf92c35f46ecefcc479d1a19c506a6abc32033db6e299c5e8557809022984aa589d83ad13a99223fce47a1b48f4e17588767be026b118a2fbb0104dae3811028e80ad949e5315c0c91399c0abb64cca1ecb50ad710c02639ad838654b85852b2b01dbd25fe6ecd2fb850bbc4c198ed4186dad6c673153294a257eacec1ba858add206dcfc6efa2b870441b4eaa3f5d9d23986286027106370ce38739ca69f1ce971caa97ba9d1f80cd65553bef7c8867f18bad2181f0824bcf85cba1992c873ed7c60c9d0d5db971cf8a1cdcc87b0af5580431edf344a8bf5d79b861072091c6a2e9140736b51c6bc05a98a0686cad8ac9b0d7a87127797b2313c68841d8e00358e633def8f905f071d535a0a3c84b227cda8a1fed80181928202cd076979cd768eaab97e80443334d01d7de60da78a09e78e22763c4cc05ec2b3101c3a41b87b348452760175c90bf0357d11eba50cb175eca0110da08799b9f3d6b0a11ab5be1f0c675879aadecad1581769b9bee386436a928b5f1b5aef5ffbc96fdf47f9419f422b6f1439d14ad19b5b3a7bb7bdee9c138203e3760253546c348e70a7b76846a588088de5fc34d3b7cddc1cff088d974772e2249c3c5de9df8cf3c482accafff3b51283d87c3c281ab252c08c6cc05defe5ec2ac2d087494687f5f5d8e0833d906e4d28adfea168bdb8a599be94c6b3445cb27bd8be77d2b231a089ca26a40d0b9cda32a69bb8dbf7b884116357d8ff2d3a1d58b21fa7f2d9f8decfdd61e39972f37d579e398fd22738d839a2e82e46029406177b16cb11f0e4c4d85680911a82dc68ffaca2804e389e3aff630c0f4dad85fe2f780c0b23a8cb10c9470bfc31eb8cff569bd62618077ea5003120d7d217329bd5ae965c0902e987ae7ee9135becbb0dfe509c7b2d450fab1434d58a5c20a12250dfcdcd09e38d0cb310c7e841e21ffe8f14e91bcbb670786e3c7da308265e72ddf8b63ef6804d4c747612467f62c6cb0ca30bfc1239f581e6643c611e84a831ad27cd0d8b88a62107a9fa6a329936eb93cb692eaeaea0cd791171c98a26fd02faf8f80a43b9e426dbe12cf0bd075217ccb51b6b415b31cb9d5a8f1b6b9781806308b1217c64bdc04b7201a330b35ce6da20eea39353156b1f09b0bc760e2daceb85d133ede351761a1d352cf20efea64686c2f506e9c2f87c0b17ff74e93ab778650cb2bd08c1cd29b91ee2632368325efe725de53e0b4f6713265155b90d874cafd42f9c7a759d53cfee50267aeb2fdf2bb858abc2fc18fe535988a3c0e1d56d7c53fe95f0164849eabf87ec65d7871288f289ba8b616603636851db8c6d3f89b8baab7b88f04e02cf77eb3febfd0b5d6f029e6b99384fb1cfefa235d87739908750398c7df8e2e05041f90284693d59c66221e90b00f4ffd7147a1326fa9deee92af882e516d111f140ae06840d2714df2b72f80a53b68c8afc9c0c3cf555a090465d02921a265ecdd30778718f72df6e061692016664e8f95efc19c63f4ab35d257c3a04831c2a2c79dd8cf0b4065249d2af272de7df734078d12fc45401ad1cd7f7fd456680cdf4dff5e6a724b1b1b56fb99a50011a8af0f11eed23f4eb0f9427714cb4d19e0544ab81433bd0e8205c9f738a19521643c09bb4d8525f86c208ef62d89d04a3494c73f9ad523bd47ca9b6a1f7323fe3abff08f052fb59b0d5c013dc598a0230032a908318c4a30a1aee3242e58302aec0d274d736d61e0c14664e221a0606ddca5f15f30e64dfd3f28c2906a88a961b07ddb1c6f99ed903b2de21fadaa6729b17931dea42c9f0608733ba7a5d2a79960aaf06e6e50d21e91ba2c5d1d381fbe846f94e150329c13e905d8d359a3500ade187d69637e62866d5232caf22ba2b5e330012e2d10fc2e610c5ea54fc5c9a7a93ef6b64a1ac5bbfe284f655aec1a3297741f5248f68eeaa61eed4964117f4dc44350775e0d1ae321d672b5a82887e406e5b11d3a76b53021b1a75fb4f641f83f76f6de5b0af1a30c92d1c27c284f71a9f646af330d6ab91529d91a0c9f1e09d0399480384ac45c9cef18f9012c4bb501bd21ead07552f931995bd45c71dc6d427dec8b6d2920fe8c3abb8ea9304d59f05e4fd9db191b33c1017867d5bb0552b3763f038fc1493f350cad92ae272da2380f0749bb8c6eb02fa73667d948c5b5b13faab5e2ab3e044b4b8c3a81fcb834e3417a812dad4e9fb5485b9de597cdeb1728c4c5575defd717543931bbb582ad0ec83d03db31f965fa7f93f5b57eaca6dd68c79b8e910931d3a450a66a1d77291f8477c377048c06088a626b3f708151051262fb20ebd96d6429f16e57645522a9ceaa2421d3c55abce4367027045aaca66db9f2fa7b3d89c67edd2092d6a186c3d7e2ca9df69709ab1628c98b6aa23cba3a1d9a00692ccad06c2b78fdcc2cc79c519667521f3b1a4ddb1737f873d43ddcd7137dd5bcd20b51e48627f8d901579946ab1a120bb425f05499fdd1684fd2db7b4fd057295bd4c1b1581bc8903202416fad2f97104638af8e46107c0e88d00bed7fcf4b95a7423da5df4df21962a5c8a2a85d50ce8aa7f6823ca8388f8ae770100c0a67fd7da45c4d76c308b484ee4e75388cffd17b4852a95bdacbc8f63b9c12fe754310b5ac766359493f763dc6b81628f51da8b82f416799495d152bd16f0eeeb1adff6cc3c9afa6b298a9ddcf26fdf0a39c93791039b095cbfa9d71582c40536263b99126c03d790fc09eac344c189f4adeec778a3908977ffa801a68b3af56d32520a3b893f48d52e02d9021c1c7c95efa6ea36f789de6d141a81a314e8f2cc75c89c7bdf4515e26d733d3307ae489de74d8c414ad480018e47d044a4518e1d3ea2a0ff856a8a1e0273e28f41de2430722f09a5dbee05166e3a1e3bee12f3402646e62dc32bb9c3807f33f9320ee5d5ca3eb6bcac8d77bc8172dbf7fefd37af6d079591edfcf47956175ece82efa6ae7bf2a7a16f92260bed45c518982a1eece2adf4dd7603644e372d2c0f098011c18ad408a03ca036c44670ab6b355af32855ce0f1fd15a3242214dd94902786de23240219a24cf2d017521a162068eca8745c16616c2c926533c55fbc04443feebd74b2988b17680c8558d186b72219a08f23edcb8964cfaa2e74aaa675f8bf5dcb54213160b9849a9e3606833f66ba99fd894fcdaf1def37282579ec55d39a20912aa4233a0c90d4d805225d96f9618b2c5bbdae6c4fac2eff5f1d11f47ee7876ff62b78b71bfe28638b1a965bd201db0c41fe1cc9851a6e68bc47ad342e50c5b5b154c77ce3aa5bb79e2072695bf67686f48e2e60f9a7e56110bd95129d18100952899171059c6dc66c56b55d99c505064bfffb8e8800ef439f85f0799b0e221e72938d7d874fe67766f79c63555e1bc921372796f54add3b80b78c7865ea9d39bce009ae7c53a5626ab33c701249898ef5268e3b3a194e7a3469df7ff38cba76be67f1f6c37d1f1e26bf3dcb7b65b06ca2989fc4d2c2500bb21a3660142c4355e04a5f2d944d6db242dedc3386ef9516846a40e5ecad295e9151d1b4adfe663cecf0777d2bb60382881eafa55f8c370f9e654837f029eafd9ebffb9a8e25aa65bae3d73064b76ed3a61ef3b65f7da32ccfd00e207d7a3d9ae930c3b990f74870a451048c7edb4ae30c01c20bd3de2f0ecdf8cadc78c91442cef2ba994c7bd576452d0a09c0eed8dde309dc2804bc631f00b612df3bc0d6835ca17cfd45be58eba771e439401a6f1e088d3cf84d8c78f1b7d02fd4c9240419f83da15502df2390bc973a16e5d817fafaf87b9462f08ebb8736b8af2bc15ba909b35132a595281a900d5f56b4ec0e0d3880fdf72d3b9491fc9aa8cdd7ce8351867fd365452649ebf41d7f348130229688da997c6b75d6051dbd82e2b2531fd48357c11c1f250c8b7539f159e346d8a8ff6881e269ec5e30324630d971d28a821b4b654155cc3df675485052fca3fba370f1ad705905206ebb60a04b7dda884b038b8a7dadebd3b504ad0531fadf9c80bea92846f6eb3578a3ba6f72ac61c3f5438e163b09226431047c74bf5a52577f18fa2c32eabee933549d4404f1ce014f20b5310dc16f5a532556016ea54d701a69180e96e6e6888af5bb3c39fa76bb91a3fa34027872569e1b634902c762b5196a64ac1fd686d1a656db40405d01f33f902339657bd5728b3c8a15b6f8ee2ce75bb44f736254058b7a04518ab9d3d5fdaf2042356afa42b6b988ec2580ef3c463b2ecfe44ff9b299ad971ab1b28fa2dfed674781d4e5e13a5214ab33ff05ad116519abb59024e8f6908674a60c9470fcf33880148f3c29e09cbeea27a17fd20fbfd642a51c85da553bb61c4f19e2f1b9c4546c06183048f7c3d6353ac49b8f945572e9b4be7130c4f9fd14c89bcce32392c1c6a555610a1bb8ef02d03841a740ba704691ccc23b6620a6ee134b2725a27be59cf1817d030ffc598059d5954355089d4746848f35194d10264a1ac9b670b955ba0cfb3d99efd971e334b713c5b982e501817d23a4142030c9bdd63f478244504be7c1636b0aa8786b7571e86048d5e87cc023dca261280b186fae597b1a46d911253a2e0608113d37e3031016506c09eb5fb48c15e6aa4a18733607c544aa037a0b70d5eb67ee78dbacab693b52d71942888b0de901c1b1ea5732109eb45fc80f354ba5b3ad91aca014405d8a6bd649bdd9d4734007609375121c7e2063b76e819a57d673cec77ef54d6f868afac1797f4fe796ee73dc5c128132e4cc2ea136fcb74c39aedb4d6e32545fdebd4673a2c26459e255ae6b2511a2b0861217c9e0f6608a3cbfcc6829ad86c3678e0b1ce08afd6ec8a19cf3e2ed3a9867b6e5a6b8ec9732eddebd6ce42cca8486ac2f2f330e00dfefb82055e961acde3abe7c45a11b3640d8ca2fef2241d519ccde6e1336cf8b6f215a3e4c03e084663958dbb141a4b4c32506aa6526248bdb9ab3e5383017aaff369e72aa20b76025ace37d453b7cdc3381dca38b89ab74d3ecfdaa8dc121aae571752f5bf1cac2ba17fb7131dcace764a9d55b54e9b10633a88e83a197bf5778d96d9c7f878881d54c49b1d52add051f8b9ad14e0d16c8e677ba3a70601570c859cf4631d5d86c680be00d0cf96f96f39cea24c3a93604870dc97d66a13095d35b8ffe8187ce39b1b6d0e49defe9602da21b08e3c7c9fb29d816adad6a11981aee71f146eeeed6f7a333f5b8d8eadf66aff7a25a5a12d84c0bc10bff51fe8f2d17a65df29f734b3a0e1ec8630dec903dabd896387d024fed5f7199c8e8ea6548fb9e2ec5c6fa4ab1524fa1c01d0152593b3be70e7884cdfe27bb3ef096e53044b30b6b36dad850eaab4837f85eb054e94adb81f51acefef971ce6d453b4fd82f55546ce9297eb6f95aaca9987a9fc3db848288a07b18a15d9dc8d36094fd5e28e0cc3ad8f72f1da81b0ebf94e9908abf91ec2a62261a6f6c8b519a416ee12c16965a484d96afd11ca696261fb6716cf3ac9400ebde622140b0dbd0f4b29bde9dde95fb6e8981ebadfe585955825a4946450513e16be885fb84d05495b742cada4ad292dcee4f6a9dc7c2726e274be47f8f7d0a561889e37ee4dd498333e193fa2aaed5fd2c379ad6f75e9205a40079eba9c67590c386df4fc3a74551a6b1d3f7f0c9f65f133741ec8cfc9391dca60e0062e977faf34683e5ee6c02e1fb3b64525e0ddbd95c51a8ebaa2f6a902b81dc19f4489194a8cb42fa5f6d7f09d8b6953448f5e3f662c1dc475099eac85c1953a5ebfaccb545e93f35cf7192b1b7a94b244f040287dc73796457145bca1a795b77b162d1f8faaff93242e3fa70b92769aaf6628d8af386582a6d6da34a4c49b3b4e3306286b77c4ffbf4294c2c04ecd313f9c56287ce0b20ecb72a042e1fadbbc16c9dc250581543a0baf47ed0b7f96a1831a57ffa25944bf9302caa3c157b476044d0f6fdf2c4e7aea474ddda54296a4880e4c7f6e866a85fe6d524be0c6ba7d11c1ef8ba233fc392676911670f416e47b59c899249b01a33f48b69b6b403f2ea604601f5b8aef9439bfb4674e4c364172f333ff08e605c25abf49b4d6584dd7b97b347ab851e3ffa032100f09d1078641a3f25a00ef7831f900ac820cdfaffce323aae0f265cdb8fdeb62c156923fe8bc6746a2e5dccda7e2928821e1f1ac248c9ad3d54b793695feb3a66fa5d2a3750aed556717fac0027e2bf1c6872e4d1227f99e15bf3168b1cc817a2fc9240c15a4eb88e85ffe165bff410f720bcc5667686578f43dbf590477bcf9aa696506b5e2bdc2cbc22f5be08514e2a344dace60d1736834c05442cdb2c5e5fd7eb54d06a28bab5a2220c7b083567f8958408ca7606a489b6fb86c777fe4382eb5a046e07a28d0082d36e6f46eb2891109355ef67966940d65a60d11a42bbdbfa236ce14faf7a914cafb6b1a16cabea350a68eceedc0a88d4d7b9822fed7599271386192b77152a19bd5f5afd5fff0847457e9c6a5ff09f7253711d3b798b63346f39870b40d58613360b2a3372b4a3a2c2e5ac9419e82a6aad1e9b04e28a7abbfc3cab9d93de642a07c8d1c9c3ffed82698c8ce598052270839bb117b08a40c6c5def6997622b5b5e57ed6579198e9d60c65da88e2a18d4652cee707dc5b6d165232cfdee710c0c03fbd34e325f2aef38ca807f0b0f1889adc65ba01dc12a4f62ad063838cfb22927f5353b1413891a81a39a64a877925e79edf1fdd75b41a4b562d9b29d4e51b8f8d76ae91a180d8ed1135ecabb6c3c6bb74ae82285aa6edd837279b3b71f30f7ac33c2c495ca316cc46fd56c4e1b694447f1112a4d7df6767532548038dbdf100f3fc12182fa00d446fe96ccc2a219d9c72a1cbb2f7566e9a3601de56cae15aec830b00c5f623633f6fbc734bb68d8678a0694c1d4504f6c156e58655fb8db97435787ad65c44d16dee122e66af508ce1ef0d9d73e657af9f30b671d49ddea442a143eae6adb54b684069db5635cff982130fdf54901eef9dd88b303648d1e981a5c249e988c596ea1232c2b3715e3cc77271d5199e7528f16bc1eb89cd7b0fb0e6a88a1fff5b099da17c11248fb833af1e8163eede096cebcddee73b032daa3760cb4bbfc6ce948e7a115cc4050c3d1d72293bf6df8c60adb7ee647f5ed87ac3572b17de6f3380d85c98c9ed2e9bc248de6f647119c8934cf7f1367cf10a4120cb4c2dbf3eb3ea194c5379ba9c6ef30f4907155c2314761b24b39d129bc3df5dfb70b52afa6a64ea2aa455fa8fbac9f780e204839e437238be72dd38a40f67928f469ca5bc1b08be6c84793167ef3306f34ca0aa73369208afd5c175007b601cc259b8ec34fb859060e13ff5eff67eaeee7df679e48d07506378177d4b70a5c3032307253b02203885a96798e38df40f5dca6ae3c168cce09f9475c1785cd5315c9ab45111a04d01a741bf6286937ce47446968d2f9276c65d58290bae382d7cdfd5428db56fe43c9f38ee732c29b8c54f131e87af3cefcea677eaa1feb0f9f214c07149fe4fceba42526be54c8ecf1e01b99b18b04e9b21c38be04b59d48b8d14c9f937115fbd58016f09f056cbf7673b2f19cfc68503be43cc67534eb6f241f3020d3474e57f75a58a1f413cf8cc75858e852cacc38f21a8c8cd4ccab4122448557e112631f2cc9fe49cf69ef999a760d37b0b9ade01b927399ec9c2558adc0e38520128bfbe35adc441c55804a8575858a40c30f033e3ed1bd7221d13d2691621eb962a63a45b9cf4f57b775099fe72d55ea569230288b172ca3dd5d3379f4359c780828c7b3fd892e3cb4569741b4ffec59e7ea918d885afc231897f389e9f9fb85eada54c88cd598fa8706d26a0a74122450bc88f0ca4f8fb3d024a27d5904c3759ec2dcc67d580aee5a220cf7ee97c9f3097edc88f48a386e2e29c1b04026cba03f71e0296275d898e30691f746e2c336aea5c467491dd3deca7eb963062bdaee16a3feac9fdd3c23eb6d8da883041d3bc2429d40397a72b683857eab5f4aae54b5f8d5272f92892f20ccb575ed07d6b509fe32bbfdbc9ca16f31af918911a1c359f8d362a06d0738690bafec50a388c08bc2b9fda486916c76c7d2ba6d01e47d41a5dcae3a4aac7db6fb1f9da91cc1fb672e924731159bc48e99ea96cbb74cd7a6a86cea370556b84fb614b0eb6276d93e968cdfedd0528ea336adba2c86e7f6141cfad0d988749149e480c7d01988addf1c10caaa7f264f7805d5ab5971d9e458d88a3382f8d9af723aa33251ba276798d0c869fcd20b37496ae67d6380218063b837d4dc5da9212daa86dd301459130249fd8328bb7e3cdde9ad65e6477671c69bc70565a9173fd1a97011d911901f7773066cd928794386b4d6d72beb2a5be944a23d4901b064c93acdf1ad5d408981139451b0e1281204a3dedd5b510780fd73ebea63c8850156da93d5d4259b5670a274e593cc834ea84655ae9ea624a3a2b26a5af116494708bbd55e1f74c4d2beeeb8e7164172efc847735907645d1cea69f8293935ae14a438c38cf490b1e2cc1b39d92cc61608bf64fdcaed0baf84097c722aa2bcc161e1b3dc5ba43265ce06cfd719686a8719413167c1eaf77800eb0fa6a3bcee11d8486191edf3505080a3ce3fd7261931b79088462fb9d7bafb96a6f44c88d63d87e0214d738ac1b46403c9a38bd07f900dfe0f7649ee0bcc9ba54551315d8cd149099d7ca1e22a5d3b5e99aff695827352348d40d1c0bbf382833299c9a238b19d0389942229bf17f32214437b79a14265e006f06c469fb36ee347fc64ead01577be904fe339fb73771d4fcbe1d021ef8760f44cdf48d92cfb72d84bb243b39220305b14ccbb04c2f8515eaf9a0568255dd8584e75697ca6a104d7f512fcee53aa6a04bd4e80344ad3ee50687ec30d9152fdf7acb6b77c2727ab08dfdcfe96d3a1fdde7a97923fd008d30d40ca4738a43da55283d2f7ca3890082ab666bb1d4b46f57423b09a057c412be224f55d3bf06fac49430da41b54f5908b5bea1491e7bdb1649b4be88b9ffdfce848e9ea6d7d55c868fd1dc57c24cb3dba050b00a03e022703a61c593aed142362f0c2d3c83558fbb6f769baa2294572e10eeb9895af3464f4d30fdda3d18dc6908cfab396c21d457756675b3b533ac21d57c1cceeb0c20e6e293ccd9cf2a06578b855b21b3c6cc8640e9d690c23c1ddec71e43bcf8d42d7634f4436d298a2af9258b3bbe8cd2cc5083d107cdddb7e1affe500907eee5c87816bd482588ecd1fc2ed1c3c30d5a6fd2dbee91c9169086db67deb6f293f71eeb570413001d0c365c3e19c3abe4664bc3ee3b61c7f646cbb225829d6e3c8e62e1ffc2313f84f43a252a0832adf91b2671897127c38d984bf21435ac4e6838058b1a3b20f2eff7d800e81384d4ecd8a6be043d41d641bb9966bcfdcfde99e6a4e662681469b9b3ebdce209f407485fa3c614a42b7a5286613f98f4ecb1d0f74d96fa8b5c86a7d332aea722fdf33ee59476c293e1bb215c08b7d8bff5dad602d1abe054ad8f456908fc0f5cab86fbafdf1195fba6b082c3d16f31b5b99a5a541c6ba563b07545bcb50868f7ceb5e87dbae19aec5bf07af101308127dc9ab0ea580acd380142bf0154e8336e238bac89a7bfa09963ac490d9942c4df5b7fbffd5b89bf417671a73664ab58ca3c468f6e0906b721212b979012834061f2240920f5bc1457d7d2da7df9eef21158a311eeed1fb666aac88268a918059c9cc761e7bf498a38d00cde900049fe16c4863746c2b5730ae8b029ddced9408760b7fc8bd04fb44fbe3ad44ededfdb3896458f1d823922cbc8e4f7394f8defd024242e5c0f50fdd24c0f20ed1ee04d548739eb00e58e5f5ecb5474006f35bf4b31e266046d28e596067410fe7971dfbaa699edabc3b60b82c8c97fdad5b55449e8ee3c284a197ab9c70a9415878905604ddd2f986d747d46d9b9b508b73b6cd35aaf2006519dc02e6cf740a23cff9a2fd21eee67bb9f7415a9e1d3a16123f8e2460da293bb36dbf32499800dc79cb9587ab38513998f24430d6ea514cb603ae34ed851d919b6f29e5c9f841b10f821cbc28ccf1762f4ca3e8726056104ac64fccb7ddca1d9cde493c3955c9e8c79efc9ad97397c8aec335cbf0b58c003e37e353f02d850819894629e918d6e34236ee87daeda67b3c88ac88cea44276f5d41e0dfa9b3637e679ded879582a1d35d97e472a57242d6efe276671f601b9066adfada26cb1743c8def02b7a0f1a22bc7b206300ecdce005be618dd34fbda953866f13b33f8c359b061d36adc14283483dbe61767665aa33b81d85f9638afd02f62f9c5c73d88bad1ce0fcf30b1b4dabe8333fde959fe2d742c32e4cfbcee617e9278149b8f489c3a0c6598144287b8af4de5002c9c16f5fe8c6952345dd98f28d5fecc647e256e33ae077f12b2db2d36ef9107e0091ec608b3460defbe7a8197f47bb762352a19bfd788b48354cd480a495d0f90004ba8ecff9629bf3c5258fb880c35a6576bbb13f5c4a7327baa6d203511c907109716c46a7afc484fc05df5610909aac8a04c13f37a937385ac340d71aaf22dc8ca8b4a06c2641f76b1bf5616eed1ead36a3d7b26d518af78e49e9c5432bc7de1d5ad63f171356e97b15c1dfcd9b219e81bfa96a0d8aea92a386868f95bf0b094afc505bc5e4926ccfb06dfe593c5117f1339205815ba19ad1c459e2b596ddb87747ed91b82c590c7cd73e862c24236eba927332b03cb8837ed68714d6c198c9054365e4a14ccce1937e79d5e7fa5827439ba94794ccc428b7134fb4648391f68b10f3058f984016112d8188be3e7d3099ba67d4dc8291b08cb0bd0be46bc93ef344875ef73495262b4665e7e06d60676d5e7bc33e610ccbfdb7563890bf7ab3399fc7179af46b27bc3ff97777e9228d04730d3eb08ced769cf6c020e0e76cef3fb1b9408fc386fe3f472e7fc6b24e200438493afb1ff299c3855b35348568b5be492d715c4ea251951c4984e12df604fadb643ba36f915fc8865cb4a5bb645052f174dd59788639437f2bd0d4dd649a0d8ebe9267779609528524a16c1919c46b5044707748eca0506461ef9dd6bb9fb654773506b010c37b7741d7090c953462d5b31d42d3197c459e190cb3511f8b43d8d3e5eaab23e3956616bb28275cd0adbd8e4051cae457bfb8c49a8eff34209d1509d3ae905bd192d14fb0b8b44dd1c0a16d9aa1e4606db75f27a96ebf817f33f262493e3c5de95cf9e1fdbd06c0ecee81e9d336bcdd1164b796fd89e8ca92a18c7f9d4582d979794b16ac6a8d5a820f3c39c08aec3316e9aebafd8ce416a8b9755ced66f59265d97689557d3a19e0e2efbab71e25525ea5483704a90442d1a5c3bc5cc3ea2c791851d17aa44c48e51b6e453dca5475ba9263a115a1797d0693a481f9259f01db196639cca168051c36e8842fbbf0221943a089a03f6f764aaaf526c6c498a85385196072f4eb3f1daa873e602786cf5e1ed22cb1defc60422bd1f9446f5e38029fc28dcd946a9c07dd0c39d89a5bf944f7c5a3722468549d48545241fca4f26a972a8b17c769cb1ad4f1be59cf49cc4b8cca40cefcc6aa55cab0a296f577524dfc39d3d1bb52b45d7f8c87d5b7ec9cdd0ffaa994b4cd6ad86c92c62c5e59becd1d4838a914bba370e9a8d3a7c85d331679123be204fc547bf74b6ecbcce3cd4360d873bc4064635f88ce71e565c824a5012edf319d7e53c8de8f66c82c2954c0c4915f0103c8557a31e81a0d3eceab821bcf4712b976fdbbb75a1fbe8b5d90125a79e124198f27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
