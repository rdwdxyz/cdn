<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaa09562cb72556f33f778f4c900ad7da58828f4e13bd76825f29c2f8721b10b34f1f6bba62be4b225b2de04a800730c2803f358972238f1a988469c683756a0aa7f9756d4c315a5312e2d296d8bd25ed46ac5d558c4de3e67b12e8ae4a02dc86ba1857b23c78e0abf737747b590769d76af806cf6772bbbb4a5d8577e87d6509b664f0ce637ab433289924231dc4f4c83979af8e1c06a30d0b44660e5e972b4047c1bd9cddb1469fe7ccf42f8aed36a9c7eecded2e68a3226431edf04df4875f19370874da0baa12bffc10fdc46a10668d677805a8fbf19670bad05134a3e1efb915a9e2a0697b38c6e3c57b00f7edb97a28a48c1b06408ad4bab8dfa8151474a97a800d57df5d4067a1b66cffcd48ad506333ace34e7f7fb3d621889c464e126e909ef28a306d2da6fbd9d07e85e679d20f58eabf8624072cddfd504dfb7ec72fd26e01b2c4eef34032fd10bea56a6597bafe194b2e24cdec59f629fc8b8e6a590c07b1ce9456598d8ba42e2d0fd16d607b4db5b41d1a9743989957d5ceaee61d087302d21090ce17da151f202a30b3bdc7c1109321de6fb526b325e29d231de65a4f68e07630a571612d7215a3d4b46ac5db69b818a1dcbe1aa87c4529841fe3f3b8a4e3a018cdbfdd8700b0e6cba433b25c5521b9368a76e5de7ca587f1bdc523f37400dadee2511e7749dc123ff1d6543338a611189a20dd3c9f7a3754952ed10583d43eff3bbec86c39d6293d7424f2e484605678a12eeaf0cab0a70b97ea0e44029c94beaaf137ed4ffc1ac35a4403a7b38a79861d94d9174dae898aed3b5a12d579bf6f3aa75e2190145bc73c27c010c07b3ff50ce49b6cbf775fbfbcb1c146c30bd885e77b6ffbbf2d2c0d71f45f700053f0a12aa8898bc7aab2847c4ba4116a9301871623813876f357cc6d25f52cf606dd8449dee795a34eeef179c5ee6d978c6bf711fceb8c0613731622406bcfcf5cd2d8fbb404fd14e8e186f710d78151ac8d57eb68b3c7a73e5f1e751f8fd5aa819d0e862a69c781b8466fe39d266bdbe75f67711e4ce2756238b1cffea1ffe94b84f9b3bc4233334e8b3882626948446f7be405f58555c39d606933540e51c53c6e4883c5893d42ffd4c9b94dd3212d34b62e393de8b9b59d53d1df5e459c0e6ae1fbebd208b3b3f08debf088db21d5a9d46650ebcf06f4742c9b7a560ddf07f4b9bf84ecd5f466c9cd057ec1c25f3e90c1974ea782ccdac959603da8668691843ea2c2c999b2beabd12e68e9bf81024d0eb33f59ca240cf953273c68a5908f73a72ad770ceb45d51eab54ef46685d12bef36edc316d48f47e924974e31f3b61b28df68fb82988e1496ccd2dcf44f033aed6202e64a545f5b0e6565e83e8936088297ca88b59fe60764650ed9db8de62aec0df0c9c09a06d11ed6721770f68c375edf9689f7e554ed73ba312055c4d2c55d3e3e6d0582a22391dbc6ed89ffa76f348329920adb2c73896f77507f7706d517e77a64ce4e2a5e9e6c77f7e9f9ced5e67324fde53fe562d43d42bb4fcd4765557b74e3f982a03a432a07234a7d8de2d1906c86cd0a2be3b8901174e043d243d98fc130cebc77abe1c118b2c5cce420e451994f957fc5f5852fc146f49cd4b4ffe09152aa34498ba9c98c62428f147a064686675a8ecc22be492318e5ade9cfa28eb6730f6ba0edbe49dff3af3275780972b899417b870b269b0bc7858a9711c369c0dfcfde0a86f0c40e7c292bdb5ba29109bb8fd57dd2f905dfea7ff871bc10ff9c298a7cfe89023b95d6ca4f437dbac5094714e1ea1184a731709f32c25cd17922e8da5f4986c0ef0d570842d506524f4456e22465a70d9bfef301fec737d0e44ce0bbee534b426c468415feff531229537e91852d2a5baa5e5fdbcb82c370bfc26b722cffb08b4390a94d491f121b8f1c2f8be7f222144802c7c09eb513f3bbc1f47f6a63c45c58c31a47a9b319ca2c96f8ea960103e0f26f13894e9e546e41402a51d824052bafd55ea3536d3b98d0cf2785ca4a7f239daa2134cca9941ab4f748ff9260dca898434e3d67a792597e63fde359f77e70e1f69bbc9a1e047024c6ff3f8cd3c16c934f3147ee8b29ebf2ce78eec3c24cf8824013ea668a58f5f2b94b39d658ea8cf8e85ea4750f79826e91b4f5cc886eec6a8b86d77fc2a7c9dc6ceaf392e2aebc45175fa723b90415393e51ec01f5193fb6023fb89fb82003a9f65141d7288f070a118620bf85cb60ec5b89256cc3613606445a119aab17e15ea117b7deac4b14edfffc58aae4f17ce04fae92cdd8683b4f3dc86806ffc25ab8bda76d8004ed220ecbfd7b911e01f3c164f28d244ae58698bf102b802adfd61e99089e4cc4c354ad461e1310598dbf427ce3e441c69c32ab35416f246dc55de8eab17b31f4f6e3e4a39788ad3f12bb267a2b161f72194f5252c8576130ae65d02a6a908bcf79ddb51ed5505e37c1429547bfa204b5ff988f1913769d329b09664e51403cc5d50a576946ea9d8a597602f83a225e06f67cc3d7bb62b64c6383e7ae8da4175d27c982568194e9338eab5ed397be63d167db2532043ce8130bf6acfe1a0688c7d12cda5c5b0bf01ece01d3d24f393f647d6fb5c16f666de8d39866c9f5befb02ee25d16ae07965059b6b89cb77f3ac268790c15e3f25a982d5c429fd7b2af1cf4bd462cd1d810193317ae6b30bc22aed04ad32a0aa8c325205c530c86904318cb62ca6877630d4d2111ee43f5495453b0f405b0d6dd20839d1696e0fe91d93a767a62bbbfc8b72db61396f1ea6cbab8c5d5892e61d620ce3fd41eb22d770243b79d07f30ec30412b8a1e1c4c0b8030a965111098ba06290b315e7a563ea5a63b33a5a183e6411aa569c62dbd7a8ffdbce10bed7d8e467f4e263948d2978d5a11750a6881ac0c7943cb0546917569a731c028e637dfee54d1e9da2ad982e5c6aacbc48aace06bef2ad73e8a600e7dc63b47d063e02154076fc2d2134d37339b9a54ea51f5388aae33c72e7fbf3d2d33b3335baaaf5bed4c007383a71e7276f9a290b5dff3bef14d7cb1c157e5c932dd35a9f6ae6cf85d5439b63369fdc24ef898b3e7b45b4a88918b33511ac521e91b8af8d3f8e92fe88122366e66de03f38be2fa566910aec5443873fcb7510d5b38133e5b8bc4b4f92d62a4591559ffed1bbad5e1363a982ed08c7fe75664fe68182f8734b61d4aaac1dfff8567a51216e968d1c39afb723bfcebbe805537fe3938fe8650477c1c4ccab19172d0af2abb8f3882ddc1edfae73419616f7aaa25b4874aa47326b4f6688d74ee8f7c3ae4ac70ac3b2ecc84eb3244be161dde2a9e2235478732318dfb83256a2445edd816da4cec96119ad70754882c138e6c3e9c61c8c7bb8842ea39698bbb2efc665487916eaba23587aa922f1e3a89441c35d610fb15223341955ea138eacca5f6240737906673cf91fca5f9cf7a1fb0dcbeffb3aa3021ea8d3db33e27f28fe99f17891f663ae5f48c21742ba33d891bd8766c1dd8dbdf92fb0fd3ef7eee9f79617afdd0a11bf60e475e78d4b7976a4a1e643a079eb7f1d68db19445f74c63cb89f6a6ebdc0c15b488a3ff51c774d040cbbad2eff1eeaee3f00bd138170ae1357e490a38b28c20dd1ce1f8d227152b45e7d25f9a25265d2a963c6d04a6c88706500f4148907283d2247e8e3f255074d1374646e5a509cff8374c96e54697e0fe0a8d4e27f4c9cc2ff2028934686ed84b4da1b39aa3b75aa5f0fd845296ca052783209f2eb06f47d3446e437eced06de185623696df1ebf445c8574ab13dbe58fbff40befe4ca1b6a5ff901c083ce99453cd2ecaef9dae7b6db70728ff0b3970f73459d605d5ef42690d7e19f8c39044857270eaf84db7c4a4c0a00c777510b50e1a2c184ef66b38491be210405de778ee91f051e1a352414c87ba6c9c8e006046caaa4f6fa32ac3e39fbbaf46d84000a0fb3eb85cecc64410116b03d1ff8b13cf0b731f89169d84287da92b1adc8b522f3c780723b003f0325993c0c8e45ca265a2a724200fd53b40932959a824f8752eba9f744f937abed691baf31c33cbf5f0a74a16072ef81c9daa8cf6d66a7cde900549c53a8de5d1af1c38a7a7417af0791708cf5ea37aad44303d63b25402610f950ee8ddabfea8fcdb0b2883213a3c417e3f296e63a5a49ca89116e0eb4458471616f834afe9f671f4e85b41b3a46f4cb29ef2c9e811ce60feade1afd3f4d5ed2dd08297ce9ed9172f56fd6d41d4c1d06dfbfddc9ad0f3b4f5ac8378e8e61789959198fa89ac888db89c4e69ec51378afc2245ccb42008514c55b035e27fbd747b2fc920b476592856a30acbffcd40036ad11ebe88ee9760f1b56ef4323c45ad70544a2271987d73ce1ad9e7b3e04db2eb71f661e29d05551ce5afc9e676e2a9b47ded7632d5435e3d93645299f9837aaa9dad3cff19898cc81fc3ce400da42ebe1e4e49745fe0ad1ce860a9073803083c24159b5108823874eebe38fcd13271cd1da3a2c9447731e6813e8475360d5a73bd5aa9fbf8159f0025b03628cc44e5f03bfe1891f7916b83a7867a580c426f4d4b6071c6df52e45b86e6d605bbb1a40460217a56ed6c721d624ba4f5944b82aae0cf57ac34e7cb59949567b4e0c99e8b87439bb2c0fbce8956ebd549de6c1b5c580dbca8b97f2954faf44dc5fb80da1f0812e695d492e3fb7b15606d296d22f4b8df17122e232aa5e762b875057110a3d73cd75791509eb7f4e9bd5e6b260432dd5b6ba65e8ac49936eeac059e579738c36d72a1d80479c5d77e904f3d0614db010b6aadee995581c77c131fcec2adaa8ab8d5c971e1d81297d8f983f21e4b5f1b3f40552b2f2485fab801c72348e1e97b0b3e944e5d75cb74389dddb977348ace07abf37c0cfc7174d1f32a97e32e8eeef5b657a7e84a7cebe66898c287d62d7ac6f6e14996a02a4c199654822bba4f3147538658127cfc3777468edeb3c92302e97b5aca46f4592d77f9889adc4facbcc31ada00c7b53269ad6b447a7f969c15d6c2b1651801cd1adb2e5f5f934736d07e7a742d3189cf6e6fb66f0d10ffd5681237cb8bb2c1b065cc599b25783bb5d7c3efc9cafc19db66190c0966a37df898a3016679255940795f69eeafae1be2cefec9642330533e7683409cd6d0b11539384c067460f48b833ca351a6aa654356adf2f5dbda390dc1094b1eef0f37086b72a075dc6d4ceb705096194ed501f73725775579c938b2b860beceefa43b9e603487a6b5f7280c23ad4cd889bfc8b06fe84c3b8e0668bea0cecf743ee5cf8386d636412594b518e22d3a30faf414d45a7c38290d84452545d2d7667618699341ae5611552fe81ee0a50a0c5d43ec2076a445f8e7e7f2ad74cc740e8bc3d4036d5998df98a0ad1d4aac9ebf349f5f6a9b2d43372ea79a7407ef9a125dbf2e9544db32e8712f37c1579ab1a48393e6c6992f328cfc3ae4b4f94cf4df3000d92717ae616c858935ab1fcfa4c1330e0fb84fff05959a1284ff21b0eec4794f9b7e4583ffdcf129eb92d7f313a26ae8edcc3124c7019e7e63e12e7a2e496b35cca021b8d49b7f41c186227fec4d5060810938ef6fa567b0f4d0d63232122dc30bb0888fe3e8421871c1df424cf6a2cc55e1ce09521d0be6d8fee1586e23e8d9c5656de77b53cb3eb98846066af2204081eb662772583a30ac22a8e02330b4761a072387df263b074a376b37f47ca13dd3d0186592c01e2a1ebf6d63e88f453ce59ee636afd4bc23f286d72e4c9e329cd47f2c9033e60c796fc748f4c801914dcf885737a5972adb68650491278205e9f10af2f315cae395b71e9f7951d52cd9ce8ab70fb3472c73bcc5b4569848b9de55c1876ac8d241b6dc1bea5ae553b067913b11709c049b4810f2d8fa3a187caaba4a184674efaacf715e3c3c024faa5c2d3e15c51fbd32c7f1d9b169201eac8c6a3d4cfa6d77f4e57f4407cf386eac83d8c07587cc802a2696f75663b0e5d51e9ff4396a4b5df71cfbb71d1e8fa6eb3342cddeeb37c89880aeb0a63c1a0696b850d3a50123fd5767a84a784bdfa9a7cc72e29118915aa2fbbf99c3b4764c69938ad7a85b00dd1d509c00ab25bc859d79cec7f95c1200f86ec9be1717661945c3a143cd0a4d860418872cdc25afdf05ddaf0b40ac77fcad770d4ce67be11cc1710b8f899c2a2231fd211d4fb1e5c4ef7d22d72a02afec93e7555450dd97f8e869a34a1849da34f53a9d5126196e91ba251911a3b53da689d1ad4703b358b314e442a5baa576ee92c330d082c97568559a50f6632b913fcf4d46bbbfe7b57a6b4a0a820d77aa9bd8d4456c90729fe4cdb79e3e41de0b6838a87984fa0a837cf7327b75950c2fed7510aabb92cb305909ea80d94ca5afab7fa95f73dbade583cc56c366a1de14d65f4c4cbed4d0de11b4ba8423f6422344ae9bf5840c11e4e25bdf912c39165b1a9b0298e9ca2bbc571fbd58325415bcd4acd5fb21f636b2733286815d23b0e477ca77e6085931c9c170c15aadf98da024c7bbb804ff3df84b9defa6184fc5fd47fdee66c0b1c6b4b3f019a811df64cda80fd36b17802d3a331fd83163bb8e67dfb96ae73445d31412d8df4c662229fea7c96c379a6d8cca7624bfad2bfa25ce1de08a5d947cf05478866fb402be90f1c27a144c0b572b4a5d28f8282dd7d9925d21c493d96201bfeb9f897c54e0680dcba9e2fa08cf45365fadafc02b1ed9d4cc644db67bd66cd1a522d719441d23152421e24a447da29a70684418254c30f285bc7afcea3b9753a4f0f2d82fb09a8f46bd676942ff1870c8a2aba0e3f5b0cb69e5542b0c6720cf96c6e1b90f40e38aa5d3e6c5ba63aab8f88c55d050dd65e6d2e0193f99fb79ad6b054e6cdf24e6e1b238895d573280c7420f1cf736f171392957a5164e522b367ce79706f04053404b305ec91e4b982c1873acc3b2761cd8b98cd5d99b7c6b4d9e9bfedd0ec334eecb6a4b73a9eb7e29142aa45800e6c26a91183f6a3e7b0b0a5409794207b3e34e05cd0dfd1fc48569a5b8b68cadd66ed89548ec9dbbda187cbaaf9e70ddee9568b7420cb1319990fcb2693ab89c35c4e0d912949e8883ed7a22e3b0c829618affd5f5e81e7111fe26663b4ceba884d4f819db3ae0159f588e8bc9298d7f43d7b0f0f42a4387c239724d2b7f9031c3c3c8390676ab7b70eb21498f50c3b6a1c93ade4533852d79a608abbb5ac26619df1789bf53a935757be606906d139f0fb90c976066b155428bbb27e229f6f11fdbc2eb1fe82e588816b0bc0386693a27f239208534603a4afdd4d25aa0498134167e28dd6e816f3d7ee6d2bf1cea30ed6c4b365a7329fd315914bf62ec9c01183d0c8a712dff68b4fcafc4379795c4d50e09337331d1fade827d0e4586ad66324f003ff8b74d46eb9bdf0f2310d597a2169cec0e46775e99e0f8ba72b228876ddb0f50261e9bb6aaae73c397fb7f825f707c3dc28b8c3bb6cd9399989c7dc5c25740f918057cd037384e0bfe86b4fb1debee945a9b084f102d23c97105a20943621890d21d102ccc534f11c98ddc39d77361ad53082808424d6a71c09dc7eeff03b92ee87122117ce60fdb4112879945f73f99d82571a1056aca1fee377e854e82cbb823c7b33f2ca472d518f78c3cb652eb70411058e4341ce83a0db1c2351fe7d8c177c59324b36d8e5abff060b37eeee42bb7d3c69177f71f2d2644dc3fe1473f40d63bbea8ae7f7094246ed51f8654a9a9495a43a4c69186b60d314c1b4347eaa66a3f9d56bc24f6f2b59927094bd91ae82cf53400ce93c0de622738f168b79d18ce7602ad3754d78e42229bbb44734e5d46ead5487f5a766baf209f572c12be2f0278a919fbff104c265690b2fa3c351692f0016910da7e1e96ac7098df5366e4907854b200297a61cb2247c0373b64c253a1f005e8277d5f68622727e3c56a41d991f5420d29ce5c73aa9ac86791dfc8ec5db89fee44f89a081b57954b572d699fad61c657eea1c1968cd39a7ac337d5d3702b54a1f2cfa3079f67af032ebb2a1c3df3e73a0d37032e934010be4cd033ee3d936a41b007845d16bd75febdabc8f030345d66014d2629d34c9874cc75a665b743930b9ebfa9762b086690243f70a754a54962b105b2843e5041c2d1032a05d9639732f88c30c141df3cc9350051e580714c61a8ffeeeb8ac40873d80d83c117b02f3726a0d3010220d2f840ddd8bcab67a4b6a8220fe9b8161bd0a4313e118750f2091ce52d18a6724a8ca780129b0691f5b2aa6fa9da2a152301e2690c5c6e12d53957028ede41a5a52a0d108038313eb3127f5392cc0911e1f9ea66bae5076caab3ed141d56872080523c4317ccb334d9d141a5fc0d102910ba87eadfdef5b8f95eba0e5966b783f5fbc2559ab87dc6b2e82688c6c293b37fc53e34b72fdc7b3ea8bfe889a4a347a021ff1383e3e50a86d0890dc00d009d65bf483de049d1d00eef39571d2e540e45fb134bd26008290bbbfe0cdd014b974b9967e951d0fc70e8be9d69b4a2557e57f74693b5563086999fcb510c355822d4dd3c91a5ac515f0863666af930652d7976f772008036ce887fa3213721b60b06c26c1ab39aa47fe859726b1174c9b75fdee9501bd9f2748292b996bf67897e5a0859eaeea251734f92e3d6f1a08df7df8c9a523bb2b00601e71ae81c14d12c3d974f60a0b4cfe20262be9c03e11cd5e66dd88076b3ec442376cb13120ad5d7a934acf1566e227f548c563343fe6ae1b9cd54cc68feb129220162d7c2d0529a92e1165013c960059732379338017d122258b776fc5721e6d8661697a84d00da1b4bce80d4e3822846f378424b2686f2582c04e67cab2238f7aec4ecf54400b5d84f11666ebb52834fa39d9508317f93ec5876eb8fff614546e43610c878c0eb004dcc1a90163b1f1a7c90e21dbc92d653ce526226a409b2f782f652833582e79c6fd839bdc2113b5e10ba6b82a52aca11e5ff2d78c7487f63468ae585818b3a8971a8d2bf6fa9cd070501f058a114a2f76d07ba022a4621fc766eaf4e989ed852a0c472382808d22cfc0749f9497d1a6ebd518da92fff9a5272c8a483484fc3a5ff631443e8538a0e3aeebf29102b9e2be9337947c82e4138bfe90562a3dcb2481b9d27dfcf4e385101bcebee05b57e233edd20a159683bcc25e6d1d4ca9e9f802600ee4bea134e23314f2546804f9ebfcaac5a2ed972e3a97523c606be6ecdc56f6d1a74224525ec3d9afcf073b623c930386c6766dee1af881ba66e0f0fb27a9798e916ea2727bb8237b019e0cf7f517b6c0e4778c2ac7156f3c25609448c605326c60552a569414e7d546229e5d9684ac9e85e8323596064f24690251c4f5057237bc5c916dccab9f870f2af49361130cae74faa7bf5c22208e18d2d649d6ec9da6f8f964f06bf3539369ca1843956136007cc2ec0c161309a3480a6332e36b1ec2fbe015a3e07352700640e1e0b8fb686431357bd57ebb76c38e55b090da5311cab6d70dc67eb466fc0cf7891302b01ebada3fd1fb188565469319b3bc1db360a6cb0ac60b81f7012a12d853faa1e1c9ac3d70e50a4b4ee2ee1fcc265ea920e99a7a71a884042eb0d2b896518398e879d91e2d114e6e14056d5ddb99de2e68e79236e6e77da938c67d0d7dc3b32fe802a0b8d9614f40ca9095eba232767c10095a25cb60f3ad377fe5bf131e263090ed7349489665fe67610c7963a132f883616d2b467ec38a2e4d5fa9f3bd2eed5f0c0e1c3975795c4981dc6a388dc413c6324094baa200ad08bbbf966c511c218a8559e890203613fabf5daca4eef166c1743c051337e290a85ee26287df26e37fa7ceef9709cacd8c2c9e7fff2c870bb6f917a325324799b54f3e43ba82e24ef0f961ae14bc5b5cd53e0e43afbe0b8b89d460d54aa912cd71b10f872f6574308a0cbe92c51f11a4c015d20791455583a422c7ce82b159bd555bd2da1128c343e3caefc4252121524600e7830d222f4df463e80e57fe6c60cbdcae426c0d8667baac1c25dd65cb29b8135463d88448a08346f4661ff701fd1e0a4d46c8b45a944016dccdb1d0b017ef64898f768bedd12a8d60ce158053040697b665cd8cfb44849304d9a6f60b4d0e3a7800fd435bc5d507edde908bee6dac061b3b00087fa3181c83db1c27d9371128b03d482f1ae76889e5e46b89722cc3fd9788495c59554191bdb3892be28d6635c0964ac5976c0ef935afa1434ea1da35f4267ab4653273fb2f8d878aa1bd646bd6928f730d88122cad0bcc7654f95a7fcc5c418d5349583c2798a6427fc349ab0f8d1a158da3206d01abe2761d34ed6c2b5c938a07ad86c0b8e007de303ce24b8450b6906e9b1a065ca23a81401bc3995b9246f0b9617ea9b33fad395f1470ed5327e0f9972a41f8f33269a6ecf1f97de5c9a6ca9ec25d3371297b7b29fd4665e52d95ed73b97102f0565da119745b904be4b2d0df0beb9d194f30cab1fe45364858ffe772047b3b312ce6df4c1399d0d9c089d264e4653ec2e069f4eb4aee1f4b6b0610271bc3991949e4519e40d2227012f132359b49dc6ef4f11b4bd9d17cc1221a5d184efb829e12275d8d013c5f1f8eb293cda7bb98a3e4956af1c4884fdd7b7458407ad886e1d7a5066fbbc3e41e92abdae66472144fb1d69c1264c7af436a5fafb564d189981a98266de076de312950947929c0abee641af867ed2f15b0592a68a072a86b3584ea3a5a3b27c2ceb534245d3bf7daed2a4f852f4960e7f9f08fe2551e6a826f7fa7ed3738f68f68ae3f030dad3483f721c7416f2e5e0c42da081032498a3228622bcf5e39c8a14f4ce57fb5b68901dec510d6b60c47887c90df5070c02715b733d2d3b302e34d141fe96662be46ec19e751bf4011a233cf340f80830d94abdd33b28cd00e83e9ef8a2e227df5b88e3b31454a9bba30d070140626d08a0b073b1eace4a8f8804e5ceb4d58de702fc20c4321e144add5e7bbf1f0d70e694ae66be0bbfab8725d3b2e55b9ce392c9dc5c52d3f809d3790db5d8a1732dd8888d65f1c72b3f846a59c8fd548c488c1a7623383e33cbe9d764054e244cd56b2fc974edcca31a4f8a95cbaa42ba20b1829310e194584e1f5f97c4c1ae7732a5a54454d73d45dfcb6ad28cef20fdb29678e61fae0ce7e22fc6ade6a2b60ae84edb33f9e621c467d2e6dc8781e74e5bba2d280f9627d83736fcff823fe38d84294056b2f63c864bc8155caaf846542239bc9339f2ba155f39ec22109e8571fb98816cc6cf0f8b7decc57bbf0e66404bb05efee6d88c46d016b7c55809927e6733df32129a9590969a2c95e088ce32914c6cbf36a615ce15e862ef598b5ac8cf52cdb664f8ff83902e4ee795bc74f49486d6f385828b3042cd173f43ab1d196474dfca206ef548a5a2fe12ab86507e404bb6e8913fe1d939b2bf5642c2a37c9153a7b679b936300de10779b7b415a2fade4ae829b9e4fbb240945f2bb09b4f86d0a5cbc37cbae7fa9f01c7fa1416a39f6c98503e92a879ff027934927e331390219fe59f72bb683df243faffd81b27ed51e6a8a83640b6b2b5082b0d605826f7b67cebcaa23b60aec7eaa74e606d7d2c6e4a6f8c71bd4675921b3198e6a86ff2af9ad5078e7f8a8ec86fbf4e5710dd409d1d9afc0e2ae8dc2cac4aa951f6b24d71f84ffbd96d32aace92d1fbcb68608e278b08196259173b95ca240a0a13ce5fbb409fdbb2fdac830fe6ba36acb9f09d013c3ff3f494aa55f022b65ec395d67ce6c2abaec4ac2c0804477084e7625b1bbb110ea2a50d6c48e0f0e42c90f3b1c34555c4f3ebd96f150ac23e3a626bd6800d0b01537fca7776b2e9c06f5d3a0b2867aa1c9061d3d1c3e716ce622547b4ff120c711a552c662334c49684fb36900c47be25ad5eabd79f4186a3edb3e90594d9a8a36d08578347e0f767139205f8098bf21120d6bfeb36b8e2a62300eeed5ca5957169b4b696a6adb5150e6a597135b5a27bf4189439ca42ddd092bb85b834a050a5c2d2fd6d90eab489afd55effce54ca12813b9eeb92f87773e29f100abcdb02ab1361e862e11f9d8f77f88cc3f58375d924011d7b70d1e02b02d50f70ffbeb866a4725a528cf999871c7904193d1c26614b0ed676fa575231e30542f300a20247d69389a8ccb9af22122bf71181b1f435d3d06c553a6a9618ac3886f5f218be61c753b8ba909360eae7060d594f7e00362ef4a824d0119469be0264df274621e0666b987a7808810a535acda9a7688751bca0dad2d145800766aead7cf22275f724c7585b5131e592ff82838c3dedfc0cdb422d7a28a15f90f6c274ef35cdfaa6a85f9a195ce80719ff5cf419252710c987ec7824d5444c5891d1f74c76ddff64b2750bdcda86467f8f2ec0c9d5f25b620b1655723687ae0d8cc5ad6b7db59f72faeb3bb447c9cc8bec999e774ec1a9c55549d152122f66d9954635f56788910d0cad50f40cab9728f5fc4c0804de3a091495db61f02e63994973dec30938f4fd645e1da62c46a3f45c10f94c1784553b9940b39eee33c19c9412f5c153baf06293903c763f33bb8fd314c84e696260b1fae0de0dcc91357e5a7b0819438b30704a265ca9890e03a1c96dcc53fd007f4073c02c7ffbeb62685df2bf4a1daa4fdc96251fedf3cfff8541172b1f7349c44647d83fb6e2d919db8781291ab12df68a3c48b2d97c17b1f49c68b4e2a9cfdb14a3f56fa44cbabb9ef6dee499ff63f4622eaa4b03883661e8aeb1ff5cf0e29060326d006ed491a1d775183102e6fd1a44162ea07b66614bbb8719e48b18c0c9f414b79b9050b2314ce0bb0b0ddba9d4b2225473171faa5fb20f0a23a5b668884c9fff200a023cd7a59a5f0e02816a2f8e5c1147452c95232f93deb50e9bf4c06963ae9f69c3352ee113ef91f103e81be46a3e94c42213bf17397cd64b44815df604588a9700698948fe15ad345f8ac7f053caaa191acef6a4a9da7d6e82d416206facd2cd9500b930a9ffbd7e893ddc626a6d9f3b3bff48c18d26d09f7d7d35d38a2bc9a02d689f56cf3ed2a77560373fc71ede451a8236fc5d021dfe0459233d127005d7359453b966ccdaef6a730e67f25cc529563270150ecd2aa014e5f61272fd39ac30afb750baef13bb812a4fa52ef4ba8e5703208917602e24bc25cccc3410969b7bc7c4140ff8df1996af952ba0a99cfb34d4a0b6a9727a5fa397a22f9c63eba3794b3c21f48425644f6248f34a7085cf58dbb42c116ad7dc9608c4c008a87cd1a5f2d41886e308cb5d9b08934ab8cba1a8113a993763f21f5a3f90919da24e5e43e7c8d29ab86ae2ad742f86493cc8f3a12213f68e0f4e2d57c67fd10454301e4da0e73dfebc8040f94a3a09c5745756f7f65f934501515612eccbd664dd3643eb537a1f51d655291a3f91465fc6eb2e95f2e4ecbf86c6da8b974ee44bc250d95288adc82b3ce73d9d25bd177cd7f9a136e249c851b26cbffb18e5c6748672e3eefa7245d0b859dc0116907c7a3f708592c63ff44c65330bf4f1d7822b38c5b128141f11717c293b1772bc4adb20793f41faf17294073718460dc04ea2c0cfb22763a0396a777af89153f11c363610c935411e42a479e1471b48883d144c69a957680d288678fcec0dc1a46fe200488cfc4bf03c88e28cb008159ab1ff42735df134813fb1bd67a42a880d01780884b8a1282c22a42abb1dd0084c2ee5e0b35529dc12554a76dd8ece596dd1cba5632f2d1f8fe8cd831c7189735b2457eeaa7dbd714ea348195341ed604015fff7e60ee3684bfff1dec5aa86b745fb01c4d3b53d4d62e9c19e043b72af800bfc54a09b59bc37c41e6c3d325bd9eb136033a177183c63ae290427712d3d9553ea582a5342674b07b7fcb6bffb89e90131d9f329e46dc6cc15bb604e6435c57764d2664d5b3fef1687a0f7d3231134c9b640750a4c6a4ef95cd79b3c4d974e70329691952e0c16b4a10345bae8516edbbd02ebf8fb7a4cfa5159f1345885e05de60a5e54629a78b4ee2ad9a970b42fd76cfb0f38d315e4ade66073e69658ffdd6452485807fa392d88e84de565838b6455f15c2a390a9a8378149bde175bb708082c867fa6966f53606efa30d1e081e3986440573825dc26b74825ac15d8e3dba6cb3f27f032d0265b97d34ea279aca5c4e8b4520cbb9ce218919b6c0bc26c461fcc1b1276a9fc82d299e4b0a4b9f0b2132dd80e0b80109bd04b5e0b577937fa9c5d2943bca10408ed0dd8f1654038af40edb46d63894bee27b970881d219b41a18c180185b44d9931361b1e13fdac7eaef8cdc46a28a12ec75dfa0e0a66d8ca489dc4360273cdecc65fc4872b1aaea15fb3b9000bd6443959fa0ffece75fbd307118ff64d9e9ee07ea276f8d67f9fdfbc36ef37a904ede830463392bd130311a3b9382affe0532868a68bb0d902b20b7184c63524eb99b2c6c0048183d9ebff2764e2958d66802ca4c1ae5be16e9affb3d539170c29d0e67d407b31817c6a787fd3458e0d20d95586f4715691a01a25bfa40a783459f7c495b9d1939704571a6096145fb337d2d4a6610defa6eeee942653379faa6063f0e1427b5bf7b269ab777391805dd3926fcda02db018d2f3d6d27ec12414ba429ac6fbade4a28a6527cf892e9186292643b54f17bdd284ad18f21ad57db187467894edacb5c384c516dcea03e00e96ab1418a6f9c87f389e4be8f7c1116130ea7b88f9a66346ec1c5cb72cf0c456f3677d74d6d00858da6aa14abaf6e3b84434775bc74a8e36dac599ebf1736574c3cbf5d7dde7146f9870fff21080fe92fc6b1802b38444ccc1e363dea2427b10db4c246bcd9569a75a3d47ef5d9df8b4b60f903bc4de7a808a16239e9f25305647adcf5061727d8c2b598607d5a48401f5b0922ce0ae0c559cba8c648df5501cfbc0fd39e7cfb9a84491da0a06084b613fc4e71de6695f4f36c0f495470d5851586c80fa1451845ebde0d78c5075845536ce7a60f73c22008847c65df2148cd11602c73dca7766041086ca671c1dcf3476e2d2872f2b472185e9c0845a7d73a85cc8ebc6f8ad439b73f20cc5a7e366452f0d026e46bd7b41657a9f9756409d12a30712c3f0430d0c930fcd040652f4ced27bf48aa98048b9538edb7064faa771059c22c6c6f43f5a0b7a77744fbcb9c4069cc54d1e808aec7646e18611c5b3c209458de192fc7ead2038e78702cfaddf99ef0860480326d3b17fb2f734a948152919f5b32733b2be112d04a82ab8dd28d0587184e8d8ca913df25714ac4e5b15b3ba0b8bf3b3303e57c2417ca6a37f43df24aa80582a6fbcc73ba05ac2d8cea71be866b407d83a8deee8898c9a9136ead6b55fa709750ad491196d5b8be23133ee4f1f33c840ae8a9f3884f8b45bdd0d22dbfea8425b3d37fd3f536dcec52914f7fd8e61e480b48772a055c7d3ecbd2b54ff3b7321edfeca480b6ae96926068c059ae8bf65e58127728f858df57a52eb77348989dc2bc18eaba7df20cd121475129e7cb5d6e43a4015c8f4b253269a9216deabc7c1e660c6111ee264efde800d514c412489d33e505cc11d5baf1437d337b48f435d5f34813bfcb02d49f080602868957697bfed6b46b2f41732a3212e40a18331ec5164a0169f93ca366839d0ae420a9e461ee4cb509bb486d527fff08375458d413e8b6c7d926f232cbd27bff53b7923a94595af1b98f98d35c8ddca2250d10816295ab7d73dd65fdbd69cb4341533fb205159d7d7324060b4478f9023a72b1c9cd4d2e277e0c20225e93dfaa34760a8d7e437ec68c8decb623a4d2fbd95d00afd63e2be1c168bbb01b82ff46c570af191611d49d38e90753fd888ec91ecdb446c3000f2e72252aaba30318b7590d7b9dec51762c7b53b608ccb8f34e628a0335eb7e13dd62d1c28ee6343fbfb11e422d2b355748be93927f88a0add8c9da3615c0abcfbc61fcbd4f449053675f1fc1a65301e84692077f706ed74cabd3cae412d2355bb8840d63433ee7417254ddf7db45bbf732b58c30f61a7f08397688f28a0fa9c4f1b50651dc0bfb72c7f4917233709d830c3e688fad11827c6968fe619b42c3d5b33d5d3340d7bd8c7160f52c546f0f06133b0bf247b6793ea36e18e03160852b0911ae1dbe8eee575841afdebd08abc4841437a6d55a8f9dbbe9810284783f5660fe9eab7494d6a33d3ddb00905a46111a9636fc9a3d88ba603e4106d80f1cb79d01aceae70e124b01cd05b76b276238604d1a9fa1115f8b95bd487b171ca336b31bb68b48e60b58ff4d3ae3f2ab14f9da350c11ef27875998c5fdf8e63da587d838e9c899d853c96f1543e518903bc214449f64eb59a4168eefb9b174591151526ff8faeee7870848311fd1596b265c5a2dfc2b831a0b157ebbcf044c8452f819bd9c7323e5e2b2c19f0ecfe6f3bb831c7da6b40dd045dc99c6c97a5556ac5c4b8bb999d6b7038517acf3000609261ac1dec2162cb018c235f8cb597b5c5333d12897d8e73122f3aa5c42ee0295ff1676615e609cf25a4efcdfa9c9f1f2078d6e584e06c96d26d50af0bf53d8c5a44b7e5d48098623ac52b0397dd10fbbd35f2bba57b73ab91e9fc48e0497e98b197338e1f7b4ce4ddad7e5df780b11649344a6d3f31678592169635eda018dd8f37cd01416719a9771b29f4563d805ef66e3b17275a883082a20f5209b77a81ca6a0dc133766e018c5ff256f55ecd5494dba3d07944a3062faa572ba131e9baad8409d25faf6a34d6823ba47adc7635a75169d9e5edcbad04c3cb9889918faaafe8fff7ea0db4b138d0d4e843007e2496711bb3b39db5935bd8a11cf274db9590e96d8f27e79637334c27e588a899eabc013a1412c55cd636ec59368aa7d2c8aca0bf7e688e575db236dc481f9f1c4d922d667640d6ad9e8ec449129d33ab65ccdc202125f73b6133dc82b55ac8ebe126f906faed1043205c06a359bab46f81b1616c28343cee12dd3d000846a97391d2d284e3e35fa4c13bc02f330131497dfa7e027857806836e79f13fe4688f08b8cb4a48bd82e5bb05a08deb309787e1d000d7a96525c88a55bcb07413cf2d99a2595e101c10865efd5479e51f3fa6eda1d2bbd65dd43e9cc4c38fcdfcb017397fb9aac1709f122041e5dc10b1c1f9dc5d83dceecc81177e38db030153a4979e082877b1b28a9d539614f314f945b420c52e5380129b008934ccd18718336469a9d64ec483ac11f1fb309f72ef9b8398b37b4dac6b4fcc89b590307cba838bf2de34a9db0ecb7bb5ce1f9dd0aed40be97a7c49a808174db309a7a1691a2f7d7fcc44d5d8f63ab6494389f197de0517c8ff387692c11ae62f934d4f7b4b82c9e6472100246885b8117caf66f572146cbd66a5e68bdd813851ccf12a64cca7a555273937ab826dba1970318590471f72bd9968a0245526cd2cd6bb0c72a090e0d1556dc972034a438fbf949816751c64bb02e66a84fec30685ae809eedab291db3b3b48d7416de00712b65f11f36973c932a6c1f50c3b28daa9da842559fe51585203e8abf4b2195d115a15bca84c04b0aebacfe3355f615597302a86f2d30cb0864901684a55a3a78f591148c4594172a0aed8b9bf135df43fb573c0e797322a591b34409b8bba37c7bd93795ac522e71c9cbb5c220ae6954ee3097d47013d6c5f9eada7fabf7bf42f90a7594d27ce036d8dd62ce09f83f4557e3c6cbbd539bd8b9a37144dc97862579349857bf50283597ddcd5f28b6600ec953bca44ca08318878891d1effb0d4c892f0b0bba6dc8e794bbd3c1f41bdc6067f075101b17792040703bea8cac37967c2ec2f76fbc8082ed227e198a3692d98364cded0708771198c30caf73e628561172ef78d7ae7901a8eec97f4c532054d232928fa311f108924d1d568a3d0d9904a71752d5ed1945b39435f013bb2e393e641afed933208f6c16517c58cf1b55bdd1a5eee06c938471cd3dd9be2f981e9a4cd71a5d938dbbbbcd023e5296f48cd9c2f31d3ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
