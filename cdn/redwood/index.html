<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"411ec3326e27ecec7c623aa5610067e70804d87a93a128a77364ab01e0ac605f2c69f0194887e01167176f49c6081874b78d096ce9140c42eb880abba3d433534e13d9bcc6c45eabc3498ae29d15b1e70707214eb0648cf53374884eb3958c7941b906ad2a1dbfd9bf0c7859a284052131fbc762ecfb649c55ec496033637c1d1e0c63e92e0212f80fdc511db837340bdbfcbb5653ef8b4e2c942209c353c85223344d27c295323f6d8be0868375e297ca8f0a0a2e22fa1bebb9072466001c0a515eee1220c7cca2c6c879e7430b7c1e79667d516c9a402151ed758853b07cff8b049f8981de7a863c0378987039e92cac60ebd8b25a4fa55815f72c327c1c375661e7af03fdea52c462343cd4245ee7414ee95ce011879c4223bb187408d49b32a5017745974a5d5ecc9c98360a3b0fd8775c214aebf37fbe5ae0d7e05bc1fbb6761b3d8a611365e34180cb1ca96861de0ebaec8b853d852a99482a2804a94b52d1342dbd4df3441b2bb9509779acd7375ddd5365c8eec94cfa83ac40888e0d2fc7c9370253f5f168ceb5e72fc971a40ef6790073093e6467e208595d89c2aeecbc9f84ac62736542fb28013506d812aa7892e84d42078eff81a74a99bb729ef86128a345a92e9fc2f87a457c93ab94f9b1bbaf2c7b097a345e00e575904fb2986584da3764719df5c9448bb6dc26808f17abad5957579f2f5de65d8739683a43572fcb7ee89d7495fa0f7f65f6cb787cc945b4ac097e7841227744e10facabbcd92c92374179272dd27bec71cc92fcc6f714465645f9f51f30cd6134a0fcdc049c6537252d1ba5de46629a5181a457ba090a2814a692ee119b6e55e353efcb775c88f865e3e31d3557d19cc4c87371cdeba27a27ad3fa517c576ff1e8658f93d88cf9399ce5d06d88c49f7c17f3e3f6cd4fa928fce430300e4dc298e277d68b6672e87df89a88e459894b78723aebed0a43a68c74e16407d78dededbd8c9a06149d4d91fe59b2b1744a66902d4ccfbc4adfb2636a183689d4e7edd221c0e9f1e891210a3150fd9c5cd1d275cc0d0b9ccbc6b4c9a8a061cd8b5c8ef65f9ef40d1e950ac35cfba88fa0955535b5303343d78611f38840092202f57e72de3c087de451d6cc94784e80f6e399c7f206fd22e0c7d8f1eb35debcbbeb41d123cdbf123b00c5e8d2e77d809adbbec699a80bae1aaa2229c6acf6981e2e2a75ad1a3418d8db05f5eeac995b6466389a7919a37f8aa8d9819a2e6c69b61163bbe10d23db95ba8bec06e407b63f337cdd095d95649b17bc79586c5117a00b0307a8a847125443a366b571bfd4ce51a960826f541ce5a1910f35893d8fdebff662bb828c1e8fb860113121b397f87fb19039bd8bf3abc0c398aabef14dcd10671bb32402d52a2371ec9221725b871ec237f61018d83c074e98df07e829983e2839f02b92900483b11b8274ce52ac4a07b5bc6a8a5d94b96a7dc1e49af79ac3ae8698e7de611786b25aae51234da597fd8de19fccb444cb0c90ba1310445768880f710fc8a25df1def5a00222e4323f0746483632f9ae664533e22785161f578b20012dadb378cbe3037286154c975b32a28fb4f8bd9cd579f1ee68917f559a7cef1211e746ec88fa64d8f0c49a2bfcafbce86319b8880ddf4c710ae5b41e25ca00f24cbb6249b0b5b053cd726cdfea558301461a983d064a48d1ccd24fd6195eb4615e4c80f0d8ee2c8f0480743cf4e0b4d8dcf77434253ff776c801af76dcace1f89f95f07fb8fdee10a343b5662910a32440bef7259f266e1a1593232cacb3d96b15847abbde02671cf113496eab603380523a4b5dcd44a4c83fa0412de1ed7d48f241617a8f64b880d7963aab6f37edea887055d610f6703249da85fc4628d66763f6c19ba6a10ab04b71b527e1abb9d7a7b0fdd37ca4aeb76a527f42f01cff2fdb8166b0b0216b163d3754a1ebf26fcbae7d5bdef10a8b9a3174c072ef8ec7f189caa887abf532998511fca238ceda74d934183550b67a4eb1149536e5e1c2d090ba573ac388928ed9fd17cc8b127f0973ada75c0fe17cbd09ba3e7829d584d3aba224ba1689b0d66669cefe2b562d8b41a26addcc16b971a3a5ec5158e2440af508f537e87df2d4f4efb6e50facf1a985d8c5de4dbaff6570f63c62c4ee74c83b07993b3a32a42e140b642487682b22ce24e75d6c08f9c43db808827abb48bfdafd83497cdf0b0b7daacf500f6881027b103de17b43a9e03558702481245bb05d8e51c7a6e1f6f2e98e7be73fea3ee118d908482dc66bc1b5beb05e8fc8a7fc405a0620852955fcea1a0339e5ff4073d27da42f06cf0a08e9f1de0e0ad91ffd2335a3fd52b4f0c8d8bdb4927eaa055f54b3200bd7b0727b2afc0378589af9a2324e4109bac0bff14a11427d80622ad66bf955c73987602fb054c28ddfccb7a18402ebaf46db032dfd048ac2934611446a58b0dd0e251ea22389ac376732c38de0c23f9f2d9b2b6b9e672210d046d883752cdcf6049685381ccdda19b18dc7aa9664632a60b5fe5205d45ebab065ff700aa2f4711d04c11c251ac0fbab33054721e1241b61e925b5b163cb84fc72ba4dc089c37ea51e8f0ac5e154091512312036b881ba6006ffe91945cd0944009d36cf42de0840cc7e8297bd74f0f978f9b9cf60f221f7b582b6e58c290166a5689183b7319ed02ce0fddfa1f26aae82fcd8086fd0fa81fdd010dde4411f7d2f8ff826e783d1c173aabc4e6fff3fcabfaccc05455612de93e1c51e331230f03742995e67f582029a7e5f3bdeb8cc22c4f7e69e1299abaa9e1ce41c464a1ecb1d62121598539264dbf19e3cc11b1a67cbc968f3b24fa14417ce53c135274621d3aeab618c4e4972bd0ce6f77a8e58ada442e35a5b9c20d514f152ae32ef6a7ccad24dfb0b3c2a5ece433dfcbf98a71952c58c6c2eea5347795f4cc42cf970e528948f6f5f839b09f6cf580e23c4c69fc79808bb65692320381cbfa2055e05148b72ade01193e977f5dd38f8645956cfcc1e07535e86badcafa286dfc86e16dbb3101f2f4901b6130c556841eaee00b24eacd6ea29e1ad09828358e54b407640d9f0d891e7d53c2aea5523b61e728c1b531b1ee26dd18e71bfc4b4897a6195698182b82e76863d0786cd24b04b93903958a2223c25ac103541faf4d82edaffbaf95cad3334b6acf807c27b94ded26005dd231f48afd56da2c59a2c00812aa65f5430d7386726e509f767659832e686e3247d7261b0f68d07c2446a01af28b9a11da110c6736f6606b72b263f7ec4ba55f71e7a13c8942c1d1e886ce4fbc307b9beaed5398ce86f8711b49b5370a16cabe78afacc06cdc1c415f3376cf71f0d5c9f3744b10a7e7afe3d3e266005eba65795bba4aa4ba5f013a2f768fa620edfe35f821bac44eb6149bb9b343e371716aab8b58e4a127aa103d3acc231c1ff22662387f6f046ab9f46c89d913fb6b91952b7a080e5d41a00c586108fc9c873152ec12bcbf6d4ed02608313541deb43ab7f0286c9e4e003b96a723e1a434ad3700bdd28c0bbae269eb0fb56f5710c00778b2373341374dbf1d042e4138ac4a3d6ec2e9333c644fedc567dba37ef17c061773d59c3c81d6140730c4a6c107a12f52c9903722cf5f7df168acc6f254bd45c119ee34389670545910a7aa99f6a5737ab0e211365dc135dfed9943cbe7998b1f57f53ac94b2a091dc35be8c9e7a47208ecb8c0fe385d3467a9b22823ae0a53c95b27d649e89ca8852f621b8c9e6fc6b47c9b549c95ac3396c9f1582b9c9aa339cd4307d9d40d593048047a39aad75a77d3a9d1057e454131f39471459843626fa0a812a5797320b3fc2aa769077f1d3d153452dfec36dad81e06f6c7e4db598e788fca2430706c4154ff48d3e91fec2edef6a46d067894cb5925a5a14ed02d83755d21d8879a45e99032acedadbe7bccfde61d81e48ddaa34394296893f8b425d33f47f69abb7196051612153bc68b4abcd9a4afaadf58966ced321bffe3c7f10b75e97be14226bd9d3d4eed7b1c0099aa69129e20dbfc539501c2d4f0bc60c941248a0fbc54f5c7c72a7445ea175efb0b575b0e5db8d33747aac2ac6284f3b728469f06fe63664cb9c8eb00bce7c131c1d706112e2797c0a889c81a9f0bc569af26910a2f6f4b37a179ab764575d447d6aae9351c1e17fe58dfa564f9019b65dec57a5145d363c24e30b9c8fa861d1c7ed3548e7aa4de6705b4bc250839b70d4ae5b2bfa6f97a58c21b60fec491b6297cff3584d88ffcfdcd3ba99c583179fd16b79265d306fb6f59056b12b138bb4db11445754d481d5b389f8b2471666f67b67d948283d382d88c1a0ab61bcb44ca19d83dc6568339b3ec87704fbeda5aadeb3af68f81736fc0c6637ab358010c3f7e7f18821b965fefee8bcb517be3842234871a48953b3bca516c7c8382aea827032029b3cecc9d250ef393206e3ad80df8a54880e28579f4869fbafbf8d2b7bafa408c7921cc6986ffd82d7884c90b3424376def7391c8f77b010b41d7bc31567dab95d34ec6159a91fc7b501771042844f3131392afc80493bf40e9dbd026c07e35107c5b0126aeae04a33107eba9afa307b30a11b2d77c044575c8bf13460e844ebf404e117a46788ee415732c2a7634363fa209caf4defc01c19d66b2fdcac38da67d926eece5308bdabf19fe42d0d27fe453342da0772d0764be4a183389b86fc771bfd387b10ae0239009dbf2966b251adfc24b78666bc83c72050c874a23c3d956d19c513aab6bf99f2f3e9d3f108d900bcd5a830cde919be05f517c1d49ac68a85dc676a689c87d9a730fc8b36876525b313a12427f98838478cd50674e4b710afb78e4e4bb4c98f338a36b8d5a7ac7ce123240a5cced2ec0980099cd6dadca2b796e887f92c1df1eb58a1df59c3148b422cf2697cfa25d922d9cc636f605469dda60f77bac6af8a6d0d1b3cd39c79b747bb25470f887cbb6d9a0f0bb02c12617680922f83394308bf316e121f6c474bc7783748eb9c0e060f7a58c89d60bc4e2cc9fea68198757f83cf0c58ba1ace2cccc3cf853b99a36040beb53f65504dc7a0206f9be1925f1f9980962f1ac90a099fa77d1e265777a3c1b017818a8c72a989fcc2d77f996d08d50edab3c22e8fe40ff6282fd83be181f73c2dd343b800bec927c3be751812af17bd0a71790a6ecaa789952d46035f9d1988cd9cf090786bd6c9c0c244a7291e47f6c5a9b4dfd19605636d9c232babff86295e754211182ad667078f20dbb8b7c119875fb31ec897c11afd6738e193cf38f20325cbd3ad036410dafcd2312d935221487f5401ce508c2ed5f5eda2b2a2f17e2101cb875eb175adf28f95d08725aa74a7dcfc345a3c79a345ceacd9be38804a717d731ccacfb33b421a70bff2025bec3138f1e760bc11cd4b39d31e5eb411e211ac8b441a19b4f2ae3d53968a41ef4365507f40f5788fab824b5608e915a30668f458304f0b50fecf9b1eaa9eef33fb5fb18859866922e8fe57cd70a5cdb1fdbfde8b7ebbf1f7966ccdef854b799782f82b1b1d9b5667b4f89ed50323018f191daf1ee7a5845cf88e18e128bf4c3a3819d9e502814392c362e0fff624d9a59bf3af85e6a6543f00dbd8d5f3765d451540b189368299b986bfb6b0d71ffc9e96e3c82419629e4e542e76910d7482c674dea726adaddbea294af6ba6e8e3bc36453a4306384ab6d7d3b902d23254664d0aa9530a25b0afc00c87b431ccd069ac9dc7061c3c0d445e76b37718ac7b48de404aadf31d6fea81fa8890f596717db1ba8e68dff2a85bd1c941776f9991fbfc3cf0038eddfa790e853bfd1dedb7cb24ccfed48aefebe217f1ebb192db82c45851f05cd795d9b1fedce2cfcd9d67fbd833b4819b17ad61af7ecfe779b988afb1533110a01be77cc7dfaba6f04ed289dfbd665eddeacd69b623d0c104d3ac52c28b7429e249f49655af52c39cdda359d8750504b46b859f278f78dd4149636167d2165616801097a324706a1b08325ac43621161b8978b134d70cf13995dd484cbf83d185fa38806253a368c64e73a21d223f478733abab795df896ffe88f69f4645c8ca590b35bccae1b7ac8d59ed4a5446feb5e5e634b37b72e3171dffed74544d005a554e0892496102c35d1a183a0629c5de5b07869b1185e8efc0090152158bcd146c3511ce5aca839b16331ecd73df221d58d20a83464bcfb4d20fb9a364469f6ac6adff8cc9bec40330e584ce79865f0a76a750627548bd037c073fc5fcfbe762d4cc690f02ac48d5d951364bd4f7008be642ef0aa19b50f11c0a53832b3317a79dfb2c91539df63fcfda30e119883cfaaab20660d25be173b0192228e454c3b2002cbbde84e036a3eb987ad042e57eef90929b702e2520f8576428a9a9f68f3674af81630dc3bae2838c4086901f8b51268eef415edbce4e91d304d03bfb71d554ac711251510acbd71f030f9c7a9f44defaaaae0bfe2e5a7ec825391feda6581ac72f4990c7b8f8c282cfa5c53742d943ab7e2473debe3c239462b32529862766162dfa59627dfe0a069f985ee0b6dd7f0962ae1a406ed5b6b0a375a1ad5ebd7d0c9dafea81609f3d46a81f86752389c46cd461f169269a943cbb86d4c4ae4acf36734ed7a575232fe5a848598aef44f26dd3d387b7f59246f5421c58fd5844970e1ef831c5b72eb1f043aebcf3e2bc9a49448598e5721e4bb226d04ae0e551263392f347b409f4938946c434e5ada824dda5525a01828b36f1803549f1db42a6624f8a5ef60711f9ed567c6bf477499173b086d9b54471fd748a9d94cc55ab72b88be9ec2ebfe224134c559a1f02a3dc603c69e57bab1a1505777b4dd18624b5e3bceaccd3efdb1523b914ee012e0a6fa2eb85a527c9ceb1efdc71a238d711035ab1fb1bfafec529102766cf3b8eb95330dd15c69ea19a91f28f71bcf9fde65021ec5db68d3fc34c183638ef90621317625721dc9b16466709fb12ef7c9229eb341e5c677aee6395c3c094efee4c6bd16eb061723e25b2f8b32117334c99714fcc8d69b7133d39424501a18eca5aa1391fd866e603d775090c7039c5bcd8cf77492160b03036f0c14c7ba432e4f4f91678478f2d2679981be083ac4f51cc7208b9cbf8901ca8b19b768d0d6264871e4ab407a18a5ce890ed7df038f9a4529f210aa79fb743717bb04bfce29676144d6c5c3ba2157295c48909c9ea8f0f0592d35aec2ae1233b5941c3e58005e7c483b488e12390d1684cd9d6e3633b0e20d2c98adfe36c4bb690581c965ea33351b55beb771f8a226fe3ed102ac087100222693f42117787296515a58115efc6f0d9154e5ab15f8c7412a7b53050d702782847b0c92e54b49a98793840394af2ea291fee60b1c1c95bedb339dbddf1a02983f66d8cb9926a7a02e91ec8a6be5400abd39fa088e0283d90bb98ad5933d325f0158f18cef5c73d077224d7e9c17bdd75bce0a0f5f9052977762551518f99764b392a88019b9e2e77df84369585dfe509a95a6cc4622a30ee5e86518070aaa8bb3d3562275e2e21db4470583aed1daddbc001d6510b7f83c88fb02e5ef803d505cbc5dee486c3f102d4a07cc0f5230fc63760123906d19dde452ac348e6e79040fa330339e551485f48954d0c9152e65b33a44e68fb0310fd9a86ab3b3ca9b78b1dfb6ef91c7116a3d6206579fe9f54f912c5857f451310933c5d0a24528ac8643c5b7012a3a4c2387e970c815a7cef21833e3e97f01ebd5768206eadd5de86ff0b99a0956044138a2a5dc9f3a1075b8223d0465f7148df73bf2bb9f3ebcd2eb38199fb6f5855a35052ec73181999edd11ba9099c7b8195d22fd7efcbdafeaa58066902a482d1bf68c7d8c57ce68b8f0d21f791b84de2031c0473de9a6da3d8ed3e23ab3c491f0a9588030209c03d0262b431912b91c23b32728cbb82e140af5a53791023399255b58b13cae29e32983b6e96d7f728209a6832613d3c273bb17f979ad9d4303c425dc84818299ee56e68a08e94a8651ee164661a17834b15fc7f5c3b5b53fd11dc9ba49148d324bc05a53893afe1feb6c15a3acbd7442072907448752cd48256f6ff1e35f2e092465b50cacc507cc3fa3dc7e2fe177ef43c2eb9355c01a82804a800762e498673032b58a4e7a0ef990cc73d88ab19b8809ae33a81cb0c0c6df2f089fb2c3b84707daf7c4a7b468ab969d96628b47ef0d32b495488c26baab320faec7e1220ea9aa9f7edbb228c1e7c47859b3ef56c359e85323d2eb58a6bd444b7bc4d46b212f78eb9eca28c0552db6523ecd6d4aabc5cf2f0c37effa66a95291aa67ccfb0f7e2e8f22a572f87de4cea81816da727997c26d3604ae145ec2678ab295bab3b2206f9c226c2762e589a236523034226b2e77a2198e2e855d096019ef9d84793478f0ee30fafdac0fe28e42341a69012333295fd775df9a84d55b0537d2c4c4e006f0eefc07c6a2dd9ccfcf57cc76429c78cbc7ef7fc258a87faaf427c8c9817348789247ddc5f126b90a3cab5d7164529ce3eb242eb13db1aed67d357bcfaf9133cf26cd86bf9a06ec5c52fd0052ccba79c200168e476fda8258f8ccdd8cec7fad0d1a019a6776dea8f28859ffb439af283f2cbd8569beb84b9f7bee5ae2449a6f94b32fc96fd03c8806f4be023c95e3d3935f25fb7dcb5113aa5139af761e34dc1b4ab49bc1e2a4eed84ab4b2767ec162dac1de1a26842b017057fa07d52e0edea5c11bd34d2a6058bf5589302726f0f65135d2171ae63b47c1376972258530069b836c4f126e211d36d65dd29e92808187a27d4e75dd611550f170d86fb40a0c1d6d4c85b1b5cb984a55b1f70705ce686846771b4c45efb7671a99b93e2f277776f52bcf338e93f148bb1890989abfc87537327d888ca5f6513f34ac452ae069ce8fb142be838a67876fe42ba5e131cb44ec5bff6954d02f23dd74dc1ef718b278232ad2ff0557a85618a6ba82dcbf73269433f1fc77bc3e99ec9f8b3377faa7764b15cdb5c8a3d772013f947f69725d2c2c35925f0ba7e84d1961ac1b9f9f6736599812d80dedaf763207cd434061ac0accf3d76eac0c96332b61a3a1db898c20eeef32c6cd221053ebd6ccc6e2c79da58e27e64ec2f1fb6fd8f2fce8a08ef0f8c883a2a9bcff1a69c461546bdb9d1df42501b5a5cc7676cd9dfa4a7318843daaaa0bcb36c20a6d3d0ecd1759772b8cadbc57976e4f88749ab03e6fc5e98a931ee2f0b895a82779765ce48cb4a1fef02ab4c50f86c4333befd38ebdc2021c8d1b16f114ecb24f2b33a17850d58ff8d08b196977fc3acef5a71285f166023554fdb7c34879c5e3f6e497d93c31a32cef47bc188d1d2a6d2a113976420d6a600e8a2cfc18953df2427216f6f9c092abaf585388c339cf3671665810f155e5385448e7db2ca102f07994341f87e2c92373ab3d2a2b4289dc043e0ba5cca4e38e9d888bb9b3df650b8829fa1ab441beae39a6a689aa7125317aeebcaa161b4988af46752ec697479ebcafac3daa6b61164527b80ebfa18a291cf5cc2182a2dc9970a8017d5a37df0e1ee674c53015a7d547b08566c9faaf04e16816bf34313bc626fe98ed0c4fddf7962b1e3a9bd0e70116fe715de93e13f9621675b7a1a1bb898eb095154b91664bdcf070298ae962716e5d79d71f84cf03baa26d568415e4673879e98278214b8867c5c2e4164a68e2c4f3244aaf3e74656b8d7bae54eb5c0f981af9d80d3ae35c8f040a2b5a494f467b42ff9d2247993ba6909b925119d71742581cfc50cc5b4398b08e4fc10f228e16b885d9156082b069bd0d75aeee28c06a4c1a890ae0e35564fff1b10e39d38a1901c9c3849d0e38d4e0b0f8b7dd787fe686fbc67f935be0a9fabf9a3b415af73294344efad34d2f567cf1336dcd0bf701d30f4f6f364eec1251647e8fe8739e530f1ed05e10742f4a22cc9d7cd3e743bd644e673af82ec5db088d682b533dee3aea2ea3a2fef60757f77796d61bd03e7a85132a340e856c650e58031b0dffd70084791ad29f04e882cf959caf17b32c8db5a3b5c0e6914580dfbd2057ad0105e18fbbda04a6b66f3c80ea01f9f02e27290cd0c89f4812843cc4f73653130e8064a5d8bd10968414039bb613c708005994162c11589fc85d8d3d86d83d61a0c8c44c3395dca3f070ef62482208ea4b192c18fb2d37e6896b27760847f90cb815a89e3c4843c2aee44b8b3c88c90299942ced53a3ee0980fa63247c4e8042b395e5f033aa30d28b4a1d5b00102c17e0c8ff65dbd888fa348b948e56a4bb052ef48ec4fab032b4c787a37871853398b9a38f218f0b0b016c0625bb9f1227661f54e7004900460e19afccff96985123e9f15d38689c0faa8f73d30c2e4cddd126f3cd7ad3e1fe75edad1df4ba3c1b1a2192b69b4696c04145d6c865f5f5356a48fc586da3f2e2beaa1aead90b458f13b5ab81f854f5c8948dfa4b117b88e4da294d7d462049a029f9d02bd722d5ddae29d74ef69d22a650583c560b1f64515d77a46466c91f8bf9917a7a0e73855afcc7e0683dd80440c90906e8a8f7b1117b0b3f3b4c6be830cd8e56c4caf35ddfd40f50eb8855aee17dc0ec3f420cf3692776b83377f3bf717e852bdf002a659d1cfce34762ef4ed25d5ef680169835f36dae4d357ca4fa2f65773ba4cf14252514ff4b32c6a95346b332fbdff40f81da75aacee0ef6e49dea043dfe81aea0e2565997d0bc35910eddf869d9dee0a6b532b4d20053f35910c2b1637f49784a7c8723ac6087841e23a786cbc16cd4ac43c265282c37b61c639d1ceff3bfd583cac5f4bb80d19adb6eced7750c5aa862008a4c62810b2dca0b6e302a4ba1866ee9b339c21f1f5ea177841b91ee24aa069fa217480cf76a4f0b9d951dfe89c28dc6c3aa094b4892fe6dd71394a5f2dfaed16f2a17bc8f52bf9f0e6106e23412d50f7a7fceba41d7cc7293fefc67b5e4c53f03a9fa4f1ea47b3d2185763e1323b9ad9a7a04015f08966a742c5715d60553f1ac3d1ebbe18d19147eb16a1bacfad311f1a4bd7b9ae34dec38f121d59914e0bb56babc4f80f2c6aacfa5dd6e83192a082fd56eb75a9b4e5e6c732a503efa337998ef6f0b6df7b51072a7e8787c2ef3e325e12919d0fbfc50b1ca68af7865fb5951b55f71621bdb892c2074719aa18d90d3c76905e98200a05aced6da2360351e788a5806ea14f727290e9e105c65fbfaeec123d3f1b4f39f6e47179f2b5141523fa6d2b373abd0fcb119d67a198b954ec1f0eabee0a6175351f008272d9fe15e117e95aa319917fc2d1d8b8a314f86073028fbbae014c55ca22da0c01bbadb839a88c38bcb903fc2a290f517ead1eb280b3bc6e521dece922167741d78a62ef276dacd70bf4ed1f32e3c64de69af08cef2938adb1833397da295be2311754d268de0661efbb05c13d5a2fe74be37112d5a91dcbb5a2c4b8f50fd23e0e3c9d7e942e23bfd0cabf435680c488d34075318a30c0260122fa1cb421f4456a596136d607f86f779bcba10ed79346e108572e79195abf7f6efbd82190298a901cbf7318149c9b77ff5e9e439a944b96d96d6fa3569124636fecd2c4025ca14f4122ef85fd0686bc7b89d55a1da9522d51cbc8e472e65561d027a55ea49a403cb40b43e2b74e56b14511b87999bb8a4415132e055f71d8868b8f43d3111bd0a31ffe2bd042f19091ba3dc9e2cf26e11c321bfbdafb4525724ec4beb5a99d69085b13b414a9bac315608135f88343047a0ad8ba682710b554447e734beaac0297185165f3d33d74f16d2ab57bd7ad829360e11b7213dbb6a078a95610a156e406a8a482d438d500ed7ee1ec421f6836dd75e3042791c55c38c79a1b7cc83792a656c3ce9deeaf185d192bbc0ba72586b03b805e97eb2704d88ebca7b47b301208e8f026ca168fc5b2752d3d306076ae7c417d7d494e1e5dbcfd86d6b9fa09ee74d10e49f0775b7b385d49bc80ad8741ed0e9a8b3e5e31e82d1f2b5a2d36fb3399eadd03aeeb4d2a1374a37f8d8ddfef782b016301713a775043e73e93df8f27b493f09dab7b5fb77d0ce122c38b92898cfecfb26f9472c1ce6161a94d65bb27eeace0e43d60a8a1c2a775349e4276f3a2f25fcff35b81c44806df9a2320a71a8019a08dd33c18414a6e3daee67132ddfdf01f3006b0c5e9c4466f878f91f42b2c478a731ae33281caf690f9928680ef4a74d73221366d9f982f7014251ce6c936d75d9bc74d4ef8f55b394673cff2f7b97c2158edf4b80add3f1f934ff0d372c775b5ddfd1c91eac41140e5d8e44145f6dd2ed09e5da5d3244cea2ee15725b0866f5201ea117302cdbc49a7eeada7dd8501f6c9d3e22f29a0703091327f1b92e8deaed207ae10ba52d93d8b7192328ba91accc42ba619d4da65b7e9fe329df3445c4df1175e543ec3baf9da0a2f46bbcdd39575fd7480d8c2ce666f89bed28d58259e4b9e4a0c07980fddca008a6d9bba59e3b7b96d68469042ead67d8c64a6b67de2fc2f16e012e8293b626cd49930c0a8d25495f9957249441ff762028793420002204f44b8b7318c387a98e7956dd043f91da72e36f26e67d4813f71ba9c55b76d2863ec3b5fb58c93a61c660abf615ccb1bc4da073fb178bd937d5e70686e633266b53da2313e216944350837dd5eda387b7b544f04da916b6891176df031743d012b40da32e87137472d6216643ee2a2cbcf2c5234862b926a980640033d0588ae7fb0a14ca8e134cda4ae8d7e256a7762184b8f205b51e2d0f69d380fab530954731e6d870a0f0dae48a51c3ed45702faa6fc1cc4691fdca281547e9c7a37bbc4a50a61a38f41c40533a309983994dfe94099d534020cddfdbd7e9c7b0eca4f73dd54fa416e9ddafa7eab477f220a58a3814e857da1b7631338babfbd34a2786ba3647b7484c4601a15c51e452de81f17a3428e03384a41eed9a66074ba399f5359007b836add46290b69257d8b9948f8fba2f65ee5abc120dcbf69fc40e2f1b5958a3af3ea0f46f6fc56b15d2313988197eca310326c545cd89d1151f90ef2c9d310773b13b644bf0e62cb5bddcc522676275ced8dbc05fb01ccd6e11af7afe89c673b32a53b6fcdd5531850331a180283691932550634d8c0e6e0b0218cfcd37acb224bd9384254dd483e4e3bac6662c782bdd3e9e128ec1113ab5a1df0c74763aaf5ba7cabe93c1fd8d9ff097d426f81e94da286d25044a37a078a8612bdcfc9d4343d6369ca6a1f961c5111f19c8ea6d2898b803fb0c3ba063f597c3773228c7ac5d7cee3f4252fb3a90862c6136c10af30d79ab009c0bc8cafc0d1d5737e99d801306356e841b73ea0901b1252f94114b9be16685dc3f560720563cdb6c32287c35a12c12a8cd3064240aafb67f01efd263335198f38184e9bd88f0f3b942c77c32ed79ca3617db55fa774a458ae0a3812ca2e6d26e35a88a31fa4aed060bdc91f5915b0de8494fd8bff65da646630c564eba9d44037f806ee206a62e2d608d507f19aa580a2de902fbaf1ec5a9b0686624b4c93f78b5deb443ea64e72060698db3755cc38d5bae2caf9fdd1547edc7ece01b377fe884773b86eb81ff1b234d6dbe5b96927b876f6bffb2169250994c4c2ee038234ea046835b3e002333ec63cdd56e03c6c7b4a430fd5ef7a2bd70d919b8be1e34cb542cce649b1e1a2cd653f77d6524dc3e5e9a87741af9a424da3d3efb1f7bddeb841e35cd85892c36b325db6a67ad51074e1b2ce5766a8881b6508463617f0bdd9db8675f9da1fc5a5a55ca0893bc39f0e83450a9570b77375a08d70ae55b72a860e799ad2b4d805d4db8e474eb2c62c29ccebf79df590de0431ad8b0867493bb32b7d23dec4684df150ab3fbacb8c83dcc3de471e601014f04eb1b4ce3e1daa0306322e784f539c33f4894ef72cd91588f6d773b065f691648f928084f80f60843265759d9f1afb3858f8accdc9f9abfe98f558dddc4e773bb20c0f637c647244b2883d4a895c7d5bb3cba03f713c1723136d2f2658373619da84f6028737ecfbfaf49c32ababdfd356fefba05f7c695ba91e50076fc87590e0530e6317f6d3695a2008f540a10fe97e722014b9ab785918ee4b5e6baf230ab97d683fc3d188e852c3c7a7e8c4ad74fdd54773db8caa7d4115d4a504753a13c931401518d05ade42679174d933a9e1d9148d4874b9b8a1ac57bf531a435ee7c5c725b99a5c152f469f89bf59ef0b08477ce17def70d7f05c7e757c0b3a61c6fb76fa2bb62a48126591841cc424adb1c7c68291bd330b5b2967f62354b87da0eda1f3eb90aaee87a9a088d2937c7308329a0e29e308320cc0eeae617b553e354f4777ac1c2c22cae60012a90c0cb22f5d07feca787cc74f36074117e54bc6a57e371493816be84e95240e54793c6e0e6afcc643ec6a27d02c345f64fcd3fd68dd866a2aa2225cbd686ba123a308f022318d7e0e39e8d39ba4bc6b918c07c5322126944ede81384eebe30559b778ed1d60229a3b674fe01a877b5c5d094c1e09ace735f7b331f184741d518bd2557548aab7270d1a358f0617141de550eb31835e972845a96d78812cc872d51c0d6b6c820599f4daa61f0562c57a2ba46df5e6b628652f55b6359f6f316422ae76a95779026fe4866aafa427ef3a6f71a1d9e27722e0fa7a35c64b03aaa593a9bcac4faa6b7b2d4d90a556484cba85771eb9ae8310d09069fd0fd68451ef3a37c7dedf8afee675003d05d9e1df5097d545ab8cc2176c323c624f61cc856199270b5e015f1e6af959976d4760ce212ef009601cd0b779cd119cdb9cd329a5faf9d4b4a4b4ade4b8a283c6749911599e2ef59f96bddcc7da7dd0250eccd99b7d0f64d0975b35efe52330cc01b9599ad1575f8a2f6cef707a8f0808254f58fe0ef53655ea3ce926eced5ac736229fcb44d2a4d96669c9f63e8ec80bce2f9e436e554d0e05acdceb7d4ebf251056d94728fb11bd3e47102ce8d470aea04072523b6b6666294544f671a184ff56c1975f8711c185b084e0b75924e7ae530d48182cfafe5a6f4fd125d2a6c183efc1ce9dffc602756ee7ac09e60e0ae216f5db15d67e8f3e7bb1129f437a68990655912cf8fa0c1f1b534135190659246e3d62841cd027ac4259594352a6e6831396aca4d837d904cecf27893983d3f2b4e18f24c2486e6cef688b75492ec81d1fcb73419b64224445c7e52c6b87efdd472986dc1a9764236d7ea2330c36043db081bf34965d450fc9c5aa9310079118542fddf438f556a1dc86bf819650422af66beb7cc9d847ca6c819cc3fbf111f12b821f082d2f9da30b46cb002e9bbdef735f91e4a97153d1a33fd94dd5f760088c7d65472dd4bb0ca4e85ce14393c990be7455688efbd932542f67b7c306c0b1e343629c17c92c3a179e55b7ed37439e43486f777751979a3f42e99edf777f3fd6d8241c0a22b9907f0172505e84f7349610fe1929b66c45d2f90d459c25b2db587e71197c5cfca801806b736b43c4270cd146392a2f9f1742440cfc728044e9b38b2422118338dc8e79cfa85274ddbbb44e75b84ed96eda058048bd15a30c40769d1d568d23db2db47de0444f386a2565a3c2e43f20a9a76b2613c3613da1c9c626da440da7891d32712672b12e1017fa81dde093c814cb68ad9d8892e29359f63a8a7dfcac46677ea99b79c69c7ca119d29dd2b68ecd0b7d12e9552c942612304764250f8292d286839df5a2b98e3d0d28100604bb9b0af2b131ecc6eeb250c31b852da0b23d967da0fe65edba938ca2446c745375eb954856d6d9c77baec2e102f4f0c276f59946b7495b743895ab26937204cee3259c61e09bb1832b85a52c22fc817f640a1503d115fbc25c14b0a4893b415463af38db57a37f0e11ecda1ff133fa0e6c20b9fb9140f461bf788daaa70cf6aef2a76263623fef5570cea9bdfd15dc6acc044a99c8b1727a1190276b0b4d810791abe09652d516c45f79b28575cc535374189b3d02a957a3192eef3fe10b6e37e81f9f9facacde9b8e6457364b09fc669fe894aa42f3e98d63fb1857b7522fd1c77dc9dab9b5744b8ac58eef56934f40360a893a4b99784395b9df7d80f6f62896df410c2a18afaed4316bcaf72594605447db1bec5b6740431c41135a54ea0d95fd92166edb4793567307294185224f33275a32c1608fafb908db3a88d1fc37620ac6c291eca6f2c40c9ead81befa0d2ddacff17a6b98e1913046378717541d1facf5ee52fd3458693939e48d3d38d391f95b1de283e7c6121c52bce49f9cded804964c2f3338f03f46278d187998b01f48f0a4e5d2c791652a53b15911eec8714aa1376f9b213ddb8dd1d2c236684f3e56e585c7e45add4d9143778a7243dcb8127c8f5a2780ab5f2fccb35f03fb6690e68e4c155ba1c5dd990dffa6eb17d093cfaf842c6514549fd1cc810ce7bac4cce1022cae3fee15b6bf680b457939bf7761568122c5183f899dec8a174ff32b3d74fc81f1c74e146e7a1528803bf3fceeb0a7d1445b189ef736da587c941f9a74f012ccffd462722fec41eb8df7ac458c8fde69a21418d59b065cefa5dcf0613e622b8ccf5525e09eb3a7714dccbabb7d223282f442e9bb632040e73cc7a70eb169c3ec24ebb50911aa4d7de2107ab9b7119202fd6a80cb6b9b4be4576bcd7efc43f8cfd38d5a03cfc13655f38ba38d8a94e480d2005ed386dbc8cca18cc26b5f6bbd8657f64995700ac3c454daa6b296996a0cdfd3608af39a9eaea50efb0dc9e5efdab32bc39d3a25ed0f0c490d28b8002aa5e802a844229261cec1239b43db4f13d776e5b26e08c9e57e9c587551cebf6305335e775ee246670fcccfdf3bc5c59d3edce6c260c642248f3b07e67ba7e55b7acc8848764e49a53bb326fc5261d3507e340dd58b17ff05b0940cbf5e97ad4c5b55e8456f25b8612ebb36fce405a0ba440a5e5583ecade2cd563e42a9591f7a9098ff258ac0bcd8947a2dd58b61a261e588160915b907e561d56a086914a43aeb57e1346a983069bb747bbd54955a536bd32feadb8f82b26b8c4bc201a8278c66113235767bc1891aeb8ef6f4c31b378a043e118d3648b9578f64f74270bff21a629a57f5b7be5c408222548a188f7be7ae1f4d2529eea08a9340be1994b7d35a7dab16999d8988841fa55ca11bf60d1d3bd0f8ee686f1fa89e87bb63c2d4f45f56b8c11e22817b36c5a7ed64bf0424f2c18fac254c3f287bd8bd959802b7e272be9fa3086dd67a0266b72bc635f312d6782ee67c5a8a72245e1e4bb8804998adf56f62e0fb05aeedd0ee32404cab8bc749ea765ef88939615a8dccb02d79ac6499e726c72d95ceb4ef6bdcdfcdd6e84b57ac5c0958fddf49b7a1fec9cf96be89e871f2ed3445c71af01c0a04995f01590a526c959ec01d197b1b9aed6101a131d8799fbe5bc6eea420753685393ba989e8b13ed74b2f2051d0b54681111f834ffcb17fa09b1c9a02c398a4451876affec13e89af946f0374343abbd49f80aba66800c1bf635c2e36a9fad6fd38212ff8659f1bfc7e1e75db093511fb4c2c76320d3a757c3aee24236e175a62aadca8154b542c19d598d64492b8b35f721b601bc57885929bc3ddd6d218b8d46969b55cf82a1b68bf72017d1e83a610a986f4c37a100a7fbd917294321bc9726cfebc849f5c2af69476b78ac5b2d0961148bcaec42a20ea6b239d96ea12b1739c5310cbd6ab2c8b5f0e07e6edcd1163aa5861132009b814affb006e66352da6baf88e17a3ffe1123d206c000d94ae8d18994e890a29394cde16eb447d66af50781549e8e1073f3ffa3cc5032d8f3459b672600087c745bae3c72404f4f14e15e79aa0035ee3becc949e6919110fd7e691b5ec565a3aac0ce67e96db51304cea8f4669fe088ae796785b3c9bbfae4facef530831c5040592f5456df623ae572a41db9c97f8cf2926df2e8affd5041d7123a31bac1551541f2524b91bf5acc62de7c94d36de6ed8b5cc92d45c775901926ead","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
