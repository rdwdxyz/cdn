<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4b9e21c47a7dd179064fe9c894175c3ffbaf505f266f7b732d40297227e8a67b5da1bb1e192b1d423c97183bb83c57c1b6ad26d74c9d87991e10685aca7098b9d197de689e71bfefcf790357e430065f0cf42dc306fd008aff487088b96aecf2aa29c73dbe1040b9432933834e10ca6dc25ee671072989f7ee9c06ab24fcac7f0848e2f41fe1e8bbdc52f92d819e28bfdf77d564184e4058fe747e625b06a1415501cb9e6eceb8ac785fbf871af985cdf97a696c07a2061b0952b63c16b3520708acbfb2e1bae97dcbb24d90f55224531374f88e20534533b23eac9205d2ee75f9ede7ad29fbf9d0ddcf01e2d736da637944985d8122250979bedd8312f4beecd5e0ca0795531d59e643f2b573f3437aee65cddad1940424863c16995ef30733d4471ff427ba44bcdafe1b1b307bacd0acce7822fc646c21072a139ceee2792d79dd7948497d15e16ca019d34ba026ade9948055d85e8df323d37b39df9d16f9b14c902e2f515d6fa28cb9c793f7441d6ab95503e60ce60bf0dba048d4f9f6feb2eeecdef8a6b2a33f883a9de196475f5a88152978a7e7ed0b6b4537776f3fab9403493008d687ce2b7a95c3dade6b3d8c86d5fce41e42a14cd2577864000df60c0313af6feaaf898b9233814b1e2c5c4341e7357444cef748b97180d53c98c2e14386b7f27f0268386d0be09538c8cf7cf4542674e19ad6cf1bfdd7f1db3a1f625b701e8bac77c463ff5accb11e6c72af4427419a44814e2c126963d26d435b5f31574550774737021e9370bd22d25a5fb8382b92068d6f77a91f812a292f96d05429c178d780f105636ad31d5c4d6c54027bee0629db763b4fefc272462139033fd8a27568aa8233a9751970d19e216b0dbea0e5f12dabb7da16e1832ad397c8c4028d314ef9675b29c42916b74b3973f4c9e5d3993da2c7c3267c82a0ec73b72cfb3d9336f358f4565064f51ba8e4b79f43e62cb1966905d85dafcbe4d2292d16b9dde1b6ec7932e0705d84a5b0f05401d8a7ac538e6f7b23cf893eed1ecdbf4893bb42c6a0f0c940a564d7107396d1ade320379b3f9ad998d470110b2f72d8ae9dd51d52c83f28cdd240f1679777819d9b329c0c2be4ab29279c86849e78dd86421cb129c2d6b2dfdc0351cfac280c21ecaf100cf545a54836555ad91921d91e09a7ccddd27620af82fa0cf79852a0eab24d2f9d06dccf69a1e7874d48085d6c1fc9073328900c4f80c52be6d5bef1a0d82510484c6da1d9b0d48bc212207d54a9a1986d907aa03ca25b063534f716782eeca394c064e761c8940d4fe0b666360ee20362af1ebd8ecb216daf7ff52f7c775b58973b2b43c75b6faaf166b25b8f329f6cfe9e3c0b2851582cb49e73a4ebf544b6898f202084bbd3e5e83e3ed9049ebea9b1984faf526a69b5289050a38301a0d3213f7f394a20dfdcd4a2d1c3e365ec64081d76a92edf6462265bb4f8357485a49fe99637c7e05a5581f06e0840da0ad91a8933126bcb92edc29e85b8697001e6a11972f8bba65dc5f652e8f9b0ab9692f05b68c57a1a5a0548a99a53a3c50b4a9b75a295f63adb140b58803bb0a864912ac599f6e31133eabdb6d5c08343e3beb16030a5f74c78db7e0fd5de78d2f8020cf8fb6546ed64c1d3de10841c5b2a23699e14e5b72948ccf9bc0355f1cf783e2cc377cf0460a1136db41bc846ba59a4f2a42074e4e1b1d3a71a3b5b6d439cfb330a4ac4d41bad55ae1e826836e655128365a739292b5a3c7ebf5776f4648d94dbb9a86f6444c8d781346fc603f5e6b3806e8084c206395e492d78e7b65eccaeef7b1664f73b1086bc6333f1f598fe1177806f54f6fd302119612e9e5ff6b4f32547ffe4d1117c93b0686199ff720e3c36dc09b020b793c198c61e733012c79eb74d999054048c38a961c169050242782e38f9ff3f028f8f918db8aa470da2079f14789e0c5416d40bdbbc33c17b2ed8815bd566816239a72aeb064e17591a1f9c9de4831c098db9ad213ccf3a85bb244a11c947b4b7d0c63e5d8c7e84daff2b7a8defb5d7805fc5629515ce62b58bda3704ad21975c7c04fc29543bdaaa9faf67f2658a43806a7b9ce874a7f2b1beaba5b9853810c1faae2bb45a77b761d430116ff7d2057c02ad8c76ef756aff63d7c33c6f7165c6123f361065ac7cf04761dbfd5a0ded208d14e11db31c801577815c51eafbafbc3af4dc144f644c48ec514632686d2f3e0a11af145429b467d4a2996c841bb307b665436b830be8652d1457f9e5ecc4419adee76eb6c5c2f2baf652ec3d718ecd20360c60c4106633558fc5b7c0d894b0ed7426528b786c9bf57cd2d99f7e08d3204cce79ff80167f68a7a807ba3e7fd7a659dcc95366eac6db67f0762b8dfbfc0f339de22245f8d6c688f2a4984768ed887d538ad75f6af613c1fc0ad341a870fea47b4ebbebc5e4ae9de74114894fc07b3fe99d4d25b22240b312b32bcad3b73880638cf80b45234e431d2e9916850d73c8818cab718674485059d8889d2cedc1707850cbbb92238cc18d989565bcb9a2cc1ed8255b8914f9cd8c79c6a38a757af7ca137c420ecba767030f5868f08a3c1f003ab475aee7d24fa01c59be305f13387ace007cd1c9fcf1e583670c595f8e53f16487251bd8ad1d950d739b2ee3a43a4f7e4fbbdcf72d5ffba74d346a0cbb939c06459f5acfcd803f112a0a384586d3114fd15e4a8d52833ce9cda0ee7df27a7f0cb7a7d4a636ae338cfa4fa54e56d47ad30f4c3d6dbac6ab5bd34d6a56e29e96676254f91d202b1d3cef1dc6b509b59ef4f6bbd59527f191face2f2e408bae7d58c3ed64dde3bc7c862c2da99794a67c2eab3f5f803896e66ce3fd5faa22bd14d47c38e3f4b97ff93c2ef0e632865b8e707d38d6ff03dce018b72f3b3121a422323ef1806e357ee2271012ee3c3580dbac18e5d4f1daaca58413cffcd41d1f2c165ffaa098e198c3e203f7eaa75ac2cecabc5e5618e52b507ddc4ac6dfd1f4a6dd2737d64804124380df69f6dc673b41570039ce96733ca5db72289d89efdcbbd9b546f84bcbce6262bba97f1cd850face5bf109747c048e9511a984ad183c4da11ae1c480d090270bbc1afcf1fc5c66e7d5d3fb00c9c36cabc99b6d55a379ffd7d42908426cd8761946b260a38a8932e8d45728ac9005af321d7e964b5270af003931d51b9ea70e672b9a9c2d950ecfad97ae3e652de46c3efa02e0b0bc880b48becf0cb7047459afe7c07da63e713821f8f5e62add5be4753343cf69f812ce8d0b6b9140af0907491cdb231d2b2ec89c1252466eb323e310b19f84b433d0dfac70dc6b7ee8c7a814995a7ba964cea61a7b080e33b0e4f4508ee806e12896b61e333342e293317edd709218f98f6368974ee330d63ae623631c581d3a2d4ad80b9781066f714676e8de49713eabc077528ccdbdc280d9c1af44fbce136ddda3f693ecc637f760b963dcbdfe9303b46cd805035f4be2c7d7abd04d53d9c452b069473fcfbe83d6b63fd4d185ee126781a4da628c7e2713db3f61dba541cc952474ce53c20640c73345020d631b13466277112af4b5a2c2a6041e154d2145b24b95ee154bf6f7a61bfcb88ff016fe2e22b819a07aa13a4f2510970a3391b9fe9199fb33195e2929a347c9383dae8e64693d77b9411fa7633215a6aac1678419f4f5d59d66c8c9e8e683dd684f43b4038075e1a52dbbe2d8768fd61d47e080bbed1db5acad4a97331782e6694bafa9a480b8f975fd407da43e28bc1b95266de5f941531acc2fdad57f518163dd478a076c3309474e0bc0c1dbcddd5ef2c6d7eaebd4221efdf6516369ab4433b3245076bcc76b39c4313beb49867a2c39f5abfc005a3add3a08291e331ab79f62ee6f1eecdb5c93c6fa4d6d5e278aeb300d654f87e31825d2324045e2f9efe64fd488274ffe4e1484f01e60459018a2ac77ddb8664c1dd85b39d0b2fe3c23279b711c1826a98344b56414afe9b356ac1fd4191c9834d6ef5416af33187e957c50724950bc81ec35e04ea11ee0329fd57c589c9e41180ee437bff4ed71ac21f2533fd29c864e65653f91a11c46568759522997e2b0eff3cf969ba9cf55f17b1f2de883147c964fe6690ce69e9fbfe1b9884c868c0881ab181288e524186e027c37bad8f04a0055dec7840e936b0b718465a28d44b9fc74222feb44f49fa1e25f3f6455e25642efbc70c2d44158bfc77fc6685720048b97ebd19da3f4057a4667133251404cd74c9456086ae358354fc14a427a4f6329288b95ff8b40b9c7a5ac33f3ed65e0c28567ff2691c48a0a5111edf41291e8e8850a3bc8ffad12039a875d26e8e5a0f9161d162d505adbd05ed0c5a8b20ffb3bfd2b35ed9695f5172c7b35c814030f35726183f6a5fe0542acf8d3d557f2fc0cee72457c938b80708727f09cb56dfd3fb342f464304537d6dd12de6d92292342514c7dcf671c1df0d86adccbf266c16e73f0753294f031b3b0656fe7b7cc05d92f48af9e1e52e4e2abf1685450630c966337722e7ca15b7c2af80cbedd6b8294934f05edecc8f7d8baf7f0a9ae2b1a7dda20b7fe19046b67c6cf1a19232b4e6ab796ac9e2e93fb94f197ad1a315b5e800bdf588ac84280b71bb056d7e16be2c4a0df54a452a88147118a92d7726e3f751e062a971e014ffee70632b2dd27e9db71500cc251fb2ee686e857381f03648d22790d4df827771f606a5142ec75b9964f1a270726a2af067f5f9b63b57121eb64b69093b52c45a39dae424f7c7ad379f914636a454f9f0a75ccf4cd15cfcd871ba407a29fbdb4a52de11303617d01f674f66a685b4b11f605f851863501e166e886df7d43318e0cb6937e856410ed2afa8ffa8d91c75c3371d87587f8e19cee4f8d03d9693c9a051845dd01a14d8acf6b839a090fe7696686b25b0f7e7edf666ee6d8dfdc526c17349deceafdf9a4b2d1322aad4de4ad044634ff9031a4c1cd17798e4e2e3389bf4971c4fd1eacd862f0cf64da4ad0728efb837669196497827ee572b75e8eba20fec1908d8141df1d7dfcab928d64983febf6a569eaee660faa0506057095a380875eb642cffd1a54c0fcad80a825fceac944cfc10b87db2704a9d4ae1741df747c7e023f890752118b5d905bc5301758ffc2d5d4a8485596328fe893ca021b159cd376cadd9a75e361f5232b3df472021e160420549491330daa45132e05cd8776d73219f1e6785439091d95c28c0269a83e44ef61e35334eb995df63c99cc2d6218b3ec2eb64ec0baa07fe50cc7330bc6259082b829468a36a6a9d6b1f2b49b21dcbc6e5cff10e5e1a64ae0d01a3ef8f73af3508a5afe5ea514157f111668de89b79b117acae2e0816995ed2c677c881f40013c80cb85b28886db31457600d78e3135ddaf1469f64870f8c3d500df4522fa8ddbc315a510a155be38e39619d5fce66d5aeddb045a869bbde144a87694538855fc7ce064e7e84a68e2054720f86a72419631d838c4187c4310f8e524dd5d47d2c12d59430bd9a6c43a4b7868a56b50771d63be3c2f38669216395b29f282d4f510437ecbd848388df8be5d4cae985a9c716e957db2be585cf698b98041e06268bedff92aa05c2ff924771ae48438009250b04aee9878cabf80cf1c08c24069475d7bddbaba9d351b9d1f8e508cf3fa25d03f1b53a96a25a8d861a99501d1c6caf2197cb43ab34c3ee7b4e62f10ad0238a6a102f6882820547a4bab59d2380457edae3750e6e1b899a245457baf3161a9bb5c087c16bd1668f41ef8abb08f3aad3ba287b9f779737afc13883a32d66c8dfa6194025da5fccc84c19d9572131ab396e2e64c36acb9b03ae906809e73f876f16f4de41ef3a130827de61d6c3aea97b67e49062a7e2702b1be89f2e3a14bd4304270124e8bf851ece1249a1ae3e6f29e3a4ff9897d9208f9804444422561457c9c2a3426c6443779938eedae0360b94375ef1e00acc8b2d2fc98105081b41723576214f71a1a1a978e680973db668b720de33dba1eb66aa54e1c23f58c6f0e7ed259bd7e9ec340c2e81b16221087b2b1db3a8a318ecf2ab14f76d3885ca5b1073d3e40084cd798942a233d214b16fbb781ae067a2b41341e2f085f1defde9469690e945634de1f8d824451363457a72d76e3dc6e5a9ab19dec7b0516e5c7dd15bddbadf779473417aecdde33f4a588db2285406dfdbb9e943e0044d628226b80c5a99edfbb44050f1a7eee3a913055eebd97c126f015842c77921245e44400ff39be733d348c6a39a4bfacbba821abf95ce0ddcb7647eed741fff2de500fee63c8074e95b07fa6eeac2e0af5370d8a1de61606bb45219aa5e306587941471b57d07abfe94f99d0ae4023bb7db02d50352cb2812ea632bf47984bb577f5432278379faca46ba5b2ffca80f6030d168c3cf0ccb972c7c28743186fd030ae36fd7dfbfebd1471f68adfc3340fc98793deb776e845dd0f4e179fdd33e04e25d04cbda11f0d03073ada69ee28f7ab7ad81eec2fb1eb3f810d0564eb8d3ffa7dc39d4c58225b6eb90328e1c6e476696aa7f86d9b823bb7c9ef10cbdad5d3dea10a9479f01ffd4b98d8d6a91fdf56d14bd26f97838c304a1591ce07d08147dd7e6e8ec8318a7eacf7b27a0dbb9bff687acacf6c33c8162c1d955dbfa87dbb9e2077ff7f934d454f6edf61830ba94f8ccab702a6ce2efe5c10162249c82a868d9aa1dff00092c6bafe2856015a1aef7c2c3e640432edd0b09e1143f35f4a555a2156520e5e109272ef48723cc83050eb5431eda9d40f00a7febadb54be52b79461ff20fcb685ae6e15f1445f6e79ff403645003a1bbde318a793ff85d7b419275378cd511cf4c432cbe7562fad0fb211cc44f4f7c4f8ab752735f7b9e0dca7cb4154e299011f8217a047351359f896e44340aafd798fb92f1770b21c79a239cad82ac044286d3c34d1ea034bb5a505f46349f006224ffe8bc0393e175261fe6d6571e76f0ac4f824874b54f0900998cac2fccc04e21347f0198de1711aaa108d2c28cb38f578297e02c0859052fdf640c27132455f7cc1c12e983ef3ff4e034014fe6d763e19f7ea7349ba019ac5f47ee64bcd27f1bdf71200f18c30df95a35a04a9625f201e1fb38758cfe1db4361fc295f5f850a27d4c5665f9a1384e205a72ad7daeebfdcd6af5a238d4d63119059ded154bf8cfb6f9e28ca13996f65ae59fc06ca1dea1859735f6f96b01ad6e7da41d5437fa7d1012b653b1fa586c00889bc05842a7310a5f58d8563bf6e5d0c5be3f5c60249684f2afd45b80e7bcdc1d144ec2da231750065c48296360e68353a1dd3e36fb39093b1d28bfb7c4a574d48669c8304c2b8ad109de7aaede9d73ec9ea8b2134fac9ac78ce19ad98c16760bae068ecc1a7d209ef7ff5948a2578dffb75e5511ec4d31552fb8ba867a2da0d9cb3f663758a6d504fb5cfa6890b31dce31523eb74b677a1da61c7ccb92933304e8db19a3b1741d7611f0b67d1783f058b874f5548efd1afffdeca8511aeb2d214dae0666920fafaefa67eeafd1fb6852b8b61a3d081fe608d0a3daa4376d2cf0fb003f308431ed5f79279bc1f52fec6f7f3ce15cb782dfeee8e8aae83d1238f8fae64567fa1498b35e09fdc56757278cbee1b7a34583d21685cf17d15a999d608924877b0767cf4119d12025a0b9b60f9f750df4f6f0cc94871ba2c9c5cc7ca5172a43548a7709e21d960d07b78c79fc3877daff708dbcecbc175c3c4cd28d57676597feaa21b6a2e28f44f557760d9590c36c6891eded29dd12c768a2ede22ce0f2bbb423bb2ee530e32222461a5e0dd30762aac35d46da616b5bf6a442424e7851ea60381ea8f17cebb45f5ecf74350bda191e50243699a6d3ba49f45109008e547db622319b45c11962295b14a9d3cc3fd4e19bd85efb408ce8e951cc38be796716664dc23e6903a3c4fd8e0bf0f355c2845d05dacd8e0d24b430828ebb4716fcee3c2243088c7bf2c3bc825f8e9ee40d27007d32795a9845d31acab2f2b523e549db2c7f06123bb745f2502e963b16305213964a2d4aefe005b7b88e64b45dec3e1469bcbdfd64ccb38d641ba0d6df2d5340dcf2f6a92b0696a4da4e04aa298bee9a50c4648e16b59c0c2a7b89a26806fa3e6edb1f7fd2ac5b2a23d514d9ad8138e0a03d4246bf8e6db4761f9bc31fd7236655691ca07c89da590594f4f999ef685de8c4bd2e2968fd77cf92643e3ed52d39734b3fa93699d493bb286e7ca7416c439e8a26ad70d153e5304d5735e108f0355bd09c7ba6d3a0268e492bd09a247e7916d8f8a2bc47a252eaabf4089a976e3dd45af9c9dd4aa684a99267973b7c80dbb19fcbcc382e1a21aa40cdcbcbfd74797a06233da3f3468e7d5e4b4a72ec3cbeab818fbe38ce1d3c376100157e8ebe0e7b3f17ae8b84baa52d14752435be1dd4ec144e72957f4ce568082964ef643c1c4c5f5109cb418d202991a894df3a85383e19d13d9cf4b214f7f80a2a3dadc2012d668c52f4eda101ed69626de75a13b4ea36ccc35455b836c9547b5a1909e8543d6a590df60724efc80f40857cfd4ae0bdb303cdd2620785056f011b08f332bf523df3483613a69632c3bb1cd5fbacbe1803ce5eabef75fc8d3aeac3c583e657e8a5f01ac1e6e6ee1077393de57bc87a9767883b91056533f24d9be4af40fc9b9c0da647340fb8ec15a7749dbb01b77f93e095dab18f4f96e44e2f42e006a1cd82a1e0c903463887ff5fc2e6fd9125ed4c83c9be14e03c597c75130799587688bfe840445c0600eb331c2fdbff37d0f8f804638a24bbd289d6007b9ed9d39e21a8bdaacc7e4aea826ee776da30e996f0824dcdc590170d99b084b255ba003c9cc95f8d3ad58f061a95714590e04743f5915f699150fa5702d1e5882a5faebd3c4cc217f504120a0d968bbfe3af6f3ab6c6585ea2e59443a82f59f56e042fcf9fd54ddb5592a827718607b94c966080f066c7291402867938b75d6ce73987a722d111dcfd78aec97878ade73000a00fc1d4c14713d8b02b8fea1690cca79478fd1a0dafb940540213d210ccf4e4dec62c7ea92c7749a26ff16bf87ddd54f603847cec1070ec01ffb4534b399c62bfc4dcd02859605c587f0e0d614cc92f8e113646cb9ee817521a40d6df599267d77384e768f5a3d7100f2ec310fbb0d54e4b412cbd71c77ada30ea432c8adae55a4a56a112585f878cd8a5476288b8631f65621947807f7dff4712137eebb21e536d2f9fc9d5518aab5cb1b365eacf7205d7fc4922186a726ef97700b944c6f50306e93bd5fbe390dd5b3ab132b26b700f30fd3dac899a56b9a584761d4dc519487ee16796e349f9cf598239ef962db5f5af30c52d4bfd9b22e01fd7938971a0e9bfbf1ce065513d50fd0165ad5fa0c8795dc14f263ba0ee07c5f75ced145fd16bed5758fb7f52d31e6c7b381cdcdd382a192c05b9f7b63e1c7a4589b95318f8e1dac17f9869d69cc9577ae24dc8c499ecd8ec6fe089b6699f1c1cea5d50b8384da61deea6edb8b564abab9bce7a46eed7102bcade98f102316c9344e2bd0b72cd4c1c6c908cf5120ec6f5bdfccbb85f47763ac1deba950716f17d5277bda13e344c8461bf188248be282c537bc14a1d9c729b50011068bf04c20b221e1a74ee26e3f98c289e144d554faac4fc5877eb8001864a49702eeab6879d936df8c316d1f0d208e1d3ae588618cdb831972b8d2ebee51f6de2ca6066ed7d6489e122e92fef1df4263eec6cf2815472e2e7d93a018c798aa86df148af1132bcb9726a463612573b46429c0d8a3ccfb8620b6431977139cd6ef490be33139e1ffc4b77eecc45d07a3cd92120a11185aa9aeddaf603db017dcd7f003228d7fa6bedec53b042e6d5e8234c92b8ea45f730bcccd5660b8fe406914fd0417a2629d7fe7387967eefb80d8b5a16dd0962d2fd2c057a9885835ac4d3090b3f320221d2d1c47a805d6ec5c6f7cc717124288a2eab86ad5b7d95c281a9b984af15aafb4969634d34bb38285e8c5e947b61fa1b2ffbf090ff0e8f3c18b18ea927cc93b206a076ad15e3357259d93fc50d059b4c8a0ee9af4e519ecb42083f7d55ce16443a2e3667550a7a25680b0297370c2dbe6449f0ca0762cd4881ba66aad14a2aa0cac8c80f84dfc1abdaf4cd1dc16784356bfcc211f0e3493e881260b9b13721b197bae2cb05d2aaae4187fe8b97f9cea5070d76f4bc515e058e80e71fdf1431832ac9a7c9ff9d2e5146cadc07e3e0cc66fae3547159995ac8ee6d705e4a5c561a0dc5092baa166863beaad1d2c99d1f6a3c30a483863fcf0071ef82a16f036937bdaa019d030126b04a62f25205891f647a87b2c610d79f31b80947c98f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
