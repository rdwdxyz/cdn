<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f22cd168a988aa742ad8671f21b16fc5fde8d2d12de1435200fd11fd48a12129732bbf4f768ffb0a4e849aec798c309b2952dadf51dc0b39130e5aa1f49d26ceb54bc5e39e97e561f9851f14de97076d5147addfd0b3c4a5b2939825e0467d1011a4fa55150f640829027e4146bed0bbe58b8f61f826653079f7f11d312d7f4060f8d347f2c62e4a982e7fea07d8c86c80497047a7249bf49d7763494ca2910af17a4f2b0192bf3f30efc2e26f091a78eb1ba7db7029e705b5a66ef59ba8ba1c2f2f8db2b6bdd613013a89119bd6d4efeed2527c91f605f87956540cffb7357965b4c76a8f517f865d0c42272a1c544173f93c86a546ac1e5bf48aab88de1c9ce4ce84bba866a62d077dc2bbc8ce46839965bc32487a8bfa7959be1f9bfd1128c19bf66530c12a83917e97322799f0fd092136c859cb4fdd02ef39ee85a7abf836d6818a70a335ea3cd5e81e2400eb9d304343f046600081f48b62b02f1e665dd892e8c6adee3e13e2bbb109ac49c439930fb4eaf89b8eddc734e8458ee1de4d5efb930d6ee2a3c164880c3746e73e094c4f9e887d594e95d697f93a3aac4c906698c88a2e0895b0288ffac15beddd814570a53191d037b034f46204bd72214837334ee0a1a8f05b78c629ffbd6bc08afec6ebf9c8c40493b020365758d643b4b05dc7cbd68a5a7a38885269ddc4e500be95dd25704dd97415a32257169ac154257ec67a8a77245ae1280f6e41d929fe7e3b8a9a18a0898e888d977eb7871581ff5ca3fc1d2e37d7cddc87fbae603729946b48dc19000fc7763e0ab06681033deb248e05d18137013cc0e906d11bee2665411166e2bf13a05a74a8ba8941a030c813073152f5fc609cc08b50b27421356dffb916170f24a8f41b07b39cd88cd301af04aee3ed1caa0f9b9f4b0af3fa36707ce93bba5d997374ddaa6b53e6e6e063475e562a72297e2d3fc8157e9cfc4d7f03c6dddfdfabc2ad4081009e05c631db6ceabfe3656923afaeec4cb90221ac17b5fa0b6378040608b6b51e28bbb1df63d2125791d6af69cced0c3aeb147e90eec1cf4bc419f470233ed0436684de211178e545d20c5454d5b8bb108a64f3456a765c98c6863f50c53cb6e942db5cdfd0983186bf0e7823d10feaff29d65d15950075b04dbbd92497ec1f5ac2491eda67712f75ccb1127695cd749e158f382420e47e4b885cb2590c8b42f1273355cbf6ed88cea6812453fedea06c7376dad93bf5966a29b00e8118b882c1fae629cf21275ed62a1df97bed75f65ba71b12c4a1e1ae189e017ff4b9cc85a81c809154639e82f920f7184ae8fcd5041136a63606c4bc4cba535217cf76a29b8d592d7c7b590705c21b882427946fc4507eeb21ed5fcc99564ca0ffdf3373072b605cf537b1f123875a00ccf4da8ab072d8959ce5c0d1c768ab81bb3a2277127f18e9cab6db0a1dc4532460edff638aaafc8d4bcd391b9016dd6b70ada6d1bc4786a6fc5e64d14f96ee4bcfbae03e4139a5a420f8130f46baf107a436744175cd5f079f15c29c5c816f9dd2fbfb550f9695a79feed256f0e9dfcd3a58a44ca06655ddb7f1b20b7002741a214fbd0cfb0d9590984ac273b791087fff8d5ff23c5a936491cafe86a4c301cd7aafebcc30425e0a91c575b98242ada92fde6f21bda3109341b1737a6fef1e56fbccf3fcaa44d5f8dc31a8cf9b3bac8ccb839c91b03d80b5695aff4ef1077ef11a912167b0949ee66e1c2b91c2118c95ed4fb1a68dd85ca798d802af0f94932e0c38ee74fd99a6812763dc37e1d8bb3fd43809e3db5226c44b6f202459ae8c54329c64d66749726c0596cde4ec3ece7ceb7185de4bf5e405baffbed177a025079c8337f3b5d4e9a0e5302ab33729fee7a009e1c0a984dcf92d2a2a3c4e988ccd96e4f85b94522db0b35f9f1567aa3419c414e0c43b9dbd4f7630bd35730435bad878cd81cd87e13df8088982d158a1e322534fc773a9f28136f60716fde4dd994ab0e2c5a13c97d90a60dafc3b04b9a32b1182da38af97ea64cbb8a183651c933215d09006f9c8132203950ac0cac6e57d7067868c19840c6e4d1d780fbdae8b27abb3db333baa1022171275fb5857c01f393c8609a18a06db7bd3111e96761268a3a0f57948c05e8502251611f32c32024432a19ec280257f10e0a1d57a2906f01150072558508a26457778ea91f0729e6f6135cf7628a06dd81327b2d3999a9de597315a23d181a046bd49a98a6a9b6af99c0275d21a9eee8212bb749b13b4a0337e88a569721d462635676b69f11f29a9d6b8ab5c05049f2a9d4f5262a32d01fec7a36725ef32685f870b9b45e3bb5bffa323ea92337e2dbde3e0dfcedc6e44ec1b5464fc18c97783e99b59eae41c6a086fc6e711fbcfd455678d4dbb86969f3294c39ed6760e3796c3ee0691efdf93278a7ba5253f8b5c0bb15a687c91c5a94cea15a3c869fc33f86a20f2ced0d284ded7fac705768f625b4e53d929638a854d8e3279a6eeb1e89c261c397ec49c9d9373db1b5f1e38c12fe1708eaa29ce1ea672faaf4b78ac94a86296227e72c90c19a21bdb8d5fae2e4bded5d19b5549abf2b2e5039b5cfb9e09d076eca4df40899fb67c474230e285e89dc716ffe2f4fa9a8c58c1d95c63087426cd7ee984cdf8d674c9cdd22a603dcb718c425644c854cc9f3638133b2f349d99761a2c95b13254831b64fc3492ff1897d75af9eefa87d113068606f1e658992eb535c0875ad833fe2edff6a9499661a4495f1c7e9c0e5b479c9251e0a49b57ba41ca841d6f795988882ed02acdf17c7e19737696bb374a1c2623dfa0a9d788b0692e42516e93bb4eacb8b1bac917ef39b1ae2eeece1baad67d3fe0f632c5f198adc7c1675d3ee71538babad7c494d848aca03519cf5cd07e14ce479685b81f26acb9bb3f3e116a9866058e2e88bf5723753b38cf9515a8f32ef55c61353d5f178d00621526d3982b3428889addbe57cab7e31375c598e98dd1f4d0dda89ad0f1d0456b986ef715a5944a00b6c719f6e50c20acac5b19a473ec934bf9a9e2855ec2dea09744c596264e168cf6185f305ea0c4bb3a8ee06905991f5afdaa27ca6a1cc661514edd554b36425d4430ac845c7f90c4ff13fa3d612e7987d5f653ec9a0de0d3672a4c36c3a6760dc2c38cc7ae09e7e19dd130e0cc77df5a85326e7294f1ba194e44d79e184f29023206d47fcd1ed077b5805847fc5742a927ec2cfef55f0be8ece372da48eeadc20c3fcb1a9140234dbd9e225d3c8a46906bf74ac5afa6b097df1740710ebb533781ec4e28d747d05655c4ca9f5565b50c80607582b58354e2d9fade956bf921a6f3338b5826e45dc0d228e5f49dd6cd0dfbb4c8d354b1bf29cb230d4a817ab3b2cc2ee4fa72be10f49629de4ce410b77824d38c675d0a1c76617a0ed9e4175051c4de12ab7abe79e7169684fd91f06930eac264550171971ab14a9791befe60aa6d90993d905702ba5d46ddbd72c50ceba393dc7d256eba440bd58889f775fa1d3640a43263f37fef563990e3a806130ac6f3def18ec27cee26eaa99bacc7de5dd4a063aa02825bc425e2784c6c267a9bc2b518cce9a9079b9be3c503e16d87dd5d806a332dbc260ac5ab65b21ff5b502b437bdd5466fb0cdb4cde9838518ff7775048eeefeab47969b41b67986e4286368d86b57878dc777da202079e38b5b123cb732fed5ffa84635d44e546b580dcb2e9deca46125755fac9b011869c709bfa13c068ba681d0f76669d129b22cde149508bc01bceb9c352bd2554b599308b976f7236336e67dba1861d6c6f81b692748ddaad07efb239831718d4cb4830c838e51ed88b3977d275e3700fdc15443083e0f86f1c56456c37b18dc80553dd3f927b65d1686d014f620d330cc86d6ff674a73b0a303ddf1a239f26d4cc71281fa37a56c1848c0be8f64084d5d0d9077bfd5be2ac5ad0b0e2fa077a352042c2d25e6e2363796150fe3abe392a257e793c4d217d3f71159ff1a847253fb474789ba656db5743608e260a61ac4dc633ecef84938f7818240a853e6d5c6ce13efad7bf98d88f98367f866852a10b1280287f0f66284a472b4519b38ee211f05016ec8bd962f05fc6f70b1051fbd294d576e5cfd1d2f994aac88878f01526cff842d6ef65f4546cf4c9aeb4405dc945485a782985ec79abb3941ae5ea0f778d48fcc86befc5aec9a67e4ddbd1cd60d2ef71aa0704c1555406b2c7f23e0e0499040d47777d9a0b243db6993836eef6847b1aa3b8d95df8b4ffa842cec6104493099e7f16e801fbf171a1621bc66932e2ba2598e4aedd0724d5a883c2e60f0cee05c587e9198475686e4d0e971e333bef42c3b02d1788c1e2a594c99ef576a0b4b5b6eacf25151335cf17c24c04de549421ca35823681201a7885072cb6cd41421e03fd3b0846ef3180e5ccbb7da4ec578c41d07f4cf47c9b5cc4b3feb5640cbe98d5e4c0d077c272861c544d5eb5448898542ffcc2c971391076242dcfe67b03603e95aec69cea85586603c775d6f8904d524103ddd09ad38553bc4ea882e1ac966680f642f823c6fb84ab8a7bed3e456b8a10e2dcc323bd733ebd0627fb99cdfb1ced065e12df9caf036895f6448a992756ae3b96ed3d700c9e09d3ce692a7b7a5763e6a5a450fd35a519ae004883e4c828b54796c69f64a27be4b2972af83f5eb4c86d2781428d6ff1cc82ec14c557d81a2c26f601663bbd6ef6c3cc1e7663356459f0949d6c5f30adb42d1c724f4bd0ea44321742e197d5dcfa8e13be6e49b6bfc1d61e390bb677bd0adf115b278f624db29dbfbdec7ebacc41dc10516192dc072a32bb390d17b5ac2c6c210758f8dcc675c01bff3f22e0ca7b5a38f98ea06ac65080910da06d84d205466b3261cc02cc8fc4ea2d5c0adce0eedd314c483d1756756327770b5ec8e877c4519a9ddd4f85b1a9531df2f92e376e75faf40f472f1a4bfa5bd76a07751a391f787fd9a703cc8385f4d51a8e69b3662503f14a70a8332d9ece0dd4f997f791ccefd79bffdbca65d9a5b100f8df3a1b28bf10fc5374ff61213325d77c764c7660df38de442896951ce6648a6e01d4af5a1fdd36f4bb23cd30f14342ef45419163135778a7f1043b3da80a9eb9d3ea144d3217ec7fc78eaa4c80c3e4316fb1f27286c7bccea091ef710896635805915681966e07b4c28633cfe35025fb315329f5d9f1bfea41cdb12d93d010d9082ff320feacade5f4a3a56a5771e9b67a7f0f16434934f542bed241e57eb0d6ff1d4b4989990d7f4f5f37680414da9dc1080e66fd0784f235a288236617778c4032d8d255fb79dcd53dfc32620b8443610311bc2ba57d7b41d09ed3eeae7870a8604a0d6def05ad7849bf1dda0f82c3c76b9e1bbf43ca1812c5697338fa9a9b98983da87f38f262f01c25aa877e6dfc687b0ab6b8e4e1c1f562f3a9946549793e6e57a1a06750d24dd12a224c0a4c05afa72686c771f0d1282b988f528b8d9f3e9d63d3ece4e9dfc9f063366ef9f1c1f9f5d8e2770b437bfac60ccf15fce4f5b4b5ce9384ebd19e89d6c23d2fd1e1b57afdf7369034f859071872fbd5d0e1bee43d11a18797ccd50fd31dce30a95e525d8d49da17e99ca96c0202692f3769357decc335d3e2fe65c55a9a873add929bc176ea0e9c2524e60a469da2497336ed0b3ee85a8c59fef4884d25a3cfe27bb79e5927e46d52216af92f135c5969e64b3e9ee83578e61a90bf558957de85bb5997b2150d4078d8c5226ce902f9d25a6c5bba8aef699d8f5fdffa7ccd6b57b5b1fc979ceecf8c9321f41b16ea7280878f0b77387140fe12d7764e19124a586e3e784d15ab84092d08842a33787938f15c650cae0cb38d6dec5e9c3823aaaf312bc999327fe8271df7b0d8ae25b90883544157f4f3413a80365a94d664209efb614131c23301c008e4d8a27c34e9030fc0949a93774485ed5817cc7db66a3878f6a461a2fd7897d2a5ec82fb6c0d6e7b122b835cd380e16576f788bba81e68ac6bf152a88221721b9fac60c73943b70dd59a37f6133f952372099d010c9a82b0df710479b05cfbdf9b6946e8b58602af2b63ef306122fecb137453695fa888d23249e3433d3fcf8d4a2ee4f77fc37a55bbdae00ae597173f1e8f30d345a40fea67862ce01523a9dc1a7e53fa2d05053a9e90de5ba07a2f8ec9c17d555280d5b4126feacdfd366f762223db11f49307071ac7b2f9802d58db246103b74e1f6aca9400a05a1d2b635467feb50f92a91672e605e4f9ec39079cd8db7d74471b17ccb4b269c5dea070ae173cba85a5e8ed3dd3099df8d8febf5f12f4993473e810680453778760f2a81cc780a0d8e66e4375ffdbe578d2bd0354c01e0bb3a7571d0eb07a10e4f8a2c2f99ecfb18111aed27c8c5abc4dfd97dae98b22ea1299558d5ed3a9888e997e16913c6d699656c5c128420b604dc7547cac45b38bf00df99028c7f874a9bd990c2761b26a93013ebaa28d963864187d6934bdf3997649e4e2d5c3a6c1e32ada56f55be5ba70f0a44f106cc8a45fb3ca8533641b55786d75b4ba4aeaca12bfd40b3fdc65d35e95d0638ddca23df23cf216aa778a0e4cfd2510c1777f7c69a84fb57d48437742384d7f0dc81eb6e9f989b5bb749f701902432243b806612c2a501eb13e0645ed740131d7a1919ba9792e8dd0380e92c85551579a85b2c368e1220d22deb686f5a1ac57d919ecbe6dafbe9c2cfa4efb8ab6cc30898e2f3f86c046a9e5251de6098d335517e7b18f071dd1c426832d3aa039f55efb0b98687f9e68b62ae7ccaa724b8d806684723d849892cb0308755218e49e886870406e9e9a23510087244da7a21fec31a5cafe1250b67bbd609d5e4a83bd2205e410335025690cd403414feff21ac0d53a7004bbd2ec0faa2b98372c63c600fbc9cdafd89f56b869ffebc14aeb213f828f96eb8e2dfb5ba4e0be4f3bc6b8774acbfc7a4011074aaddbb6a6adfdfadf97d074312db8db2f72c89c6ed89f4584cb8b90922010b0b0981e3c7ec0a57ababcf69a04ba13ef33f386bf24c4474c162117821fa38525597f5094e4d2014a1e62169ec6ff21f588bfd674f954543407d67a36dde9204fc3c9c629d69fbe23a861869bf23d81188c016fd3b90e3921ac50b455ba190ba1c598d366ea289a844e5bd7a27216955003c9e38ef436937a113c74a6c979939fd5f6bbecb3f4a6dcb4e2c3e05e6f9c308ee9cdc43b2d61451568aaf45198f8ce57d0afdbf955728f0b7636858925ca181395a0146eb67f003cdaffe93a0f6559f881c8ce1c095a893a49efe6d95841e6d070a39f3df48962fa263e3e9a686af630d2d4dc6447e563f02d4f87e586214e4ac6b3133e66556d726ec0ff515ad99d8d9eab8d8a839dde088ce2fb3a622ebde40c5f41870fc93e5ca84ed621e980a1d2bfe2873dc621e3570fad9086884e9bd350f72e7eb5ead3cd75386e9d2b3a80fe64b133a0141701f6a413a79d4b1b52bf916e3e089154a2476d7fc4ca8050902bdd3d62860ee065d3af6be791137e606672ec5e6aacad91f3867f8cfcf3881c093a0ecce49fd266337cd6c94beed1b51770b07ec82ef68acec91a8711172c2d0319be6be96dc21463be95f5a48f1fbc70c536c2f3a1d6de287757876c29ee7ccdebe0867a2818f695bdff01d79abee48e771f88d2b65ad97cfce5e8d81db9228b9006f9bc41fb297a5a346d34705fd319b36d578d4046051ba38bf2a92d24426007d31e9b29ee184cd2880e249aa569227975eaceef461999b9267d7f1090c3dc99be3a8599cfb5f664c35f494da575e9527905acf984576f03e74338e1daa742617327ae2fa997414db15974a3b3f595371dae706b8db8680006e709dcb74eabf4b356cffb307eed73c30a410ea40d75815c55ed73b587be90f01795b42f8305046b5e7dd4d69a8693dc238005f32da66402050ac42708d34f953bb7c7e7e2bf81e2642d074ac73e0c904fe80b70b73f749d4c83d9d912de978f4c5df799745efeaf47de73fc0745350e7c1d7e7afe0481f8861579d971901c2cdaaa370b38e7bc2e581fd9217004f9ce1f19cfe5f084cfe6c9863a0afe8f70089ff6e131b3e2c07ccaf4bb034cf3665d2f9ec505903d01b1637de5854c3f3bfb8b54acfe30fc60be8923a1a2eba4d876a43ea78df0c9450a951ab8a041f6c8084e78a18c7ba5d97784dd29cdad769d9395c3b8d9ef87e8dd69b4faa6f162c67d82cebd1b7707d0a86a7a02e0e566d8ca317a393cd035f2569b1b138266513b20cd2ac92fba22cce18196225c263713ceab889ee437ab084439732e7c04a65f9f7786a3f94fc9e6d278343ab056bed16914348692b73210dcc81cdf82af2c147015cd8c52a4d8b8c1bbb0ecb634b13b8df686bb65fe5aef85be7cd1410be72a03f121c7a065ad85ab2ce2d4033adaef39b644aa9197daa6460f570087bbc48a7f555ae1a29227afbb8edb3a470f08a8a2dcb36da0bfd95defba749d0c5614ca932b671e7666666e3b89ab18d29cef7350753e860a91f3b9ac8024361677115adadf8cefd59bbcd9825183ed6c9c8cb97a24e5402321e8121f0bae53e5b3d80317e5d84f8c5b18d0f33d9430642af92beb246ab536efa59a25d7c9b6d1211e01c8a516f26c4ba4a8ae437c9a226926e6d8fe4298888ab1dc5d1ca0f168ac90f871d61ddf26bc0184b87c24b72b14d8554a2b3dfc21b43c9b8b8ce91f6ba33870c48a9b3b445e1877b2e9ccdd6ac7f4d52e69743815dec5295bef2feb7caefb0a45eada6894ff5a1a8d0fdcb751d0dcf619e6fd7f85300fd693cb53b4b47f3891605c2f6acc67affff0365940bd1327b639d5af29e8e31bde9f3b34cd6b377354e4462ff8f38465e77d3a5b728de6e4ec86c9a30eb7b4849356c4d7bca724bfb2686b33d1ed411a2a0f388974f5dfd1b591c6e1c94b11d12e799f253091d269e13a97e83f773adc249914c03fde797b7c1bdc17f09d6b724a7bceb7712d95e7cbbe4a4d243b0ea7e619f92d430e10d52c79fd2fedd1a00e1a0be69efcc6039fbdeb3a91248cb0d0758b8022b1259d9933fb436ce05720a3f9e1d0d38fd776af5b6a2b3c9458638446e7d2f2ce4d2abaced9cd5210bb4bab3f018a81a1a5d4a6f5269aec7e897987ce8228a3e04d7865c1b8d0db38f1037cf0f277a8c1da60200585175ef0484bfe313c411e17af22df2b2ea9033eba00ee17d9c11f9949d7050b2f3aee99a2c6fceb3d620e983115a676eaa0d554c834626acbbcda2c644c4a3d5e56da0d83e2234c0f92b746b7e4c8053ebe524e963ce90a5818c9a995257a7c8ede979c2916db0e913a68ec04aadccefd67094bce1ea76835dcd69cd7b19f2c8409b0dc402a9072d0c8ef9d38213cfef145f4ca9dee1f210adc7375e97cf1cbdf98aff830866626abe63de1b38b02a967ce4d962432e8149714facbd113b58e23bc6464b0b0937c8b75dd6ed7c2781372d39e16a228fd73c4f5f22150e6acf2e769d145c4e6a6acb26bd8e9a4bb5e6be1dc58610d2911f598e2c13d1866290d688d7ff955c72760d38b03a9ea39d11f2c1d78383024911ad41d76eff8be2d69b930fec6151b971829eba0df21c4a6620f931ac90bdb41f5b34ae0aaf9c820e7ca3c0c10f0f15f787fe7eddad3b5eea7d56765b6d477ea840b0f9ae6fa2d8f108f4b04a5f5f3529036d30fd5c7241efe613aa7416082454e15dc85af1464ee9d9fb9540e1ccaa3bb7f18b8c92cfdd7136ce5b3791b929d560c59b697594ac35ebb74bc17b0c9dca747c960c14440a41c2493ffdb437145942a17c953e06f5d55820b339a4688cc21223f76e1b00b072717571434541c68d2c84eae165ff9fd582c2bed9904db1c3199c423fd91f1ba1e10fd7338c4989e7e471148a637932cfd4a92919135326f73ffb7ec72e37e5e8c48db7e94a7ab838b32c1ed3f2ef177ba1967c6ea075113aa06d198640e040bf6f4b46510ffad3a4a12b0c649fc22b54c39afcb44090071d538d6aae1be4797bd4d7db37469480279d390d91ea07079931ae9db093c0c80eef373892468194db12c0a259e9a7ff6ec2111569abef0d51c87aa2e5e5733976d0178eeca265e8751100aa5dec34b4e7e9d3f800a0ce8bd755b91a352878556d5a247018549961ce15c03591430330005ed00bf1350790dc3d54777eeefd0a110dad50153b84328f33b3764d60366a32f67e24912b08870cfbc697cb54c2bdc1dd697ceb11d8b256b0b743e000b52ae1086f45358bb40c556b9e9bf0b116ee895ba427d8cdc5e54385997a4288503073b4b082da6c97c350cd91a3cc003a903d789331fe81d150ec1ea16c9a3008ae8503014ac5e16dcb158e44f97ff3175db4591a4012650317a2cbe0f4a56def742453ae410d8ead7ce378711d612bfc45645aad8de3d6f17340ac84d3da926228172d2bddcc954d06a6fda5ba01d33959219c7a486a5fab25f3eeb5b96e88ebd2e14b994fb1bb320f1dfe0353b999b6f691f3be65f4e677e30ec609a38b26ef940fc7cbd9409747eb117d6a71da8f931edbbe7aa40d50b1752f8c97ece903364c6032e45704b87f65e39dee0e06bf967674b8b3679cf6cde2993729adb02a961cb3293a0b0ca8d4431fd131f03b0e7e2d1e93fa323b8096e3b8cb728a693e5ea4028c76fe5d1d618fdb9ac9d937313683425acb13cec5eb20471b47b62af16a3f4659283a50acd60fc2b122282b810409a9a9e6f7d302afb9b51e17a066b4192a89ba4f222ba93d76ad7b94927aa87545ffdd5291f87b71a5611c33238a6b3e39e4c4367b554e743753a56cc1dc4597224131dd3a007439c0e869b7e0f55df14c54aea45abec713a0b0cda2f9f5631d3f230cfc7363e74092789a28b77ef1e9a2502085f210b4f3fd271dcb33947b90ff32d1f8b8f85cbe6d3ba7468ae81fdff77d7db5431e337556e367b2bf7e2dc39d5f6a712acdef27aece0406d07f568e55d89a6225856785ccee3402d4bc8837d2b77596941eb759ac0861fd0befd4449af0119160b1d95afa0978a874d9057c84cfa8c3c189ce23a7ff73865f86a7fdd3d57b0e74f7d813a132062418d85cda665fe9f36c868c68ec74eb4636a3ddc89fe245c1f989031d9541615707da4fa095feb343657555bb090e21cdcd43d4fb286a41db12f7cd563bb836aa761097ccff0f6eff69a3793b593ccd80e90d80115c40acd25142695b173889637f753626b0d60eef3b8619320144d53f1bfc0fc083847d0a07a85829d9f0df7f9e9571ffc0a0feff6d951d0989c1d53609a045ce1285c1aedf8ca2ea9c11b8e5201bc967aaf6c91055da3314e7bc68b77181cf41e9fbc8bc6ceeabfaabc554764938dabdd934eb010dc04efa86e18d948f41ff1c2db43e48595845842414a2acd1ac7442fe91e3c9b2becf1c8135f4afbb454840713e31eff513b764f956b4c0e709be611a29b76a765b3e1e2738da0cb446f1a1aded601bdf8375cca25f41e6e79b30395e7b4c62d1182071465271c7c338f8f6ae705e6868cb2fd1c1375af186c147da1a673bc4e622fcfb91256093c3916448e9684ec53fa6993977fbac1982d5a13be2057b2915244698963d2752560d427be0d20dfc6d36d0d9c1352e3d46871e0a339cbcf5d8ca33842afa6582944656ff932d22884ec16e0b60da3eb7fd326a4fc4c394ac8efb62d8492764857e33806b7bb8a8a0465f4fe3086a7f13c867601c4f556bf94464725e395d8c6c19962dde989c873d3d40e033bdfb054d25a6adea9e0c455da5ed1e623e52297fe67108f178bb1f3fb50206ac14e53974d9e2411aa47e1da5acc24402e83c5e082a033bbfc60b2a819b92ca59da23b3edc2f6dc17393566395cbb4b9486543e56fe713d6925dcc608e7023a4e8a736d7856c4dcf1ef77cb5b5b52278798d71fee64dc02924be8082a25b4790cd4b496abd14909cbc1d26dd662c9f6500e1140260b737da84c45d2afc6b3d00df59134e0158287a38ecced1d58a66645884fd5bb2068002f971a00c5d7cf640372de5a2b3bb5631758a0da0105c7a8ce7cec6f631f72d10045d2ddc5ae73af4aa851d616596cfb239c261995ecccb8ed62065456f8afda6dcb5d8a9e490ecde4f10804dd4e9f2ee3897c53ab85060fc2271f8b5d62e174c5cacf1c106da124e0caa0b3373506bd82e9be17581ba0d3b1bb0d2ae06f8158554d4a33a406b2389e72a5101028e5f4a42b5458e0c49b82fe4b14ce56b32be48d34bc4bdeb9e5fb7acb4975589cd3daea9736f09f554fb90ef4016dab58c081dfc654e45ae32aafe879410859d053cc301e362e35f1c59467dead02ab6b64cf1932bd66454f1801797d8ebe6a7b4f5a861ae3226247b369b11a825de106d77944e42f654da2811da149622bccd02beed800b2f551091abd50a4794c9252dc89643a43699369dba66f4ab8d32b3c74c0d7d68da98712c7e9705bf48902cb995850260e11b1c49c07c8895104b32025d64d92846f4d6f66bdcead9edc05c60832d16c2313d0686799e859e3e292b4f2dc6bbc2c019260b7e6c84997a49301eff8757c016c713ec758eee9dbfe1ca1f495399b0c90ee4ef964019fe640ad68da3edc3560056219611072e79f47b0421125a3c65b82d1e49116155f84a55b5a3b69a974c3359fafc406765cbcbc86964d7a49cd473af3138efcb33e51b98cb3e720aa19c39f3b8d5cb3dc283943db40008ad52b4c9c80c02ec714ff92fb70305bd782590a052e59ddafb02c06c5f3adae68faee74f57d86fe631ab8c058578dd093a9d2708bb66941a6ee9dea595587b1d5040c2d1da6a4939d9c784135bda9719b1f4f7f689f006a09330f7c6d5aa039f69b81ca17d28857add61abb861f61c186786ab21c9c843573da7e3b7778386ce8f463d88ec2beaa721b0d4ff442ba73e17f7ed5381ad37a84a82f2f750070bcc2d59564a5552a032f72fbd5d25e5d70ba746e94923aa03e44bc3a233f94e925c344441478e0711701928426eff83bd2ebe7389546414978fa9281961d5f11ca54e34013e1a8c419dd732a59622b0dae1433c363a6c748d745e22025c9cfbd338f9813cee10699e955412b40a45badf2defb52dda587dd37c373a38872a945475b0f42ff023ccbaec9db26c200852de3b4408db9e269bca4b603bde12281f27287812e490b3245a09ec75558ef93825d45d58676f7b9f72d56efabe10540d4b4740bfc43ebb3512a222bc7235c5b17f2befb011a11386379839239237b18687bf125cf9b27e2db8b56eae6a4006f659c3da3ea6b8968fd17aeda294b09bd190d5771f3dd7180740eca5409337f0f1ab1bd050704f8d6b51e02820ec0ca5ed13158da3e43dfc4b0a46c9c31c33cf79915c7004a08b34617a46cf02677ad5bcc988a6f862c9014bb8614a31b7eb9e0ecca908bcacd6afd17a353dc8bbb6e7c9108cac36923d2fbaf111645b466888603dc306617affbc2d74f2d304447327542469cc78e844c795578fef2665c8bdf6b4564de0fada35a31d48e545a6fcc4e25578ca2154804b6d3864a0bbe939ff7268fb4a90e9a34ba84df4f372c63e062c4e9f19589d1a77dfdd18ba557252ff1fcd30579f752410348d5631357aaa3f195bd1e4342666fbce6741734c9db8f74cf701f9263645a80c9771e89e9319f05971573aa9c314e961e5c38daf25ae52766997eea58466d70fe04be4174c9e1ee02157d96d4e1d39c580c82b56c86f9999d36cd873ddf329453e0e34134883776c91d3038912477967e57ce236fd6e434ebd39fa535f040d531be64da31e47f299a5443dae780d054d3cc429ca77ea8b10ce3dddca99d166e959c0b94115fe4ab797a9aefef881c76797104da6ee659e8804e19ec57a2f52508697b025230eb60cf442b50aad25f667635db1e1d3c60443824360688c62fd5af3d18b3a1ee8cdb9d4242e16d9a285192c8370d246aed882ea8c703c704ace7a77f532fa6922db1ebaf4fc362111c8d69b4f1488c668ff1545f927fa654d06c893a9592d761a6211da2fb5b5ed34c9fd6d6e66c07993d97c16f966115d0d0f517e9ca6233dbfc0c19603f7480eb29f8f4c21d44c9ea588e3ab3a4a2f7adbe521274f55b856084e87b40188b3015a33f91a835d4877db2ac20c11ea8f979624d22218c4d51a1034f5ec226c845c7c0c2449921c370bfd63081028dd5787de463f8b331e9eadbefaca91c239b6528fc3b1c6899d5e74826d9881abf49b11d45cf0c0edb0147a870f9b22d1d4aae2a88c56fe4d1f389df198569790aba4501ca726d731109fb86ced06f0f6a5d4f4fa5aa60f2eba357ba5a3a5cff2637fe7ee1ee52c78bbaa0a760057b30f03223b7bbf6f554d929d71adbf5cf2ca448abc3790b6d6dcb0fcc25c416907a19c1e62648e1bd78518a3d2d4b966dab59f8320577544331719dc3d0247e024ef77942224d6c5afc6caee35bfa1336f0e655a898f50aa305b7735248f71ed09260c664d936652228a866f4e74142a0d65c0a414e6d65a27c8d4bd33c0894881fb7e2b00d4ba9d4f26cd189a044dcf27ede7b919b0ebebaf3a15dd7ede85c85f16967fe75f750eedd02dfe9cdb0a8f8c460541aa8e7d6682c5dfa56d2203799905e1e341972b1b38dfc12b0dfb5fdb1bb40525ecca8f40bc2faabf6687bc8769be43484f2cd3c7c509f7da8b5ef6fc1d8bc19717076701d66bcc3b7d4eb632ea5c9fe435badd884ce9015e5d7e228d931c89867c4ba20bf6e64e5874fd94aa881edcfc084281a12e3031aa4e5bfa38f0545a492ee0d3c4aef60a2acc191613615cdc24b084e420b31754874c9f2c7774e79cfd98d06ac021247ea76aa8b470735a73faafa2742eead0fce1c29c175e692c02dce93f296be0a86319e38d3bf2c7b9fcd2e504425c3d1fb32017399d6361a007e55f6449fcc3e65f15721d9cdf567c061868e8c748aaf73494c87753b1383fdbee2d58f55c6368d4cb124eb5785d4f0db3d7e4f089eab1a392a8e569e83162f1a0fbfe9083462944326b9610eaeafd9a7a3523446b7bc876d9c3a89f02bf6c640aa804b5665eb0adad00617b462e30c88292b19204f87d32375f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
