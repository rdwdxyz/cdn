<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4897dba51b559aafbc9a58170371a8cae811f1665e6a2ed50a352a788a34b3c1d4463fc768b7a2ded32b9a8080cc8cd10b5e14b9d72addf4e105e2037777d25f691ebb08317a2c093f80c7da4d8fa9499d6d4bf21b50620e6aa975e5d6f27580da87f1a72855d3d281adda5a5e77cb3a0d74fa2434b160fc658d2468226a2bd6909afc4c065d60ea742a42c8407483bc5b09cf1df42be7e87de7c2bcffc452f6c10d549ddd6ce8bfb04ba84f3cb792d4150f9074e7d0192c31faf57f2a79f5798f66a3dd31e9348d5d81e46a09915b7414cd2b7050bf73628c58237b1f8430b663d423a059178ee2fc66ac5a584524c3c61c755bc457f854b33120d2a46165c52409dc6f7f1dd44a1e83c39177325814b7afd4210316dcc8ae6c394959215e4408e0bb676b8e5e36a03fafb6fcf452ccc97beea42e2e53197547897f51e915a27c595090d4d74cd5f108a8faee0d92eb5ad1a1d06f1f8b8b5d7537bf669f61ecd9433e65dd187980a9d03347f9e5a87695b744aebe96d953e386e65e247b88ca46ebfd1797a5995082eac48e2a735bca3c5dfca987774d117c99f3970a630cb6291a8af39d88fef97598bf71670a6abe90b0cfefa30c295a7b392a2103a59fafcb116b7a24f1b121ba48f7547db20aed4e0be14448a6c63771fac097afc8090975439f9a15f1986f2d2c84895f71db477b9df7221d6e9d4d3968011e41c712b8fa49df2841179357e8f2bf70ae580d012517be86b86cf292be3418447d89e14901ba36cf29b275146e494bac26532ac1489644d6c5bafd36e0ea66480a8a9b4ed97c3e255e751fe0ddc2fb86ce3cf5ad5099b6c96355c5e15f9d5969307cbfc1e00bd4aed37ec668a71f2fb64f9a72fbc2307cdaee202a734953101c3cc93c9e8fb3730f0d20fd75d6a23f76ea1c4eb788794df419a0b5d7998b8ec8fda74c77bd61cea8037a2aa6931d97b3e4f8f5482c1500ebccd28f77e5b0b9598f68ad7378e46d6c082963525f64c2c2c9af49946c95ef0fc468f002427f2a8c193920e57142b521334c647fa44210cdff2be459ce1dbc8bb62c84253ebb7e6d3cea24f26ee25835914c2f2ae689a4441499b2583b1d3bbbba3e879ab704bef6e28f412c3c236d0cc0916fcb00d6190b33ccaedca1001ce1a6d8a844676f55579b7b911738405f3950e2cafb3ad66c0413d8722760bdd007179543dbbbd2d7f4a5b04590034323ff9eb9b5804053ccfe061683ec55ab9cf303660a6c7da33c4e2b4ee1c0efa3b86ad86fb933809ea532cd288b417e3b0b89e9047802faf8fe945609ed0ee9471b78fb5ac3a254f5474baac37f079a73d7d20327cc655946f5c7bbb7f8f6e8da37b35497eae0a8684a97e14b20b2e10c31265548b25f71037692cc0c9341dfe2f3f8e76a8d94bcbb04e7d3c4fd2d07db239c9404e0bae38264b3ee0dfb612fa68810d94fed3ebf10d03e6f7985fa3f51c8cdeb67efcb2f65027ade34b34ad32f5e5819eb3bf98c218387c38fe80eefb4e74147a8602cf2b3e8a4ba58671a51858586e1ffb2c5994ba376bee580538be308bc4166182141de1821ad49a7893fae8d52f4b980e7cbd92341f3a6e195f828244e66e8b6c83781dcd0cc617e5c44e23aefc39ccd15866353c73bb7d70c31d792090e4a858d45902ee47d7b337e8a3e70f68df4a96cc1c9a1caac7971a04ab423ce3f4c396cead10246b7837d3d82e596b404b7bc4f3c8cc401f8c220f1784f7c87ef3b19b386473989eddc6cdf08e79ea3e900d9b893c31792e11555d199f94c7536ec6ff1e53d894999dfe0ecd7c6f0c6c4049a8f5feb0aeb04f85d8efdcc1bfcddccff423128a7383d11216ee862b1342b2596edba9fad70b1120a83efe7e9ab2ad2e482ba5fca56e5cefe232ec119b0fa3b7ac6461c4fd2858154e4079cf98173800d90510da223249de895a87c08b13a30b279c87da29489f2521d966caab776978ffc1ca7365b7fe5d390932751b7b06480550d0b2d3fe28f916f638347fec19f9033ef4814ee068fb3f8ca3568d83121a25f23649f57b9a72e9980c00732ace600556f57124d91823bf8d3bbfd4bd4efcebca3aafde6fab5dce42ec1cd78d7fc5e72084231940bc663de818c26837edb1473a6c16fa4addd2842124eb014e60f2fb571e0aab77b5406f84c043ed0ea49b81f93190f6d4da659f2a3f86f1411f1823a07309ac5e4a83e98e4538e42683063046f9a7658e87898244a862504254442e0d2d79a5b74a713e38a8e8d9e8db389c92ecd2393b67cfd8c1288cfba9041e12f3cf0cac350d0526d0d28a558b40ccb14ab4f90429fe328ed4f8affaf56212bc163800a16cf4f55e980e820c2cd105a8ebcf6046a49c3ccdb54e02f8da2eac883b8f3383fa77815342b89b38426450c5e1f5b93c448e6c5a70a23f1ff9056e0f27843b5bbc2ae03aa1a25795568fd972922a24a6d1e379be7980a9255b5bc2ac478a675bcf17082f75ae4714e211c674529fffa0f98616f2cff5fb4d866eb1352b06c57679e275e3faffc9560798440b74b22246bf3393ba1edd2aa17c55b6d9ea6a5a9de823b23416adf63d83f52bcb44ff150aa7ae79f0698b487ccef331e9e3a08c766cd450c091b059fd05429d68edeae5206d7c99549cde913e904288b68e855ffd91aa8ed116ad91eaee0080dd939d38fa80d097aafe85123afdd04a3d82c89099f5582ad9cbc8a99c32c684cacd547ae9dbb0df461550cee8574bcbd996301ca3e9df9f248d04deadeb6e00fe41f0beeaebbcad32cba5b648b81427ee091c4665e10d64b0b343bff619d3cfb6bef5f28e57502ab97a9a5319a0df885e9f4583bbfb857acd94a72f89f60eddf7710a9a919d2edbda484b9b1bba4885e8aab0952740093a2ad7c40c47ceaae323247dca296d224575ac7f4f2b6a6deace2e7cb282bccff6de54ce6bf1b88b1b0a52b1a0b4109dbf84d19cf1901be7de0e3c1fa7faa5fcd4c51cc19d87601d0fad6ab74b0142b59ff1f6dbd01fa946434f57b7f43d1963909cb19486b41f65c40e9da848e89c94c324aaf7658e7e7431a14567e9be0df85bb57de0d1954008396db7ecf91cc680ddf592961dcb101222b6cb07f033e7154ff2f74fd5c03a6682ec32795e8d03664806e0b445d41335db122539a476f83a5c983565082be689089df7c24a77e1b79724e4553eebc785a2c0d9e11d2a515f92dea7c6554e4904fd1fa657b7b0b572349ba04a9c7888a3ecddcb63458fe4c9c4a29515b33d801fcf2c1f55f6cbb5b6b3ddb7e227dd9e843172fa4b7d8dc9cc97475010e409fe19b7ce0f1b174b8fb9a7bb8d22dfb932c69cf7ed21166885de6af391742c0e275ffcbb169deb33fa86c4d070d1d990d39daa3d93e2ecf3401d51bd92d0a92667cff4d1939c48ba2e9de2f1ec18d84c03edfe6742f918979bebf944818df552171f8dcb634f54f8e70fe58774bc95ea0987f3422657479402172309c9f0234e0039f6201bf1a4d027dd52ac0bef2700871e10ec997366d795bcc926cd774641b39ef6139b1ac1a6e0744eb262f29fc544fd01d3795de72211f52460e82b543b96cd1678c4168913fcd0cc9deb46627dda1abb2f3d563758bb5d805c1bee470618a360ea1d029f102e9dc00c34978afb48b9b14cb7bf5a15c3211544bfb0eac9aa3d7e35d317718453d62d05989047738ee6e8d7d8cbd164e51f8aa1bc3727d1c13cdc2eeba909c2aad27f81280550e97894d8a80db70b33b2bff7c2807ec8afa519a6f6fc8fe0666c581456896332edc1a09811d236072f26a3aa8920164b8ecd8d7393fe92a95864c17ee2fba03f42bd9ef5bf6e29d3fa27f15553ad99e9fdc34bb4dc545d6d6e187a5b3effa4a74c27af69033f94a008b712be37e71298026a9c65e75505f6c65f58c622155c4890c6bd157318fd4d4ae727cda596748bd1956e06080ca70cba60a17af75a2ea3b51dcbbc1e779747f674a92abbedb5cbd674131b3f6ba9a0e63e86d847082676ec013b4e117185daf228a40ccfb49f2c67fdc8c171da1420daee203590b9c63d5b8c92ff4bb07a52671f8bb0ec719143af7388a1cd6f80b786547b2c843353eca3abc9e5d434af87f8a0f18f61b2ed2819d52aca735ee8a08ad2e908c509c346a8c853fd7500ddac3ab819b55497ceafa92ae99dfe50af27a356565ce5aa8acb440bbd30a05e10b96d971b2baff56d84ed8b54667f7847a7cc98a54d9424c65d80d1168fe8531b4704de86b13ec20341d8efe0f903622b4e8f4d5001b3d884f726d5128197aba5fc4e8feda813606105723d871f13f487277401543df2647d67cbfd2441d11cfbba4995eae66e256287e35a6b017eafa926ce34b5f4673c04ee40f04b7b59ab9f94e8cd28f1c6412ece9aa2436ddf3af62ba642f8ec42281851aa650f508254de740d3ceccf8b01c73e6bf4b1291e89f4aec5edc6dd4563d004f279ee9bf3f1108270c955c1391518d48a33f7959ee60daff0a0905f69ac4bd51833dd7845915c0b934c4c256833e0d9de70d6a39c7488191816a85d99273841755882587443848f49ff85f72296495d7acc5abe75bba673017a18bbaf7d46215f38153bce840a93c045729ae28f7034a4593aee71818fa036bed6f7381c2ce798c9d17e2c1faabffce0ed6013ac560a28d5985e407839c890d954515eff728d95ccea4898aa53dc1c5857230f94f75c01cad5cf7f7356a9d22f7e952f61546fdd8c8366627bf9f7561aec47f037f8dbd5b8765ec96741a77097e2ea7b359798b8bc1280dd43cae58e6947508274929aeecd605de09a55403c7ab4c9104e2b1be2e46d5a791d17c61738ba7cc7a0049ceeb3093532a447b38f463d79586bd7f3c12d36193349c458e6bb5924a106a74ffb6c4eb6ea28a4174341e5d352962c36dfac8e086932956c23dc6d8f4ed273bbd75e0767f1c35715f9480b685f027051c15bd7daa1fc2e1c5bed81f12faffc1bd6387d2cab8b60478d923ab08067a3522df9f7415f5bb744ec9d01bcc549d6519a5630c5eff8624d435917e3df2d15daa3b1d180224ef922c0b718d94ff7aafb63d10035eb4f52ea86356e84cd195afa0ce10401885b0a3a3444bbf808264c743569cea260e638cfc1033ab92e384563efc4d1e002e810cf90c1c9930a4bd92e55b6e8a1102e8d48d246f9ed1c1d4d46d2520761e1994794279fa3e0901bc59ae0d8b6cf1c49cacb8ff100000db6d86e03ef121a1dd8fd8cdef713b98dd0c87dbe6beb92316974da57f2f1bddb0108f930d4c89d742e23a4943d95aef4ac6bc11935229e4cdd5dc179a6b1779723eb1b6280b23d8e534f375585c4e14e0568d02d91a280de96c4970d154b9ea50a557a0735af830f48258c8abd14e26346c44b59156bbc86ba8e0b226ec11becdd97b160758ab754337ed4116d2edeb66cb8fe94a43c079d24b4281a9c8c60ef257f3bed2956e0d68eeca15de63218948bd1f153b2421eea347ee35890daad073fc33593c6d2da505fe1bc28c419449babdf9c82c602ebc62830e4977ca81838fa376f44991de3ea935fd4bb577a5892a87816ae34a4f8a7a1246331953ad4dca23835962a3c8e6382ad830603f2d202850399290cbf765ef375561a18f4bbe37ac27212de20de39908a3c85be7cc358cea9519d03f0afd8e06a9ca1e426cac2313b4b54fe126bb397933ca98a15db6401ff61fe6568a6c329e81d2487e63d0380a94e0e2b4e85bfde5ce161d479a06ed8815855c0e03e66e2132c388a79e15db09b9ff631994b302ac82adb19c02e499a724952951547630cc9adee87dc1f95dd88343a7addb791c9dfbedd48de329b2d2629f9710f123eb586e91f64ca63c9b31d0565da7cbc3335af1a6c768488d376cf2214fb26095306cc88486a4c436970a14fab08a398e1c45923ab669589d67fb67513bae726a9b66bca6f2daec74ac74d0cd66a1ff6ff135323efeebd060ef434b57d89471a96c27bdc50fbf6e5576725e2ec7fcb250105dd3fa730574c3ea748136bbee7edd1cc1b6e7abaaa103a302f0229bf58502bac8e5e69466ccbcb88b3cc6c3fa7b63d25e1d0b524bdb95e18fe4a45942bf35b07a489c8e5d98cb2bb62facbf6833ceef5401874aabded782b65dacb23780734a9ab0a7f4fb0f5e69d4e97b7bc52ef6989363c1afd594c472203753fdbe5ea5ad6eb790efe4d7badc1f8ce33740f4fa0b020f116bd92fe0e6e31ce7e35d8717b5a8c471ebb85a9a8902be73f05f9d8eeb6d9b2d2d148b1b6ff770caadc03e04144970c17e55972a8a34f139f7f3d4db36a87b2c85df70ad082e3ddaf1da85e941a9e47804b8de1e992a529a6cf827d0dd9dd0e71ca906dd45d35bf5d94fb1bcd3159719c91302897896859da2d8026a75ac753f224520f87ed4d1de5d592f68cb16bfed67c50a823d806543b29afd8909661e5cf2f84776fda45fd46cea1bea6d16310a1d3a915eab45ea935a9ce4e1864a714a5165851f7e91b618db676a3954ae591dcc920ca1362cff128f814be3f2193a4334c206d34ceb6ae7d6ab64f683ff4af881c685e9b90ae1c5a4f0ea6900f7fda34976c73f76d2adb2d5a74bded591631ff51a6c2372a1911cd535bf588cf90db40a85b7a054a723997cbb4454c49cf2ba1da11f2d02440cc8719e438c9d0e851ebc0e8e225a175612491fac7654241f972293854a6f083ec38f8a97989ea381576e57a60b2233a9f4fc3952b73e351db21f36a4d74ad2d700a710326c668211058ef8648c55c792f6b4eede8e6ec7471ded4d8263888d2701a958aa9570cface312054c00448d7e205857d5bfdf404e34815cf7291427d24e59fa3b6b920ae9482f9cc09c578bc1866a82207362c7eed53bf9417fd29cc23b71223039610722fbc63ffb124b286e4c1bba05e022c2013c5af5c54eabe20d4a4ae6ac4769b585a1d3940ffef94a2eb177329ffd984d5255d977ebaabf3ce9d2b0378df9450016391c1acddce587a52e1730852f338ed5fd332e856b7749e3c9dee50b04e5e323a75ebcc56323acf85be90c0c68a6b55d75182c96f8ff9d1600a0fcc3aabc3810eee581d10b40224d1c2af275d3fc7e77155d130d3586bdbf69b2bedf727a21aaa675353845ba036ef14f93de4b7b47e2f40435fb52097c44551c79031b5cd0caf5a30f1e01458221a89bed85f39242cf98384a15d1f41d4f5aed297a2de08a669b335c5eb1fb0c43a00dec357a2c7d1318ff2bed4563154b0d99e02ff417e8d70a1929378dbec8c62c3e2b745c530f9564642a23a930ba47e5423aa43e866c4d11353dccfbc8dc2e2d374a414bb877c7b34b4bd34d8dbcb3387d9d6cdc5d6d6f0c33d06d46ade302678782b0c754c8f69803f87ea26a0c07e02952633184f662526f1d5b367e26abd554749b67e7ece7c20224d2d22de026311e53ff7e74df89746f324498777421a55ede2c100d19789251737bf16ddf7d64e600c3e2dc451889234e99f0160489e244f80bc9758009ec070290169108eba09d644f94e0660ab3e7b1121f4870702a6942776fa64ff1f3c8f837ce7bbf1e3ae257517fdf00fb2b417d7791c97f0e413d825ffe8aeab2e3d2a506a1a562c5fe43c1a141950eeeb8365e521c21fbd0bb5d3ec0e8a2917b88669f86c07034a841741ccffa7f0b952595c0c8c240d1100a76b61e615cbcccf916acb5c8fbc80d4ac85986ac75c9a729e059bb06ccf39a46c6853a1a81511135979e01d8b1682c1457675b3158f837ecb972012328743c70664ed16bcbc57b83e1c593e89c0df1814ec342cc9f62b15adc1c9dd86fdd345a72977e37e55bb816d8f015385f9427265f9a4b84a91cf8d058e41df2eafb1946abfeaee83bf96118bb355c5188f2f3b5f293a0ce9cbd0528375330d1c062a54ddcda03eaae4d3495244ae967f8955322529c8a1b3de6f2d44be9552b6295ff981d04bd2ce6a6cac11af471059a4ec70097926af3817fbbd43119751dcaa4cb5c456a690dce888a4f80d484908c40f7ad866a1168c999e6f96ff7b49bfb07f8db6399a1674b6b3de6437146f84b629db8e2c9ea68ead8fa36388729891e26dc100ed30b711647bbd6b8f0067805ed6be71bd0395077696912dd986425d9d8a93bbe2314c8810cfb2dc0c56770d71fa3e967e24be88b05dc72b5e65393bece4fb1e46ec0e0511bfd222817eaefdd6f4eca4556df54d7ae51742eb9c4441a9c49d0707b255db5c0a805b8200a4e34774b202f45831c24c25ff694a393094b436571cba82e9f8182751c9dd186ccc9db639a6eb24d284ef9987fa6f50bd38e73cffc265fde16d483fcdd9e0d134992fb4788fa324a0038505eb12340ba2537a40269e64913cd4d315d8b3e6fbb0aa8cf86c28b5e042c78e51ba046105603c129613164a5d14635d9a82edc7b2bf454b8819cc271cd2d75edb8d72cbac16d7335ad0321fcf6ca6e1beea308fccfa8af611ccc00abed979548eb4ee0c754a7d1741ab9ab195598f7fbdf30e8033d05e5c1e134f7cfa275275897c2bd3658cf5aae68f18988240bf6f3480c0de2ad79ae597748d87c21f1cf390a9a9fd1b46018823392b9c80560ac06b73aba96ba7e0eaf9846a5ef503137a3c377a5a00fe641366cd0091c9bf328d1b954cda0c96140a8c001672e43e34632bad1aba195733ce2577ceaa03e9ad0513c15c1caed80428fdc061203de7e8c637ea2fea50bd321c816bdbae74ac4e3fb7396d9537a556cabb9889331636088827a869142dea41fb16d3cb6a9e2c8cf9a1108047df67c7f87cc98c0d06d573c65fcd2eb62014e2a03cc26e2663f7e3adc920d4ce43ebc1cf30bb4f4410db094a212040b2a40ec597c55ba87d5f842d6fe977dff756bb600ecda0774858889ed386b51b89cd3da60a3ae2f65e0866e7a4015ddd914536ff98dde189556def105165a51f4a8996af8fbe67c38c11e13fd1f8d5fcfef398df56328a2586d47377280a49e79c3e9f1e8c8083e51f9376f4f1d6a9448209603282cf9deb9e82615311f82f7face6144ec5b68036c262872cb930f6fc436e31135c7e6a359ea7ebaf904261b2a39082c95a9565054db21a393cf0aabeb60b25c112b3c157ee36c7d7b1caeed9dbfcc6151a2f32ee9bfb8c383f519430f14403aae382fad2fa9ce22d89ff85ecfafd669de1eb0cdb7c0334be3018253818dfcd9efa7dc605d58d20cdeb9ce3aae121ffdca50572282ab388ef2ff0c7d4658b77a57dbefb65fe52a24c1bc33fc6e53c38ab3b25e9df4ba79ec4a2a9d8154d89cd38e1fab42aa8552622ac05d0033c0d147be812f2a8bfa111f6909d57672ab197dfe259b1d4f83ec26a90a050bb876facb2e8ef22aa3c3b648906b3270995421ec478cd0ae8b6f809033287fa0896a704cdd4db973a52518fbcf101f8f39765541fff560e3b5ff0aa2fa0434643b4c51701de520d1ced08372724a5d50eefe1ed28f0b868db0c66c8e79b8238c049e56160af447d1e7ce86640cdf2375c78c4c1b673ed89e815f16037ffea012a26c154cd4337851506c0cda8c575d12f7cbe2625849d95cb53e70adbfca452e669ad2979869b4a10f9618e424e8367303438cee788d21359fdd279f3324b7b82d26bd1596e67e7abbfd0649d2db24dd513df88909873ea075c718f1c32a193ad6171b0a4caa1c526568db84c49cebbb3847fcd63476088c24e4f02468080df857383dc36a877445d5020e531100b396f6f5be40f98876c4470577076aad7b7ad62426a98f4533eb3372d7936014e232e59f56e9cbb0a9deaa7a2a5c9ec0d07c379284fdd5a0ccc5ab41a927d04f6abc941d3c8bea18a05fbf446683b3134fecd4956300888060c7b8216e1dbccd9a5f3efccfce734ac6e688f50ac79eeff73f03b41d8046e3504eba5d0d6de51a8f19932bcc8cc62202efd79bce428893a1ad04e979f7b5e06e9c1919243d7339f99ee5c6d58e3a3a6a34a9228f4097f6679b75da40bbca267ca7ee966899d147e142f01c61c0a01a5678d7043d96cd850c76e2b1ec263ada1344e1235159f78d27b09b5e014973220ff7af316f32a898586e280a3d45fd5d402bd455dbd4419040b814257eaffc249ac1554a39d207e21a35c71278b340106c279bae4450934241ede6c351758234995a3412bfdc33a103cc24f922f12c0717debb330f3a2f4fe57b78fb67ffacefffb3e05e00a3c8b3defef96392f62ba21bc433b4cccd03047c486137dbce384da15fbd423e813db6dbc0d98df514e7fc8718a10bb2396cbef31fc29765678713cbfbc6325d160de55b54b6dcd991cd03e3b071e5e0ac7513402f0c8b177b01defebd58f7240c1ea59bd6667eb12b94d78eac17684dd6b1aeccee70e5e11a3fc3f73f670317b0e78b033fa98459342348907eb65942de7645ba71c7cc02aaf6dbe152fb46bf8a16979fbc8bb9ff08cdec1262bbffce3225b433e19d32dbaf18201f4cd27b7a948c23da6add9f5304e31c42ac7d17d7e9b9f82cd91e4b89807628d7cd40f8997fd625a3f407625d9b92f164e12ae8e67df187d915720cb29a8efbe0e314b9ffcd6145d1195b1589d9cac0df62ac978025f48176de530f6030e51fc4a2def78164adf10a4fe11a2f1999e034cc1ce834e00b34f6ee6611f2ea858cae296a3b80df24b3b06cdf26926cb922ec0e17c548fd5c4d9a243f2373cc1f2040bd27712647a81420f42654baa36e17fdc7a15eaf20162b7ac7863085a92ba0c98e7eef95d99063e89353733fb4e7c8cd494761805845f0535f387b5415888fbb3c191c63232f162524feb0a3670c5f351b3288f89f1aed810c51dffe9041f7fed33677d5c4189fa871a924df4063341d9c0be8c2de8bf4bf671a1dc5dee806d3266292e3a0f70d00cd591a7de87a37fe6f8e132fa79cbeb1108ffe152795a0e138323dba36df9fbcfcee937851e7287d929a1a82aa5540e7fc4eab2839499902b5520d76d9284f017f8b98c7a1ddb3ee79b5bdedb02a07a2e584e6d3382f03f3ff4d1e856b8a3ad1605ce822c6e6fbfa656ad15c92ea888fb5fd918a0a1a204ca416b885d39b62fcb71560b6591c1bb7d7a4b65e2e5fb32e41a0d174d61ac73eee7263bd00a8f0fb8f569979f13d3ee0f772388bfc046a1f2e96325944f2444bc55fcf72b30c05ae8156299248a573a8526fe22caed7c2a3a5b86076cdfa5b839b9e24a7bd8f69969ce2f68004bef46aeefd819f8e0fe03886bbd6e4a9c93d7cfcb0e0017301472bb9ab1cdfecb26337ee6e44a5ea60dad1cf2c3537c27211c8f5abadab091f98dd4501aed717ff32d7c345d24b7c721d0092d33ccb336c32b1f9e1d0c01348013d4b77b4660805a5f19c45547b61d1bde367e726f2411638451590e813a0d36a3104253e9bcbf8fc855eefecdfb4915da64995b745cec82b5172ed33a77e9cc4bd12d58f1fbee850b2590897f1f4735b27e06c8d783f56d2d1f6b60d654642822c729fd62fb47b042a4c20e201a74b3b5743a26b623638d704ef897c41df5d04a84644df68519477f0021657e687d94baec7283808784ec8ff6396fa81f4633df9b87dd9dfff67931b2d6a1db89dce41b216c1c4614680bca41ad1bc64a8133132b1f93191f9beb23e3c34e70cf662dda5a08dc1a447aeb2942727017bf4d75e4e21f3e90cdceb3a56f0ebf93da5ebfcae3b8783d638398f51581058862cff1f7ed465923384a5e8bb7e989450463118d2e675a56563ac3785a62698e72dd0c93d4e3f6a7d4adbbb60e3be9d991c3108bd4be29fcd22b019dbe710cd1d8ecda4534c6d49c7a4eed4a36eb3b00a2680eb6b121d4690f4115db9f815436ec4948ba96922303b4480a53b7454c8de202cb46990ae666f1cc1fe54b0a0805c746b80b9c0e51c1fc813ac101fb6642c6f2e731588518c7ffc4ec480c2d1c42ba99be7e2abc5cde995519bbe27d05f8fbe08dd1b5da45d398039fe6942fdd45cba7f9e6ddb1021e8cb5af3915a5058a1cec498547368ba19e24fd88ad0ca06fbca8f01fa784dcc4cb46a43099a6ed77a76adf6b47dbd43401273f5cde61e47b9ff5c1ba9cc423988e990737f9cf0e3903d84102b73c1d124cc4281abf2b568b47388c5b7404c428c244c8c1bfa27442d56b6a08a477a7e06c088226b308abd529193650ae840577553a3e924c1051e3aa30710e8adfaa9c26b9e326c0bd15603402e7497f690131ed707dea1c57ba6888159d7e7faef5e8f371be51a09ba286de22bc20601d1b779793aff38d6cb475e2c8c39b9c0f927d416b61ef2357ef5438ec1e7410c4dc525ac43faeeda2b3c50045f3a2db413f8d0e1686d810fc9c954aa2edafe4617192419d0f51d3c5e9ba5d9a238902dd06daf0b84754ba75aa026f2d5272ff1e4f8b74e345a611556824003f401d0b720dbc04abe8c8fc159e1c223f30f65be5ece14d0c6e5dca84d356c4e5dcae033b7bbc6a0983b5185cc33deaa99b03b178b573875fe1dfa9e0141855c93a281f430b0117c66addf1922e601f137c6b4adedad1fa29806c1a1b1e993d7eae3285903cf5d67878ca60c93151588452961b6cb7d56629369aa90e1724d59352ad8be038fcc5ac5f89c7643a35f0ac8b2589d1e6cd7f89f06b199197d53fe3525ed93fa61330ded8f6ed0f0106c9530b96b1da5dbbdba6012bf26d1564f5a6b17594ce0f179e3f8dd4bd5a13367ed99886d0f0bd9ae935ca74ce0eba2ae84d13c5d20ec2aa79a0d5b3b0ac8d30abb0bcfee713db0dacb60c360c36b362b64babd7e8c2f12f1ed8914ec88e95d369bc874511b2f94ea64d40ec2be36f5d8bdeaad97bc8ec40125c08947d56b5fed57419618d4970274c9650f1412625b7767a2a3e62af9c871edd7181b360c1156b8c5c4b73b7a6a2b50bc2cd98a95d85f820ff21efcff286a74081ebc1d7be43ec8d4e577c0c0c1b1fdb68543b57784d45c469bc84c97a01387cd5a20be3154378ec958b78f4fbee43eeaeee835d8038557235502cd46de70f9fc9b8d505de1fb39af00a159191c7703495d7e15174b93260664208d313d8435c6cb33fbea379e228fac31856f86958a26cc07424480afada8770596adc997e64d11584f984905f0eb632d904c3b5a37af4909597ff2cefa04ff3227b9b1248dd4ceed9fa12169a06deccf096bed78357c43f60afc7b214ff6ce230f0703343c27a31f9c5d0dbdfa66de868fcdb48893f6283cd0edc069b68935738671bb73ef69285fe4b661a2f747c9cc46c0e85be23f7a70887bf6e3949602b5264962c56701fcec53e53f8784fd3f6b59ebabfd5c8fbe38855bbe66a5faf32b2c18e1b6b5350dacfdb70e73d3330a1fb5da5cb5605766d373f84251b7a46ae6f8f365fdbcc46455571c0909aee06d6f062e0093929d593ad8427158bb0c6d5220d6b2da1f04ed73b7a745fee7b85b1503a9dacc2e118aa90b45414f20e90ca9779c6e1beaf64ef21699066ee9287b9522bf94739d8df73891b559660a079eb604f919020afe5781de929c42336184f1a14be484c413127628fb168fd46c58706c246b9de9522cbe6661fa3177762fd3c6daac1af987d9c24ab98d73e6cb97fa9c625874fcb6086cefd7b22319956452b471cac253bf9da563ae3d69c8c15afe01e860411615f931dc4bf8f2f1d8a8e1b8390dda8fb5ace0bd49c14c2e8082ca21aac5d3fbc3167f4c7e25a7aaa3459f55377278c2708b4a66976f7238c9c1568e22cc2650487b852e84007070ee4414f43c6e86e9aed4f365ee604f3fdc56d4f6f7484d8a22947ed6499b4145599cefacb6d89f08a6a6a42ff11d39ec25067ffb64f4649f2f3705085b174df5c7fb5b5ee91721e7a1d0949b70b2aafa7102b17bb767680f8f3ec77d6d0238622424f19cf8bd0135e449c42140b566079570faeee13356f9abefebb7ad1d84c9a0d3c73cf89bf0421096b76a3ab006de5a9bbf851ef976f560b11d358f73302a8063eea31b81bb62b1663f821abdb0db1acf98a7ae3c80406e18c3d8c6df1aed41fce437cfdcfab1e5172ed0f62bb77e9ab7f5d4f9fc3e8bc1ec1e5053ff7d0593817dd046b16a0055828909a63bd013d2387ccb2705bf7d1c0ca20201732cea8f599303039419f2a16cba40fb31d06f901a0bc9578211b492248e9b3897fe49ba7d995e617cb4b5689a99abd415584a0e9089cb17876fef6fb471668771c598580320b0709f4bdde91b88894087bc4539cbd3961496536176a35d939f0205c8d3a3a72152ef0da832131e5386cb75af19d70cb57ac76a07c7e9b99557ed18264e351154c5e5710d78034cb0e362a46c25145f8397ae81cf7a4ff37a0a48211723c5414ee133ed9c5a4c96a23c48b3a6e9924843b81e6f06e234a3c01e0e3677111104298111131e453af7643b1d0e55de5f0958c81f8adf120842ed196b5b152499d8825b4dde90a2074de86313a3cfe907cce1f2d03bb0cd2b3933fb0b95a4f2f02632de2c647f2e3b9081d39542e20ed515284972b0f75e45bed67a609b622464adbd8edda342d72bfe7074ea58db9224334a00c1060aa9cf82aaee6f5f5db908f1795c430778fe0db14225b12215c4834ad028465d8fc443ab885faa0e341ba6c4b2a86a02fedda9fea513f50fd4bfb6773bcd776ff78407e231bc260447811b8023b45a72cddaea1fe242c7374758613967082cecbd1b81c43467f2b8bd65770adade8a73a8360881f31c388911d1543ba6dd0f46bab1d644817361a03b0e243a683feae3d0e70d8af90255a43272bfa3eb5fc835efcc69e6e1377055b86421801eff4cdc5e37f961caa75a30b5e778e8b060136180466c6062d137ccdc65c81211389cab6c96094d6923b6123f7d9bde3fb9c7a815c11089ad5c963eff216be2aa20f070abe5607615484d30830b8f25452ebee2f178f323013f1653e5326349c5e85d2876d992996715bcf844b407025763ec345f64c2ebb7b2f06325589b35ba542e9ac06d61c7ffe08888796f7d70ca256979ffb91bc8a60c29ba9be2c8ee339f3a7e94fd8e6c9800381ffec8b38a8984f9a505397d5acc2b391240b164153266af09e9d4e405ac6ed74aa8d43d1c381068ea4a3315419927f191ab1f4cf61d60b9394a73cd0202c8ed6a8ee7d91c8952dced5320","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
