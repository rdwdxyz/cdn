<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5dce1e6be254bf8229f0d947e9d886e13e79b599a150a7d76216ba013db05f2342890f50ea7a2c34af7c3e1c0028c68bf3ad53f0e9a9d760211a27f6e96578087b3e8729b9add065fff284482ba7fd8214b099cd055a77810069331bbcb66a40e37878c0409fcd3f1fa197c187b12a4a970e5c9f7dcbd89237b1922da2a9f7bb9071ff6867fb7ad28212c98143b6247cd1511cb1c0401ea1f29f75e904a7373c51226453edb501380b87107953c85df93da2b3679807c30f35cfcf833f48386a2305239b8b21e8339ce43f083917a841cc571132d0c032b073d06318e2931e2bc115e43f283f7f65a21ab6b88ecd0766e141039e07404278d3aba7d956df1f63550a6783a9c6d795bee9890f6ae4bdc531625d389c38d85d9d4f06bc25a2078ee864217c657c325c597b35489608483b3923f4edb0cc06b3488ecab165dbee3246ff5424cd1510264ee8c50bc2b483a712df9dd05b43efdf50f8cd5eec2c09a5b806eb451f821ba0f80cb6afc747989bc2a8299ae9b02e9a76d8aff7ddc9d4633cf06f2b62ccf6dfbf8be69414827c44aad93a6f1c47ad1df824b3fbd11dab1cb44668dd14e6200781004b67b5fe02a2e56d4b368fd301db2eb22de343c6d4d34a08afe4c765e75a8a63fcac47e14120e6c6e8785b4685611336f3a69544aedfe475ae6cb5b5330bc77eadaec1c6e93a8099a5b524f5997ef2d46402f75ce8aafce7973e52c64d6cc27ac822e951532dc5b790567e08b6b73da8d7f5acf305cc36b71679bf3ed5c3ef2a27214592e0b3d42d1c8f4727beb224defeb836ba4cee0f8e57582af0f558be82c0eaf0260ebb3b664019daed7f09f316b95b240b132f9509d4e48c9d590e707d177413de877458e7affea9bdbb60fe36fb82cc2d78ae0c8157dce43e5c77d08e4753ae7f1e5e7ad58d4656c722505d12050e2d754029ccaa59b9c058d50385e25cfd46ece21a8532ec43b5c6c6fe479e0d832d0d266d69593122adc2554e0731ef5d10e0865348042079aa582cdfaab1f30c014d49d5a3c8d6fc3bbe813f4f189f8e36d62236a3277f2f36553fa13499dd595337e6f75b17e66f3f9f24f03f13301534b1148585c7cf916a0b069891630958cc529407e9df8357120eb81e8e2dd3270ea5b35d1a0050ecaed988a58dc096a81a05e70284235ad01dbd03311a2d2f5c54949136d4110e3df21c6a586ec6c496fdc61652a9328f00567c8fc641c23d62abfe403d844fc3e06090d63f094555aac32ff223970226898d5a9b2f2c606e34ae5331f5e890ee991481a74c0e1bd7e4158a39485248fc60b6ba39bff26393d85aa5e1c932581b9c730a2a3c56926c22e38ecfc953cb3958094512a48a0f787198a0b49992a844513766027515bcab1e3c9febc1f1f0c82774bea9d55906e9f34ec4ed94abeae35419e6e2fe9fdeb6b6f4f48586e637b9ae04c3b855812cb50e7ef5320224b55333c33c28d62704f9ee67a2a3b92e2d2817080d17e85038ea69052a4cfc19bdb28f8aab9fc24032ca3ad77858f624c12e396dc27942a89a81dedba1674bfbc0af1eefcd937baef6714b05a18523f3c8b8e00887f00657044a273e5c445bebaa5661c02e0c011e8de8c6952375ce24ef416b80a02390fd988ebcb41394d6a8ad4ea8fc8d7a45e00eb5d18c73635624bed8b490907dd1132bf8f22e254b98a86ddaccef3678eb77610aa94a71ff959b803302662cd5f2681a61fef29fb48d405676f2f621bbbb72f385f49458bb814d4cdccde4904028bacffdcc196cbf41c45624a1b70459553272821bdad6211f89e8c50abfcb02a7b2aa85d5e4aa8022f6e616fdc0b7391e2184e084a47e4c533dbeb8a3ededa9bed2e3ccd79b639dc34559166b57955c61c1a36b4b0e8b7ef07e8619bb05dbd6c380825c7a7cb3aa80191ad7ccc3eab3d9a2801eba0201b3f24e4ae3e9ac72a466c606950e988ea61f6a429706bc341bcfd9a7c0bd3515d0f5ab2084f6d9e097bcd56df25fd391adbaaa7b2a14132acb4e75c9440c2d7e96913394e3db440521e2ae26fac1c587d925f86cac1c7d14e9b05212cc6e9454089757ce873167ed524fdac70068b942c65486f4330146f56b3c2734b419c3286b672091bc5b3dffd75a423de297f73453d4c2c7d62fae0066c55d13865b21836fbc7c3feac2bced972bd130b4cd4163352cd8ed330f3fd117d424859b57a2376b9118673bec8ed1f6f1da068681560b54512b456fdfaec1c76f902effc6ffb732ae4337ac1bfa8b4ad84398a3fbc50108fe0e0de3a7c81da8c48e60d6b557556400e2c4869cae585108ba453ff28cb7c8847833c2f232ef8a529caef6deff3c7e0ae599bd162001460419fd4269fa16f7e1b6c52f3002dd6c3c0db096b1db5e7cf623f503fd54adb5cdfb0ce1ba60bba39bccf556a76080a92e54405945bd6670a7d4011e8c2ff019f2fb718fdf7cc2f44bb7c0f89e92856591e4437736df6426eff0f7cffa25628b3e9f81611ce72518e76ae458176e24936e5fe9bb41e8f1452b2964a8968b8a899343c52fd4ca623165d3bad20de9437c9218e32ccf08f13af83841a3a6bf3ce1be00b572e42befbde0027fb1cc1fe281ac5766e5e41c09c287128b71be78d65c7614ef4237554946046cf6d1ac21985e94376d4a6ba2899d1cf266a46a05c52d4f38d6fc0b67810193e5b79b9f3bca1415139f6bb70ddc6f7aa804603e43d23277becaf2a0a7c948649c212d0d48d91d048278c8143b9843f02d2056569e24ea991fccc9842b8b12c80c9cf9971cbea74940128bef98de2ff77e46181e242caed39a0955039aa8a7e3d13f16f1bc0ebc1ab34c1acabebf673b53ffe47b924d23cf0404c8cb3117b1158c1a90a937ad7f247b59973bcfdc2e657664e81814a0c827b3693aea344e81162bb4c11cd7336c2428bbe5dd6fd55b9b4e7885f1dc4ba78fec1e5f935a7499f6f5df4e5f9cd1ca39458520586281bdced1f0e4802f1d2f77c041391ce5859fda7fa357dac5307492cddc53027db84be61b7b423d4f8d206aa3b020903102ad1f6f9a42295898a7fa3895e7292c26c15e8f22c16b4874471dbb31b3730803c12727a38ec7d729e23d2bf2f84caa496eb6f0dc22ff1070586f27f246ef47b5573696d0b609cdb6bec5cb53dfd829127fedca8dc621d0595e1d41b9d3d504015115e63ae8e819302f1a31df62150e0e03ad6d8ef14fc83b8cff95cf85ceab3cb07476f6706581fb41c8134264c25c207242da0131ffa7ed2bf06836d561bf061f4953e47d616e2d5f1ea1b2bb952f1659b60b19a51100a73d3c7c4d14f69bcef4132403dc53965242c3543f3f8be70304e5738d3d52b160fb1b6d4e8cdba3a04d9686d256d59bdc6d564de8de4d5d68a05c0764a02e681366c5096a82733d48ccd61a79415a4f0c35a00bfbe1a1415189f45459132d29bc34d3b0138b1e4151143f4787c3d31d0513b0c12292121e0b7c0fabdcce5c33e76f5e46407f2449491054ef167b1eabcb06925a255ff0c3f89934a9fff702c25c2136d4fe4fa3cfd3cffa48e3cd102d6f9224dc08b46bd9f76789cfc1265ba5a27bc80d8d3860ca276b7981e8b0f5d21b4ecde83072b672daf53268d401e0682595fd74dec366bd8e677b0c453ff0d2cf5e48ef9a759ae19958cfff9c287e46b1fbc8958937e430c5b411f57a292c090d8e2c0df8ca27f3b4a41203f9d90e0c391fcfaf46061d15ae9854fc1386ed25a3bf56515497df366e73afdea230af9c9215dc418c6f955ab33e50a4f922b447110b37502b5899e68ed21c4b7018f51158377c2a4a1a8f7639ea881357bf3b8dc47b65800e975b989a9411bfa5c41578c1ae3d5d0596536a340e55d96b9a7f689743af9a5cd34bbe9f9e95922a0cf422bcb477f7095d134b674faa11ebef1928ac06c5bcac6d9d84844cd252796ec1a8252a798c1f243867ffa64d111ca47fa26b8bdd76c1daad7bf2d955701f43245d1e4e4da15a4373ba5a93ec78b766dba55fce8b604cac3552040e106f3156b4f829277c24a7c98e762adbcdd7f42ac2aae9e4408e99103cbd7c797ad32f88b1e842683450a585307d0f0d66b291c82f87da8740192c8f0e704d7dbf8ac76035c9204821be198f45be89cf8413347b09ca051ecdd3b456d57a03fa1cfb789816c7f2d9c59e70c43e5d4e6734edc181e47272c528790ae012e1d3e74ef387a1c53d8b6b241382393a63d2573847ec4de24080d52646bb63a4237b0b9b3521c955e8bc5356f1854800131feb0a4ca936da2e0d611a29e7056f6bf997ae75f8a90f64cc8f354de50f9d61d0eff3009c0470e0646f70ea296b2762a5d0528125ed72b287fccbf60764ab2cbbd01eddef4022bb70184894d427d3a1bb422b4bfd03d1d1527e028959dab2858c5378c3f73ca418d93deddcf9f9357e725cb7bbf6be6e2aaf42e8b67d6e3654162847b57f3f6b8bad9f2e27c0887011f1a1e3b1fe50a8ab44f6c6583643b073df5d5d429dfb1c0101787d3fe655461a4eed884d07cfc4f07f6a80fb7a6c8c9a02c7c97cdd09387c187c3c9ec23cf9469dfa7c6d4e271aad20a95eb5c5803ca77c3871e7ea55409c3197bee438e000af56aff66c2e40f3c17c4d2bd02f728eb2687b3bee1eca8797c0efa89fec0364273ab02883ffd31e88b06bb0581189a30ce54e56adaec0651fe5f9070d1695a655776a8252185cfe7e45e6a558c3796ce429105ec94907de8ee8545fc610ca73dda433f2bc3a37dd0963fdf9de2deadbd02be7e435da6368c538b810065c19f2fbaae695f37e18f502ec1b5521b8ccb6f7135f3957245b372f668d6618a7d46e2ce767e0518ccebaa8e0f060dd77377ae43f0cfb0d49c780a10f63ddd4765db2af6d6a55bcaec02d4bdb677dbdbb4ac9af6f619c54346644fe4b95daf29a6be738a23f790164ffe2fb30846e4e38fec9da076b61fbc97e46afe36d14f93da1f00cb97010adc6586c3c20d1e3ad9aa7b5c71726de547447746782445f6f88ff3bd784651356298f374b2f700a342cd674d4fbc1982d034b1fec6a6e5d8a725defb665922f03c120fefed68ab3ca7bcfd56aec3bdee04280acd469a235a3889f2fd208de1478fac19c05f717c5fea5fd3514d88701bed458ea21c2447056ec0ef125b65e719e45065f758c24935d6b7b33a6328103e59ed5ac40c0515f5c7b95b4a9086e4330fa8927bce792bbcd718042aab8c4c20084afc46842caac1f54bb25e575b6e3ba93640667cf02b9a88f1d5b6324d4a31bab54fa3ff3fec50ecdce1fe378f8a4160d47fa767943e38e18251b9d64e37de7076f97aed3e573447fc8d47c47ea445017dad4253376229f880ae5371c9a683e3628a48c67138a163a6a88127e700fd3cec2b50a5e962391da488c281b0aaa531dd850aa3047ab3fa60a8047faf415a85dbfd6773337645bd6a512071ceae20fcf75d786847f169da69227c5ca9a4523116644e3b2f3d7675353b1ef65f23771f6427a45ed334fbaf090b273d2b389d27cfb3a3a5c2c1a66a116fe495cd8a2cc6ba2b122569bffac70719a4a0abe0b938565f1240c414f18251f12dfc241bb1ab829186641dc7e61ac84ce7e522929f07b69b33477e083fc9083b9bb21067f1106516b0a66829b1f7eae54ca7b7c763d4bc88b509f340661ee3d14b582a656a3a5f012b4867d3d13b58d6068af1bd8ad6e854ad835e803ffdad995b533b395ad6e717c4cce5e6f83f19019d7439d3c6c8efc868519d0fb3eb6bc07a1364db3ee78406b265e25901c9b82c837f0091d14eedb85be40f0cdab38a823fa10127fc840a299cd4d595b79089f7179b1b2686a42e8c864229dc48f0553f4a263dea9b12f93c71c90186af99d9ddfbca93c5edcd27faed592e6e0fde756aca64c4fd75dc9124f5d36bf26484d4c843aadd8e7026aaea94d2747d424a5ba0b70d7ca4b8e6980adddc3380df000ee1f30b26e8c39520889dcc96db3d1d7c55df25fa7e100d0bb4b313659e5a167b05f2a1bedc096fd65ad2a3c85e174e106273ec67515e6ff29a15dc6939135a9fb007d85fe0149bdc7cd83421e7a5a7639c65a3651da9baafd68c5e364df07797b669143488bf0110adaa29f8553d31bccca67a59c281f19234c23b11d9b53d540d1863976f1bbd2756e0db81dec88a2eab29e8c6913f61945276254189915d852b3226e1b936befacf7da234865bd656aad4d95aebef9c3c58c0589d2722020f647999209396baf217f1d458dd63e0287e263345ada0f3476960ef50b1132306ce5f906ff033187e4079fbe0cbb8591a434e9ad7d1c808c86f0ab3e6025c6b37cfb0f1a6ba514cd15b6def23fd08583fe1a411d8e24f9ee7e17abe626b337c3c3ad4aaf0f8ed6117098a3c316018132b4a568fd70d79dfc6d6814d74bb67699803e75b35b654a795384f8e29b7b440cccd00764021513874f35a2b7b2d42ae65bf9337d6bed0e62d47a4a28c019153fb8a7c85ab03a6676ea4bb9314a634c67ae07568966d4f8660364128b8c51818315a786d501e25f9fd55067e7d3897ccd5e6320eef89bbc46662fd7aae590caed659b0a5c11ccad794ad2dad963bc4aa35df2775352b0f3d3c69941fc0da14b488d347c7f716a811e70f17f5741763a4621063eaed8f022b609e61470a104573bd31a95350ee2b4270ab93ec7f7690ddb186d21ed7c7528fcbda69dfefb3d7424384a640e71e52816f96aadfe2fe6ea6c41d21dd51a6139fe4bd47bad4a67a4ab873a90817deb0c682cc1f5f36b587d457d1f44163cd509e9e0d343fbb8b6e2209c351cdcc83a3a2ef2ebaa44ba22a76a0f5b1716a45a6f50e244c38ef5290fb17852ee0892698db6b714174557a279d271736cffcb01a07ad1b66a12e04e42ff5327cd3e3724462953237681b62695823a6371a1f9ac8fac140c0d4ab1cae4c1f56fd992a8d0d29e65bfcb3a62504b8c1c85d91e137e84356bb7ced3b5e4c56919cf113d7824d1ac66b980b20b236b6b0f0db99ba4a0437c55a0f8f4db941bec452d03bdb82a1d430d0b6fa2b7a8c56c45e825889da27d4038c97867719357a68a0538da09c337f2c664bd2eae8fd9822848b98396d56382b25a8d22e2d2bd7ff2ad31a5c12abe2c0ac4d604550f9172da7ede3a3ca2ceea9cc369765ef1742ff13ad9aa577a949cefc8af9f0cf80edc2c55bdda213bca9072e3905f7e1a28aea9f1c35334d5f2bbeeea41569fae0aad0422e937c8064de8bf6cc3b40ce83d7e5143146a1e43973e054991f910f76ca1cd97c3627bc15a1c3122ead65650f03d697ce4582365e7b5d55fa29d30960cf80e52f2db8985d71f330465ae4e4d5c480da93a2537c2308fe51645e5173521159aa7ee1094998c3c14d6728edfbb8cc58432d5000df54efb2a6852528d25de28b60acdf7c2c02b6d41afdc0f2e731a8dce115e9f86f404549aac2d7151d5e6632dc98d4d1ea1ee87aefff3a1ea9c84327e5121920835f03057f18296aa8c14019364db4d749ede72fe41719aa4231ffef41c93bf3b12c1a1d20115e98ffd49ae4f7cb77d44206f2b475c7179737fc380a21a07b6a4e7f3c30565f39cd0ca95874ff9292b25b8ff5be1817384aa3ab5663c862fe8597974aec0603417f9c4f8f60ae9efb279b3fe749c5e2dd00776bad8056c3a61a5e0d10a37e1c9ac989f9f0c9f476faf8ec50aa5d26c380817fe5fb0c82546d7a817056660f873ddb69a51a2c7652c81308b8bcb5d7fda755d46a088f3d64fc7fb3626e785140e7d223c1f9f62c92307b582f21a927f6d14e77322617e6a11c16b4e47fba03eca802b2a7f0bd804df0dad8486a1b4645df7774d2154db0c59ea17f1d93462faba9562d9ae68d1c85478b29db97c610bdcc7fd4aac76fe6b55977795275f32cfe89b437406f4052652e421dfd7553c6773e01a914376341ba733b4a31bca0c715a1ab5440b185757c33263c3910f9ca42e69624b28979e09d798160e653086f2ef0af1fcca212add89f5392f34b97d7fa2db4ad99e7f3b49fa3d9fa6ff01dc4967aa893bf8d5c6d5d12d8889b5efbc6dc762b6654734e4cd0ea279f069c79fbeaab2309c6a16a52f9340dd75baa670a86d501a5c79d463feba71bf33433b6fb2698974209a107ff38feeea17c03e5b41289a800e9417b77b730ad54a5982719ba5c2ef89de40c1fca000bc2694260f8241b0fd72803cd30fe4837287580468897eec5e3218891cf9b5a69345336a834e9fd8085535d2af094994b590254e7f0e74f70c1c4f13c8edd358a86889e50d87ff251f8c1bc1506a99d5f924624c5f5d0c162cca375217e57b74cbe6604d2af896cc6003dd4cfd479908958e589841868c7db5aa9f61edbda79dc1877adc0d9640786307f3e0d15c20e55e8ff8f8e961bb32b417dacf1de3f0324b81ed043a42b0ef65bbcd3fc33137ab1f60053639dfb52d6f906da2af389a39a649fe5571c9a268ae61131f1402b12d416e438b5c4a1b75a996d6d12e277d830785987ff0faecccebd348556a0861abc372db5ba90bfe16691be2b7636e1f3c05394d34baaba86ccf307bb3605d6312669043b4b3457f5856a026928da611c30673dd2bab5722816d1b57c7be6a982c8a6eb7f74e728d374ca894a09bf1b984d2c0fb46e16fbc103c88a5697fc0c19af6709c253f7da4de547decf608f02ec9b234fdf9e0ec830232f7b6ab5ec8cfc1f3f5379333c833422cb4dd4c35110516cdb749fa7d8cde464a0de18afb3340f6bd14ba5a27178e91a69eb0d2b7632dd7d43a780b2516a3e90512d739927fb0f12893502074bad8c1f355c16b9b10d6743402b5aa87aa5fd53efbbd3db9c5dc7fdd4979c8f87dabb4e159419eaf3affe227e7455cf7abd0f5f832f2719696978ba9e4cbc6b2ce4ad56c91548ea4501f0787fb0b941a5c92d680e4e78fa22080e6114c4e0869b6b4643aaf0a41765f6dd8025ac50aea1d23fb8f7abd6a02d65fa8bce75faee32bd0d7c86bd55abbe72189076ce8a411e523dd90fb4a5736f37ad7e33c3d3e74a12c94008845e00ad2f0b93e1e959d45da8f39dcb6ffd093e7f2c914cc6cd76550df0e521f650afaae26182b388251c309930b68811a89f7aca57f1eae6fc32c990e4a82d43d59d08ddf21972c55e0255739a283aad5616efab3f336bd59c6bf7d90d6807b0b42df64684c5778fc13862bc9d466722348a2bbbec17bc3d7fa2be0b98a49438a28a9e07d55eb05b823e97c93d88ceeec4d198b3cbb07dc9aefd31d7307070f1a8a262757550ec8da73daaff93e0336aa00d015bab2e144d3b596f9937a3ae052afef46d59996beebdaed9f95375c674079ed67241bc727c3e76649de53c1d6bbf27b1f64008501d95ad0a379d135ca1ec5eb9f7f105bc379be5f07d6d4b4bd11722c9fa99391670712fb10eab2f9f6a518f8476e76b5939bf2e4bf2686dfdb4f3b62c42a5fce6b1656fd72ce09f5f56bc4a24cd698ce18ce0b29d00206772307d6fdf4d9ded279c5a129c70b258b2df6f578737d95179283e2eeeb2e1df7d8388292a3b0b45ad4407764faac1136ba30a68f971a01e217260dca9ea58a7cc2d2a156be78f1348621ae6ee67d734c65628c7129fa7c6f4277f62e8e7505c5192f24eca517c8104ba3103b01309cc6857ce395feff27d763cb5543b6955dc9fe46e7c396a434474622e3c4cd211fc73ec4a38ca1ace27da6cd2dc71dcd0f8c91fbe2530e1f767e32bf9092a1b08ab2437b9ac6d4a69916592e52a8ccc705aa2023ac70d78727865990d4f1c1424fb02fd0c4608a1620166a17936fa324bc29ef86b26d6c2ea414193942230d8afa3f19b537efc4729bb1982a63a5bbcf324a2b642d8922920772da587fbefdca60772bc8655095868f297237cfdb90ab64eb67ac3e1063595706aa06f56081465fab89ce4d13a3c0d0abb4c95ca9771bc24aaccfa6e36bb3f4e0c1c4452600f9bb45a11217bf5089b7e4e6cccb859cd5facaa3660d0e7378bff36d42656b0a07f6d9d31be75983db500119d0cec5d234f3e143bb6014c3f4b96dc0e290b92484cd6f675b38af7e0fd1274bdf1a9529a15cea50f8d192c4f9b58f6cbf3b636a61dd4fbd58186741c0648bdf4208498999b0d9479c949631687f59472372278a048e74457c309533c8aabd401a36fa9add8e211d4b31ccd57b54b4c1e67d3deec4ffcb6ad0fa4072d872b1aef3d4fadb2e56424699f226ca5681831322dd2a39b0ad67700564e6a520e7c4026356add9828c6bb07ce622b74d68c45e88657d6c2e9882985064c4f27f3a32736b8eccc2ec9bc92ea079947081b35dad9248baf5f088c63df44385909a25d50a350efae7a38c1d9195e3014cc414f24a5ab05a4ad8461b454b22da82c5dd8b2728ef7da307dbc1f305b45782f799699369c9f24420b8712a130592ee1cbc80502aa690208dddf059409a590821a54b791712f6f71d3d7debf4abce280e61d92ed19e5f9185b97afcbb6af26b34c1abb783237a6c9ea774019b7cf4d3a96496085c991dcd7cc27ff510f1ec0e5e0e39fc2bf349699442a5721917e305593567325a0b3b760c06b1b2a692d311c2b039bd1394abdaf3f6dd8b85def6edf30a263f1300bbc1d0198298bb2f986760a530b58f37eabcbe53405b6fc2cd2986bcc30bee488466ecf8f4ff755ca4957af65d9b860807dd8758d7c2dd8b098727d55a042d77dcc69e306db5151df888cb1f50df449a708a5bbad3ec6ca3ba16ed5c7bf1c4b70067fbd9ae77f17b854f7f3379a9101493925fd10b9eb72f26c38a03e48cedb8cf7437666b9ecf889b9579bc00e2de29847bda042fb7dc42839afef6325fa3aa91d2e76c643e7f3cd14329cebf1f14cf162b51fe92520c3576fd137d4f4c9d6d1856c2399efca100c990ac5d6b5932ec37ebafa3a17ec58dec8d23314f6316ae2d285ad606d275fa7a64ad52a6e76ba7dbeff551726ba9e00c9a402ca6d401868db2103f33fe4bf62cfbc16f29780e507035b4f879f56f4dd0a01669ddb89098ff87e0d4a1440b311ae9eeaeb0764439396d7983cea30213442b0c5f52ced807e9bed1aefe7ea6866d9f15a90244e02b0bbef7e6ed6c95378e3cea8485cfaf633e0523575525f559292cabf97bc655b48b484a5b935200b9d2722258ca779e93b34dd06648e607e86cef6d6a666f0e504bdbfabd0bd265885efa21c2a0eee2c6193561d13866ef9f91cff873c7cd059d58a2934b5a53fd3585c643b52fc261019673d0edef47c4fb5ce65339749944799057fd4622b0f8a0fd47eae5202d2b9d47d5679bab22707f663300c6c2d6a9a6e02cd20b75852c7eceb9223b25c9ebfd9910dba3550a5d08eb0dbe98d31fb01bb9ed15b4584d2922e47d88d6db4a63c3f79c938fcedb8edffa2419acde737e0e5325a3a051f891b0ab22d105d122ade7a1156d1ca4815392e6a6811cb1e98f1476a980a918c069fa80db0efd0ca817f4c534d533537b16e96f4a9035e1a6be7ffd7e5df104c448546b50eb49491191ddcfadeb91b27afa3c3774a2b4d5002cbffa69e32bdc255c52fc2fa7687f660393b150e1420559fd57a7b9ad755af611204c27a8586c764781295ae6c47907b766aed06417ca2e47a0d89a793b787be4d164859d127b5f5762a71488a8f1e7f8aaedcfb3962cbd7419d40f3757ff4da878feb4de56241fe7c838612e11369c00631d05947eb231c31a4255a219703daad10bc3feaee7f6e386a5d68538795040ee0fb7b5b01b1951019881caaffeaece02284846fdb861e069dd83e82e6e87c2a10ec61ebe3e6f97dc366e571a5be165603c9e410b41c973133d0010c5334289c877cbdfe3ea45e9f52859729fa7382f86d6ba7e8b5fd09f80c0aaf7e1a2da406a4974b2bf9ebd03372cf14413e28e13b335ba82bac7817038269b1393b451d6e0bbee548180b0ca41b04e6f47ee9606c30be471d74152e6a44947eaaf861a84c2fc0f9e4480fcc819e1c1cb98242165dc978755ce41d380efb33377b79646a57416e1f7a6171b0d01d382252fb30caf2fcbf98842ea1598e71023320dd7e59c3db2c69efdf725b964ca04f9520305afa8bfc6994deaad0db9fb546ca803502579a162ef93058678669599950ef9dcad1a3ff3abdba0e1a7ab2d05c06d08ce318404007ea2d266a26d1574b765a4918b0b081fce10d2f17b41aef846b21393569f911431233466ae0a0adb24bea926062cf0633c0520458558f59d7c50caefe31647334e3ca5cace47c9892bb328209f0545b6cb100397402575e771b16ca2c2b487d0ab040d0ca78786cd1d825f8684b22086f49bfef4d520b441fb2df603665714e0693a6195cd1eb3be32c2d00269113b0a5138bfbd38ed72a29882a0be694a42b39500e36fb0736e18ff7f3c30212baaaf272c1669cb7982c1a2dfd5b24a47658101017e191251ae038436ec6c585538aaee0c8adea3a6f16ee01b403dca3b95875377c9ee53d9f8bc9e8bd6b2b2e7a1bc2a2f780e81d10f1d3e0c11d43408441011a83e87f2b746ce65607fa7f0049746fbe2bd1c645f009701b1968300ad03a63c800e6a23a30616d84589ba201a7af50ae052c96c5a4c41f88dd005865720ff629751ce5fe7a0aa9ddc1c23335c78bca9807663435a24b2b5bf0f4a3ac759d109d9cdcad064eb4162940286654e30fabd2e73f42c3599180aea92c8e8b7eb83f38117c0ee31547d5d811f1ffe473726a2ec28b9d812650ea580d70f4dcf238ae9150141674bec9f0ee80b203e0d3274d4b45a4823472b4d5283736f1115c820a0984103e06976f5960fee4a8162a33d2ebecdcc056084e686917bcada493d0357d6312edbe8861a6bd86be61c1d94b48340378a947ffccfd38f4cbad41c5a40610e1825d28660ebc35654c398cab042bd43cc25cc512f5e1b28f1e060719a55b42086e6709f5d556648aacdbf2300e1ab06ca806c3101a8f1103a72e4e973e86b27fe51c5efccc2f5b1eec84cafb4197f766f978259d9d752984c99135a21381dad7a05728f2965377d0b8cb3cd686903ab3ccd817e7847ad713b21f6a0402daedcfc1b86f31d8dbbab0c25c9f0f4c79d1fbb7f3a7f4305deaf714895fa4dce6ebea58f9b5cbbea7521a269f7e8e78c24b04215f6791842b2d900f316baba6a3ef4111fb3a104a4a58524a245915910cf9c59cf2b1e5f9f427a04e7b6a3285cd2fcaf29c10b3b0af2188be904beac30fd2df36befa349418f56d04f4da625874033a6ba0c04b8be0c17f89b4d7a6918fdbc45f03db4404de0d700122525f60427324d5d6a6a96638e08e4e5185fdef307e4aa6c3f5af39b53ced14e1209b242eb0b9ab0d12a269b2b2e2f020f1da6a8b7aafa2067898e3867d09253576d7815760eccb92c0c165ce75396c7eecf15a907218da96ac69c913e49a94bb3bb6a6cc7a6e035889096be699fbcbf36b5a018448b9e28a1c71c0373df4bf0c6a4a6b1d427ae8d55a0b809a5a6cbe1e1cd1d29420d8b65cf908ed1fb4880fd853975100160e9bc2aae5eceed7fc3bc2a8205d04f49240eb9f96d5a5a0cc1016095ba217ad9d0f8079edbee837810e121056b90207a335d8c6b0cc53dc15a50d8b078a721c39fc25d291836884f8937a12aa15495ccff2e158bc435406693d828792f184fc71a6e58d6391a0ea3cd0a82363e83a780b2b7545bddeaeb94b5049a55abfcd745b35ef2a439908444a0631211a65a19206a628bc6ac6a1b29fdd2fa6762e0d3ea258ef70f484456277ce241cd644732ac163b59470dcecdf90713cbd2f888f32ead4709fe871f0486672a4576a4ca4c563a4be4b8f8e21bb40e55d3aeea27945e3a5f75453cbf0e7755b8550cf5c502a2b93a5bece7ffae96cf6bbcba8c40ed0667a1b70e81bbdaa315ee95e534f4e143e52acb62e2ce3b4f14eeb6847c4f5ac9dff7054549e4c8bf365482bbd6acd9b4703a9ef0448787ef013a416860c635fd476f635e65f76704147f9e9f12b4bfe3259aa6a4783eeec6265087cc631db77e0cc5f3491d2a9860309c31330b0565a6308f627d8f3bccfbbef6cddc000b1147ce90a769e7f94a0250b116b139aa1b41eaa1bec25cabc67d968be517e8ed76d986be84ec4d1b06f4ea901dadf3642238a9d16746b227e98a1458275a8326ace8538358f701219003cb02a1d927f8a5605f6d69f8f9b44836fc97abfb266de4463eb9d42f429074663b20da9d033017527d2770297f7e361c182b060acc20bc4d7822f097c8346ffa34b2c6f5ebe7bb0b5bd40f034e7a073710c7f9ae8fa2a5fdac5b179c87848a0e8d8e03b23039eb0e83949778d85233dfef1d94a7a0d0a8959e0c59dfb9e3556cebc8cd240a33a1666585db67380eadfe05f11aeff43ce35718920b4f9ab6b141ff338816c2c158e090fc5980320571351ed3db633a49774ab4065de3256a11f2bd091935a39fc05966f444eb0d6208e664273eb2e9c3e73cd3313101335ac1cdb35376c4c629da35cd8194260b500c7bbc759b30ad1fe786671ba6306b0774c1bef1427ef697966211fdbb7341ae344140016d5b38f2e0f0fb88740b460e716f45e1555da3320b7696b86fd87e2b59679f0af77ef25fd87d6515e701eb17d914f443dec88d9c949dc0258d31f1a87fc7ca0e00c8d3b9ed311988900e642b41ba0ebe12b2d5ae20872be2dd44bf5c15c5066cd3ec18310beba23b61c99db1bc6ae6449cde9707a4bcac1be66da09f74607f4d977bec322c62e63af27d5bb55792ab7759e7bbd8dac925f20f6fdbcbbe3acde97e99c13bce6be0783cdfb4265b3a28431b9c68d718154fb9f9ac6d11a526e2810ed905d344c71b27b566ba9a7495f522a584bd9ee86ef9565c7d9d9cd164c398bd63d053471c695fb7ffc4298251758da6dd08e09d74d73ca7d329b634ac3183a08a567e2cb8181963f6c5e051779065e3b6e1c89283219b6991eaead827a9182fd717c27085093a15ab3c71933adc31d78ca55188958f891720f0048b59c16887f98e7c2904bc4c295cb6ebc0fe35aace70e0b1de7df64f954855b10332bdef147f263378a73571246008b0f047da47775844053ec09aa41a7bc03edc451b0ade1585e6b6034c70094d093e9db076c3b0f2830cd98f6b14febe08e33c982172a74f38023abc7e97bed516b7363083554ba16866dc6e497078dc5be6b679d90b19c8e696af04f9d0a08ecd698fabeb9a93d68ba0c6343cdf74ff09e218a007a65388b9c2de0b5e4d2907c23bfaa9d6132bae17535f630028922d39adc9d50b4ae6aa2e4c4b6a75243c19fcf9f72becdf109d3b4ff607a41418a0d7e7c8a5aca5fc52cf440f0cbe991a65025e14f4151b8e5e59b997ed9db7b3d8855dfcb5d405038a753115c1f8dc4f6ec30ed99a7d557e59edb51cd88b7e8dcd39556d6fce1a0d1c2e84253846523eb31353724e9bb4de035e1ab98afc26460271d53e16fdcf768d114056b56d15af0afe756e35e631e2556a31cce2a1432bd293f3ed797f610735f711907f8c8ede84c3475ae7d6762b1b4e0d2806dc5ecd5920e907943bd29e9e65551044a82092fc9c4d388912001b52ab873e01493fd8fcccf8d5aee63e70c15c8f654956e958ff1761bc48696257b6259cec721344ba5f33269a15f7e1756584bbc20eeff719fa8df63f658907b26b7b01c62a54a0c01c67ae724f23d6dc209819394c134c75c911a94a28faac98e817d0dbf2132f321098d808e6f0caded7a1e2a60692869d76a556a499b0fd4c7473ab9554ebce26497929b94e4c2490d8e621a80ef0849340d38538e8a03b0f0d92187ede681b1c4386a5ba79bf3396431ca73e264e043ee0cddb21ec55d983b274c03d6c73f1c2487289959fe52900efdd4e58966c4eb886105126633a558834b82a2641b430cb9c084b11cab2b6e5b96190c74f01b6a008717d7bbab04878d4032182cc7c53a3872973813c9173468cc3e5b38aca82c763b118f4c71f828b585e81c644bdc63582f739013be6d2c9ad130ab78e823786ed8e93f68dce608da04b47b8af6c3cac26629101e9791ca1e354c7ccfc1f6f54e66d833a0b5e43604dc66e89b25b63359c77cbe6ed94be5ed269a917348c60e760761369c987c82f37e32a2b630bf2586c9edec59f650586dedee280427f251ffcd8f889ee62e65f5f93d6569629dd13372f577195e86a8b4d4b8af427e14cb79c8aaec77cc75fc2d26a04811af090ca98435af96f39677a4119389d2bbd86498bc59e063079e2560ee34b430764b81d436353b3863f69ae33e7954eb633c531841a81a401e1cc02cb9203b61f0325acab5215c09200e82b523603d972c451f6d91d58b201b7c44b7b0b6a8ecf90a6e8b5e829a893aa26240261cd8edb84c752f51cbafc58434463bd93cd0c9d0b96db3dc3aa7d902e33a04ce6a2a2f1de6f0bbf360b5d9ff0985668d63a3e5c09e89862d30b771e5fe3f4446bb359ef27d7ca57ce2f876e644d075662efc7b68928389667e4d36be0f6a2b283de6750d59d643ec728f957c9569f9ac4ac138beec3ff89636c8749707dab478d8aaaf4892332d4748ac5c30913e3f1b82ee31d503cc5fb7154b3afb4a4b3159ef153611ce381843f1ef147c193dc11d921bea330147c2fd991b50651a90e800491a3f38f2bda1d53943ed5dd6bb1c7107f3347a1ea5980b952d082a3729e93580b15575923b988306b0518958fd7b245de3c9d8adefdeaa482d4479654990f8c3f982a39eb339a342c3e3845650af6f309ec339a7ee3f6d94f4c441faa118c5aa9c880d118130b047f7be8420baf3d2df208071c4687a57088a4bf381e1c4c5a20a2f6cc1cf9490c0530bd93730f2b810794107f1a9a78f2777d6e3fc7102093375d5daf62f04598dc93313451ae6bb6206431f5585703447fd6b5ad780f0a3ba4cf4107884120b43f65383d219b57c000b59ab344879b7ad1630fc21a41880ec21b5cd1a49a79ee3856e75fea4734e901f020ac656f9f96c97ac1fd8576e79d9f3a72964e4b74df6f7b6e67ef24b9d7e5c85e4db2a5c5eec3f234a13edcbe2b18d58716106d67491d30d5487e0764f36d41b23756d8e2db050ad75b3a976b5cf755c3bafdff6b67d45aaa53beacf4149bc0cc7511502849ece9df95af715779d4ed933a6f2bed5e47fd69eae1263fc94a7eef0893f6af1791287228586573e253f1d260b3b0f32a54ea036bd0809d5bfea818351dc7f1d730a7f442b7c655b81e2c2b1a4b3591b15ae65d1d817df6690622522f88ebf220418c271fa7a7465ffeeab7f0f85f7ed3bfaed338c245a38c50ad3ece091b959622481d9416df2ff08cdbd05fa579d5a4d14335999a788a2fb5337ae5595544471e3a3319eabb94538b59383bdcb66d24a87506ca2eadd08321a43759365d2328ac15a7678b99cbf2573b3cd2b884d0e1716ca0676de82d4ed36a5697e1b3180bad0bfd30672d600f11cadebb90252fe4721d980a70b9fccd184648d2919df11c6a675cee6ce30cbe57bd30e34ca401f720768b16f80ada4b7a546fb88d16b64cbe32964704d341e87e5189463efd6fd2386379a296590a1fa2a79215df41c62e9db8e95d245b0fc591e4c9974f00839f8df3448e3cc3b8036f25c8d876c213d0a70dbcbd419e8b54cabf92c0336cc7c89db3fad8ad2043a54c5694ffef1eedb3826a07ccb002e7a415d5ca2b2c4507c9d2a722e7a8ac01e43b3d3d4022438f83bf32b73c8adc41cffb802223f4f1922960ef962e3dbad0adcb3f422a154393eb3265fc97e18076dc3238fb604716e1bce9cec6f6fe471cb5ef02230afd5fd9da8eb7ea1dd99e40479aaf083a3e2e1309222636ea77bf8f80ca761398e6cf722447edbc42c71122dda54629b0f0aba6969a8d21fa57ac7b61d50cc6816d1d682e7b6a26c5e27d3eb15aecd7a1c8f5895d6f484952b543f106e169d9f2ecfd44153531683748454b7cd6f88afdaef0d78de3d4f1f8fbfdea943c44941bc633f8d2209af843771b806e341a0bbfd602ec45121177270f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
